adlist.c list 	abspath.c path 
list len 	path die error 
current 	retval cwd 
next list 	depth last elem 
node list 	last slash 
node list 	next len path 
old node 	path path 
node list 	pfx pfx len 
node 	arg path 
list direction 	stat isdir die 
iter iter 	strbuf reset 
list list 	strbuf addstr directory 
iter current 	find last 
orig copy 	dir sep xstrdup 
iter 	strbuf setlen 
node list 	xmemdupz strbuf reset 
key iter 	strbuf getcwd 
node list 	die errno chdir 
index list 	die errno 
tail zmalloc 	strbuf getcwd 
free 	die errno dir 
zfree zfree 	sep strbuf 
zmalloc zmalloc 	addch strbuf addstr 
zmalloc free 	free lstat 
zfree zmalloc 	islnk strbuf readlink 
zfree list 	die errno 
create 	strbuf swap strbuf 
list iterator 	release free 
list next 	chdir die errno 
dup list 	strbuf release 
release list 	real path real 
release iterator 	path strbuf 
list 	reset strbuf absolute 
node tail 	path absolute 
list release 	path strbuf reset 
list release 	strbuf strbuf 
iterator list 	addstr strbuf reset 
release iterator 	absolute path 
list 	strbuf strbuf 
iterator list 	addstr use inspecting 
next match 	tracked content 
list release 	path symlink directory 
iterator list 	want say 
release iterator 	directory dealing tracked 
list 	content working 
release iterator 	allow recursive symbolic 
list length 	links within 
adlist doubly 	reason though real 
linked list 	path absolute 
implementation copyright 	path symlinks resolved 
salvatore 	extra slashes 
sanfilippo antirez 	removed equivalent specified 
gmail dot 	path want 
rights reserved 	absolute path mind 
redistribution use 	links use 
source binary 	absolute path 
forms 	pointer buffer input 
without modification 	intermediate paths 
permitted provided 	must shorter max 
following conditions 	path directory 
met redistributions 	part path everything 
source code 	last dir 
must 	sep must denote 
retain copyright 	valid existing 
notice list 	directory last component 
conditions following 	need exist 
disclaimer redistributions 	die error die 
binary form 	informative error 
must 	message problem otherwise 
reproduce copyright 	errors without 
notice list 	generating output path 
conditions following 	buffer path 
disclaimer documentation 	already user wants 
materials provided 	temporarily chdir 
distribution 	store original 
neither name 	cwd chdir back 
redis names 	end function 
contributors may 	already done use 
used endorse 	absolute path 
promote products 	relative one want 
derived 	resolve links 
software without 	use real path 
specific prior 	unlike prefix 
written permission 	path used named 
software provided 	file interact 
copyright holders 	index entry name 
contributors 	random file 
express implied 	filesystem prefix absolute 
warranties including 	paths still 
limited implied 	replace add.c builtin 
warranties merchantability 	usage patch 
fitness particular 	interactive interactive edit 
purpose 	interactive take 
disclaimed shall 	worktree changes 
copyright owner 	flags errors data 
contributors liable 	opt cbdata 
direct indirect 	data path prefix 
incidental special 	pathspec flags 
exemplary 	data rev dir 
consequential damages 	pathspec prefix 
including limited 	seen src dst 
procurement substitute 	entry verbose 
goods services 	pathspec seen revision 
loss use 	patch mode 
data 	pathspec status argv 
profits business 	argc argv 
interruption however 	prefix patch pathspec 
caused theory 	argc argv 
liability whether 	prefix file apply 
contract strict 	argv child 
liability 	rev file ignore 
tort including 	error verbose 
negligence otherwise 	show ignored 
arising way 	refresh ignore errors 
use software 	intent ignore 
even advised 	missing addremove addremove 
possibility 	opt arg 
damage create 	unset builtin options 
list created 	dir flags 
list freed 	exit status argc 
free list 	argv prefix 
every node 	exit status pathspec 
need 	dir flags 
freed user 	files require pathspec 
call free 	seen baselen 
list error 	path dtype fix 
returned otherwise 	unmerged status 
pointer list 	die file index 
free 	die file 
whole list 	index memset 
function fail 	init revisions setup 
node list 	revisions copy 
head containing 	pathspec run diff 
specified pointer 	files xcalloc 
error 	dir path match 
returned operation 	pathspec matches 
performed list 	index xcalloc refresh 
remains unaltered 	index die 
success list 	free argv push 
pointer pass 	argv push 
function 	argv push argv 
returned node 	push argv 
list tail 	push run command 
containing specified 	opt argv 
pointer error 	clear parse pathspec 
returned operation 	run interactive 
performed 	git pathdup git 
list remains 	config read 
unaltered success 	cache die 
list pointer 	init revisions setup 
pass function 	revisions diff 
returned specified 	opt open die 
node 	xfdopen run 
specified list 	diff files die 
caller free 	launch editor 
node function 	die stat die 
fail returns 	errno die 
list iterator 	run command die 
iter 	unlink free 
initialization every 	strcmp strcmp git 
call list 	config git 
next next 	config file cache 
element list 	die git 
function fail 	config parse options 
release 	exit interactive 
iterator memory 	edit patch die 
create iterator 	die hold 
list iterator 	locked index 
structure next 	read cache die 
element iterator 	parse pathspec 
valid 	memset setup standard 
currently returned 	excludes fill 
element list 	directory prune directory 
del node 	refresh find 
elements function 	pathspecs matching index 
returns pointer 	guard pathspec 
next 	file exists excluded 
element list 	dir ignored 
elements classical 	die free plug 
usage patter 	bulk checkin 
iter list 	files cache files 
iterator list 	unplug bulk 
direction 	checkin write locked 
node list 	index die 
next iter 	git builtin command 
something list 	copyright linus 
node node 	torvalds request 
duplicate whole 	path missing working 
list 	deleted either 
memory returned 	request path exists 
success copy 	working attempt 
original list 	explicitly path exist 
returned dup 	working caught 
method list 	error caller immediately 
dup 	compare unmerged 
method function 	paths stage pass 
used copy 	original pathspec 
node otherwise 	parsed diff options 
pointer original 	unspecified told 
node used 	ignore adding removals 
copied 	takes arguments 
node original 	given turn git 
list success 	pathspec git 
error never 	pathspec check 
modified search 	pathspec match files 
list node 	block enabling 
matching 	magic git porcelain 
given key 	excludes picks 
match performed 	paths tracked file 
match method 	exists assumes 
list match 	exact match advice.c 
method match 	advice push 
method 	update rejected advice 
pointer every 	push non 
node directly 	current advice push 
compared key 	non matching 
pointer success 	advice push already 
first matching 	exists advice 
node 	push fetch first 
pointer returned 	advice push 
search starts 	needs force advice 
head matching 	status hints 
node exists 	advice status 
returned element 	option advice commit 
specified 	merge advice 
zero index 	resolve conflict advice 
head element 	identity advice 
next head 	detached head advice 
negative integers 	upstream failure 
used order 	advice name warning 
count 	advice hints 
tail last 	name preference advice 
element penultimate 	buf name 
index range 	fmt start strbuf 
returned rotate 	vaddf end 
list removing 	strchrnul strbuf release 
tail 	skip prefix 
node inserting 	size strcmp git 
head detach 	config error 
current tail 	advise error resolve 
move head 	conflict die 
adlist.h list 	error advise 
list 	die make backward 
list list 	compatibility message 
old node 	used git commit 
list node 	fails commands 
list direction 	merge advice.h advice 
iter iter 	push update 
orig 	rejected advice push 
list key 	non current 
list index 	advice push non 
list list 	matching advice 
list adlist 	push already exists 
doubly linked 	advice push 
list 	fetch first advice 
implementation copyright 	push needs 
salvatore sanfilippo 	force advice status 
antirez gmail 	hints advice 
dot rights 	status option advice 
reserved redistribution 	commit merge 
use 	advice resolve 
source binary 	conflict advice identity 
forms without 	advice detached 
modification permitted 	head advice upstream 
provided following 	failure advice 
conditions met 	name warning advice 
redistributions 	hints advice 
source code 	name advice alias.c 
must retain 	key split 
copyright notice 	cmdline errors cmdline 
list conditions 	argv src 
following disclaimer 	dst size quoted 
redistributions 	split cmdline 
binary form 	errno strbuf addf 
must reproduce 	git config 
copyright notice 	key valid git 
list conditions 	config strbuf 
following disclaimer 	release alloc isspace 
documentation 	isspace alloc 
materials provided 	grow free 
distribution neither 	free alloc grow 
name redis 	split skip 
names contributors 	alloc.c blob commit 
may used 	tag count 
endorse 	node size ret 
promote products 	blob state 
derived software 	state tag state 
without specific 	state obj 
prior written 	commit state count 
permission software 	name count 
provided 	size xmalloc memset 
copyright holders 	alloc node 
contributors express 	alloc node alloc 
implied warranties 	node alloc 
including limited 	node alloc node 
implied warranties 	alloc commit 
merchantability 	index report 
fitness particular 	report report report 
purpose disclaimed 	report alloc 
shall copyright 	specialized allocator objects 
owner contributors 	copyright linus 
liable direct 	torvalds standard malloc 
indirect 	free wastes 
incidental special 	much space objects 
exemplary consequential 	partly maintains 
damages including 	allocation infrastructure isn 
limited procurement 	needed since 
substitute goods 	never free descriptor 
services 	anyway even 
loss use 	ends maximal alignment 
data profits 	doesn know 
business interruption 	alignment allocation total 
however caused 	number nodes 
theory liability 	allocated number nodes 
whether 	left current 
contract strict 	allocation first 
liability tort 	free node current 
including negligence 	allocation alloca.h 
otherwise arising 	am.c filename msg 
way use 	str dir 
software 	cur last author 
even advised 	name author 
possibility damage 	email author date 
node list 	msg msg 
iterator data 	len orig commit 
structures used 	prec interactive 
currently 	threeway quiet signoff 
functions implemented 	utf keep 
macros prototypes 	message scissors git 
directions iterators 	apply opts 
adlist ae.c 	resolvemsg committer date 
setsize loop 	author date 
loop 	ignore date allow 
loop setsize 	rerere autoupdate 
loop loop 	sign commit 
loop mask 	rebasing state dir 
proc client 	gpgsign state 
data loop 	state path state 
mask 	name state 
loop seconds 	name state name 
milliseconds milliseconds 	state fmt 
sec cur 	state state file 
sec cur 	trim key 
sec loop 	str state filename 
milliseconds 	state state 
proc client 	state filename state 
data finalizer 	state state 
proc loop 	ret state hook 
prev loop 	ret state 
nearest loop 	invalid line msg 
processed 	ret obj 
max sec 	obj header regex 
retval loop 	regex ret 
flags numevents 	paths state 
shortest tvp 	paths keep last 
sec mask 	state paths 
rfired 	keep stdin mail 
mask milliseconds 	ret keep 
pfd retval 	subject printed str 
loop loop 	state paths 
beforesleep zmalloc 	keep series dir 
zmalloc zmalloc 	series dir 
time 	buf patches ret 
api create 	keep str 
zfree zfree 	timestamp end split 
zfree api 	mail setup 
resize zrealloc 	state head state 
zrealloc api 	file head 
free 	opt state cmdline 
zfree zfree 	mine state 
zfree api 	state mail 
api del 	msg author name 
gettimeofday time 	author date 
zmalloc milliseconds 	author email ret 
finalizer 	commit mail 
proc zfree 	state commit buffer 
time time 	ident line 
time proc 	author date msg 
milliseconds time 	ident len 
search nearest 	ident split state 
timer 	commit rev 
time api 	info state head 
poll rfile 	rev info 
proc wfile 	state mail commit 
proc process 	commit sha 
time events 	state index file 
memset 	state index 
poll beforesleep 	file state orig 
process events 	status state 
api name 	index path 
simple driven 	orig rev info 
programming library 	diff filter 
originally 	str state parent 
wrote code 	commit ptr 
jim loop 	parents reflog msg 
jim tcl 	author state 
interpreter later 	state reply msg 
translated form 	pager state 
library 	resume argv mail 
easy reuse 	apply status 
copyright salvatore 	skip advice amworkdir 
sanfilippo antirez 	state head 
gmail dot 	remote reset file 
rights reserved 	opts file 
redistribution 	opts head remote 
use source 	head remote 
binary forms 	index index merge 
without modification 	state head 
permitted provided 	state abort 
following conditions 	safety head state 
met 	curr head 
redistributions source 	orig head curr 
code must 	head orig 
retain copyright 	head curr branch 
notice list 	opt arg 
conditions following 	unset opt status 
disclaimer 	argc argv 
redistributions binary 	prefix state binary 
form must 	keep patch 
reproduce copyright 	format progress usage 
notice list 	options paths 
conditions following 	stat die errno 
disclaimer 	strchrnul isspace 
documentation materials 	memset xstrdup git 
provided distribution 	config git 
neither name 	config argv init 
redis names 	git config 
contributors may 	free free 
used 	free free free 
endorse promote 	argv clear 
products derived 	mkpath write file 
software without 	path write 
specific prior 	file path write 
written permission 	state text 
software 	start vfprintf putc 
provided copyright 	end lstat 
holders contributors 	isdir lstat path 
express implied 	isreg lstat 
warranties including 	path isreg strbuf 
limited 	reset strbuf 
implied warranties 	read file path 
merchantability fitness 	strbuf trim 
particular purpose 	die errno path 
disclaimed shall 	strbuf getline 
copyright owner 	skip prefix 
contributors 	skip prefix strbuf 
liable direct 	dequote strbuf 
indirect incidental 	detach strbuf release 
special exemplary 	path fopen 
consequential damages 	die errno read 
including limited 	shell fclose 
procurement 	read shell fclose 
substitute goods 	read shell 
services loss 	fclose fgetc fclose 
use data 	fclose strbuf 
profits business 	addstr quote buf 
interruption however 	strbuf addch 
caused 	strbuf addstr quote 
theory liability 	buf strbuf 
whether contract 	addch strbuf addstr 
strict liability 	quote buf 
tort including 	strbuf addch write 
negligence otherwise 	state text 
arising 	strbuf release 
way use 	read state file 
software even 	strbuf release 
advised possibility 	strbuf detach path 
damage include 	xopen write 
best multiplexing 	full die errno 
layer 	close read 
supported system 	state file die 
following ordered 	strtol read 
performances events 	state file die 
mask none 	strtol read 
initialize vector 	author script die 
current 	read commit 
size resize 	msg read state 
maximum size 	file hashclr 
loop requested 	sha hex die 
size smaller 	path read 
current size 	state file strcmp 
already 	read state 
file descriptor 	file strcmp 
use requested 	read state file 
size minus 	strcmp read 
one err 	state file strcmp 
returned operation 	read state 
performed 	file strcmp strcmp 
otherwise returned 	read state 
operation successful 	file strcmp read 
make sure 	state file 
created slots 	strcmp strcmp read 
initialized none 	state file 
mask 	argv clear dequote 
update max 	argv die 
specified found 	path file exists 
search first 	path strbuf 
timer fire 	release strbuf addstr 
operation useful 	dir recursively 
know 	strbuf release run 
many time 	hook path 
put sleep 	free read 
without delay 	commit msg die 
timers returned 	path find 
note since 	hook argv push 
time 	argv push 
events unsorted 	xopen path run 
possible optimizations 	command close 
needed redis 	init copy notes 
far insert 	rewrite xfopen 
order nearest 	path strbuf getline 
head 	error sha 
much better 	hex error error 
still insertion 	sha hex 
deletion timers 	error copy note 
use skiplist 	rewrite error 
operation insertion 	sha hex sha 
log 	hex finish 
process time 	copy notes rewrite 
events system 	fclose strbuf 
clock moved 	release fseek 
future back 	die errno regcomp 
right time 	die strbuf 
events 	getline regexec regfree 
may delayed 	strbuf release 
random way 	strcmp directory xfopen 
often means 	strbuf getline 
scheduled operations 	starts starts starts 
performed soon 	strcmp strbuf 
enough 	reset strbuf getline 
detect system 	strbuf reset 
clock skews 	strbuf getline starts 
force time 	starts starts 
events processed 	mail fclose strbuf 
asap happens 	release argv 
idea 	push argv pushf 
processing events 	argv pushf 
earlier less 	argv push 
dangerous delaying 	argv push argv 
indefinitely practice 	push argv 
suggests processed 	pushv capture command 
time 	strtol strcmp 
list may 	fopen error strerror 
longer restart 	mkpath fopen 
head still 	error strerror fclose 
make sure 	fclose error 
process events 	strbuf getline str 
registered 	isspace skip 
handlers order 	prefix starts starts 
loop forever 	strbuf reset 
saved max 	strbuf fread fwrite 
want handle 	strbuf reset 
future optimizations 	strbuf release error 
note 	xstrdup dirname 
great algorithmically 	fopen error strerror 
redis uses 	strbuf getline 
single time 	argv push 
problem right 	mkpath fclose strbuf 
way elements 	release free 
head 	split mail conv 
flag deleted 	argv clear 
elements special 	strbuf getline skip 
way later 	prefix skip 
deletion putting 	prefix strtoul error 
references nodes 	skip prefix 
another 	error strtol error 
linked list 	error labs 
process every 	labs show date 
pending time 	date mode 
every pending 	starts strbuf reset 
file may 	strbuf fread 
registered 	fwrite strbuf reset 
time callbacks 	strbuf release 
processed without 	free free free 
special flags 	free unlink 
function sleeps 	path unlink 
file fires 	path hashclr unlink 
next 	path sha 
time occurs 	write state text 
flags function 	sha hex 
nothing returns 	write state text 
flags events 	write state 
kind events 	count strbuf reset 
processed 	strbuf addf 
flags file 	xcalloc hold locked 
events file 	index refresh 
events processed 	cache write locked 
flags time 	index die 
events time 	sha diff setup 
events 	diff opt 
processed flags 	diff opt diff 
dont wait 	cache diffcore 
function returns 	std strbuf addch 
asap events 	strbuf addstr 
possible process 	diff flush 
without 	diff opt tst 
wait processed 	strbuf addch 
function returns 	strbuf addstr exit 
number events 	strbuf addf 
processed nothing 	fmt name getenv 
asap note 	getenv strcmp 
want 	strstr strchr strbuf 
call even 	addstr strbuf 
file events 	release strbuf attach 
process want 	signoff strbuf 
process time 	detach setup mailinfo 
events order 	commit output 
sleep 	encoding die die 
next time 	fopen die 
ready fire 	fopen path die 
calculate time 	mailinfo path 
missing nearest 	path die 
timer fire 	fclose fclose xfopen 
check 	path strbuf 
events need 	getline skip prefix 
asap dont 	strbuf addch 
wait need 	strbuf addstr skip 
timeout zero 	prefix strbuf 
otherwise block 	addstr skip prefix 
wait 	strbuf addstr 
forever note 	skip prefix strbuf 
mask mask 	addstr fclose 
code maybe 	strcmp empty file 
already processed 	path die 
removed element 	user resolve strbuf 
fired 	addstr strbuf 
still didn 	addbuf strbuf stripspace 
processed check 	signoff strbuf 
still valid 	detach strbuf detach 
check time 	strbuf detach 
events number 	strbuf detach 
processed 	strbuf release strbuf 
file time 	release strbuf 
events wait 	release strbuf release 
milliseconds given 	strbuf release 
file descriptor 	clear mailinfo xfopen 
becomes writable 	strbuf getline 
readable 	skip prefix sha 
ae.h privdata 	hex strbuf 
mask privdata 	release fclose logmsg 
mask privdata 	reencode commit 
loop privdata 	output encoding find 
loop privdata 	commit header 
loop 	split ident line 
privdata loop 	strbuf die 
privdata loop 	strbuf strbuf detach 
redis handle 	xstrdup strbuf 
read redis 	strbuf detach xstrdup 
handle write 	show ident 
create 	date date 
file file 	mode strbuf addstr 
create file 	strbuf detach 
file redis 	strstr die oid 
del read 	hex xstrdup 
redis del 	strlen xfopen path 
write 	init revisions 
free malloc 	diff opt diff 
copyright pieter 	opt pending 
noordhuis pcnoordhuis 	diff setup done 
gmail dot 	log commit 
rights reserved 	sha lookup lookup 
redistribution 	xfopen path 
use source 	init revisions pending 
binary forms 	diff setup 
without modification 	done run diff 
permitted provided 	index mail 
following conditions 	commit sha die 
met 	lookup commit 
redistributions source 	die commit 
code must 	info write commit 
retain copyright 	patch hashcpy 
notice list 	write state text 
conditions following 	sha hex 
disclaimer 	argv pushf argv 
redistributions binary 	push argv 
form must 	pushv argv push 
reproduce copyright 	argv push 
notice list 	argv push path 
conditions following 	run command 
disclaimer 	discard cache read 
documentation materials 	cache index 
provided distribution 	file argv push 
neither name 	argv pushv 
redis names 	argv pushf argv 
contributors may 	push path 
used 	run command 
endorse promote 	argv pushf sha 
products derived 	hex linelen 
software without 	argv push argv 
specific prior 	push argv 
written permission 	push sha hex 
software 	argv push 
provided copyright 	argv push sha 
holders contributors 	hex argv 
express implied 	push sha hex 
warranties including 	run command 
limited implied 	discard cache read 
warranties 	cache sha 
merchantability fitness 	hashcpy build fake 
particular purpose 	ancestor error 
disclaimed shall 	discard cache read 
copyright owner 	cache write 
contributors liable 	index error say 
direct 	init revisions 
indirect incidental 	diff opt 
special exemplary 	parse pending sha 
consequential damages 	diff setup 
including limited 	done run diff 
procurement substitute 	index run 
goods 	apply error write 
services loss 	index error 
use data 	say discard cache 
profits business 	read cache 
interruption however 	run fallback merge 
caused theory 	recursive rerere 
liability 	error run hook 
whether contract 	exit write 
strict liability 	cache die sha 
tort including 	commit commit 
negligence otherwise 	list insert lookup 
arising way 	commit say 
use 	fmt ident setenv 
software even 	commit die 
advised possibility 	getenv strbuf 
damage nothing 	addf linelen update 
attached something 	xfopen path 
already attached 	sha sha hex 
create 	sha hex 
container context 	fclose run hook 
events functions 	strbuf release 
start stop 	die path die 
listening events 	path isatty 
simple driven 	die puts puts 
programming 	puts git 
library originally 	prompt launch editor 
wrote code 	path free 
jim loop 	strbuf detach strbuf 
jim tcl 	release git 
interpreter later 	pager prepare pager 
translated 	args argv 
form library 	push path run 
easy reuse 	command unlink 
copyright salvatore 	path refresh 
sanfilippo antirez 	write cache index 
gmail dot 	changes write 
rights 	state die strbuf 
reserved redistribution 	release path 
use source 	msgnum file exists 
binary forms 	validate resume 
without modification 	state parse mail 
permitted provided 	rebase parse 
following 	mail write author 
conditions met 	script write 
redistributions source 	commit msg interactive 
code must 	run applypatch 
retain copyright 	msg hook exit 
notice list 	say linelen 
conditions 	run apply strbuf 
following disclaimer 	addstr path 
redistributions binary 	fall back threeway 
form must 	strbuf release 
reproduce copyright 	index changes 
notice list 	say msgnum linelen 
conditions 	git config 
following disclaimer 	path die user 
documentation materials 	resolve commit 
provided distribution 	next load empty 
neither name 	file path 
redis names 	copy notes rebase 
contributors 	run post 
may used 	rewrite hook destroy 
endorse promote 	close packs 
products derived 	run command opt 
software without 	validate resume 
specific prior 	state say linelen 
written 	index changes 
permission software 	die user resolve 
provided copyright 	unmerged cache 
holders contributors 	die user 
express implied 	resolve write index 
warranties including 	patch interactive 
limited 	rerere commit next 
implied warranties 	load run 
merchantability fitness 	parse parse xcalloc 
particular purpose 	hold locked 
disclaimed shall 	index refresh cache 
copyright owner 	memset init 
contributors 	desc init desc 
liable direct 	unpack trees 
indirect incidental 	rollback file write 
special exemplary 	locked index 
consequential damages 	die parse xcalloc 
including limited 	hold locked 
procurement 	index memset init 
substitute goods 	desc unpack 
services loss 	trees rollback file 
use data 	write locked 
profits business 	index die 
interruption however 	parse indirect error 
caused 	sha hex 
theory liability 	parse indirect error 
whether contract 	sha hex 
strict liability 	read cache unmerged 
tort including 	fast forward 
negligence otherwise 	write cache parse 
arising 	indirect error 
way use 	sha hex fast 
software even 	forward merge 
advised possibility 	branch state rerere 
damage macros 	clear list 
types data 	clear rerere clear 
structures 	sha hashcpy 
file structure 	clean index die 
one readable 	next load 
writable time 	run file exists 
structure time 	path read 
seconds milliseconds 	state file 
fired 	sha hex die 
state program 	path hashclr 
highest file 	sha hashclr hashcmp 
descriptor currently 	error safe 
registered max 	abort destroy rerere 
number file 	clear resolve 
descriptors 	refdup sha hashcpy 
tracked used 	sha hashcpy 
detect system 	clean index update 
clock skew 	free destroy 
registered events 	strcmp strcmp strcmp 
fired events 	strcmp error 
used 	git gpg config 
polling api 	git config 
specific data 	git config state 
prototypes setsize 	init git 
loop loop 	path progress load 
loop mask 	parse options 
proc 	git committer 
client data 	info read index 
loop mask 	preload die 
loop loop 	isatty die append 
milliseconds proc 	signoff file 
client data 	exists destroy state 
finalizer 	release die 
proc loop 	die absolute path 
loop flags 	argv push 
mask milliseconds 	argv push mkpath 
loop loop 	setup argv 
beforesleep loop 	clear run run 
loop 	resolve skip 
setsize copyright 	abort die state 
pieter noordhuis 	release builtin 
pcnoordhuis gmail 	git git junio 
dot rights 	hamano returns 
reserved redistribution 	file empty 
use 	exist otherwise returns 
source binary 	length first 
forms without 	line msg returns 
modification permitted 	str consists 
provided following 	whitespace otherwise pass 
conditions met 	flag git 
redistributions 	mailinfo pass flag 
source code 	git mailinfo 
must retain 	pass scissors git 
copyright notice 	mailinfo pass 
list conditions 	scissors git mailinfo 
following disclaimer 	signoff command 
redistributions 	line state directory 
binary form 	path current 
must reproduce 	last patch numbers 
copyright notice 	indexed commit 
list conditions 	metadata message rebasing 
following 	records original 
disclaimer documentation 	commit patch 
materials provided 	came number digits 
distribution neither 	patch filename 
name redis 	various operating modes 
names contributors 	command line 
may 	options signoff type 
used endorse 	keep type 
promote products 	scissors type initializes 
derived software 	state values 
without specific 	state directory dir 
prior written 	releases memory 
permission 	allocated state returns 
software provided 	path relative 
copyright holders 	state directory convenience 
contributors express 	call write 
implied warranties 	file state quiet 
including limited 	calls fmt 
implied 	appends newline end 
warranties merchantability 	returns session 
fitness particular 	progress otherwise 
purpose disclaimed 	reads contents file 
shall copyright 	state directory 
owner contributors 	returns number bytes 
liable 	read success 
direct indirect 	file exist trim 
incidental special 	trailing whitespace 
exemplary consequential 	removed reads key 
damages including 	shell variable 
limited procurement 	assignment returning newly 
substitute 	allocated must 
goods services 	quoted key must 
loss use 	match key 
data profits 	returns failure used 
business interruption 	read author 
however caused 	script read git 
theory 	author variables 
liability whether 	author script reads 
contract strict 	parses state 
liability tort 	directory author 
including negligence 	script file sets 
otherwise arising 	state author 
way 	name state author 
use software 	email state 
even advised 	author date accordingly 
possibility damage 	returns success 
nothing attached 	file could parsed 
something already 	author script 
attached 	format git author 
create container 	name author 
context events 	name git author 
functions start 	email author 
stop listening 	email git author 
events simple 	date author 
driven 	date author name 
programming library 	author email 
originally wrote 	author date 
code jim 	quoted strict parsing 
loop jim 	file meant 
tcl interpreter 	eval old git 
later 	script thus 
translated form 	file differs function 
library easy 	expects better 
reuse copyright 	bail something user 
salvatore sanfilippo 	expect saves 
antirez gmail 	state author name 
dot 	state author 
rights reserved 	email state author 
redistribution use 	date state 
source binary 	directory author script 
forms without 	file reads 
modification permitted 	commit message state 
provided 	directory commit 
following conditions 	file setting state 
met redistributions 	msg contents 
source code 	state msg 
must retain 	len length contents 
copyright notice 	bytes returns 
list 	success file exist 
conditions following 	saves state 
disclaimer redistributions 	msg state directory 
binary form 	commit file 
must reproduce 	loads state disk 
copyright notice 	removes state 
list 	directory forcefully terminating 
conditions following 	current session 
disclaimer documentation 	runs applypatch msg 
materials provided 	hook returns 
distribution neither 	exit code runs 
name redis 	post rewrite 
names 	hook returns exit 
contributors may 	code reads 
used endorse 	state directory rewritten 
promote products 	file copies 
derived software 	notes old 
without specific 	commits listed file 
prior 	rewritten commits 
written permission 	returns success failure 
software provided 	determines file 
copyright holders 	looks like piece 
contributors express 	rfc mail 
implied warranties 	grabbing non indented 
including 	lines checking 
limited implied 	look like begin 
warranties merchantability 	valid header 
fitness particular 	field names returns 
purpose disclaimed 	file looks 
shall copyright 	like piece mail 
owner 	otherwise end 
contributors liable 	header ignore indented 
direct indirect 	folded lines 
incidental special 	header matches header 
exemplary consequential 	regex attempts 
damages including 	detect patch 
limited 	format patches contained 
procurement substitute 	paths returning 
goods services 	patch format returns 
loss use 	patch format 
data profits 	unknown detection fails 
business interruption 	mbox format 
however 	input stdin directories 
caused theory 	otherwise check 
liability whether 	first lines first 
contract strict 	patch starting 
liability tort 	first non blank 
including negligence 	line detect 
otherwise 	format second line 
arising way 	empty third 
use software 	author date entry 
even advised 	likely git 
possibility damage 	patch splits individual 
macros types 	email patches 
data 	paths path 
structures file 	either mbox file 
structure one 	maildir returns 
readable writable 	success failure callback 
time structure 	signature split 
time seconds 	mail conv foreign 
milliseconds 	patch read 
fired state 	converted patch rfc 
program highest 	mail format 
file descriptor 	written success failure 
currently registered 	calls file 
max number 	paths convert foreign 
file 	patch rfc 
descriptors tracked 	mail format suitable 
used detect 	parsing git 
system clock 	mailinfo returns success 
skew registered 	failure split 
events fired 	mail conv 
events 	callback converts git 
used polling 	patch rfc 
api specific 	message suitable parsing 
data prototypes 	git mailinfo 
ae.h privdata 	function supports single 
mask privdata 	git series 
mask 	file paths given 
privdata loop 	git series 
privdata loop 	file converts git 
privdata loop 	patches series 
privdata loop 	rfc messages suitable 
privdata loop 	parsing git 
redis 	mailinfo queues state 
handle read 	directory returns 
redis handle 	success failure skip 
write create 	comment lines 
file file 	split patches conv 
create file 	callback converts 
file 	mercurial patch 
redis del 	rfc message suitable 
read redis 	parsing git 
del write 	mailinfo mercurial timezone 
free malloc 	seconds west 
copyright pieter 	utc however git 
noordhuis 	timezone hours 
pcnoordhuis gmail 	minutes east utc 
dot rights 	convert splits 
reserved redistribution 	list files directories 
use source 	individual email 
binary forms 	patches path paths 
without 	must file 
modification permitted 	directory formatted according 
provided following 	patch format 
conditions met 	split individual email 
redistributions source 	patches stored 
code must 	state directory patch 
retain 	filename index 
copyright notice 	padded state 
list conditions 	prec digits state 
following disclaimer 	cur index 
redistributions binary 	first mail state 
form must 	last index 
reproduce 	last mail keep 
copyright notice 	convert lines 
list conditions 	ending end disable 
following disclaimer 	behavior use 
documentation materials 	configured setting returns 
provided distribution 	success failure 
neither 	setup session applying 
name redis 	patches note 
names contributors 	since next last 
may used 	files determine 
endorse promote 	state session progress 
products derived 	written last 
software 	increments patch pointer 
without specific 	cleans state 
prior written 	application next 
permission software 	patch returns filename 
provided copyright 	current patch 
holders contributors 	email refresh write 
express 	index returns 
implied warranties 	index differs head 
including limited 	otherwise unborn 
implied warranties 	branch returns entries 
merchantability fitness 	index otherwise 
particular purpose 	strbuf provided space 
disclaimed 	separated list 
shall copyright 	files differ appended 
owner contributors 	dies user 
liable direct 	friendly message proceed 
indirect incidental 	resolving problem 
special exemplary 	message overridden state 
consequential 	resolvemsg end 
damages including 	sign need 
limited procurement 	duplicate text appends 
substitute goods 	signoff msg 
services loss 	field state parses 
use data 	mail git 
profits 	mailinfo extracting patch 
business interruption 	authorship info 
however caused 	state msg patch 
theory liability 	message state 
whether contract 	author name state 
strict liability 	author email 
tort 	state author date 
including negligence 	patch author 
otherwise arising 	name email date 
way use 	respectively patch 
software even 	body written state 
advised possibility 	directory patch 
damage 	file returns patch 
nothing attached 	skipped otherwise 
something already 	extract message 
attached create 	author information skip 
container context 	pine folder 
events functions 	data sets commit 
start 	commit hash 
stop listening 	mail generated returns 
events simple 	success failure 
driven programming 	sets state msg 
library originally 	state author 
wrote code 	name state author 
jim 	email state 
loop jim 	author date commit 
tcl interpreter 	respective info 
later translated 	writes commit patch 
form library 	state directory 
easy reuse 	patch file writes 
copyright 	diff index 
salvatore sanfilippo 	head patch state 
antirez gmail 	directory patch 
dot rights 	file like 
reserved redistribution 	parse mail parses 
use source 	mail looking 
binary 	commit directly used 
forms without 	rebasing mode 
modification permitted 	bypass git mailinfo 
provided following 	munging patches 
conditions met 	state orig commit 
redistributions source 	original commit 
code 	always patch never 
must retain 	skipped applies 
copyright notice 	current patch git 
list conditions 	apply returns 
following disclaimer 	success otherwise index 
redistributions binary 	file patch 
form 	applied index allowed 
must reproduce 	fall back 
copyright notice 	way merge give 
list conditions 	errors initial 
following disclaimer 	attempt reload 
documentation materials 	index git apply 
provided 	modified builds 
distribution neither 	index contains blobs 
name redis 	needed way 
names contributors 	merge three way 
may used 	merge fake 
endorse promote 	ancestor constructed fake 
products 	ancestor postimage 
derived software 	patch state attempt 
without specific 	threeway merge 
prior written 	index path temporary 
permission software 	index list 
provided copyright 	paths needed way 
holders 	fallback user 
contributors express 	review extra care 
implied warranties 	spot mismerges 
including limited 	wrong depending 
implied warranties 	picked orig may 
merchantability fitness 	wildly different 
particular 	wildly different changes 
purpose disclaimed 	parts patch 
shall copyright 	touch recursive ends 
owner contributors 	canceling saying 
liable direct 	reverted changes commits 
indirect incidental 	current index 
special 	state msg commit 
exemplary consequential 	message state 
damages including 	author name state 
limited procurement 	author email 
substitute goods 	state author date 
services loss 	author information 
use 	validates state resuming 
data profits 	msg authorship 
business interruption 	fields must filled 
however caused 	interactively prompt 
theory liability 	user whether 
whether contract 	current patch applied 
strict 	returns user 
liability tort 	chooses apply patch 
including negligence 	user chooses 
otherwise arising 	skip translators make 
way use 	sure include 
software even 	translation program accept 
advised 	english input 
possibility damage 	point applies queued 
macros types 	mail resume 
data structures 	resuming msg authorship 
file structure 	fields well 
one readable 	state directory patch 
writable 	file used 
time structure 	applying patch committing 
time seconds 	mail skipped 
milliseconds fired 	applying patch earlier 
state program 	merging result 
highest file 	may produced 
descriptor 	rebasing mode caller 
currently registered 	take care 
max number 	housekeeping resume current 
file descriptors 	session patch 
tracked used 	application failure user 
detect system 	hard work 
clock 	patch application trust 
skew registered 	commit user 
events fired 	index working performs 
events used 	checkout fast 
polling api 	forward head remote 
specific data 	reset unmerged 
prototypes 	entries discarded returns 
setsize loop 	success failure 
loop loop 	merges index index 
mask proc 	stat info 
client data 	take precedence merged 
loop mask 	returns success 
loop 	failure clean 
loop milliseconds 	index without touching 
proc client 	entries modified 
data finalizer 	head remote resets 
proc loop 	rerere merge 
loop flags 	resolution metadata resume 
mask 	current session 
milliseconds loop 	skipping current patch 
loop beforesleep 	returns safe 
loop loop 	reset head orig 
setsize copyright 	head otherwise 
pieter noordhuis 	safe reset head 
pcnoordhuis 	git previously 
gmail dot 	failed index dirty 
rights reserved 	head moved 
redistribution use 	since git previously 
source binary 	failed aborts 
forms without 	current session safe 
modification 	parse options 
permitted provided 	callback validates 
following conditions 	sets opt patch 
met redistributions 	format corresponding 
source code 	arg ensure valid 
must retain 	committer ident 
copyright 	constructed user error 
notice list 	feed patches 
conditions following 	session progress mbox 
disclaimer redistributions 	path provided 
binary form 	command line stdin 
must reproduce 	tty user 
copyright 	trying feed patch 
notice list 	standard input 
conditions following 	somewhat unreliable stdin 
disclaimer documentation 	could dev 
materials provided 	example caller intend 
distribution neither 	feed patch 
name 	wanted unattended 
redis names 	handle stray state 
contributors may 	directory independent 
used endorse 	run rebasing caller 
promote products 	take care 
derived software 	stray directories annotate.c 
without 	argc argv 
specific prior 	prefix args argv 
written permission 	pushl argv 
software provided 	push cmd blame 
copyright holders 	git annotate 
contributors express 	builtin copyright ryan 
implied 	anderson apple-common-crypto.h 
warranties including 	inlen err encoder 
limited implied 	input output 
warranties merchantability 	length inlen err 
fitness particular 	decoder input 
purpose disclaimed 	output length sec 
shall 	encode transform 
copyright owner 	create git 
contributors liable 	error check data 
direct indirect 	create sec 
incidental special 	transform attribute git 
exemplary consequential 	error check 
damages 	sec transform execute 
including limited 	git error 
procurement substitute 	check data length 
goods services 	data bytes 
loss use 	range make release 
data profits 	release release 
business 	strlen sec decode 
interruption however 	transform create 
caused theory 	git error check 
liability whether 	data create 
contract strict 	sec transform attribute 
liability tort 	git error 
including 	check sec transform 
negligence otherwise 	execute git 
arising way 	error check 
use software 	data length data 
even advised 	bytes range 
possibility damage 	make release release 
nothing 	release strlen 
attached something 	suppress inclusion conflicting 
already attached 	openssl functions 
create container 	apple type conflicts 
context events 	config apple 
functions 	lion newer apply.c 
start stop 	prefix prefix 
listening events 	length newfd unidiff 
simple driven 	zero known 
programming library 	check index update 
originally wrote 	index cached 
code 	diffstat numstat summary 
jim loop 	check apply 
jim tcl 	apply reverse apply 
interpreter later 	reject apply 
translated form 	verbosely allow 
library easy 	overlap threeway paths 
reuse 	fake ancestor 
copyright salvatore 	line termination context 
sanfilippo antirez 	apply usage 
gmail dot 	whitespace error squelch 
rights reserved 	whitespace errors 
redistribution use 	applied fixing patch 
source 	input file 
binary forms 	root read stdin 
without modification 	options option 
permitted provided 	option whitespace option 
following conditions 	max change 
met redistributions 	max len linenr 
source 	leading trailing 
code must 	oldpos oldlines newpos 
retain copyright 	newlines patch 
notice list 	size linenr 
conditions following 	next name old 
disclaimer redistributions 	name def 
binary 	name old mode 
form must 	mode rejected 
reproduce copyright 	rule lines added 
notice list 	lines deleted 
conditions following 	score fragments result 
disclaimer documentation 	resultsize old 
materials 	sha prefix sha 
provided distribution 	prefix next 
neither name 	threeway stage list 
redis names 	next patch 
contributors may 	list next len 
used endorse 	buf len 
promote 	alloc line allocated 
products derived 	line table 
software without 	len last last 
specific prior 	result img 
written permission 	bol len 
software provided 	flag image buf 
copyright 	len prepare 
holders contributors 	linetable next image 
express implied 	output fmt 
warranties including 	patch buffer size 
limited implied 	len str 
warranties merchantability 	name namelen terminate 
fitness 	name line 
particular purpose 	def name line 
disclaimed shall 	len line 
copyright owner 	len line len 
contributors liable 	date line 
direct indirect 	len time line 
incidental 	len line 
special exemplary 	len line len 
consequential damages 	end line 
including limited 	def end terminate 
procurement substitute 	len start 
goods services 	deflen ret 
loss 	line def terminate 
use data 	name line 
profits business 	def len date 
interruption however 	len name 
caused theory 	cnt nameline name 
liability whether 	val nameline 
contract 	stamp regexp colon 
strict liability 	stamp zoneoffset 
tort including 	hourminute status first 
negligence otherwise 	second patch 
arising way 	name first name 
use software 	line patch 
even 	line isnull orig 
advised possibility 	name side 
damage macros 	len name another 
types data 	line patch 
structures file 	orig line patch 
structure one 	orig line 
readable 	patch line 
writable time 	patch line patch 
structure time 	line patch 
seconds milliseconds 	line patch line 
fired state 	patch line 
program highest 	patch line patch 
file 	line patch 
descriptor currently 	val line patch 
registered max 	val line 
number file 	patch ptr eol 
descriptors tracked 	len line 
used detect 	patch line llen 
system 	nslash line 
clock skew 	llen name second 
registered events 	len line 
fired events 	len first line 
used polling 	len size 
api specific 	patch offset 
data 	str patch oplen 
prototypes ae 	line ptr 
epollc loop 	line len offset 
state loop 	expect digits 
setsize state 	line size fragment 
loop state 	ret len 
loop 	line len fragment 
mask state 	offset line 
loop delmask 	size hdrsize patch 
state mask 	offset len 
loop tvp 	nextlen dummy git 
state retval 	hdr len 
numevents 	result line len 
mask zmalloc 	linenr err 
zmalloc zfree 	line len rule 
epoll create 	result line 
zfree zfree 	size patch fragment 
zrealloc close 	added deleted 
zfree 	offset oldlines 
zfree epoll 	newlines leading trailing 
ctl epoll 	line size 
ctl epoll 	patch offset context 
ctl epoll 	fragp fragment 
wait linux 	len patch data 
epoll 	size inflated 
module copyright 	size stream buf 
salvatore sanfilippo 	status used 
antirez gmail 	llen used size 
dot rights 	buffer patch 
reserved redistribution 	method origlen data 
use 	hunk size 
source binary 	frag length max 
forms without 	length newsize 
modification permitted 	buffer size patch 
provided following 	forward reverse 
conditions met 	status used used 
redistributions 	name old 
source code 	name limit 
must retain 	name include name 
copyright notice 	exclude pathname 
list conditions 	pathlen buffer size 
following disclaimer 	patch hdrsize 
redistributions 	patchsize offset git 
binary form 	binary llen 
must reproduce 	used binhdr len 
copyright notice 	frag pluses 
list conditions 	minuses patch qname 
following disclaimer 	max del 
documentation 	total path buf 
materials provided 	preimage postimage 
distribution neither 	buf len postlen 
name redis 	ctx reduced 
names contributors 	old preimage len 
may used 	img preimage 
endorse 	postimage lno rule 
promote products 	match beginning 
derived software 	match end 
without specific 	buf buf orig 
prior written 	target len 
permission software 	postlen preimage limit 
provided 	buf end 
copyright holders 	imgoff preoff postlen 
contributors express 	extra chars 
implied warranties 	preimage eof preimage 
including limited 	end prelen 
implied warranties 	imglen oldlen tgtlen 
merchantability 	fixstart tgtfix 
fitness particular 	match fixstart oldlen 
purpose disclaimed 	img preimage 
shall copyright 	postimage line rule 
owner contributors 	match beginning 
liable direct 	match end backwards 
indirect 	forwards backwards 
incidental special 	lno forwards lno 
exemplary consequential 	lno img 
damages including 	img img 
limited procurement 	applied pos preimage 
substitute goods 	postimage count 
services 	insert count applied 
loss use 	result preimage 
data profits 	limit img frag 
business interruption 	inaccurate eof 
however caused 	rule nth fragment 
theory liability 	match beginning 
whether 	match end patch 
contract strict 	size old 
liability tort 	oldlines newlines blank 
including negligence 	lines end 
otherwise arising 	found blank lines 
way use 	end hunk 
software 	linenr leading trailing 
even advised 	pos applied 
possibility damage 	pos preimage 
hint kernel 	postimage first len 
already monitored 	plen added 
need mod 	blank line blank 
operation 	context start 
otherwise need 	offset img patch 
operation merge 	fragment len 
old events 	dst img patch 
avoid valgrind 	name sha 
warning avoid 	size result img 
valgrind 	patch frag 
warning note 	name rule inaccurate 
kernel requires 	eof nth 
non pointer 	buf sha mode 
even epoll 	result buf 
ctl del 	name item patch 
ae 	patch patch 
evportc evport 	item patch item 
debug loop 	istate costate 
state loop 	patch gone 
setsize loop 	previous buf name 
state state 	expected mode 
portfd 	image patch buf 
mask events 	len img 
err loop 	previous status image 
mask state 	path file 
fullmask pfd 	file file result 
loop mask 	status image 
state 	patch buf status 
fullmask pfd 	pos len 
loop tvp 	img name mode 
state timeout 	image patch 
tsp mask 	pre sha post 
nevents zmalloc 	sha sha 
port 	buf len status 
create zfree 	img tmp 
close zfree 	image patch image 
port associate 	patch old 
strerror strerror 	name previous 
api lookup 	status mode pos 
pending 	name exists 
api associate 	nst symlink changes 
api lookup 	path ent 
pending port 	path ent patch 
dissociate perror 	name change 
abort api 	name ret name 
associate 	patch old 
abort api 	name name patch 
associate abort 	old name 
port getn 	name name tpatch 
perror abort 	exists status 
module illumos 	err patch err 
ports 	path sha 
copyright joyent 	pos sha hunk 
inc rights 	heading preimage 
reserved redistribution 	list filename patch 
use source 	result sha 
binary forms 	name patch 
without 	files adds dels 
modification permitted 	patch name 
provided following 	newdelete mode name 
conditions met 	show name 
redistributions source 	renamecopy old slash 
code must 	old slash 
retain 	patch patch lines 
copyright notice 	len len 
list conditions 	patch rmdir empty 
following disclaimer 	path mode 
redistributions binary 	buf size namelen 
form must 	size path 
reproduce 	mode buf size 
copyright notice 	nbuf path 
list conditions 	mode buf size 
following disclaimer 	newpath patch 
documentation materials 	stage namelen 
provided distribution 	size mode patch 
neither 	path mode 
name redis 	size buf patch 
names contributors 	phase patch 
may used 	rej namebuf frag 
endorse promote 	cnt list 
products derived 	phase errs cpath 
software 	item file 
without specific 	filename options offset 
prior written 	buf listp 
permission software 	skipped patch patch 
provided copyright 	opt arg 
holders contributors 	unset opt arg 
express 	unset opt 
implied warranties 	arg unset opt 
including limited 	arg unset 
implied warranties 	opt arg unset 
merchantability fitness 	whitespace option 
particular purpose 	opt arg 
disclaimed 	unset argc argv 
shall copyright 	prefix errs 
owner contributors 	gitdir force apply 
liable direct 	whitespace option 
indirect incidental 	builtin apply options 
special exemplary 	arg squelched 
consequential 	strcmp strcmp strcmp 
damages including 	strcmp strcmp 
limited procurement 	strcmp die strcmp 
substitute goods 	strcmp strcmp 
services loss 	strcmp strcmp die 
use data 	free free 
profits 	free fragment list 
business interruption 	free free 
however caused 	free free free 
theory liability 	free patch 
whether contract 	isspace isspace isspace 
strict liability 	isspace isspace 
tort 	isspace isspace 
including negligence 	isspace isspace alloc 
otherwise arising 	grow hash 
way use 	line memset line 
software even 	info free 
advised possibility 	free memset strcmp 
damage 	quote style 
file api 	strbuf addstr quote 
ports present 	style quote 
solaris systems 	style fputc strbuf 
since solaris 	release strbuf 
port associate 	read die errno 
file 	strbuf grow 
descriptors port 	memset skip prefix 
association also 	isspace unquote 
includes poll 	style strbuf release 
events consumer 	strchr strbuf 
interested pollin 	release strbuf strbuf 
pollout 	insert squash 
one tricky 	slash strbuf 
piece implementation 	detach strlen strlen 
events via 	strlen isdigit 
api poll 	strlen strlen strlen 
corresponding file 	isdigit isdigit 
descriptors 	isdigit isdigit strlen 
become dissociated 	strlen strlen 
port necessary 	isdigit isdigit isdigit 
poll events 	isdigit isdigit 
level triggered 	isdigit strlen isdigit 
didn become 	isdigit strlen 
dissociated 	strlen strlen strlen 
would immediately 	isdigit isdigit 
fire another 	isdigit isdigit isdigit 
since underlying 	isdigit isdigit 
state hasn 	isdigit time len 
changed yet 	isdigit sane 
must 	len colon 
associate file 	len time len 
descriptor know 	fractional time 
caller actually 	len date len 
read api 	trailing spaces 
tell exactly 	len isspace name 
happens 	terminate squash 
know must 	slash xstrdup squash 
happen time 	slash xstrdup 
api poll 	strlen strncmp squash 
called solution 	slash xstrdup 
keep track 	xstrfmt squash slash 
last 	squash slash 
fds returned 	xmemdupz find name 
api poll 	gnu find 
associate next 	name common find 
time api 	name gnu 
poll invoked 	strchrnul diff timestamp 
summarize 	len find 
module association 	name common 
either represented 	find name common 
via kernel 	dev find 
association represented 	name traditional strchr 
pending fds 	strncmp count 
pending 	slashes strncmp count 
masks last 	slashes free 
fds returned 	xmalloc regcomp warning 
api poll 	regexec size 
enter api 	warning strtol strtol 
poll point 	memcmp memcmp 
restore 	strtol strtol guess 
kernel association 	guess dev 
port pending 	find name traditional 
fds pending 	dev find 
fds pending 	name traditional find 
fds masks 	name traditional 
nothing 	find name traditional 
resize helper 	free epoch 
function invoke 	timestamp epoch 
port associate 	timestamp xstrdup die 
given mask 	find name 
since port 	strlen die find 
associate 	name memcmp 
events argument 	die free memcmp 
replaces existing 	die gitdiff 
events must 	verify name free 
sure include 	gitdiff verify 
whatever events 	name free strtoul 
already 	strtoul free 
associated call 	xstrdup gitdiff oldmode 
port associate 	free xstrdup 
recently returned 	gitdiff newmode free 
api poll 	find name 
safe consumer 	free find name 
processed 	free find 
poll play 	name free find 
safer simply 	name strtoul 
updating pending 	strtoul strchr 
mask associated 	memcpy strchr strchrnul 
usual api 	memcpy strtoul 
poll 	strlen strlen unquote 
called returned 	style skip 
api poll 	prefix strbuf isspace 
currently associated 	unquote style 
port need 	skip prefix strcmp 
update pending 	strbuf release 
mask 	strbuf detach skip 
appropriately currently 	prefix memcmp 
associated port 	strbuf detach strbuf 
like must 	release strbuf 
look full 	release skip prefix 
mask file 	unquote style 
descriptor 	skip prefix strncmp 
updating association 	isspace strbuf 
good way 	strbuf detach strbuf 
knowing events 	release strchr 
without looking 	skip prefix 
loop state 	strncmp xmemdupz git 
directly 	header name 
rely fact 	xstrfmt free linelen 
caller already 	size strlen 
updated mask 	memcmp isdigit strtoul 
loop removing 	parse num 
events use 	parse num strlen 
port 	memcmp warning 
dissociate association 	linelen starts starts 
completely failure 	warning linelen 
indicates bug 	parse range parse 
enomem potentially 	range linelen 
condition kernel 	memcmp parse fragment 
won 	header die 
generally unless 	memcmp parse git 
things really 	header die 
bad eagain 	xstrdup xstrdup 
indicates reached 	die memcmp memcmp 
resource 	linelen memcmp 
limit doesn 	parse traditional patch 
make sense 	whitespace error 
retry counter 	free check record 
intuitively errors 	error linelen 
indicate bug 	parse fragment header 
cases 	recount diff 
best abort 	linelen check whitespace 
returned events 	check whitespace 
must associate 	check whitespace memcmp 
port calling 	memcmp linelen 
port see 	error error memcmp 
block 	xcalloc parse 
comment top 	fragment die die 
file explanation 	die memset 
since deleted 	xmalloc git inflate 
see api 	init git 
del fatal 	inflate git 
port 	inflate end free 
getn errno 	linelen starts 
etime returned 	strtoul starts strtoul 
events etime 	linelen xrealloc 
check nevents 	decode xcalloc inflate 
error indicates 	free free 
bug 	error parse binary 
ae kqueuec 	hunk error 
loop state 	parse binary hunk 
loop setsize 	free free 
state loop 	xstrdup prefix filename 
state loop 	free prefix 
mask 	one prefix one 
state loop 	list append 
mask state 	strlen memcmp wildmatch 
loop tvp 	find header 
state retval 	prefix patch use 
numevents timeout 	patch whitespace 
mask 	rule parse 
zmalloc zmalloc 	single patch linelen 
zfree kqueue 	memcmp parse 
zfree zfree 	binary memcmp strlen 
zrealloc close 	memcmp metadata 
zfree zfree 	changes die swap 
kevent 	swap swap 
kevent kevent 	swap swap swap 
kevent kevent 	swap quote 
kevent kqueue 	style strchr strbuf 
module copyright 	splice strbuf 
harish mallipeddi 	release strbuf release 
harish 	strbuf readlink 
mallipeddi gmail 	error strbuf read 
rights reserved 	file error 
redistribution use 	convert git prepare 
source binary 	image free 
forms without 	xmalloc memmove memcpy 
modification 	die memcmp 
permitted provided 	isspace fuzzy 
following conditions 	matchlines isspace strbuf 
met redistributions 	init strbuf 
source code 	strbuf strbuf detach 
must retain 	update pre 
copyright 	post images strbuf 
notice list 	init fix 
conditions following 	copy strbuf init 
disclaimer redistributions 	fix copy 
binary form 	memcmp strbuf release 
must reproduce 	fix copy 
copyright 	isspace strbuf detach 
notice list 	update pre 
conditions following 	post images strbuf 
disclaimer documentation 	release match 
materials provided 	fragment xmalloc sub 
distribution neither 	memcpy memcpy 
name 	memcpy free 
redis names 	realloc memmove memcpy 
contributors may 	memset memset 
used endorse 	xmalloc strbuf init 
promote products 	linelen strbuf 
derived software 	addch line info 
without 	line info 
specific prior 	blank line memcpy 
written permission 	line info 
software provided 	strbuf fix copy 
copyright holders 	line info 
contributors express 	blank line error 
implied 	strbuf setlen 
warranties including 	find pos first 
limited implied 	line first 
warranties merchantability 	line last line 
fitness particular 	last line 
purpose disclaimed 	record error last 
shall 	line update 
copyright owner 	image error 
contributors liable 	free strbuf release 
direct indirect 	free free 
incidental special 	error error patch 
exemplary consequential 	delta clear 
damages 	image clear image 
including limited 	xmemdupz strlen 
procurement substitute 	strlen sha hex 
goods services 	sha hex 
loss use 	error hash sha 
data profits 	file strcmp 
business 	sha hex error 
interruption however 	sha hex 
caused theory 	error sha hex 
liability whether 	sha clear 
contract strict 	image sha file 
liability tort 	read sha 
including 	file error clear 
negligence otherwise 	image apply 
arising way 	binary fragment 
use software 	error hash sha 
even advised 	file strcmp 
possibility damage 	sha hex error 
ae 	sha hex 
selectc loop 	apply binary apply 
state loop 	one fragment 
setsize loop 	error isgitlink strbuf 
loop mask 	grow strbuf 
state loop 	addf sha hex 
mask 	read sha 
state loop 	file strbuf attach 
tvp state 	read blob 
retval numevents 	list lookup list 
mask zmalloc 	insert list 
zero zero 	insert list insert 
zfree 	memset checkout 
clr clr 	entry lstat error 
memcpy memcpy 	table deleted 
isset isset 	deleted isgitlink 
module copyright 	isdir match stat 
salvatore sanfilippo 	read file 
antirez 	gitlink error isgitlink 
gmail dot 	read file 
rights reserved 	gitlink symlink leading 
redistribution use 	path strlen 
source binary 	error read old 
forms without 	data error 
modification 	previous patch error 
permitted provided 	strbuf load 
following conditions 	patch target free 
met redistributions 	fragment list 
source code 	error strbuf detach 
must retain 	prepare image 
copyright 	read mmblob read 
notice list 	mmblob read 
conditions following 	mmblob merge 
disclaimer redistributions 	free free free 
binary form 	free clear 
must reproduce 	image die cache 
copyright 	name pos 
notice list 	strlen error lstat 
conditions following 	error strerror 
disclaimer documentation 	checkout target verify 
materials provided 	index match 
distribution neither 	error load patch 
name 	target strbuf 
redis names 	detach prepare image 
contributors may 	isgitlink isgitlink 
used endorse 	write sha file 
promote products 	sha read 
derived software 	blob error strbuf 
without 	detach prepare 
specific prior 	image apply fragments 
written permission 	clear image 
software provided 	write sha 
copyright holders 	file clear image 
contributors express 	load current 
implied 	error load preimage 
warranties including 	error write 
limited implied 	sha file clear 
warranties merchantability 	image three 
fitness particular 	way merge oidclr 
purpose disclaimed 	hashcpy hashcpy 
shall 	hashcpy load preimage 
copyright owner 	apply fragments 
contributors liable 	threeway table free 
direct indirect 	error previous 
incidental special 	patch error lstat 
exemplary consequential 	error strerror 
damages 	cache name pos 
including limited 	strlen error 
procurement substitute 	checkout target verify 
goods services 	index match 
loss use 	error error 
data profits 	strerror mode stat 
business 	error warning 
interruption however 	free cache name 
caused theory 	pos strlen 
liability whether 	lstat isdir symlink 
contract strict 	leading path 
liability tort 	strlen error strerror 
including 	list lookup 
negligence otherwise 	list insert list 
arising way 	lookup islnk 
use software 	symlink changes islnk 
even advised 	symlink changes 
possibility damage 	check symlink changes 
need 	cache file 
copy sets 	exists islnk lstat 
safe reuse 	islnk strbuf 
sets ensure 	addstr path beyond 
enough room 	symlink strbuf 
type aligned 	release verify 
allocc 	path die verify 
alignment alignment 	path die 
size alignment 	check preimage table 
size total 	deleted deleted 
buf errno 	check create error 
aligned alloc 	error strcmp 
errno 	error error die 
errno aligned 	path path 
alloc errno 	beyond symlink error 
errno aligned 	apply data 
alloc errno 	error prepare symlink 
errno aligned 	changes prepare 
alloc 	table say patch 
errno errno 	name check 
aligned alloc 	patch read cache 
errno aligned 	cache name 
alloc buferror 	pos strlen hashcpy 
errno test 	memchr starts 
fail 	sha hex 
malloc usable 	starts sha hex 
size free 	isgitlink preimage 
test define 	sha gitlink patch 
maxalign size 	die sha 
all.c lua 	blob current sha 
core 	die die 
libraries interpreter 	make cache entry 
single file 	die index 
allocated.c config 	entry die hold 
stats arg 	file update 
err usize 	write locked index 
thd 	die discard 
mallctl test 	index show stats 
fail strerror 	print stat 
mallctl test 	summary write name 
fail strerror 	quoted strchr 
mallctl test 	strchr memcmp 
fail 	show mode change 
strerror mallctl 	show file 
test fail 	mode name show 
strerror malloc 	file mode 
ptr mallctl 	name show rename 
mallctl ptr 	copy show 
malloc 	mode change show 
usable size 	mode change 
free mallctl 	quote style strlen 
mallctl ptr 	quote style 
test skip 	strlen file cache 
thd start 	die warn 
thd 	path strlen cache 
create thd 	entry size 
test run 	xcalloc memcpy create 
tests multiple 	mode create 
times check 	flags isgitlink skip 
bad interactions 	prefix sha 
anet.c 	hex die 
err fmt 	lstat die errno 
err non 	fill stat 
block flags 	cache info write 
err err 	sha file 
err interval 	die cache entry 
val 	die isgitlink 
err val 	lstat isdir mkdir 
err err 	islnk symlink 
err buffsize 	open convert working 
err yes 	write die 
err err 	strbuf release close 
host 	die errno 
ipbuf ipbuf 	create file safe 
len flags 	create leading 
hints info 	directories create file 
err host 	lstat isdir 
ipbuf ipbuf 	rmdir getpid mksnpath 
len 	create file 
err host 	rename unlink 
ipbuf ipbuf 	warn die errno 
len err 	strlen cache 
yes err 	entry size file 
domain err 	cache oid 
addr 	xcalloc memcpy create 
port source 	mode create 
addr flags 	flags hashcpy cache 
portstr hints 	entry die 
servinfo bservinfo 	create one file 
bound err 	conflicted stages 
addr 	file index file 
port err 	file create 
addr port 	file file create 
err addr 	file say 
port source 	patch name die 
addr err 	strbuf addf 
addr 	say patch name 
port source 	strbuf release 
addr err 	strlen size 
path flags 	size warning memcpy 
err path 	memcpy fopen 
err path 	error strerror fputc 
buf 	fclose write 
count nread 	one result write 
totlen buf 	one reject 
count nwritten 	list append list 
totlen err 	sort list 
len backlog 	clear rerere read 
err 	patch file 
yes err 	xcalloc parse chunk 
port bindaddr 	reverse patches 
backlog port 	use patch patch 
hints servinfo 	stats free 
err port 	patch die hold 
bindaddr 	locked index 
backlog err 	read cache 
port bindaddr 	die check patch 
backlog err 	list exit 
path perm 	write results exit 
backlog err 	build fake 
len 	ancestor stat patch 
err len 	list numstat 
port salen 	patch list summary 
err salen 	patch list 
len port 	free patch list 
salen buf 	strbuf release 
buf 	list clear git 
len port 	config git 
buf buf 	config git config 
len port 	name limit 
len port 	name limit atoi 
salen fmt 	parse whitespace 
fmt 	option strbuf reset 
len port 	strbuf addstr 
start vsnprintf 	strbuf complete 
end fcntl 	strlen git apply 
anet error 	config parse 
strerror fcntl 	whitespace option parse 
anet 	ignorewhitespace option 
error strerror 	parse options die 
anet block 	die die 
anet block 	die die strcmp 
setsockopt anet 	apply patch 
error strerror 	prefix filename open 
setsockopt 	die errno 
anet error 	whitespace mode apply 
strerror setsockopt 	patch close 
anet error 	whitespace mode apply 
strerror setsockopt 	patch warning 
anet error 	die warning warning 
strerror 	write locked 
setsockopt anet 	index die apply 
error strerror 	copyright linus 
anet tcp 	torvalds applies 
delay anet 	patches top arbitrary 
tcp delay 	version scm 
setsockopt 	check turns checking 
anet error 	working matches 
strerror setsockopt 	files modified doesn 
anet error 	apply patch 
strerror setsockopt 	stat diffstat doesn 
anet error 	actually apply 
strerror 	numstat numeric diffstat 
memset getaddrinfo 	doesn actually 
anet error 	apply index info 
gai strerror 	shows old 
inet ntop 	index info paths 
inet ntop 	available index 
freeaddrinfo 	updates cache well 
anet resolve 	cached updates 
anet resolve 	cache without ever 
setsockopt anet 	touching working 
error strerror 	diff stat 
socket anet 	like behaviour keep 
error 	track biggest 
strerror anet 	change seen longest 
reuse addr 	filename allows 
close snprintf 	simple scaling various 
memset getaddrinfo 	current state 
anet error 	notably line numbers 
gai 	file patching 
strerror socket 	right xxxx things 
anet reuse 	flags means 
addr anet 	know yet represents 
non block 	one hunk 
getaddrinfo anet 	patch starting oldpos 
error 	oldlines newpos 
gai strerror 	newlines marker patch 
bind freeaddrinfo 	text pointed 
anet error 	patch length 
strerror connect 	stored size leading 
close anet 	trailing number 
error 	context lines patch 
strerror close 	usually borrowed 
freeaddrinfo anet 	buf apply patch 
tcp connect 	codepaths store 
anet tcp 	allocated buffer dealing 
connect anet 	binary patch 
tcp 	reuse leading field 
connect anet 	store type 
tcp connect 	binary hunk either 
anet tcp 	deflated delta 
connect anet 	deflated represents patch 
create socket 	file metainfo 
strncpy 	changes creation deletion 
anet non 	filemode content 
block connect 	changes represented series 
anet error 	fragments unknown 
strerror close 	three way 
anet unix 	fallback result line 
connect 	file len 
anet unix 	bytes includes terminating 
connect read 	incomplete line 
write bind 	end file ends 
anet error 	one contents 
strerror close 	hashes hash represents 
listen 	file lines 
anet error 	records filenames touched 
strerror close 	order handle 
setsockopt anet 	one patches touch 
error strerror 	file compare 
close snprintf 	lines length length 
memset 	ignoring whitespace 
getaddrinfo anet 	difference returns match 
error gai 	otherwise ignore 
strerror socket 	line endings skip 
anet anet 	leading whitespaces 
reuse addr 	begin whitespace 
anet 	early lines empty 
listen anet 	skip whitespace 
error freeaddrinfo 	inside check whitespace 
anet tcp 	buffers want 
server anet 	match reached end 
tcp 	one side 
server anet 	lines match buf 
create socket 	file contents 
memset strncpy 	patched read various 
anet listen 	sources attach 
chmod accept 	image line index 
anet 	image owns 
error strerror 	buf fmt must 
anet accept 	contain one 
inet ntop 	substitution make sure 
ntohs inet 	slop buffer 
ntop ntohs 	speculative memcmp etc 
anet 	see nul 
accept getpeername 	filled slashes 
inet ntop 	make index work 
ntohs inet 	filenames proposed 
ntop ntohs 	style gnu patch 
strncpy snprintf 	diff format 
strchr 	see http marc 
anet peer 	info git 
anet format 	date digit year 
addr getsockname 	permit digit 
inet ntop 	hours time expected 
ntohs inet 	format fractional 
ntop 	seconds hours minutes 
ntohs anet 	whole seconds 
sock name 	expected format spaces 
anet format 	posix gnu 
addr anet 	date bad space 
basic tcp 	date success 
socket 	space date whitespace 
stuff made 	damage generally 
bit less 	prefer shorter 
boring copyright 	name especially one 
salvatore sanfilippo 	variation something 
antirez gmail 	tacked end file 
dot 	orig file 
rights reserved 	given guess appropriate 
redistribution use 	given patch 
source binary 	begin prefix likely 
forms without 	apply directory 
modification permitted 	line posix timestamp 
provided 	last gnu 
following conditions 	diff puts epoch 
met redistributions 	signal creation 
source code 	deletion timestamp interested 
must retain 	epoch timestamp 
copyright notice 	non zero fraction 
list 	cannot one 
conditions following 	hence regexp 
disclaimer redistributions 	reason date must 
binary form 	either seconds 
must reproduce 	part must yyyy 
copyright notice 	must either 
list 	west gmt east 
conditions following 	gmt name 
disclaimer documentation 	etc info lines 
materials provided 	traditional patch 
distribution neither 	header fixme end 
name redis 	filename heuristics 
names 	kind screwy existing 
contributors may 	files happily 
used endorse 	check index match 
promote products 	creating file 
derived software 	match whatever patch 
without specific 	idea skip 
prior 	skip anal diff 
written permission 	header consistency 
software provided 	make sure 
copyright holders 	end strange ambiguous 
contributors express 	patches floating 
implied warranties 	around result gitdiff 
including 	old name 
limited implied 	check names previous 
warranties merchantability 	information make 
fitness particular 	sure expect dev 
purpose disclaimed 	index line 
shall copyright 	hexadecimal hexadecimal optional 
owner 	space octal 
contributors liable 	mode normal diff 
direct indirect 	doesn change 
incidental special 	anything fall next 
exemplary consequential 	diff tell 
damages including 	parser skip leading 
limited 	components line 
procurement substitute 	accept absolute paths 
goods services 	extract name 
loss use 	appears diff 
data profits 	git line find 
business interruption 	anything rename 
however 	patch find name 
caused theory 	elsewhere need 
liability whether 	reliably find name 
contract strict 	mode change 
liability tort 	creation deletion empty 
including negligence 	file cases 
otherwise 	sides name respectively 
arising way 	strip prefix 
use software 	including trailing slash 
even advised 	second points 
possibility damage 	one past closing 
socket blocking 	name find 
non 	second name must 
block zero 	match otherwise 
non blocking 	ignore unquoted second 
note fcntl 	unquoted first 
getfl setfl 	name since 
interrupted signal 	first name unquoted 
tcp 	exists must 
keep alive 	beginning second name 
option detect 	good accept 
dead peers 	name shows twice 
interval option 	exactly form 
used linux 	separator preimage postimage 
linux 	pathname interested 
specific probe 	rename def name 
send time 	rename patch 
interval count 	names elsewhere unambiguous 
settings less 	form postimage 
garbage keepalive 	name len bytes 
time 	starting name 
linux modify 	second separated one 
settings make 	found exactly 
feature actually 	match verify 
useful send 	recognize lines following 
first probe 	git header 
interval 	git diff information 
send next 	guess things 
probes specified 	may old name 
interval note 	rest headers 
delay interval 	anywhere pure mode 
send three 	changes removing 
probes 	adding empty files 
detecting error 	name header 
see next 	fall parse unified 
setsockopt call 	diff fragment 
consider socket 	header form figure 
error state 	number lines 
three 	fragment testing early 
send three 	allows take 
ack probes 	shortcuts make sure 
without getting 	find unconnected 
reply avoid 	patch fragments 
unused warning 	sign didn find 
non 	header patch 
linux systems 	become corrupted broken 
socket send 	git patch 
timeout sndtimeo 	might real patch 
socket option 	rename mode 
specified number 	change handle specially 
milliseconds 	followed accept 
disable argument 	unified patches want 
zero anet 	least chars 
resolve called 	minimum shortest consider 
anet resolve 	patch parse 
anet resolve 	unified diff note 
actual 	really needs 
work resolves 	parse fragment separately 
hostname host 	since way 
representation address 	know difference part 
buffer pointed 	patch starts 
ipbuf flags 	next patch 
anet 	look line counts 
function resolves 	parse thing 
hostnames actually 	newer gnu diff 
already addresses 	empty context 
turns function 	line allow newline 
validating normalizing 	end file 
function 	depending locale settings 
specify socktype 	patch produced 
avoid dups 	know line looks 
make sure 	like thing 
connection intensive 	know begins checking 
things like 	sanity check 
redis 	newline least fragment 
benckmark able 	ends incomplete 
close open 	line failed include 
sockets zillion 	loop hit 
times make 	oldlines newlines seeing 
sure connection 	seen diff 
intensive 	git header 
things like 	traditional patch header 
redis benchmark 	read hunks 
able close 	belong patch fragments 
open sockets 	hang given 
zillion times 	patch structure fragment 
best 	patch fragment 
effort binding 	size pair points 
strlen create 	memory given 
socket connect 	caller copy something 
fail socket 	removed old 
call connect 	lines cannot creation 
retry 	something added 
next entry 	cannot deletion however 
servinfo getaddrinfo 	reverse unified 
saves self 	patches necessarily creation 
determining socket 	even though 
non blocking 	old lines ones 
connect 	necessarily deletion 
einprogress error 	unfortunately real 
ended iteration 	creation deletion patch 
loop without 	context line 
errors connected 	definition cannot safely 
socket caller 	tell apart 
handle 	unified insanity least 
best effort 	patch one 
binding binding 	hunk creation deletion 
address used 	read binary 
possible create 	hunk fragment fragment 
socket without 	patch points 
binding 	allocated memory caller 
address like 	must free 
read make 	marked free patch 
sure count 	expect line 
read unless 	begins binary patch 
error eof 	method delta 
condition 	followed length 
encountered like 	data deflating sequence 
write make 	length followed 
sure count 	encoded data follow 
written unless 	terminated newline 
error encountered 	sequence encodes bytes 
strlen 	would limit 
effect bindaddr 	patch line characters 
format port 	one line 
pair something 	fit groups would 
easy parse 	decode bytes 
matches surrounded 	max length corresponds 
port 	bytes corresponds 
separated colons 	bytes consume blank 
standard display 	line minimum 
addresses within 	line line length 
redis like 	must multiple 
anet format 	plus input length 
addr 	multiple would 
extract port 	filler end 
socket peer 	filler never exceed 
anet.h err 	bytes read 
addr port 	git binary patch 
err addr 	follows line 
port 	says patch method 
err addr 	currently either 
port source 	delta length data 
addr err 	deflating sequence 
addr port 	length followed encoded 
source addr 	data follows 
err 	binary patch reversible 
path err 	another binary 
path buf 	hunk format starting 
count err 	patch method 
host ipbuf 	either delta length 
ipbuf len 	data sequence 
err 	length encoded data 
host ipbuf 	terminated another 
ipbuf len 	empty line 
err port 	data applied postimage 
bindaddr backlog 	produces preimage 
err port 	one hunk forward 
bindaddr 	hunk otherwise 
backlog err 	already gave error 
path perm 	message reverse 
backlog err 	hunk error corrupt 
serversock len 	reverse hunk 
port err 	include exclude paths 
serversock 	outside touched 
buf count 	regardless include see 
err err 	matches exclude 
err err 	include rule include 
err err 	path match 
len port 	rule used otherwise 
err 	saw bunch 
interval len 	exclude rules none 
port fmt 	path used 
fmt len 	read patch 
port fmt 	text buffer size 
fmt len 	bytes stop 
fmt 	reading seeing single 
fmt len 	patch changes 
anet basic 	single file create 
tcp socket 	fragments patch 
stuff made 	hunks hang given 
bit less 	patch number 
boring 	bytes consumed caller 
copyright salvatore 	call next 
sanfilippo antirez 	patch empty patch 
gmail dot 	cannot applied 
rights reserved 	text patch without 
redistribution use 	metadata change 
source 	binary patch appears 
binary forms 	empty scale 
without modification 	filename scale 
permitted provided 	update preimage common 
following conditions 	lines postimage 
met redistributions 	buffer buf length 
source 	len postlen 
code must 	postimage updated place 
retain copyright 	otherwise updated 
notice list 	buffer length postlen 
conditions following 	update preimage 
disclaimer redistributions 	whitespace fixes note 
binary 	losing preimage 
form must 	buf apply one 
reproduce copyright 	fragment free 
notice list 	oldlines adjust common 
conditions following 	context lines 
disclaimer documentation 	postimage done place 
materials 	shrinking whitespace 
provided distribution 	fixing needs buffer 
neither name 	ignoring whitespace 
redis names 	expanding leading 
contributors may 	tabs spaces trust 
used endorse 	caller tell 
promote 	update done place 
products derived 	postlen added 
software without 	line counterparts preimage 
specific prior 	common context 
written permission 	skip original postimage 
software provided 	find corresponding 
copyright 	one preimage preimage 
holders contributors 	expected run 
express implied 	caller addition trailing 
warranties including 	blank lines 
limited implied 	copy fixing line 
warranties merchantability 	length fix 
fitness 	length whole thing 
particular purpose 	hunk falls 
disclaimed shall 	within boundaries img 
copyright owner 	hunk beyond 
contributors liable 	end img 
direct indirect 	removing blank lines 
incidental 	end file 
special exemplary 	many lines beginning 
consequential damages 	preimage must 
including limited 	match img remainder 
procurement substitute 	preimage must 
goods services 	blank hunk beyond 
loss 	end img 
use data 	removing blanks end 
profits business 	reject hunk 
interruption however 	position quick hash 
caused theory 	check exact 
liability whether 	match told match 
contract 	end size 
strict liability 	must exactly fragsize 
tort including 	otherwise fragsize 
negligence otherwise 	must still within 
arising way 	preimage either 
use software 	old piece 
even 	match preimage exactly 
advised possibility 	preimage beyond 
damage flags 	end img cannot 
used certain 	exact match 
functions aof.c 	must one non 
size block 	blank context 
privdata 	line match line 
mask block 	end img 
nwritten len 	exact match ignoring 
block thislen 	whitespace run 
numblocks level 	line line fuzzy 
count block 	matching collect 
nwritten 	line length information 
statloc cwd 	need adjust 
cwdp force 	whitespace match preimage 
nwritten sync 	matches whitespace 
progress latency 	fuzz imgoff 
last write 	holds length target 
error 	matches preimage 
log log 	end file count 
dst argc 	number characters 
argv buf 	preimage fall beyond 
len buf 	end file 
cmd key 	make sure whitespace 
seconds 	characters happen 
argv cmd 	removing blank lines 
dictid argv 	end file 
argc buf 	update preimage common 
tmpargv seldb 	postimage context 
filename fake 	lines use whitespace 
client 	target whitespace 
old aof 	missing target preimage 
state loops 	beyond end 
valid argc 	file use whitespace 
len argv 	preimage hunk 
buf argsds 	apply hash 
cmd 	says might whitespace 
obj key 	fuzz weren 
items list 	asked ignore whitespace 
entry cmd 	asked correct 
items key 	whitespace errors matching 
items llval 	whitespace correction 
cmd 	checking preimage target 
items eleobj 	whitespace errors 
cmd items 	count large corresponding 
key items 	postimage needs 
eptr sptr 	postimage prepared apply 
vstr vlen 	one fragment 
vll 	whitespace errors added 
score cmd 	lines already 
items eleobj 	common lines propagated 
score cmd 	may become 
items vstr 	longer whitespace errors 
vlen vll 	first count 
key 	added lines 
items cmd 	postimage preimage may 
items buf 	extend beyond 
nread total 	end file loop 
filename aof 	handle part 
tmpfile processed 	preimage falls within 
selectcmd 	file fixing 
keystr key 	line preimage fixing 
expiretime cmd 	line target 
cmd nodata 	match either preimage 
start privdata 	version whitespace 
mask fds 	breakage lacking whitespace 
childpid 	fix patch 
start tmpfile 	preimage already target 
dirty childpid 	whitespace breakage 
tmpfile latency 	preimage doesn either 
exitcode bysignal 	fixing whitespace 
newfd oldfd 	breakages might well 
tmpfile 	take fix 
latency list 	together real 
release list 	change length common 
create list 	postimage handle 
free method 	lines preimage falls 
list rewind 	beyond end 
list 	file match empty 
next list 	contain whitespace 
node unused 	blank eol start 
unused unused 	preimage fixing 
unused list 	line preimage yes 
first file 	preimage older 
write 	version still whitespace 
memmove list 	breakages unfixed 
del node 	fixing makes hunk 
list last 	match update 
memcpy zmalloc 	context lines postimage 
list 	match beginning 
node tail 	match end specified 
list length 	point starting 
server log 	wrong line 
aof rewrite 	never match wander 
buffer size 	around wait 
file 	match specified end 
events create 	comparison following 
file list 	test also take 
rewind list 	care negative 
next list 	line number result 
node write 	match end 
bio 	preimage larger target 
create background 	probably smart 
job server 	way smart beautiful 
flush append 	people simple 
file aof 	stupid change preimage 
fsync close 	postimage found 
server 	apply applied pos 
log kill 	counts line 
wait aof 	numbers img 
rewrite buffer 	update img preimage 
reset aof 	replace postimage 
temp file 	copy preimage offset 
aof 	img replace 
close pipes 	postimage removing blank 
open server 	lines end 
getcwd server 	img preimage may 
log strerror 	extend beyond 
rewrite append 	end must careful 
file 	part preimage 
background close 	falls within boundaries 
server log 	img initialize 
sdslen bio 	preimage limit number 
pending jobs 	lines preimage 
type server 	falls within boundaries 
log 	adjust contents 
latency start 	adjust line table 
monitor write 	note knows 
sdslen latency 	never call 
end monitor 	first line anything 
latency sample 	pre post 
needed 	image use patch 
latency sample 	hunk text 
needed latency 	frag prepare two 
sample needed 	images preimage 
latency sample 	postimage hunk find 
needed sdslen 	lines match 
server 	preimage img replace 
log strerror 	part img 
server log 	postimage text plen 
sdslen ftruncate 	much line 
server log 	use actual patch 
strerror server 	data normally 
log 	first character line 
exit sdsrange 	line followed 
server log 	newline also last 
sdslen sdsavail 	one newline 
sdsclear sdsfree 	course newer 
sdsempty latency 	gnu diff empty 
start 	context line 
monitor aof 	followed newline nothing 
fsync latency 	fall lines 
end monitor 	ignore already handled 
latency sample 	hunk change 
needed aof 	lines beginning would 
background 	begin need 
fsync sdscatlen 	careful inserts second 
decoded sdslen 	line also 
sdscatlen sdscatlen 	pattern hunk empty 
sdslen sdscatlen 	file would 
decr count 	begin words hunk 
decoded 	frag oldpos 
strtoll mstime 	without leading context 
decr count 	must match 
create create 	beginning hunk without 
cat append 	trailing lines 
command decr 	must match 
count 	end however simply 
decr count 	cannot tell 
sdsempty snprintf 	hunk must match 
sdscatprintf strlen 	end lack 
cat append 	trailing lines patch 
expire command 	generated unidiff 
create 	without context context 
cat append 	limits reduce 
command decr 	number context lines 
count cat 	reduce leading 
append expire 	trailing equal otherwise 
command cat 	reduce larger 
append 	context would want 
command sdscatlen 	prevent write 
sdslen aof 	results taking place 
rewrite buffer 	apply patch 
append sdslen 	follows callchain 
sdsfree zmalloc 	led apply patch 
sdsempty 	check patch 
list create 	list check patch 
list create 	apply data 
list free 	apply fragments apply 
method list 	one fragment 
dup method 	warn necessary reduce 
init 	number context 
client multi 	lines binary patch 
state decr 	irreversible without 
count zfree 	optional second hunk 
sdsfree list 	replace img 
release list 	result applying binary 
release 	patch binary 
free client 	patch data patch 
multi state 	fragment still 
zfree fopen 	kept preimage prepared 
redis fstat 	caller img 
fileno fclose 	freed helper 
server 	function apply binary 
log strerror 	fragment calls 
exit create 	safety require patch 
fake client 	index line 
start loading 	contain full textual 
loading progress 	sha old 
ftello 	least see old 
process events 	one matches 
blocked fgets 	patch applies otherwise 
feof atoi 	old one 
zmalloc fgets 	must empty deletion 
free fake 	patch already 
client 	postimage verified buf 
argv strtol 	matches preimage 
sdsnewlen fread 	apply patch data 
sdsfree free 	stored patch 
fake client 	fragments patch size 
argv create 	verify result 
fread 	matches xxx 
free fake 	read sha file 
client argv 	nul terminates 
lookup command 	item filename table 
server log 	records status 
exit proc 	path usually points 
server 	patch whose 
list length 	result records contents 
server free 	applying could 
fake client 	path deleted path 
argv ftello 	previously applied 
fclose free 	patch already removed 
fake 	path deleted 
client stop 	path later patch 
loading aof 	would latter 
update current 	needed deal two 
size feof 	paths swapped 
server log 	first renaming renaming 
strerror 	moving prevented 
exit server 	due presence 
log server 	later patch always 
log truncate 	name unless 
server log 	patch deletion cover 
server log 	cases normal 
strerror 	diffs file creations 
lseek server 	copies store 
log strerror 	failure rename deletion 
server log 	cases later 
server log 	chunks shouldn patch 
exit server 	old names 
log 	store information incoming 
exit rio 	file deletion 
write bulk 	git patches depend 
sds encoded 	order deletion 
rio write 	hasn happened yet 
bulk sdslen 	apply patch 
server 	populate image 
panic quicklist 	current version working 
iterator quicklist 	index depending 
next rio 	situation cached index 
write bulk 	applying non 
count rio 	git patch incrementally 
write 	updates read 
bulk rio 	result previous diff 
write bulk 	patched copy 
rio write 	memory use way 
bulk rio 	apply subproject 
write bulk 	patch without looking 
quicklist 	index needswork 
release iterator 	shouldn flagged error 
server panic 	directly falling 
intset rio 	back three way 
write bulk 	merge read 
count rio 	current contents name 
write 	cases function 
bulk rio 	called point 
write bulk 	falling back way 
rio write 	merge cases 
bulk dict 	preimage patch prepared 
iterator dict 	apply patch 
next 	post image post 
dict key 	sha sha 
rio write 	core three way 
bulk count 	merge post 
rio write 	pre note reject 
bulk rio 	apply fragments 
write 	returns patch looking 
bulk rio 	modifies deletes 
write bulk 	would want lose 
dict release 	local modification 
iterator server 	either working index 
panic ziplist 	also decides 
index 	non git patch 
server ziplist 	creation patch 
next server 	modification existing 
server ziplist 	empty file check 
zzl score 	state current 
rio write 	creation patch function 
bulk 	caller check 
count rio 	patch separately makes 
write bulk 	sure errors 
rio write 	otherwise path patch 
bulk rio 	creates exist 
write bulk 	current leading component 
rio 	name might 
write bulk 	symlink going removed 
rio write 	patch still 
bulk zzl 	pointing somewhere path 
next dict 	path name 
iterator dict 	exist far git 
next 	concerned need 
dict key 	keep track symlinks 
dict val 	preimage manipulated 
rio write 	patches patch 
bulk count 	symlink allowed affect 
rio write 	directory symlink 
bulk 	points patch removes 
rio write 	perfectly fine 
bulk rio 	patch removes make 
write bulk 	room create 
rio write 	directory created symlink 
bulk dict 	patch old 
release 	name removed symlink 
iterator server 	patch name 
panic hash 	created remains scan 
type current 	backwards cannot 
ziplist rio 	may see one 
write bulk 	created higher 
rio 	level otherwise check 
write bulk 	preimage check 
hash type 	apply patch core 
current hash 	result patch 
table rio 	result caller 
write bulk 	write destination drop 
server 	succeed type 
panic hash 	change diff always 
type init 	split patch 
iterator hash 	old immediately followed 
type next 	patch create 
rio write 	see diff run 
bulk 	diff entry 
count rio 	deleted previous patch 
write bulk 	still working 
rio write 	index patch swap 
bulk rio 	rename would 
write hash 	first rename rename 
iterator 	applying first 
cursor rio 	one presence stop 
write hash 	getting renamed 
iterator cursor 	ask deleted 
hash type 	later rename removal 
release iterator 	rename handled 
read 	way asking deleted 
sdscatlen mstime 	happy attempt 
snprintf getpid 	read path beyond 
fopen server 	symbolic link 
log strerror 	prevented load patch 
sdsempty rio 	target called 
init 	beginning apply data 
file rio 	worry patch 
sync dict 	marked bit however 
size dict 	need make 
safe iterator 	sure patch result 
fclose rio 	deposited path 
write 	beyond symbolic link 
rio write 	function tries 
bulk dict 	read sha current 
next dict 	index usable 
key dict 	gitlink patch 
val init 	one fragment hunk 
expire 	looks like 
rio write 	subproject commit old 
rio write 	sha subproject 
bulk rio 	commit sha subproject 
write bulk 	commit old 
rewrite list 	sha removal patch 
rewrite 	patch one 
rewrite sorted 	hunk preimage one 
rewrite hash 	line preimage 
server panic 	begin heading record 
rio write 	full sha 
rio write 	abbreviated name index 
bulk 	line agree 
rio write 	looks fine may 
bulk aof 	full name 
read diff 	index line build 
parent dict 	index contains 
release iterator 	files needed 
fflush 	way merge start 
fsync fileno 	supporting reverse 
mstime mstime 	patch may worth 
wait aof 	showing sha 
read diff 	prefix textual part 
parent write 	looks sane 
anet 	mode change update 
non block 	current find 
sync read 	common prefix old 
server log 	name thru 
aof read 	old common prefix 
diff parent 	old end 
server 	names renames although 
log sdslen 	buf size 
rio write 	counted also nul 
sdslen fflush 	terminated optimistically 
fsync fileno 	directories exist time 
fclose rename 	anyway create 
server 	may trying 
log strerror 	create file directory 
unlink server 	used phase 
log server 	zero phase one 
log strerror 	create rename 
fclose unlink 	modification boils thing 
dict 	old write 
release iterator 	happen removal patch 
unused unused 	leaves contents 
unused read 	marked rejected patch 
server log 	level say 
write server 	even without verbose 
log 	normal git 
strerror file 	tools never deal 
pipe pipe 	rej pretend 
pipe anet 	git patch saying 
non block 	git giving 
anet non 	extended headers 
block 	maybe please kompare 
create file 	wants trailing 
server log 	tab garbage end 
strerror close 	line owns 
file file 	patch text way 
close close 	still need 
close 	write index think 
close close 	twice adding 
close aof 	nul synonym archive-tar.c 
create pipes 	block offset 
ustime fork 	tar umask args 
close listening 	data size 
sockets 	buf chunk tail 
redis proc 	data size 
title snprintf 	tail sha buf 
getpid rewrite 	readlen keyword 
append file 	valuelen len tmp 
zmalloc dirty 	header chksum 
server 	path pathlen 
log exit 	maxlen args header 
child exit 	mode size 
child ustime 	args sha buffer 
zmalloc used 	size header 
memory latency 	mode args sha 
sample 	path pathlen 
needed server 	mode header ext 
log strerror 	header old 
server log 	mode size buffer 
time update 	err plen 
dict resize 	rest args sha 
policy 	ext header 
replication script 	header mode err 
cache flush 	tar filters 
reply error 	tar filters alloc 
reply status 	tar filters 
rewrite append 	name len data 
file 	name type 
background reply 	namelen args 
status reply 	err args cmd 
snprintf unlink 	filter argv 
latency start 	tar archiver write 
monitor redis 	die memcpy 
fstat 	write needed write 
server log 	die memcpy 
strerror latency 	memset write needed 
end monitor 	write blocked 
latency sample 	finish record memset 
needed ustime 	write die 
server 	memset write die 
log latency 	open istream 
start monitor 	error sha hex 
snprintf open 	read istream 
server log 	write blocked close 
strerror aof 	istream finish 
rewrite 	record strlen strbuf 
buffer write 	grow strbuf 
server log 	addf strbuf 
strerror close 	strbuf addch xsnprintf 
latency end 	xsnprintf isreg 
monitor latency 	xsnprintf xsnprintf xsnprintf 
sample 	strlcpy strlcpy 
needed server 	xsnprintf xsnprintf memcpy 
log aof 	memcpy snprintf 
rewrite buffer 	ustar header chksum 
size open 	memset xsnprintf 
latency start 	sha hex prepare 
monitor 	header write 
rename server 	blocked write blocked 
log strerror 	memset isdir 
close close 	isgitlink islnk isreg 
latency end 	error sha 
monitor latency 	hex path prefix 
sample 	memcpy memcpy 
needed close 	xsnprintf sha 
aof fsync 	hex strbuf append 
aof background 	ext header 
fsync aof 	memcpy isreg sha 
update current 	info islnk 
size 	isreg sha file 
sdsfree sdsempty 	archive error 
server log 	sha hex islnk 
bio create 	xsnprintf sha 
background job 	hex strbuf append 
server log 	ext header 
ustime 	memcpy prepare header 
server log 	write extended 
server log 	header free strbuf 
aof close 	release write 
pipes aof 	blocked isreg write 
rewrite buffer 	blocked stream 
reset 	blocked free strbuf 
aof temp 	append ext 
file time 	header sha 
copyright salvatore 	hex memset xsnprintf 
sanfilippo antirez 	prepare header 
gmail 	write blocked write 
dot rights 	blocked strbuf 
reserved redistribution 	release strncmp parse 
use source 	config key 
binary forms 	find tar filter 
without modification 	xcalloc xmemdupz 
permitted 	alloc grow strcmp 
provided following 	config error 
conditions met 	nonbool free xstrdup 
redistributions source 	strcmp git 
code must 	config strcmp strcmp 
retain copyright 	umask umask 
notice 	git config tar 
list conditions 	filter config 
following disclaimer 	write extended header 
redistributions binary 	write archive 
form must 	entries write 
reproduce copyright 	trailer die strbuf 
notice 	addstr strbuf 
list conditions 	addf start command 
following disclaimer 	die errno 
documentation materials 	close dup die 
provided distribution 	errno close 
neither name 	write tar archive 
redis 	close finish 
names contributors 	command die strbuf 
may used 	release archiver 
endorse promote 	tar filter config 
products derived 	tar filter 
software without 	config tar filter 
specific 	config tar 
prior written 	filter config git 
permission software 	config archiver 
provided copyright 	copyright rene scharfe 
holders contributors 	writes whole 
express implied 	block full 
warranties 	queues writes write 
including limited 	calls write 
implied warranties 	exactly one full 
merchantability fitness 	block pads 
particular purpose 	writes recordsize end 
disclaimed shall 	tar archives 
copyright 	marked nul bytes 
owner contributors 	follows rest 
liable direct 	block queues writes 
indirect incidental 	write calls 
special exemplary 	write exactly one 
consequential damages 	full block 
including 	pads writes recordsize 
limited procurement 	pax extended 
substitute goods 	header records format 
services loss 	contains size 
use data 	whole including first 
profits business 	keyword second 
interruption 	one function 
however caused 	constructs appends strbuf 
theory liability 	omit filters 
whether contract 	never command configured 
strict liability 	archive-zip.c zip 
tort including 	date zip time 
negligence 	zip dir 
otherwise arising 	zip dir size 
way use 	zip offset 
software even 	zip dir offset 
advised possibility 	zip dir 
damage aof 	entries max creator 
rewrite 	version magic 
buffer implementation 	version flags compression 
following code 	method mtime 
implement simple 	mdate crc compressed 
buffer used 	size size 
order accumulate 	filename length 
changes 	extra length end 
background process 	magic crc 
rewriting aof 	compressed size size 
file need 	end magic 
append use 	creator version version 
realloc large 	flags compression 
block 	method mtime mdate 
huge reallocs 	crc compressed 
always handled 	size size filename 
one could 	length extra 
expect via 	length comment length 
remapping pages 	disk attr 
level 	attr offset end 
may involve 	magic disk 
copying data 	directory start disk 
reason use 	entries disk 
list blocks 	entries size offset 
every block 	comment length 
aof 	end magic 
buf block 	extra size flags 
size bytes 	mtime end 
per block 	magic record size 
function free 	creator version 
old aof 	version disk directory 
rewrite 	start disk 
buffer needed 	entries disk entries 
initialize fresh 	size offset 
one tests 	end magic disk 
server aof 	offset number 
rewrite buf 	disks end dest 
blocks 	dest dest 
equal used 	max clamped dest 
first initialization 	clamped data 
well current 	size compression level 
size aof 	compressed size 
rewrite buffer 	stream maxsize buffer 
handler 	result size 
used send 	compressed size 
data child 	crc trailer header 
process aof 	size compressed 
rewrite send 	size crc header 
pieces aof 	size compressed 
differences 	size crc path 
buffer write 	buffer size 
child finishes 	driver args sha 
rewrite small 	path pathlen 
append data 	mode header dirent 
aof rewrite 	extra attr 
buffer 	compressed size crc 
allocating blocks 	direntsize method 
needed already 	deflated buffer stream 
got least 	flags size 
allocated block 	binary path without 
appending least 	prefix creator 
piece 	version buf readlen 
current block 	buf readlen 
already full 	zstream result 
first block 	len compressed trailer 
allocate need 	locator sha 
another block 	trailer clamped time 
log 	dos date 
every time 	dos time args 
cross blocks 	err zip 
respectively notice 	archiver copy clamp 
warning install 	max git 
file send 	deflate init raw 
data 	git deflate 
rewrite child 	bound xmalloc git 
one already 	deflate free 
write buffer 	git deflate end 
possibly composed 	copy copy 
multiple blocks 	copy copy write 
specified 	die copy 
write error 	copy copy 
happens returned 	copy copy copy 
otherwise number 	isascii userdiff 
bytes written 	find path userdiff 
returned aof 	find name 
file 	buffer binary crc 
implementation starts 	ascii utf 
background task 	warning error sha 
performs fsync 	hex isdir 
specified file 	isgitlink isreg islnk 
descriptor one 	islnk islnk 
aof 	isreg isreg open 
file another 	istream error 
called user 	sha hex sha 
switches appendonly 	file archive 
yes appendonly 	error sha hex 
runtime config 	crc entry 
command 	binary error sha 
rewrite operation 	hex zlib 
progress kill 	deflate raw 
wait child 	copy copy copy 
exit reset 	xrealloc copy 
buffer accumulating 	copy copy copy 
changes 	copy copy 
child saves 	copy zip dir 
close pipes 	data desc 
used ipc 	copy copy copy 
two processes 	copy copy 
called user 	copy copy copy 
switches 	copy copy 
appendonly appendonly 	copy copy zip 
yes runtime 	header data 
config command 	desc copy copy 
current working 	write die 
dir path 	write die write 
error 	die read 
messages correctly 	istream crc entry 
switched aof 	binary write 
wait rewrite 	die close 
complete order 	istream write zip 
append data 	data desc 
disk 	zip dir data 
write append 	desc git 
file buffer 	deflate init raw 
disk since 	read istream 
required write 	crc entry binary 
aof replying 	git deflate 
client 	die write die 
way client 	close istream 
socket write 	git deflate die 
entering loop 	git deflate 
accumulate aof 	end write die 
writes memory 	write zip 
buffer 	data desc zip 
write disk 	dir data 
function entering 	desc write die 
loop force 	free free 
argument fsync 	copy memcpy 
policy everysec 	memcpy memcpy copy 
may 	copy copy 
delay flush 	copy copy copy 
still fsync 	copy copy 
going background 	copy copy copy 
since instance 	copy copy 
linux write 	copy write die 
blocked 	write die 
background fsync 	copy copy copy 
anyway happens 	copy clamp 
remember aof 	copy clamp copy 
buffer flushed 	copy copy 
asap server 	write die write 
cron 	zip trailer 
function however 	write die write 
force write 	die sha 
regardless background 	hex localtime 
fsync seconds 	dos time xmalloc 
errors logging 	write archive 
append 	entries write zip 
fsync policy 	trailer free 
background fsyncing 	archiver copyright rene 
fsync still 	scharfe arm 
progress delay 	padding added end 
write couple 	simple reports 
seconds 	two bytes payload 
previous write 	size interested 
postponing remember 	mtime make sure 
postponing flush 	enough free 
already waiting 	space dictionary archive.c 
fsync finish 	archive usage 
less 	archivers archivers alloc 
two seconds 	archivers remote 
still postpone 	allow unreachable commit 
otherwise fall 	src len 
trough write 	buf free 
since wait 	fmt ctx sha 
two 	file archive 
seconds want 	check attr export 
perform single 	ignore attr 
write guaranteed 	export subst oid 
atomic least 	baselen len 
filesystem writing 	mode stage path 
real 	args write 
physical one 	entry bottom sha 
save server 	baselen filename 
killed think 	mode stage context 
much whole 	path args 
server stopping 	write entry check 
power 	path without 
problems alike 	prefix err sha 
want capture 	filename mode 
different events 	stage context sha 
delayed writes 	filename mode 
delay happens 	stage len 
pending 	ret sha filename 
fsync saving 	mode stage 
child active 	context next args 
two conditions 	write entry 
missing also 	context opts err 
use additional 	len next 
name 	name sha filename 
save samples 	mode stage 
useful graphing 	context ret path 
monitoring purposes 	paths pathspec 
performed write 	ret pathspec args 
reset postponed 	argv args 
flush 	prefix remote name 
sentinel zero 	commit sha 
limit logging 	archive time commit 
rate line 	oid colon 
per aof 	refnamelen oid mode 
write log 	err argc 
error 	argv args 
rate seconds 	name hint remote 
log aof 	format remote 
write error 	exec output compression 
record error 	level verbose 
code ftruncate 	list worktree attributes 
succeeded 	opts argc 
nwritten since 	argv prefix setup 
longer data 	prefix name 
aof handle 	hint remote nongit 
aof write 	args filename 
error recover 	ext prefixlen filename 
fsync 	alloc grow 
policy always 	strbuf detach memmem 
since reply 	memchr strbuf 
client already 	reset strbuf strbuf 
output buffers 	format commit 
contract user 	message strbuf strbuf 
acknowledged 	release free 
write data 	git attr 
synced disk 	git attr strbuf 
recover failed 	reset strbuf 
write leaving 	grow strbuf strbuf 
data buffer 	strbuf addstr 
however 	isdir isgitlink strbuf 
error stop 	addch setup 
accepting writes 	archive check git 
error condition 	check attr 
cleared trim 	size attr attr 
sds buffer 	isdir isgitlink 
write 	write entry isdir 
way undo 	write entry 
ftruncate next 	write archive entry 
call successful 	strlen xmalloc 
write aof 	xsnprintf hashcpy write 
error state 	directory write 
restore 	archive entry 
state log 	free strncmp free 
use aof 	isdir queue 
buffer small 	directory write directory 
enough maximum 	write archive 
comes arena 	entry write entry 
size 	memset memset 
minus overhead 	init desc unpack 
otherwise arbitrary 	trees git 
fsync appendfsync 	attr direction read 
rewrite yes 	recursive free 
children background 	strcmp isdir strbuf 
perform 	addbuf strbuf 
fsync needed 	addstr match pathspec 
aof fsync 	strbuf release 
defined fdatasync 	parse pathspec read 
linux order 	recursive free 
avoid flushing 	pathspec parse pathspec 
metadata 	path exists 
data disk 	die strchrnul 
create sds 	dwim die free 
representation pexpireat 	sha die 
command seconds 	lookup commit reference 
time live 	gently time 
cmd 	parse indirect die 
understand command 	entry isdir 
translating pexpireat 	die parse indirect 
command used 	parse options 
order translate 	die die die 
expire pexpire 	exit archive 
commands 	format filename usage 
pexpireat command 	options lookup 
retain precision 	archiver die die 
append file 	strlen setup 
time always 	git directory gently 
absolute relative 	git config 
make 	git config init 
sure use 	tar archiver 
strtoll convert 	init zip 
argument milliseconds 	archiver parse archive 
expire setex 	args setup 
expireat convert 	git directory parse 
absolute 	treeish arg 
time expire 	parse pathspec arg 
pexpire setex 	write archive 
psetex command 	strlen strlen strcmp 
targeting last 	match extension 
command appended 	trailing slash setup 
issue 	index instruct 
command needed 	attr read index 
translate expire 	must consistent 
pexpire expireat 	parse pathspec path 
pexpireat translate 	exists also 
setex psetex 	pathspec patterns dependent 
pexpireat 	big trouble 
commands need 	test one separately 
translation need 	remotes allowed 
translation already 	fetch actual 
operated command 	refs need least 
vector replication 	one parameter 
append 	ish know die 
aof buffer 	error could 
flushed disk 	die error message 
entering loop 	specific could 
client positive 	write need character 
reply operation 	character ensure 
performed 	prefix non empty 
background append 	match tar 
file rewriting 	actual filename copyright 
progress want 	franck bui 
accumulate differences 	huu copyright rene 
child current 	scharfe inject 
one 	fake format field 
buffer child 	beginning arguments 
process work 	format inferred 
append differences 	output filename way 
append file 	format options 
aof loading 	start reading spit 
redis 	stdout output 
commands always 	file output argc 
executed context 	argv remote 
client order 	exec name hint 
load append 	buf transport 
file need 	remote format argc 
create 	argv prefix 
fake client 	exec output remote 
fake client 	local opts 
slave waiting 	open die errno 
synchronization redis 	dup die 
send replies 	errno close remote 
client 	die transport 
replay append 	transport connect archive 
log file 	format filename 
success returned 	packet write 
non fatal 	packet write packet 
error append 	flush packet 
file 	read line die 
zero length 	strcmp starts 
err returned 	die starts die 
fatal error 	die packet 
error message 	read line die 
logged program 	recv sideband 
exists 	transport disconnect parse 
offset latest 	options create 
well formed 	output file run 
command loaded 	remote archiver 
temporarily disable 	setvbuf write archive 
aof prevent 	trailing slash 
exec 	setup index instruct 
feeding multi 	attr read 
file read 	index must consistent 
serve clients 	parse pathspec 
time time 	path exists 
free free 	also pathspec patterns 
free 	dependent big 
discard crlf 	trouble test one 
command lookup 	separately remotes 
run command 	allowed fetch actual 
context fake 	refs need 
client fake 	least one parameter 
client 	ish know 
reply fake 	die error could 
client never 	die error 
blocked clean 	message specific could 
command code 	write need 
may 	character character ensure 
changed argv 	prefix non 
argc use 	empty match tar 
argv argc 	actual filename 
client instead 	copyright franck bui 
local variables 	huu copyright 
point 	rene scharfe 
reached eof 	inject fake format 
reached without 	field beginning 
errors client 	arguments format inferred 
middle multi 	output filename 
exec log 	way format options 
error 	start reading 
quit loaded 	spit stdout archive.c 
cleanup caller 	archive usage 
read error 	archivers archivers alloc 
feof fall 	archivers remote 
unexpected eof 	allow unreachable commit 
unexpected 	src len 
aof end 	buf free fmt 
file make 	ctx sha 
sure aof 	file archive check 
file descriptor 	attr export 
points end 	ignore attr 
file 	export subst oid 
truncate call 	baselen len 
format error 	mode stage path 
aof rewrite 	args write 
writing writing 	entry bottom sha 
bulk bulk 	baselen filename 
placed 	mode stage context 
rio since 	path args 
adds redis 	write entry check 
dependency avoid 	path without 
decoded help 	prefix err sha 
copy write 	filename mode 
often 	stage context sha 
child process 	filename mode 
function called 	stage len ret 
emit commands 	sha filename 
needed rebuild 	mode stage context 
list function 	next args 
returns 	write entry 
error success 	context opts err 
emit commands 	len next 
needed rebuild 	name sha filename 
function returns 	mode stage 
error success 	context ret path 
emit 	paths pathspec 
commands needed 	ret pathspec args 
rebuild sorted 	argv args 
function returns 	prefix remote name 
error success 	commit sha 
write either 	archive time commit 
key 	oid colon 
currently selected 	refnamelen oid mode 
item hash 	err argc 
argument passes 	argv args name 
valid redis 	hint remote 
hash iterator 	format remote exec 
filed 	output compression 
specifies write 	level verbose 
key either 	list worktree attributes 
obj hash 	opts argc 
key obj 	argv prefix setup 
hash function 	prefix name 
returns 	hint remote nongit 
error non 	args filename 
zero success 	ext prefixlen filename 
emit commands 	alloc grow 
needed rebuild 	strbuf detach memmem 
hash function 	memchr strbuf 
returns 	reset strbuf strbuf 
error success 	format commit 
function called 	message strbuf strbuf 
child rewriting 	release free 
aof file 	git attr git 
read difference 	attr strbuf 
accumulated 	reset strbuf grow 
parent buffer 	strbuf strbuf 
concatenated end 	strbuf addstr 
rewrite pipe 	isdir isgitlink strbuf 
buffer size 	addch setup 
linux systems 	archive check git 
write 	check attr 
sequence commands 	size attr attr 
able fully 	isdir isgitlink 
rebuild dataset 	write entry isdir 
filename used 	write entry 
rewriteaof bgrewriteaof 	write archive entry 
order 	strlen xmalloc 
minimize number 	xsnprintf hashcpy write 
commands needed 	directory write 
rewritten log 	archive entry free 
redis uses 	strncmp free 
variadic commands 	isdir queue directory 
possible 	write directory 
rpush sadd 	write archive entry 
zadd however 	write entry 
max aof 	memset memset 
rewrite items 	init desc unpack 
per cmd 	trees git 
items 	attr direction read 
per time 	recursive free 
inserted single 	strcmp isdir strbuf 
command note 	addbuf strbuf 
use different 	addstr match pathspec 
temp name 	strbuf release 
compared 	parse pathspec read 
one used 	recursive free 
rewrite append 	pathspec parse pathspec 
file background 	path exists 
function iterate 	die strchrnul dwim 
writing every 	die free 
entry 	sha die lookup 
key already 	commit reference 
expired skip 	gently time 
save key 	parse indirect die 
associated emit 	entry isdir 
command key 	die parse indirect 
save 	parse options 
expire time 	die die die 
read diff 	exit archive 
parent process 	format filename usage 
time time 	options lookup 
initial slow 	archiver die die 
fsync 	strlen setup 
parent still 	git directory gently 
sending data 	git config 
order make 	git config init 
next fsync 	tar archiver 
faster read 	init zip archiver 
times 	parse archive 
data parent 	args setup git 
read forever 	directory parse 
server may 	treeish arg 
receive data 	parse pathspec arg 
clients faster 	write archive 
able 	strlen strlen strcmp 
send data 	match extension 
child read 	trailing slash setup 
data loop 	index instruct 
soon good 	attr read index 
chance data 	must consistent 
come 	parse pathspec path 
looks like 	exists also 
wasting time 	pathspec patterns dependent 
abort happens 	big trouble 
without data 	test one separately 
start counting 	remotes allowed 
zero 	fetch actual refs 
stop contiguous 	need least 
timeouts ask 	one parameter ish 
master stop 	know die 
sending diffs 	error could 
read ack 	die error message 
server 	specific could 
seconds timeout 	write need character 
normally reply 	character ensure 
asap lose 	prefix non empty 
reply sure 	match tar 
child eventually 	actual filename copyright 
terminated 	franck bui 
read diff 	huu copyright rene 
write received 	scharfe inject 
diff file 	fake format field 
make sure 	beginning arguments 
data remain 	format inferred output 
output 	filename way 
buffers use 	format options start 
rename make 	reading spit 
sure file 	stdout output file 
changed atomically 	output argc 
generate file 	argv remote 
aof 	exec name hint 
rewrite pipes 	buf transport 
ipc handler 	remote format argc 
called aof 	argv prefix 
rewriting child 	exec output remote 
sends single 	local opts 
signal 	open die errno 
stop sending 	dup die 
buffer diffs 	errno close remote 
parent sends 	die transport 
well acknowledge 	transport connect archive 
send ack 	format filename 
inform 	packet write packet 
user since 	write packet 
side children 	flush packet read 
use timeout 	line die 
kernel buffer 	strcmp starts 
write children 	die starts die 
terminated 	die packet 
handler since 	read line die 
called one 	recv sideband 
time rewrite 	transport disconnect parse 
create pipes 	options create 
used parent 	output file run 
child 	remote archiver 
process ipc 	setvbuf write archive 
rewrite data 	trailing slash 
pipe used 	setup index instruct 
send aof 	attr read 
incremental diffs 	index must consistent 
child 	parse pathspec 
two pipes 	path exists also 
used children 	pathspec patterns 
signal finished 	dependent big trouble 
rewrite data 	test one 
written another 	separately remotes 
parent 	allowed fetch actual 
acknowledge understood 	refs need 
condition parent 	least one parameter 
children data 	ish know 
children parent 	die error could 
ack children 	die error 
parent 	message specific could 
ack parent 	write need 
children data 	character character ensure 
non blocking 	prefix non 
aof background 	empty match tar 
rewrite rewriting 	actual filename 
append 	copyright franck bui 
file background 	huu copyright 
works user 	rene scharfe inject 
calls bgrewriteaof 	fake format 
redis calls 	field beginning arguments 
function forks 	format inferred 
child 	output filename 
rewrite append 	way format options 
file temp 	start reading 
file parent 	spit stdout archive.h 
accumulates differences 	baselen commit 
server aof 	sha commit time 
rewrite 	pathspec compression 
buf child 	level name archiver 
finished exists 	archiver args 
parent trap 	flags data archiver 
exit code 	args write 
append data 	entry argc argv 
accumulated 	prefix setup 
server aof 	prefix name hint 
rewrite buf 	remote filename 
temp file 	sha file archive 
rename temp 	archive argv-array.c 
file actual 	empty argv fmt 
file 	arg argv 
name file 	ret alloc 
reopened append 	grow argv push 
file profit 	nodup xstrdup 
child parent 	start strbuf vaddf 
per second 	end argv 
appendseldb 	push nodup strbuf 
order force 	detach start 
next call 	arg argv push 
feed append 	end argv 
file issue 	push free free 
command differences 	free argv 
accumulated 	init xcalloc argv 
parent server 	init argv-array.h 
aof rewrite 	empty argv argv 
buf start 	argc alloc 
statement safe 	argv argv argv 
merge unreached 	fmt argv 
update 	argv argv 
server aof 	argv argv argv 
current size 	attr.c git 
field explicitly 	attr git attr 
stat check 	git attr 
size file 	unknown next attr 
useful 	maybe macro 
rewrite restart 	maybe real name 
normally size 	attr cannot 
updated adding 	trust maybe real 
write length 	check attr 
current length 	attr name namelen 
much 	name namelen 
faster background 	name len hval 
append file 	pos name 
rewriting bgrewriteaof 	attr setto pattern 
terminated work 	patternlen nowildcardlen 
handle flush 	flags pat attr 
differences 	macro num 
accumulated parent 	attr state 
rewritten aof 	blank src lineno 
remaining thing 	len line 
rename temporary 	src lineno macro 
file configured 	namelen num 
file 	attr name states 
file descriptor 	res macro 
used aof 	prev origin originlen 
writes want 	num matches 
close rename 	alloc attrs setto 
calls block 	builtin attr 
server 	res line src 
old file 	lineno macro 
deletion two 	list res line 
possible scenarios 	lineno use 
aof disabled 	index path macro 
one time 	res buf 
rewrite 	lineno bufp path 
temporary file 	macro res 
renamed configured 	buf lineno 
file file 	path macro res 
already exists 	elem match 
unlinked may 	attr elem system 
block 	wide path 
server aof 	dirlen elem info 
enabled rewritten 	len namelen 
aof immediately 	pathbuf pathname pathlen 
start receiving 	basename offset 
writes temporary 	pat baselen pattern 
file 	prefix isdir 
renamed configured 	attr rem rem 
file original 	check attr 
aof file 	path pathlen basename 
descriptor closed 	offset stk 
since last 	rem rem stk 
reference 	path num 
file closing 	check stk pathlen 
causes underlying 	rem dirlen 
file unlinked 	last slash 
may block 	basename offset path 
server mitigate 	num check 
blocking 	path num check 
effect unlink 	count git 
operation either 	attr direction hash 
caused rename 	name memcmp 
scenario close 	invalid attr name 
scenario use 	flex alloc 
background 	mem realloc git 
take care 	attr strlen 
first make 	strcspn strchr invalid 
scenario identical 	attr name 
scenario opening 	xmemdupz git attr 
target file 	strspn strspn 
exists 	strcspn strlen starts 
unlink operation 	strlen strspn 
rename executed 	strcspn invalid attr 
upon calling 	name strspn 
close descriptor 	parse attr 
everything guarantee 	xcalloc git attr 
atomicity 	memcpy parse 
already happened 	exclude pattern warning 
care outcome 	parse attr 
duration close 	free free free 
operation file 	free free 
descriptor released 	parse attr line 
aof 	alloc grow 
disabled care 	xcalloc handle attr 
fails oldfd 	line fopen 
handle one 	warn inaccessible xcalloc 
notable old 	fgets skip 
file exist 	utf bom strlen 
aof 	handle attr 
enabled current 	line fclose read 
aof filedes 	blob data 
later rename 	index xcalloc 
temporary file 	handle attr line 
unlink target 	free read 
file 	attr index read 
exists reference 	attr file 
oldfd aof 	read attr file 
disabled need 	read attr 
aof file 	index read attr 
descriptor file 	index xcalloc 
close 	attr attr attr 
aof enabled 	unset free 
replace old 	attr elem system 
one make 	path git 
sure issued 	env git attr 
clear regular 	system read 
aof 	attr file git 
buffer since 	etc gitattributes 
contents written 	xdg config home 
aof background 	read attr 
rewrite buffer 	file bare 
change state 	repository read attr 
wait 	xstrdup debug 
rewrite needed 	push read attr 
asynchronously close 	file git 
overwritten aof 	path info attributes 
sigusr whitelisted 	xcalloc bootstrap 
way kill 	attr stack strlen 
child 	strncmp debug 
without tirggering 	pop free attr 
error conditon 	elem bare 
schedule rewrite 	repository strlen memchr 
waiting aof 	strbuf strbuf 
arena.c opt 	addch strbuf addstr 
dirty 	read attr 
mult dirty 	strbuf setlen strbuf 
mult arena 	detach debug 
bin info 	push strbuf release 
map bias 	match basename 
map misc 	match pathname 
offset 	debug macroexpand one 
arena maxrun 	path matches 
large maxclass 	fill one fill 
small maxrun 	one prepare 
small run 	attr stack fill 
tab nlclasses 	collect attrs 
nhclasses 	collect attrs alloc 
arena arena 	handle git 
run dirty 	attributes see gitattributes 
cleaned decommitted 	description file 
arena chunk 	syntax documentation technical 
run bin 	api gitattributes 
arena 	txt description api 
chunk run 	one basic 
bin size 	design decision going 
miscelm miscelm 	support insanely 
miscelm chunk 	large number attributes 
pageind mapbits 	randomly chosen 
miscelm 	prime attribute 
miscelm size 	name cannot begin 
qsize size 	must consist 
large run 	characters matched pattern 
size next 	decide exc 
size qsize 	flag one rule 
ret 	gitattributes file 
miscelm qsize 	macro attr pointer 
qsize miscelm 	git attr 
arena chunk 	defined macro pattern 
pageind npages 	points filename 
arena chunk 	pattern rule applies 
pageind 	memory pointed 
npages arena 	part memory block 
chunk pageind 	allocated match 
npages miscelm 	attr instance either 
arena chunk 	num attr 
pageind npages 	number attributes 
miscelm 	affected rule state 
node arena 	listing attributes 
node cache 	listed appear file 
arena node 	macros unexpanded 
dirty run 	parse whitespace delimited 
bin 	attribute state 
info ret 	attr attr attr 
regind miscelm 	attr starting 
rpages run 	src write results 
ptr chunk 	pointer remainder 
pageind mapbits 	leading whitespace removed 
binind 	error first 
bin info 	pass count attr 
regind chunk 	states second 
run ind 	pass fill attr 
npages chunk 	states like 
run ind 	info exclude gitignore 
chunk 	attribute information 
run ind 	come many 
arena pages 	places gitattribute file 
sub pages 	directory gitattribute 
cactive diff 	file parent directory 
arena chunk 	match goes 
run 	recursively upwards like 
ind flag 	gitignore git 
dirty flag 	dir info attributes 
decommitted need 	overrides file 
pages total 	later entries earlier 
pages rem 	match list 
pages 	would entries info 
flags flag 	attributes earliest 
unzeroed mask 	reading file top 
arena run 	bottom gitattribute 
size zero 	root directory reading 
chunk miscelm 	file top 
flag 	bottom current directory 
dirty flag 	scan list 
decommitted run 	backwards find 
ind need 	first match exactly 
pages flag 	excluded dir 
unzeroed mask 	deal gitignore gitattributes 
arena 	file might 
run size 	index allow operation 
zero arena 	sparsely work 
run size 	read bottom attribute 
zero arena 	stack built 
run size 	attribute definitions followed 
binind 	contents prefix 
chunk miscelm 	etc gitattributes file 
flag dirty 	specified core 
flag decommitted 	attributesfile contents gitattribute 
run ind 	files directories 
need pages 	closer root ones 
flag 	deeper directories 
unzeroed arena 	pushed stack top 
chunk arena 	stack always 
chunk zero 	keep contents 
arena chunk 	git dir info 
hooks zero 	attributes checking 
commit 	use entries near 
chunk arena 	top stack 
zero commit 	preferring git dir 
chunk chunk 	info attributes 
hooks arena 	gitattributes deeper directories 
chunk zero 	shallower ones 
commit 	use built pop 
flag unzeroed 	info one 
flag decommitted 	always top stack 
arena chunk 	pop ones 
arena chunk 	directories prefix path 
spare chunk 	checking loop 
hooks 	see root one 
committed arena 	whose origin 
usize index 	empty builtin 
arena usize 	one whose origin 
index arena 	without popping 
usize index 	read parent directories 
arena 	push bootstrap 
usize index 	attr stack added 
arena oldsize 	loop stopped 
usize arena 	popping root element 
oldsize usize 	whose attr 
arena node 	stack origin empty 
arena 	push info 
node arena 	one top stack 
chunk hooks 	collect attributes 
usize alignment 	path pointed check 
zero csize 	attr num 
ret commit 	non zero attributes 
arena 	check collected 
usize alignment 	otherwise attributes collected 
zero ret 	count number 
chunk hooks 	attributes attr.h 
csize arena 	git attr git 
chunk usize 	attr attr 
chunk 	git attr path 
hooks csize 	git attr 
arena chunk 	check path num 
oldsize usize 	check git 
udiff udiff 	attr direction attribute 
arena chunk 	pointer opaque 
oldsize 	structure given gitattribute 
usize udiff 	corresponds use 
cdiff chunk 	check git attr 
hooks nchunk 	check results 
arena chunk 	send one git 
hooks chunk 	attr check 
oldsize 	git check attr 
usize zero 	member tells 
nchunk udiff 	unset one returned 
cdiff err 	name attribute 
commit arena 	represented argument 
chunk oldsize 	pointer delimited part 
usize 	data structure 
zero err 	modified freed retrieve 
chunk hooks 	attributes apply 
nchunk udiff 	specified path num 
cdiff arena 	number attributes 
size search 	path check point 
size 	newly allocated 
key miscelm 	git attr check 
arena size 	objects describing 
zero run 	attributes values check 
arena size 	must free 
zero chunk 	caller attr base85.c 
run 	dst buffer 
arena size 	len acc cnt 
binind run 	buf data 
arena size 	bytes acc cnt 
binind chunk 	val buf 
run dirty 	len len 
mult 	size prep say 
arena dirty 	error error 
mult arena 	error say say 
dirty mult 	say say 
arena threshold 	say strcmp strlen 
arena ndirty 	encode strcmp 
rdelm 	decode strcmp encode 
chunkselm npages 	nothing nothing 
chunk miscelm 	nothing detect overflow 
pageind arena 	basename.c path 
npurge threshold 	path buf dos 
arena chunk 	drive prefix 
hooks 	tentative skip dos 
npurge purge 	drive prefix 
runs sentinel 	dir sep dir 
purge chunks 	sep dir 
sentinel rdelm 	sep skip dos 
rdelm next 	drive prefix 
chunkselm 	dir sep 
nstashed npages 	dir sep dir 
chunkselm next 	sep dir 
zero chunk 	sep strbuf reset 
chunk miscelm 	strbuf addf 
pageind run 	adapted libiberty basename 
run 	posix says 
size arena 	dirname dirname dirname 
chunk hooks 	posix says 
purge runs 	ignore trailing slashes 
sentinel purge 	bisect--helper.c git 
chunks sentinel 	bisect helper usage 
npurged 	argc argv 
nmadvise rdelm 	prefix next checkout 
chunkselm npages 	options parse 
size pageind 	options usage options 
run size 	bisect next 
flag unzeroed 	next bisect.c 
flags 	good revs skipped 
decommitted chunk 	revs current 
miscelm arena 	bad oid argv 
chunk hooks 	checkout argv 
purge runs 	show branch term 
sentinel purge 	bad term 
chunks 	good entry commit 
sentinel rdelm 	list commit 
rdelm next 	elem elem weight 
chunkselm chunkselm 	commit count 
next addr 	debug counted list 
size zeroed 	commit flags 
committed 	size buf subject 
chunk miscelm 	start subject 
pageind decommitted 	len list best 
run arena 	best distance 
chunk hooks 	distance flags commit 
npurge npurgeable 	distance list 
npurged 	cnt distance 
purge runs 	flags buf obj 
sentinel purge 	list weights 
chunks sentinel 	find counted commit 
ndirty arena 	flags flags 
arena chunk 	list reaches find 
size 	list best 
run ind 	next last weights 
run pages 	flags refname 
flag dirty 	oid flags data 
flag decommitted 	good prefix 
size run 	delim joined hexs 
ind 	list tried 
run pages 	show count skipped 
nrun size 	first next 
nrun pages 	count val list 
prun size 	count cur 
prun pages 	previous prn index 
arena 	list tried 
chunk run 	count skipped 
run ind 	first revs prefix 
size bin 	bad format 
info arena 	good format read 
chunk run 	paths rev 
miscelm 	argv revs tried 
run ind 	bad oid 
offset length 	filename str res 
arena run 	bisect rev 
dirty cleaned 	checkout bisect rev 
decommitted chunk 	hex res 
miscelm 	sha rev rev 
size run 	bad hex 
ind run 	good hex hex 
pages flag 	bad hex 
dirty flag 	good hex checkout 
decommitted flags 	result rev 
arena 	rev prefix revs 
chunk run 	pending copy 
committed arena 	res prefix 
chunk run 	checkout filename prefix 
oldsize newsize 	commit opt 
miscelm pageind 	read bad read 
head 	good str 
npages flag 	filename prefix checkout 
dirty flag 	revs tried 
decommitted flag 	steps bisect rev 
unzeroed mask 	log count 
tail npages 	distance weight read 
arena 	sha file 
chunk run 	weight sha hex 
oldsize newsize 	sha hex 
dirty miscelm 	find commit subject 
pageind head 	weight oidcmp 
npages flag 	xcalloc weight qsort 
dirty 	snprintf name 
flag decommitted 	decoration free 
flag unzeroed 	count interesting parents 
mask tail 	weight show 
miscelm tail 	list weight weight 
run tail 	show list 
npages 	weight weight count 
bin miscelm 	distance clear 
bin run 	distance halfway show 
miscelm bin 	list weight 
run miscelm 	weight weight weight 
bin run 	show list 
arena 	weight weight halfway 
bin run 	show list 
binind bin 	best bisection best 
info arena 	bisection sorted 
bin binind 	show list show 
bin info 	list xcalloc 
run 	find bisection weight 
ret chunk 	free strbuf 
arena tbin 	addstr strbuf 
binind prof 	addstr strcmp xmalloc 
accumbytes nfill 	oidcpy starts 
bin run 	sha append starts 
ptr 	sha append 
ptr bin 	strbuf release strbuf 
info zero 	getline strbuf 
redzone size 	trim dequote argv 
ptr usize 	die strbuf 
offset arena 	release fclose strbuf 
redzone 	addstr sha 
corruption ptr 	hex strbuf addch 
bin info 	strbuf detach 
reset error 	sha lookup prn 
size redzone 	sqrti sqrti 
size ptr 	oidcmp filter skipped 
bin 	skip away 
info redzone 	init revisions argv 
size arena 	push argv 
dalloc junk 	pushf oid 
small ptr 	hex argv pushf 
usize binind 	sha hex 
bin 	argv push read 
info arena 	bisect paths 
size zero 	setup revisions prepare 
ret bin 	revision walk 
run binind 	die mark edges 
arena size 	uninteresting print 
zero 	commit list oid 
ret usize 	hex exit 
random offset 	git path bisect 
run miscelm 	expected rev 
idump index 	stat isreg fopen 
tsd arena 	strbuf getline 
usize 	strcmp oid hex 
alignment zero 	strbuf release 
ret alloc 	fclose memcpy sha 
size leadsize 	hex update 
trailsize run 	update run 
chunk miscelm 	command opt exit 
rpages 	run command 
head miscelm 	opt lookup commit 
head run 	reference die 
run ind 	sha hex alloc 
dirty decommitted 	commit reference 
index tsd 	commit reference expected 
arena 	rev oid 
usize alignment 	hex sha hex 
zero tcache 	strcmp strcmp 
ret ptr 	strcmp strcmp exit 
size chunk 	exit sha 
pageind binind 	hex sha hex 
chunk 	sha hex 
run bin 	warning free bad 
binind bin 	good commits 
info arena 	merge bases 
chunk run 	many hashcmp handle 
bin arena 	bad merge 
chunk 	sha lookup sha 
run bin 	lookup handle 
arena chunk 	skipped merge exit 
ptr bitselm 	bisect checkout 
junked pageind 	free free commit 
rpages ind 	list bisect 
run 	rev setup bisect 
bin bin 	common clear 
info binind 	commit marks free 
arena chunk 	git pathdup 
ptr bitselm 	die stat isreg 
arena chunk 	check ancestors 
ptr 	check merge bases 
pageind bitselm 	open warning 
run bin 	strerror close free 
rpages ind 	init revisions 
arena chunk 	git config 
ptr pageind 	log commit git 
bitselm 	path fopen 
ptr usize 	die strerror strbuf 
arena dalloc 	getline strbuf 
junk large 	detach strbuf getline 
arena chunk 	strbuf detach 
ptr junked 	strbuf release fclose 
pageind 	read bisect 
miscelm run 	terms read bisect 
usize index 	refs die 
arena chunk 	check good ancestors 
ptr arena 	bad bisect 
chunk ptr 	rev setup bisect 
arena 	common find 
chunk ptr 	bisection managed skipped 
oldsize size 	exit skipped 
pageind miscelm 	commits oid hex 
run oldindex 	exit exit 
index arena 	hashcmp exit 
chunk 	skipped commits sha 
ptr oldsize 	hex show 
usize min 	diff exit estimate 
usize max 	bisect steps 
zero pageind 	bisect checkout log 
npages followsize 	exp remember 
run 	update flag allocation 
usize splitsize 	truly stupid 
size flag 	algorithm used bisection 
dirty flag 	care enough 
unzeroed mask 	care barely enough 
oldindex index 	avoid recursing 
ptr 	non merge entries 
old usize 	cut something 
usize arena 	going halfway halfway 
ralloc junk 	debug bisect 
large ptr 	desc sort enough 
oldsize usize 	dist zero 
min 	positive weight 
usize max 	number interesting commits 
zero chunk 	reach including 
arena ret 	especially weight means 
ptr oldsize 	reach changing 
size extra 	commits uninteresting one 
zero 	traversal pathspec 
usize min 	weight means one 
usize max 	parent distance 
tsd arena 	yet computed weight 
usize alignment 	means one 
zero tcache 	parent distance unknown 
tsd 	running count 
arena ptr 	distance first zero 
oldsize size 	positive distance 
alignment zero 	otherwise known reach 
tcache ret 	changing commit 
usize copysize 	gets weight one 
arena 	parent resulting 
ret arena 	reach one 
dss prec 	commit parent reach 
dirty mult 	run expensive 
arena dss 	count distance single 
dirty mult 	strand pearls 
nactive 	however one parents 
ndirty astats 	cannot distance 
bstats lstats 	one since usually 
hstats bin 	reach ancestor 
ind arena 	would end counting 
bin bin 	twice way 
info 	first count distance 
pad size 	merges usual 
run size 	way fill blanks 
perfect run 	cheaper algorithm 
size actual 	happen exactly half 
run size 	way weight 
nregs 	unknown known 
perfect nregs 	one counted otherwise 
actual nregs 	inherit directly 
align min 	happen exactly half 
bin info 	way count 
header size 	number total changing 
arena 	items list 
arena arena 	reversing list real 
arena chunk 	work finding 
map misc 	bisection commit function 
arena mapbits 	passing skipped 
size encode 	first special means 
arena 	want know 
miscelm key 	first commit list 
arena mapbits 	skipped want 
size decode 	test commit away 
arena miscelm 	indeed skipped 
key chunk 	first commit skipped 
addr 	cannot take 
arena miscelm 	shortcut list 
pageind arena 	find first non 
mapbits arena 	skipped commit 
mapbits size 	fully filtered list 
decode page 	use skipped 
ceiling 	first mean found 
index size 	first commit 
size index 	skipped skipped first 
run quantize 	back function 
page ceiling 	returns move current 
page 	tried list 
ceiling index 	means know skipped 
size size 	move current 
index run 	filtered list pseudo 
quantize run 	random number 
quantize next 	generator man rand 
run 	used properly 
quantize arena 	seed argument increased 
miscelm key 	one call 
arena miscelm 	matter application 
key size 	custom integer square 
arena miscelm 	root http 
size 	wikipedia wiki integer 
run quantize 	square root 
arena miscelm 	rev argv argv 
size arena 	ignored setup 
miscelm key 	revisions xxx leak 
arena mapbits 	rev argv 
unallocated 	revs may still 
size arena 	pointing check 
avail insert 	merge bases checks 
arena miscelm 	merge bases 
arena mapbits 	bad one bad 
unallocated size 	means user 
arena 	assumed something wrong 
avail arena 	must exit 
miscelm arena 	non error code 
miscelm arena 	one good 
mapbits unallocated 	old good 
size arena 	nothing one skipped 
mapbits 	know warn 
dirty arena 	know check ask 
mapbits dirty 	user test 
meld arena 	save pending objects 
miscelm arena 	cleaned later 
mapbits unallocated 	bisect common calls 
size 	prepare revision 
arena mapbits 	walk right away 
dirty arena 	together leak 
mapbits dirty 	pending makes sole 
extent node 	owner list 
size extent 	pending objects clean 
node 	objects used 
dirty linkage 	reused check good 
init extent 	ancestors bad 
node dirty 	checks good 
insert arena 	revs ancestor bad 
chunk dirty 	rev need 
npages 	check merge bases 
extent node 	merge must 
dirty arena 	tested user source 
chunk dirty 	code tested 
npages arena 	user exit check 
chunk dirty 	file bisect 
npages 	ancestors exists bisecting 
bitmap full 	good rev 
bitmap sfu 	check good revs 
arena run 	ancestor bad 
miscelm arena 	rev create file 
miscelm rpages 	bisect ancestors 
uintptr 	git diff pretty 
chunk addr 	commit without 
arena mapbits 	one fork exec 
arena ptr 	diff init 
small binind 	diff options 
arena run 	pretty diff init 
regind 	terms used 
arena miscelm 	bisect session stored 
rpages arena 	bisect terms 
run miscelm 	read store adapt 
arena miscelm 	messages accordingly 
rpages arena 	bad good use 
run 	convention exiting 
miscelm bitmap 	exit code means 
bitmap unset 	bisection process 
jemalloc valgrind 	finished successfully calling 
make mem 	shell script 
undefined memset 	exit checkout non 
jemalloc 	zero bisection 
valgrind make 	process checkout trial 
mem defined 	commit instead 
size arena 	simply updates bisect 
run page 	head exit 
mark zeroed 	bad commit 
chunk 	also skip commit 
ceiling chunk 	means bisection 
ceiling stats 	process succeeded estimate 
cactive arena 	number bisect 
mapbits unallocated 	steps left current 
size arena 	step included 
mapbits 	excluded probability steps 
dirty arena 	left looks 
avail arena 	like means bisect.h 
run dirty 	list reaches 
arena cactive 	find list tried 
update arena 	show count 
mapbits 	skipped first revs 
unallocated arena 	flags show 
mapbits unzeroed 	timestamp hdr termination 
arena mapbits 	header prefix 
unallocated arena 	prefix checkout bad 
mapbits unzeroed 	good bitmap.c 
arena 	bitmap self 
run dirty 	pos block old 
insert arena 	size self 
avail insert 	pos block self 
chunk addr 	pos block 
arena run 	bitmap ewah running 
miscelm 	empty words 
arena miscelm 	last word ewah 
pageind arena 	bitmap blowup 
mapbits dirty 	self count self 
arena mapbits 	original size 
decommitted commit 	word self callback 
arena 	data word 
run split 	offset self count 
jemalloc valgrind 	self big 
make mem 	small bitmap bitmap 
defined arena 	xmalloc xcalloc 
run zero 	ewah block 
arena 	realloc memset ewah 
mapbits unzeroed 	mask ewah 
arena run 	block ewah mask 
zero arena 	ewah block 
run page 	ewah mask ewah 
validate zeroed 	ewah ewah 
arena 	empty words ewah 
run page 	bitmap ewah 
mark zeroed 	iterator init ewah 
jemalloc valgrind 	iterator next 
make mem 	alloc grow realloc 
undefined arena 	memset ewah 
mapbits 	iterator init ewah 
large arena 	iterator next 
mapbits unzeroed 	callback ewah bit 
arena mapbits 	ctz callback 
large arena 	ewah bit popcount 
mapbits unzeroed 	memset free 
arena 	free copyright 
run split 	git hub inc 
large helper 	copyright daniel 
arena run 	lemire cliff moon 
split large 	david intosh 
helper chunk 	robert becho google 
addr 	inc veronika 
arena run 	zenz program free 
miscelm arena 	software redistribute 
miscelm pageind 	modify terms gnu 
arena mapbits 	general license 
dirty arena 	published free software 
mapbits 	foundation either 
decommitted commit 	version license option 
arena run 	later version 
split arena 	program distributed hope 
mapbits unzeroed 	useful without 
arena mapbits 	warranty without even 
small 	implied warranty 
arena run 	merchantability fitness 
page validate 	particular purpose see 
zeroed jemalloc 	gnu general 
valgrind make 	license details received 
mem undefined 	copy gnu 
arena 	general license along 
mapbits allocated 	program write 
arena mapbits 	free software foundation 
allocated arena 	inc franklin 
mapbits unallocated 	street fifth floor 
size arena 	boston usa 
mapbits 	blame.c blame usage 
unallocated size 	blame opt 
arena mapbits 	usage longest file 
dirty arena 	longest author 
mapbits dirty 	max orig digits 
extent node 	max digits 
init 	max score digits 
extent node 	show root 
achunk chunk 	reverse blank 
malloc mutex 	boundary incremental xdl 
unlock chunk 	opts abbrev 
alloc wrapper 	whole file rename 
commit 	show progress 
chunk dalloc 	blame date mode 
wrapper arena 	blame date 
chunk decommit 	width mailmap num 
chunk dalloc 	read blob 
wrapper malloc 	num patch num 
mutex 	commits blame 
chunk alloc 	move score blame 
cache arena 	copy score 
chunk chunk 	refcnt previous next 
dalloc cache 	commit suspects 
arena chunk 	file blob sha 
alloc 	mode guilty 
hard arena 	path progress blamed 
chunk alloc 	lines file 
arena mapbits 	file ctxlen 
unallocated jemalloc 	hunk func data 
valgrind make 	xpp xecfg 
mem 	ecb path mode 
undefined arena 	sha sha 
bitselm size 	valid buf buf 
arena bitselm 	size textconv 
arena bitselm 	opt file file 
arena mapbits 	size next 
jemalloc 	lno num lines 
valgrind make 	suspect lno 
mem defined 	score list list 
arena bitselm 	tail head 
size arena 	compare commits revs 
bitselm arena 	path buf 
bitselm 	buf size ent 
arena mapbits 	num lines 
unzeroed arena 	lineno scoreboard 
mapbits unallocated 	ent next porigin 
arena chunk 	sorted commit 
init spare 	path commit path 
arena 	origin parent 
chunk init 	origin porigin diff 
hard arena 	opts paths 
avail insert 	name parent origin 
arena mapbits 	porigin diff 
allocated arena 	opts queue queue 
mapbits 	dst src 
allocated arena 	lno data lno 
mapbits unallocated 	split tlno 
size arena 	plno parent chunk 
mapbits unallocated 	end lno 
size arena 	blamed unblamed split 
mapbits 	entry split 
dirty arena 	head tail next 
mapbits dirty 	dstq srcq 
arena mapbits 	tlno offset 
decommitted arena 	parent diffp next 
mapbits decommitted 	len next 
arena 	len parent offset 
avail arena 	dstq srcq 
mapbits dirty 	start count start 
arena run 	count data 
dirty chunk 	target parent file 
deregister arena 	file newdest 
mapbits 	score best far 
decommitted chunk 	ent tlno 
hooks decommit 	plno parent split 
chunk dalloc 	ent parent 
cache size 	split plno tlno 
index cassert 	start count 
size 	start count data 
index cassert 	ent parent 
size index 	split file file 
cassert size 	small source 
index cassert 	score min 
arena huge 	oldsmall blamed toosmall 
dalloc 	target parent 
stats update 	split unblamed leftover 
arena huge 	file unblamedtail 
malloc stats 	next ent split 
update arena 	unblamed num 
huge dalloc 	ents num ents 
stats 	blame list 
update undo 	blamed toosmall target 
arena huge 	parent porigin 
malloc stats 	opt diff opts 
update undo 	blame list 
malloc mutex 	num ents unblamed 
last 	leftover unblamedtail 
malloc mutex 	norigin file split 
unlock alloc 	origin porigin 
tail malloc 	suspects revs commit 
mutex unlock 	revs commit 
malloc mutex 	blamed porigin 
elm 	suspects next origin 
tail insert 	opt revs 
malloc mutex 	pass num commit 
unlock chunk 	buf porigin 
alloc wrapper 	origin toosmall blames 
malloc mutex 	blametail scoreboard 
arena 	commit origin porigin 
huge malloc 	porigin porigin 
stats update 	tail author author 
undo malloc 	mail author 
mutex unlock 	time author committer 
chunk ceiling 	committer mail 
malloc 	committer time committer 
mutex arena 	summary inbuf 
huge malloc 	name mail time 
stats update 	ident len 
chunk alloc 	maillen namelen 
cache malloc 	tmp endp namebuf 
mutex 	mailbuf commit 
unlock arena 	ret detailed len 
chunk alloc 	subject encoding 
huge hard 	message path suspect 
stats cactive 	repeat prev 
chunk ceiling 	ent suspect opt 
malloc 	revs commit 
mutex arena 	ent suspect next 
huge dalloc 	time str 
stats update 	show raw time 
stats cactive 	time buf 
sub chunk 	time str time 
dalloc 	width suspect 
cache malloc 	repeat ent opt 
mutex unlock 	repeat cnt 
chunk ceiling 	suspect hex ent 
chunk ceiling 	opt cnt 
malloc mutex 	suspect hex 
arena 	show raw time 
huge ralloc 	length name 
stats update 	name pad option 
stats cactive 	ent count 
stats cactive 	suspect commit start 
sub malloc 	end buf 
mutex 	len end lineno 
unlock chunk 	num graft 
ceiling chunk 	file buf graft 
ceiling malloc 	abbrev suspect 
mutex arena 	uniq len option 
huge ralloc 	longest src 
stats 	lines longest dst 
update stats 	lines largest 
cactive sub 	score compute abbrev 
chunk ceiling 	abbrev suspect 
chunk dalloc 	num baa ent 
cache malloc 	opt arg 
mutex 	end score 
unlock chunk 	prefix path output 
alloc wrapper 	option work 
malloc mutex 	path parents commit 
arena huge 	sha blob 
ralloc stats 	sha mode tail 
update 	sha parent 
undo malloc 	tail merge head 
mutex unlock 	line sha 
merge chunk 	len buf opt 
ceiling chunk 	path contents 
dalloc arena 	commit origin parent 
chunk 	tail parent 
hooks chunk 	head sha buf 
ceiling chunk 	ident size 
ceiling chunk 	len mode msg 
ceiling malloc 	read buf 
mutex arena 	ptr buf len 
huge 	pos revs 
ralloc stats 	name found 
update chunk 	name obj name 
alloc cache 	commit name 
malloc mutex 	revs obj option 
unlock arena 	arg unset 
chunk 	opt option arg 
ralloc huge 	unset opt 
expand hard 	argc argv prefix 
merge chunk 	revs path 
ceiling chunk 	ent dashdash pos 
dalloc arena 	lno commit 
stats 	name commit range 
cactive run 	list opt 
quantize first 	show stats revs 
arena miscelm 	file contents 
key create 	options ctx cmd 
arena avail 	annotate ranges 
nsearch 	range anchor 
arena run 	bottom top bottom 
first best 	top next 
fit arena 	xdi diff alloc 
run split 	filespec fill 
large page 	filespec textconv free 
ceiling 	filespec fill 
arena run 	textconv free filespec 
alloc large 	diff opt 
helper arena 	tst textconv read 
chunk alloc 	sha file 
arena miscelm 	die sha hex 
arena 	origin decref 
run split 	free free die 
large arena 	free llist 
run alloc 	mergesort compare commits 
large helper 	commit date 
arena run 	origin decref free 
first 	sanity check 
best fit 	refcnt blame 
arena run 	merge prio queue 
split small 	put flex 
page ceiling 	alloc str strcmp 
arena run 	origin incref 
alloc 	make origin sha 
small helper 	entry sha 
arena chunk 	info hashclr strcmp 
alloc arena 	origin incref 
miscelm arena 	diff setup diff 
run split 	opt parse 
small 	pathspec diff setup 
arena run 	done oid 
alloc small 	diff cache diff 
helper ssize 	sha diffcore 
malloc mutex 	std origin hashcpy 
malloc mutex 	strcmp die 
unlock 	die origin hashcpy 
arena dirty 	diff flush 
mult valid 	free pathspec 
malloc mutex 	diff setup diff 
arena maybe 	opt diff 
purge malloc 	setup done oid 
mutex 	diff cache 
unlock arena 	diff sha diffcore 
purge next 	std strcmp 
next extent 	origin hashcpy diff 
node size 	flush free 
next chunk 	pathspec origin incref 
addr 	origin incref 
arena miscelm 	origin decref memcpy 
arena miscelm 	nth line 
pageind arena 	memset origin incref 
mapbits allocated 	origin incref 
arena mapbits 	origin incref dup 
large 	entry xmalloc 
arena mapbits 	memcpy blame entry 
dirty arena 	xmalloc memcpy 
mapbits unallocated 	blame entry 
size next 	dup entry dup 
next next 	entry xmalloc 
chunk 	memcpy blame entry 
alloc cache 	dup entry 
extent node 	xmalloc memcpy blame 
addr extent 	entry origin 
node size 	decref xcalloc origin 
extent node 	decref origin 
addr 	incref reverse blame 
extent node 	reverse blame 
zeroed extent 	xcalloc origin incref 
node dirty 	reverse blame 
insert extent 	reverse blame die 
node size 	blame chunk 
chunk 	fill origin blob 
addr arena 	fill origin 
miscelm arena 	blob diff hunks 
miscelm pageind 	die oid 
arena mapbits 	hex oid 
unallocated 	hex blame chunk 
size arena 	queue blames 
mapbits dirty 	nth line nth 
arena mapbits 	line isalnum 
dirty arena 	ent score ent 
chunk alloc 	score origin 
arena 	incref decref split 
run split 	memcpy split 
large next 	overlap copy split 
prev meld 	better decref 
malloc mutex 	split handle split 
unlock next 	memset nth 
next 	line nth line 
extent node 	memset diff 
size next 	hunks die oid 
chunk addr 	hex handle 
arena miscelm 	split ent 
arena miscelm 	score fill origin 
pageind 	blob find 
arena mapbits 	copy blob ent 
large size 	score split 
arena mapbits 	blame decref split 
decommitted arena 	filter small 
mapbits decommitted 	reverse blame xcalloc 
decommit 	diff setup 
chunk purge 	diff opt diff 
wrapper arena 	setup done 
mapbits large 	strcmp diff opt 
arena mapbits 	oid diff 
large arena 	cache diff sha 
mapbits 	diff opt 
malloc mutex 	tst diffcore std 
next next 	setup blame 
next extent 	list diff file 
node addr 	valid isgitlink 
extent node 	strcmp origin 
size 	hashcpy fill origin 
extent node 	blob find 
zeroed extent 	copy blob copy 
node committed 	split better 
extent node 	decref split origin 
dirty arena 	decref ent 
node 	score split blame 
dalloc chunk 	decref split 
dalloc arena 	free filter small 
chunk addr 	reverse blame 
arena miscelm 	diff flush free 
arena miscelm 	pathspec origin 
pageind 	incref origin decref 
arena mapbits 	queue blames 
decommitted arena 	free commit list 
run dalloc 	lookup decoration 
chunk hooks 	first scapegoat commit 
arena dirty 	list count 
count 	blame sort 
arena compute 	reverse blame queue 
npurge extent 	blames num 
node dirty 	scapegoats size memset 
linkage init 	xcalloc parse 
arena stash 	commit find hashcmp 
dirty 	pass whole 
arena purge 	blame origin decref 
stashed arena 	hashcmp origin 
unstash purged 	decref origin incref 
malloc mutex 	pass blame 
arena purge 	parent filter small 
malloc 	find move 
mutex unlock 	parent filter small 
arena mapbits 	blame merge 
allocated arena 	filter small find 
mapbits dirty 	copy parent 
arena mapbits 	distribute blame drop 
decommitted 	origin blob 
arena mapbits 	origin decref 
unallocated size 	drop origin blob 
arena mapbits 	free strstr 
unallocated size 	strlen strchr strlen 
arena mapbits 	split ident 
dirty 	line strbuf addstr 
arena mapbits 	strbuf addstr 
decommitted arena 	strbuf addstr strtoul 
avail arena 	strbuf strbuf 
run dirty 	addstr map user 
arena mapbits 	strbuf addf 
unallocated 	strbuf strbuf init 
size arena 	strbuf init 
mapbits unallocated 	strbuf init strbuf 
size arena 	init strbuf 
mapbits allocated 	init strbuf init 
arena mapbits 	strbuf init 
dirty 	strbuf release 
arena mapbits 	strbuf release strbuf 
decommitted arena 	release strbuf 
mapbits unallocated 	release strbuf release 
size arena 	strbuf release 
mapbits unallocated 	strbuf release commit 
size 	info init 
arena mapbits 	log output encoding 
dirty arena 	logmsg reencode 
mapbits decommitted 	line unuse commit 
arena avail 	buffer line 
arena run 	find commit subject 
dirty 	strbuf strbuf 
arena mapbits 	addf oid hex 
unallocated size 	unuse commit 
arena mapbits 	buffer write name 
unallocated size 	quoted commit 
arena mapbits 	info oid hex 
large 	write name 
arena mapbits 	quoted commit 
large size 	info destroy oid 
arena mapbits 	hex emit 
large size 	one suspect detail 
arena run 	write filename 
miscelm 	info maybe flush 
arena miscelm 	die display 
pageind arena 	progress prio queue 
run size 	start progress 
decommit chunk 	delay prio queue 
addr arena 	origin incref 
run 	parse commit pass 
miscelm arena 	blame mark 
miscelm pageind 	parents uninteresting found 
arena run 	guilty entry 
size arena 	origin decref sanity 
cactive update 	check refcnt 
arena 	stop progress strbuf 
mapbits dirty 	reset strbuf 
arena mapbits 	addf atoi 
dirty arena 	show date strbuf 
mapbits dirty 	addstr utf 
arena mapbits 	strwidth strbuf addch 
unallocated 	emit one 
arena mapbits 	suspect detail write 
unallocated arena 	filename info 
mapbits unallocated 	sha hex emit 
arena mapbits 	porcelain details 
unzeroed arena 	nth line emit 
mapbits 	porcelain details 
unallocated arena 	putchar putchar putchar 
mapbits unzeroed 	commit info 
arena run 	sha hex nth 
coalesce arena 	line memset 
mapbits unallocated 	putchar format time 
size 	utf strwidth 
arena mapbits 	format time putchar 
unallocated size 	putchar commit 
arena mapbits 	info destroy 
dirty arena 	emit porcelain emit 
mapbits dirty 	memchr next 
arena 	line alloc next 
mapbits decommitted 	line fopen 
arena mapbits 	strbuf getwholeline read 
decommitted arena 	graft line 
avail insert 	commit graft fclose 
arena run 	strbuf release 
dirty 	find unique abbrev 
insert arena 	strlen update 
chunk dalloc 	abbrev strcmp strlen 
arena maybe 	commit info 
purge arena 	utf strwidth utf 
run decommit 	strwidth commit 
arena 	info destroy ent 
run dalloc 	score ent 
arena run 	score width 
miscelm arena 	width width oid 
miscelm pageind 	hex find 
arena mapbits 	alignment output die 
dirty 	strtoul prefix 
arena mapbits 	path strlen strcmp 
decommitted arena 	git config 
mapbits large 	strcmp git config 
size arena 	strcmp git 
mapbits large 	config strcmp config 
arena 	error nonbool 
mapbits unzeroed 	parse date format 
arena mapbits 	userdiff config 
large arena 	git config entry 
mapbits unzeroed 	sha info 
arena mapbits 	die lookup commit 
large 	reference die 
size arena 	sha hex commit 
mapbits dirty 	list insert 
arena mapbits 	open git 
large arena 	path merge head 
mapbits unzeroed 	die git 
arena 	path merge head 
run dalloc 	strbuf getwholeline 
arena run 	sha hex die 
miscelm arena 	git path 
miscelm pageind 	merge head append 
arena mapbits 	parent close 
dirty 	strbuf release strbuf 
arena mapbits 	detach commit 
decommitted arena 	buffer time alloc 
mapbits large 	commit node 
size arena 	resolve die append 
mapbits large 	parent append 
arena 	merge parents verify 
mapbits unzeroed 	working path 
arena mapbits 	make origin fmt 
large arena 	ident strbuf 
mapbits unzeroed 	addstr strbuf 
arena mapbits 	addf oid hex 
large 	strbuf addf 
size arena 	strcmp commit buffer 
mapbits dirty 	strbuf strcmp 
arena mapbits 	stat die errno 
large arena 	lstat die 
mapbits unzeroed 	errno canon mode 
arena 	diff opt 
miscelm arena 	tst textconv strbuf 
run dalloc 	attach strbuf 
arena run 	read file die 
first arena 	errno strbuf 
run miscelm 	readlink die errno 
arena 	die strbuf 
run search 	read die errno 
arena run 	convert git 
insert arena 	pretend sha file 
run miscelm 	discard cache 
arena run 	read cache 
search 	strlen cache name 
arena run 	pos cache 
arena bin 	entry size xcalloc 
runs first 	hashcpy memcpy 
arena bin 	create flags create 
runs arena 	mode cache 
bin 	entry cache invalidate 
nonfull run 	path deref 
tryget arena 	tag die die 
bin index 	find single 
malloc mutex 	xstrdup deref tag 
unlock malloc 	die die 
mutex 	die xstrdup parse 
arena run 	score parse 
alloc small 	score strcmp git 
bitmap init 	config init 
malloc mutex 	revisions diff opt 
unlock malloc 	diff opt 
mutex 	parse options 
arena bin 	start parse options 
nonfull run 	step exit 
tryget arena 	strcmp parse revision 
bin index 	opt diff 
arena bin 	opt tst diff 
nonfull 	opt clr 
run arena 	parse options end 
run reg 	die isatty 
alloc chunk 	read ancestry die 
addr arena 	errno utf 
dalloc bin 	strwidth strlen show 
run 	date diff 
arena bin 	opt tst usage 
lower run 	options prefix 
arena run 	usage options usage 
reg alloc 	options prefix 
arena prof 	file exists 
accum 	prefix setup work 
prof idump 	file exists 
malloc mutex 	die errno setup 
arena run 	revisions memset 
reg alloc 	prepare die prepare 
arena bin 	initial setup 
malloc 	work fake working 
hard memmove 	commit pending 
unlikely arena 	die find single 
alloc junk 	die prepare 
small malloc 	revision walk die 
mutex unlock 	oidcmp xcalloc 
memset 	decoration die oidcmp 
memset memset 	die oid 
malloc jemalloc 	xmemdupz origin fill 
arena redzone 	blob sha 
corruption arena 	mode die diff 
redzone corruption 	opt tst 
abort 	textconv read 
arena redzones 	sha file die 
validate memset 	sha hex 
jemalloc cassert 	prepare lines list 
size index 	append xstrdup 
arena redzones 	range init parse 
validate 	range arg 
size index 	usage die range 
index size 	append sort 
malloc mutex 	merge range xcalloc 
arena run 	origin incref 
reg alloc 	prio queue put 
arena 	origin decref 
bin malloc 	range release list 
hard malloc 	clear read 
mutex unlock 	mailmap assign blame 
malloc mutex 	setup pager 
unlock arena 	free blame sort 
prof 	coalesce find 
accum prof 	alignment output 
idump unlikely 	free free blame 
arena alloc 	copyright authors 
junk small 	see copying licensing 
unlikely memset 	conditions stats 
jemalloc 	blame blame entry 
valgrind make 	score lower 
mem undefined 	thresholds passed parent 
unlikely arena 	move copy 
alloc junk 	logic remember update 
small jemalloc 	flag allocation 
valgrind 	one blob commit 
make mem 	suspected record 
undefined memset 	preceding blame record 
malloc mutex 	blob origins 
prng arena 	put list linked 
run alloc 	via next 
large 	hanging corresponding commit 
malloc mutex 	field order 
unlock arena 	make finding 
run miscelm 	fast presence chain 
arena miscelm 	count towards 
rpages size 	origin reference count 
index 	tempting count 
arena prof 	commit pending examination 
accum locked 	even circumstances 
malloc mutex 	commit present multiple 
unlock prof 	times priority 
idump unlikely 	queue unexamined commits 
memset 	processing first 
unlikely memset 	instance work requiring 
page ceiling 	origin data 
arena choose 	second instance interspersed 
unlikely page 	commit changing 
ceiling malloc 	would preexisting different 
mutex 	ancestry commit 
arena run 	date order 
alloc large 	wedge two instances 
malloc mutex 	commit priority 
unlock chunk 	queue produce blame 
addr arena 	entries relevant 
run 	want tripped certainly 
miscelm arena 	seem worth 
miscelm rpages 	optimizing suspects contains 
alignment ceiling 	blame entries 
arena miscelm 	may attributed origin 
arena miscelm 	commit parent 
pageind 	commits commit processed 
arena run 	suspects moved 
trim head 	either assigning origin 
arena run 	different commit 
trim tail 	shipping scoreboard ent 
arena run 	list cannot 
init 	attributed different commit 
large arena 	guilty gets 
miscelm pageind 	shipping suspects 
arena run 	blame list instead 
miscelm arena 	commits prepare 
mapbits dirty 	diff filespec convert 
arena 	diff textconv 
mapbits decommitted 	api textconv driver 
arena run 	exists conversion 
dalloc malloc 	succeeds otherwise given 
mutex unlock 	origin prepare 
arena miscelm 	mmfile structure used 
rpages 	diff machinery 
size index 	origin refcounted usually 
malloc mutex 	keep blob 
unlock unlikely 	contents reused present 
memset unlikely 	exactly commit 
memset arena 	chain lines described 
malloc 	blame entry 
arena malloc 	split pass blame 
likely arena 	parents arranged 
palloc large 	linked lists 
likely huge 	kept suspects unprocessed 
malloc huge 	origin entered 
palloc 	blame origin finalized 
cassert chunk 	scoreboard structure 
addr isalloc 	scoreboard structure sorted 
isalloc chunk 	end processing 
addr size 	according image line 
index arena 	number lists 
mapbits 	attached origin sorted 
large binind 	target line 
isalloc isalloc 	number first line 
arena bin 	image internally 
index extent 	line numbers many 
node arena 	lines commit 
arena 	introduced image line 
bin runs 	number first 
arena run 	line suspect file 
search arena 	internally line 
run miscelm 	numbers significant 
malloc mutex 	entry cached avoid 
unlock 	scanning lines 
malloc mutex 	merge blames happens 
arena run 	lists blames 
dalloc decommit 	arrived via different 
malloc mutex 	parents single 
unlock malloc 	suspect want sort 
mutex 	according suspect 
arena bin 	line numbers opposed 
runs insert 	image line 
arena bin 	numbers function body 
runs insert 	somewhat longish 
arena mapbits 	avoids unnecessary writes 
small 	image line 
runind arena 	numbers different need 
miscelm unlikely 	three way 
arena dalloc 	comparison allow 
junk small 	collating suspects sort 
arena run 	according respective 
reg 	pointer primary sorting 
dalloc arena 	criterion actual 
dissociate bin 	relation pretty unimportant 
run arena 	establishes total 
dalloc bin 	order comparing integers 
run arena 	gives current 
bin 	state blame assignment 
lower run 	commit started 
arena dalloc 	digging priority queue 
bin locked 	commits unassigned 
impl arena 	blame records contents 
mapbits small 	image used 
runind 	many functions obtain 
arena miscelm 	contents nth 
malloc mutex 	line indexed scoreboard 
arena dalloc 	lineno blame 
bin locked 	entry lno 
impl malloc 	linked list blames 
mutex 	look line 
unlock arena 	buffer two blame 
ptr small 	entries next 
binind arena 	came contiguous lines 
mapbits arena 	origin commit 
bitselm arena 	path pair merge 
dalloc 	together sanity 
bin unlikely 	merge given sorted 
memset jemalloc 	list blames 
arena miscelm 	preexisting origin previous 
arena mapbits 	blames commit 
large 	entered commit priority 
size arena 	queue score 
dalloc junk 	board given commit 
large size 	path create 
index arena 	origin structure callers 
run dalloc 	blame scoreboard 
decommit 	use origin 
arena dalloc 	obtain shared refcounted 
large locked 	copy instead 
impl malloc 	calling function directly 
mutex arena 	locate existing 
dalloc large 	origin create one 
locked 	moves origin 
impl malloc 	front position commit 
mutex unlock 	list bump 
arena miscelm 	front fill blob 
malloc mutex 	sha field 
arena run 	origin hasn later 
trim 	call fill 
tail size 	origin blob use 
index size 	locate data 
index malloc 	blob sha origin 
mutex unlock 	also used 
arena mapbits 	pass blame entire 
large 	file parent 
size malloc 	detect child 
mutex arena 	blob identical parent 
mapbits allocated 	also fills 
arena mapbits 	origin mode corresponding 
unallocated size 	path origin 
index 	check path exists 
size size 	parent origin 
index arena 	structure represent first 
miscelm arena 	check existing 
run split 	origins path origin 
large page 	parent without 
ceiling 	renaming common see 
memset page 	origin path 
ceiling arena 	different parent origin 
mapbits dirty 	first time 
arena mapbits 	diff fairly efficient 
dirty arena 	path parent 
mapbits 	since origin path 
large arena 	pathspec parent 
mapbits unzeroed 	commit directory 
arena mapbits 	see whole bunch 
large arena 	deletion files 
mapbits unzeroed 	directory care exist 
size 	parent type 
index size 	changed origin find 
index malloc 	path corresponds 
mutex unlock 	parent origin structure 
malloc mutex 	represent append 
unlock unlikely 	blame entry given 
memset 	output queue 
jemalloc chunk 	src typically stack 
addr extent 	want copy 
node arena 	information malloced blame 
arena ralloc 	entry gets 
large grow 	added given queue 
unlikely 	origin dst 
memset isalloc 	loses refcnt 
unlikely memset 	known lines tlno 
isalloc arena 	came parent 
ralloc junk 	overlap range also 
large arena 	known parent 
ralloc 	line plno corresponds 
large shrink 	line tlno 
likely size 	split potentially three 
index size 	parts chunk 
index size 	chunk blamed parent 
index arena 	portion pre 
ralloc 	chunk part blamed 
large huge 	parent post 
ralloc move 	chunk part blamed 
arena malloc 	parent turns 
ipalloct likely 	nothing blame parent 
arena ralloc 	forget splitting 
move 	split suspect signals 
arena ralloc 	split overlap 
move helper 	divided existing 
jemalloc valgrind 	blame three parts 
make mem 	split assigned 
undefined memcpy 	blame moved queue 
isqalloc 	reflect split 
huge ralloc 	first part reuse 
malloc mutex 	storage existing 
malloc mutex 	entry last part 
unlock malloc 	middle part 
mutex malloc 	parent parent covers 
mutex 	entire area 
unlock atomic 	reuse storage replace 
read arena 	parent parent 
dirty mult 	parent splitting blame 
valid atomic 	origins used 
write malloc 	stack blame entry 
mutex 	lose one 
arena metadata 	refcnt reverse blame 
allocated malloc 	reverses list 
mutex unlock 	given head 
malloc mutex 	appending tail allows 
malloc mutex 	build lists 
unlock 	reverse order reverse 
alloc cacheline 	afterwards faster 
ceiling quantum 	building list proper 
ceiling alloc 	order right 
malloc mutex 	away reason building 
init memset 	proper order 
malloc 	requires writing link 
large stats 	previous element 
cacheline ceiling 	building reverse order 
memset malloc 	requires placing 
huge stats 	list head current 
cacheline ceiling 	element process 
quantum 	one hunk patch 
ceiling memset 	current suspect 
chunk dss 	blame entry parent 
prec arena 	first blames 
dirty mult 	unfinished entries 
arena avail 	chunk target parent 
malloc 	start differing 
mutex init 	parent splits blame 
extent szad 	entries start 
extent extent 	end difference region 
szad extent 	since use 
malloc mutex 	options may lead 
init 	overlapping duplicate 
malloc mutex 	source line number 
init malloc 	ranges rely 
mutex init 	sorting merging order 
arena run 	first suspect 
memset unlikely 	line number current 
jemalloc 	record starts 
ffs unlikely 	differing portion reaches 
alloc arena 	need split 
dirty mult 	examine second 
offsetof offsetof 	part separately move 
index size 	second half 
size 	record push record 
index size 	diffp pass 
index size 	blame everything differing 
index bin 	chunk parent 
info init 	know much common 
small run 	stretch diff 
size 	occur currently blamed 
init malloc 	parts assign 
mutex prefork 	parent prepend split 
malloc mutex 	portions everything 
prefork malloc 	starts blameable portion 
mutex prefork 	retain records 
malloc 	target parts different 
mutex prefork 	parent current 
malloc mutex 	record sameness need 
prefork malloc 	split move 
mutex postfork 	second half 
parent malloc 	record processed later 
mutex 	chunks push 
postfork parent 	record samep move 
malloc mutex 	across elements 
postfork parent 	unblamable portion diff 
malloc mutex 	chunks parent 
postfork parent 	target looking origin 
malloc 	target aiming 
mutex postfork 	pass blame lines 
parent malloc 	suspected parent 
mutex postfork 	run diff find 
child malloc 	lines came 
mutex postfork 	parent pass blame 
child 	nothing remains 
malloc mutex 	target rest parent 
postfork child 	lines blame 
malloc mutex 	entry splitting blames 
postfork child 	many times 
malloc mutex 	become small 
postfork 	trivial point becomes 
child data 	pointless blame 
max run 	parents appears everywhere 
size arenas 	ordinary program 
max large 	worth say copied 
size max 	totally unrelated 
run 	file parent compute 
size used 	trivial lines 
small size 	blame entry best 
classes valid 	far split 
small run 	existing blame entry 
page multiples 	passes blame 
number 	parent maintain best 
large size 	far best 
classes number 	split far comparing 
huge size 	best far 
classes function 	copying bst far 
prototypes functions 	needed looking 
referenced 	part image 
prior definition 	represented ent tlno 
generate red 	offset ent 
black functions 	lno tlno looking 
change sizes 	image including 
valid small 	match preimage plno 
run 	looking preimage 
sizes round 	image ent tlno 
nearest run 	preimage plno 
size actually 	line numbers find 
requested normal 	lines parent 
large allocation 	ent pass blames 
large 	file blob 
pad cache 	contents parent prepare 
index randomization 	mmfile contains 
offset allocation 	lines ent file 
page boundary 	part image 
next quantized 	annotating file 
size 	partially may match 
greater input 	image remainder 
size quantized 	match preimage move 
sizes comprise 	blame entries 
run sizes 	list source score 
back small 	smaller score 
region 	min front list 
runs run 	small returns 
sizes back 	pointer link pointing 
large regions 	old head 
alignment constraints 	small list see 
skip quantization 	lines currently 
may 	target suspected attributed 
adequately large 	parent nothing 
run sized 	remains target iteration 
runs may 	unblamed terminated 
mixed happens 	list entries yet 
unusual size 	tested blame 
requested 	leftover contains 
aligned allocation 	reversed list entries 
one several 	tested without 
places linear 	assignable parent count 
search would 	number entries 
potentially find 	target suspected prepare 
sufficiently 	list entry 
aligned available 	best split lines 
memory somewhere 	target suspected 
lower compare 	see find code 
quantized size 	movement across 
rather size 	file boundary parent 
order 	commit porigin 
sort equally 	path parent already 
useful runs 	tried nothing 
address treat 	remains target find 
keys lower 	copies harder 
anything generate 	path requested want 
red 	use diffcore 
black functions 	rename actually 
freeing interior 	match things find 
pointer cause 	copies harder 
assertion failure 	force diff sha 
freeing unallocated 	feed filepairs 
pointer 	diff queue code 
cause assertion 	needs diff 
failure keep 	setup done usually 
track trailing 	makes find 
unused pages 	copies harder imply 
later use 	copy detection 
run 	exist parent ignore 
untouched therefore 	git links 
zeroed run 	find move already 
dirty pages 	dealt path 
must zeroed 	blobs origin porigin 
run clean 	exactly match 
pages 	everything origin suspected 
may zeroed 	blamed parent 
never touched 	steal file 
last element 	pass blame current 
first run 	commit parents 
contains one 	keep saying parent 
page 	porigin mean 
statements element 	find scapegoat exonerate 
extent node 	distribute collected 
notion committed 	unsorted blames respected 
doesn directly 	sorted lists 
apply arena 	various origins first 
chunks 	pass looks 
arbitrarily mark 	unrenamed path optimize 
committed commit 	common cases 
state runs 	look renames second 
tracked individually 	pass optionally 
upon chunk 	find moves parents 
deallocation 	files optionally 
entire chunk 	find copies parents 
consistent commit 	files prepend 
state commit 	toosmall origin 
header undo 	suspects point sorting 
commit header 	ends big 
initialize 	unsorted list caller 
map contain 	anyway information 
one maximal 	commits used output 
free untouched 	filled asked 
run mark 	details parse author 
pages zeroed 	committer line 
chunk 	commit buffer ugh 
alloc returned 	convert name 
zeroed decommitted 	mail mailmap allow 
chunk need 	nonportable characters 
initialize page 	pathnames style quoted 
map entries 	needed porcelain 
unless 	incremental format wants 
chunk zeroed 	show lot 
insert run 	details per 
runs avail 	commit instead repeating 
run runs 	every line 
avail arena 	emit first time 
use 	commit appears 
decommit header 	output unless user 
mark chunk 	specifically asked 
decommitted even 	repeat blame entry 
header decommit 	found guilty 
fails since 	range show incremental 
treating 	output main 
partially committed 	loop blobs lines 
chunk committed 	whose origin 
high potential 	still unknown pick 
causing later 	one blob 
access decommitted 	allow lines pass 
memory 	blames parents 
revert optimistic 	find one suspect 
stats updates 	use suspect 
optimistically update 	later loop 
stats revert 	hold onto meantime 
optimistic stats 	treat root 
updates 	commit boundary take 
optimistically update 	responsibility remaining 
stats first 	entries sanity space 
best fit 	paddings time 
run selection 	buf display width 
lowest run 	use time 
best 	width display width 
fits run 	calibration allow 
sizes quantized 	quick access contents 
candidate runs 	nth line 
necessarily exactly 	image prepare index 
size search 	scoreboard phony 
arena 	grafts use primarily 
chunks lowest 	support git 
best fit 	cvsserver wants give 
usable runs 	linear history 
create chunk 	clients format 
allocate run 	commit parent parent 
arena 	many columns 
chunk alloc 	need show line 
failed another 	numbers authors 
may made 	filenames one abbrev 
sufficient memory 	length needed 
available one 	boundary commit debugging 
dropped 	origin refcounted 
arena arena 	asserts underflow nobody 
chunk alloc 	zero negative 
search one 	refcnt isn simple 
time search 	passing buf 
arena chunks 	len want transfer 
lowest 	ownership buffer 
best fit 	commit must use 
usable runs 	detach prepare 
create chunk 	dummy commit represents 
allocate run 	work staged 
arena chunk 	item note 
alloc 	annotating work item 
failed another 	never works 
may made 	reverse reading stdin 
sufficient memory 	read current 
available one 	index replace path 
dropped arena 	entry origin 
arena 	blob sha without 
chunk alloc 	mucking mode 
search one 	type bits going 
time purge 	write index 
option disabled 	want run diff 
recursively purge 	index cached 
iterate 	bother reading head 
since preventing 	must one 
recursive purging 	one negative commit 
could otherwise 	must boundary 
many dirty 	enables copy 
pages purge 	removed files enables 
unless 	copy existing 
number purgeable 	files blaming file 
pages exceeds 	enables copy 
threshold compute 	existing files everybody 
minimum number 	one abbrev 
pages purge 	length needed boundary 
stash 	commit maximum 
least npurge 	width used show 
pages allocate 	dates translators 
chunkselm remains 	used tell maximum 
valid due 	display width 
dalloc node 	relative timestamp git 
argument 	blame output 
chunk alloc 	locale years months 
cache purging 	ago takes 
spare chunk 	places longest among 
run make 	various forms 
available prior 	relative timestamps 
allocation 	language may need 
temporarily allocate 	fewer display 
free dirty 	columns strip collected 
run stash 	options unknown 
redundant actually 	argv unk passed 
purge chunk 	revision machinery 
chunkselm 	going bottom processing 
embedded chunk 	remaining dashdash 
must remain 	pos either blame 
valid deallocate 	revisions path 
chunk arena 	blame path rev 
unstash purged 	otherwise one 
destroyed 	two blame revisions 
decommitted purged 	path blame 
depending chunk 	path rev note 
deallocation policy 	must strip 
unzeroed flag 	path arguments want 
pages chunk 	path pruning 
purge 	may want 
wrapper returned 	bottom processing reorder 
whether pages 	way rev 
zeroed side 	path fallthrough path 
effect purging 	without anything 
chunk map 	positive head use 
modification 	working contents 
safe even 	bottom mark ancestors 
though arena 	bottom commits 
mutex isn 	would reach traversing 
currently owned 	uninteresting blob.c 
run marked 	blob type sha 
allocated 	obj item 
thus protecting 	buffer size lookup 
modified writes 	create alloc 
perturb first 	blob node type 
last elements 	blob.h blob 
chunk 	type sha item 
map allocated 	buffer size 
bits behavior 	blobs contain 
well defined 	references objects structured 
deallocate chunks 	data needs 
runs calls 	parsing however code 
arena 	may use 
dirty count 	parsed bit blob 
disabled even 	determine whether 
debug builds 	content found actually 
overhead grows 	available parse 
nonlinearly memory 	blob buffer used 
usage 	flag read 
increases coalesce 	successfully database blob 
forward successor 	branch.c spec 
runs avail 	src remote matches 
coalesced run 	remote priv 
inserted later 	tracking origin tracking 
successor 	advice flag 
dirty dirty 	local origin 
pages coalesce 	remote shortname key 
backward predecessor 	rebasing setup 
runs avail 	tracking buf branch 
coalesced run 	name name 
inserted 	name force attr 
later predecessor 	head sha 
dirty dirty 	remote data tracking 
pages run 	branch query 
dirty caller 	upstream branch upstream 
claims dirtied 	missing upstream 
well 	advice create branch 
already dirty 	branch existing 
allocated caller 	remote find tracking 
doesn claim 	free free 
cleaned mark 	setup rebase skip 
pages unallocated 	prefix strcmp 
chunk 	warning strbuf addf 
map insert 	git config 
runs avail 	gently strbuf 
coalescing complete 	reset strbuf addf 
deallocate chunk 	git config 
completely unused 	gently strbuf reset 
okay 	strbuf addf 
dirty page 	git config gently 
processing even 	strbuf release 
chunk deallocated 	strbuf release error 
since spare 	advise strbuf 
waiting possible 	addf git config 
chunk 	strbuf release 
deallocation dirty 	strbuf addstr free 
processing allows 	strbuf release 
old spare 	strbuf check branch 
fully deallocated 	die exists 
thus decreasing 	die strlen resolve 
chances 	bare repository 
spuriously crossing 	strcmp die memset 
dirty page 	remote find 
purging threshold 	tracking remote 
update chunk 	unlink git path 
map arena 	cherry pick 
run 	head unlink git 
dalloc treat 	path revert 
leading run 	head unlink git 
separately allocated 	path merge 
last element 	head unlink git 
run first 	path merge 
single 	unlink git path 
page runs 	merge msg 
update chunk 	unlink git path 
map arena 	merge mode 
run dalloc 	unlink git path 
treat trailing 	squash msg 
run 	find shared symref 
separately allocated 	skip prefix 
last element 	die called branched 
run first 	orig tries 
single page 	infer settings 
runs look 	branch remote merge 
usable 	config branching 
run existing 	existing branch unique 
runs space 	completion good 
available allocate 	real branch builtin 
run initialize 	git branch 
run internals 	copyright kristian gsberg 
arena 	krh redhat 
run alloc 	git branch junio 
small failed 	hamano plain 
another may 	remote local current 
made sufficient 	upstream checks 
memory available 	whether merge bases 
one 	branch head 
dropped bin 	branch branch builds 
search one 	upon contains 
time fill 	branch means branch 
bin runcur 	already merged 
call arena 	safely head 
run 	branch safety valve 
reg alloc 	fully redefined 
another updated 	check upstream otherwise 
runcur one 	head result 
ran without 	merge bases without 
bin arena 	following code 
bin 	transition period gentle 
nonfull run 	reminder order 
arena run 	subsequent messages translators 
alloc small 	make sure 
may allocated 	match head detached 
run may 	head detached 
pulled 	status ahead behind 
run bin 	vcs svn 
run therefore 	drop obj pool 
make assumptions 	listing remote 
run previously 	branches remote 
used arena 	branches remotes prefix 
bin 	need account 
lower run 	width sorting parameter 
must called 	given sorting 
region deallocated 	refname would give 
run oom 	alphabetically sorted 
tbin avail 	head beginning followed 
isn 	local branches 
yet filled 	refs heads remote 
first element 	tacking branches 
successful allocations 	refs remotes bad 
must moved 	name could 
tbin avail 	attempt rename used 
bailing 	allow created 
insert low 	accident command like 
regions used 	git branch 
first large 	currentbranch currentbranch cannot 
allocation compute 	cause worktree 
uniformly distributed 	become inconsistent 
offset 	head allow need 
within first 	pass logmsg 
page multiple 	head didn really 
cacheline size 	move git 
pages cachelines 	branch local also 
handles large 	shows head 
allocations 	detached create branch 
require page 	takes care 
alignment cause 	setting tracking info 
oom small 	making sure 
alignment doesn 	upstream correct show 
require special 	instructions user 
run 	gave one branch 
placement large 	doesn exist 
alignment doesn 	locally name remote 
require special 	tracking branch 
run placement 	builtin branch usage 
however cached 	head head 
pointer 	sha branch 
may random 	use color branch 
offset run 	colors output 
bit manipulation 	colopts slot slot 
retrieve dissociate 	name slot 
run bin 	branch color kind 
block 	name rev 
conditional necessary 	head rev reference 
run contains 	rev reference 
one region 	name reference name 
never gets 	free merged 
inserted non 	branch upstream sha 
full 	branchname refname 
runs make 	sha head rev 
sure bin 	kinds force 
runcur non 	rev branchname buf 
refers lowest 	argc argv 
non full 	force kinds quiet 
run 	head rev 
okay runcur 	sha name 
rather proactively 	fmt ret remote 
keeping pointing 	branch bname 
lowest non 	target flags stat 
full run 	branch name 
runcur 	show upstream branch 
arena ptr 	upstream fancy 
small binind 	upstream gone added 
extra sanity 	decoration item 
checking shrink 	filter refname stat 
run make 	sub commit 
trailing 	desc state item 
pages available 	maxwidth filter 
allocations extend 	remote prefix current 
run next 	color name 
run available 	prefix desc free 
sufficiently large 	utf compensation 
split 	refs remote 
following run 	bonus max desc 
merge first 	filter sorting 
part existing 	maxwidth remote prefix 
allocation zero 	oldname newname 
trailing bytes 	force logmsg newsection 
original 	recovery clobber 
allocation last 	head edit description 
page since 	branch name 
indeterminate state 	buf name argc 
mark extended 	argv prefix 
run dirty 	list edit description 
either 	unset upstream 
portion run 	upstream filter sorting 
dirty allocation 	tail options 
rather pedantic 	branch name branch 
actually sequence 	branch branch 
events could 	buf branch remote 
cause 	tracking buf 
resulting run 	strcasecmp strcasecmp 
passed arena 	strcasecmp strcasecmp strcasecmp 
run dalloc 	strcasecmp starts 
dirty argument 	git column config 
dirty flag 	strcmp git 
consistency 	config colorbool skip 
would really 	prefix parse 
matter resize 	branch color slot 
large allocation 	config error 
order avoid 	nonbool color parse 
copying always 	git color 
fail 	config branch branch 
growing following 	upstream resolve 
run already 	refdup lookup commit 
use current 	reference merge 
size compatible 	bases merge bases 
maximal fill 	warning warning 
shrinking 	free lookup commit 
order avoid 	reference error 
race avoid 	branch merged 
moving allocation 	error strbuf addf 
size left 	git config 
reallocation would 	rename section warning 
require 	strbuf release 
move avoid 	die lookup commit 
moving allocation 	reference die 
size oldsize 	strbuf branchname strcmp 
different enough 	error free 
need move 	mkpathdup resolve error 
fall 	check branch 
back allocating 	commit sha error 
space copying 	find unique 
junk zero 	abbrev branch config 
filling already 	free branch 
done ipalloc 	stat tracking info 
arena 	shorten unambiguous 
malloc allocate 	want color strbuf 
arena arena 	addf branch 
lstats arena 	color branch 
hstats contiguously 	color strbuf addstr 
mainly way 	strbuf addf 
clean 	strbuf addf strbuf 
alloc nondeterministic 	addf strbuf 
seed address 	addf strbuf addf 
arena reduces 	strbuf addf 
likelihood lockstep 	strbuf addf strbuf 
non uniform 	addf strbuf 
cache 	release strbuf addch 
index utilization 	free parse 
among identical 	commit commit easy 
concurrent processes 	fill tracking 
cost test 	info strbuf addf 
repeatability debug 	find unique 
builds 	abbrev strbuf release 
instead use 	strbuf release 
deterministic seed 	memset status 
initialize bins 	state strbuf addf 
calculate bin 	strbuf addf 
info run 	strbuf addf strbuf 
size 	addf strbuf 
meets following 	addstr free free 
constraints bin 	free strbuf 
info run 	detach skip prefix 
size arena 	strcmp skip 
maxrun bin 	prefix head description 
info 	strbuf addf 
nregs run 	strlen utf strwidth 
maxregs bin 	strbuf addf 
info nregs 	branch color branch 
bin info 	color strbuf 
reg offset 	addf branch color 
also 	branch color 
calculated since 	skip prefix strbuf 
settings interdependent 	addf verbose 
determine redzone 	info column 
size minimum 	active list append 
alignment minimum 	strbuf release 
redzone 	strbuf release free 
size padding 	skip prefix 
end run 	skip prefix utf 
needed align 	strwidth memset 
regions padding 	verify format filter 
allows redzone 	refs calc 
half 	maxwidth strlen sorting 
minimum alignment 	sort format 
without padding 	print item clear 
redzone would 	die strbuf 
twice large 	check branch exists 
order maintain 	die strcmp 
alignment 	validate branchname strbuf 
compute run 	addf rename 
size ideal 	die strbuf release 
conditions redzones 	warning strcmp 
limit run 	create symref 
size redzones 	die strbuf addf 
require 	strbuf release 
enough padding 	strbuf addf strbuf 
even single 	release git 
region fit 	config rename section 
within number 	die strbuf 
pages would 	release strbuf release 
normally 	read branch 
dedicated run 	desc strbuf addch 
size increase 	strbuf commented 
run size 	addf write file 
least one 	gently git 
region fits 	path strbuf release 
make 	error strerror 
sure run 	strbuf reset launch 
fit within 	editor git 
arena chunk 	path strbuf release 
copy settings 	strbuf stripspace 
compute header 	strbuf addf 
size 	git config strbuf 
large enough 	release strbuf 
contain page 	release memset strcmp 
map page 	usage options 
map biased 	git config resolve 
omit entries 	refdup die 
header 	strcmp skip prefix 
iteration necessary 	die parse 
compute map 	options usage options 
bias compute 	finalize colopts 
safe header 	explicitly enable column 
size map 	die die 
bias 	branches print list 
values include 	print columns 
enough space 	list clear die 
unbiased page 	die strbuf 
map refine 	addf exists strbuf 
map bias 	release error 
omit 	error strbuf 
header pages 	release edit branch 
page map 	description die 
resulting map 	rename branch rename 
bias may 	branch die 
one small 	branch die strcmp 
refine 	die die 
map bias 	exists die create 
result result 	branch branch 
always correct 	die strcmp die 
small chunk 	die branch 
sizes possible 	merge config die 
fewer 	strbuf addf 
non header 	git config multivar 
pages available 	strbuf reset 
necessary serve 	strbuf addf git 
size classes 	config multivar 
chunksize arena.h 	strbuf release 
binind 	branch strcmp die 
nfree bitmap 	die die 
bits prof 	strbuf addf exists 
tctx pun 	strbuf release 
prof tctx 	exists create branch 
run node 	usage options 
map 	called branched orig 
bits reg 	tries infer 
size redzone 	settings branch remote 
size reg 	merge config 
interval run 	branching existing branch 
size nregs 	unique completion 
bitmap 	good real branch 
info reg 	builtin git 
offset runcur 	branch copyright kristian 
runs stats 	gsberg krh 
ind nthreads 	redhat git branch 
stats prof 	junio hamano 
accumbytes 	plain remote 
offset state 	local current upstream 
dss prec 	checks whether 
spare dirty 	merge bases branch 
mult purging 	head branch 
nactive ndirty 	branch builds upon 
runs 	contains branch 
avail runs 	means branch already 
dirty chunks 	merged safely 
cache huge 	head branch safety 
mtx chunks 	valve fully 
szad cached 	redefined check upstream 
chunks 	otherwise head 
cached chunks 	result merge bases 
szad retained 	without following 
chunks retained 	code transition period 
chunks mtx 	gentle reminder 
node cache 	order subsequent messages 
mtx 	translators make 
chunk hooks 	sure match 
bins large 	head detached head 
pad opt 	detached status 
dirty mult 	ahead behind vcs 
arena bin 	svn drop 
info 	obj pool listing 
map bias 	remote branches 
map misc 	remote branches remotes 
offset arena 	prefix need 
maxrun large 	account width sorting 
maxclass nlclasses 	parameter given 
nhclasses 	sorting refname would 
arena node 	give alphabetically 
cache arena 	sorted head beginning 
node cache 	followed local 
arena arena 	branches refs heads 
node arena 	remote tacking 
usize 	branches refs remotes 
alignment zero 	bad name 
arena chunk 	could attempt 
usize arena 	rename used allow 
chunk oldsize 	created accident 
usize arena 	command like git 
chunk 	branch currentbranch 
oldsize usize 	currentbranch cannot cause 
arena chunk 	worktree become 
oldsize usize 	inconsistent head allow 
zero arena 	need pass 
arena dirty 	logmsg head didn 
mult 	really move 
arena arena 	git branch local 
arena tbin 	also shows 
binind prof 	head detached create 
accumbytes ptr 	branch takes 
bin info 	care setting tracking 
zero 	info making 
arena redzone 	sure upstream 
corruption arena 	correct show instructions 
dalloc junk 	user gave 
small ptr 	one branch doesn 
bin info 	exist locally 
ptr 	name remote tracking 
usize arena 	branch branch.c 
size zero 	spec src remote 
arena size 	matches remote 
zero tsd 	priv tracking origin 
arena 	tracking advice 
usize alignment 	flag local origin 
zero tcache 	remote shortname 
ptr size 	key rebasing setup 
arena chunk 	tracking buf 
ptr bitselm 	branch name name 
arena 	name force 
chunk ptr 	attr head sha 
pageind bitselm 	remote data 
arena chunk 	tracking branch 
ptr pageind 	query upstream branch 
arena dalloc 	upstream missing 
junk 	upstream advice create 
large ptr 	branch branch 
usize arena 	existing remote find 
chunk ptr 	tracking free 
arena chunk 	free setup rebase 
ptr arena 	skip prefix 
ralloc 	strcmp warning strbuf 
junk large 	addf git 
ptr oldsize 	config gently strbuf 
size extra 	reset strbuf 
zero tsd 	addf git config 
arena ptr 	gently strbuf 
oldsize 	reset strbuf addf 
size alignment 	git config 
zero tcache 	gently strbuf release 
arena arena 	strbuf release 
dss prec 	error advise 
dirty mult 	strbuf addf git 
arena 	config strbuf 
dss dirty 	release strbuf addstr 
mult nactive 	free strbuf 
ndirty astats 	release strbuf check 
bstats lstats 	branch die 
hstats ind 	exists die strlen 
arena 	resolve bare 
arena arena 	repository strcmp die 
chunk pageind 	memset remote 
chunk pageind 	find tracking remote 
miscelm miscelm 	unlink git 
run chunk 	path cherry pick 
pageind 	head unlink 
mapbitsp chunk 	git path revert 
pageind mapbits 	head unlink 
chunk pageind 	git path merge 
chunk pageind 	head unlink 
chunk pageind 	git path 
chunk 	merge unlink git 
pageind chunk 	path merge 
pageind chunk 	msg unlink git 
pageind chunk 	path merge 
pageind chunk 	mode unlink git 
pageind chunk 	path squash 
pageind 	msg find shared 
mapbitsp mapbits 	symref skip 
size chunk 	prefix die called 
pageind size 	branched orig 
flags chunk 	tries infer settings 
pageind size 	branch remote 
chunk 	merge config branching 
pageind flags 	existing branch 
chunk pageind 	unique completion good 
size flags 	real branch 
chunk pageind 	builtin git 
binind chunk 	branch copyright kristian 
pageind 	gsberg krh 
runind binind 	redhat git branch 
flags arena 	junio hamano 
size arena 	plain remote local 
size arena 	current upstream 
arena accumbytes 	checks whether merge 
arena 	bases branch 
accumbytes arena 	head branch branch 
accumbytes ptr 	builds upon 
mapbits arena 	contains branch means 
bin run 	branch already 
bin info 	merged safely head 
ptr 	branch safety 
ptr ptr 	valve fully redefined 
usize tctx 	check upstream 
ptr usize 	otherwise head result 
old ptr 	merge bases 
old tctx 	without following 
tsd 	code transition period 
arena size 	gentle reminder 
zero tcache 	order subsequent messages 
ptr ptr 	translators make 
demote tsd 	sure match head 
ptr tcache 	detached head 
tsd 	detached status ahead 
ptr size 	behind vcs 
tcache chunk 	svn drop obj 
pageind chunk 	pool listing 
pageind miscelm 	remote branches remote 
chunk pageind 	branches remotes 
miscelm 	prefix need account 
chunk pageind 	width sorting 
miscelm run 	parameter given sorting 
miscelm chunk 	refname would 
pageind mapbitsp 	give alphabetically sorted 
chunk pageind 	head beginning 
mapbits 	followed local 
size chunk 	branches refs heads 
pageind mapbits 	remote tacking 
chunk pageind 	branches refs remotes 
mapbits chunk 	bad name 
pageind mapbits 	could attempt rename 
chunk 	used allow 
pageind mapbits 	created accident command 
binind chunk 	like git 
pageind mapbits 	branch currentbranch currentbranch 
chunk pageind 	cannot cause 
mapbits chunk 	worktree become inconsistent 
pageind 	head allow 
mapbits chunk 	need pass logmsg 
pageind mapbits 	head didn 
chunk pageind 	really move git 
mapbits mapbitsp 	branch local 
mapbits size 	also shows head 
mapbits 	detached create 
chunk pageind 	branch takes 
size flags 	care setting tracking 
mapbitsp chunk 	info making 
pageind size 	sure upstream correct 
mapbitsp mapbits 	show instructions 
chunk 	user gave one 
pageind flags 	branch doesn 
mapbitsp chunk 	exist locally name 
pageind size 	remote tracking 
flags mapbitsp 	branch builtin branch 
chunk pageind 	usage head 
binind 	head sha branch 
mapbitsp mapbits 	use color 
chunk pageind 	branch colors output 
runind binind 	colopts slot 
flags mapbitsp 	slot name slot 
arena size 	branch color 
arena 	kind name rev 
size arena 	head rev 
arena accumbytes 	reference rev 
arena accumbytes 	reference name reference 
arena accumbytes 	name free 
ret ptr 	merged branch upstream 
mapbits 	sha branchname 
binind chunk 	refname sha head 
arena pageind 	rev kinds 
actual mapbits 	force rev branchname 
rpages ind 	buf argc 
run bin 	argv force kinds 
run 	quiet head 
binind actual 	rev sha name 
binind bin 	fmt ret 
info miscelm 	remote branch bname 
rpages arena 	target flags 
bin binind 	stat branch name 
run 	show upstream 
bin info 	branch upstream 
ptr shift 	fancy upstream gone 
diff regind 	added decoration 
interval miscelm 	item filter refname 
rpages interval 	stat sub 
invs 	commit desc state 
ptr ret 	item maxwidth 
chunk pageind 	filter remote prefix 
mapbits elm 	current color 
ptr usize 	name prefix desc 
tctx chunk 	free utf 
pageind 	compensation refs remote 
elm ptr 	bonus max 
usize old 	desc filter sorting 
ptr old 	maxwidth remote 
tctx chunk 	prefix oldname newname 
pageind elm 	force logmsg 
tsd 	newsection recovery clobber 
arena size 	head edit 
zero tcache 	description branch 
ptr chunk 	name buf name 
ptr demote 	argc argv 
ret chunk 	prefix list edit 
pageind 	description unset 
binind tsd 	upstream upstream filter 
ptr tcache 	sorting tail 
chunk pageind 	options branch name 
mapbits binind 	branch branch 
size tsd 	branch buf branch 
ptr 	remote tracking 
size tcache 	buf strcasecmp strcasecmp 
chunk pageind 	strcasecmp strcasecmp 
binind pageind 	strcasecmp strcasecmp starts 
chunk addr 	git column 
chunk addr 	config strcmp git 
arena 	config colorbool 
miscelm pageind 	skip prefix parse 
offsetof arena 	branch color 
miscelm pageind 	slot config 
arena miscelm 	error nonbool color 
pageind offsetof 	parse git 
arena 	color config branch 
miscelm pageind 	branch upstream 
arena miscelm 	resolve refdup lookup 
pageind arena 	commit reference 
bitselm arena 	merge bases merge 
mapbitsp read 	bases warning 
arena 	warning free lookup 
mapbitsp arena 	commit reference 
mapbits arena 	error branch merged 
mapbits size 	error strbuf 
decode arena 	addf git config 
mapbits arena 	rename section 
mapbits 	warning strbuf release 
size decode 	die lookup 
arena mapbits 	commit reference die 
arena mapbits 	strbuf branchname 
arena mapbits 	strcmp error 
arena mapbits 	free mkpathdup resolve 
arena 	error check 
mapbits arena 	branch commit sha 
mapbits arena 	error find 
mapbits arena 	unique abbrev branch 
mapbitsp arena 	config free 
mapbitsp write 	branch stat tracking 
arena 	info shorten 
mapbits size 	unambiguous want color 
encode arena 	strbuf addf 
mapbitsp arena 	branch color branch 
mapbitsp read 	color strbuf 
arena mapbitsp 	addstr strbuf addf 
write 	strbuf addf 
arena mapbits 	strbuf addf strbuf 
size encode 	addf strbuf 
arena mapbitsp 	addf strbuf 
arena mapbitsp 	addf strbuf addf 
write arena 	strbuf addf 
mapbitsp 	strbuf release strbuf 
arena mapbitsp 	addch free 
write arena 	parse commit commit 
mapbits size 	easy fill 
encode arena 	tracking info strbuf 
mapbitsp arena 	addf find 
mapbitsp 	unique abbrev strbuf 
read arena 	release strbuf 
mapbits large 	release memset status 
size arena 	state strbuf 
mapbitsp write 	addf strbuf addf 
arena mapbitsp 	strbuf addf 
arena 	strbuf addf strbuf 
mapbitsp write 	addstr free 
atomic atomic 	free free strbuf 
sub atomic 	detach skip 
read cassert 	prefix strcmp 
cassert likely 	skip prefix head 
arena 	description strbuf 
prof accum 	addf strlen utf 
impl cassert 	strwidth strbuf 
likely malloc 	addf branch color 
mutex arena 	branch color 
prof accum 	strbuf addf branch 
impl 	color branch 
malloc mutex 	color skip prefix 
unlock chunk 	strbuf addf 
addr extent 	verbose info column 
node arena 	active list 
arena mapbits 	append strbuf release 
arena 	strbuf release 
mapbits large 	free skip prefix 
arena mapbits 	skip prefix 
allocated arena 	utf strwidth memset 
mapbits small 	verify format 
runind arena 	filter refs 
miscelm 	calc maxwidth strlen 
arena miscelm 	sorting sort 
rpages arena 	format print item 
run miscelm 	clear die 
arena miscelm 	strbuf check branch 
rpages jemalloc 	exists die 
ffs 	strcmp validate branchname 
likely cassert 	strbuf addf 
chunk addr 	rename die strbuf 
likely arena 	release warning 
mapbits likely 	strcmp create symref 
arena miscelm 	die strbuf 
atomic 	addf strbuf release 
read huge 	strbuf addf 
prof tctx 	strbuf release git 
cassert chunk 	config rename 
addr likely 	section die strbuf 
arena mapbits 	release strbuf 
allocated 	release read 
unlikely arena 	branch desc strbuf 
mapbits large 	addch strbuf 
arena miscelm 	commented addf write 
atomic write 	file gently 
arena mapbits 	git path strbuf 
large 	release error 
huge prof 	strerror strbuf reset 
tctx cassert 	launch editor 
unlikely chunk 	git path strbuf 
addr likely 	release strbuf 
arena mapbits 	stripspace strbuf addf 
allocated 	git config 
arena mapbits 	strbuf release strbuf 
large arena 	release memset 
miscelm atomic 	strcmp usage options 
write huge 	git config 
prof tctx 	resolve refdup 
reset 	die strcmp skip 
arena choose 	prefix die 
unlikely likely 	parse options usage 
likely tcache 	options finalize 
alloc small 	colopts explicitly enable 
arena malloc 	column die 
small 	die branches print 
likely likely 	list print 
tcache alloc 	columns list clear 
large arena 	die die 
malloc large 	strbuf addf exists 
huge malloc 	strbuf release 
chunk 	error error strbuf 
addr likely 	release edit 
extent node 	branch description die 
arena huge 	rename branch 
aalloc chunk 	rename branch die 
addr likely 	branch die 
arena 	strcmp die 
mapbits allocated 	die exists die 
arena mapbits 	create branch 
binind unlikely 	branch die strcmp 
arena mapbits 	die die 
large arena 	branch merge config 
mapbits 	die strbuf 
large size 	addf git config 
arena mapbits 	multivar strbuf 
dirty arena 	reset strbuf addf 
mapbits dirty 	git config 
arena mapbits 	multivar strbuf release 
large 	branch strcmp 
arena ptr 	die die die 
small binind 	strbuf addf 
arena mapbits 	exists strbuf release 
index size 	exists create 
huge salloc 	branch usage options 
chunk 	called branched 
addr likely 	orig tries 
arena mapbits 	infer settings branch 
arena mapbits 	remote merge 
allocated likely 	config branching existing 
likely arena 	branch unique 
ptr 	completion good real 
small binind 	branch builtin 
tcache dalloc 	git branch copyright 
small arena 	kristian gsberg 
dalloc small 	krh redhat git 
extent node 	branch junio 
arena 	hamano plain remote 
arena mapbits 	local current 
large size 	upstream checks whether 
likely tcache 	merge bases 
dalloc large 	branch head branch 
arena dalloc 	branch builds 
large 	upon contains branch 
extent node 	means branch 
arena huge 	already merged 
dalloc chunk 	safely head branch 
addr likely 	safety valve 
arena mapbits 	fully redefined check 
allocated 	upstream otherwise 
arena mapbits 	head result merge 
large arena 	bases without 
mapbits large 	following code transition 
size arena 	period gentle 
salloc likely 	reminder order subsequent 
likely 	messages translators 
size index 	make sure match 
tcache dalloc 	head detached 
small arena 	head detached status 
dalloc small 	ahead behind 
extent node 	vcs svn drop 
arena 	obj pool 
likely tcache 	listing remote branches 
dalloc large 	remote branches 
arena dalloc 	remotes prefix 
large extent 	need account width 
node arena 	sorting parameter 
huge 	given sorting refname 
dalloc maximum 	would give 
number regions 	alphabetically sorted head 
one run 	beginning followed 
minimum redzone 	local branches refs 
size redzones 	heads remote 
may 	tacking branches refs 
larger necessary 	remotes bad 
preserve region 	name could attempt 
alignment minimum 	rename used 
ratio active 	allow created accident 
dirty pages 	command like 
per 	git branch currentbranch 
arena computed 	currentbranch cannot 
nactive dirty 	cause worktree 
mult ndirty 	become inconsistent head 
supposing dirty 	allow need 
mult less 	pass logmsg head 
times 	didn really 
many active 	move git branch 
pages dirty 	local also 
pages jemalloc 	shows head detached 
types index 	create branch 
bin run 	takes care setting 
associated 	tracking info 
number free 	making sure upstream 
regions run 	correct show 
per region 	instructions user gave 
allocated deallocated 	one branch 
bitmap element 	doesn exist locally 
chunk 	name remote 
map corresponds 	tracking branch branch.h 
one page 	create branch 
within chunk 	name force 
run address 	attr flag local 
size various 	origin remote 
flags 	strbuf branch name 
stored together 	branch functions 
bit layout 	acting information branches 
looks like 	creates branch 
assuming bit 	head branch currently 
system nnnnn 	name branch 
nnndumla 	name start name 
unallocated run 	name existing 
address first 	branch branch start 
last pages 	force enables 
unset pages 	overwriting existing non 
small 	head branch 
run page 	reflog creates reflog 
offset large 	branch track 
run page 	causes branch configured 
count first 	merge remote 
page unset 	branch start 
trailing 	name tracking branch 
pages binind 	validates requested 
small size 	branch may created 
binind invalid 	returning interpreted 
large size 	force indicates whether 
dirty unzeroed 	non head 
decommitted 	branches may overwritten 
large allocated 	non zero 
following example 	indicates force parameter 
bit patterns 	non zero 
three types 	branch already exists 
runs run 	contrary attr 
page 	caller interested verifying 
offset run 	update named 
size binind 	branch point potentially 
size large 	different commit 
objects binind 	merely asking change 
invalid care 	attribute named 
dumla 	branch tracking 
bit dumla 	upstream needswork needs 
bit unset 	split two 
unallocated clean 	separate functions longer 
ssssssss ssssssss 	run sanity 
sss dum 	information state working 
xxxxxxxx 	current branch 
xxxxxxxx xxxxxxxx 	merge head configure 
xxx uxxx 	local branch 
ssssssss ssssssss 	local downstream branch 
sss unallocated 	remote remote 
dirty ssssssss 	origin used git 
ssssssss 	branch upstream 
sss xxxxxxxx 	returns success read 
xxxxxxxx xxxxxxxx 	branch description 
xxxxxxxx ssssssss 	check branch main 
ssssssss sss 	worktree linked 
small pppppppp 	worktree die 
pppppppp 	message describing checkout 
pppnnnnn nnnd 	location bswap.h 
pppppppp pppppppp 	val val result 
pppnnnnn nnn 	result builtin 
pppppppp pppppppp 	constant swab builtin 
pppnnnnn nnnd 	constant bswap 
large 	builtin constant bswap 
ssssssss ssssssss 	git bswap 
sss xxxxxxxx 	git bswap make 
xxxxxxxx xxxxxxxx 	sure always 
xxxxxxxx large 	sane definition ntohl 
sampled size 	htonl libraries 
large 	define function call 
minclass ssssssss 	perform shifting 
ssssssss sssnnnnn 	bringing significant overhead 
nnn xxxxxxxx 	simple operation 
xxxxxxxx xxxxxxxx 	version compiler ought 
xxxxxxxx large 	optimize properly 
sampled 	constant values 
size large 	performance might improved 
minclass ssssssss 	cpu architecture 
ssssssss sss 	bit loads fast 
xxxxxxxx xxxxxxxx 	ntohl available 
xxxxxxxx xxxxxxxx 	otherwise fall back 
arena 	loads shifts 
chunk map 	portable faster architectures 
misc corresponds 	memory alignment 
one page 	issues builtin-fetch--tool.c buf 
within chunk 	show action 
like arena 	refname sha oldval 
chunk 	msg rla 
map bits 	name head note 
two separate 	verbose force 
arrays stored 	sha old sha 
within chunk 	oldh newh 
header order 	current updated msg 
improve 	head remote 
cache locality 	remote name 
linkage run 	remote nick local 
trees two 	name merge 
disjoint uses 	verbose force commit 
arena runs 	remote len 
avail 	note len sha 
arena run 	note kind 
conceptually uses 	keep signo remote 
linkage use 	name refs 
non full 	force merge len 
runs rather 	next single 
directly 	force merge local 
embedding linkage 	part retlen 
linkage list 	remote remote nick 
dirty runs 	refs verbose 
profile counters 	force buffer err 
used large 	len local 
runs 	name single force 
small region 	merge len 
run metadata 	reflist next 
jemalloc arena 	next colon remote 
structs arena 	result numrefs 
chunk header 	refs matchlen replacelen 
pointer 	found one 
arena owns 	remote lref colon 
chunk stored 	tail next 
within node 	eol sha namelen 
field whole 	sha rref 
used chunks 	remote result err 
rtree 	pass line 
support ivsalloc 	name namelen shown 
core debugging 	next rreflen 
map pages 	lrr argc argv 
within chunk 	prefix verbose 
keeps track 	force sopt arg 
free 	result filename 
large small 	result filename reflist 
first map 	remote result 
bias entries 	reflist strbuf 
omitted since 	read die errno 
chunk header 	strbuf detach 
need 	getenv snprintf warning 
tracked map 	update sha 
omission saves 	hex die sha 
header page 	info die 
common chunk 	show sha strncmp 
sizes dynamically 	show update 
sized 	env hashcmp show 
read information 	strncmp show 
associated element 	update env lookup 
arena bins 	commit reference 
stored separately 	lookup commit reference 
partly reduce 	strcpy find 
memory 	unique abbrev strcpy 
usage one 	find unique 
copy rather 	abbrev merge 
one per 	bases update env 
arena mainly 	update env 
avoid cacheline 	sha error lookup 
sharing 	commit reference 
run following 	gently strcmp strncmp 
layout pad 	strncmp strncmp 
redzone reg 	strlen strncmp sprintf 
offset region 	sprintf sprintf 
redzone redzone 	sha hex update 
region 	local unlink 
reg interval 	keep sigchain pop 
redzone redzone 	strlen strchr 
region nregs 	strncmp strlen xmemdupz 
redzone alignment 	sigchain push 
pad reg 	common atexit fgets 
interval 	isspace strlen 
least minimum 	strcmp die strcmp 
alignment reg 	strcmp directory 
size preserves 	strlen strlen 
alignment constraint 	xmalloc sprintf find 
depends alignment 	local name 
pad 	append fetch head 
either redzone 	isspace isspace 
size present 	isspace isspace strchr 
needed align 	putchar strchr 
reg offset 	strlen isspace strchr 
size regions 	strlen memcmp 
run 	sha hex isspace 
bin size 	strncmp putchar 
redzone size 	isspace strchrnul xcalloc 
interval regions 	isspace strchrnul 
reg size 	memcmp error free 
redzone size 	strcmp strcmp 
total 	strcmp error strcmp 
size run 	error git 
bin size 	path fetch head 
total number 	fopen error 
regions run 	strerror append 
bin size 	fetch head fclose 
metadata 	strcmp error 
used manipulate 	git path fetch 
bitmaps runs 	head fopen 
associated bin 	error strerror fetch 
offset first 	store fclose 
region run 	strcmp error strcmp 
bin 	stdin parse 
size operations 	reflist strcmp error 
runcur runs 	strcmp stdin 
stats require 	pick rref strcmp 
locked run 	error strcmp 
allocation deallocation 	stdin expand refs 
arena 	wildcard error 
may acquired 	storing glob glob 
holding one 	lref colon 
bin locks 	remote hierarchy name 
vise versa 	colon tail 
current run 	local next 
used 	eol name identical 
service allocations 	lref colon 
bin size 	yes match pass 
non full 	counts allocates 
runs used 	pass fills builtin.h 
looking existing 	git usage 
run 	git info shortlog 
runcur longer 	len fmt 
usable choose 	merge msg opts 
non full 	path mode 
run lowest 	sha sha valid 
memory policy 	buf buf 
tends 	size argc argv 
keep objects 	prefix argc 
packed well 	argv prefix argc 
also help 	argv prefix 
reduce number 	argc argv 
almost empty 	prefix argc argv 
chunks 	prefix argc 
bin statistics 	argv prefix argc 
arena index 	argv prefix 
within arenas 	argc argv prefix 
number threads 	argc argv 
currently assigned 	prefix argc argv 
arena 	prefix argc 
field arenas 	argv prefix argc 
three classes 	argv prefix 
arena operations 	argc argv prefix 
locking perspective 	argc argv 
assignment modifies 	prefix argc argv 
nthreads 	prefix argc 
arenas bin 	argv prefix argc 
related operations 	argv prefix 
bin locks 	argc argv prefix 
chunk run 	argc argv 
related operations 	prefix argc 
mutex 	argv prefix argc 
list tcaches 	argv prefix 
extant threads 	argc argv prefix 
associated arena 	argc argv 
stats merged 	prefix argc argv 
incrementally exit 	prefix argc 
opt 	argv prefix argc 
stats print 	argv prefix 
enabled prng 	argc argv prefix 
state cache 	argc argv 
index randomization 	prefix argc argv 
large allocation 	prefix argc 
pointers 	argv prefix argc 
order avoid 	argv prefix 
rapid chunk 	argc argv prefix 
allocation deallocation 	argc argv 
arena oscillates 	prefix argc argv 
right cusp 	prefix argc 
needing 	argv prefix 
chunk cache 	argc argv prefix 
recently freed 	argc argv 
chunk spare 	prefix argc argv 
left arena 	prefix argc 
chunk trees 	argv prefix argc 
deleted 	argv prefix 
one spare 	argc argv prefix 
chunk per 	argc argv 
arena rather 	prefix argc argv 
one spare 	prefix argc 
total order 	argv prefix argc 
avoid 	argv prefix 
interactions multiple 	argc argv prefix 
threads could 	argc argv 
make single 	prefix argc argv 
spare inadequate 	prefix argc 
minimum ratio 	argv prefix argc 
log 	argv prefix 
nactive ndirty 	argc argv 
currently executing 	prefix argc argv 
arena purge 	prefix argc 
number pages 	argv prefix argc 
active runs 	argv prefix 
huge 	argc argv prefix 
regions current 	argc argv 
count pages 	prefix argc argv 
within unused 	prefix argc 
runs potentially 	argv prefix argc 
dirty madvise 	argv prefix 
madv 	argc argv prefix 
dontneed called 	argc argv 
tracking institute 	prefix argc argv 
limit much 	prefix argc 
dirty unused 	argv prefix argc 
memory mapped 	argv prefix 
arena 	argc argv 
size address 	prefix argc argv 
ordered arena 	prefix argc 
available runs 	argv prefix argc 
used first 	argv prefix 
best fit 	argc argv prefix 
run 	argc argv 
allocation unused 	prefix argc argv 
dirty memory 	prefix argc 
arena manages 	argv prefix argc 
dirty memory 	argv prefix 
conceptually tracked 	argc argv prefix 
arbitrarily 	argc argv 
interleaved lru 	prefix argc argv 
dirty runs 	prefix argc 
cached chunks 	argv prefix argc 
list linkage 	argv prefix 
actually semi 	argc argv prefix 
duplicated 	argc argv 
order avoid 	prefix argc 
extra arena 	argv prefix argc 
chunk map 	argv prefix 
misc space 	argc argv prefix 
overhead lru 	argc argv 
mru 	prefix argc argv 
arena chunk 	prefix argc 
chunks cache 	argv prefix argc 
node run 	argv prefix 
run runs 	argc argv prefix 
dirty extant 	argc argv 
huge 	prefix argc argv 
allocations synchronizes 	prefix argc 
huge allocation 	argv prefix argc 
update deallocation 	argv prefix 
trees chunks 	argc argv prefix 
previously allocated 	argc argv 
trees 	prefix argc argv 
differ node 	prefix argc 
ordering used 	argv prefix 
allocating chunks 	argc argv prefix 
attempt use 	argc argv 
address space 	prefix argc argv 
depending 	prefix argc 
function different 	argv prefix argc 
orderings needed 	argv prefix 
two trees 	argc argv prefix 
contents cache 	argc argv 
nodes allocated 	prefix argc argv 
via 	prefix argc 
alloc user 	argv prefix argc 
configurable chunk 	argv prefix 
hook functions 	argc argv prefix 
bins used 	argc argv 
store trees 	prefix argc argv 
free 	prefix argc 
regions jemalloc 	argv prefix argc 
arena structs 	argv prefix 
jemalloc structs 	argc argv 
number arena 	prefix argc argv 
chunk header 	prefix bulk-checkin.c 
pages 	pack compression level 
max run 	pack tmp 
size arenas 	name offset pack 
max large 	idx opts 
size number 	written alloc written 
large size 	written state 
classes 	oid packname state 
number huge 	sha stream 
size classes 	pack state flags 
jemalloc externs 	deflate pack 
jemalloc arena 	index bulk checkin 
freeing pointer 	close unlink 
lower 	sha close sha 
region zero 	close fixup 
cause assertion 	pack header footer 
failure avoid 	close strbuf 
division variable 	addf directory 
divisor possible 	finish tmp packfile 
actual 	free free 
division reduce 	memset strbuf release 
allocator throughput 	reprepare packed 
rescale factor 	git sha file 
powers numerator 	hashcmp create 
denominator divisor 	tmp packfile reset 
power 	pack idx 
divide number 	option write pack 
power two 	header die 
multiply right 	errno finish bulk 
shift positions 	checkin copyright 
becomes interval 	google inc make 
invs 	objects wrote 
size inv 	available may already 
shift omit 	exist repository 
first three 	might want 
elements never 	keep list sorted 
divide powers 	need keep 
two 	read contents size 
handled tctx 	bytes streaming 
must always 	packfile state updating 
initialized large 	hash ctx 
runs surrounding 	signal failure returning 
conditional logic 	negative resulting 
equivalent 	pack would exceed 
checking whether 	pack size 
ptr refers 	limit first pack 
large run 	caller discard 
initialize tcache 	wrote current pack 
checking size 	truncating opening 
order 	one caller call 
avoid infinite 	rewinding input 
recursion tcache 	already hashed pointer 
initialization size 	kept untouched 
allocation pointed 	caller make 
ptr large 	sure hash called 
allocation 	way caller 
common demote 	checkpoint hash status 
function callers 	calling ask 
end looking 	call pack would 
binind determine 	bust size 
ptr small 	limit lazily create 
allocation 	backing packfile 
small allocation 	state pretend going 
possibly promoted 	write one 
large small 	note idx non 
allocation make 	writing writing 
sure use 	current pack make 
promoted 	big need 
size request 	truncate start pack 
size small 	write bulk-checkin.h 
allocation jemalloc 	index bulk checkin 
arena jemalloc 	copyright google 
inlines asciilogo.h 	inc bundle.c 
ascii 	bundle signature sha 
logo copyright 	name list 
salvatore sanfilippo 	header report path 
antirez gmail 	buf status 
dot rights 	sha prereq path 
reserved redistribution 	header path 
use 	quiet header argc 
source binary 	argv header 
forms without 	verbose revs argv 
modification permitted 	refs commit 
provided following 	req message header 
conditions met 	argc argv 
redistributions 	tag revs size 
source code 	line lineend 
must retain 	date result bundle 
copyright notice 	revs pack 
list conditions 	objects bundle revs 
following disclaimer 	argc argv 
redistributions 	rls buf 
binary form 	rls fout sha 
must reproduce 	bundle revs 
copyright notice 	count oid display 
list conditions 	flag one 
following 	obj header path 
disclaimer documentation 	argc argv 
materials provided 	bundle bundle stdout 
distribution neither 	count revs 
name redis 	header bundle flags 
names contributors 	argv index 
may 	pack alloc grow 
used endorse 	hashcpy xstrdup 
promote products 	strbuf getwholeline strcmp 
derived software 	error strbuf 
without specific 	getwholeline strbuf strbuf 
prior written 	rtrim sha 
permission 	hex isspace 
software provided 	error list list 
copyright holders 	close strbuf 
contributors express 	release open error 
implied warranties 	parse bundle 
including limited 	header open memset 
implied 	parse bundle 
warranties merchantability 	header close strcmp 
fitness particular 	sha hex 
purpose disclaimed 	init revisions parse 
shall copyright 	pending error 
owner contributors 	error sha hex 
liable 	setup revisions 
direct indirect 	prepare revision walk 
incidental special 	die revision 
exemplary consequential 	error error oid 
damages including 	hex clear 
limited procurement 	commit marks free 
substitute 	list refs 
goods services 	list refs 
loss use 	list refs read 
data profits 	sha file 
business interruption 	memmem memchr memchr 
however caused 	strtoul free 
theory 	argv pushl start 
liability whether 	command error 
contract strict 	write die write 
liability tort 	die oid 
including negligence 	hex write die 
otherwise arising 	close finish 
way 	command error argv 
use software 	pushl argv 
even advised 	push start command 
possibility damage 	xfdopen strbuf 
async.c cmd 	getwholeline write die 
len key 	sha hex 
privdata 	parse die pending 
src dup 	sha hex 
privdata key 	parse die 
key privdata 	strbuf release fclose 
key privdata 	finish command 
val callback 	error dwim strlen 
dict 	read full 
port port 	tag date range 
source addr 	warning oidcmp 
path list 	lookup commit reference 
source list 	parse die 
target reply 	pending write die 
reply 	oid hex 
dstcb callbacks 	write die write 
pvariant stype 	die strlen 
sname reply 	write die free 
status done 	write die 
start str 	strcmp hold file 
len 	update dup 
privdata cmd 	die errno write 
len pvariant 	die strlen 
hasnext cstr 	init revisions 
astr clen 	compute write prerequisites 
alen sname 	setup revisions 
privdata 	error duplicates write 
format cmd 	bundle refs 
len status 	die write pack 
privdata format 	data commit 
status privdata 	file die errno 
argc argv 	verify bundle 
argvlen 	run command error 
cmd len 	bundle header 
status dict 	begins signature bundle 
gen hash 	header ends 
function sdslen 	empty line tip 
malloc memcpy 	lines name 
sdslen 	refname prerequisites name 
sdslen memcmp 	optionally followed 
sdsfree free 	subject line 
realloc dict 	remember update flag 
create dict 	allocation fast 
create redis 	check prereqs missing 
connect 	line line 
non block 	verbose errors write 
redis initialize 	pack data 
redis free 	bundle close write 
redis copy 	bundle refs 
error redis 	tips already parsed 
connect 	revs pending 
bind non 	side effect may 
block redis 	manipulate revs 
initialize redis 	pending include additional 
copy error 	necessary objects 
redis connect 	like tags returns 
unix 	number refs 
non block 	written negative error 
redis initialize 	make sure 
redis free 	refs wrote 
redis copy 	correct max count 
error write 	limiting options 
malloc 	could prevented tips 
memcpy memcpy 	getting output 
free redis 	non commit objects 
shift callback 	tags blobs 
redis run 	issue affected extra 
callback redis 	constraints run 
shift 	git bundle create 
callback redis 	bndl name 
run callback 	positive commit referenced 
dict iterator 	tag tag 
dict next 	positive end range 
redis run 	expressed terms 
callback 	tag range need 
dict entry 	include name 
val dict 	independent pack objects 
release iterator 	input tag 
dict release 	included output 
dict iterator 	otherwise would end 
dict 	triggering empty 
next redis 	bundle error end 
run callback 	header write 
dict entry 	pack data close 
val dict 	passed commit 
release iterator 	file also close 
dict 	lockfile make 
release cleanup 	copy file descriptor 
disconnect disconnect 	avoid trying 
redis free 	close twice write 
redis free 	signature init 
redis copy 	revs list objects 
error 	pack objects 
redis shift 	later write prerequisites 
callback redis 	write pack 
free redis 	basic handler bundle 
disconnect tolower 	files connect 
sdsnewlen dict 	repositories via 
find 	sneakernet invocation must 
memcpy dict 	include action 
entry val 	function create bundle 
strcasecmp dict 	provide information 
sdsfree redis 	existing bundle supporting 
shift callback 	fetch pull 
redis 	remote builtin bundle 
reply sdslen 	usage argc 
redis disconnect 	argv prefix header 
redis push 	cmd bundle 
callback redis 	file bundle buffer 
shift callback 	usage snprintf 
snprintf 	memset strcmp read 
free redis 	bundle header 
disconnect redis 	strcmp close usage 
subscribe callback 	verify bundle 
redis run 	strcmp close list 
callback free 	bundle refs 
redis 	strcmp usage 
free free 	die create bundle 
redis disconnect 	strcmp die 
redis check 	unbundle list bundle 
socket error 	refs usage 
connect redis 	bundle header begins 
disconnect 	signature bundle 
connect redis 	header ends empty 
handle connect 	line tip 
redis buffer 	lines name refname 
read redis 	prerequisites name 
disconnect read 	optionally followed subject 
redis 	line remember 
process callbacks 	update flag allocation 
redis handle 	fast check 
connect redis 	prereqs missing line 
buffer write 	line verbose 
redis disconnect 	errors write 
write 	pack data bundle 
del write 	close write 
read strchr 	bundle refs tips 
strtol strchr 	already parsed 
next argument 	revs pending side 
tolower strncasecmp 	effect may 
next 	manipulate revs pending 
argument sdsnewlen 	include additional 
dict replace 	necessary objects like 
dict replace 	tags returns 
strncasecmp strncasecmp 	number refs written 
redis push 	negative error 
callback 	make sure refs 
redis push 	wrote correct 
callback redis 	max count limiting 
push callback 	options could 
redis append 	prevented tips getting 
command write 	output non 
redisv 	commit objects 
format command 	tags blobs issue 
redis command 	affected extra 
free start 	constraints run git 
redisv command 	bundle create 
end redis 	bndl name positive 
format 	commit referenced 
command argv 	tag tag positive 
redis command 	end range 
free copyright 	expressed terms tag 
salvatore sanfilippo 	range need 
antirez gmail 	include name independent 
dot 	pack objects 
copyright pieter 	input tag included 
noordhuis pcnoordhuis 	output otherwise 
gmail dot 	would end triggering 
rights reserved 	empty bundle 
redistribution use 	error end header 
source 	write pack 
binary forms 	data close 
without modification 	passed commit file 
permitted provided 	also close 
following conditions 	lockfile make copy 
met redistributions 	file descriptor 
source 	avoid trying close 
code must 	twice write 
retain copyright 	signature init revs 
notice list 	list objects 
conditions following 	pack objects later 
disclaimer redistributions 	write prerequisites 
binary 	write pack basic 
form must 	handler bundle 
reproduce copyright 	files connect repositories 
notice list 	via sneakernet 
conditions following 	invocation must include 
disclaimer documentation 	action function 
materials 	create bundle provide 
provided distribution 	information existing 
neither name 	bundle supporting 
redis names 	fetch pull remote 
contributors may 	bundle.c bundle 
used endorse 	signature sha name 
promote 	list header 
products derived 	report path buf 
software without 	status sha 
specific prior 	prereq path header 
written permission 	path quiet 
software provided 	header argc argv 
copyright 	header verbose 
holders contributors 	revs argv refs 
express implied 	commit req 
warranties including 	message header argc 
limited implied 	argv tag 
warranties merchantability 	revs size line 
fitness 	lineend date 
particular purpose 	result bundle 
disclaimed shall 	revs pack objects 
copyright owner 	bundle revs 
contributors liable 	argc argv rls 
direct indirect 	buf rls 
incidental 	fout sha bundle 
special exemplary 	revs count 
consequential damages 	oid display flag 
including limited 	one obj 
procurement substitute 	header path argc 
goods services 	argv bundle 
loss 	bundle stdout count 
use data 	revs header 
profits business 	bundle flags argv 
interruption however 	index pack 
caused theory 	alloc grow hashcpy 
liability whether 	xstrdup strbuf 
contract 	getwholeline strcmp error 
strict liability 	strbuf getwholeline 
tort including 	strbuf strbuf 
negligence otherwise 	rtrim sha hex 
arising way 	isspace error 
use software 	list list close 
even 	strbuf release 
advised possibility 	open error parse 
damage forward 	bundle header 
declaration function 	open memset parse 
hiredis functions 	bundle header 
managing dictionary 	close strcmp sha 
callbacks 	hex init 
pub sub 	revisions parse pending 
regular connect 	error error 
functions always 	sha hex setup 
flag redis 	revisions prepare 
connected api 	revision walk die 
want 	revision error 
wait first 	error oid hex 
write received 	clear commit 
setting flag 	marks free 
reset want 	list refs list 
error field 	refs list 
accessible 	refs read sha 
directly instead 	file memmem 
requiring indirection 	memchr memchr strtoul 
redis context 	free argv 
common way 	pushl start command 
detect established 	error write 
connection 	die write die 
wait first 	oid hex 
write fired 	write die close 
assumes related 	finish command 
library functions 	error argv pushl 
already helper 	argv push 
functions 	start command xfdopen 
push shift 	strbuf getwholeline 
callbacks copy 	write die sha 
callback stack 	hex parse 
heap store 	die pending 
callback list 	sha hex parse 
copy 	die strbuf 
callback heap 	release fclose finish 
stack helper 	command error 
function free 	dwim strlen read 
context execute 	full tag 
pending callbacks 	date range warning 
reply 	oidcmp lookup 
execute callbacks 	commit reference parse 
invalid commands 	die pending 
run subscription 	write die oid 
callbacks callbacks 	hex write 
reply signal 	die write die 
lib 	strlen write 
clean execute 	die free write 
disconnect callback 	die strcmp 
redis free 	hold file 
initiated destroying 	update dup die 
context status 	errno write 
always 	die strlen init 
redis cleanup 	revisions compute 
self free 	write prerequisites setup 
context function 	revisions error 
called callback 	duplicates write bundle 
control needs 	refs die 
returned 	write pack data 
redis process 	commit file 
callbacks actual 	die errno verify 
free ing 	bundle run 
flag context 	command error bundle 
picked redis 	header begins 
process 	signature bundle header 
callbacks otherwise 	ends empty 
context immediately 	line tip lines 
free helper 	name refname 
function make 	prerequisites name 
disconnect happen 	optionally followed subject 
clean 	line remember 
make sure 	update flag allocation 
error accessible 	fast check 
clean disconnects 	prereqs missing line 
pending callbacks 	line verbose 
disconnection caused 	errors write pack 
error 	data bundle 
make sure 	close write bundle 
pending callbacks 	refs tips 
cannot call 	already parsed revs 
commands non 	pending side 
clean disconnects 	effect may manipulate 
redis 	revs pending 
free execute 	include additional necessary 
pending callbacks 	objects like 
reply tries 	tags returns number 
clean disconnect 	refs written 
redis meaning 	negative error 
stops 	make sure refs 
commands issued 	wrote correct 
tries flush 	max count limiting 
output buffer 	options could 
execute callbacks 	prevented tips getting 
remaining replies 	output non 
function 	commit objects tags 
called callback 	blobs issue 
might replies 	affected extra constraints 
safely defer 	run git 
disconnecting redis 	bundle create bndl 
process callbacks 	name positive 
otherwise 	commit referenced tag 
disconnect immediately 	tag positive 
pending callbacks 	end range expressed 
custom reply 	terms tag 
functions supported 	range need include 
pub sub 	name independent 
fail 	pack objects 
hard used 	input tag included 
locate right 	output otherwise 
callback unsubscribe 	would end triggering 
message last 	empty bundle 
unsubscribe message 	error end header 
revert 	write pack 
non subscribe 	data close passed 
mode shift 	commit file 
callback invalid 	also close lockfile 
commands connection 	make copy 
disconnected replies 	file descriptor avoid 
cue 	trying close 
really disconnect 	twice write signature 
monitor mode 	init revs 
repush callback 	list objects pack 
connection disconnected 	objects later 
simply stop 	write prerequisites write 
trying 	pack basic 
replies wait 	handler bundle 
next loop 	files connect repositories 
tick even 	via sneakernet 
context subscribed 	invocation must include 
pending regular 	action function 
callbacks 	create bundle provide 
reply pub 	information existing 
sub messages 	bundle supporting fetch 
arrive spontaneous 	pull remote 
reply subscribed 	builtin bundle usage 
context error 	argc argv 
reply 	prefix header cmd 
sent connection 	bundle file 
exceeds maximum 	bundle buffer usage 
number allowed 	snprintf memset 
connections server 	strcmp read bundle 
side seen 	header strcmp 
error 	close usage 
instead regular 	verify bundle strcmp 
reply server 	close list 
closes connection 	bundle refs strcmp 
sending prevent 	usage die 
error overwritten 	create bundle strcmp 
eof 	die unbundle 
error connection 	list bundle refs 
closed see 	usage bundle 
issue another 	header begins signature 
possibility server 	bundle header 
loading dataset 	ends empty line 
also 	tip lines 
want close 	name refname prerequisites 
connection user 	name optionally 
wait server 	followed subject line 
ready take 	remember update 
request 	flag allocation fast 
regular callbacks 	check prereqs 
errors context 	missing line 
must subscribed 	line verbose errors 
monitoring proceed 	write pack 
free ing 	data bundle close 
redis 	write bundle 
free called 	refs tips already 
callback reply 	parsed revs 
either callback 	pending side effect 
callbacks begin 	may manipulate 
either way 	revs pending include 
abort 	additional necessary 
error simply 	objects like tags 
ignore client 	returns number 
doesn know 	refs written negative 
server spit 	error make 
wire disconnect 	sure refs wrote 
error 	correct max 
reading reply 	count limiting options 
helper function 	could prevented 
detect socket 	tips getting 
status first 	output non commit 
time read 	objects tags 
write 	blobs issue affected 
fires connecting 	extra constraints 
succesful connect 	run git bundle 
callback called 	create bndl 
redis err 	name positive commit 
status context 	referenced tag 
free 	tag positive end 
later connect 	range expressed 
still progress 	terms tag range 
mark context 	need include 
connected function 	name independent pack 
called socket 	objects input 
readable 	tag included output 
processes replies 	otherwise would 
read executes 	end triggering empty 
callbacks abort 	bundle error 
connect successful 	end header 
later context 	write pack data 
still 	close passed 
connected always 	commit file also 
schedule reads 	close lockfile 
abort connect 	make copy file 
successful later 	descriptor avoid 
context still 	trying close twice 
connected 	write signature 
writing done 	init revs list 
stop writing 	objects pack 
otherwise always 	objects later write 
schedule reads 	prerequisites write 
writes sets 	pack basic handler 
pointer 	bundle files 
first argument 	connect repositories via 
length starting 	sneakernet invocation 
returns number 	must include 
bytes skip 	action function create 
following argument 	bundle provide 
helper 	information existing bundle 
function redis 	supporting fetch 
command family 	pull remote bundle.h 
functions writes 	alloc sha 
formatted command 	name prerequisites references 
output buffer 	path quiet 
registers 	path header header 
provided callback 	path argc 
function context 	argv header verbose 
accept commands 	header bundle 
connection closed 	flags header argc 
setup callback 	argv cache-tree.c 
find 	one onelen two 
command appended 	twolen path 
every channel 	pathlen mdl cmp 
pattern list 	path pathlen 
subscription callbacks 	create pos 
useful call 	path pathlen path 
unsubscribe 	slash namelen 
context subscribed 	pos istate path 
one channels 	cache entries 
patterns unsubscribe 	flags funny silent 
response every 	name next 
channel pattern 	name len dst 
unsubscribed 	src cache 
receive message 	entries baselen skip 
means append 	count flags 
callback function 	buffer missing dryrun 
command monitor 	repair invalidate 
flag push 	sub path slash 
callback 	pathlen sublen 
likely result 	subcnt subskip sub 
error reply 	path slash 
needs received 	pathlen entlen sha 
passed callback 	mode expected 
always schedule 	missing sha 
write 	istate flags cache 
write buffer 	entries skip 
non empty 	buffer path pathlen 
async.h port 	prev root 
port source 	buffer size buf 
addr path 	size subtree 
privdata 	sub subtree name 
format privdata 	buffer size 
format privdata 	path slash sub 
argc argv 	sha index 
argvlen copyright 	state index path 
salvatore sanfilippo 	flags prefix 
antirez 	entries valid newfd 
gmail dot 	file subtree 
copyright pieter 	sha flags prefix 
noordhuis pcnoordhuis 	desc entry 
gmail dot 	cnt sub subtree 
rights reserved 	istate root 
redistribution 	info parent 
use source 	root ent info 
binary forms 	flags xcalloc 
without modification 	cache free free 
permitted provided 	free free 
following conditions 	memcmp subtree name 
met 	cmp subtree 
redistributions source 	pos alloc grow 
code must 	flex alloc 
retain copyright 	mem memmove strlen 
notice list 	find subtree 
conditions following 	strchrnul subtree pos 
disclaimer 	cache free 
redistributions binary 	free memmove find 
form must 	subtree invalidate 
reproduce copyright 	path invalidate path 
notice list 	stage sha 
conditions following 	hex strlen 
disclaimer 	strlen strncmp cache 
documentation materials 	free free 
provided distribution 	sha file cache 
neither name 	fully valid 
redis names 	sha file namelen 
contributors may 	memcmp strchr 
used 	find subtree cache 
endorse promote 	update one 
products derived 	die discard unused 
software without 	subtrees strbuf 
specific prior 	init namelen memcmp 
written permission 	strchr find 
software 	subtree die sha 
provided copyright 	file strbuf 
holders contributors 	release error sha 
express implied 	hex intent 
warranties including 	strbuf grow strbuf 
limited implied 	addf strbuf 
warranties 	hash sha 
merchantability fitness 	file sha file 
particular purpose 	hashcpy hash 
disclaimed shall 	sha file write 
copyright owner 	sha file 
contributors liable 	strbuf release strbuf 
direct 	release sha 
indirect incidental 	hex verify cache 
special exemplary 	update one 
consequential damages 	strbuf grow strbuf 
including limited 	strbuf addf 
procurement substitute 	sha hex strbuf 
goods 	subtree name 
services loss 	cmp die write 
use data 	one write 
profits business 	one cache strtol 
interruption however 	strtol hashcpy 
caused theory 	sha hex xcalloc 
liability 	read one 
whether contract 	cache sub 
strict liability 	die cache free 
tort including 	read one 
negligence otherwise 	strchrnul find subtree 
arising way 	xcalloc hold 
use 	file update read 
software even 	index cache 
advised possibility 	free cache cache 
damage need 	fully valid 
forward declaration 	cache update write 
redis context 	locked index 
dictionary 	cache find hashcpy 
header included 	hashcpy rollback 
reply callback 	file write index 
prototype container 	index file 
simple singly 	hashcpy init desc 
linked list 	entry isdir 
list 	lookup parse cache 
callbacks either 	sub cache 
regular replies 	prime cache 
pub sub 	rec cache free 
connection callback 	cache prime 
prototypes context 	cache rec find 
connection 	cache traversal 
redis hold 	cache find find 
regular context 	cache traversal 
realloc setup 	cache find hashcmp 
error flags 	cache cache 
used directly 	update invalidate self 
used 	find invalidate 
hiredis library 	invalidate self exists 
data hooks 	subtree subtree 
hooks called 	pos move one 
library expects 	place entries 
start reading 	subtree pos verify 
writing 	merged also 
functions idempotent 	verify cache path 
called either 	path file 
connection terminated 	time point 
due error 	know cache stage 
per user 	entries path 
request 	file always comes 
status accordingly 	path way 
redis redis 	cache sorted also 
err called 	path appear 
first write 	means conflicting one 
received regular 	would immediately 
command 	follow first scan 
callbacks subscription 	subtrees update 
callbacks functions 	start marking existing 
proxy hiredis 	subtrees ones 
handle read 	unmarked result find 
write events 	subtrees update 
command 	end level bbb 
functions context 	slash path 
write command 	baselen bbb 
output buffer 	sublen used next 
provided callback 	loop write 
atomic.c test 	level end level 
skip 	entries removed 
test body 	index written disk 
test body 	skip remain 
test body 	consistent future disk 
test body 	index intent 
test body 	entries exist disk 
test 	index part 
atomic.c test 	generated trees invalidate 
skip test 	root force 
body test 	cache users read 
body test 	elsewhere one 
body test 	cache entry consists 
body 	following path 
test body 	nul terminated entry 
test atomic.h 	count subtree 
success success 	sha missing 
atomic fetch 	invalid subtree cache 
atomic fetch 	entries subtrees 
sub 	skip name make 
atomic compare 	sure name 
exchange strong 	exists heuristic directories 
atomic store 	often want 
atomic fetchadd 	extend immediately hence 
atomic fetchadd 	read subtree 
atomic 	whole path slash 
cmpset atomic 	name subtree 
store rel 	look free memory 
atomic atomic 	becomes part 
atomic compare 	linked list parsed 
swap atomic 	atexit able 
cas 	write fine interested 
atomic read 	updating cache 
interlocked exchange 	part next caller 
interlocked exchange 	ends old 
interlocked compare 	index unupdated 
exchange interlocked 	cache part misses 
exchange 	work performance 
sync fetch 	penalty big deal 
sync sub 	find cache 
fetch sync 	corresponds current level 
compare swap 	without exploding 
sync test 	full path textual 
atomic 	form root 
fetch atomic 	cache given root 
fetch sub 	current level 
atomic compare 	info root level 
exchange strong 	info prev 
atomic store 	root otherwise find 
atomic 	cache corresponds 
fetchadd atomic 	one level find 
fetchadd atomic 	cache-tree.h cache 
cmpset atomic 	count namelen used 
store rel 	name entry 
atomic atomic 	count sha 
atomic 	subtree subtree alloc 
compare swap 	cache index 
atomic cas 	state cache strbuf 
atomic read 	root buffer 
interlocked exchange 	size cache index 
interlocked exchange 	state sha 
interlocked 	index state index 
compare exchange 	path flags 
interlocked exchange 	prefix sha flags 
sync fetch 	prefix index 
sync sub 	state cache ent 
fetch sync 	info internally 
compare 	used update one 
swap sync 	negative means 
test atomic 	invalid bitmasks write 
atomic atomic 	cache flags 
atomic atomic 	error codes 
cas atomic 	cache.h flush level 
cas 	level level 
atomic write 	flush hash hdr 
atomic write 	signature hdr 
atomic atomic 	version hdr entries 
atomic atomic 	sec nsec 
atomic cas 	ctime mtime dev 
atomic 	ino uid 
cas atomic 	gid size ent 
write atomic 	stat data 
write atomic 	mode flags namelen 
atomic atomic 	index sha 
atomic atomic 	name dst src 
cas 	state stage 
atomic cas 	mode mode trust 
atomic write 	executable bit 
atomic write 	symlinks mode mode 
jemalloc types 	cache version 
jemalloc structs 	cache cache 
jemalloc 	alloc cache changed 
externs arithmetic 	resolve undo 
functions arithmetic 	cache split index 
result atomic 	timestamp name 
operation atomic 	hash dir hash 
operation prior 	sha untracked 
mutation 	index istate istate 
following functions 	istate bare 
must redundantly 	repository cfg git 
compute result 	work cfg 
returned functions 	path gitdir gitdir 
normally inlined 	namespaced path 
extra 	path path error 
operations optimized 	code suspect 
away values 	prefix pathspec prefix 
aren used 	len path 
callers atomic 	prefix len remaining 
read atomic 	path prefix 
atomic 	len path 
sub atomic 	prefix name prefix 
cas atomic 	name diagnose 
write bit 	misspelt rev prefix 
operations outputs 	name prefix 
inputs outputs 	path git dir 
inputs 	real git 
outputs inputs 	dir dir flags 
clobbers implied 	index state 
xchgq outputs 	index state pathspec 
inputs clobbers 	istate path 
atomic fetchadd 	must exist index 
doesn 	state path 
exist ever 	index state index 
use function 	state index 
systems atomic 	state flags index 
fetchadd documented 	state index 
atomic api 	state path istate 
expose 	name namelen 
atomic exchange 	istate name 
bit operations 	istate name namelen 
outputs inputs 	igncase index 
outputs inputs 	state name namelen 
outputs inputs 	index state 
implied 	option index state 
xchgl outputs 	pos name 
inputs clobbers 	index state pos 
documented atomic 	istate index 
api expose 	state path index 
atomic exchange 	state path 
pointer 	stat flags index 
operations size 	state path 
operations operations 	flags mode sha 
jemalloc inlines 	path stage 
base.c mtx 	refresh options index 
avail szad 	state index 
nodes 	state index 
allocated resident 	state cache entry 
mapped node 	stat index 
node minsize 	state cache entry 
node csize 	stat index 
nsize addr 	sha path flags 
size 	istate index 
ret csize 	state flags pathspec 
usize node 	seen header 
key allocated 	msg index state 
resident mapped 	file file 
jemalloc valgrind 	trust executable bit 
make 	trust ctime 
mem undefined 	check stat quote 
jemalloc valgrind 	path fully 
make mem 	symlinks minimum abbrev 
undefined node 	abbrev ignore 
alloc cacheline 	unchanged prefer symlink 
ceiling 	refs log 
chunk ceiling 	updates warn 
chunk alloc 	ambiguous refs warn 
node dalloc 	refname ambiguity 
page ceiling 	shared repository apply 
extent node 	whitespace apply 
init 	ignorewhitespace git attributes 
cacheline ceiling 	file zlib 
extent node 	compression level core 
init malloc 	compression level 
mutex extent 	core compression seen 
szad nsearch 	packed git 
extent 	window size packed 
szad chunk 	git limit 
alloc extent 	delta cache limit 
node addr 	big file 
extent node 	threshold pack size 
size extent 	limit cfg 
node 	check replace refs 
addr extent 	git replace 
node size 	fsync files 
extent node 	core preload index 
size extent 	core apply 
szad insert 	sparse checkout precomposed 
node 	unicode protect 
dalloc page 	hfs protect ntfs 
ceiling page 	git env 
ceiling jemalloc 	git index env 
valgrind make 	git graft 
mem defined 	env git common 
malloc 	dir env 
mutex unlock 	paranoia comment line 
malloc mutex 	comment line 
malloc mutex 	notes name grafts 
unlock malloc 	replace parents 
mutex init 	repository format version 
extent 	repository format 
szad malloc 	precious objects attribute 
mutex prefork 	attribute attribute 
malloc mutex 	attribute attribute 
postfork parent 	attribute attribute attribute 
malloc 	attribute sha 
mutex postfork 	sha sha sha 
child data 	len hex 
mtx must 	sha len sha 
held mtx 	oid sha 
must held 	sha oid oid 
mtx 	sha oid 
must held 	sha dst sha 
allocate enough 	src dst 
space also 	src hash oid 
carve node 	sha path 
necessary alloc 	path suffix len 
guarantees 	pattern suffix 
demand zeroed 	len mode pattern 
memory order 	mode path 
make multi 	path path path 
page sparse 	strict path 
data structures 	path path 
radix 	path prefix prefix 
nodes efficient 	dst src 
respect physical 	prefix len dst 
memory usage 	src path 
round size 	prefixes path suffix 
nearest multiple 	path name 
cacheline 	filename read sha 
size chance 	file extended 
cache line 	lookup replace sha 
sharing use 	sha flag 
existing space 	buf len type 
allocate space 	sha buf 
one 	len type sha 
page resident 	buf len 
every page 	type sha flags 
boundary crossed 	pretend sha 
allocation base.h 	file sha 
size allocated 	mtime name sha 
resident 	size stream 
mapped jemalloc 	map mapsize buffer 
types jemalloc 	bufsiz hdr 
structs jemalloc 	sizep check packed 
externs jemalloc 	crc sha 
inlines bio.c 	buf size type 
bio 	tmpfile filename 
threads bio 	sha sha flags 
mutex bio 	sha oid 
condvar bio 	sha sha sha 
jobs bio 	type hexval 
pending time 	table path mode 
arg 	symlink path 
arg arg 	str sha str 
arg attr 	sha str 
stacksize arg 	sha str sha 
type arg 	str sha 
arg arg 	str sha 
job 	name prefix str 
arg job 	flags sha 
type sigset 	orc prefix hex 
type val 	sha hex 
err pthread 	sha sha sha 
mutex init 	oid str 
pthread 	len strbuf str 
cond init 	sha name 
list create 	len mode name 
pthread attr 	len mode 
init pthread 	name len mode 
attr getstacksize 	name len 
pthread 	mode name len 
attr setstacksize 	name len 
pthread create 	name len stage 
server log 	name len 
exit zmalloc 	stage sha required 
time pthread 	type size 
mutex 	sha ret 
list node 	peel type path 
tail pthread 	fmt path 
cond signal 	fmt pager program 
pthread mutex 	pager use 
unlock server 	color cmd child 
log 	process pager 
pthread setcancelstate 	editor program askpass 
pthread setcanceltype 	program excludes 
pthread mutex 	file dst line 
sigemptyset sigaddset 	linelen buf 
pthread sigmask 	data bytes prog 
server 	prefix pathspec 
log strerror 	flags diff refresh 
list length 	index whitespace 
pthread cond 	rule cfg line 
wait list 	len rule 
first pthread 	line len rule 
mutex 	stream reset 
unlock close 	strbuf line 
aof fsync 	len rule name 
server panic 	prefix cmdline 
zfree pthread 	argv cmdline errno 
mutex list 	repository prefix 
del 	startup info strategy 
node pthread 	xopts xopts 
mutex pthread 	common head arg 
mutex unlock 	remotes overwrite 
pthread cancel 	ignore file argv 
pthread server 	path millisec 
log 	dir share memcpy 
strerror server 	offsetof offsetof 
log background 	islnk isdir isgitlink 
service redis 	permissions isreg 
file operations 	islnk isreg isreg 
need perform 	create mode 
background 	create mode 
currently single 	ntohl isreg isdir 
operation background 	isgitlink islnk 
close system 	isreg permissions islnk 
call needed 	isdir hashcmp 
process last 	hashcmp hashcmp memcpy 
owner 	hashcpy memset 
reference file 	hashclr hashcmp dir 
closing means 	sep dos 
unlinking deletion 	drive prefix lookup 
file slow 	replace lookup 
blocking server 	replace sha file 
future 	flags platform 
either implementing 	underlying implementation sha 
things need 	could open 
libeio however 	ssl blk sha 
probably term 	apple common 
uses file 	crypto etc note 
may 	including sha 
want put 	header may 
redis specific 	already defined platform 
background tasks 	sha ctx 
instance impossible 	implementations like block 
need non 	sha ppc 
blocking 	sha list open 
flushdb flushall 	ssl compatible 
implementation design 	sha implementations length 
design trivial 	bytes hex 
structure representing 	digits name sha 
job perform 	unknown mode 
different 	impossible combination ififo 
job queue 	ifchr directory 
every job 	link link another 
type every 	git directory 
wait jobs 	normally valid mode 
queue process 	also happens 
every 	ifdir iflnk mode 
job sequentially 	bits also 
jobs type 	used internally 
guaranteed processed 	computations must overlap 
least recently 	valid modes 
inserted recently 	must emitted outside 
inserted 	world appear 
older jobs 	disk network words 
processed first 	temporary fields 
currently way 	internally use stay 
creator job 	house approach 
notified completion 	valid standard fits 
operation 	bits git 
added needed 	codebase mode assumed 
copyright salvatore 	least bits 
sanfilippo antirez 	used internally diff 
gmail dot 	intensive research 
rights reserved 	course many years 
redistribution 	shown port 
use source 	totally unused anything 
binary forms 	search port 
without modification 	match documents 
permitted provided 	www google puts 
following conditions 	port properly 
met 	assigned git use 
redistributions source 	iana git 
code must 	assigned git tcp 
retain copyright 	git pack 
notice list 	transfer service git 
conditions following 	udp git 
disclaimer 	pack transfer service 
redistributions binary 	linus torvalds 
form must 	torvalds osdl point 
reproduce copyright 	contact september 
notice list 	see http www 
conditions following 	iana assignments 
disclaimer 	port numbers basic 
documentation materials 	data structures 
provided distribution 	directory cache 
neither name 	dirc cache time 
redis names 	low bits 
contributors may 	time doesn matter 
used 	overflows check 
endorse promote 	equality bits save 
products derived 	link extension 
software without 	range ffff fff 
specific prior 	flags divided 
written permission 	two parts memory 
software 	flags disk 
provided copyright 	ones flags extended 
holders contributors 	flags saved 
express implied 	disk want save 
warranties including 	flag extended 
limited implied 	flags memory flags 
warranties 	work directory 
merchantability fitness 	used temporarily mark 
particular purpose 	paths matched 
disclaimed shall 	pathspecs extended 
copyright owner 	disk flags extended 
contributors liable 	future extension 
direct 	safeguard avoid saving 
indirect incidental 	wrong flags 
special exemplary 	extended won saved 
consequential damages 	semantic known 
including limited 	bits ffff saved 
procurement substitute 	flags already 
goods 	bits currently memory 
services loss 	flags forward 
use data 	structure decls copy 
profits business 	sha stat 
interruption however 	state cache entry 
caused theory 	one another 
liability 	never change name 
whether contract 	hash state 
strict liability 	copy hash chain 
tort including 	name restore 
negligence otherwise 	hash state 
arising way 	unclassified changes name 
use 	hashing future 
software even 	expansion check local 
advised possibility 	repo env 
damage following 	list environment variable 
used hold 	expected contain 
number pending 	indicating whether treat 
jobs 	git dir 
every type 	foo git git 
allows export 	git work 
bio pending 	given expected users 
jobs type 	make use 
api useful 	use internally communicate 
main 	sub processes 
wants perform 	bare repo defaults 
operation may 	repository local 
involve objects 	git environment variables 
shared background 	cleared git 
main wait 	spawns sub 
longer 	process runs inside 
jobs type 	another repository 
executed performing 	terminated makes easy 
sensible operation 	pass env 
data also 	parameter run command 
useful reporting 	invocation simple 
structure 	walk given path 
represents background 	git directory 
job used 	note looks directory 
locally file 	want know 
api expose 	whether foo git 
internals time 	repository must 
job 	feed path foo 
created job 	given path 
specific arguments 	root git repository 
pointers need 	submodule bare 
pass three 	repositories creating bare 
arguments pass 	repository foo 
pointer 	git calling 
structure alike 	git repository foo 
make sure 	run read 
enough stack 	errors err side 
perform things 	saying yes 
main initialize 	usually consider sub 
background 	repos precious 
system spawning 	would prefer err 
initialization state 	side disrupting 
vars objects 	deleting realloc buffer 
stack size 	pointed variable 
may small 	hold least entries 
system 	number entries 
world full 	currently allocated alloc 
solaris fixes 	standard growing 
ready spawn 	factor alloc macro 
threads use 	use expression 
single argument 	side effect 
function 	alloc initialize use 
accepts order 	cache information 
pass job 	testting replace file 
responsible check 	directory skip 
type within 	conflict checks append 
right interval 	read replace 
make 	existing ones invalidate 
killable time 	cache stat 
bio kill 	comparison even valid 
threads work 	check contents 
reliably block 	report dirty racily 
sigalrm sure 	clean entries 
main 	stat comparison even 
receive watchdog 	skip worktree 
signal loop 	ignore non existent 
always starts 	files stat 
hold pop 	update enable stat 
job queue 	refresh record 
possible 	data use 
unlock background 	check whether file 
system know 	might changed 
stand alone 	consistent file changed 
job structure 	since filled 
process process 	differences combination mtime 
job 	changed ctime 
accordingly type 	changed owner changed 
reiterating loop 	inode changed 
longer jobs 	data changed ignore 
process block 	valid allow 
pthread cond 	unmerged quiet ignore 
wait 	non existent 
number pending 	ignore submodules user 
jobs specified 	friendly output 
type kill 	needs update environment 
running bio 	bits configuration 
threads unclean 	mechanism replace refs 
way 	need run 
function used 	variable initialized 
critical stop 	unless replace used 
threads reason 	git replace 
currently redis 	objects commands want 
crash instance 	replace references 
sigsegv 	active optimization also 
order perform 	replace references 
fast memory 	sought none include 
check without 	broken refs 
threads messing 	iterations generally choke 
memory bio.h 	dangerous operations 
type 	rather letting silently 
arg arg 	proceed without 
arg type 	taking broken account 
type num 	character begins 
type copyright 	commented line user 
salvatore sanfilippo 	editable file 
antirez 	subject stripspace git 
gmail dot 	repo version 
rights reserved 	version write 
redistribution use 	read variant highest 
source binary 	number know 
forms without 	handle statically allocated 
modification 	filename either 
permitted provided 	generically mkpath repository 
following conditions 	directory git 
met redistributions 	path submodule repository 
source code 	directory git 
must retain 	path submodule cases 
copyright 	note result 
notice list 	may overwritten another 
conditions following 	call functions 
disclaimer redistributions 	consider safer dup 
binary form 	strbuf formats 
must reproduce 	cases versions already 
copyright 	removed define 
notice list 	memoized git 
conditions following 	path like git 
disclaimer documentation 	path func 
materials provided 	git path foo 
distribution neither 	foo use 
name 	one ones name 
redis names 	file local 
contributors may 	database would used 
used endorse 	store loose 
promote products 	specified sha pointer 
derived software 	statically allocated 
without 	buffer overwritten time 
specific prior 	function called 
written permission 	name local packfile 
software provided 	specified sha 
copyright holders 	name pointer memory 
contributors express 	overwritten time 
implied 	function called name 
warranties including 	local pack 
limited implied 	index file 
warranties merchantability 	specified sha name 
fitness particular 	pointer memory 
purpose disclaimed 	overwritten time function 
shall 	called abbreviated 
copyright owner 	sha unique within 
contributors liable 	repository database 
direct indirect 	result least len 
incidental special 	characters nul 
exemplary consequential 	terminated non version 
damages 	returns buffer 
including limited 	overwritten subsequent calls 
procurement substitute 	variant writes 
goods services 	buffer supplied caller 
loss use 	must least 
data profits 	git sha hexsz 
business 	bytes number 
interruption however 	bytes written excluding 
caused theory 	nul terminator 
liability whether 	note version 
contract strict 	avoids buffer fully 
liability tort 	reentrant calls 
including 	non reentrant git 
negligence otherwise 	code permissions 
arising way 	passing mode arguments 
use software 	open note 
even advised 	note note perm 
possibility damage 	umask old 
exported 	perm old perm 
api background 	everybody enumerations 
job opcodes 	must changed old 
deferred close 	repositories core 
syscall deferred 	sharedrepository written numeric 
aof fsync 	format therefore 
bitmap.c 	values preserved compatibility 
binfo nbits 	reasons create 
count binfo 	directory containing named 
nbits binfo 	path care 
bitmap binfo 	somewhat safe 
extra count 	races one scld 
bitmap 	error values 
bits groups 	indicate success failure 
bitmap bits 	scld vanished 
groups bitmap 	indicates one ancestor 
info init 	directories path 
bitmap info 	existed one point 
ngroups 	function call 
memset compute 	suddenly vanished probably 
number groups 	another process 
necessary store 	pruned directory working 
nbits bits 	robust kind 
progressively work 	race callers might 
upward 	want invoking 
levels reaching 	function returns scld 
level requires 	vanished newly 
one bits 	allocated evaluation 
actually inverted 	xdg config home 
regard external 	git filename 
bitmap 	xdg config home 
bitmap starts 	non empty 
bits trailing 	otherwise home config 
unused bits 	git filename 
note uses 	upon error replacement 
bit correspond 	function declared 
first 	benefit lookup replace 
logical bit 	please call 
extra bits 	directly sha replaced 
significant bits 	replacement name 
last iteratively 	replaced recursively necessary 
bits 	either sha 
starting beginning 	pointer permanently allocated 
iteratively unset 	replacement suppressed 
bits starting 	always sha read 
end verify 	unpack sha 
bitmap sfu 	file memory 
reaches 	write memory sha 
unset bits 	file flag 
iteratively bits 	enable extra checks 
starting beginning 	accessing packed 
verify bitmap 	objects iff named 
sfu looks 	sha whether 
past 	local alternate database 
prev size 	whether packed 
size binfo 	loose function respect 
bitmap binfo 	replace references 
bitmap binfo 	quick flag check 
bitmap binfo 	pack directory 
bitmap 	cannot find means 
bitmap size 	may give 
bitmap info 	negative answer another 
init malloc 	process simultaneously 
bitmap info 	repacking iff alternate 
ngroups bitmap 	database loose 
init 	specified name 
bitmap free 	function respect replace 
bitmap info 	references convert 
init malloc 	hex sha representation 
bitmap info 	symlink path 
ngroups bitmap 	used entry follow 
init 	symlinks symlinks 
bitmap bitmap 	point outside repository 
full free 	read sha 
bitmap info 	hexadecimal format characters 
init malloc 	starting hex 
bitmap info 	write result sha 
ngroups 	binary form 
bitmap init 	success reading stops 
bitmap bitmap 	nul encountered 
full bitmap 	input safe pass 
unset bitmap 	function arbitrary 
bitmap full 	terminated convert binary 
free 	sha hex 
bitmap info 	equivalent variant 
init malloc 	reentrant writes nul 
bitmap info 	terminated output 
ngroups bitmap 	buffer must least 
init bitmap 	git sha 
sfu 	hexsz bytes returns 
bitmap full 	pointer convenience 
bitmap unset 	non variant returns 
bitmap sfu 	buffer uses 
bitmap unset 	ring buffers making 
bitmap bitmap 	safe make 
bitmap 	multiple calls single 
sfu bitmap 	statement like 
unset bitmap 	sha hex one 
sfu bitmap 	sha hex 
full free 	two buffer result 
test compute 	buffer sha 
number 	hex convenience helper 
groups necessary 	passing constant 
store nbits 	type like 
bits progressively 	show date date 
work upward 	mode normal 
levels reaching 	signals success time 
level 	part result 
requires one 	may input lacks 
bits actually 	timestamp zone 
inverted regard 	like show date 
external bitmap 	pull timestamp 
bitmap starts 	parameters ident split 
bits 	also sanity 
trailing unused 	check values produce 
bits note 	well known 
uses bit 	sentinel date appear 
correspond first 	bogus compare 
logical bit 	split idents equality 
extra 	strict ordering 
bits significant 	note compare 
bits last 	ident part line 
iteratively bits 	ignoring timestamp 
starting beginning 	two fields must 
iteratively unset 	choose one 
bits 	primary key currently 
starting end 	arbitrarily pick 
verify bitmap 	email something like 
sfu reaches 	git objects 
unset bits 	pack xxxxx pack 
iteratively bits 	hook report 
starting 	invalid files pack 
beginning verify 	directory mmap 
bitmap sfu 	index file specified 
looks past 	packfile already 
bitmap.c binfo 	mmapped success munmap 
nbits count 	index file 
binfo 	specified packfile currently 
nbits binfo 	mmapped make 
bitmap binfo 	sure pointer 
extra count 	access mmap index 
bitmap bits 	file within 
groups bitmap 	bounds provide least 
bits 	bytes data 
groups bitmap 	note necessary variable 
info init 	length segments 
bitmap info 	file like bit 
ngroups memset 	extended offset 
compute number 	table compare size 
groups 	length parts 
necessary store 	open file sha 
nbits bits 	nth within 
progressively work 	specified packfile open 
upward levels 	index already 
reaching level 	open points sha 
requires 	within mmapped 
one bits 	index error offset 
actually inverted 	nth within 
regard external 	specified packfile 
bitmap bitmap 	index must already 
starts bits 	opened named 
trailing 	sha present specified 
unused bits 	packfile offset 
note uses 	within packfile otherwise 
bit correspond 	iterate files 
first logical 	loose parts directory 
bit extra 	path triggering 
bits 	following callbacks loose 
significant bits 	called loose 
last iteratively 	find loose cruft 
bits starting 	called files 
beginning iteratively 	appear loose objects 
unset bits 	note look 
starting 	loose directories objects 
end verify 	report objects 
bitmap sfu 	foobar cruft loose 
reaches unset 	subdir called 
bits iteratively 	top level 
bits starting 	hashed subdirectory directory 
beginning 	objdir called 
verify bitmap 	objects directory processed 
sfu looks 	callback ignored 
past prev 	callbacks returning non 
size size 	zero end 
binfo bitmap 	iteration buf variant 
binfo 	path strbuf 
bitmap binfo 	also used scratch 
bitmap binfo 	buffer restored 
bitmap bitmap 	original contents function 
size bitmap 	returns iterate 
info init 	loose packed objects 
malloc 	local repository 
bitmap info 	alternates repositories unless 
ngroups bitmap 	local flag 
init bitmap 	request response 
free bitmap 	nothing expose cached 
info init 	nothing expose 
malloc 	loose dumb servers 
bitmap info 	support git 
ngroups bitmap 	config parse key 
init bitmap 	returns negated 
bitmap full 	git config gently 
free bitmap 	git config 
info 	multivar gently match 
init malloc 	parse config 
bitmap info 	key form section 
ngroups bitmap 	subsection key 
init bitmap 	gets handed config 
bitmap full 	caller provides 
bitmap 	section match otherwise 
unset bitmap 	subsection key 
bitmap full 	parameters filled function 
free bitmap 	subsection missing 
info init 	contents list 
malloc bitmap 	ordered according position 
info 	config files 
ngroups bitmap 	order parsing files 
init bitmap 	key pair 
sfu bitmap 	last position git 
full bitmap 	config last 
unset bitmap 	item list hack 
sfu 	test programs 
bitmap unset 	like test dump 
bitmap bitmap 	untracked cache 
bitmap sfu 	ensure modify untracked 
bitmap unset 	cache reading 
bitmap sfu 	use otherwise helper 
bitmap 	functions pager 
full free 	alloc pkt line 
test compute 	success addition 
number groups 	file failed files 
necessary store 	ignore errors 
nbits bits 	specified flags 
progressively 	diff match trees 
work upward 	whitespace rules 
levels reaching 	used diff apply 
level requires 	last two 
one bits 	digits tab width 
actually inverted 	files takes 
regard 	negative returned split 
external bitmap 	cmdline git 
bitmap starts 	merge encapsulate concept 
bits trailing 	whether file 
unused bits 	changed since last 
note uses 	uses criteria 
bit 	similar used index 
correspond first 	returns path 
logical bit 	regular file symlink 
extra bits 	regular file 
significant bits 	matches saved stat 
last iteratively 	validity otherwise 
bits 	missing inaccessible 
starting beginning 	file considered match 
iteratively unset 	initialized previous 
bits starting 	update found inaccessible 
end verify 	file update 
bitmap sfu 	stat validity file 
reaches 	opened descriptor 
unset bits 	file missing inaccessible 
iteratively bits 	regular file 
starting beginning 	future calls stat 
verify bitmap 	validity check 
sfu looks 	match iff one 
past 	conditions continues 
bitmap.h offset 	create directory share 
nbits nlevels 	nonzero adjust 
levels binfo 	permissions according shared 
nbits binfo 	repository setting 
nbits bitmap 	use directories 
binfo 	git dir use 
bitmap binfo 	working directories 
bitmap binfo 	cache cat-file.c enabled 
bit bitmap 	follow symlinks 
binfo bit 	print contents buffer 
bitmap binfo 	output objects 
bitmap 	format opt exp 
binfo bit 	type obj 
bitmap binfo 	name unknown type 
rgoff bitmap 	sha buf 
binfo bit 	size obj context 
goff bitmap 	flags args 
binfo 	blob sha buffer 
bit goff 	target sha 
bitmap binfo 	size disk size 
bit bitmap 	rest delta 
binfo bit 	sha mark query 
goff propagate 	split whitespace 
bitmap 	info atom 
bitmap bitmap 	slen alen atom 
full jemalloc 	len vdata 
ffsl jemalloc 	data start data 
ffsl bitmap 	end opt 
bitmap bitmap 	data len opt 
maximum 	data sha 
bitmap bit 	size contents obj 
count bitmap 	name opt 
maxbits number 	data buf obj 
bits per 	name opt 
number groups 	data ctx flags 
required 	opt expand 
store given 	sha vdata data 
number bits 	sha path 
number groups 	data sha pack 
required particular 	pos data 
level given 	opt buf data 
number 	save warning 
bits assuming 	retval cat 
number levels 	file usage opt 
number groups 	arg unset 
required given 	argc argv prefix 
number bits 	opt obj 
maximum 	name batch unknown 
number groups 	type options 
required support 	sha context die 
bitmap maxbits 	sha info 
maximum number 	extended die strbuf 
levels possible 	release sha 
jemalloc 	info extended die 
types offset 	sha file 
level groups 	die textconv sha 
within groups 	info die 
logical number 	cmd stream blob 
bits bitmap 	read sha 
stored 	file die type 
bottom level 	sha info 
number levels 	read sha 
necessary nbits 	file skip prefix 
first nlevels 	sha hex 
elements used 	die sha hex 
levels 	free hashcpy 
ordered bottom 	sha info stream 
top bottom 	blob read 
level stored 	reference die die 
levels jemalloc 	write die 
structs jemalloc 	strlen memcmp atom 
externs 	strbuf addstr 
bitmap full 	sha hex atom 
iff root 	strbuf addstr 
propagate state 	atom strbuf addf 
transitions sfu 	atom strbuf 
first unset 	addf atom strbuf 
propagate 	addstr atom 
state transitions 	strbuf addstr sha 
jemalloc inlines 	hex die 
bitops.c offset 	strchr die 
loffset err 	expand atom fwrite 
count bits 	die errno 
bitsinbyte 	write die fflush 
aux aux 	stream blob 
aux aux 	die sha hex 
aux aux 	read sha 
aux count 	file die sha 
bit skipval 	hex die 
one 	sha hex die 
pos err 	sha hex 
bitoffset bit 	batch write free 
byteval bitval 	sha info 
llbuf bitoffset 	extended sha hex 
bit bitval 	fflush strbuf 
opname 	expand strbuf addch 
targetkey numkeys 	batch write 
objects src 	strbuf release 
len maxlen 	print die batch 
minlen res 	write sha 
output lres 	context strlen strlen 
start 	strlen die 
end strlen 	fflush fflush batch 
llbuf bytes 	write hashcpy 
bit start 	batch write sha 
end strlen 	append sha 
llbuf end 	append memset strbuf 
given 	expand loose 
bytes pos 	packed sha unique 
reply reply 	sha clear 
error server 	strbuf getline strpbrk 
panic bit 	strchr batch 
offset argument 	one strbuf release 
reply 	userdiff config 
reply error 	git config strcmp 
lookup key 	git config 
write create 	parse options 
sdsnewlen check 	usage options usage 
type unshare 	options usage 
sdsgrowzero 	options usage options 
signal modified 	batch objects 
key notify 	die cat one 
keyspace reply 	file git 
bit offset 	information manager hell 
argument lookup 	copyright linus 
key 	torvalds custom pretty 
read reply 	print otherwise 
check type 	spit data attempted 
sds encoded 	dereference tag 
sdslen reply 	blob failed may 
strcasecmp strcasecmp 	dereference mechanisms 
strcasecmp 	code aware fall 
strcasecmp reply 	back usual 
reply error 	mark query expand 
zmalloc zmalloc 	anything rather 
zmalloc lookup 	mark info 
key read 	items wish query 
check 	whether split 
type decr 	input whitespace feeding 
count zfree 	sha decided 
zfree zfree 	mark query phase 
decoded sdslen 	whether rest 
sdsnewlen memcpy 	token format mark 
memcpy 	query run 
decr count 	info passed sha 
zfree zfree 	info extended 
zfree create 	point data elements 
key notify 	retrieve response 
keyspace decr 	expand special mark 
count 	query flag 
signal modified 	prime info handed 
key notify 	sha info 
keyspace reply 	extended printing always 
lookup key 	fill type 
read reply 	since want 
check 	decide whether stream 
type sdslen 	going call 
reply reply 	sha potentially large 
reply reply 	number objects 
reply redis 	large cases actual 
popcount reply 	sha cost 
reply 	check one also 
error lookup 	warn ends 
key read 	dwarfing actual cost 
reply check 	lookups work 
type sdslen 	around turning warning 
reply reply 	split first 
reply 	whitespace tying beginning 
reply redis 	saving remainder 
bitpos reply 	data rest check-attr.c 
reply bit 	attrs cached 
operations copyright 	attrs stdin 
salvatore sanfilippo 	paths check attr 
antirez 	usage nul 
gmail dot 	term line check 
rights reserved 	attr options 
redistribution use 	cnt check file 
source binary 	prefix cnt 
forms without 	check file full 
modification 	path prefix 
permitted provided 	cnt check buf 
following conditions 	unquoted getline 
met redistributions 	msg argc argv 
source code 	prefix check 
must retain 	cnt doubledash filei 
copyright 	name attr 
notice list 	attr attr unset 
conditions following 	git attr 
disclaimer redistributions 	name quote style 
binary form 	git attr 
must reproduce 	name prefix 
copyright 	path strlen git 
notice list 	check attr 
conditions following 	die output attr 
disclaimer documentation 	git attrs 
materials provided 	die output attr 
distribution neither 	free free 
name 	getline strbuf reset 
redis names 	unquote style 
contributors may 	die strbuf swap 
used endorse 	check attr 
promote products 	maybe flush die 
derived software 	strbuf release 
without 	strbuf release error 
specific prior 	usage options 
written permission 	bare repository setup 
software provided 	work git 
copyright holders 	config parse options 
contributors express 	read cache 
implied 	die git 
warranties including 	attr direction strcmp 
limited implied 	error usage 
warranties merchantability 	error usage error 
fitness particular 	usage error 
purpose 	usage error usage 
disclaimed shall 	xcalloc git 
copyright owner 	attr error check 
contributors liable 	attr stdin 
direct indirect 	paths check attr 
incidental special 	maybe flush 
exemplary 	die path attrname 
consequential damages 	attrvalue process 
including limited 	attribute arguments treat 
procurement substitute 	arguments attribute 
goods services 	names treat exactly 
loss use 	one argument 
data 	attribute name check 
profits business 	file argument 
interruption however 	check-ignore.c quiet 
caused theory 	verbose stdin paths 
liability whether 	show non 
contract strict 	matching index check 
liability 	ignore usage 
tort including 	nul term line 
negligence otherwise 	check ignore 
arising way 	options path exclude 
use software 	bang slash 
even advised 	dir prefix argc 
possibility 	argv full 
damage helpers 	path seen exclude 
low level 	pathspec dir 
bit functions 	prefix buf unquoted 
helper function 	pathspec getline 
used getbit 	num ignored argc 
setbit 	argv prefix 
parses bit 	num ignored 
offset argument 	dir write name 
making sure 	quoted quote 
error returned 	style quote style 
negative overflows 	fputc parse 
redis 	pathspec find pathspecs 
limit limit 	matching index 
offset bytes 	last exclude matching 
count number 	output exclude 
bits binary 	free getline strbuf 
pointed count 	reset unquote 
bytes 	style die strbuf 
implementation function 	swap check 
required work 	ignore maybe flush 
input length 	die strbuf 
count initial 	release strbuf release 
bytes aligned 	git config 
bit 	parse options die 
count bits 	die die 
bytes time 	die die 
count remaining 	die read cache 
bytes position 	die memset 
first bit 	setup standard excludes 
one 	check ignore 
bit zero 	stdin paths check 
bit bitmap 	ignore maybe 
starting count 	flush die clear 
bytes function 	directory check 
guaranteed bit 	ignore needs paths 
since 	magic beyond 
zero bit 	really irrelevant look 
found returns 	pathspecs matching 
count assuming 	entries index since 
zero padded 	ignored order 
right however 	consistent git status 
bit 	git etc 
possible single 	read cache necessary 
bit bitmap 	watch submodules 
special returned 	check-mailmap.c use 
position bit 	stdin check mailmap 
caller process 	usage check 
whole 	mailmap options mailmap 
words first 	contact name 
seeking first 	mail namelen maillen 
word ones 	ident argc 
zeros respectively 	argv prefix mailmap 
lookig zeros 	buf split 
ones 	ident line strlen 
much faster 	die map 
large contiguous 	user git config 
blocks bits 	parse options 
compared vanilla 	die read mailmap 
bit per 	check mailmap 
bit 	maybe flush die 
processing note 	strbuf getline 
start address 	check mailmap maybe 
aligned consume 	flush die 
aligned skip 	strbuf release 
initial bits 	clear mailmap check-racy.c 
aligned 	dirty clean 
skip bits 	racy read cache 
full word 	lstat error 
step load 	strerror match stat 
bytes word 	match stat 
considering first 	check-ref-format.c builtin check 
significant 	format usage 
basically consider 	refname ret prev 
written big 	arg nongit 
endian since 	argc argv prefix 
consider bits 	normalize flags 
left right 	refname xmallocz strlen 
first 	setup git 
bit position 	directory gently strbuf 
zero note 	check branch 
loading designed 	die strcmp usage 
work even 	strcmp check 
bytes left 	format branch 
count 	strcmp strcmp strcmp 
less full 	strcmp strcmp 
word pad 	usage usage collapse 
zero right 	slashes check 
special bits 	refname format git 
zero looking 	information manager 
one 	hell copy refname 
signal single 	leading slashes 
whole happen 	removed runs adjacent 
looking right 	slashes replaced 
zero padded 	single slashes function 
last word 	similar normalize 
left 	path copy stripped 
scan bit 	meet check 
bit first 	format simpler needs 
thing need 	checkout-index.c nul 
single significant 	term line 
position know 	checkout stage tempfile 
size 	topath state 
use simple 	name prefix name 
trick bits 	prefix namelen 
bits msb 	pos name checkout 
bits msb 	errs prefix 
reached point 	prefix length errs 
bug 	last builtin 
algorithm since 	checkout index usage 
match handled 	file opt 
special avoid 	arg unset argc 
warnings bits 	argv prefix 
related commands 	newfd read stdin 
getbit 	prefix length 
setbit bitcount 	index opt builtin 
bitop setbit 	checkout index 
key offset 	options arg buf 
bitvalue bits 	unquoted getline 
cleared current 	putchar fputs 
values 	putchar fputs putchar 
update bit 	write name 
original getbit 	quoted relative strlen 
key offset 	cache name 
bitop name 	pos namelen memcmp 
target key 	stage stage 
src 	checkout entry stage 
key src 	write tempfile 
key src 	record fputc stage 
key src 	stage namelen 
key source 	memcmp namelen namelen 
objects source 	memcmp namelen 
pointers 	write tempfile record 
length src 	checkout entry 
max len 	stage write tempfile 
min len 	record exit 
among input 	strcmp die strcmp 
keys resulting 	usage options 
parse 	git config 
operation name 	strlen read cache 
sanity check 	die parse 
accepts single 	options strlen hold 
key argument 	locked index 
lookup keys 	die die prefix 
store 	path checkout 
pointers objects 	file free die 
handle non 	getline strbuf 
existing keys 	reset unquote style 
empty error 	die strbuf 
one keys 	swap prefix path 
compute 	checkout file 
bit operation 	free strbuf release 
least one 	strbuf release 
empty fast 	checkout write locked 
path far 	index die 
data input 	check files current 
bitmaps 	cache directory 
take fast 	copyright linus 
path performs 	torvalds checkout stage 
much better 	already done 
vanilla algorithm 	error reporting exit 
note sds 	code die 
pointer 	prefix specified want 
always aligned 	update cache 
boundary different 	check named files 
branches per 	first checkout.c 
different operations 	checkout usage patch 
speed sorry 	mode quiet 
next 	merge force force 
process previous 	detach writeout 
loop store 	stage overwrite ignore 
computed target 	ignore skipworktree 
key output 	ignore worktrees show 
length bytes 	progress branch 
bitcount 	branch force 
key start 	orphan branch branch 
end lookup 	log diff 
check type 	options branch exists 
non existing 	prefix pathspec 
keys pointer 	source old changed 
stack 	sha pathname 
allocated integer 	mode stage context 
encoded parse 	len pos 
start end 	old pathspec pos 
range convert 	stage pos 
negative indexes 	stages pos seen 
whole 	name stage 
syntax error 	pos state pos 
precondition end 	state path 
end strlen 	ancestor status sha 
condition zero 	result buf 
returned start 	threeway mode stage 
end 	opts revision 
bitpos key 	pos state 
bit start 	matched rev flag 
end parse 	head errs 
bit argument 	file head opts 
understand looking 	rev msg 
clear 	commit worktree writeout 
bits key 	error opts 
exist point 	desc name path 
view infinite 	commit checkout 
bits user 	branch buf opts 
looking fist 	old writeout 
clear 	error ret file 
bit user 	trees topts 
looking first 	result work branch 
bit pointer 	opts old 
stack allocated 	msg old desc 
integer encoded 	reflog msg 
parse 	ret refname err 
start end 	refname oid 
range convert 	flags data 
negative indexes 	commit commit revs 
whole syntax 	last lost 
error empty 	old revs refs 
ranges 	opts ret 
start end 	old path free 
empty range 	rev flag 
contain looking 	writeout error opts 
clear bits 	src dst 
user specified 	dst sha unique 
exact 	remote data 
range start 	query name sha 
end consider 	data src 
right range 	argc argv dwim 
zero padded 	local branch 
end given 	opts rev source 
redis 	branch argcount 
bitpos returns 	branch rev arg 
first bit 	dash dash 
outside range 	pos dash 
caller mean 	dash recover dwim 
specified range 	remote opts 
single 	status branch opts 
bit adjust 	sha flag 
bytes skipped 	head rev flag 
blocked.c timeout 	argc argv 
unit tval 	prefix opts conflict 
btype reply 	style dwim 
reply 	local branch options 
error mstime 	argv rev 
list length 	dwim buf run 
list first 	hook sha 
server list 	hex sha hex 
del node 	isdir strlen 
sdslen 	xcalloc cache entry 
process input 	size hashcpy 
buffer unblock 	memcpy memcpy 
client waiting 	create flags create 
data unblock 	mode cache 
client waiting 	name pos hashcmp 
replicas 	free cache 
server panic 	entry read recursive 
list node 	strcmp strcmp 
tail reply 	stage error error 
reply replication 	strcmp stage 
count acks 	error strcmp stage 
offset 	checkout entry 
server panic 	error error memset 
list rewind 	stage strcmp 
list next 	hashcpy create mode 
list node 	sha sha 
reply sds 	error read mmblob 
sdsnew 	read mmblob 
unblock client 	read mmblob merge 
blocked support 	free free 
blocking operations 	free free 
like blpop 	error write sha 
wait copyright 	file die 
salvatore 	make cache entry 
sanfilippo antirez 	die checkout 
gmail dot 	entry die die 
rights reserved 	die die 
redistribution use 	die die die 
source binary 	run interactive 
forms 	xcalloc hold locked 
without modification 	index read 
permitted provided 	cache preload error 
following conditions 	read xcalloc 
met redistributions 	skip worktree path 
source code 	match report 
must 	path error free 
retain copyright 	free unmerge 
notice list 	marked index stage 
conditions following 	warning check 
disclaimer redistributions 	stage check 
binary form 	stages error skip 
must 	name memset 
reproduce copyright 	stage checkout entry 
notice list 	checkout stage 
conditions following 	checkout merged skip 
disclaimer documentation 	name write 
materials provided 	locked index die 
distribution 	read full 
neither name 	lookup commit reference 
redis names 	gently post 
contributors may 	checkout hook init 
used endorse 	revisions diff 
promote products 	setup done pending 
derived 	run diff 
software without 	index parse commit 
specific prior 	commit easy 
written permission 	find unique abbrev 
software provided 	strbuf release 
copyright holders 	memset parse 
contributors 	init desc unpack 
express implied 	trees strbuf 
warranties including 	branchname strcmp xstrdup 
limited implied 	strbuf splice 
warranties merchantability 	strbuf detach xcalloc 
fitness particular 	hold locked 
purpose 	index read cache 
disclaimed shall 	preload error 
copyright owner 	resolve undo clear 
contributors liable 	reset memset 
direct indirect 	setup unpack trees 
incidental special 	porcelain refresh 
exemplary 	cache unmerged cache 
consequential damages 	error cache 
including limited 	unborn xcalloc setup 
procurement substitute 	standard excludes 
goods services 	parse indirect init 
loss use 	desc parse 
data 	indirect init 
profits business 	desc unpack trees 
interruption however 	files cache 
caused theory 	init merge options 
liability whether 	write memory 
contract strict 	reset merge trees 
liability 	reset cache 
tort including 	cache fully valid 
negligence otherwise 	cache update 
arising way 	write locked index 
use software 	die show 
even advised 	local changes branch 
possibility 	format tracking 
damage api 	info fputs strbuf 
timeout reply 	release mkpathdup 
utility function 	safe create reflog 
parse timeout 	free strbuf 
argument since 	release strbuf 
blocking 	release create branch 
operations usually 	setup branch 
require timeout 	path oid hex 
block client 	getenv strbuf 
client blocked 	addf strbuf insert 
flag client 	strlen strcmp 
specified 	update detach advice 
block type 	describe detached 
btype filed 	head create symref 
one blocked 	die strcmp 
macros unblock 	exists reflog exists 
client unblocks 	reflog branch 
client 	state strbuf release 
following calls 	strcmp report 
btype specific 	tracking pending sha 
function cleanup 	strbuf addstr 
state unblocks 	strbuf addstr find 
client unsetting 	unique abbrev 
client 	strbuf addch 
blocked flag 	parse commit commit 
puts client 	easy strbuf 
list unblocked 	addch revision describe 
clients processed 	one orphan 
asap sleep 	describe one orphan 
loop 	strbuf addf 
callback query 	strbuf release find 
buffer process 	unique abbrev 
also required 	init revisions setup 
otherwise readable 	revisions pending 
fired already 	oid hex pending 
read 	sha prepare 
pending commands 	revision walk die 
also client 	suggest reattach 
unblocked flag 	describe detached head 
remember client 	clear commit 
unblocked clients 	marks free memset 
list 	resolve refdup 
process unblocked 	lookup commit 
clients called 	reference gently skip 
inside sleep 	prefix die 
function process 	parse commit die 
query buffer 	merge working 
unblocked 	free orphaned commit 
clients clients 	warning update 
blocked clients 	refs post checkout 
queue reply 	hook free 
blocked client 	strcmp handle ignore 
timed called 	submodules arg 
cron 	starts parse submodule 
function client 	config option 
blocked reaches 	git xmerge config 
specified timeout 	memset remote 
timeout timeout 	find tracking sha 
processed usually 	free free 
needs 	snprintf remote free 
send reply 	strcmp die 
client implementing 	strcmp sha 
type blocking 	check filename wildcard 
opeation implementation 	unique tracking 
modify unblock 	name die setup 
client 	branch path 
reply blocked 	check refname format 
client timed 	read hashcpy 
order handle 	lookup commit reference 
btype specific 	gently parse 
behavior 	indirect parse commit 
two functions 	die die 
blocking operation 	verify non filename 
waits certain 	die strbuf 
keys change 	addf create symref 
state cluster 	strbuf release 
redirect 	die die die 
blocked client 	die die 
needed function 	die die 
also updated 	die resolve refdup 
timeout store 	strcmp die 
timeout timeout 	free read full 
always 	sha unborn 
stored milliseconds 	branch branches memset 
time timeout 	memset gitmodules 
expire however 	config git config 
parsing performed 	parse options 
according unit 	isatty git xmerge 
seconds 	config die 
milliseconds note 	strcmp die skip 
timeout zero 	prefix skip 
usually point 	prefix strchr die 
view commands 	parse branchname 
api means 	arg parse pathspec 
timeout 	die die 
stored timeout 	die die validate 
zero block 	branchname strbuf 
client specific 	release checkout 
operation type 	paths checkout branch 
client blocked 	checking index 
flag 	commit exists entry 
client query 	current index 
buffer longer 	old entry place 
processed accumulated 	whether uptodate 
processed client 	checkout entry right 
unblocked function 	thing update 
called 	index given info 
sleep function 	args expanding 
loop order 	wildcards exit non 
process pending 	zero code 
input buffer 	skip needswork create 
clients unblocked 	conflicts merges 
blocking 	merge renormalize needswork 
operation process 	absolutely reason 
remaining data 	write blob create 
input buffer 	phony cache 
unless client 	entry leak 
blocked actually 	hack primarily write 
process 	entry machinery 
input buffer 	massages contents work 
checks client 	format writes 
blocked proceed 	allows cache entry 
things may 	code write 
change code 	entry needs refactored 
conceptually 	allow feed 
correct way 	buffer size mode 
unblock client 	instead cache 
calling right 	entry refactoring would 
function depending 	help merge 
kind operation 	recursive well also 
client 	writes merge 
blocking clear 	result database even 
flags put 	may contain 
client unblocked 	conflicts make sure 
list process 	pathspecs participated 
commands query 	locating paths 
buffer 	git checkout ish 
asap client 	path entry 
may already 	original index working 
unblocked list 	matter pathspec 
previous blocking 	matched entry anything 
operation back 	entry either 
list 	entry came ish 
multiple times 	checking paths 
function gets 	checking index comes 
called blocked 	ish already 
client timed 	know matches pathspec 
order send 	could stamp 
reply 	matched update still 
kind mass 	need matched 
unblock clients 	read recursive eventually 
something changed 	entry interesting 
instance makes 	cannot fill 
blocking longer 	matched yet avoid 
safe 	calling match 
example clients 	pathspec entries opts 
blocked list 	source checkout 
operations instance 	path recreate conflicted 
turns master 	state unmerged 
slave function 	paths committed check 
called 	think want 
master turns 	full paths even 
slave semantics 	subdirectory nevertheless 
send unblocked 	index right importantly 
error client 	made best 
disconnecting time 	efforts update paths 
btalloc.c 	work cannot 
size bits 	revert name used 
btalloc btalloc.h 	full name 
size bits 	real branch named 
btalloc provides 	commit branch 
mechanism allocating 	detached already 
via 	checkout way merge 
permuted backtraces 	branch unpack 
intentionally sabotage 	couldn trivial merge 
tail call 	either give 
optimization btalloc 	real merge depending 
btalloc chunk.c 	whether merge 
opt 	flag used without 
dss opt 	old commit 
chunk curchunks 	two unpack already 
highchunks chunks 	tried failed 
rtree chunksize 	real merge update 
chunksize mask 	index fully 
chunk 	write index merge 
npages addr 	branch current 
size alignment 	old branch reset 
zero commit 	index working 
arena ind 	branch leaving working 
chunk size 	merged version 
committed 	skipping unmerged 
arena ind 	entries index needswork 
chunk size 	carrying local 
offset length 	changes branches different 
arena ind 	end line 
chunk size 	normalization clean smudge 
offset 	rules pain 
length arena 	plumb option renormalize 
ind chunk 	nothing longer 
size offset 	branch branches singular 
length arena 	version plural 
ind chunk 	version give ngettext 
size 	count singular 
size size 	version plural version 
committed arena 	give ngettext 
ind chunk 	count commit tip 
size chunk 	detached head 
size committed 	reachable last chance 
arena 	user without 
ind chunk 	resorting reflog 
hooks arena 	git checkout paths 
chunk hooks 	must valid 
chunks szad 	everything must path 
chunks cache 	git checkout 
chunk 	paths everything must 
size zeroed 	paths git 
committed arena 	checkout something something 
arena chunk 	commit branch 
hooks arena 	detach head special 
chunk hooks 	something missing 
old 	means head omit 
chunk hooks 	one side 
arena chunk 	unique merge names 
hooks locked 	merge something 
uninitialized hooks 	commit either present 
arena chunk 	something path 
hooks 	given tracking branch 
arena chunk 	whose name 
hooks chunk 	something one 
node size 	one remote hand 
nadd cur 	fork local 
high chunk 	something remote tracking 
node 	branch otherwise 
err size 	present treat like 
nsub arena 	otherwise reference 
chunks szad 	treat like path 
chunks size 	treat like 
key arena 	fail git checkout 
chunk 	something paths 
hooks chunks 	first argument must 
szad chunks 	ambiguous reference 
cache addr 	treat like path 
size alignment 	treat like 
zero commit 	fail either something 
dalloc 	commit attempt 
node ret 	use invalid 
node alloc 	likely error need 
size leadsize 	find create 
trailsize zeroed 	branch accept git 
committed key 	checkout foo 
arena 	git checkout foo 
addr size 	candidates dwim 
alignment zero 	dwi mmed create 
commit dss 	local branch 
prec ret 	end anymore eat 
chunk hooks 	argument existing 
size 	branch commit want 
ret zero 	complain common 
commit arena 	git checkout branch 
chunk hooks 	even happen 
addr size 	file called branch 
alignment zero 	would extremely 
dalloc 	annoying implied branch 
node ret 	contain branch 
commit arena 	branch force 
ind arena 	orphan branch tell 
addr size 	one orphan 
alignment zero 	used track without 
commit 	orphan dwim 
arena ind 	extract branch name 
ret arena 	command line 
arena chunk 	arguments left pathspecs 
hooks addr 	handle git 
size alignment 	checkout paths git 
zero 	checkout paths 
commit ret 	git checkout something 
arena chunk 	paths including 
hooks chunks 	last branch syntax 
szad chunks 	dwim ery 
cache chunk 	names remote branches 
size 	erroring invalid 
zeroed committed 	ambiguous cases give 
unzeroed node 	helpful suggestion 
prev key 	branch argc 
arena chunk 	caught later clean.c 
hooks chunk 	force interactive 
size 	del list colopts 
committed arena 	builtin clean 
chunk hooks 	usage msg msg 
chunk size 	would msg 
zeroed committed 	skip git dir 
chunk size 	msg would 
committed 	skip git dir 
arena ind 	msg warn 
arena chunk 	failed clean use 
hooks chunk 	color clean 
size committed 	colors header prompt 
chunk size 	flags hotkey 
offset 	title selected stuff 
length arena 	slot name 
ind chunk 	slot clean color 
size offset 	clean print 
length arena 	color opt 
ind arena 	arg unset exclude 
chunk 	list path 
offset length 	prefix force flag 
chunk size 	dry run 
offset length 	quiet dir gone 
arena ind 	dir quoted 
arena chunk 	len dels list 
hooks 	item buf 
chunk size 	qname copts menu 
offset length 	list local 
chunk size 	colopts copts singleton 
size size 	stuff chosen 
committed arena 	menu list menu 
ind 	menu item 
chunk size 	list item highlighted 
chunk size 	choice menu 
committed arena 	stuff menu 
ind nelms 	item list item 
info malloc 	len found 
mutex 	menu stuff single 
chunk hooks 	input chosen 
locked malloc 	choice list ptr 
mutex unlock 	choose top 
malloc mutex 	range number opts 
atomic copy 	stuff choice 
hook 	chosen result eof 
atomic copy 	dir confirm 
hook atomic 	ignore list item 
copy hook 	dtype menu 
atomic copy 	opts menu stuff 
hook atomic 	items chosen 
copy 	confirm buf item 
hook atomic 	qname eof 
copy hook 	menu opts menu 
atomic copy 	stuff menus 
hook malloc 	chosen ret 
mutex unlock 	argc argv prefix 
memcmp 	res ignored 
chunk hooks 	gone flags abs 
locked chunk 	path dir 
hooks chunk 	pathspec buf exclude 
hooks assure 	list item 
initialized impl 	qname options ent 
chunk 	matches rel 
hooks assure 	strcasecmp strcasecmp strcasecmp 
initialized impl 	strcasecmp strcasecmp 
extent node 	strcasecmp starts git 
addr rtree 	column config 
extent node 	strcmp git config 
size 	colorbool skip 
atomic atomic 	prefix parse clean 
read atomic 	color slot 
cas atomic 	config error nonbool 
read prof 	color parse 
gdump unlocked 	strcmp git 
prof 	config git color 
gdump rtree 	config list 
extent node 	append nonbare repository 
size atomic 	dir quote 
read atomic 	path relative opendir 
sub chunk 	rmdir quote 
ceiling 	path relative warning 
extent node 	strbuf complete 
init extent 	readdir dot dotdot 
szad nsearch 	strbuf setlen 
chunk ceiling 	strbuf addstr lstat 
malloc mutex 	isdir dirs 
chunk 	quote path relative 
hooks assure 	list append 
initialized locked 	unlink quote path 
extent node 	relative list 
init extent 	append quote path 
search chunk 	relative warning 
first 	closedir strbuf 
best fit 	setlen rmdir quote 
extent node 	path relative 
size malloc 	warning list clear 
mutex unlock 	quote path 
alignment ceiling 	relative list append 
extent 	memset print 
node addr 	columns strbuf release 
extent node 	list clear 
addr extent 	memset print columns 
node size 	clean print 
extent node 	color clean print 
size 	color die 
extent node 	strbuf addf strbuf 
addr extent 	addstr clean 
node zeroed 	color strbuf addch 
extent node 	strbuf addstr 
committed split 	clean color 
extent 	strbuf addch list 
node addr 	append strbuf 
extent node 	reset strbuf addf 
size malloc 	list append 
mutex unlock 	strbuf reset pretty 
extent szad 	print menus 
extent 	strbuf release list 
arena chunk 	clear strlen 
cache maybe 	die strncasecmp strncasecmp 
extent node 	strbuf split 
size extent 	max strbuf split 
szad insert 	max strbuf 
extent 	trim strbuf isdigit 
insert arena 	atoi atoi 
chunk cache 	strchr atoi strchr 
maybe insert 	strcmp find 
split arena 	unique clean print 
node dalloc 	color clean 
malloc 	print color 
mutex unlock 	strbuf list free 
chunk record 	alloc clean 
arena node 	color clean color 
alloc malloc 	print highlight 
mutex unlock 	menu stuff clean 
chunk 	color clean 
record extent 	color strbuf getline 
node init 	strbuf trim 
uintptr extent 	strcmp prompt help 
szad insert 	cmd parse 
extent insert 	choice xmalloc xcalloc 
arena 	free strbuf 
chunk cache 	release pretty print 
maybe insert 	dels clean 
commit malloc 	print color clean 
mutex unlock 	print color 
chunk record 	strbuf getline strbuf 
malloc 	trim putchar 
mutex unlock 	memset exclude 
arena node 	list strbuf split 
dalloc memset 	max strbuf 
jemalloc valgrind 	trim exclude excluded 
make mem 	list empty 
defined 	items clean print 
chunk recycle 	color clean 
chunk alloc 	print color strbuf 
dss chunk 	list free 
alloc mmap 	clear directory strbuf 
chunk alloc 	release list 
dss 	choose list empty 
chunk alloc 	items free 
mmap jemalloc 	quote path relative 
valgrind make 	strbuf getline 
mem undefined 	strbuf trim putchar 
chunk recycle 	strncasecmp list 
jemalloc 	empty items strbuf 
valgrind make 	release strbuf 
mem undefined 	release list 
arena tsd 	clear clean print 
fetch chunk 	color clean 
arena chunk 	print color clean 
alloc 	print color 
core jemalloc 	clean print color 
valgrind make 	pretty print 
mem undefined 	dels list choose 
chunk hooks 	free clean 
assure initialized 	print color clean 
alloc 	print color 
jemalloc valgrind 	quit cmd free 
make mem 	git config 
undefined jemalloc 	parse options memset 
valgrind make 	die die 
mem noaccess 	die read cache 
malloc 	die setup 
mutex chunk 	standard excludes exclude 
hooks assure 	list exclude 
initialized locked 	parse pathspec 
extent node 	fill directory cache 
init extent 	name dir 
nsearch 	path match lstat 
extent node 	die errno 
addr extent 	isdir relative path 
node addr 	list append 
extent node 	interactive main loop 
committed merge 	strbuf addstr 
extent 	strbuf addstr lstat 
node addr 	isdir dirs 
extent node 	quote path relative 
size extent 	unlink quote 
szad arena 	path relative warning 
chunk cache 	quote path 
maybe 	relative strbuf reset 
extent node 	strbuf release 
addr extent 	strbuf release 
node size 	list clear list 
extent node 	clear git 
size extent 	clean builtin command 
node 	copyright shawn 
zeroed extent 	bohrer git clean 
node zeroed 	pavel roskin 
extent szad 	unset plain prompt 
insert arena 	header help 
chunk cache 	error honors color 
maybe 	interactive config 
insert arena 	variables also applied 
node alloc 	git interactive 
chunk purge 	git stash inspect 
wrapper extent 	color config 
node init 	variable others empty 
extent 	dir could 
insert extent 	removed even unreadble 
szad insert 	fall thru 
arena chunk 	path stat 
cache maybe 	fails non directory 
insert 	still exists 
extent prev 	always enable column 
extent node 	display consult 
addr extent 	column layout strategy 
node size 	stuff display 
extent node 	menu stuff number 
committed 	prefix hotkey 
merge extent 	highlight hotkey matching 
node addr 	parse user 
extent node 	input choice menu 
size extent 	menu stuff 
szad extent 	input single choice 
arena 	numbered item 
chunk cache 	foo item menu 
maybe extent 	title empty 
szad arena 	nothing multiple choice 
chunk cache 	single item 
maybe extent 	range items 
node 	multiple ranges foo 
addr extent 	item menu 
node addr 	title unselect specified 
extent node 	items choose 
size extent 	items empty finish 
node size 	selecting parse 
extent 	result saved chosen 
node size 	number total 
extent node 	selections input begins 
zeroed extent 	unchoose range 
node zeroed 	specified like implement 
extent node 	git interactive 
zeroed 	compatible borrowed git 
extent szad 	interactive perl 
insert arena 	integers free allocated 
chunk cache 	memory ends 
maybe insert 	eof user pressed 
arena node 	ctrl eof 
dalloc 	selection returned 
malloc mutex 	chosen uninitialized chosen 
unlock chunk 	initialized print 
addr chunk 	highlight menu stuff 
record arena 	help prompt 
maybe purge 	multiple choice menu 
chunk 	press enter 
addr chunk 	empty back recalculate 
hooks assure 	back menu 
initialized dalloc 	directly selections quit 
decommit purge 	filter pattern 
chunk record 	mode press enter 
chunk 	ctrl selected 
dss chunk 	item end chosen 
dalloc mmap 	chosen eof 
chunk hooks 	won ctrl stop 
assure initialized 	removing files 
dalloc jemalloc 	translators make 
valgrind 	sure keep might 
make mem 	removed part 
noaccess pages 	earlier recursive directory 
commit pages 	removal lstat 
decommit chunk 	could fail enoent 
addr pages 	clone.c builtin 
purge 	clone usage option 
chunk purge 	checkout option 
arena chunk 	bare option mirror 
arena chunk 	option single 
hooks assure 	branch option hardlinks 
initialized purge 	option shared 
chunk 	option recursive option 
dss chunk 	option depth 
dss alloc 	option origin option 
system info 	branch real 
jemalloc ffs 	git dir option 
chunk dss 	upload pack 
boot 	option verbosity 
rtree chunk 	option progress option 
dss prefork 	config option 
chunk dss 	reference option dissociate 
postfork parent 	builtin clone 
chunk dss 	options argv submodule 
postfork 	path bundle 
child data 	suffix bundle suffix 
used exclusively 	baselen signature 
gdump triggering 	dst len repo 
various chunk 	bundle path 
related settings 	raw canon repo 
chunksize 	bundle bare 
function prototypes 	start ptr len 
functions referenced 	dir prev 
prior definition 	space dir end 
copy field 	item data 
atomically impossible 	git repo alternate 
readers 	git git 
see partially 	src dst 
updated pointers 	src repo line 
places readers 	abs path 
need one 	src dest src 
hook function 	repo src 
pointer 	baselen buf src 
therefore need 	len dest 
copy entirety 	len dir src 
arena chunk 	repo dest 
hooks stale 	repo alt src 
reads affect 	dest junk 
correctness 	work junk git 
perform unlocked 	dir junk 
reads refresh 	repo msg signo 
cur may 	refs branch 
decreased since 	head refs refspec 
lost highchunks 	head local 
update 	refs tail remote 
race first 	head local 
best fit 	refs err 
chunk selection 	refs msg data 
lowest chunk 	sha refs 
best fits 	mapped refs remote 
cached 	head points 
chunks use 	branch top msg 
node linkage 	transport check 
embedded headers 	connectivity head remote 
dalloc node 	msg head 
addr non 	sha head file 
operating 	opts err 
specific chunk 	key data config 
beware size 	src prefix 
wrap around 	head points remote 
split lead 	head points 
node insert 	branch top key 
leading 	head argv 
space smaller 	alternates argc 
chunk split 	argv prefix local 
trail insert 	buf repo 
trailing space 	name repo work 
smaller chunk 	git dir 
caller 	path dir dest 
specifies zero 	exists refs 
still possible 	remote head remote 
receive zeroed 	head points 
memory zero 	head points mapped 
toggled arena 	refs reflog 
chunk 	msg transport src 
alloc takes 	prefix remote 
advantage avoid 	complete refs fetch 
demanding zeroed 	refspec fetch 
chunks taking 	pattern size strbuf 
advantage returned 	setlen strbuf 
retained 	addstr stat isdir 
primary dss 	git directory 
mmap requesting 	isreg open 
address implemented 	read full close 
chunk alloc 	strncmp read 
mmap call 	gitfile size strbuf 
addr 	setlen strbuf 
secondary dss 	addstr stat isreg 
strategies allocation 	strbuf addstr 
failed directly 	repo path xstrdup 
call chunk 	absolute path 
alloc mmap 	strbuf release strlen 
rather 	strstr dir 
chunk alloc 	sep dir sep 
core critical 	isspace dir 
chunk alloc 	sep strncmp dir 
untouched demand 	sep memchr 
zeroed memory 	memchr isdigit dir 
dodge 	sep strip 
tsd order 	suffix mem die 
avoid bootstrapping 	xstrfmt xstrndup 
issues arena 	isspace strlen 
allocating behalf 	dir sep xstrdup 
must initialized 	real path 
already 	read gitfile read 
coalesce forward 	gitfile mkpath 
coalesce chunk 	free xstrdup directory 
following address 	mkpath mkpathdup 
range change 	free directory mkpath 
position within 	common dir 
chunks 	die die access 
insert chunks 	mkpath die 
szad coalescing 	access mkpath die 
forward failed 	strbuf addf 
insert node 	alternates file strbuf 
node allocation 	release free 
failed 	list fopen strbuf 
exceedingly unlikely 	getline absolute 
failure leak 	path alternates file 
chunk making 	mkpathdup normalize 
sure pages 	path copy 
already purged 	alternates file free 
memory 	strbuf release 
leak coalesce 	fclose opendir die 
backward coalesce 	errno mkdir 
chunk previous 	die errno stat 
address range 	die errno 
change position 	isdir die strbuf 
within 	addch strbuf 
chunks insert 	addch readdir strbuf 
node chunks 	setlen strbuf 
szad deallocate 	addstr strbuf setlen 
decommit purge 	strbuf addstr 
fails verify 	stat warning isdir 
actual 	copy link 
page size 	directory strcmp copy 
equal integral 	alternates unlink 
multiple configured 	die errno link 
page size 	die errno 
configure chunksize 	copy file 
match 	time die errno 
granularity usually 	closedir strbuf 
pages map 	addf alternates file 
always take 	strbuf release 
fast path 	common dir common 
variables according 	dir strbuf 
opt 	addstr strbuf addstr 
chunk install 	copy link 
custom chunk 	directory strbuf release 
hooks large 	strbuf release 
size classes 	warning strbuf addstr 
huge size 	dir recursively 
classes 	strbuf reset strbuf 
test dalloc 	addstr dir 
decommit purge 	recursively strbuf reset 
cascade test 	junk sigchain 
decommit commit 	pop strbuf 
observe split 	addstr strbuf addstr 
merge 	find name 
test purge 	strbuf release strbuf 
chunk huge 	addstr strbuf 
allocations least 	addstr find name 
four size 	strbuf release 
classes per 	copy find name 
doubling 	guess remote 
successful xallocx 	head copy find 
size huge 	remote branch 
size huge 	warning fetch map 
guaranteed trailing 	fetch map 
purgeable memory 	fetch map fetch 
test 	map transaction 
decommit large 	begin die transaction 
allocations make 	create die 
sure non 	initial transaction commit 
huge allocation 	die strbuf 
succeeds restore 	release transaction 
chunk 	free starts ends 
hooks malloc 	file update 
conf orig 	hashcpy check everything 
hooks old 	connected transport 
hooks dalloc 	die write remote 
decommit alloc 	refs write 
dalloc 	followtags strbuf addstr 
commit decommit 	strbuf addstr 
purge split 	create symref die 
merge addr 	strbuf release 
size alignment 	skip prefix create 
zero commit 	symref die 
arena 	update install branch 
ind chunk 	config lookup 
size committed 	commit reference update 
arena ind 	update resolve 
chunk size 	refdup warning strcmp 
offset length 	detach advice 
arena 	sha hex 
ind err 	starts die free 
chunk size 	setup work 
offset length 	xcalloc hold locked 
arena ind 	index memset 
err chunk 	parse indirect parse 
size 	init desc 
offset length 	unpack trees die 
arena ind 	write locked 
chunk size 	index die run 
size size 	hook sha 
committed arena 	hex sha hex 
ind 	run command 
chunk size 	opt git config 
chunk size 	multivar gently 
committed arena 	git config parse 
ind old 	parameter die 
size size 	starts strbuf addf 
large 	strbuf addf 
large huge 	skip prefix 
huge huge 	die strbuf addf 
hooks xallocx 	strbuf addf 
success xallocx 	strbuf addf git 
success xallocx 	config multivar 
success 	strbuf reset strbuf 
trace hook 	addf git 
alloc trace 	config strbuf reset 
hook dalloc 	strbuf release 
trace hook 	strbuf release git 
commit trace 	pathdup access 
hook 	run command opt 
decommit trace 	die unlink 
hook purge 	die errno free 
trace hook 	packet trace 
split trace 	identity parse options 
hook merge 	usage msg 
mallctl 	opt usage 
ptr ptr 	msg opt die 
ptr ptr 	die repo 
ptr ptr 	path xstrdup absolute 
ptr mallctl 	path strchr 
mallctl mallctl 	die atoi die 
mallctl 	xstrdup guess 
mallctl mallocx 	dir name strip 
ptr xallocx 	trailing slashes 
mallctl dallocx 	stat empty dir 
mallocx ptr 	die strbuf 
xallocx mallctl 	addf getenv stat 
xallocx 	die xstrdup 
dallocx mallocx 	mkpathdup atexit sigchain 
ptr xallocx 	push common 
dallocx mallocx 	safe create leading 
ptr mallctl 	directories die 
xallocx mallctl 	errno mkdir die 
xallocx 	errno git 
dallocx mallocx 	work safe 
ptr dallocx 	create leading directories 
mallctl mallctl 	die git 
ptr ptr 	dir init init 
ptr ptr 	write config 
ptr 	git config strbuf 
ptr ptr 	addstr git 
test data 	config strbuf addf 
used exclusively 	strbuf addf 
gdump triggering 	strbuf addf git 
various chunk 	config strbuf 
related 	reset setup reference 
settings chunksize 	parse fetch 
function prototypes 	refspec strbuf reset 
functions referenced 	remote transport 
prior definition 	transport verbosity repo 
copy field 	path warning 
atomically 	access mkpath warning 
impossible readers 	warning die 
see partially 	transport option 
updated pointers 	transport option transport 
places readers 	option transport 
need one 	option transport remote 
hook 	refs wanted 
function pointer 	peer refs oid 
therefore need 	transport fetch 
copy entirety 	refs find name 
arena chunk 	guess remote 
hooks stale 	head find remote 
reads 	branch die 
affect correctness 	die warning install 
perform unlocked 	branch config 
reads refresh 	write refspec config 
cur may 	clone local 
decreased since 	transport fetch refs 
lost 	update remote 
highchunks update 	refs update head 
race first 	transport unlock 
best fit 	pack transport 
chunk selection 	disconnect close packs 
lowest chunk 	dissociate references 
best 	checkout strbuf release 
fits cached 	strbuf release 
chunks use 	strbuf release strbuf 
node linkage 	release free 
embedded headers 	builtin git clone 
dalloc node 	copyright kristian 
addr 	gsberg krh redhat 
non operating 	daniel barkalow 
specific chunk 	barkalow iabervon git 
beware size 	commit junio 
wrap around 	hamano linus torvalds 
split lead 	clone repository 
node 	different directory yet 
insert leading 	exist overall 
space smaller 	fixm respect 
chunk split 	environment git objects 
trail insert 	implementation notes 
trailing space 	dropping use separate 
smaller 	remote separate 
chunk caller 	remote compatibility gitfile 
specifies zero 	skip scheme 
still possible 	skip authentication data 
receive zeroed 	stripping happen 
memory zero 	greedily strip last 
toggled 	inside host 
arena chunk 	part strip trailing 
alloc takes 	spaces slashes 
advantage avoid 	git strip trailing 
demanding zeroed 	port number 
chunks taking 	got hostname dir 
advantage 	separator colon 
returned retained 	check required strip 
primary dss 	uri like 
mmap requesting 	foo bar 
address implemented 	git result dir 
chunk alloc 	guessed due 
mmap 	backwards compatibility find 
call addr 	last component 
secondary dss 	remain backwards compatible 
strategies allocation 	also regard 
failed directly 	colons path separators 
call chunk 	cloning repository 
alloc 	foo bar git 
mmap rather 	would result 
chunk alloc 	directory bar guessed 
core critical 	strip bundle 
chunk alloc 	git replace sequences 
untouched demand 	control characters 
zeroed 	whitespace one ascii 
memory dodge 	space leading 
tsd order 	trailing spaces strip 
avoid bootstrapping 	leading whitespace 
issues arena 	beware read 
allocating behalf 	gitfile real path 
must 	mkpath buffer 
initialized already 	read source objects 
coalesce forward 	info alternates 
coalesce chunk 	file copy entries 
following address 	corresponding file 
range change 	destination repository alternates 
position 	file src 
within chunks 	dst path objects 
insert chunks 	info alternates 
szad coalescing 	instead copying bit 
forward failed 	bit original 
insert node 	need append existing 
node 	one already 
allocation failed 	created entry via 
exceedingly unlikely 	clone lost 
failure leak 	also turn entries 
chunk making 	paths relative 
sure pages 	original absolute 
already 	used repository files 
purged memory 	cannot copied 
leak coalesce 	bit bit fall 
backward coalesce 	proceed removal 
chunk previous 	branch tag pull 
address range 	requested tag 
change 	explicitly skip anything 
position within 	missing peer 
chunks insert 	actually going write 
node chunks 	returning notes 
szad deallocate 	end list caller 
decommit 	local branch 
purge fails 	link branch specifies 
verify actual 	non branch 
page size 	tags detach head 
equal integral 	know remote 
multiple configured 	head points non 
page 	branch head 
size configure 	points branch 
chunksize match 	know one detach 
granularity usually 	head cases 
pages map 	need work checkout 
always take 	otherwise next 
fast 	git fetch simply 
path variables 	fetch head 
according opt 	without updating remote 
chunk install 	tracking branch 
custom chunk 	want configure remote 
hooks large 	need strict 
size 	transport option validate 
classes huge 	transport remote 
size classes 	refs may refs 
test dalloc 	sha mapped 
decommit purge 	refs see transport 
cascade test 	refs list 
decommit 	comment need 
commit observe 	fetch early remote 
split merge 	head code 
test purge 	relies normal clones 
chunk huge 	transport remote 
allocations least 	refs reliable delay 
four 	cloning remote 
size classes 	head check color.c 
per doubling 	git use 
successful xallocx 	color color stdout 
size huge 	tty column 
size huge 	colors ansi column 
guaranteed 	colors ansi 
trailing purgeable 	max red green 
memory test 	blue word 
decommit large 	len match val 
allocations make 	name len 
sure non 	color names end 
huge 	val name 
allocation succeeds 	len attr 
restore chunk 	values attr names 
hooks chunk.c 	str dst 
opt dss 	dst color bytes 
opt chunk 	len type 
curchunks 	len dst ptr 
highchunks chunks 	len end 
rtree chunksize 	attr word val 
chunksize mask 	wordlen sep 
chunk npages 	bit term want 
addr size 	color color 
alignment 	fmt args trail 
zero commit 	color fmt 
arena ind 	args color fmt 
chunk size 	args size 
committed arena 	strncasecmp hexval hexval 
ind chunk 	match word 
size 	hex color hex 
offset length 	color hex 
arena ind 	color size 
chunk size 	match word strtol 
offset length 	size strncasecmp 
arena ind 	color parse mem 
chunk 	strlen xsnprintf 
size offset 	die xsnprintf xsnprintf 
length arena 	strncasecmp xsnprintf 
ind chunk 	isspace isspace parse 
size size 	color parse 
size committed 	attr color empty 
arena 	color empty 
ind chunk 	xsnprintf color empty 
size chunk 	color output 
size committed 	color empty color 
arena ind 	output error 
chunk hooks 	strcasecmp strcasecmp strcasecmp 
arena 	git config 
chunk hooks 	isatty pager use 
chunks szad 	getenv strcmp 
chunks cache 	check color 
chunk size 	strcmp git config 
zeroed committed 	colorbool git 
arena 	color config git 
arena chunk 	config vfprintf 
hooks arena 	start color vfprintf 
chunk hooks 	end start 
old chunk 	color vfprintf end 
hooks arena 	strcmp list 
chunk 	available column colors 
hooks locked 	ignore reset 
uninitialized hooks 	end giving size 
arena chunk 	individual foreground 
hooks arena 	background color basic 
chunk hooks 	ansi colors 
chunk 	numeric ansi color 
node size 	modes bit 
nadd cur 	rgb color 
high chunk 	values word buffer 
node err 	length len 
size nsub 	match nul terminated 
arena 	match exactly 
chunks szad 	positions must match 
chunks size 	ansi color 
key arena 	codes first special 
chunk hooks 	word normal 
chunks szad 	bit rgb pick 
chunks 	human readable 
cache addr 	color names color 
size alignment 	mode number 
zero commit 	allow normal negative 
dalloc node 	numbers bogus 
ret node 	fall error rewrite 
alloc 	low numbers 
size leadsize 	portable standard colors 
trailsize zeroed 	write ansi 
committed key 	color codes 
arena addr 	already ansi escape 
size alignment 	code enough 
zero 	space fit color 
commit dss 	attr foreground 
prec ret 	colors range background 
chunk hooks 	colors range 
size ret 	missing turn colorization 
zero commit 	normal truth 
arena 	defaults color.h column 
chunk hooks 	colors ansi 
addr size 	column colors ansi 
alignment zero 	max color 
dalloc node 	stdout tty dst 
ret commit 	color bytes 
arena 	dst len dst 
ind arena 	color fmt 
addr size 	color fmt color 
alignment zero 	color num 
commit arena 	attrs nul 
ind ret 	xxm maximum length 
arena 	ansi color 
arena chunk 	sequence would generate 
hooks addr 	leading esc 
size alignment 	attr color color 
zero commit 	terminating nul 
ret arena 	overcounts attr use 
chunk 	one semicolon 
hooks chunks 	close enough important 
szad chunks 	due way 
cache chunk 	color codes emulated 
size zeroed 	windows write 
committed unzeroed 	fputs particular use 
node 	puts write 
prev key 	special meaning color 
arena chunk 	selected first 
hooks chunk 	three chosen match 
size committed 	common usage 
arena chunk 	code returned 
hooks 	git config colorbool 
chunk size 	returned config 
zeroed committed 	colorbool converted want 
chunk size 	color either 
committed arena 	list colors use 
ind arena 	commit graphs 
chunk 	show branch output 
hooks chunk 	generally color 
size committed 	code lazily figure 
chunk size 	provides mechanism 
offset length 	callers autodetection use 
arena ind 	first one 
chunk 	need color config 
size offset 	second convenience 
length arena 	going change git 
ind arena 	config color 
chunk offset 	buffer must 
length chunk 	color maxlen bytes 
size 	raw color 
offset length 	bytes useful initializing 
arena ind 	color variables 
arena chunk 	color column.c list 
hooks chunk 	colopts opts 
size offset 	rows cols len 
length 	width colopts 
chunk size 	len str len 
size size 	data width 
committed arena 	data data total 
ind chunk 	width cols 
size chunk 	rows list indent 
size 	data initial 
committed arena 	width empty cell 
ind nelms 	len newline 
info malloc 	list colopts opts 
mutex chunk 	data initial 
hooks locked 	width empty 
malloc 	cell list colopts 
mutex unlock 	opts nopts 
malloc mutex 	colopts stdout tty 
atomic copy 	name mask 
hook atomic 	arg len colopts 
copy hook 	opts name 
atomic 	len arg str 
copy hook 	colopts sep 
atomic copy 	len key colopts 
hook atomic 	command colopts 
copy hook 	opt arg unset 
atomic copy 	colopts column 
hook 	process colopts opts 
atomic copy 	argv strbuf 
hook malloc 	addstr strstr strspn 
mutex unlock 	strbuf utf 
memcmp chunk 	strwidth strbuf release 
hooks locked 	strlen div 
chunk 	round linear 
hooks chunk 	linear realloc div 
hooks assure 	round realloc 
initialized impl 	compute column width 
chunk hooks 	strlen compute 
assure initialized 	column width linear 
impl 	col layout 
extent node 	memset alloc item 
addr rtree 	length layout 
extent node 	shrink columns xmallocz 
size atomic 	memset display 
atomic read 	cell free free 
atomic 	free memset 
cas atomic 	term columns column 
read prof 	active display 
gdump unlocked 	plain col layout 
prof gdump 	display plain 
rtree extent 	display table die 
node 	col layout 
size atomic 	isatty size 
read atomic 	strncmp strlen strncmp 
sub chunk 	error strcspn 
ceiling extent 	parse option strspn 
node init 	config error 
extent 	nonbool parse config 
szad nsearch 	error skip 
chunk ceiling 	prefix strcmp column 
malloc mutex 	config strcmp 
chunk hooks 	column config parse 
assure initialized 	config child 
locked 	process init argv 
extent node 	push argv 
init extent 	pushf argv pushf 
search chunk 	argv pushf 
first best 	argv pushf fflush 
fit extent 	dup start 
node 	command dup close 
size malloc 	dup close 
mutex unlock 	fflush close 
alignment ceiling 	finish command dup 
extent node 	close cell 
addr extent 	length index longest 
node 	row column 
addr extent 	length letters ansi 
node size 	escapes stripped 
extent node 	len func calculate 
size extent 	cell width 
node addr 	rows cols table 
extent 	equal cells 
node zeroed 	given table width 
extent node 	many spaces 
committed split 	cells shrink columns 
extent node 	shortening one 
addr extent 	row time adding 
node 	columns along 
size malloc 	way hopefully 
mutex unlock 	longest cell moved 
extent szad 	next column 
extent arena 	column shrunk space 
chunk cache 	columns process 
maybe 	ends whole thing 
extent node 	longer fits 
size extent 	data total width 
szad insert 	display without 
extent insert 	layout enabled print 
arena chunk 	cell stdout 
cache 	necessary leading traling 
maybe insert 	space empty 
split arena 	cell initial width 
node dalloc 	chars real 
malloc mutex 	column narrower increase 
unlock chunk 	len bit 
record 	fill less space 
arena node 	display col 
alloc malloc 	column col 
mutex unlock 	row none always 
chunk record 	never specified 
extent node 	setting layout implies 
init 	always current 
uintptr extent 	col enable mask 
szad insert 	disregarded means 
extent insert 	column pass column 
arena chunk 	row become 
cache maybe 	always column never 
insert 	column always 
commit malloc 	unless arg states 
mutex unlock 	otherwise one 
chunk record 	special must first 
malloc mutex 	one builtin 
unlock arena 	column usage colopts 
node 	argc argv 
dalloc memset 	prefix list copts 
jemalloc valgrind 	real command 
make mem 	options git 
defined chunk 	column config starts 
recycle chunk 	git config 
alloc 	git config memset 
dss chunk 	term columns 
alloc mmap 	parse options usage 
chunk alloc 	options strcmp 
dss chunk 	die finalize colopts 
alloc mmap 	strbuf getline 
jemalloc 	list append print 
valgrind make 	columns cell 
mem undefined 	length index longest 
chunk recycle 	row column 
jemalloc valgrind 	length letters ansi 
make mem 	escapes stripped 
undefined 	len func calculate 
arena tsd 	cell width 
fetch chunk 	rows cols table 
arena chunk 	equal cells 
alloc core 	given table 
jemalloc valgrind 	width many spaces 
make 	cells shrink 
mem undefined 	columns shortening one 
chunk hooks 	row time 
assure initialized 	adding columns along 
alloc jemalloc 	way hopefully 
valgrind make 	longest cell moved 
mem 	next column 
undefined jemalloc 	column shrunk space 
valgrind make 	columns process 
mem noaccess 	ends whole thing 
malloc mutex 	longer fits 
chunk hooks 	data total width 
assure 	display without 
initialized locked 	layout enabled print 
extent node 	cell stdout 
init extent 	necessary leading 
nsearch extent 	traling space empty 
node addr 	cell initial 
extent 	width chars real 
node addr 	column narrower 
extent node 	increase len bit 
committed merge 	fill less 
extent node 	space display col 
addr extent 	column col 
node 	row none always 
size extent 	never specified 
szad arena 	setting layout implies 
chunk cache 	always current 
maybe extent 	col enable mask 
node addr 	disregarded means 
extent 	column pass column 
node size 	row become 
extent node 	always column never 
size extent 	column always 
node zeroed 	unless arg 
extent node 	states otherwise one 
zeroed 	special must 
extent szad 	first one column.c 
insert arena 	list colopts 
chunk cache 	opts rows cols 
maybe insert 	len width 
arena node 	colopts len str 
alloc 	len data 
chunk purge 	width data data 
wrapper extent 	total width 
node init 	cols rows list 
extent insert 	indent data 
extent szad 	initial width empty 
insert 	cell len 
arena chunk 	newline list colopts 
cache maybe 	opts data 
insert extent 	initial width empty 
prev extent 	cell list 
node addr 	colopts opts 
extent 	nopts colopts stdout 
node size 	tty name 
extent node 	mask arg len 
committed merge 	colopts opts 
extent node 	name len arg 
addr extent 	str colopts 
node 	sep len key 
size extent 	colopts command 
szad extent 	colopts opt arg 
arena chunk 	unset colopts 
cache maybe 	column process colopts 
extent szad 	opts argv 
arena 	strbuf addstr strstr 
chunk cache 	strspn strbuf 
maybe extent 	utf strwidth strbuf 
node addr 	release strlen 
extent node 	div round linear 
addr extent 	linear realloc 
node 	div round 
size extent 	realloc compute column 
node size 	width strlen 
extent node 	compute column width 
size extent 	linear col 
node zeroed 	layout memset alloc 
extent 	item length 
node zeroed 	layout shrink columns 
extent node 	xmallocz memset 
zeroed extent 	display cell free 
szad insert 	free free 
arena chunk 	memset term columns 
cache 	column active 
maybe insert 	display plain col 
arena node 	layout display 
dalloc malloc 	plain display table 
mutex unlock 	die col 
chunk addr 	layout isatty 
chunk 	size strncmp strlen 
record arena 	strncmp error 
maybe purge 	strcspn parse option 
chunk addr 	strspn config 
chunk hooks 	error nonbool parse 
assure initialized 	config error 
dalloc 	skip prefix strcmp 
decommit purge 	column config 
chunk record 	strcmp column config 
chunk dss 	parse config 
chunk dalloc 	child process init 
mmap chunk 	argv push 
hooks 	argv pushf argv 
assure initialized 	pushf argv 
dalloc jemalloc 	pushf argv pushf 
valgrind make 	fflush dup 
mem noaccess 	start command dup 
pages 	close dup 
commit pages 	close fflush 
decommit chunk 	close finish command 
addr pages 	dup close 
purge chunk 	cell length index 
purge arena 	longest row 
chunk 	column length letters 
arena chunk 	ansi escapes 
hooks assure 	stripped len func 
initialized purge 	calculate cell 
chunk dss 	width rows cols 
chunk dss 	table equal 
alloc 	cells given table 
system info 	width many 
jemalloc ffs 	spaces cells shrink 
chunk dss 	columns shortening 
boot rtree 	one row time 
chunk dss 	adding columns 
prefork 	along way hopefully 
chunk dss 	longest cell 
postfork parent 	moved next 
chunk dss 	column column shrunk 
postfork child 	space columns 
data used 	process ends whole 
exclusively 	thing longer 
gdump triggering 	fits data total 
various chunk 	width display 
related settings 	without layout enabled 
chunksize function 	print cell 
prototypes functions 	stdout necessary leading 
referenced 	traling space 
prior definition 	empty cell initial 
copy field 	width chars 
atomically impossible 	real column narrower 
readers see 	increase len 
partially updated 	bit fill less 
pointers 	space display 
places readers 	col column col 
need one 	row none 
hook function 	always never 
pointer therefore 	specified setting layout 
need copy 	implies always 
entirety 	current col enable 
arena chunk 	mask disregarded 
hooks stale 	means column pass 
reads affect 	column row 
correctness perform 	become always column 
unlocked reads 	never column 
refresh 	always unless arg 
cur may 	states otherwise 
decreased since 	one special must 
lost highchunks 	first one 
update race 	builtin column usage 
first best 	colopts argc 
fit 	argv prefix list 
chunk selection 	copts real 
lowest chunk 	command options git 
best fits 	column config 
cached chunks 	starts git 
use node 	config git config 
linkage 	memset term 
embedded headers 	columns parse options 
dalloc node 	usage options 
addr non 	strcmp die finalize 
operating specific 	colopts strbuf 
chunk beware 	getline list append 
size 	print columns 
wrap around 	cell length index 
split lead 	longest row 
node insert 	column length letters 
leading space 	ansi escapes 
smaller chunk 	stripped len func 
split 	calculate cell 
trail insert 	width rows cols 
trailing space 	table equal 
smaller chunk 	cells given 
caller specifies 	table width many 
zero still 	spaces cells 
possible 	shrink columns shortening 
receive zeroed 	one row 
memory zero 	time adding columns 
toggled arena 	along way 
chunk alloc 	hopefully longest cell 
takes advantage 	moved next 
avoid 	column column shrunk 
demanding zeroed 	space columns 
chunks taking 	process ends whole 
advantage returned 	thing longer 
retained primary 	fits data total 
dss mmap 	width display 
requesting 	without layout enabled 
address implemented 	print cell 
chunk alloc 	stdout necessary leading 
mmap call 	traling space 
addr secondary 	empty cell 
dss strategies 	initial width chars 
allocation 	real column 
failed directly 	narrower increase len 
call chunk 	bit fill 
alloc mmap 	less space display 
rather chunk 	col column 
alloc core 	col row none 
critical 	always never 
chunk alloc 	specified setting layout 
untouched demand 	implies always 
zeroed memory 	current col enable 
dodge tsd 	mask disregarded 
order avoid 	means column pass 
bootstrapping 	column row 
issues arena 	become always column 
allocating behalf 	never column 
must initialized 	always unless arg 
already coalesce 	states otherwise 
forward coalesce 	one special 
chunk 	must first one 
following address 	column.h width 
range change 	padding indent option 
position within 	command colopts 
chunks insert 	colopts stdout tty 
chunks szad 	colopts list 
coalescing 	colopts opts colopts 
forward failed 	column options 
insert node 	always never column 
node allocation 	given cmdline 
failed exceedingly 	shrink columns possible 
unlikely failure 	making space 
leak 	columns must zero 
chunk making 	fill columns 
sure pages 	rows fill rows 
already purged 	columns one 
memory leak 	column combine-diff.c one 
coalesce backward 	two curr 
coalesce 	num parent 
chunk previous 	tail cmp len 
address range 	path next 
change position 	prev len parent 
within chunks 	map line 
insert node 	lost head lost 
chunks 	tail len 
szad deallocate 	lost lenlost plost 
decommit purge 	bol len 
fails verify 	flag lno line 
actual page 	len line 
size equal 	len flags lenbase 
integral 	lennew parent 
multiple configured 	flags lcs baseend 
page size 	newend origbaselen 
configure chunksize 	lline lline oid 
match granularity 	mode size 
usually pages 	textconv path 
map 	blob sline line 
always take 	len lline 
fast path 	mask lno nmask 
variables according 	num parent 
opt chunk 	sline lost bucket 
install custom 	state line 
chunk 	len state parent 
hooks large 	mode result 
size classes 	file sline cnt 
huge size 	num parent 
classes test 	result deleted textconv 
dalloc decommit 	path flags 
purge 	lno lno nmask 
cascade test 	xpp xecfg 
decommit commit 	parent file state 
observe split 	context combine 
merge test 	marker sline mask 
purge chunk 	sline mask 
huge 	hunk begin 
allocations least 	sline mark cnt 
four size 	look uninteresting 
classes per 	sline cnt num 
doubling successful 	parent mask 
xallocx size 	mark pre sline 
huge 	cnt num 
size huge 	parent dense mask 
guaranteed trailing 	mark interesting 
purgeable memory 	hunk begin hunk 
test decommit 	end diff 
large allocations 	contin diff sline 
make 	context bol 
sure non 	line len reset 
huge allocation 	saw eol 
succeeds restore 	sline line prefix 
chunk hooks 	cnt num 
malloc conf 	parent use color 
orig 	result deleted 
hooks old 	mark pre 
hooks dalloc 	lno frag func 
decommit alloc 	old context 
dalloc commit 	reset hunk end 
decommit purge 	rlines hunk 
split 	comment context comment 
merge addr 	end mask 
size alignment 	sline cnt lno 
zero commit 	imask jmask 
arena ind 	head prefix path 
chunk size 	line prefix 
committed 	meta reset buf 
arena ind 	elem num 
chunk size 	parent dense rev 
offset length 	line prefix 
arena ind 	mode differs show 
err chunk 	file header 
size 	opt abbrev prefix 
offset length 	prefix meta 
arena ind 	reset abb 
err chunk 	added deleted elem 
size offset 	num parent 
length arena 	dense working file 
ind 	rev opt 
chunk size 	result size cnt 
size size 	lno result 
committed arena 	deleted result sline 
ind chunk 	mode differs 
size chunk 	show hunks result 
size 	file userdiff 
committed arena 	textconv binary line 
ind old 	prefix buf 
size size 	oid len done 
large large 	file buf 
huge huge 	buf size tmp 
huge 	num parent 
hooks xallocx 	rev opt 
success xallocx 	line termination inter 
success xallocx 	name termination 
success trace 	line prefix num 
hook alloc 	parent dense 
trace 	rev opt pair 
hook dalloc 	num parent 
trace hook 	pair pool opt 
commit trace 	paths num 
hook decommit 	parent num paths 
trace hook 	obj path 
purge 	sha parents opt 
trace hook 	paths num 
split trace 	parent output format 
hook merge 	orderfile stat 
mallctl ptr 	opt sha parents 
ptr ptr 	opt nparent 
ptr 	parents sha paths 
ptr ptr 	head sha 
ptr mallctl 	parents dense 
mallctl mallctl 	rev opt diffopts 
mallctl mallctl 	paths num 
mallocx ptr 	paths needsep show 
xallocx 	log first 
mallctl dallocx 	num parent need 
mallocx ptr 	pathscan stat 
xallocx mallctl 	opt tmp commit 
xallocx dallocx 	dense rev 
mallocx ptr 	parent parents isdir 
xallocx 	isdir strcmp 
dallocx mallocx 	name compare strlen 
ptr mallctl 	strlen diff 
xallocx mallctl 	unmodified pair strlen 
xallocx dallocx 	xmalloc combine 
mallocx ptr 	diff path size 
dallocx 	memcpy memset 
mallctl mallctl 	hashcpy hashcpy compare 
ptr ptr 	paths free 
ptr ptr 	hashcpy xdl 
ptr ptr 	isspace xdl isspace 
ptr test 	memcmp xdl 
data 	isspace xdl isspace 
used exclusively 	xdl isspace 
gdump triggering 	xdl isspace xdl 
various chunk 	isspace xdl 
related settings 	isspace xdl isspace 
chunksize function 	xdl isspace 
prototypes 	xcalloc xcalloc free 
functions referenced 	free free 
prior definition 	free free isgitlink 
copy field 	xmalloc snprintf 
atomically impossible 	oid hex oid 
readers see 	xcalloc alloc 
partially 	filespec fill filespec 
updated pointers 	fill textconv 
places readers 	free filespec read 
need one 	sha file 
hook function 	die oid 
pointer therefore 	hex flex alloc 
need 	mem memcmp 
copy entirety 	parse hunk header 
arena chunk 	xcalloc append 
hooks stale 	lost grab blob 
reads affect 	memset memset 
correctness perform 	memset xdi diff 
unlocked 	outf die 
reads refresh 	oid hex free 
cur may 	coalesce lines 
decreased since 	find next find 
lost highchunks 	next find 
update race 	next adjust hunk 
first 	tail interesting 
best fit 	give context adjust 
chunk selection 	hunk tail 
lowest chunk 	give context isalpha 
best fits 	strlen diff 
cached chunks 	color diff 
use 	color diff color 
node linkage 	diff color 
embedded headers 	diff color diff 
dalloc node 	color hunk 
addr non 	comment line putchar 
operating specific 	show parent 
chunk 	lno putchar isspace 
beware size 	putchar putchar 
wrap around 	putchar show line 
split lead 	eol fputs 
node insert 	fputs fputs putchar 
leading space 	putchar show 
smaller 	line eol strbuf 
chunk split 	reset strbuf 
trail insert 	addstr strbuf addstr 
trailing space 	strbuf addstr 
smaller chunk 	quote two 
caller specifies 	style strbuf addstr 
zero 	puts diff 
still possible 	opt tst diff 
receive zeroed 	color opt 
memory zero 	diff color opt 
toggled arena 	show log 
chunk alloc 	dump quoted path 
takes 	find unique 
advantage avoid 	abbrev find unique 
demanding zeroed 	abbrev dump 
chunks taking 	quoted path dump 
advantage returned 	quoted path 
retained primary 	dump quoted path 
dss 	dump quoted 
mmap requesting 	path diff line 
address implemented 	prefix userdiff 
chunk alloc 	find path userdiff 
mmap call 	find name 
addr secondary 	diff opt 
dss 	tst userdiff textconv 
strategies allocation 	grab blob 
failed directly 	lstat islnk strbuf 
call chunk 	readlink error 
alloc mmap 	strerror strbuf detach 
rather chunk 	canon mode 
alloc 	isdir resolve gitlink 
core critical 	grab blob 
chunk alloc 	grab blob alloc 
untouched demand 	filespec fill 
zeroed memory 	filespec fill textconv 
dodge tsd 	free filespec 
order 	open xsize canon 
avoid bootstrapping 	mode islnk 
issues arena 	canon mode xmallocz 
allocating behalf 	read full 
must initialized 	die errno die 
already coalesce 	convert git 
forward 	free strbuf 
coalesce chunk 	detach xcalloc close 
following address 	buffer binary 
range change 	grab blob buffer 
position within 	binary free 
chunks insert 	show combined header 
chunks 	free xcalloc 
szad coalescing 	xcalloc mult oidcmp 
forward failed 	reuse combine 
insert node 	diff combine diff 
node allocation 	make hunks 
failed exceedingly 	show combined header 
unlikely 	dump sline 
failure leak 	free free free 
chunk making 	free diff 
sure pages 	line prefix show 
already purged 	log putchar 
memory leak 	diff unique abbrev 
coalesce 	diff unique 
backward coalesce 	abbrev putchar 
chunk previous 	putchar write name 
address range 	quoted show 
change position 	raw diff show 
within chunks 	patch diff 
insert 	free free xmalloc 
node chunks 	xcalloc hashcpy 
szad deallocate 	oid hashcpy oid 
decommit purge 	xcalloc combined 
fails verify 	pair format callback 
actual page 	free combined 
size 	pair free diff 
equal integral 	sha diffcore 
multiple configured 	std intersect paths 
page size 	diffcore order 
configure chunksize 	diff flush alloc 
match granularity 	strbuf init 
usually 	diff paths 
pages map 	strbuf release free 
always take 	show log 
fast path 	commit format empty 
variables according 	diff line 
opt chunk 	prefix copy pathspec 
install 	diff opt 
custom chunk 	diff opt clr 
hooks large 	diff opt 
size classes 	tst find paths 
huge size 	find paths 
classes test 	multitree diff sha 
dalloc 	diffcore std 
decommit purge 	diffcore order diff 
cascade test 	flush alloc 
decommit commit 	order objects free 
observe split 	show raw 
merge test 	diff handle combined 
purge 	callback diff 
chunk huge 	line prefix 
allocations least 	show patch diff 
four size 	free free 
classes per 	pathspec saved parents 
doubling successful 	sha append 
xallocx 	diff combined sha 
size huge 	clear paths 
size huge 	curr linked list 
guaranteed trailing 	queue sorted 
purgeable memory 	order path queue 
test decommit 	drop queue 
large 	path skip lines 
allocations make 	lost parent 
sure non 	lines lost current 
huge allocation 	parent coalescing 
succeeds restore 	lines surviving merge 
chunk hooks 	result accumulated 
chunk.h 	coalesced lost lines 
opt chunk 	bit parent 
opt dss 	line change 
chunks rtree 	bit used interesting 
chunksize chunksize 	lines including 
mask chunk 	context bit used 
npages 	show deletion 
chunk hooks 	consume remaining spaces 
arena arena 	matched full 
chunk hooks 	line line coalesce 
chunk node 	lines finding 
chunk 	lcs coalesce lines 
node size 	finding lcs 
arena chunk 	create table run 
hooks addr 	programming compute 
size alignment 	lcs reverse read 
zero dalloc 	direction structure 
node 	match assign parent 
arena chunk 	flag consume 
hooks addr 	baseend newend consume 
size alignment 	baseend insert 
zero commit 	newend lline 
arena chunk 	consume newend point 
hooks 	baseend newend 
chunk size 	point end lists 
committed arena 	lline list 
chunk hooks 	update newend lline 
chunk size 	list deleted 
zeroed committed 	blob removed lines 
arena 	would come 
chunk hooks 	line result lost 
chunk size 	buckets hang 
committed arena 	line removed lines 
chunk offset 	note correct 
length arena 	even hunk removes 
chunk 	first line 
hooks chunk 	file hunk yet 
size offset 	result deleted 
length chunk 	assign line numbers 
dependent ptr 	parent sline 
dependent rtree 	lno lno 
size 	records first line 
alignment memory 	number counting 
chunks allocated 	parent hunk display 
memory system 	started showing 
chunk address 	sline lno possibly 
allocation address 	showing lost 
chunk 	lines attached first 
offset address 	coalesce lines 
smallest chunk 	many lines would 
multiple jemalloc 	sline advance 
types jemalloc 	lno means parent 
structs chunksize 	means parent 
jemalloc 	trailer parents lost 
externs jemalloc 	lines added 
inlines chunk 	parent interesting points 
dssc dss 	first uninteresting 
prec names 	line last 
dss prec 	line hunk interesting 
dss 	deletion interesting 
mtx dss 	purpose giving trailing 
dss prev 	context lines 
dss max 	output line unmodified 
increment ret 	sline gives 
dss prec 	one extra context 
arena 	line examined 
addr size 	look find next 
alignment zero 	interesting uninteresting 
commit ret 	line interesting mean 
cpad dss 	interesting marked 
next gap 	give context function 
size 	includes context 
cpad size 	lines interesting interesting 
incr chunk 	function surrounded 
hooks chunk 	interesting ones two 
ret sbrk 	groups interesting 
implemented malloc 	lines may 
mutex 	gap uninteresting lines 
malloc mutex 	connect groups 
unlock malloc 	give bit context 
mutex malloc 	first start 
mutex unlock 	interesting function says 
cassert malloc 	mark mark 
mutex 	paint context lines 
chunk dss 	mark interesting 
sbrk chunk 	would still say 
addr offset 	context lines 
alignment ceiling 	treated interesting end 
malloc mutex 	paint lines 
unlock 	first interesting line 
chunk dss 	know included 
sbrk malloc 	next uninteresting one 
mutex unlock 	start rest 
chunk dalloc 	interesting lookahead context 
wrapper jemalloc 	lines interesting 
valgrind 	paint interesting 
make mem 	gap small first 
undefined memset 	uninteresting line 
pages decommit 	overlap beyond within 
malloc mutex 	context lines 
unlock cassert 	paint trailing edge 
malloc 	bit look 
mutex malloc 	hunk changes one 
mutex unlock 	parent changes 
cassert malloc 	one parent mark 
mutex init 	uninteresting interesting 
chunk dss 	hunks look beyond 
sbrk 	end see 
malloc mutex 	interesting line hunk 
prefork malloc 	within context 
mutex postfork 	span lookahead hunk 
parent malloc 	end interesting 
mutex postfork 	really interesting check 
child 	two versions 
data current 	result matches 
dss precedence 	one look line 
used creating 	records lines 
arenas protects 	added parents line 
sbrk calls 	appears result 
avoids 	line records parents 
malloc races 	line removed 
among threads 	line appear result 
though protect 	check parents 
races threads 	result difference lines 
call sbrk 	lines different 
directly 	parents result differences 
address dss 	means two 
current end 	versions even two 
dss dss 	versions result 
exhausted current 	match parents considered 
upper limit 	interesting would 
dss 	line passing 
addresses sbrk 	two versions test 
uses increment 	would appear 
argument take 	parents parents changes 
care interpret 	others lost 
huge allocation 	line parents hunk 
request 	interesting result 
negative increment 	deleted pointing last 
loop necessary 	hunk even 
recover races 	running unified lines 
threads dss 	hunk needs 
something malloc 	processed loop order 
avoid 	show deletion 
unnecessary system 	recorded lost head 
call current 	however want 
end dss 	show resulting line 
make sure 	blank context 
earlier condition 	markers compensate sline 
still 	hang lost 
holds calculate 	lines front 
much padding 	already examined parent 
necessary chunk 	know parent 
align end 	parent reuse combined 
dss compute 	result parent 
much 	parent overall size 
chunk aligned 	file sline 
pad space 	cnt say added 
necessary satisfy 	nobody survived 
alignment space 	lines read result 
recycled later 	merge first 
use 	used diff read 
wrap around 	working symlinks 
success chunk 	work symlink parents 
dssh dss 	symlinks fake 
prec names 	symlink apply filters 
dss prec 	autocrlf incomplete 
arena 	line even lno 
addr size 	cnt valid 
alignment zero 	end line 
commit chunk 	number deletion hunk 
jemalloc types 	end many 
jemalloc structs 	colons parents show 
jemalloc 	modes show 
externs jemalloc 	sha result elem 
inlines chunk 	working parents 
mmapc size 	typically multiple stages 
alignment zero 	merge diff 
commit ret 	files state head 
alloc 	index diff 
size pages 	index combine diff 
leadsize size 	path expresses 
alignment zero 	parents lhs merge 
commit ret 	result synthesize 
offset chunk 	diff filepair entries 
size 	one side 
pages map 	entry two side 
alignment ceiling 	future might 
pages trim 	want data 
pages decommit 	combine diff path 
pages map 	fill fields 
alignment 	ignoring notably size 
addr offset 	currently nobody 
pages unmap 	uses suffice find 
chunk alloc 	paths every 
mmap slow 	parent touches tell 
pages decommit 	diff emit 
pages 	paths sorted order 
unmap beware 	wrt paths 
size wrap 	show stat first 
around ideally 	parent even 
would way 	combined diff showing 
specify alignment 	diff show 
mmap 	requested order find 
like net 	paths everybody 
bsd absence 	touches assuming 
feature work 	diff run without 
hard efficiently 	rename copy 
create aligned 	detection etc comparing 
mappings 	trees simultaneously 
reliable slow 	faster fake list 
method create 	head worker 
mapping sized 	non nothing parents 
trim excess 	find paths 
however always 	everybody touches note 
results 	diffcore transformations 
one two 	bound diff filespec 
calls pages 	logic comparing 
unmap optimistically 	two entries apply 
mapping precisely 	directly combine 
right amount 	diff transformations requested 
falling 	launch path 
back slow 	scanning works significantly 
method expectation 	slower compared 
optimistic approach 	simultaneous trees 
works time 	one scan find 
chunk mmaph 	paths multitree 
size 	todo filters could 
alignment zero 	ported work 
commit chunk 	combine diff paths 
size jemalloc 	functionality skips 
types jemalloc 	paths theory could 
structs jemalloc 	end multitree 
externs 	path scanning note 
jemalloc inlines 	please keep 
ckh.c tsd 	semantically sync diffcore 
ckh tsd 	std note 
ckh ckh 	also handles stat 
bucket key 	computes diff 
cell 	sha parent job 
ckh key 	specifically parent 
hashes bucket 	show stat first 
cell ckh 	parent even 
bucket key 	combined diff 
data cell 	find number surviving 
offset 	paths order 
ckh argbucket 	paths according diffcore 
argkey argdata 	order clean 
key data 	things commit-slab.h define 
tkey tdata 	commit slab 
cell hashes 	slabname elemtype creates 
bucket 	boilerplate code 
tbucket ckh 	define slabname used 
argkey argdata 	associate piece 
hashes bucket 	data elemtype commits 
key data 	functions use 
ckh tab 	including header file 
count 	define commit 
nins key 	slab indegee call 
data tsd 	following functions 
ckh ret 	indegree indegree commit 
tab ttab 	function locates 
curcells prevbuckets 	data associated 
usize 	given commit indegree 
tsd ckh 	slab returns 
tab ttab 	pointer location store 
curcells usize 	data allocated 
prevbuckets tsd 	necessary indegree peek 
ckh minitems 	indegree commit 
hash 	function similar indegree 
keycomp ret 	call indegree 
mincells usize 	made commit init 
mincells tsd 	indegree indegree 
ckh ckh 	init indegree stride 
ckh tabind 	indegree initializes 
key 	indegree slab associates 
data ncells 	integers commit 
tsd ckh 	stride specifies big 
key data 	slab initialized 
ret tsd 	variant without stride 
ckh searchkey 	associates commit 
key 	one integer 
data cell 	clear indegree indegree 
ckh searchkey 	empties slab 
key data 	slab reused stride 
cell key 	without calling 
hash key 	init indegree reconfigured 
hash 	different stride 
keycomp hash 	calling init indegree 
ckh bucket 	stride call 
search ckh 	function slab falls 
bucket search 	scope avoid 
prng prng 	leaking memory allocate 
hash 	allowing malloc 
ckh bucket 	overhead note seemingly 
insert hash 	redundant second 
ckh bucket 	declaration required allow 
insert ckh 	terminating semicolon 
bucket insert 	makes instantiations 
ckh 	look like function 
evict reloc 	declarations expansion 
insert ckh 	define commit slab 
insert ipallocztm 	indegree ends 
ckh rebuild 	stat indegreerealloc would 
idalloctm tcache 	otherwise syntax 
idalloctm 	error according least 
tcache ipallocztm 	iso hard 
ckh rebuild 	gcc silently parses 
idalloctm tcache 	statically initialize 
idalloctm tcache 	commit slab named 
ipallocztm malloc 	note evaluates 
idalloctm 	stride multiple times 
tcache memset 	example indegree 
ckh search 	indegrees commit slab 
ckh insert 	init indegrees 
ckh grow 	commit slab commit-tree.c 
ckh isearch 	commit usage 
ckh 	sign commit 
shrink ckh 	parent parents oid 
isearch hash 	parents status 
strlen strcmp 	argc argv prefix 
hash implementation 	got parents 
cuckoo hashing 	sha commit sha 
indicates 	buffer arg 
hash bucket 	sha error oid 
contains cells 	hex commit 
indicates two 	list insert git 
hash functions 	gpg config 
employed original 	strcmp git config 
cuckoo 	git config 
hashing algorithm 	git config strcmp 
described pagh 	usage strcmp 
rodler cuckoo 	usage sha commit 
hashing journal 	die sha 
algorithms generalization 	type parent lookup 
cuckoo 	commit skip 
hashing discussed 	prefix strcmp 
erlingsson manasse 	strcmp usage strbuf 
sherry cool 	addch strbuf 
practical alternative 	addstr strbuf complete 
traditional hash 	line strcmp 
tables 	usage strbuf addch 
proceedings workshop 	strcmp open 
distributed data 	die errno strbuf 
structures wdas 	read die 
santa clara 	errno close die 
january implementation 	errno strbuf 
uses 	complete line sha 
precisely two 	die die 
hash functions 	strbuf read die 
fewest work 	errno commit 
supporting multiple 	strbuf release sha 
hashes implementation 	hex strbuf 
burden 	release git information 
reproduction figure 	manager hell 
erlingsson shows 	copyright linus 
approximate expected 	torvalds commit.c buf 
maximum load 	len save 
factors various 	commit buffer commit 
configurations 	type sha 
cells bucket 	quiet obj sha 
hashes number 	sha name 
cells per 	sha obj name 
bucket chosen 	oid commit 
bucket fits 	buf tail dateptr 
one 	commit graft 
cache line 	commit graft alloc 
bit systems 	commit graft 
use cuckoo 	index table commit 
hashing respectively 	graft table 
function prototypes 	sha graft ignore 
non 	dups pos 
functions search 	buf len 
bucket key 	graft entry size 
cell number 	graft file 
found size 	buf graft commit 
max otherwise 	graft prepared 
search 	graft file sha 
table key 	pos data 
cell number 	ret sha pos 
found size 	buffer size 
max otherwise 	buffer slab commit 
search primary 	buffer size 
bucket 	commit sizep commit 
search secondary 	sizep ret 
bucket cycle 	size commit buffer 
cells bucket 	commit commit 
starting random 	sizep ret item 
position randomness 	buffer size 
avoids 	tail bufptr parent 
worst search 	pptr graft 
overhead buckets 	entry len 
fill space 	parent entry len 
available bucket 	parent parent 
randomly evict 	item quiet missing 
item 	buffer size 
find alternate 	ret item commit 
location item 	buffer subject 
iteratively repeat 	eol item list 
eviction relocation 	list list 
procedure either 	head list item 
success 	list date 
detection eviction 	date next list 
relocation bucket 	list mark 
cycle choose 	ret parents commit 
random item 	plist commit 
within bucket 	mark parents commit 
evict 	mark list 
critical correct 	commit mark mark 
function without 	commit stack 
eventually evicting 	top item 
items within 	author date commit 
bucket iteration 	buffer ident 
would 	ident line ident 
possible stuck 	len date 
infinite loop 	end date data 
item hashes 	author date 
indicated bucket 	date date unused 
swap cell 	sort topological 
key 	order flags queue 
data key 	commit one 
data evict 	twos queue result 
find alternate 	commit parents 
bucket evicted 	flags one twos 
item may 	list result 
tbucket 	commit ret end 
bucket still 	bases cnt 
item hashes 	work redundant filled 
indicate bucket 	index filled 
however guaranteed 	common one 
eventually escape 	twos cleanup list 
bucket 	rslt result 
iteration assuming 	cnt one twos 
pseudo random 	one twos 
item selection 	one two commit 
randomness would 	commit commit 
make infinite 	reference reference bases 
looping 	commit reference 
remote possibility 	heads tail num 
reason never 	head gpg 
trapped forever 	sig header gpg 
two cases 	sig header 
bucket 	len buf keyid 
argbucket quickly 	sig inspos 
detect eviction 	copypos bol eol 
cycle terminate 	len commit 
item evicted 	payload signature 
bucket another 	size buffer signature 
means 	saw signature 
least one 	line tail sig 
item bucket 	next buf 
hashes indicate 	line tail signature 
distinct buckets 	sig start 
check cycle 	sig end next 
insert 	parent tail 
primary bucket 	desc mergetag buf 
insert secondary 	size len 
bucket find 	commit sigc payload 
place item 	signature ret 
via iterative 	parents tail parent 
eviction 	buffer extra 
relocation rebuild 	commit exclude extra 
hash table 	size buffer 
scratch inserting 	commit data extra 
items old 	free field 
table possible 	len field 
though 	len exclude xlen 
unlikely given 	buffer size 
well behaved 	exclude line next 
hashes table 	eof eob 
doubled order 	buf extra next 
create usable 	msg msg 
table 	len parents ret 
swap table 	author sign 
rebuilding failed 	commit tail result 
back partially 	buf len 
rebuilt table 	offset max codepoint 
possible though 	bytes bad 
unlikely 	offset codepoint min 
given well 	val max 
behaved hashes 	val buf pos 
table rebuild 	bad replace 
fail oom 	commit utf warn 
error isn 	msg msg 
worth 	len parents 
propagating since 	ret author sign 
doesn prevent 	commit extra 
future operations 	result encoding utf 
proceeding swap 	buffer parent 
table rebuilding 	name obj commit 
failed 	oid desc 
back partially 	commit next list 
rebuilt table 	format cur 
doesn really 	format last format 
matter find 	msg key 
minimum power 	len key len 
large 	line eol 
enough fit 	boc bol old 
minitems entries 	conflicts block 
cuckoo hashing 	next line deref 
expected maximum 	tag parse 
load factor 	type lookup commit 
least 	reference gently 
conservative load 	lookup commit 
factor typically 	reference die hashcmp 
allow mincells 	warning sha 
items fit 	hex lookup create 
without ever 	alloc commit 
growing 	node type sha 
table nothing 	committish lookup 
necessary halve 	commit reference parse 
table less 	commit memcmp 
full ignore 	memcmp strtoul sha 
error due 	pos commit 
oom 	graft pos free 
insert search 	free alloc 
tsd ckh 	grow memmove isspace 
tsd ckh 	xmalloc mult 
strs missing 	oid hex sha 
tsd ckh 	hex error 
seen 	free fopen strbuf 
tabind tsd 	getwholeline read 
fetch ckh 	graft line 
ckh ckh 	commit graft error 
ckh tsd 	fclose strbuf 
fetch ckh 	release graft file 
ckh 	read graft 
count ckh 	file repository shallow 
count ckh 	prepare commit 
insert ckh 	graft commit graft 
count ckh 	pos commit 
count ckh 	graft pos memmove 
search 	define commit 
ptr ptr 	slab commit slab 
ckh search 	init buffer 
ckh ptr 	slab buffer slab 
ptr ckh 	peek cached 
count ckh 	commit buffer read 
count 	sha file 
ckh tsd 	die oid 
fetch ckh 	hex die oid 
mallocx ptr 	hex buffer 
ckh insert 	slab peek free 
ckh search 	buffer slab 
ptr 	peek free buffer 
ptr ckh 	slab peek 
count ckh 	memcmp error oid 
count ckh 	hex sha 
search ckh 	hex error oid 
ptr ptr 	hex lookup 
ckh 	lookup commit graft 
search ckh 	memcmp sha 
memset ckh 	hex error oid 
iter ptr 	hex lookup 
ckh search 	commit commit list 
ckh ptr 	insert lookup 
ptr 	commit commit list 
ckh search 	insert parse 
ckh dallocx 	commit date 
ckh count 	read sha file 
ckh count 	error oid 
ckh test 	hex free error 
implementation 	oid hex 
cuckoo hashing 	parse commit buffer 
indicates hash 	commit buffer 
bucket contains 	free parse commit 
cells indicates 	die oid 
two hash 	hex xmalloc commit 
functions 	list append 
employed original 	pop commit commit 
cuckoo hashing 	list insert 
algorithm described 	llist mergesort pop 
pagh rodler 	commit parse 
cuckoo hashing 	commit commit list 
journal 	insert date 
algorithms generalization 	commit list insert 
cuckoo hashing 	commit list 
discussed erlingsson 	insert clear 
manasse sherry 	commit marks pop 
cool practical 	commit clear 
alternative 	commit marks many 
traditional hash 	lookup commit 
tables proceedings 	reference gently clear 
workshop distributed 	commit marks 
data structures 	free define commit 
wdas santa 	slab commit 
clara 	buffer find commit 
january implementation 	header split 
uses precisely 	ident line strtoul 
two hash 	author date 
functions fewest 	slab unuse commit 
work supporting 	buffer author 
multiple 	date slab author 
hashes implementation 	date slab 
burden reproduction 	commit list append 
figure erlingsson 	prio queue 
shows approximate 	put prio 
expected maximum 	queue put queue 
load 	nonstale prio 
factors various 	queue commit list 
configurations cells 	insert date 
bucket hashes 	parse commit prio 
number cells 	queue put 
per bucket 	clear prio queue 
chosen 	commit list 
bucket fits 	insert parse commit 
one cache 	parse commit 
line bit 	paint common pop 
systems use 	commit commit 
cuckoo hashing 	list insert date 
respectively 	commit list 
function prototypes 	insert merge bases 
non functions 	xcalloc xcalloc 
search bucket 	alloc parse 
key cell 	commit paint common 
number found 	clear commit 
size 	marks clear commit 
max otherwise 	marks free 
search table 	commit list memcpy 
key cell 	free free 
number found 	free merge bases 
size max 	many clear 
otherwise 	commit marks clear 
search primary 	commit marks 
bucket search 	many commit list 
secondary bucket 	count xcalloc 
cycle cells 	free commit list 
bucket starting 	clear commit 
random 	marks clear commit 
position randomness 	marks many 
avoids worst 	redundant commit list 
search overhead 	insert date 
buckets fill 	free merge 
space available 	bases many merge 
bucket 	bases many 
randomly evict 	merge bases many 
item find 	merge bases 
alternate location 	parse commit parse 
item iteratively 	commit paint 
repeat eviction 	common clear commit 
relocation 	marks clear 
procedure either 	commit marks many 
success detection 	free commit 
eviction relocation 	list merge bases 
bucket cycle 	many xcalloc 
choose random 	redundant commit list 
item 	insert strstr 
within bucket 	signing key sign 
evict critical 	buffer strbuf 
correct function 	release strchrnul strbuf 
without eventually 	insert strbuf 
evicting items 	insert strbuf 
within 	insert strbuf release 
bucket iteration 	commit buffer 
would possible 	memchr starts strbuf 
stuck infinite 	strbuf unuse 
loop item 	commit buffer memchr 
hashes indicated 	starts strbuf 
bucket 	merge remote read 
swap cell 	sha file 
key data 	parse signature xcalloc 
key data 	xstrdup free 
evict find 	parse commit check 
alternate bucket 	signature strbuf 
evicted 	release strbuf release 
item may 	handle tag 
tbucket bucket 	strbuf addstr strbuf 
still item 	lines strbuf 
hashes indicate 	addch commit buffer 
bucket however 	read commit 
guaranteed 	extra header 
eventually escape 	lines unuse commit 
bucket iteration 	buffer read 
assuming pseudo 	commit extra headers 
random item 	strcmp free 
selection randomness 	commit extra headers 
would 	memcmp memcmp 
make infinite 	memcmp memcmp memcmp 
looping remote 	strlen memcmp 
possibility reason 	memchr strbuf strbuf 
never trapped 	detach strbuf 
forever two 	reset strchr standard 
cases 	header field 
bucket argbucket 	excluded header field 
quickly detect 	xcalloc xmemdupz 
eviction cycle 	strbuf strbuf detach 
terminate item 	free free 
evicted bucket 	free append 
another 	merge tag headers 
means least 	commit extended 
one item 	free commit extra 
bucket hashes 	headers find 
indicate distinct 	invalid utf strbuf 
buckets check 	strbuf insert 
cycle 	sha type memchr 
insert primary 	error encoding 
bucket insert 	utf strbuf init 
secondary bucket 	strbuf addf 
find place 	sha hex pop 
item via 	commit strbuf 
iterative 	addf oid hex 
eviction relocation 	git author 
rebuild hash 	info strbuf addf 
table scratch 	strbuf addf 
inserting items 	git committer info 
old table 	strbuf addf 
possible 	extra header 
though unlikely 	strbuf addch strbuf 
given well 	verify utf 
behaved hashes 	sign commit write 
table doubled 	sha file 
order create 	strbuf release sha 
usable 	parse peel 
table swap 	type xmalloc strdup 
table rebuilding 	xmalloc oid 
failed back 	hex strlen strchrnul 
partially rebuilt 	strncmp memchr 
table possible 	starts nada nada 
though 	nada dateptr 
unlikely given 	buf buf strtoul 
well behaved 	stop buf 
hashes table 	format commit parent 
rebuild fail 	parent format 
oom error 	commit parent parent 
isn 	make sure 
worth propagating 	shallows read 
since doesn 	hex sha clone 
prevent future 	shallow parent 
operations proceeding 	must traverse real 
swap table 	parents even 
rebuilding 	unhide nothing topological 
failed back 	sort support 
partially rebuilt 	count number children 
table doesn 	emitted record 
really matter 	author date commit 
find minimum 	author line 
power 	malformed author line 
large enough 	malformed date 
fit minitems 	newer commits larger 
entries cuckoo 	date first 
hashing expected 	newer commits larger 
maximum load 	date first 
factor 	performs place topological 
least conservative 	sort list 
load factor 	supplied rev 
typically allow 	sort graph order 
mincells items 	mark clear 
fit without 	indegree also record 
ever 	author dates 
growing table 	needed update indegree 
nothing necessary 	find tips 
halve table 	tips nodes reachable 
less full 	node list 
ignore error 	tips serve starting 
due 	work queue 
oom insert 	unfortunate initial tips 
search ckh.c 	need shown 
tsd ckh 	order given revision 
tsd ckh 	traversal machinery 
ckh bucket 	longer need commit 
key 	list parents 
cell ckh 	enqueued emission children 
key hashes 	emitted thereby 
bucket cell 	guaranteeing topological 
ckh bucket 	order children commit 
key data 	already emitted 
cell 	emit merge stuff 
offset ckh 	remember update 
argbucket argkey 	flag allocation input 
argdata key 	commits one 
data tkey 	twos must parsed 
tdata cell 	mark parents 
hashes 	found merge stale 
bucket tbucket 	mark even 
ckh argkey 	result clean commit 
argdata hashes 	may ancestor 
bucket key 	another commit move 
data ckh 	commit end 
tab 	number commits independent 
count nins 	collect result 
key data 	one commit 
tsd ckh 	descendant one elements 
ret tab 	commit list 
ttab curcells 	commit ancestor one 
prevbuckets 	references commit 
usize tsd 	ancestor reachable reference 
ckh tab 	uniquify find 
ttab curcells 	end header dump 
usize prevbuckets 	whole remainder 
tsd ckh 	buffer dump whole 
minitems 	remainder buffer 
hash keycomp 	could verify signature 
ret mincells 	either omit 
usize mincells 	tag validate integrator 
tsd ckh 	may key 
ckh ckh 	signer tag merging 
tabind 	later auditor 
key data 	may auditing run 
ncells tsd 	verify buffer 
ckh key 	verify buffer 
data ret 	buf len buf 
tsd ckh 	len size 
searchkey 	len warn warning 
key data 	tag unverified 
cell ckh 	merge tag continuation 
searchkey key 	simple ascii 
data cell 	worries count many 
key hash 	high bits 
key 	many bytes sequence 
hash keycomp 	must bytes 
hash ckh 	longer sequences result 
bucket search 	codepoints beyond 
ckh bucket 	ffff guaranteed never 
search prng 	exist many 
prng 	bytes place encoded 
hash ckh 	bits bottom 
bucket insert 	compute valid range 
hash ckh 	verify good 
bucket insert 	continuation bytes 
ckh bucket 	reject codepoints range 
insert 	sequence length 
ckh evict 	surrogates utf cannot 
reloc insert 	encoded utf 
ckh insert 	fffe ffff guaranteed 
ipallocztm ckh 	non characters 
rebuild idalloctm 	anything range fdd 
tcache 	fdef verifies 
idalloctm tcache 	buffer proper utf 
ipallocztm ckh 	format isn 
rebuild idalloctm 	assumes non utf 
tcache idalloctm 	characters latin 
tcache ipallocztm 	conversion know must 
malloc 	range commitencoding 
idalloctm tcache 	utf avoid reallocs 
memset ckh 	headers note 
search ckh 	ordering means exact 
insert ckh 	merged different 
grow ckh 	order parents 
isearch 	different changeset even 
ckh shrink 	everything stays 
ckh isearch 	person date information 
hash strlen 	comment check 
strcmp hash 	encoding append commit 
implementation cuckoo 	end commit 
hashing 	list next starts 
indicates hash 	pointing variable 
bucket contains 	holds head empty 
cells indicates 	commit list 
two hash 	updated point next 
functions employed 	field last 
original 	item list commits 
cuckoo hashing 	appended usage 
algorithm described 	example commit list 
pagh rodler 	list commit 
cuckoo hashing 	list next 
journal algorithms 	list next commit 
generalization 	list append 
cuckoo hashing 	next next commit 
discussed erlingsson 	list append 
manasse sherry 	next commit list 
cool practical 	count list 
alternative traditional 	list inspect determine 
hash 	end log 
tables proceedings 	message order find 
workshop distributed 	put line 
data structures 	ignored trailing comment 
wdas santa 	lines blank 
clara january 	lines also traditional 
implementation 	conflicts block 
uses precisely 	commented use git 
two hash 	commit amend 
functions fewest 	existing commit forgot 
work supporting 	returns number 
multiple hashes 	bytes tail 
implementation 	ignore fed second 
burden reproduction 	parameter append 
figure erlingsson 	signoff first run 
shows approximate 	comments otherwise 
expected maximum 	continuing pathname conflicts 
load 	block previous 
factors various 	trailing comment builtin 
configurations cells 	git commit 
bucket hashes 	copyright kristian gsberg 
number cells 	krh redhat 
per bucket 	git commit junio 
chosen 	hamano linus 
bucket fits 	torvalds real index 
one cache 	used commits 
line bit 	message variables commit 
systems use 	names take 
cuckoo hashing 	commit message authorship 
respectively 	unspecified commit 
function prototypes 	message cleanup 
non functions 	mode lines beginning 
search bucket 	shell comments 
key cell 	leading trailing whitespaces 
number found 	empty lines 
size 	containing whitespaces editor 
max otherwise 	used whitespaces 
search table 	message specified explicitly 
key cell 	must come 
number found 	git config nothing 
size max 	nothing take 
otherwise 	paths index named 
search primary 	typically head 
bucket search 	paths match given 
secondary bucket 	pattern list 
cycle cells 	better valid pointer 
bucket starting 	fake one 
random 	skip worktree already 
position randomness 	reported error 
avoids worst 	finish dying 
search overhead 	refresh flags contains 
buckets fill 	refresh quiet 
space available 	errors unmerged entries 
bucket 	non non 
randomly evict 	commit real index 
item find 	update index 
alternate location 	necessary write index 
item iteratively 	real index 
repeat eviction 	still locked name 
relocation 	locked index 
procedure either 	file caller run 
success detection 	hooks locked 
eviction relocation 	real index goes 
bucket cycle 	well commit 
choose random 	real index failure 
item 	rollback real 
within bucket 	index commit 
evict critical 	name real index 
correct function 	file caller 
without eventually 	run hooks real 
evicting items 	index create 
within 	commit index still 
bucket iteration 	need refresh 
would possible 	index commit find 
stuck infinite 	affected paths 
loop item 	real index file 
hashes indicated 	update index 
bucket 	given paths write 
swap cell 	index real 
key data 	index still locked 
key data 	index file 
evict find 	reset index head 
alternate bucket 	update index 
evicted 	way write index 
item may 	index file 
tbucket bucket 	name index 
still item 	file still locked 
hashes indicate 	caller run 
bucket however 	hooks locked index 
guaranteed 	create commit 
eventually escape 	goes well commit 
bucket iteration 	real index 
assuming pseudo 	failure rollback real 
random item 	index either 
selection randomness 	rollback index checks 
would 	barfs author 
make infinite 	badly specified insert 
looping remote 	proper subject 
possibility reason 	line commit message 
never trapped 	options content 
forever two 	remaining cases modify 
cases 	message argument 
bucket argbucket 	prepare commit msg 
quickly detect 	hook squash 
eviction cycle 	commit used 
terminate item 	commit subject possibly 
evicted bucket 	hijacking commit 
another 	log options reset 
means least 	hook args 
one item 	tell real story 
bucket hashes 	ignore status 
indicate distinct 	display comment prefix 
buckets check 	need comments 
cycle 	commit editmsg hints 
insert primary 	counter productive 
bucket insert 	commit already started 
secondary bucket 	checks committer 
find place 	ident explicitly given 
item via 	cleanup space 
iterative 	never fail come 
eviction relocation 	fmt ident 
rebuild hash 	may fail sane 
table scratch 	ident test 
inserting items 	know name 
old table 	mail pointers least 
possible 	valid enough 
though unlikely 	tests printing unless 
given well 	user explicitly 
behaved hashes 	request submodule ignore 
table doubled 	mode passing 
order create 	command line option 
usable 	ignore changed 
table swap 	submodule sha comparing 
table rebuilding 	index parent 
failed back 	matter configured otherwise 
partially rebuilt 	won commit 
table possible 	submodules manually staged 
though 	would really 
unlikely given 	confusing reject attempt 
well behaved 	record non 
hashes table 	merge empty commit 
rebuild fail 	without allow 
oom error 	empty cherry 
isn 	pick may empty 
worth propagating 	due conflict 
since doesn 	resolution user okay 
prevent future 	read index 
operations proceeding 	pre commit hook 
swap table 	could updated 
rebuilding 	write must invoke 
failed back 	editor invoke 
partially rebuilt 	run status check 
table doesn 	rest whitespace 
really matter 	find message strbuf 
find minimum 	contains whitespace 
power 	lines see user 
large enough 	edited message 
fit minitems 	editor left intact 
entries cuckoo 	already initialized 
hashing expected 	enumerate needs 
maximum load 	propagated porcelain effect 
factor 	unspecified sanity 
least conservative 	check options oldsha 
load factor 	newsha nul 
typically allow 	hook know editor 
mincells items 	launched end 
fit without 	commit message options 
ever 	end commit 
growing table 	contents options ignore 
nothing necessary 	status everything 
halve table 	writing commit includes 
less full 	running hooks 
ignore error 	writing trees interacting 
due 	user determine 
oom insert 	parents commit message 
search tsd 	truncate message 
ckh tsd 	diff amending current 
ckh strs 	head builtin 
missing tsd 	commit usage 
ckh 	builtin status usage 
seen tabind 	ident advice 
tsd fetch 	noconfig ident advice 
ckh ckh 	config empty 
ckh ckh 	amend advice empty 
tsd fetch 	cherry pick 
ckh 	advice empty cherry 
ckh count 	pick advice 
ckh count 	single empty cherry 
ckh insert 	pick advice 
ckh count 	multi use message 
ckh count 	buffer commit 
ckh 	editmsg index logfile 
search ptr 	force author 
ptr ckh 	file author message 
search ckh 	author message 
ptr ptr 	buffer edit message 
ckh count 	use message 
ckh 	fixup message 
count ckh 	squash message also 
tsd fetch 	interactive patch 
ckh mallocx 	interactive amend signoff 
ptr ckh 	edit flag 
insert ckh 	quiet verbose verify 
search 	allow empty 
ptr ptr 	dry run renew 
ckh count 	authorship post 
ckh count 	rewrite allow empty 
ckh search 	message untracked 
ckh ptr 	files arg force 
ptr 	date ignore 
ckh search 	submodule arg sign 
ckh memset 	commit cleanup 
ckh iter 	arg sequencer use 
ptr ckh 	include status 
search ckh 	show ignored status 
ptr 	option include 
ptr ckh 	assumed message 
search ckh 	opt arg unset 
dallocx ckh 	buf err 
count ckh 	list prefix pattern 
count ckh 	ret max 
test 	prefix item list 
implementation cuckoo 	current head 
hashing indicates 	opts refresh flags 
hash bucket 	argc argv 
contains cells 	prefix current head 
indicates two 	status pathspec 
hash 	refresh flags ret 
functions employed 	old index 
original cuckoo 	env index file 
hashing algorithm 	prefix nowarn 
described pagh 	sha current head 
rodler cuckoo 	buf hack 
hashing 	buf errors 
journal algorithms 	buf val author 
generalization cuckoo 	ident name 
hashing discussed 	email date author 
erlingsson manasse 	ident len 
sherry cool 	date buf ident 
practical 	date buf 
alternative traditional 	candidates candidate index 
hash tables 	file prefix 
proceedings workshop 	current head author 
distributed data 	ident statbuf 
structures wdas 	committer ident commitable 
santa 	hook arg 
clara january 	hook arg clean 
implementation uses 	message contents 
precisely two 	old display comment 
hash functions 	prefix ctx 
fewest work 	buffer ctx commit 
supporting 	ident shown 
multiple hashes 	saved color 
implementation burden 	setting sha parent 
reproduction figure 	diff flags 
erlingsson shows 	index env start 
approximate expected 	eol tmpl 
maximum 	start name revs 
load factors 	commit buf 
various configurations 	mailmap ctx name 
cells bucket 	enc commit 
hashes number 	show branch use 
cells per 	deferred config 
bucket 	argc argv options 
chosen bucket 	usage prefix 
fits one 	current head argc 
cache line 	argv prefix 
bit systems 	current head commitable 
use cuckoo 	index file 
hashing 	slot slot name 
respectively function 	slot argc 
prototypes non 	argv prefix 
functions search 	sha builtin status 
bucket key 	options user 
cell number 	config xdg config 
found 	config exists 
size max 	prefix sha initial 
otherwise search 	commit rev 
table key 	commit format junk 
cell number 	sha head 
found size 	pctx author ident 
max 	committer ident 
otherwise search 	date status oldsha 
primary bucket 	newsha buf 
search secondary 	proc argv code 
bucket cycle 	editor used 
cells bucket 	index file name 
starting 	hook env 
random position 	index args ret 
randomness avoids 	argc argv 
worst search 	prefix builtin 
overhead buckets 	commit options author 
fill space 	ident index 
available 	file reflog msg 
bucket randomly 	sha pptr 
evict item 	statbuf current head 
find alternate 	extra transaction 
location item 	err allow fast 
iteratively repeat 	forward parent 
eviction 	saved errno exclude 
relocation procedure 	gpgsig tail 
either success 	cfg strbuf setlen 
detection eviction 	strbuf addch 
relocation bucket 	strbuf addstr strbuf 
cycle choose 	complete line 
random 	file exists git 
item within 	path merge 
bucket evict 	head file 
critical correct 	exists git path 
function without 	cherry pick 
eventually evicting 	head file exists 
items 	git path 
within bucket 	status prepare gitmodules 
iteration would 	config git 
possible stuck 	config determine whence 
infinite loop 	rollback file 
item hashes 	rollback file rollback 
indicated 	file commit 
bucket swap 	file commit file 
cell key 	rollback file 
data key 	xcalloc common prefix 
data evict 	overlay cache 
find alternate 	free path match 
bucket 	list insert 
evicted item 	skip worktree report 
may tbucket 	path error 
bucket still 	free lstat 
item hashes 	cache die file 
indicate bucket 	cache discard 
however 	cache memset parse 
guaranteed eventually 	indirect die 
escape bucket 	parse init desc 
iteration assuming 	unpack trees 
pseudo random 	exit refresh cache 
item selection 	die resolve 
randomness 	conflict parse pathspec 
would make 	read cache 
infinite looping 	preload die hold 
remote possibility 	locked index 
reason never 	refresh cache die 
trapped forever 	write locked 
two 	index die getenv 
cases bucket 	setenv file 
argbucket quickly 	path interactive die 
detect eviction 	setenv unsetenv 
cycle terminate 	discard cache 
item evicted 	read cache file 
bucket 	path update 
another means 	main cache reopen 
least one 	file die 
item bucket 	write locked index 
hashes indicate 	die warning 
distinct buckets 	file path hold 
check 	locked index 
cycle insert 	files cache refresh 
primary bucket 	cache die 
insert secondary 	update main cache 
bucket find 	write locked 
place item 	index die file 
via 	path hold 
iterative eviction 	locked index refresh 
relocation rebuild 	cache die 
hash table 	cache fully valid 
scratch inserting 	update main 
items old 	cache write 
table 	locked index die 
possible though 	rollback file 
unlikely given 	index file die 
well behaved 	die list 
hashes table 	init list paths 
doubled order 	exit discard 
create 	cache read cache 
usable table 	die hold 
swap table 	locked index files 
rebuilding failed 	refresh cache 
back partially 	update main cache 
rebuilt table 	write locked 
possible 	index die hold 
though unlikely 	file update 
given well 	git path getpid 
behaved hashes 	create index 
table rebuild 	files refresh cache 
fail oom 	write locked 
error 	index die 
isn worth 	discard cache file 
propagating since 	path read 
doesn prevent 	cache sha status 
future operations 	collect shortstatus 
proceeding swap 	print porcelain print 
table 	die status 
rebuilding failed 	print split ident 
back partially 	line die 
rebuilt table 	strbuf addch strbuf 
doesn really 	addf setenv 
matter find 	strbuf release strbuf 
minimum 	addch parse 
power large 	date approxidate careful 
enough fit 	strbuf addf 
minitems entries 	free xstrdup getenv 
cuckoo hashing 	xstrdup getenv 
expected maximum 	xstrdup getenv 
load 	find commit header 
factor least 	die split 
conservative load 	ident line die 
factor typically 	ident xmemdupz 
allow mincells 	ident xmemdupz strbuf 
items fit 	addch strbuf 
without 	strbuf addch strbuf 
ever growing 	ident strbuf 
table nothing 	detach split ident 
necessary halve 	line strlen 
table less 	die ident xmemdupz 
full ignore 	ident xmemdupz 
error 	parse force date 
due oom 	die ident 
insert search 	strbuf detach strbuf 
ckh.h key 	addstr fmt 
data ngrows 	ident split ident 
nshrinks nshrinkfails 	export one 
ninserts 	export one 
nrelocs prng 	export one free 
state count 	free free 
minbuckets curbuckets 	memchr strchr strchr 
hash keycomp 	die determine 
tab tsd 	author info run 
ckh 	commit hook 
minitems hash 	strcmp strbuf addstr 
keycomp tsd 	lookup commit 
ckh ckh 	reference name die 
ckh tabind 	commit output 
key data 	encoding format commit 
tsd 	message strbuf 
ckh key 	addbuf strcmp isatty 
data tsd 	strbuf read 
ckh searchkey 	die errno strbuf 
key data 	read file 
ckh seachkey 	die errno strstr 
key 	strbuf addstr 
data key 	lookup commit 
hash key 	reference name die 
hash typedefs 	commit output 
allow easy 	encoding format commit 
function pointer 	message stat 
passing 	git path merge 
maintain counters 	msg strbuf 
used idea 	read file git 
performance define 	path merge 
ckh count 	msg die errno 
print counter 	stat git 
values 	path squash msg 
ckh requires 	strbuf read 
ckh count 	file git path 
define ckh 	squash msg 
verbose ckh 	die errno strbuf 
bucket 	read file 
cells cells 	die errno fopen 
hash table 	writing git 
bucket fit 	path die 
one bucket 	errno git path 
per cache 	strbuf stripspace 
line 	append signoff ignore 
jemalloc types 	non trailer 
hash table 	fwrite die errno 
cell counters 	adjust comment 
used idea 	line strbuf release 
performance used 	strbuf addstr 
pseudo 	git committer info 
random number 	status cut 
generation total 	line status git 
number items 	path status 
minimum current 	status cut line 
number hash 	status status 
table 	split ident split 
buckets ckh 	ident ident 
bucket cells 	cmp status 
cells per 	author date interesting 
bucket hash 	status show 
comparison functions 	ident date date 
hash 	mode committer 
table curbuckets 	ident sufficiently given 
buckets jemalloc 	status status 
structs jemalloc 	run status read 
externs jemalloc 	cache die 
inlines cluster.c 	sha strcmp index 
nodename 	differs strbuf 
flags node 	release fclose merge 
privdata mask 	run status 
privdata mask 	fputs fputs fputs 
link type 	fputs discard 
nodename node 	cache read cache 
request 	update main 
slot filter 	cache error run 
name master 	commit hook 
slave slot 	git path 
slot node 	snprintf launch editor 
slot max 	git path 
slaves 	exit run commit 
bitmap pos 	hook git 
flags link 	path memchr strlen 
node delnode 	starts isspace 
flags filename 	rest empty strbuf 
line maxline 	read file 
argc 	strbuf stripspace skip 
argv master 	prefix strbuf 
start stop 	release rest empty 
slot direction 	init revisions 
fsync content 	strbuf addf setup 
size fsync 	revisions read 
filename 	mailmap prepare revision 
saveconf hard 	walk die 
node oldname 	revision strbuf release 
node link 	format commit 
link privdata 	message clear 
mask cport 	mailmap strbuf detach 
cfd 	die strcmp 
max cip 	strcmp strcmp die 
link key 	lookup commit 
keylen nodename 	reference name die 
flags node 	commit output 
failing sender 	encoding logmsg reencode 
node 	die parse 
maxtime node 	options finalize deferred 
sender node 	config strchr 
master slave 	find author nickname 
remaining slaves 	die die 
master slave 	die die die 
okslaves 	die die 
nodename node 	die read commit 
retval delnode 	message read 
node name 	commit message die 
node newname 	die strcmp 
retval max 	strcmp strcmp 
node 	strcmp strcmp die 
max epoch 	handle untracked 
sender expire 	files arg die 
node nodeid 	prepare index 
retval node 	run status rollback 
failures needed 	index files 
quorum 	strcasecmp strcasecmp strcasecmp 
node port 	strcasecmp strcasecmp 
node port 	strcasecmp strcasecmp strcasecmp 
norm hdr 	starts git 
link count 	column config strcmp 
sender flags 	git config 
node 	strcmp git config 
buf link 	strcmp git 
node link 	config strcmp strcmp 
port sender 	git config 
sender config 	colorbool strcmp 
epoch slots 	git config skip 
curmaster 	prefix skip 
newmaster dirty 	prefix parse status 
slots dirty 	slot config 
slots count 	error nonbool color 
link hdr 	parse strcmp 
totlen type 	git config strcmp 
flags 	config error 
sender config 	nonbool strcmp strcmp 
epoch sender 	strcmp error 
count explen 	git diff config 
explen explen 	strcmp usage 
explen explen 	options status init 
node 	config parse 
master sender 	options finalize colopts 
master dirty 	finalize deferred 
slots failing 	config handle untracked 
channel message 	files arg 
channel len 	parse pathspec 
message 	read cache preload 
len reported 	refresh index 
config epoch 	hold locked index 
link privdata 	sha status 
mask link 	collect update index 
nwritten privdata 	able shortstatus 
mask 	print porcelain print 
buf nread 	die status 
hdr link 	print expand user 
readlen rcvbuflen 	path xdg 
link msg 	config home file 
msglen buf 	exists file 
len 	exists free free 
node hdr 	lookup commit 
type totlen 	die parse commit 
offset master 	die strbuf 
link type 	addstr format commit 
buf hdr 	message format 
gossipcount 	commit message 
wanted totlen 	strbuf cmp strbuf 
freshnodes maxiterations 	addstr strbuf 
gossip target 	addbuf percentquote author 
node local 	date interesting 
slave link 	format commit message 
channel 	strbuf addstr 
message buf 	strbuf addbuf percentquote 
payload hdr 	strbuf release 
totlen channel 	committer ident sufficiently 
len message 	given strbuf 
len nodename 	addstr strbuf addbuf 
buf 	percentquote strbuf 
hdr link 	addch strbuf addstr 
node buf 	ident advice 
hdr channel 	strbuf release strbuf 
message buf 	release init 
hdr totlen 	revisions setup revisions 
node 	commit format 
buf hdr 	diff setup 
totlen node 	done resolve strcmp 
buf hdr 	skip prefix 
totlen node 	log commit log 
request master 	commit strbuf 
request 	release strcmp git 
current epoch 	config pathname 
request config 	strcmp git config 
epoch claimed 	strcmp git 
slots force 	config strcmp git 
ack myoffset 	config git 
rank 	gpg config git 
master reason 	status config 
msg lastlog 	find hook start 
time nolog 	command snprintf 
fail time 	sha hex sha 
oldmaster data 	hex sigchain 
age 	push write full 
auth age 	close sigchain 
needed quorum 	pop finish 
manual failover 	command snprintf start 
auth timeout 	run hook 
auth retry 	end strcmp usage 
time 	options status 
newrank added 	init config sha 
delay max 	lookup commit 
slaves okslaves 	die parse commit 
candidate node 	die parse 
orphaned update 	validate options dry 
state 	run commit 
orphaned masters 	prepare index prepare 
max slaves 	commit rollback 
slaves min 	index files getenv 
pong node 	commit list 
iteration handshake 	insert commit list 
timeout 	insert fopen 
node old 	git path 
ping sent 	merge head die 
link node 	errno git 
delay okslaves 	path merge head 
fsync flags 	strbuf getline 
bitmap 	merge parent die 
pos bit 	commit list 
bitmap pos 	insert fclose strbuf 
bit bitmap 	release stat 
pos bit 	git path merge 
slot old 	mode strbuf 
slot 	read file git 
old slot 	path merge 
slot slot 	mode die errno 
node state 	strcmp reduce 
reachable masters 	heads commit list 
among minority 	insert strbuf 
time 	reset strbuf read 
first call 	file git 
time node 	path rollback 
needed quorum 	index files die 
rejoin delay 	strerror status 
update config 	truncate message cut 
flag 	line strbuf 
name redis 	stripspace untouched rollback 
node flags 	index files 
table flags 	exit message empty 
size nodeflag 	rollback index 
node start 	files exit read 
bit 	commit extra 
filter node 	headers append merge 
slot num 	tag headers 
masters slot 	commit extended rollback 
replylen node 	index files 
start bit 	die strbuf release 
nested 	free commit 
elements nested 	extra headers strchr 
replylen port 	strbuf setlen 
slot slots 	strbuf addch 
del retval 	strbuf insert strlen 
slot retval 	strbuf insert 
reply 	strlen transaction begin 
statestr slots 	transaction update 
fail myepoch 	transaction commit rollback 
info retval 	index files 
key slot 	die transaction free 
maxkeys slot 	unlink git 
numkeys 	path cherry pick 
keys takeover 	head unlink 
epoch hard 	git path revert 
payload buf 	head unlink 
crc len 	git path merge 
footer rdbver 	head unlink 
crc 	git path merge 
dumpobj payload 	msg unlink 
ttl payload 	git path merge 
type replace 	mode unlink 
obj host 	git path 
port timeout 	squash msg commit 
name 	index files 
host port 	die rerere run 
name copy 	commit hook 
replace timeout 	index file init 
dbid ttl 	copy notes 
expireat newargv 	rewrite copy note 
cmd 	rewrite finish 
payload may 	copy notes rewrite 
retry write 	run rewrite 
error first 	hook print summary 
key num 	strbuf release 
keys buf 	nada nada nada 
towrite 	dateptr buf 
nwritten buf 	buf strtoul stop 
buf error 	buf format 
target socket 	commit parent 
error del 	parent format commit 
idx cmd 	parent parent 
argv 	make sure shallows 
argc hashslot 	read hex 
error code 	sha clone shallow 
firstkey multiple 	parent must 
keys missing 	traverse real parents 
keys mcmd 	even unhide 
margv 	nothing topological sort 
margc keyindex 	support count 
numkeys thiskey 	number children emitted 
thisslot hashslot 	record author 
error code 	date commit author 
key slot 	line malformed 
node 	author line malformed 
fopen server 	date newer 
log strerror 	commits larger date 
exit fstat 	first newer 
fileno fclose 	commits larger 
zmalloc fgets 	date first performs 
sdssplitargs 	place topological 
strcasecmp strcasecmp 	sort list supplied 
strtoull strcasecmp 	rev sort 
strtoull server 	graph order mark 
log sdsfreesplitres 	clear indegree 
cluster lookup 	also record author 
node 	dates needed 
create cluster 	update indegree find 
node cluster 	tips tips 
node strrchr 	nodes reachable node 
memcpy strlen 	list tips 
atoi strchr 	serve starting work 
strcasecmp 	queue unfortunate 
server strcasecmp 	initial tips need 
strcasecmp strcasecmp 	shown order 
strcasecmp mstime 	given revision traversal 
strcasecmp strcasecmp 	machinery longer 
strcasecmp server 	need commit 
panic 	list parents enqueued 
cluster lookup 	emission children 
node create 	emitted thereby guaranteeing 
cluster node 	topological order 
cluster node 	children commit already 
cluster node 	emitted emit 
slave 	merge stuff remember 
atoi mstime 	update flag 
atoi mstime 	allocation input commits 
strtoull strchr 	one twos 
server atoi 	must parsed mark 
cluster lookup 	parents found 
node 	merge stale mark 
create cluster 	even result 
node cluster 	clean commit may 
node strchr 	ancestor another 
atoi atoi 	commit move commit 
atoi cluster 	end number 
slot 	commits independent 
sdsfreesplitres zfree 	collect result one 
fclose server 	commit descendant 
log cluster 	one elements commit 
max epoch 	list commit 
cluster max 	ancestor one references 
epoch 	commit ancestor 
server log 	reachable reference uniquify 
zfree fclose 	find end 
exit cluster 	header dump whole 
gen nodes 	remainder buffer 
description sdscatprintf 	dump whole remainder 
sdslen 	buffer could 
open fstat 	verify signature either 
sdsgrowzero memset 	omit tag 
write sdslen 	validate integrator may 
sdslen fsync 	key signer 
sdslen ftruncate 	tag merging 
close 	later auditor may 
sdsfree close 	auditing run 
sdsfree cluster 	verify buffer verify 
save config 	buffer buf 
server log 	len buf len 
exit open 	size len 
server 	warn warning tag 
log strerror 	unverified merge 
flock server 	tag continuation simple 
log server 	ascii worries 
log strerror 	count many high 
close zmalloc 	bits many 
dict 	bytes sequence must 
create dict 	bytes longer 
create memset 	sequences result codepoints 
cluster close 	beyond ffff 
slots cluster 	guaranteed never exist 
config exit 	many bytes 
cluster 	place encoded 
load config 	bits bottom compute 
create cluster 	valid range 
node server 	verify good continuation 
log cluster 	bytes reject 
node cluster 	codepoints range sequence 
save 	length surrogates 
config die 	utf cannot encoded 
server log 	utf fffe 
exit listen 	ffff guaranteed non 
port exit 	characters anything 
create file 	range fdd fdef 
server 	verifies buffer 
panic zsl 	proper utf format 
create reset 	isn assumes 
manual failover 	non utf characters 
node slave 	latin conversion 
cluster node 	know must range 
master 	commitencoding utf 
replication unset 	avoid reallocs 
master empty 	headers note ordering 
cluster close 	means exact 
slots reset 	merged different order 
manual failover 	parents different 
cluster 	changeset even everything 
del slot 	stays person 
dict safe 	date information comment 
iterator dict 	check encoding 
next dict 	append commit end 
val cluster 	commit list 
del 	next starts pointing 
node dict 	variable holds 
release iterator 	head empty commit 
server log 	list updated 
sdsnewlen dict 	point next field 
sdsfree random 	last item 
hex 	list commits appended 
chars cluster 	usage example 
node server 	commit list 
log cluster 	list commit list 
sleep zmalloc 	next list 
mstime sdsempty 	next commit list 
sdsempty 	append next 
file file 	next commit list 
sdsfree sdsfree 	append next 
close zfree 	commit list count 
unused unused 	list list 
unused anet 	inspect determine end 
tcp 	log message 
accept server 	order find put 
log anet 	line ignored 
non block 	trailing comment lines 
anet enable 	blank lines 
tcp delay 	also traditional conflicts 
server 	block commented 
log create 	use git commit 
cluster link 	amend existing 
create file 	commit forgot 
crc crc 	returns number bytes 
crc zmalloc 	tail ignore 
memcpy 	fed second parameter 
random hex 	append signoff 
chars mstime 	first run comments 
memset memset 	otherwise continuing 
list create 	pathname conflicts block 
list free 	previous trailing 
method 	comment builtin git 
list rewind 	commit copyright 
list next 	kristian gsberg krh 
mstime zmalloc 	redhat git 
mstime list 	commit junio hamano 
node tail 	linus torvalds 
mstime 	real index used 
list rewind 	commits message 
list next 	variables commit 
list del 	names take commit 
node list 	message authorship 
rewind 	unspecified commit message 
list next 	cleanup mode 
list del 	lines beginning shell 
node cluster 	comments leading 
node cleanup 	trailing whitespaces empty 
failure reports 	lines containing 
cluster 	whitespaces editor used 
node cleanup 	whitespaces message 
failure reports 	specified explicitly must 
list length 	come git 
memmove zrealloc 	config nothing nothing 
node failed 	take paths 
node 	index named typically 
slave cluster 	head paths 
node slave 	match given pattern 
sdsnewlen server 	list better 
dict sdsfree 	valid pointer 
free cluster 	fake one skip 
link 	worktree already 
list release 	reported error finish 
zfree zfree 	dying refresh 
dict sdsnewlen 	flags contains refresh 
cluster del 	quiet errors 
slot dict 	unmerged entries non 
safe 	non commit 
iterator dict 	real index update 
next dict 	index necessary 
val cluster 	write index real 
node del 	index still 
failure report 	locked name locked 
dict 	index file 
release iterator 	caller run hooks 
free cluster 	locked real 
node sdsnewlen 	index goes well 
dict find 	commit real 
sdsfree dict 	index failure 
val 	rollback real index 
sdsnewlen server 	commit name 
log dict 	real index file 
sdsfree server 	caller run 
memcpy cluster 	hooks real index 
node dict 	create commit 
safe 	index still need 
iterator dict 	refresh index 
next dict 	commit find affected 
val dict 	paths real 
release iterator 	index file update 
cluster max 	index given 
epoch 	paths write index 
cluster sleep 	real index 
server log 	still locked index 
node master 	file reset 
node master 	index head update 
memcmp cluster 	index way 
save 	write index 
config die 	index file name 
server log 	index file 
dict safe 	still locked caller 
iterator dict 	run hooks 
next dict 	locked index create 
integer 	commit goes 
val dict 	well commit real 
dict key 	index failure 
dict release 	rollback real index 
iterator sdsnewlen 	either rollback 
cluster blacklist 	index checks barfs 
cleanup 	author badly 
dict sdsdup 	specified insert proper 
dict find 	subject line 
dict integer 	commit message options 
val time 	content remaining 
sdsfree sdsnewlen 	cases modify 
cluster 	message argument prepare 
blacklist cleanup 	commit msg 
dict find 	hook squash commit 
sdsfree node 	used commit 
timed node 	subject possibly hijacking 
failed cluster 	commit log 
node 	options reset hook 
failure reports 	args tell 
count node 	real story ignore 
master server 	status display 
log mstime 	comment prefix need 
node master 	comments commit 
cluster 	editmsg hints counter 
send fail 	productive commit 
cluster sleep 	already started checks 
mstime server 	committer ident 
node failed 	explicitly given cleanup 
node slave 	space never 
server 	fail come 
log node 	fmt ident may 
slave cluster 	fail sane 
sleep node 	ident test know 
master server 	name mail 
log cluster 	pointers least valid 
sleep 	enough tests 
dict safe 	printing unless user 
iterator dict 	explicitly request 
next dict 	submodule ignore mode 
val node 	passing command 
handshake strcasecmp 	line option ignore 
dict 	changed submodule 
release iterator 	sha comparing index 
inet pton 	parent matter 
inet pton 	configured otherwise won 
memset inet 	commit submodules 
ntop inet 	manually staged would 
ntop 	really confusing 
cluster handshake 	reject attempt 
progress create 	record non merge 
cluster node 	empty commit 
memcpy cluster 	without allow empty 
node ntohs 	cherry pick 
cluster 	may empty due 
lookup node 	conflict resolution 
ntohs represent 	user okay read 
cluster node 	index pre 
flags sdsempty 	commit hook could 
server log 	updated write 
ntohs 	must invoke editor 
sdsfree cluster 	invoke run 
lookup node 	status check rest 
node master 	whitespace find 
cluster node 	message strbuf contains 
failure report 	whitespace lines 
server 	see user edited 
log mark 	message editor 
node failing 	left intact 
needed cluster 	already initialized enumerate 
node del 	needs propagated 
failure report 	porcelain effect unspecified 
server 	sanity check 
log strcasecmp 	options oldsha newsha 
ntohs free 	nul hook 
cluster link 	know editor launched 
memcpy ntohs 	end commit 
cluster blacklist 	message options end 
exists 	commit contents 
cluster start 	options ignore status 
handshake ntohs 	everything writing 
anet peer 	commit includes running 
node strcmp 	hooks writing 
memcpy free 	trees interacting user 
cluster 	determine parents 
link server 	commit message 
log node 	truncate message diff 
slave replication 	amending current 
master node 	head commit.c buf 
master cluster 	len save 
node 	commit buffer commit 
slave cluster 	type sha 
sleep node 	quiet obj sha 
master server 	sha name 
log bitmap 	sha obj name 
test bit 	oid commit 
count 	buf tail dateptr 
keys slot 	commit graft 
cluster del 	commit graft alloc 
slot cluster 	commit graft 
slot cluster 	index table commit 
sleep server 	graft table 
log 	sha graft ignore 
cluster master 	dups pos 
cluster sleep 	buf len 
del keys 	graft entry size 
slot ntohl 	graft file 
ntohs server 	buf graft commit 
log 	graft prepared 
sdslen ntohs 	graft file sha 
ntohs ntohs 	pos data 
ntohl ntohl 	ret sha pos 
cluster lookup 	buffer size 
node node 	buffer slab commit 
handshake 	buffer size 
ntohu ntohu 	commit sizep commit 
cluster sleep 	sizep ret 
ntohu mstime 	size commit buffer 
node slave 	commit commit 
server log 	sizep ret item 
server 	buffer size 
log anet 	tail bufptr parent 
sock name 	pptr graft 
strcmp memcpy 	entry len 
server log 	parent entry len 
cluster sleep 	parent parent 
create 	item quiet missing 
cluster node 	buffer size 
node ntohs 	ret item commit 
cluster node 	buffer subject 
cluster sleep 	eol item list 
cluster process 	list list 
gossip 	head list item 
section cluster 	list date 
send ping 	date next list 
server log 	list mark 
node handshake 	ret parents commit 
server log 	plist commit 
node 	mark parents commit 
update address 	mark list 
needed ntohs 	commit mark mark 
cluster sleep 	commit stack 
cluster del 	top item 
node cluster 	author date commit 
rename 	buffer ident 
node server 	ident line ident 
log cluster 	len date 
sleep memcmp 	end date data 
server log 	author date 
mstime free 	date date unused 
cluster 	sort topological 
link cluster 	order flags queue 
sleep node 	commit one 
handshake node 	twos queue result 
update address 	commit parents 
needed ntohs 	flags one twos 
cluster 	list result 
sleep mstime 	commit ret end 
node timed 	bases cnt 
cluster sleep 	work redundant filled 
node failed 	index filled 
clear node 	common one 
failure 	twos cleanup list 
needed memcmp 	rslt result 
cluster node 	cnt one twos 
master cluster 	one twos 
lookup node 	one two commit 
node master 	commit commit 
cluster 	reference reference bases 
del node 	commit reference 
slots cluster 	heads tail num 
sleep cluster 	head gpg 
node slave 	sig header gpg 
cluster node 	sig header 
slave 	len buf keyid 
cluster sleep 	sig inspos 
node master 	copypos bol eol 
memcmp node 	len commit 
master cluster 	payload signature 
update slots 	size buffer signature 
config 	saw signature 
bitmap test 	line tail sig 
bit server 	next buf 
log cluster 	line tail signature 
send update 	sig start 
node master 	sig end next 
node 	parent tail 
master cluster 	desc mergetag buf 
handle config 	size len 
epoch collision 	commit sigc payload 
cluster process 	signature ret 
gossip section 	parents tail parent 
cluster 	buffer extra 
lookup node 	commit exclude extra 
server log 	size buffer 
mstime cluster 	commit data extra 
sleep server 	free field 
log dict 	len field 
size 	len exclude xlen 
list length 	buffer size 
ntohl ntohl 	exclude line next 
create create 	eof eob 
pubsub publish 	buf extra next 
message decr 	msg msg 
count 	len parents ret 
decr count 	author sign 
cluster send 	commit tail result 
failover auth 	buf len 
needed node 	offset max codepoint 
master cluster 	bytes bad 
sleep 	offset codepoint min 
reset manual 	val max 
failover mstime 	val buf pos 
pause clients 	bad replace 
mstime server 	commit utf warn 
log ntohu 	msg msg 
cluster 	len parents 
lookup node 	ret author sign 
node slave 	commit extra 
cluster node 	result encoding utf 
master cluster 	buffer parent 
sleep cluster 	name obj commit 
update 	oid desc 
slots config 	commit next list 
server log 	format cur 
free cluster 	format last format 
link unused 	msg key 
unused write 	len key len 
sdslen 	line eol 
server log 	boc bol old 
strerror handle 	conflicts block 
link error 	next line deref 
sdsrange sdslen 	tag parse 
file unused 	type lookup commit 
unused 	reference gently 
sdslen memcmp 	lookup commit 
ntohl server 	reference die hashcmp 
log handle 	warning sha 
link error 	hex lookup create 
ntohl read 	alloc commit 
server 	node type sha 
log strerror 	committish lookup 
handle link 	commit reference parse 
error sdscatlen 	commit memcmp 
ntohl cluster 	memcmp strtoul sha 
process packet 	pos commit 
sdsfree 	graft pos free 
sdsempty sdslen 	free alloc 
create file 	grow memmove isspace 
sdscatlen dict 	xmalloc mult 
safe iterator 	oid hex sha 
dict next 	hex error 
dict 	free fopen 
val cluster 	strbuf getwholeline read 
send message 	graft line 
dict release 	commit graft error 
iterator node 	fclose strbuf 
slave memset 	release graft file 
htons 	read graft 
htons memcpy 	file repository shallow 
memcpy memset 	prepare commit 
memcpy htons 	graft commit graft 
htons htonu 	pos commit 
htonu node 	graft pos memmove 
slave 	define commit 
replication slave 	slab commit slab 
offset htonu 	init buffer 
node master 	slab buffer slab 
htonl dict 	peek cached 
size floor 	commit buffer read 
dict 	sha file 
size zcalloc 	die oid 
mstime cluster 	hex die oid 
build message 	hex buffer 
hdr dict 	slab peek free 
random key 	buffer slab 
dict 	peek free buffer 
val memcmp 	slab peek 
memcpy htonl 	memcmp error oid 
htonl memcpy 	hex sha 
htons htons 	hex error oid 
htons htonl 	hex lookup 
cluster 	lookup commit graft 
send message 	memcmp sha 
zfree dict 	hex error oid 
safe iterator 	hex lookup 
dict next 	commit commit list 
dict val 	insert lookup 
node 	commit commit list 
handshake node 	insert parse 
slave cluster 	commit date 
send ping 	read sha file 
dict release 	error oid 
iterator decoded 	hex free error 
decoded 	oid hex 
sdslen sdslen 	parse commit buffer 
cluster build 	commit buffer 
message hdr 	free parse commit 
htonl htonl 	die oid 
htonl zmalloc 	hex xmalloc commit 
memcpy 	list append 
memcpy sdslen 	pop commit commit 
memcpy sdslen 	list insert 
sdslen cluster 	llist mergesort pop 
send message 	commit parse 
cluster broadcast 	commit commit list 
message 	insert date 
decr count 	commit list insert 
decr count 	commit list 
zfree cluster 	insert clear 
build message 	commit marks pop 
hdr memcpy 	commit clear 
cluster 	commit marks many 
broadcast message 	lookup commit 
ntohl cluster 	reference gently clear 
build message 	commit marks 
hdr memcpy 	free define commit 
htonu memcpy 	slab commit 
cluster 	buffer find commit 
send message 	header split 
ntohl cluster 	ident line strtoul 
send publish 	author date 
cluster build 	slab unuse commit 
message hdr 	buffer author 
htonl 	date slab author 
cluster broadcast 	date slab 
message cluster 	commit list 
build message 	append prio queue 
hdr htonl 	put prio 
cluster send 	queue put queue 
message 	nonstale prio 
cluster build 	queue commit list 
message hdr 	insert date 
htonl cluster 	parse commit prio 
send message 	queue put 
ntohu ntohu 	clear prio queue 
node 	commit list 
slave server 	insert parse commit 
log server 	parse commit 
log node 	paint common pop 
master node 	commit commit 
failed node 	list insert date 
master 	commit list 
server log 	insert merge bases 
server log 	xcalloc xcalloc 
node failed 	alloc parse 
server log 	commit paint common 
mstime server 	clear commit 
log 	marks clear commit 
mstime bitmap 	marks free 
test bit 	commit list memcpy 
server log 	free free 
cluster send 	free merge bases 
failover auth 	many clear 
mstime 	commit marks clear 
server log 	commit marks 
server node 	many commit list 
slave replication 	count xcalloc 
slave offset 	free commit list 
time node 	clear commit 
failed 	marks clear commit 
mstime time 	marks many 
server log 	redundant commit list 
node master 	insert date 
cluster node 	free merge 
master replication 	bases many merge 
unset 	bases many 
master cluster 	merge bases many 
node slot 	merge bases 
bit cluster 	parse commit parse 
del slot 	commit paint 
cluster slot 	common clear commit 
cluster 	marks clear 
update state 	commit marks many 
cluster save 	free commit 
config die 	list merge bases 
cluster broadcast 	many xcalloc 
pong 	redundant commit list 
reset manual 	insert strstr 
failover mstime 	signing key sign 
node master 	buffer strbuf 
node failed 	release strchrnul strbuf 
mstime mstime 	insert strbuf 
cluster 	insert strbuf 
log cant 	insert strbuf release 
failover mstime 	commit buffer 
random cluster 	memchr starts strbuf 
slave rank 	strbuf unuse 
mstime server 	commit buffer memchr 
log 	starts strbuf 
mstime replication 	merge remote read 
slave offset 	sha file 
cluster broadcast 	parse signature xcalloc 
pong cluster 	xstrdup free 
slave rank 	parse commit check 
server 	signature strbuf 
log mstime 	release strbuf release 
cluster log 	handle tag 
cant failover 	strbuf addstr strbuf 
cluster log 	lines strbuf 
cant failover 	addch commit buffer 
server 	read commit 
log cluster 	extra header 
request failover 	lines unuse commit 
auth cluster 	buffer read 
sleep server 	commit extra headers 
log server 	strcmp free 
log 	commit extra headers 
cluster failover 	memcmp memcmp 
replace master 	memcmp memcmp memcmp 
cluster log 	strlen memcmp 
cant failover 	memchr strbuf strbuf 
node failed 	detach strbuf 
node 	reset strchr standard 
timed dict 	header field 
safe iterator 	excluded header field 
dict next 	xcalloc xmemdupz 
dict val 	strbuf strbuf detach 
node slave 	free free 
node 	free append 
failed node 	merge tag headers 
master cluster 	commit extended 
count non 	free commit extra 
failing slaves 	headers find 
mstime memcmp 	invalid utf strbuf 
dict 	strbuf insert 
release iterator 	sha type memchr 
mstime server 	error encoding 
log cluster 	utf strbuf init 
master clients 	strbuf addf 
paused clients 	sha hex pop 
paused 	commit strbuf 
mstime server 	addf oid hex 
log reset 	git author 
manual failover 	info strbuf addf 
replication slave 	strbuf addf 
offset server 	git committer info 
log 	strbuf addf 
dict safe 	extra header 
iterator dict 	strbuf addch strbuf 
next dict 	verify utf 
val node 	sign commit write 
handshake cluster 	sha file 
del 	strbuf release sha 
node anet 	parse peel 
tcp non 	type xmalloc strdup 
block bind 	xmalloc oid 
connect mstime 	hex strlen strchrnul 
server log 	strncmp memchr 
create 	starts nada nada 
cluster link 	nada dateptr 
create file 	buf buf strtoul 
cluster send 	stop buf 
ping server 	format commit parent 
log dict 	parent format 
release 	commit parent parent 
iterator dict 	make sure 
random key 	shallows read 
dict val 	hex sha clone 
server log 	shallow parent 
cluster send 	must traverse real 
ping 	parents even 
dict safe 	unhide nothing topological 
iterator dict 	sort support 
next dict 	count number children 
val mstime 	emitted record 
node slave 	author date commit 
node 	author line 
master node 	malformed author line 
failed cluster 	malformed date 
count non 	newer commits larger 
failing slaves 	date first 
node slave 	newer commits larger 
free 	date first 
cluster link 	performs place topological 
cluster send 	sort list 
ping node 	supplied rev 
master cluster 	sort graph order 
send ping 	mark clear 
server 	indegree also record 
log dict 	author dates 
release iterator 	needed update indegree 
node slave 	find tips 
node addr 	tips nodes reachable 
replication master 	node list 
manual 	tips serve starting 
failover check 	work queue 
timeout node 	unfortunate initial tips 
slave cluster 	need shown 
handle manual 	order given revision 
failover cluster 	traversal machinery 
handle 	longer need commit 
slave failover 	list parents 
cluster handle 	enqueued emission 
slave migration 	children emitted thereby 
cluster update 	guaranteeing topological 
state cluster 	order children commit 
handle 	already emitted 
slave failover 	emit merge stuff 
cluster update 	remember update 
state cluster 	flag allocation input 
save config 	commits one 
die bitmap 	twos must parsed 
test 	mark parents 
bit bitmap 	found merge stale 
bit bitmap 	mark even 
test bit 	result clean commit 
bitmap clear 	may ancestor 
bit bitmap 	another commit move 
test 	commit end 
bit cluster 	number commits independent 
node slot 	collect result 
bit server 	one commit 
cluster node 	descendant one elements 
clear slot 	commit list 
bit 	commit ancestor one 
cluster node 	references commit 
slot bit 	ancestor reachable reference 
cluster del 	uniquify find 
slot memset 	end header dump 
memset mstime 	whole remainder 
node 	buffer dump whole 
master mstime 	remainder buffer 
dict safe 	could verify signature 
iterator dict 	either omit 
next dict 	tag validate integrator 
val node 	may key 
master 	signer tag merging 
dict release 	later auditor 
iterator mstime 	may auditing run 
node master 	verify buffer 
mstime server 	verify buffer 
log node 	buf len buf 
slave 	len size 
dict size 	len warn warning 
count keys 	tag unverified 
slot server 	merge tag continuation 
log cluster 	simple ascii 
slot server 	worries count many 
log 	high bits 
cluster save 	many bytes sequence 
config die 	must bytes 
server server 	longer sequences result 
node master 	codepoints beyond 
cluster close 	ffff guaranteed never 
slots 	exist many 
cluster node 	bytes place encoded 
slave cluster 	bits bottom 
node slave 	compute valid range 
replication master 	verify good 
reset manual 	continuation bytes 
failover 	reject codepoints range 
sdscat sdscat 	sequence length 
sds incr 	surrogates utf cannot 
len sdscatprintf 	encoded utf 
sdsempty represent 	fffe ffff guaranteed 
cluster node 	non characters 
flags 	anything range fdd 
sdscatprintf sdscatlen 	fdef verifies 
sdscatprintf cluster 	buffer proper utf 
node slot 	format isn 
bit sdscatprintf 	assumes non utf 
sdscatprintf sdscatprintf 	characters latin 
sdscatprintf 	conversion know must 
sdsempty dict 	range commitencoding 
safe iterator 	utf avoid reallocs 
dict next 	headers note 
dict val 	ordering means 
cluster gen 	exact merged different 
node 	order parents 
description sdscatsds 	different changeset even 
sdsfree sdscatlen 	everything stays 
dict release 	person date information 
iterator reply 	comment check 
error deferred 	encoding append commit 
multi 	end commit 
bulk length 	list next starts 
dict safe 	pointing variable 
iterator dict 	holds head empty 
next dict 	commit list 
val node 	updated point next 
master 	field last 
cluster node 	item list commits 
slot bit 	appended usage 
deferred multi 	example commit list 
bulk length 	list commit 
reply reply 	list next 
reply 	list next commit 
reply reply 	list append 
multi bulk 	next next commit 
len reply 	list append 
bulk reply 	next commit list 
reply bulk 	count list 
buffer 	list inspect determine 
node failed 	end log 
reply multi 	message order find 
bulk len 	put line 
reply bulk 	ignored trailing comment 
reply reply 	lines blank 
bulk 	lines also traditional 
buffer deferred 	conflicts block 
multi bulk 	commented use git 
length dict 	commit amend 
release iterator 	existing commit forgot 
deferred multi 	returns number 
bulk 	bytes tail 
length reply 	ignore fed second 
error strcasecmp 	parameter append 
reply error 	signoff first run 
format cluster 	comments otherwise 
start handshake 	continuing pathname conflicts 
reply 	block previous 
error format 	trailing comment builtin 
reply strcasecmp 	git commit 
cluster gen 	copyright kristian gsberg 
nodes description 	krh redhat 
create reply 	git commit junio 
bulk 	hamano linus 
decr count 	torvalds real index 
strcasecmp reply 	used commits 
bulk buffer 	message variables commit 
strcasecmp cluster 	names take 
reply multi 	commit message authorship 
bulk 	unspecified commit 
slots strcasecmp 	message cleanup 
dict size 	mode lines beginning 
reply error 	shell comments 
cluster del 	leading trailing whitespaces 
node slots 	empty lines 
cluster 	containing whitespaces editor 
sleep reply 	used whitespaces 
strcasecmp strcasecmp 	message specified explicitly 
zmalloc strcasecmp 	must come 
memset slot 	git config nothing 
reply zfree 	nothing take 
reply 	paths index named 
error format 	typically head 
zfree reply 	paths match given 
error format 	pattern list 
zfree reply 	better valid pointer 
error format 	fake one 
zfree 	skip worktree already 
cluster del 	reported error 
slot cluster 	finish dying 
slot server 	refresh flags contains 
info zfree 	refresh quiet 
cluster sleep 	errors unmerged entries 
reply 	non non 
strcasecmp node 	commit real index 
slave reply 	update index 
error slot 	necessary write index 
reply strcasecmp 	real index 
reply error 	still locked name 
format 	locked index 
cluster lookup 	file caller run 
node reply 	hooks locked 
error format 	real index goes 
strcasecmp reply 	well commit 
error format 	real index failure 
cluster 	rollback real 
lookup node 	index commit 
reply error 	name real index 
format strcasecmp 	file caller 
strcasecmp cluster 	run hooks real 
lookup node 	index create 
reply 	commit index still 
error format 	need refresh 
count keys 	index commit find 
slot reply 	affected paths 
error format 	real index file 
count keys 	update index 
slot 	given paths write 
cluster bump 	index real 
config epoch 	index still locked 
without consensus 	index file 
server log 	reset index head 
cluster del 	update index 
slot 	way write index 
cluster slot 	index file 
reply error 	name index 
cluster sleep 	file still locked 
reply strcasecmp 	caller run 
cluster bump 	hooks locked index 
config 	create commit 
epoch without 	goes well commit 
consensus sdscatprintf 	real index 
sdsempty reply 	failure rollback real 
sds strcasecmp 	index either 
node failed 	rollback index checks 
node 	barfs author 
timed node 	badly specified insert 
slave sdscatprintf 	proper subject 
sdsempty dict 	line commit message 
size reply 	options content 
sds sdscatprintf 	remaining cases modify 
sdsempty 	message argument 
sdslen reply 	prepare commit msg 
sds reply 	hook squash 
strcasecmp cluster 	commit used 
save config 	commit subject possibly 
reply reply 	hijacking commit 
error 	log options reset 
format strerror 	hook args 
strcasecmp reply 	tell real story 
key hash 	ignore status 
slot sdslen 	display comment prefix 
strcasecmp reply 	need comments 
reply 	commit editmsg hints 
error reply 	counter productive 
count keys 	commit already started 
slot strcasecmp 	checks committer 
reply reply 	ident explicitly given 
reply error 	cleanup space 
zmalloc 	never fail come 
keys slot 	fmt ident 
reply multi 	may fail sane 
bulk len 	ident test 
reply bulk 	know name 
zfree strcasecmp 	mail pointers least 
cluster 	valid enough 
lookup node 	tests printing unless 
reply error 	user explicitly 
format reply 	request submodule ignore 
error node 	mode passing 
slave reply 	command line option 
error 	ignore changed 
cluster blacklist 	submodule sha comparing 
node cluster 	index parent 
del node 	matter configured otherwise 
cluster sleep 	won commit 
reply strcasecmp 	submodules manually staged 
cluster 	would really 
lookup node 	confusing reject attempt 
reply error 	record non 
format reply 	merge empty 
error node 	commit without allow 
slave reply 	empty cherry 
error 	pick may empty 
node master 	due conflict 
dict size 	resolution user okay 
reply error 	read index 
cluster master 	pre commit hook 
cluster sleep 	could updated 
reply 	write must invoke 
strcasecmp cluster 	editor invoke 
lookup node 	run status check 
reply error 	rest whitespace 
format node 	find message strbuf 
slave reply 	contains whitespace 
error 	lines see user 
reply multi 	edited message 
bulk len 	editor left intact 
cluster gen 	already initialized 
node description 	enumerate needs 
reply bulk 	propagated porcelain effect 
sdsfree 	unspecified sanity 
strcasecmp cluster 	check options oldsha 
lookup node 	newsha nul 
reply error 	hook know editor 
format reply 	launched end 
cluster node 	commit message options 
failure 	end commit 
reports count 	contents options ignore 
strcasecmp strcasecmp 	status everything 
strcasecmp reply 	writing commit includes 
node master 	running hooks 
reply error 	writing trees interacting 
reply 	user determine 
error node 	parents commit message 
failed reply 	truncate message 
error reset 	diff amending current 
manual failover 	head builtin 
mstime server 	commit usage 
log 	builtin status usage 
cluster bump 	ident advice 
config epoch 	noconfig ident advice 
without consensus 	config empty 
cluster failover 	amend advice empty 
replace master 	cherry pick 
server 	advice empty cherry 
log server 	pick advice 
log cluster 	single empty cherry 
send start 	pick advice 
reply strcasecmp 	multi use message 
reply reply 	buffer commit 
error 	editmsg index logfile 
format dict 	force author 
size reply 	file author message 
error reply 	author message 
error server 	buffer edit message 
log cluster 	use message 
sleep 	fixup message 
reply strcasecmp 	squash message also 
strcasecmp strcasecmp 	interactive patch 
reply node 	interactive amend signoff 
master dict 	edit flag 
size reply 	quiet verbose verify 
error 	allow empty 
cluster reset 	dry run renew 
reply reply 	authorship post 
error rio 	rewrite allow empty 
init buffer 	message untracked 
sdsempty server 	files arg force 
rdb 	date ignore 
save type 	submodule arg sign 
server rdb 	commit cleanup 
save sdscatlen 	arg sequencer use 
crc sdslen 	include status 
memrev ifbe 	show ignored 
sdscatlen 	status option include 
crc memrev 	assumed message 
ifbe memcmp 	opt arg unset 
lookup key 	buf err 
read reply 	list prefix pattern 
create 	ret max 
dump payload 	prefix item list 
create reply 	current head 
bulk decr 	opts refresh flags 
count strcasecmp 	argc argv 
reply lookup 	prefix current head 
key 	status pathspec 
write reply 	refresh flags ret 
reply reply 	old index 
error verify 	env index file 
dump payload 	prefix nowarn 
sdslen reply 	sha current head 
error 	buf hack 
rio init 	buf errors 
buffer rdb 	buf val author 
load type 	ident name 
rdb load 	email date author 
reply error 	ident len 
expire 	date buf ident 
mstime signal 	date buf 
modified key 	candidates candidate index 
reply sdsempty 	file prefix 
sdscatlen sdslen 	current head author 
sdscatlen sdscatlen 	ident statbuf 
sdslen 	committer ident commitable 
dict fetch 	hook arg 
sdsfree dict 	hook arg clean 
size dict 	message contents 
random key 	old display comment 
dict val 	prefix ctx 
close 	buffer ctx commit 
zfree dict 	ident shown 
dict key 	saved color 
anet tcp 	setting sha parent 
non block 	diff flags 
connect atoi 	index env start 
sdsfree 	eol tmpl 
reply error 	start name revs 
format anet 	commit buf 
enable tcp 	mailmap ctx name 
delay wait 	enc commit 
sdsfree reply 	show branch use 
sds 	deferred config 
sdsnew close 	argc argv options 
zmalloc dict 	usage prefix 
sdsempty sdscatlen 	current head argc 
sdslen sdscatlen 	argv prefix 
sdscatlen sdslen 	current head commitable 
dict 	index file 
fetch sdsfree 	slot slot name 
close zfree 	slot argc 
dict sdsfree 	argv prefix 
dict safe 	sha builtin status 
iterator dict 	options user 
next 	config xdg config 
dict val 	config exists 
close zfree 	prefix sha initial 
dict dict 	commit rev 
key dict 	commit format junk 
release iterator 	sha head 
strcasecmp 	pctx author ident 
strcasecmp strcasecmp 	committer ident 
sdslen reply 	date status oldsha 
error reply 	newsha buf 
reply reply 	proc argv code 
zrealloc zrealloc 	editor used 
lookup 	index file name 
key read 	hook env 
zfree zfree 	index args ret 
reply sds 	argc argv 
sdsnew migrate 	prefix builtin 
socket zfree 	commit options author 
zfree 	ident index 
rio init 	file reflog msg 
buffer sdsempty 	sha pptr 
server info 	statbuf current head 
rio write 	extra transaction 
bulk count 	err allow fast 
server 	forward parent 
info rio 	saved errno exclude 
write bulk 	gpgsig tail 
server info 	cfg strbuf setlen 
rio write 	strbuf addch 
bulk expire 	strbuf addstr strbuf 
mstime 	complete line 
server info 	file exists git 
rio write 	path merge 
bulk count 	head file 
server info 	exists git path 
rio write 	cherry pick 
bulk 	head file exists 
server info 	git path 
rio write 	status prepare gitmodules 
bulk server 	config git 
info sds 	config determine whence 
encoded server 	rollback file 
info 	rollback file rollback 
rio write 	file commit 
bulk sdslen 	file commit file 
server info 	rollback file 
rio write 	xcalloc common prefix 
bulk create 	overlay cache 
dump 	free path match 
payload server 	list insert 
info rio 	skip worktree report 
write bulk 	path error 
sdslen sdsfree 	free lstat 
server info 	cache die file 
rio 	cache discard 
write bulk 	cache memset parse 
sdslen sync 	indirect die 
write sync 	parse init desc 
read line 	unpack trees 
zmalloc sync 	exit refresh cache 
read 	die resolve 
line reply 	conflict parse pathspec 
error format 	read cache 
signal modified 	preload die hold 
key incr 	locked index 
count create 	refresh cache die 
replace 	write locked 
client command 	index die getenv 
vector zfree 	setenv file 
reply sdsfree 	path interactive die 
zfree zfree 	setenv unsetenv 
zfree migrate 	discard cache 
close 	read cache file 
socket sdsfree 	path update 
migrate close 	main cache reopen 
socket zfree 	file die 
zfree zfree 	write locked index 
reply sds 	die warning 
sdscatprintf 	file path hold 
sdsempty reply 	locked index 
error reply 	files cache refresh 
reply error 	cache die 
reply reply 	update main cache 
keys command 	write locked 
key 	index die file 
hash slot 	path hold 
sdslen keys 	locked index refresh 
free result 	cache die 
equal objects 	cache fully valid 
keys free 	update main 
result 	cache write 
lookup key 	locked index die 
read keys 	rollback file 
free result 	index file die 
node slave 	die list 
reply sds 	init list paths 
sdsnew 	exit discard 
reply sds 	cache read cache 
sdsnew reply 	die hold 
sds sdsnew 	locked index files 
reply sds 	refresh cache 
sdsnew reply 	update main cache 
sds 	write locked 
sdscatprintf sdsempty 	index die hold 
server panic 	file update 
cluster redirect 	git path getpid 
client dict 	create index 
iterator dict 	files refresh 
next 	cache write locked 
dict key 	index die 
key hash 	discard cache file 
slot sdslen 	path read 
cluster redirect 	cache sha status 
client cluster 	collect shortstatus 
redirect 	print porcelain print 
client dict 	die status 
release iterator 	print split ident 
redis cluster 	line die 
implementation copyright 	strbuf addch strbuf 
salvatore sanfilippo 	addf setenv 
antirez 	strbuf release strbuf 
gmail dot 	addch parse 
rights reserved 	date approxidate careful 
redistribution use 	strbuf addf 
source binary 	free xstrdup getenv 
forms without 	xstrdup getenv 
modification 	xstrdup getenv 
permitted provided 	find commit header 
following conditions 	die split 
met redistributions 	ident line die 
source code 	ident xmemdupz 
must retain 	ident xmemdupz strbuf 
copyright 	addch strbuf 
notice list 	strbuf addch strbuf 
conditions following 	ident strbuf 
disclaimer redistributions 	detach split ident 
binary form 	line strlen 
must reproduce 	die ident xmemdupz 
copyright 	ident xmemdupz 
notice list 	parse force date 
conditions following 	die ident 
disclaimer documentation 	strbuf detach strbuf 
materials provided 	addstr fmt 
distribution neither 	ident split ident 
name 	export one 
redis names 	export one 
contributors may 	export one free 
used endorse 	free free 
promote products 	memchr strchr strchr 
derived software 	die determine 
without 	author info run 
specific prior 	commit hook 
written permission 	strcmp strbuf addstr 
software provided 	lookup commit 
copyright holders 	reference name die 
contributors express 	commit output 
implied 	encoding format commit 
warranties including 	message strbuf 
limited implied 	addbuf strcmp isatty 
warranties merchantability 	strbuf read 
fitness particular 	die errno strbuf 
purpose disclaimed 	read file 
shall 	die errno strstr 
copyright owner 	strbuf addstr 
contributors liable 	lookup commit 
direct indirect 	reference name die 
incidental special 	commit output 
exemplary consequential 	encoding format commit 
damages 	message stat 
including limited 	git path merge 
procurement substitute 	msg strbuf 
goods services 	read file git 
loss use 	path merge 
data profits 	msg die errno 
business 	stat git 
interruption however 	path squash msg 
caused theory 	strbuf read 
liability whether 	file git path 
contract strict 	squash msg 
liability tort 	die errno strbuf 
including 	read file 
negligence otherwise 	die errno 
arising way 	fopen writing git 
use software 	path die 
even advised 	errno git path 
possibility damage 	strbuf stripspace 
reference 	append signoff ignore 
handy make 	non trailer 
code clear 	fwrite die errno 
always points 	adjust comment 
server cluster 	line strbuf release 
cluster node 	strbuf addstr 
represents 	git committer info 
node initialization 	status cut 
load cluster 	line status git 
config filename 	path status 
file exist 	status cut line 
zero length 	status status 
may 	split ident split 
happen nodes 	ident ident 
conf file 	cmp status 
create zero 	author date interesting 
length one 	status show 
sake locking 	ident date date 
already 	mode committer 
exist err 	ident sufficiently given 
returned configuration 	status status 
loaded file 	run status read 
returned check 	cache die 
file zero 	sha strcmp index 
length 	differs strbuf 
err signal 	release fclose merge 
write config 	run status 
parse file 	fputs fputs fputs 
note single 	fputs discard 
lines cluster 	cache read cache 
config 	update main 
file really 	cache error run 
include hash 	commit hook 
slots node 	git path 
means worst 	snprintf launch editor 
possible half 	git path 
redis 	exit run commit 
slots present 	hook git 
single line 	path memchr strlen 
possibly importing 	starts isspace 
migrating state 	rest empty strbuf 
together node 	read file 
sender 	strbuf stripspace skip 
receiver simplify 	prefix strbuf 
allocate cluster 	release rest empty 
slots bytes 	init revisions 
per line 	strbuf addf setup 
skip blank 	revisions read 
lines 	mailmap prepare revision 
created either 	walk die 
users manually 	revision strbuf release 
editing nodes 	format commit 
conf config 	message clear 
writing process 	mailmap strbuf detach 
stopped 	die strcmp 
truncate call 	strcmp strcmp die 
split line 	lookup commit 
arguments processing 	reference name die 
handle special 	commit output 
vars line 	encoding logmsg reencode 
pretend 	die parse 
last line 	options finalize deferred 
even actually 	config strchr 
generated redis 	find author nickname 
regular config 	die die 
lines least 	die die die 
eight 	die die 
fields create 	die read commit 
node exist 	message read 
address port 	commit message die 
parse flags 	die strcmp 
nothing master 	strcmp strcmp 
master 	strcmp strcmp die 
populate master 	handle untracked 
slave list 	files arg die 
ping sent 	prepare index 
pong received 	run status rollback 
timestamps config 	index files 
epoch 	strcasecmp strcasecmp strcasecmp 
node populate 	strcasecmp strcasecmp 
hash slots 	strcasecmp strcasecmp strcasecmp 
served instance 	starts git 
handle migrating 	column config strcmp 
importing slots 	git config 
either 	strcmp git config 
config sanity 	strcmp git 
check something 	config strcmp strcmp 
never happen 	git config 
current epoch 	colorbool strcmp 
smaller max 	git config skip 
epoch 	prefix skip 
found nodes 	prefix parse status 
configuration however 	slot config 
handle form 	error nonbool color 
protection manual 	parse strcmp 
editing critical 	git config strcmp 
files 	config error 
cluster node 	nonbool strcmp strcmp 
configuration exactly 	strcmp error 
cluster nodes 	git diff config 
output function 	strcmp usage 
writes node 	options status init 
config 	config parse 
returns error 	options finalize colopts 
returned note 	finalize deferred 
need write 	config handle untracked 
file atomic 	files arg 
way point 	parse pathspec 
view 	read cache preload 
posix filesystem 	refresh index 
semantics server 	hold locked index 
stopped crashes 	sha status 
write end 	collect update index 
either old 	able shortstatus 
file 	print porcelain print 
one since 	die status 
full payload 	print expand user 
write available 	path xdg 
use single 	config home file 
write write 	exists file 
whole 	exists free free 
file pre 	lookup commit 
existing file 	die parse commit 
bigger pad 	die strbuf 
payload newlines 	addstr format commit 
anyway ignored 	message format 
truncate 	commit message 
file afterward 	strbuf cmp strbuf 
nodes description 	addstr strbuf 
concatenate vars 	addbuf percentquote author 
directive save 	date interesting 
current epoch 	format commit message 
last 	strbuf addstr 
vote epoch 	strbuf addbuf percentquote 
pad payload 	strbuf release 
existing file 	committer ident sufficiently 
length greater 	given strbuf 
truncate file 	addstr strbuf addbuf 
needed 	percentquote strbuf 
padding garbage 	addch strbuf addstr 
ftruncate failing 	ident advice 
critical error 	strbuf release strbuf 
cluster config 	release init 
flock leaks 	revisions setup revisions 
file 	commit format 
descritor used 	diff setup 
acquire file 	done resolve strcmp 
locked forever 	skip prefix 
works always 	log commit log 
update nodes 	commit strbuf 
conf 	release strcmp git 
version place 	config pathname 
reopening file 	strcmp git config 
writing place 	strcmp git 
later adjusting 	config strcmp git 
length ftruncate 	config git 
success 	gpg config git 
returned otherwise 	status config 
error logged 	find hook start 
function returns 	command snprintf 
err signal 	sha hex sha 
acquired flock 	hex sigchain 
exist 	push write 
solaris fcntl 	full close sigchain 
solution won 	pop finish 
help constantly 	command snprintf start 
open file 	run hook 
release locks 	end strcmp usage 
anyway 	options status 
need open 	init config sha 
file way 	lookup commit 
created exist 	die parse commit 
otherwise race 	die parse 
condition processes 	validate options dry 
acquired 	run commit 
leak closing 	prepare index prepare 
retain file 	commit rollback 
process exists 	index files getenv 
sun cluster 	commit list 
config file 	insert commit list 
make 	insert fopen 
sure every 	git path 
node uses 	merge head die 
nodes conf 	errno git 
load create 	path merge head 
nodes configuration 	strbuf getline 
configuration 	merge parent die 
found use 	commit list 
random name 	insert fclose strbuf 
provided create 	release stat 
cluster node 	git path merge 
function 	mode strbuf 
need listening 	read file git 
tcp port 	path merge 
cluster messaging 	mode die errno 
needs port 	strcmp reduce 
sanity check 	heads commit list 
handshake 	insert strbuf 
port check 	reset strbuf read 
triggered late 	file git 
stop trying 	path rollback 
use high 	index files die 
cluster port 	strerror status 
number 	truncate message cut 
slots keys 	line strbuf 
map sorted 	stripspace untouched rollback 
init port 	index files 
listening port 	exit message empty 
need discover 	rollback index 
address 	files exit read 
via meet 	commit extra 
messages reset 	headers append merge 
node performing 	tag headers 
soft hard 	commit extended rollback 
reset nodes 	index files 
forget 	die strbuf release 
assigned open 	free commit 
slots released 	extra headers strchr 
node slave 	strbuf setlen 
turns master 	strbuf addch 
hard reset 	strbuf insert strlen 
node 	strbuf insert 
generated hard 	strlen transaction begin 
reset current 	transaction update 
epoch config 	transaction commit rollback 
epoch configuration 	index files 
saved cluster 	die transaction free 
state 	unlink git 
updated node 	path cherry pick 
slave whole 	head unlink 
data flushed 	git path revert 
away turn 	head unlink 
master close 	git path merge 
slots 	head unlink 
reset manual 	git path merge 
failover state 	msg unlink 
unassign slots 	git path 
forget nodes 	merge mode unlink 
hard reset 	git path 
epochs 	squash msg commit 
change node 	index files 
change node 	die rerere run 
need old 	commit hook 
name nodes 	index file init 
table change 	copy notes 
back 	rewrite copy note 
name make 	rewrite finish 
sure persist 	copy notes rewrite 
config update 	run rewrite 
state cluster 	hook print summary 
communication link 	strbuf release 
free 	nada nada nada 
cluster link 	dateptr buf 
free associated 	buf strtoul stop 
node course 	buf format 
function make 	commit parent 
sure original 	parent format commit 
node 	parent parent 
associated link 	make sure shallows 
link field 	read hex 
server starting 	sha clone shallow 
accept cluster 	parent must 
connections update 	traverse real parents 
messages 	even unhide 
may interact 	nothing topological sort 
database content 	support count 
use non 	number children emitted 
blocking cluster 	record author 
messages create 	date commit author 
link 	line malformed 
use handle 	author line malformed 
connection gets 	date newer 
passed readable 	commits larger date 
handler data 	first newer 
available initiallly 	commits larger 
link 	date first performs 
node pointer 	place topological 
know node 	sort list supplied 
right node 	rev sort 
references know 	graph order mark 
node identity 	clear indegree 
key 	also record author 
space handling 	dates needed 
hash slots 	update indegree find 
hash slot 	tips tips 
given key 	nodes reachable node 
obtained least 	list tips 
significant 	serve starting work 
bits crc 	queue unfortunate 
key however 	initial tips need 
key contains 	shown order 
pattern part 	given revision traversal 
hashed may 	machinery longer 
useful 	need commit 
future force 	list parents enqueued 
certain keys 	emission children 
node assuming 	emitted thereby guaranteeing 
resharding progress 	topological order 
start end 	children commit already 
indexes 	emitted emit 
hash whole 	merge stuff remember 
key found 	update flag 
check corresponding 	allocation input commits 
nothing betweeen 	one twos 
hash whole 	must parsed mark 
key 	parents found 
right hash 	merge stale mark 
middle cluster 	even result 
node api 	clean commit may 
create cluster 	ancestor another 
node specified 	commit move commit 
flags 	end number 
nodename considered 	commits independent 
first handshake 	collect result one 
random node 	commit descendant 
name assigned 	one elements commit 
node later 	list commit 
receive 	ancestor one references 
first pong 	commit ancestor 
node created 	reachable reference uniquify 
returned user 	find end 
automatically added 	header dump whole 
nodes hash 	remainder buffer 
table 	dump whole remainder 
function called 	buffer could 
every time 	verify signature either 
failure report 	omit tag 
node side 	validate integrator may 
effect populate 	key signer 
fail 	tag merging 
reports list 	later auditor may 
update timestamp 	auditing run 
existing report 	verify buffer verify 
failing node 	buffer buf 
failure state 	len buf len 
according 	size len 
sender node 	warn warning tag 
function returns 	unverified merge 
updates timestamp 	tag continuation simple 
existing failure 	ascii worries 
report sender 	count many high 
returned 	bits many 
failure report 	bytes sequence must 
created failure 	bytes longer 
report sender 	sequences result codepoints 
already exists 	beyond ffff 
update timestamp 	guaranteed never exist 
otherwise 	many bytes 
create report 	place encoded 
failure reports 	bits bottom compute 
old old 	valid range 
means reasonably 	verify good continuation 
older node 	bytes reject 
timeout 	codepoints range sequence 
note anyway 	length surrogates 
node flagged 	utf cannot encoded 
fail need 	utf fffe 
local pfail 	ffff guaranteed non 
state least 	characters anything 
older 	range fdd fdef 
node timeout 	verifies buffer 
trust number 	proper utf format 
failure reports 	isn assumes 
nodes failing 	non utf characters 
report node 	latin conversion 
previously 	know must range 
considered failing 	commitencoding utf 
sender function 	avoid reallocs 
called node 	headers note ordering 
informs via 	means exact 
gossip node 	merged different order 
point 	parents different 
view fail 	changeset even everything 
pfail flags 	stays person 
note function 	date information comment 
called relatively 	check encoding 
often gets 	append commit end 
called 	commit list 
even nodes 	next starts pointing 
failing however 	variable holds 
cluster fine 	head empty commit 
failure reports 	list updated 
list empty 	point next field 
function 	last item 
runs constant 	list commits appended 
time function 	usage example 
returns failure 	commit list 
report found 	list commit list 
removed otherwise 	next list 
returned 	next commit list 
search failure 	append next 
report sender 	next commit list 
failure report 	append next 
sender failure 	commit list count 
report number 	list list 
external 	inspect determine end 
nodes believe 	log message 
node failing 	order find put 
including node 	line ignored 
may pfail 	trailing comment lines 
fail state 	blank lines 
node 	also traditional conflicts 
well already 	block commented 
slave low 	use git 
level cleanup 	commit amend existing 
node structure 	commit forgot 
called cluster 	returns number bytes 
del 	tail ignore 
node node 	fed second parameter 
associated slaves 	append signoff 
slaves slaveof 	first run comments 
fields unknown 	otherwise continuing 
node list 	pathname conflicts block 
slaves 	previous trailing 
master unlink 	comment builtin git 
nodes release 	commit copyright 
link associated 	kristian gsberg krh 
data structures 	redhat git 
node nodes 	commit junio hamano 
hash 	linus torvalds 
table node 	real index used 
cluster functio 	commits message 
performs high 	variables commit 
level cleanup 	names take commit 
calling free 	message authorship 
cluster 	unspecified commit message 
node low 	cleanup mode 
level cleanup 	lines beginning shell 
following mark 	comments leading 
slots handled 	trailing whitespaces empty 
unassigned failure 	lines containing 
reports 	whitespaces editor used 
sent node 	whitespaces message 
referenced nodes 	specified explicitly must 
free node 	come git 
free cluster 	config nothing nothing 
node turn 	take paths 
hash 	index named typically 
table list 	head paths 
slaves master 	match given pattern 
slave node 	list better 
mark slots 	valid pointer 
unassigned failure 	fake one skip 
reports 	worktree already 
free node 	reported error finish 
unlinking cluster 	dying refresh 
node lookup 	flags contains refresh 
name used 	quiet errors 
handshake connect 	unmerged entries non 
given 	non commit 
port result 	real index update 
cluster meet 	index necessary 
node name 	write index real 
yet pick 	index still 
random one 	locked name locked 
fix 	index file 
receive pong 	caller run hooks 
request function 	locked real 
cluster config 	index goes well 
epoch handling 	commit real 
greatest config 	index failure 
epoch 	rollback real index 
found cluster 	commit name 
current epoch 	real index file 
greater node 	caller run 
config epoch 	hooks real index 
node epoch 	create commit 
zero 	index still need 
already greatest 	refresh index 
across cluster 	commit find affected 
pov local 	paths real 
configuration function 	index file update 
generate config 	index given 
epoch 	paths write index 
incrementing current 	real index 
epoch assign 	still locked index 
epoch node 	file reset 
without consensus 	index head 
persist configuration 	update index way 
disk 	write index 
sending packets 	index file name 
configuration config 	index file 
epoch generated 	still locked caller 
assigend returned 	run hooks 
otherwise err 	locked index create 
returned 	commit goes 
since node 	well commit real 
already greatest 	index failure 
configuration around 	rollback real index 
operation performed 	either rollback 
important note 	index checks barfs 
function 	author badly 
violates principle 	specified insert proper 
config epochs 	subject line 
generated consensus 	commit message options 
unique across 	content remaining 
cluster however 	cases modify 
redis 	message argument prepare 
cluster uses 	commit msg 
generated config 	hook squash commit 
epochs two 	used commit 
cases slots 	subject possibly hijacking 
closed importing 	commit log 
otherwise 	options reset hook 
resharding would 	args tell 
expansive cluster 	real story ignore 
failover called 	status display 
options force 	comment prefix need 
slave failover 	comments commit 
master 	editmsg hints counter 
even master 	productive commit 
majority able 	already started checks 
create configuration 	committer ident 
epoch redis 	explicitly given cleanup 
cluster explode 	space never 
function 	fail come 
even collision 	fmt ident may 
node another 	fail sane 
node generating 	ident test know 
configuration epoch 	name mail 
unilaterally config 	pointers least valid 
epoch 	enough tests 
conflict resolution 	printing unless user 
algorithm eventually 	explicitly request 
move colliding 	submodule ignore mode 
nodes different 	passing command 
config epochs 	line option ignore 
however 	changed submodule 
function may 	sha comparing index 
violate last 	parent matter 
failover wins 	configured otherwise won 
rule used 	commit submodules 
care function 	manually staged would 
called 	really confusing 
node master 	reject attempt 
receive another 	record non merge 
master configuration 	empty commit 
epoch equal 	without allow empty 
configuration epoch 	cherry pick 
background 	may empty due 
possible different 	conflict resolution 
slaves config 	user okay read 
epoch failover 	index pre 
election slaves 	commit hook could 
need voted 	updated write 
majority 	must invoke editor 
however perform 	invoke run 
manual resharding 	status check rest 
cluster node 	whitespace find 
assign configuration 	message strbuf contains 
epoch without 	whitespace lines 
ask 	see user edited 
agreement usually 	message editor 
resharding happens 	left intact 
cluster working 	already initialized enumerate 
well supervised 	needs propagated 
sysadmin however 	porcelain effect unspecified 
possible 	sanity check 
failover happen 	options oldsha newsha 
exactly node 	nul hook 
resharding slot 	know editor launched 
assigns configuration 	end commit 
epoch able 	message options end 
propagate 	commit contents 
technically possible 	options ignore status 
condition two 	everything writing 
nodes end 	commit includes running 
configuration epoch 	hooks writing 
another possibility 	trees interacting user 
bugs 	determine parents 
implementation causing 	commit message 
happen moreover 	truncate message diff 
cluster created 	amending current 
nodes start 	head commit.h item 
config epoch 	next index 
collision 	date parents save 
resolution code 	commit buffer 
allows nodes 	commit type next 
automatically end 	type name 
different config 	name decoration obj 
epoch startup 	sha sha 
automatically 	sha quiet name 
cases want 	sha name 
mechanism resolves 	item buffer size 
issue automatically 	item quiet 
safeguard configuration 	missing item item 
epoch masters 	commit buffer 
serving 	size commit size 
different slots 	commit size 
harmful nodes 	commit buffer 
end serving 	commit commit sizep 
slots reason 	commit buffer 
manual errors 	subject item list 
software 	commit next 
bugs without 	item list list 
proper failover 	list list 
procedure general 	abbrev subject subject 
want system 	preserve subject 
eventually always 	date mode need 
ends 	bit cte 
different masters 	notes message reflog 
different configuration 	info output 
epochs whatever 	encoding mailmap color 
happened since 	ident body 
nothign worse 	headers text commit 
split 	commit encoding 
brain condition 	output encoding arg 
distributed system 	rev info 
behavior function 	msg line 
gets called 	separator fmt commit 
happens node 	format empty 
lexicographically 	heads next key 
smaller node 	len parents 
compared node 	tail msg msg 
conflicting epoch 	len parents 
sender node 	ret author sign 
assign greatest 	commit msg 
configuration 	msg len parents 
epoch currently 	ret author 
detected among 	sign commit commit 
nodes plus 	extra header 
means even 	commit extra msg 
multiple nodes 	key len 
colliding 	commit data obj 
node greatest 	name name 
node never 	commit message signature 
moves forward 	buf list 
eventually nodes 	format cur 
end 	format last commit 
different configuration 	sigc unused 
epoch prerequisites 	editor used index 
nodes config 	file name 
epoch masters 	parse commit gently 
act colliding 	decorate name 
node 	used commits look 
smaller node 	named sha 
next available 	dereference tag necessary 
best node 	commit sha 
knowledge cluster 	dereference commit use 
nodes blacklist 	name report 
nodes 	error die associate 
blacklist way 	buffer commit 
ensure given 	ownership memory handed 
node given 	commit must 
node readded 	free able 
time elapsed 	cached buffer associated 
time 	commit returns 
specified seconds 	none resulting memory 
cluster blacklist 	freed commit 
ttl useful 	contents either cache 
want node 	reading disk 
cluster completely 	resulting memory modified 
cluster 	must given 
forget called 	unuse commit buffer 
also puts 	caller done 
node blacklist 	tell commit subsytem 
even receive 	done particular 
gossip messages 	commit buffer commit 
nodes 	buffer input 
still remember 	respectively earlier call 
node want 	commit buffer 
time currently 	buffer may may 
cluster blacklist 	freed call 
ttl minute 	callers access 
means 	memory afterwards free 
redis trib 	cached buffer 
seconds send 	associated commit disassociate 
cluster forget 	cached buffer 
messages nodes 	commit free buffer 
cluster without 	none returned 
dealing 	find beginning length 
problem nodes 	commit subject 
adding back 	shallow copy input 
node nodes 	list commit 
already sent 	formats callers tweak 
forget command 	change behavior 
data 	functions fields manipulated 
structure used 	internally functions 
hash table 	counted callers revision 
sds representing 	circularly uses 
node key 	cmit fmt removes 
time node 	first commit 
minute 	list sorted 
node exists 	date adds parents 
operations always 	performs place 
expired entries 	topological sort list 
black list 	supplied invariant 
operation problem 	resulting list reachable 
since 	ord ord 
exists operations 	sort order specifies 
called infrequently 	rev sort 
hash table 	graph order show 
supposed contain 	commit single 
little elements 	parent chain together 
max 	rev sort 
however without 	commit date show 
cleanup uptimes 	eligible commits 
automated node 	committer date order 
removal procedures 	shallow commit 
entries could 	used flags call 
accumulate 	longer matter 
cleanup blacklist 	largest positive 
node black 	number bit integer 
list key 	contain receive 
added duplicate 	pack search commit 
sds representation 	contents given 
key 	msg header key 
next lookup 	returns pointer 
free end 	start header contents 
non zero 	length header 
specified node 	first newline returned 
exists blacklist 	via len 
need 	note headers like 
pass sds 	mergetag may 
pointer bytes 	multi line caller 
work cluster 	responsibility parse 
messages exchange 	find end log 
ping pong 	message right 
gossip 	place trailer 
function checks 	named could tag 
given node 	given name 
marked fail 	command line merge 
happens following 	find commit 
conditions met 	storing merge remote 
received 	desc field 
enough failure 	allow callers tell 
reports master 	told merge 
nodes via 	tag check signature 
gossip enough 	given commit 
means majority 	result check stored 
masters 	sig check 
signaled node 	result good signature 
recently believe 	good signature 
node pfail 	untrusted signer bad 
state failure 	signature signature 
detected also 	may allocate memory 
inform 	sig gpg 
whole cluster 	output sig 
trying force 	gpg status sig 
every node 	signer sig 
fail flag 	key commit config.c 
node note 	prev file 
form 	buf len pos 
agreement used 	origin type 
weak collect 	name path die 
majority masters 	error linenr 
state time 	eof conf zlib 
even force 	compression seen 
agreement 	config conf conf 
propagating fail 	conf conf 
message partitions 	conf conf include 
may reach 	depth advice 
every node 	path inc ret 
however either 	buf expanded 
reach 	slash data inc 
majority eventually 	ret text 
fail state 	env old 
propagate cluster 	text data pair 
majority slave 	data env 
promotion authorized 	envw argv alloc 
fail 	space data 
flag cleared 	name ret name 
time reach 	name data 
already fai 	comment baselen bomptr 
ling also 	end val 
count voter 	ret max end 
master 	val uval 
weak agreement 	factor ret max 
masters mark 	end val 
node failing 	oldval ret tmp 
broadcast failing 	ret tmp 
node name 	ret tmp name 
everybody 	reason name 
forcing reachable 	ret name ret 
nodes flag 	name ret 
node fail 	name name 
function called 	name discard dest 
node marked 	dest abbrev 
fail 	level level pgsz 
able reach 	dummy top 
checks conditions 	data ret origin 
undo fail 	type name 
state slaves 	path data top 
always clear 	data filename 
fail 	data ret origin 
flag contact 	type name 
node master 	buf len data 
fail state 	top name 
old enough 	sha data buf 
yet serving 	size ret 
slots 	name data sha 
point view 	system wide 
failed apparently 	def val data 
one going 	repo config 
fix slots 	found xdg 
clear fail 	config user config 
flag 	data config 
already node 	source respect includes 
handshake state 	repo config 
matching specified 	ret inc data 
address port 	data index 
number function 	values entry list 
used 	info data 
order avoid 	key found entry 
adding handshake 	normalized key 
node address 	ret key item 
multiple times 	info unused 
start handshake 	entry iter key 
specified 	filename key 
address one 	values key key 
already progress 	dest key 
returns non 	dest key 
zero handshake 	dest key dest 
actually started 	key dest 
error 	key dest key 
zero returned 	dest key 
errno one 	dest key key 
following values 	key dest 
eagain already 	ret key dest 
handshake progress 	key dest 
address 	key dest key 
einval port 	dest key 
valid sanity 	dest key dest 
check port 	key dest 
sanity check 	ret val key 
norm normalized 	filename linenr 
representation 	git die config 
node address 	baselen key 
node random 	match regex multi 
address first 	replace offset 
argument create 	offset alloc 
cluster node 	seen key key 
everything 	section len 
handshake process 	filename key dot 
gossip section 	success key 
ping pong 	success length quote 
packets note 	contents size 
function assumes 	offset found bracket 
packet 	bracket offset 
already sanity 	offset config filename 
caller content 	key config 
gossip section 	filename key key 
length update 	key key 
state accordingly 	store key baselen 
gossip 	quiet dot 
sections already 	baselen last dot 
know node 	key store 
handle failure 	key baselen key 
reports sender 	config filename 
master already 	key regex 
know 	multi replace ret 
node reachable 	filename buf 
see different 	contents contents copy 
address gossip 	begin copy 
section node 	end line config 
talk node 	filename key 
update 	regex multi replace 
address disconnect 	key regex 
old link 	multi replace key 
attempt connect 	regex multi 
address noaddr 	replace buf name 
state start 	dot name 
handshake 	config filename old 
process port 	name name 
pairs note 	filename buf buf 
require sender 	config file 
gossip message 	length output offset 
well known 	old name 
node 	name section 
cluster otherwise 	subsection subsection len 
risk joining 	key section 
another cluster 	len dot getc 
next node 	unlocked ungetc 
conversion buf 	ftell die config 
supposed 	error nonbool 
least bytes 	expand user path 
update node 	error absolute 
address address 	path error find 
extracted link 	last dir 
specified port 	sep strbuf strbuf 
also 	addstr access 
disconnect node 	die die git 
link connect 	config file 
address port 	strbuf release free 
pair already 	strcmp handle 
correct operation 	path include 
performed 	getenv strbuf addstr 
function returns 	strbuf addch 
node address 	quote buf setenv 
still otherwise 	strbuf release 
returned proceed 	strbuf split str 
link sender 	error strbuf 
link 	setlen strbuf trim 
function designed 	strbuf list 
see node 	free error strbuf 
link consistent 	tolower strbuf 
symmetric link 	list free strbuf 
used receive 	list free 
pin 	getenv xstrdup dequote 
node side 	argv free 
effect function 	error git config 
never frees 	parse parameter 
passed link 	free free free 
safe call 	free fgetc 
packet 	fgetc ungetc 
processing port 	strbuf reset next 
different update 	isspace strbuf 
check master 	addch next strbuf 
change replication 	addch strbuf 
target well 	addch isalnum next 
reconfigure 	iskeychar strbuf 
specified node 	addch tolower next 
master function 	parse isspace 
called node 	next strbuf addch 
believed slave 	next next 
acting master 	strbuf addch next 
order 	next isspace 
update state 	extended iskeychar strbuf 
node update 	addch tolower 
config state 	next isspace strbuf 
function called 	reset strbuf 
receive master 	addch isalpha strbuf 
configuration 	setlen strbuf 
via ping 	addch tolower 
pong update 	die error strcasecmp 
packet receive 	strcasecmp strcasecmp 
node config 	strtoimax parse unit 
epoch node 	factor labs 
slots 	labs strtoumax parse 
claimed config 	unit factor 
epoch rebind 	git parse maximum 
slots newer 	type git 
configuration compared 	parse maximum type 
local configuration 	git parse 
needed 	maximum type die 
turn ourself 	die git 
replica node 	parse die bad 
see function 	number git 
comments info 	parse die bad 
sender node 	number git 
received 	parse die bad 
configuration update 	number strcasecmp 
sometimes actually 	strcasecmp strcasecmp 
sender information 	strcasecmp strcasecmp strcasecmp 
like receive 	git parse 
info via 	maybe git parse 
update 	git parse 
packet dirty 	maybe git config 
slots list 	git config 
list slots 	config error nonbool 
lose ownership 	xstrdup config 
still keys 	error nonbool expand 
inside 	user path 
usually happens 	die strcmp git 
failover manual 	config strcmp 
cluster reconfiguration 	git config strcmp 
operated admin 	strcasecmp strcasecmp 
update message 	strcmp git config 
able 	strcmp git 
demote master 	config strcmp 
slave resync 	git config strcmp 
master updating 	git config 
whole key 	pathname strcmp git 
space need 	config strcmp 
keys 	git config strcmp 
slots lost 	git config 
ownership curmaster 	strcmp git config 
node node 	strcmp git 
node replicates 	config strcmp git 
slave loop 	config strcmp 
interested 	git config die 
check slots 	strcmp git 
taken away 	config die strcmp 
curmaster slot 	getpagesize git 
already bound 	config strcmp git 
sender message 	config strcmp 
slot 	git config strcmp 
importing state 	git config 
modified manually 	strcmp strcasecmp 
via redis 	error git config 
trib example 	strcmp strcasecmp 
resharding progress 	git config strcmp 
migrating 	strcasecmp strcasecmp 
side slot 	strcasecmp error strcmp 
already closed 	xstrdup strcmp 
advertising config 	git config strcmp 
still want 	git config 
slot closed 	strcmp config error 
manually 	nonbool strcasecmp 
rebind slot 	error strcmp git 
node claiming 	config strcmp 
slot unassigned 	git config pathname 
node claims 	strcmp config 
greater config 	error nonbool parse 
epoch 	whitespace rule 
currently importing 	strcmp git config 
slot slot 	strcmp git 
mine still 	config strcmp 
contains keys 	strcmp strcmp die 
mark dirty 	strcmp git 
slot 	config strcmp git 
least one 	config strcmp 
slot reassigned 	git config strcmp 
node another 	git config 
node greater 	strcmp git config 
config epoch 	strcmp git 
possible 	config strcmp strcasecmp 
master left 	git config 
without slots 	strcmp config error 
means failed 	nonbool strcmp 
turn replica 	strcmp strcmp strcmp 
master slave 	error strcmp 
master 	config error nonbool 
left without 	strcmp strcmp 
slots need 	strcmp strcmp strcmp 
replicate slots 	strcmp error 
owner received 	error strcmp 
update message 	git config pathname 
removed 	strcmp git 
ownership certain 	config starts git 
slots still 	core config 
keys still 	starts git ident 
serving slots 	config starts 
master node 	git config starts 
demoted 	git branch 
slave order 	config starts git 
maintain consistent 	push config 
state keys 	starts git mailmap 
slots need 	config starts 
keys slots 	git advice config 
lost 	strcmp strcmp 
function called 	git config strcmp 
packet process 	git config 
starting node 	strbuf init strbuf 
rcvbuf releasing 	init git 
buffer caller 	parse source 
function 	strbuf release strbuf 
handle higher 	release config 
level stuff 	config file fopen 
processing packet 	flockfile config 
modifying cluster 	file funlockfile fclose 
state needed 	config read 
function 	sha file error 
returns link 	free error 
still valid 	git config mem 
packet processed 	free sha 
otherwise link 	error git config 
freed since 	blob sha 
packet 	system path getenv 
processing lead 	git config 
inconsistency error 	getenv git parse 
instance pong 	die git 
received wrong 	env xdg 
sender perform 	config home expand 
sanity 	user path 
checks least 	git config system 
signature version 	access die 
totlen count 	git etc gitconfig 
handle messages 	git config 
different 	file git etc 
versions expected 	gitconfig access 
length packet 	die git config 
check sender 	file access 
known node 	die git config 
update curret 	file access 
epoch 	die git config 
see newer 	file git 
epoch cluster 	config parameters die 
update sender 	free free 
config epoch 	git config stdin 
publishing newer 	git config 
one 	file git 
update replication 	config blob git 
offset info 	pathdup git 
node slave 	config early free 
performing manual 	git config 
failover master 	options die git 
sent 	die config 
offset already 	linenr git config 
paused populate 	check init 
state initial 	configset iter git 
processing ping 	config parse 
meet requests 	key hashmap entry 
replying 	init strhash 
pong use 	hashmap free xmalloc 
incoming meet 	configset find 
messages order 	element xmalloc hashmap 
address since 	entry init 
cluster nodes 	strhash xstrdup list 
send 	init hashmap 
meet messagses 	list append 
handshakes cluster 	nodup xstrdup alloc 
joins later 	grow strintern 
changed address 	strcmp hashmap init 
nodes use 	hashmap iter 
official 	init hashmap iter 
address connect 	next free 
obtaining address 	list clear hashmap 
socket simple 	free free 
way discover 	configset git config 
update address 	file git 
cluster 	configset multi configset 
without hardcoded 	find element 
config however 	git configset git 
address update 	config git 
address even 	configset git configset 
normal ping 	git config 
packet 	git configset git 
wrong meet 	config git 
later node 	configset git 
msg type 	config git configset 
meet stage 	git config 
node right 	git configset git 
flags 	config maybe 
slaveof pointer 	git configset git 
forth details 	config pathname 
resolved receive 	git configset init 
pon node 	git config 
meet packet 	raw git configset 
unknown 	clear git 
node still 	config check init 
process gossip 	git configset 
section since 	git config check 
trust sender 	init git 
message type 	configset multi git 
anyway 	config check 
reply pong 	init git 
ping pong 	configset git die 
meet process 	config git 
config information 	config check init 
already node 	git config 
change 	git config check 
port node 	init git 
one free 	configset git config 
node already 	check init 
cause link 	git configset git 
freed well 	config check 
first 	init git configset 
thing replacing 	git config 
random name 	check init git 
right node 	configset git 
name handshake 	config check init 
stage reply 	git configset 
non 	maybe git config 
matching node 	check init 
disconnect node 	git configset 
associated address 	pathname git die 
update node 	config git 
address changed 	config maybe git 
update 	config strcasecmp 
info node 	error die die 
pfail condition 	strcmp regexec 
reversed without 	matches warning alloc 
external help 	grow ftell 
momentary turn 	strrchr memcmp alloc 
fail 	grow ftell 
state fail 	matches alloc grow 
condition also 	ftell strrchr 
reversible specific 	strncmp alloc grow 
conditions detected 	ftell error 
clear node 	memchr strbuf addf 
failure 	strbuf addch 
needed check 	strbuf addch strbuf 
role slave 	addstr strbuf 
master master 	addf write 
slave node 	full strbuf release 
master node 	strlen strbuf 
slave 	addf strbuf addstr 
master turned 	strbuf addstr 
slave reconfigure 	strbuf addch strbuf 
node update 	addch strbuf 
config state 	addf write full 
master node 	strbuf release 
changed 	git config multivar 
slave update 	file gently 
config update 	git config multivar 
info served 	file git 
slots note 	config multivar gently 
must happen 	git config 
update 	multivar strrchr error 
master slave 	error xmallocz 
state cluster 	strlen iskeychar isalpha 
node master 	error tolower 
flag many 	error free 
checks needed 	git config parse 
served 	key git 
slots instance 	config parse key 
claims different 	git config 
compared slots 	parse key git 
check asap 	pathdup xcalloc 
avoid computational 	hold file update 
expansive 	error strerror 
checks later 	free open free 
sender master 	error strerror 
slave sender 	store write section 
claimed slots 	store write 
match view 	pair xmalloc regcomp 
sender 	error free 
message master 	alloc grow git 
detected slots 	config file 
claims changed 	error free 
scan slots 	regfree free free 
see need 	regfree free 
update 	fstat xsize xmmap 
configuration also 	gently isdir 
check reverse 	error strerror close 
condition sender 	chmod file 
claims serve 	path error file 
slots know 	path strerror 
served 	find beginning line 
master greater 	write full 
config epoch 	write str full 
happens inform 	store write 
sender useful 	section store write 
sometimes partition 	pair write 
heals 	full munmap commit 
reappearing master 	file error 
may last 	strerror git config 
one claim 	clear rollback 
given hash 	file free 
slots configuration 	munmap close write 
instances 	error file 
know deprecated 	path git config 
example master 	multivar file 
slave slots 	gently die git 
partitioned away 	config multivar 
gets promoted 	file gently git 
partitioned 	config multivar 
away returns 	file isspace isspace 
available usually 	isspace isspace 
would ping 	isalnum section name 
publishing served 	error git 
slots config 	pathdup xcalloc hold 
epoch 	file update 
partition inform 	error fopen fstat 
configuration nodes 	fileno chmod 
updated table 	file path error 
must way 	file path 
stop act 	strerror fgets 
master 	isspace section name 
failover conditions 	match strlen 
win election 	store write section 
todo instead 	write error 
exiting loop 	file path strlen 
send every 	strlen write 
update 	full write error 
packet nodes 	file path 
owner sender 	fclose commit file 
slots config 	error strerror 
epoch collides 	free git config 
sender fix 	rename section 
problem 	file error strlen 
info gossip 	starts strrchr 
section bother 	git information manager 
creating useless 	hell copyright 
objects pub 	linus torvalds copyright 
sub subscribers 	johannes schindelin 
know 	config contains 
node know 	key pairs usual 
node consider 	config config 
vote sender 	files repo specific 
master serving 	git config 
non zero 	user wide gitconfig 
number 	xdg config 
slots current 	file etc gitconfig 
epoch greater 	use absolute 
equal epoch 	path interpret relative 
node started 	paths including 
election maybe 	config file pass 
reached 	along values 
quorum flag 	including include directives 
make sure 	makes possible 
check asap 	query information includes 
message acceptable 	dequote write 
master sender 	dos like systems 
one 	characters escape 
slaves manual 	reject unknown 
failover requested 	escape sequences full 
slaves initialize 	name already 
state accordingly 	consumed need linenr 
node update 	point line 
know 	parsed call accurate 
sender know 	line number 
reported node 	error messages require 
nothing current 	format extension 
config node 	feff order mark 
slave master 	utf file 
update 	beginning skip utf 
node config 	encoded bom 
epoch check 	present sane editors 
bitmap served 	won put 
slots update 	windows notepad happily 
config accordingly 	tolerate bom 
function 	bom file 
called detect 	beginning cool reset 
link node 	prior determining 
lost node 	stem truncate name 
longer connected 	back section 
cluster cron 	header stem prior 
detect 	grabbing suffix 
connection connected 	part name needs 
instead node 	better name 
temporary node 	must multiple pagesize 
used accept 	config variables 
query completely 	documentation config txt 
free 	config variables 
node error 	documentation config txt 
send data 	config variables 
handled trivial 	documentation config txt 
send buffer 	deprecated config 
gets consumed 	variables documentation config 
write 	txt config 
optimize speed 	variables documentation 
much low 	config txt config 
traffic channel 	variables documentation 
read data 	config txt source 
read first 	specific fields 
field 	die error name 
header first 	callbacks fgetc 
check full 	ungetc ftell top 
length packet 	need initialized 
whole packet 	calling function push 
memory function 	config file 
call 	parsing state stack 
function process 	pop config 
packet forth 	file parsing state 
read data 	stack parse 
read first 	environment variable various 
obtain first 	possible spellings 
bytes 	missing use def 
full message 	parse environment 
length read 	variable possibly 
full message 	unit suffix missing 
perform sanity 	use val 
check message 	error found nothing 
signature 	found least 
length data 	one item specific 
ready error 	filename use 
read data 	otherwise follow regular 
recast pointer 	lookup sequence 
buffer total 	git config options 
length 	normally returns 
obtained process 	positive values errors 
packet link 	fatal non 
longer valid 	fatal potential errors 
put stuff 	guarded statements 
send buffer 	entered error possible 
guaranteed 	ever encounter 
function never 	non fatal error 
side effect 	means something 
link invalidated 	went really 
safe call 	wrong stop immediately 
function handlers 	key may 
stuff 	come user normalize 
link later 	querying entries 
send message 	hashmap since keys 
nodes part 	fed git 
cluster connected 	config callback mechanism 
link guaranteed 	already normalized 
function 	simply without munging 
never side 	values read 
effect node 	git config parameters 
link invalidated 	follows last 
safe call 	one wins semantic 
function handlers 	multiple matches 
stuff 	queried key files 
node links 	configset returned 
later build 	last list 
message header 	key hack test 
hdr must 	programs like 
point buffer 	test dump untracked 
least 	cache find 
cluster msg 	stuff git config 
bytes node 	always matches 
master send 	never matches looking 
slots bitmap 	store key 
config epoch 	section section part 
node 	baselen found 
slave send 	key section would 
master information 	want know 
instead node 	key section looking 
flagged slave 	already know 
receiver knows 	section hold store 
really 	key increment 
charge slots 	matches match made 
current epoch 	sure desired 
config epochs 	section fallthru 
replication offset 	error code failed 
message flags 	rename check 
compute 	see needs surrounded 
message length 	pair note 
certain messages 	problematic characters always 
messages caller 	backslash quoted 
ping pong 	check losing leading 
meet fixing 	trailing follow 
totlen 	beginning comment characters 
field caller 	configuration parser 
send ping 	auxiliary function sanity 
pong packet 	check split 
specified node 	key section variable 
making sure 	name returns 
enough 	success invalid character 
gossip informations 	key section 
number gossip 	name key store 
sections added 	key pointer 
far number 	hold copy 
gossip sections 	key lowercase section 
want 	variable name 
append possible 	baselen pointer hold 
total packet 	length section 
length freshnodes 	subsection part since 
max number 	key actually 
nodes hope 	contains section name 
append 	real key 
nodes available 	name separated dot 
minus two 	know dot 
ourself node 	validate key lower 
sending message 	matching extended 
however practically 	basename untouched unset 
may 	config regex 
less valid 	disregard key pairs 
nodes since 	match regex 
nodes handshake 	config regex none 
state disconnected 	match existing 
considered many 	values one 
gossip 	multi replace nothing 
sections want 	one matching 
number nodes 	key replaced matching 
anyway least 	key values 
masters entries 	regardless many removed 
consider node 	pair written 
timeout 	returns success function 
exchange node 	locks config 
least packets 	file creating git 
ping worst 	config parses 
node timeout 	config store aux 
time also 	validator find 
receive 	position key pair 
two pings 	replace unset 
host total 	must found exactly 
packets node 	config file 
timeout falure 	mmap part 
reports validity 	match written file 
time 	changed part 
single pfail 	rest config file 
node expect 	removed file 
receive following 	rename parse key 
number failure 	returns negative 
reports specified 	flip sign feed 
window 	exit serves 
time prob 	purpose addition locking 
gossip entries 	contents git 
per packet 	config written git 
total packets 	config exist 
prob probability 	yet write minimal 
featured 	version invalid 
single gossip 	config file nothing 
entry num 	unset error 
nodes entries 	store offset contain 
total packets 	end offset 
num masters 	last match 
masters 	remain match found 
num nodes 	side effect 
num masters 	make sure transform 
always majority 	valid existing 
specifically number 	config file nothing 
nodes account 	unset many 
many 	matches error write 
masters failing 	first part 
time since 	config write pair 
non voting 	means unset 
slaves lower 	write rest config 
probability entry 	committed roll 
feature 	back note since 
node number 	lockfile keeps 
entires per 	linked list created 
packet total 	file structures 
nodes compute 	isn safe free 
maxium totlen 	better hanging 
allocate 	around invalidate 
buffer fix 	config cache nothing 
totlen later 	nothing match 
according number 	find right length 
gossip sections 	offset gobbling 
really able 	whitespace well nothing 
put 	empty section 
inside packet 	names bogus dot 
note cluster 	must alphanumeric 
build message 	dash first dot 
hdr expects 	anything goes 
buffer always 	stop checking name 
least 	section removed 
cluster msg 	instead config file 
populate header 	means nothing 
populate gossip 	rename error nothing 
fields include 	section wrote 
node 	section newline skip 
whole packet 	old section 
header already 	length content 
gossip nodes 	means declaration put 
give bias 	next line 
fail pfail 	indent tab call 
nodes 	report error 
gossip section 	variable means start 
include nodes 	section find 
handshake state 	key know yet 
nodes noaddr 	subsection must 
flag disconnected 	parse backwards end 
nodes 	since subsection 
configured slots 	may dots subsection 
tecnically correct 	use fwrite 
saves cpu 	buf contain end 
check already 	show key 
added node 	name back delimiter 
ready 	needswork naive 
send fix 	pattern lowercasing obviously 
totlen fiend 	work complex 
queue message 	patterns like 
output buffer 	foo bar perhaps 
send pong 	deprecate altogether 
packet 	someday normalization type 
every connected 	path path 
node handshake 	like foobar prefer 
state valid 	store foobar 
link redis 	config file expand 
cluster pongs 	retrieving none 
used 	found config unknown 
failure detection 	home gitconfig 
also carry 	exists know write 
important configuration 	xdg location 
information broadcasting 	error even xdg 
pong useful 	config home 
something 	points sane location 
changes configuration 	builtin config 
want make 	usage key 
cluster aware 	key regexp regexp 
asap instance 	show keys 
slave promotion 	omit values use 
target 	key regexp 
argument specifies 	match delim key 
receiving instances 	delim term 
defines cluster 	use config use 
broadcast known 	system config 
instances cluster 	use local config 
broadcast 	given config 
local slaves 	source actions types 
slaves master 	color slot 
slaves ring 	colorbool slot end 
send publish 	respect includes 
message link 	show origin builtin 
message 	config options 
broadcasted whole 	argc min max 
cluster use 	buf term 
local buffer 	key buf 
possible send 	items alloc buf 
fail message 	key key 
nodes 	values key regex 
able contact 	ret values 
fail message 	buf key color 
sent detect 	found color 
node failing 	slot colorbool slot 
cluster node 	parsed color 
pfail 	def color colorbool 
also receive 	found diff 
gossip confirmation 	color found color 
node state 	found print 
cluster node 	values item matched 
fail ask 	url section 
nodes 	tail item config 
asap send 	values matched 
update message 	buf buf argc 
specified link 	argv prefix 
carrying specified 	nongit user 
node slots 	config xdg config 
configuration 	config file 
node name 	content ret ret 
slots bitmap 	ret error 
config epoch 	usage options strbuf 
info included 	addstr current 
cluster pub 	config origin type 
sub 	strbuf addch 
support little 	strbuf addstr current 
propagating publish 	config name 
messages across 	quote style current 
whole cluster 	config name 
future smarter 	strbuf addch show 
avoiding 	config origin 
propagating messages 	fwrite strbuf release 
hosts without 	show config 
receives given 	origin strbuf addstr 
channel slave 	strbuf addch 
node specific 	strbuf addf 
functions 	git config strbuf 
function sends 	addstr git 
failove auth 	config git config 
request message 	strbuf addstr 
every node 	strbuf addf git 
order see 	config pathname 
quorum 	strbuf addstr free 
slave instance 	strbuf addstr 
failover failing 	strbuf setlen strbuf 
master note 	addch strcmp 
send failover 	regexec regexec alloc 
request everybody 	grow strbuf 
master 	init format config 
slave nodes 	xstrdup strlen 
masters supposed 	tolower tolower xmalloc 
reply query 	regcomp error 
manual failover 	free git 
clustermsg flag 	config parse key 
forceack 	xmalloc regcomp 
bit header 	error free git 
communicate nodes 	config options 
receiving message 	fwrite strbuf release 
authorized failover 	free free 
even master 	regfree free regfree 
working 	free xstrdup 
send failover 	xstrfmt git config 
auth ack 	xstrdup git 
message specified 	config git config 
node send 	xstrfmt xstrdup 
mfstart message 	die strcmp config 
specified 	error nonbool 
node vote 	color parse git 
node asking 	config options 
vote conditions 	color parse die 
master serving 	fputs strcmp 
least slot 	git config 
right 	colorbool strcmp git 
vote cluster 	config colorbool 
size redis 	strcmp git config 
cluster number 	colorbool git 
masters serving 	config options strcmp 
least one 	want color 
slot 	die die die 
quorum cluster 	list insert 
size request 	xmalloc strbuf init 
epoch must 	strbuf reset 
current epoch 	strbuf addstr url 
note impossible 	normalize die 
actually 	xstrdup tolower strchr 
greater since 	git config 
current epoch 	options format config 
updated side 	fwrite strbuf 
effect receiving 	release strbuf release 
request request 	list clear 
epoch 	list clear 
greater already 	free free strbuf 
voted epoch 	addf ident 
asap node 	name ident email 
must slave 	strbuf detach 
master master 	getenv parse options 
non 	error usage 
failing request 	options strcmp expand 
flagged clustermsg 	user path 
flag forceack 	xdg config home 
manual failover 	die access 
voted slave 	warn access warn 
master 	git etc 
two times 	gitconfig git pathdup 
node timeout 	absolute path 
strictly needed 	xstrdup prefix filename 
correctness algorithm 	strlen multi 
makes linear 	bits error usage 
slave 	options error 
requesting vote 	usage options 
must config 	multi bits error 
epoch claimed 	usage options 
slots one 	usage options error 
masters currently 	usage options 
serving 	error usage options 
slots current 	check argc 
configuration reached 	git config options 
point found 	die errno 
slot current 	die check argc 
slots served 	die die 
master 	die git config 
greater config 	xstrdup git 
epoch one 	path open user 
claimed slave 	config write 
requesting vote 	str full free 
refuse vote 	close die 
slave 	errno launch editor 
vote slave 	free check 
function returns 	write check 
rank instance 	argc normalize git 
slave context 	config file 
master slaves 	gently error check 
ring 	write check 
rank slave 	argc normalize git 
given number 	config multivar 
slaves master 	file gently check 
better replication 	write check 
offset compared 	argc normalize git 
local 	config multivar 
one better 	file gently check 
means greater 	write check 
claim data 	argc normalize git 
slave rank 	config multivar 
one greatest 	file gently check 
date 	argc check 
replication offset 	argc check 
forth note 	argc check argc 
rank computed 	urlmatch check 
multiple slaves 	write check argc 
may rank 	git config 
offset 	multivar file gently 
slave rank 	git config 
used delay 	file gently check 
start election 	write check 
order voted 	argc git config 
replace failing 	multivar file 
master 	gently check write 
slaves better 	check argc 
replication offsets 	git config rename 
likely win 	section file 
never called 	die check write 
slaves without 	check argc 
master 	git config rename 
function called 	section file 
cluster handle 	die check 
slave failover 	argc color check 
order slave 	argc git 
log able 	config colorbool git 
failover 	information manager 
sometimes conditions 	hell copyright linus 
since failover 	torvalds copyright 
function called 	johannes schindelin config 
log things 	contains key 
continuously function 	pairs usual config 
works 	config files 
logging given 	repo specific git 
conditions reason 	config user 
failover initiated 	wide gitconfig xdg 
changed reasons 	config file 
also include 	etc gitconfig use 
none 	absolute path 
reason reset 	interpret relative paths 
state slave 	including config 
finds master 	file pass 
fine fail 	along values including 
flag also 	include directives 
log 	makes possible query 
emitted master 	information includes 
still reason 	dequote write dos 
failing still 	like systems 
cluster cant 	characters escape reject 
failover relog 	unknown escape 
period 	sequences full name 
seconds elapsed 	already consumed 
function logs 	need linenr point 
slave five 	line parsed 
seconds node 	call accurate line 
timeout way 	number error 
nothing 	messages require format 
logged failover 	extension feff 
starts reasonable 	order mark utf 
time function 	file beginning 
called reason 	skip utf 
slave failover 	encoded bom present 
one 	sane editors 
integer macros 	won put windows 
cluster cant 	notepad happily 
failover function 	tolerate bom bom 
guaranteed called 	file beginning 
slave log 	cool reset prior 
reason 	determining stem 
time also 	truncate name back 
emit log 	section header 
master failed 	stem prior grabbing 
ago goal 	suffix part 
function log 	name needs better 
slaves 	name must 
stalled condition 	multiple pagesize config 
time function 	variables documentation 
part automatic 	config txt 
manual failovers 	config variables documentation 
slave grabs 	config txt 
master 	config variables documentation 
hash slots 	config txt 
propagates configuration 	deprecated config variables 
note caller 	documentation config 
sure node 	txt config variables 
got configuration 	documentation config 
epoch 	txt config variables 
already turn 	documentation config 
node master 	txt source specific 
claim slots 	fields die 
assigned master 	error name callbacks 
update state 	fgetc ungetc 
save 	ftell top need 
config pong 	initialized calling 
nodes update 	function push config 
state accordingly 	file parsing 
detect switched 	state stack 
master role 	pop config file 
manual 	parsing state 
failover progress 	stack parse environment 
clear state 	variable various 
function called 	possible spellings missing 
slave node 	use def 
master serving 	parse environment variable 
non 	possibly unit 
zero amount 	suffix missing use 
hash slots 	val error 
fail state 	found nothing found 
gaol function 	least one 
check able 	item specific filename 
perform 	use otherwise 
failover data 	follow regular lookup 
updated elected 	sequence git 
masters perform 	config options normally 
failover informing 	returns positive 
nodes compute 	values errors 
failover 	fatal non fatal 
timeout max 	potential errors 
time send 	guarded statements entered 
votes wait 	error possible 
replies failover 	ever encounter non 
retry time 	fatal error 
time 	means something went 
wait trying 	really wrong 
voted timeout 	stop immediately key 
min node 	may come 
timeout milliseconds 	user normalize querying 
retry two 	entries hashmap 
times 	since keys fed 
timeout pre 	git config 
conditions run 	callback mechanism already 
function must 	normalized simply 
met automatic 	without munging values 
manual failover 	read git 
slave 	config parameters 
master flagged 	follows last one 
fail manual 	wins semantic 
failover serving 	multiple matches queried 
slots reasons 	key files 
failover reason 	configset returned last 
returning 	list key 
without failing 	hack test programs 
none data 	like test 
age number 	dump untracked cache 
seconds disconnected 	find stuff 
master node 	git config always 
timeout 	matches never 
data age 	matches looking store 
fine disconnected 	key section 
master least 	section part baselen 
time flagged 	found key 
fail baseline 	section would 
check 	want know key 
data recent 	section looking 
enough according 	already know section 
slave validity 	hold store 
factor configured 	key increment matches 
user check 	match made 
bypassed 	sure desired section 
manual failovers 	fallthru error 
previous failover 	code failed rename 
attempt timedout 	check see 
retry time 	needs surrounded pair 
elapsed setup 	note problematic 
one 	characters always backslash 
delay milliseconds 	quoted check 
fail msg 	losing leading trailing 
propagate random 	follow beginning 
delay milliseconds 	comment characters configuration 
another delay 	parser auxiliary 
proportional 	function sanity 
slave rank 	check split key 
specifically second 	section variable 
rank way 	name returns success 
slaves probably 	invalid character 
less updated 	key section name 
replication 	key store 
offset penalized 	key pointer hold 
however manual 	copy key 
failover delay 	lowercase section variable 
needed scheduled 	name baselen 
election broadcast 	pointer hold length 
offset 	section subsection 
slaves updated 	part since key 
offsets offset 	actually contains 
better possible 	section name real 
received updated 	key name 
offsets slaves 	separated dot know 
master 	dot validate 
since computed 	key lower 
election delay 	matching extended basename 
update delay 	untouched unset 
rank changed 	config regex disregard 
performed manual 	key pairs 
failover 	match regex config 
asap still 	regex none 
start election 	match existing values 
asap election 	one multi 
old valid 	replace nothing one 
ask votes 	matching key 
needed 	replaced matching key 
wait replies 	values regardless 
check reached 	many removed pair 
quorum quorum 	written returns 
failover master 	success function locks 
update config 	config file 
epoch 	creating git config 
epoch election 	parses config 
take responsability 	store aux 
cluster slots 	validator find position 
cluster slave 	key pair 
migration slave 	replace unset must 
migration 	found exactly 
process allows 	config file mmap 
slave master 	part match 
already covered 	written file changed 
least another 	part rest 
slave migrate 	config file removed 
master 	file rename 
orpaned left 	parse key returns 
working slaves 	negative flip 
function responsible 	sign feed exit 
decide replica 	serves purpose 
migrated different 	addition locking contents 
orphaned 	git config 
master called 	written git config 
cluster cron 	exist yet 
function slave 	write minimal 
node detected 	version invalid config 
least one 	file nothing 
orphaned 	unset error store 
master cluster 	offset contain 
slave one 	end offset last 
masters greatest 	match remain 
number slaves 	match found side 
checks 	effect make 
performed caller 	sure transform valid 
since requires 	existing config 
iterate nodes 	file nothing unset 
anyway spend 	many matches 
time cluster 	error write first 
handle 	part config 
slave migration 	write pair means 
definitely needed 	unset write 
fuction called 	rest config 
pre computed 	committed roll back 
max slaves 	note since 
max 	lockfile keeps linked 
number working 	list created 
fail state 	file structures isn 
slaves single 	safe free 
master additional 	better hanging around 
conditions migration 	invalidate config 
examined 	cache nothing nothing 
inside function 	match find 
step migrate 	right length offset 
cluster state 	gobbling whitespace 
step migrate 	well nothing empty 
master left 	section names 
least 	bogus dot must 
migration barrier 	alphanumeric dash 
slaves migration 	first dot anything 
step idenitfy 	goes stop 
candidate migration 	checking name 
check among 	section removed instead 
masters 	config file 
greatest number 	means nothing rename 
slaves one 	error nothing 
smallest node 	section wrote section 
candidate slave 	newline skip 
note means 	old section length 
eventually 	content means 
replica migration 	declaration put next 
occurr since 	line indent 
slaves reachable 	tab call report 
always fail 	error variable 
flag cleared 	means start section 
eventually 	find key 
must candidate 	know yet subsection 
time mean 	must parse 
race conditions 	backwards end since 
possible two 	subsection may 
slaves migrating 	dots subsection 
time 	use fwrite buf 
unlikely happen 	contain end 
harmless happens 	show key name 
want migrate 	back delimiter 
master working 	needswork naive pattern 
orphaned used 	lowercasing obviously 
slaves 	work complex patterns 
failed master 	like foo 
slaves migrate 	bar perhaps deprecate 
flag way 	altogether someday 
migrate instances 	normalization type path 
supposed replicas 	path like 
check 	foobar prefer store 
number working 	foobar config 
slaves track 	file expand retrieving 
starting time 	none found 
orphaned condition 	config unknown home 
master check 	gitconfig exists 
slave 	know write 
candidate migration 	xdg location error 
attached master 	even xdg 
maximum number 	config home points 
slaves smallest 	sane location 
node step 	config.c prev file 
perform 	buf len 
migration target 	pos origin type 
candidate master 	name path 
continuously orphaned 	die error linenr 
couple seconds 	eof conf 
failovers give 	zlib compression seen 
time 	config conf 
natural slaves 	conf conf conf 
instance advertise 	conf conf 
old master 	include depth advice 
one cluster 	path inc 
manual failover 	ret buf 
important 	expanded slash data 
steps performed 	inc ret 
slaves manual 	text env old 
failover user 	text data 
send cluster 	pair data env 
failover command 	envw argv 
failover 	alloc space data 
state initialized 	name ret 
setting end 	name name data 
millisecond unix 	comment baselen 
time abort 	bomptr end val 
attempt slave 	ret max 
sends 	end val uval 
mfstart message 	factor ret 
master requesting 	max end val 
pause clients 	oldval ret 
two times 	tmp ret tmp 
manual failover 	ret tmp 
timeout 	name reason 
cluster timeout 	name ret name 
master paused 	ret name 
manual failover 	ret name name 
also starts 	name discard 
flag packets 	dest dest abbrev 
clustermsg 	level level 
flag paused 	pgsz dummy top 
slave waits 	data ret 
master send 	origin type name 
replication offset 	path data 
flagged paused 	top data filename 
slave 	data ret 
received offset 	origin type name 
master offset 	buf len 
matches start 	data top name 
cluster handle 	sha data 
slave failover 	buf size ret 
perform 	name data 
failover usually 	sha system 
difference vote 	wide def val 
request modified 	data repo 
force masters 	config found xdg 
vote slave 	config user 
working 	config data config 
master point 	source respect 
view master 	includes repo config 
things simpler 	ret inc 
pause clients 	data data index 
packet received 	values entry 
master 	list info data 
sets end 	key found 
well sender 	entry normalized key 
slave time 	ret key 
limit manual 	item info unused 
failover master 	entry iter 
send 	key filename key 
pin often 	values key 
slave flagged 	key dest 
paused flag 	key dest key 
slave master 	dest key 
offset receiving 	dest key dest 
packet 	key dest 
master flag 	key dest key 
gaol manual 	dest key 
failover perform 	key key dest 
fast failover 	ret key 
without data 	dest key dest 
loss 	key dest 
due asynchronous 	key dest key 
master slave 	dest key 
replication reset 	dest key dest 
manual failover 	ret val 
state works 	key filename linenr 
masters 	git die 
slavesa state 	config baselen 
manual failover 	key match regex 
cleared function 	multi replace 
used initialize 	offset offset alloc 
manual failover 	seen key 
state 	key section len 
startup abort 	filename key 
manual failover 	dot success key 
progress use 	success length 
side effect 	quote contents size 
function manual 	offset found 
failover 	bracket bracket offset 
progress manual 	offset config 
failover timed 	filename key config 
abort function 	filename key 
called cluster 	key key key 
cron function 	store key 
order 	baselen quiet dot 
forward manual 	baselen last 
failover state 	dot key 
machine asap 	store key baselen 
manual failover 	key config 
progress start 	filename key regex 
non 	multi replace 
zero failover 	ret filename buf 
already triggered 	contents contents 
next steps 	copy begin copy 
performed cluster 	end line 
handle slave 	config filename key 
failover 	regex multi 
wait offset 	replace key regex 
replication offset 	multi replace 
matches master 	key regex multi 
replication offset 	replace buf 
announced clients 	name dot name 
paused 	config filename 
start failover 	old name name 
cluster cron 	filename buf 
job executed 	buf config 
times every 	file length output 
second many 	offset old 
masters 	name name section 
without slaves 	subsection subsection 
max number 	len key section 
slaves single 	len dot 
master number 	getc unlocked ungetc 
slaves master 	ftell die 
slave 	config error nonbool 
number times 	expand user 
function called 	path error absolute 
far handshake 	path error 
timeout time 	find last dir 
handshake node 	sep strbuf 
turned 	strbuf addstr access 
normal node 	die die 
removed nodes 	git config file 
usually node 	strbuf release 
timeout node 	free strcmp 
timeout small 	handle path include 
use 	getenv strbuf 
second check 	addstr strbuf addch 
disconnected nodes 	quote buf 
establish connection 	setenv strbuf release 
node handshake 	strbuf split 
state limited 	str error strbuf 
lifespan 	setlen strbuf 
equal configured 	trim strbuf list 
node timeout 	free error 
got synchronous 	strbuf tolower strbuf 
error connect 	list free 
cluster send 	strbuf list free 
ping 	getenv xstrdup 
chance called 	dequote argv free 
node ping 	error git 
sent zero 	config parse parameter 
failure detection 	free free 
work claim 	free free 
actually 	fgetc fgetc ungetc 
sent ping 	strbuf reset 
really sent 	next isspace strbuf 
soon link 	addch next 
obtained queue 	strbuf addch strbuf 
ping connection 	addch isalnum 
asap 	next iskeychar strbuf 
crucial avoid 	addch tolower 
positives failure 	next parse isspace 
detection node 	next strbuf 
flagged meet 	addch next next 
send meet 	strbuf addch 
message 	next next isspace 
instead ping 	extended iskeychar 
one force 	strbuf addch tolower 
receiver node 	next isspace 
table active 	strbuf reset 
ping link 	strbuf addch isalpha 
disconnected 	strbuf setlen 
want restore 	strbuf addch tolower 
ping time 	die error 
otherwise replaced 	strcasecmp strcasecmp strcasecmp 
cluster send 	strtoimax parse 
ping call 	unit factor labs 
clear 	labs strtoumax 
flag first 	parse unit factor 
packet sent 	git parse 
never receive 	maximum type git 
pong never 	parse maximum 
send packets 	type git parse 
node 	maximum type 
instead pong 	die die git 
received longer 	parse die 
meet handshake 	bad number git 
status want 	parse die 
send normal 	bad number 
ping 	git parse die 
packets ping 	bad number 
random node 	strcasecmp strcasecmp strcasecmp 
time every 	strcasecmp strcasecmp 
iterations usually 	strcasecmp git parse 
ping one 	maybe git 
random 	parse git parse 
node every 	maybe git 
second check 	config git config 
random nodes 	config error 
ping one 	nonbool xstrdup config 
oldest pong 	error nonbool 
received 	expand user path 
time ping 	die strcmp 
nodes disconnected 	git config strcmp 
ping currently 	git config 
active iterate 	strcmp strcasecmp strcasecmp 
nodes check 	strcmp git 
need 	config strcmp 
flag something 	git config strcmp 
failing loop 	git config 
also responsible 	strcmp git config 
check orphaned 	pathname strcmp 
masters masters 	git config strcmp 
without 	git config 
non failing 	strcmp git config 
slaves count 	strcmp git 
max number 	config strcmp git 
non failing 	config strcmp 
slaves single 	git config strcmp 
master 	git config 
count number 	die strcmp git 
slaves master 	config die 
slave use 	strcmp getpagesize git 
updated time 	config strcmp 
every iteration 	git config strcmp 
orphaned 	git config 
master check 	strcmp git 
useful current 	config strcmp strcasecmp 
instance slave 	error git 
may migrate 	config strcmp strcasecmp 
another master 	git config 
master 	strcmp strcasecmp strcasecmp 
orphaned serving 	strcasecmp error 
non zero 	strcmp xstrdup strcmp 
number slots 	git config 
working slaves 	strcmp git config 
used least 	strcmp config 
one 	error nonbool strcasecmp 
slave failed 	error strcmp 
master used 	git config strcmp 
slaves waiting 	git config 
pong half 	pathname strcmp config 
cluster timeout 	error nonbool 
reconnect 	parse whitespace 
link maybe 	rule strcmp git 
connection issue 	config strcmp 
even node 	git config strcmp 
alive connected 	strcmp strcmp 
already reconnected 	die strcmp git 
already 	config strcmp 
sent ping 	git config strcmp 
still waiting 	git config 
pong waiting 	strcmp git config 
pong timeout 	strcmp git 
disconnect link 	config strcmp git 
reconnected 	config strcmp 
automatically currently 	strcasecmp git config 
active ping 	strcmp config 
instance received 	error nonbool strcmp 
pong older 	strcmp strcmp 
half cluster 	strcmp error strcmp 
timeout 	config error 
send ping 	nonbool strcmp 
ensure nodes 	strcmp strcmp strcmp 
pinged without 	strcmp strcmp 
big delay 	error error strcmp 
master one 	git config 
slaves 	pathname strcmp git 
requested manual 	config starts 
failover ping 	git core config 
continuously check 	starts git 
active ping 	ident config starts 
instance compute 	git config 
delay 	starts git branch 
pong note 	config starts 
already received 	git push config 
pong node 	starts git 
ping sent 	mailmap config starts 
zero reach 	git advice 
code 	config strcmp strcmp 
timeout reached 	git config 
node possibly 	strcmp git 
failing already 	config strbuf init 
state slave 	strbuf init 
node replication 	git parse source 
still 	strbuf release 
turned enable 	strbuf release config 
know address 	config file 
master appears 	fopen flockfile config 
abourt manual 	file funlockfile 
failover timeout 	fclose config read 
reached 	sha file 
orphaned slaves 	error free error 
slave among 	git config 
masters max 	mem free sha 
number non 	error git 
failing slaves 	config blob sha 
consider 	system path 
migrating orphaned 	getenv git config 
masters note 	getenv git 
make sense 	parse die 
migration master 	git env xdg 
least two 	config home 
working 	expand user path 
slaves function 	git config 
called handler 	system access die 
returns sleep 	git etc 
events useful 	gitconfig git config 
perform operations 	file git 
must 	etc gitconfig access 
done asap 	die git 
reaction events 	config file access 
fired safe 	die git 
perform inside 	config file access 
handlers perform 	die git 
potentially 	config file git 
expansive tasks 	config parameters 
need single 	die free 
time replying 	free git config 
clients handle 	stdin git 
failover needed 	config file git 
likely 	config blob 
already quorum 	git pathdup git 
masters order 	config early 
react fast 	free git config 
update cluster 	options die 
state save 	git die config 
config 	linenr git 
possibly fsync 	config check init 
reset flags 	configset iter 
strictly needed 	git config parse 
since every 	key hashmap 
single function 	entry init strhash 
called 	hashmap free 
flags able 	xmalloc configset find 
clear flag 	element xmalloc 
slots management 	hashmap entry 
test bit 	init strhash xstrdup 
pos bitmap 	list init 
bit 	hashmap list append 
otherwise bit 	nodup xstrdup 
position pos 	alloc grow strintern 
bitmap clear 	strcmp hashmap 
bit position 	init hashmap iter 
pos bitmap 	init hashmap 
slot 	iter next free 
bit old 	list clear 
clear slot 	hashmap free free 
bit old 	configset git 
slot bit 	config file git 
cluster 	configset multi 
node structure 	configset find element 
specified slot 	git configset 
list slots 	git config git 
node serve 	configset git 
operation ended 	configset git 
success 	config git configset 
slot already 	git config 
assigned another 	git configset git 
instance considered 	config git 
error err 	configset git config 
returned specified 	git configset 
slot 	git config maybe 
marking unassigned 	git configset 
returns slot 	git config pathname 
assigned otherwise 	git configset 
slot already 	init git config 
unassigned err 	raw git 
returned 	configset clear git 
slots associated 	config check 
specified node 	init git configset 
number deleted 	git config 
slots returned 	check init git 
clear migrating 	configset multi 
importing 	git config 
state slots 	check init git 
useful initialization 	configset git 
turning master 	die config git 
slave cluster 	config check 
state evaluation 	init git config 
function 	git config 
following defines 	check init git 
used evaluation 	configset git 
function heuristics 	config check init 
actaully main 	git configset 
point rejoin 	git config check 
writable 	init git 
delay orders 	configset git config 
magnitude larger 	check init 
network latency 	git configset git 
master node 	config check 
wait time 	init git configset 
turning 	maybe git 
state since 	config check 
good idea 	init git configset 
rejoin cluster 	pathname git 
writable master 	die config git 
reboot without 	config maybe 
giving 	git config strcasecmp 
cluster chance 	error die 
reconfigure node 	die strcmp regexec 
note delay 	matches warning 
calculated starting 	alloc grow ftell 
first call 	strrchr memcmp 
function 	alloc grow ftell 
since server 	matches alloc 
start order 	grow ftell strrchr 
count loading 	strncmp alloc 
time start 	grow ftell error 
assuming state 	memchr strbuf 
turn 	addf strbuf 
fail right 	addch strbuf addch 
conditions check 	strbuf addstr 
slots covered 	strbuf addf write 
compute cluster 	full strbuf 
size number 	release strlen strbuf 
master 	addf strbuf 
nodes serving 	addstr strbuf addstr 
least single 	strbuf addch 
slot time 	strbuf addch strbuf 
count number 	addf write 
reachable masters 	full strbuf release 
least 	git config 
one slot 	multivar file gently 
minority partition 	git config 
change cluster 	multivar file git 
state fail 	config multivar 
log state 	gently git config 
change 	multivar strrchr 
instance master 	error error 
partitioned away 	xmallocz strlen iskeychar 
minority accept 	isalpha error 
queries time 	tolower error free 
partition heals 	git config 
make 	parse key git 
sure enough 	config parse 
time receive 	key git config 
configuration update 	parse key 
change state 	git pathdup xcalloc 
log function 	hold file 
called 	update error strerror 
node startup 	free open 
order verify 	free error strerror 
data loaded 	store write 
disk agreement 	section store write 
cluster configuration 	pair xmalloc 
find 	regcomp error free 
keys hash 	alloc grow 
slots responsibility 	git config 
following happens 	file error free 
node charge 	regfree free 
according current 	free regfree free 
cluster 	fstat xsize 
configuration slots 	xmmap gently isdir 
node according 	error strerror 
config nodes 	close chmod file 
already charge 	path error 
lots slots 	file path strerror 
importing 	find beginning 
point view 	line write full 
order justify 	write str 
slots order 	full store write 
make redis 	section store 
trib aware 	write pair write 
issue 	full munmap 
fix find 	commit file error 
data different 	strerror git 
err signal 	config clear 
caller quit 	rollback file free 
server error 	munmap close 
message 	write error file 
take actions 	path git 
function always 	config multivar file 
returns even 	gently die 
correct error 	git config multivar 
described however 	file gently 
data 	git config multivar 
found different 	file isspace 
err returned 	isspace isspace isspace 
function also 	isalnum section 
uses logging 	name error git 
facility order 	pathdup xcalloc 
warn 	hold file update 
user desynchronizations 	error fopen 
data memory 	fstat fileno 
cluster configuration 	chmod file path 
node slave 	error file 
perform check 	path strerror fgets 
completely 	isspace section 
depend replication 	name match strlen 
stream make 	store write 
sure keys 	section write error 
check slots 	file path 
see populated 	strlen strlen write 
memory 	full write 
corresponding entry 	error file path 
cluster table 	fclose commit 
otherwise fix 	file error strerror 
table keys 	free git 
slot check 	config rename section 
assigned 	file error 
slot importing 	strlen starts strrchr 
cases check 	git information 
next slot 	manager hell 
configuration makes 	copyright linus torvalds 
sense data 	copyright johannes 
cluster 	schindelin config contains 
config agree 	key pairs 
slot populated 	usual config config 
even importing 	files repo 
assigned slot 	specific git config 
fix condition 	user wide 
slot 	gitconfig xdg config 
unassigned take 	file etc 
responsibility slave 	gitconfig use absolute 
nodes handling 	path interpret 
specified node 	relative paths including 
master node 	config file 
node 	pass along values 
currently master 	including include 
turned slave 	directives makes possible 
nodes representation 	query information 
functions concatenate 	includes dequote 
comma separated 	write dos like 
list 	systems characters 
node flags 	escape reject unknown 
given sds 	escape sequences 
trailing comma 	full name already 
generate csv 	consumed need 
alike representation 	linenr point line 
specified 	parsed call 
cluster node 	accurate line number 
see cluster 	error messages 
gen nodes 	require format extension 
description top 	feff order 
comment information 	mark utf file 
function 	beginning skip 
returns representation 	utf encoded bom 
sds node 	present sane 
coordinates flags 	editors won put 
slave latency 	windows notepad 
pov node 	happily tolerate 
config 	bom bom file 
epoch link 	beginning cool 
status slots 	reset prior determining 
served instance 	stem truncate 
node also 	name back section 
dump info 	header stem 
slots 	prior grabbing suffix 
migrating instances 	part name 
importing instances 	needs better name 
generate csv 	must multiple 
alike representation 	pagesize config variables 
nodes aware 	documentation config 
including 	txt config variables 
node sds 	documentation config 
containing representation 	txt config variables 
caller free 	documentation config 
nodes matching 	txt deprecated 
least one 	config variables documentation 
node 	config txt 
flags specified 	config variables documentation 
filter excluded 	config txt 
output zero 	config variables documentation 
filter include 	config txt 
known nodes 	source specific fields 
representation 	die error 
including nodes 	name callbacks fgetc 
handshake state 	ungetc ftell 
representation obtained 	top need initialized 
function used 	calling function 
output cluster 	push config file 
nodes 	parsing state 
function format 	stack pop config 
cluster configuration 	file parsing 
file nodes 	state stack parse 
conf given 	environment variable 
node cluster 	various possible 
command 	spellings missing use 
format start 	def parse 
slot end 	environment variable possibly 
slot master 	unit suffix 
master port 	missing use val 
node replica 	error found 
replica 	nothing found least 
port node 	one item 
continued done 	specific filename use 
skip slaves 	otherwise follow 
iterated producing 	regular lookup sequence 
output master 	git config 
masters 	options normally returns 
serving slot 	positive values 
slots master 	errors fatal non 
addr slot 	fatal potential 
exists output 	errors guarded statements 
map list 	entered error 
create 	possible ever 
output map 	encounter non fatal 
slot one 	error means 
slot low 	something went really 
high low 	wrong stop 
high first 	immediately key may 
node 	come user 
reply position 	normalize querying entries 
always master 	hashmap since 
remaining nodes 	keys fed git 
reply replicas 	config callback 
slot range 	mechanism already normalized 
loop 	simply without 
copy pasted 	munging values read 
cluster gen 	git config 
node description 	parameters follows last 
modifications per 	one wins 
slot node 	semantic multiple matches 
aggregation 	queried key 
cluster nodes 	files configset 
cluster myid 	returned last list 
cluster slots 	key hack 
cluster flushslots 	test programs like 
cluster addslots 	test dump 
slot 	untracked cache find 
slot cluster 	stuff git 
delslots slot 	config always matches 
slot check 	never matches 
arguments parseable 	looking store key 
slots already 	section section 
busy 	part baselen found 
slot importing 	key section 
clear state 	would want know 
real owner 	key section 
slot setslot 	looking already know 
migrating node 	section hold 
setslot 	store key increment 
importing node 	matches match 
setslot stable 	made sure 
setslot node 	desired section fallthru 
node cluster 	error code 
setslot slot 	failed rename check 
stable 	see needs 
cluster setslot 	surrounded pair note 
slot node 	problematic characters 
node hash 	always backslash quoted 
slot served 	check losing 
make sure 	leading trailing follow 
longer 	beginning comment 
local keys 	characters configuration parser 
hash slot 	auxiliary function 
slot migrating 	sanity check split 
status keys 	key section 
assigning slot 	variable name returns 
another 	success invalid 
node clear 	character key 
migratig status 	section name key 
node importing 	store key 
slot assigning 	pointer hold copy 
slot also 	key lowercase 
clears 	section variable name 
importing status 	baselen pointer 
slot manually 	hold length section 
migrated node 	subsection part 
config epoch 	since key actually 
epoch version 	contains section 
propagated 	name real key 
cluster note 	name separated 
ever results 	dot know dot 
collision another 	validate key 
node getting 	lower matching extended 
config epoch 	basename untouched 
example 	unset config regex 
failover happens 	disregard key 
time close 	pairs match 
slot config 	regex config regex 
epoch collision 	none match 
resolution fix 	existing values one 
assigning 	multi replace 
different epoch 	nothing one matching 
node cluster 	key replaced 
bumpepoch cluster 	matching key values 
info cluster 	regardless many 
keyslot key 	removed pair written 
cluster 	returns success 
countkeysinslot slot 	function locks config 
cluster getkeysinslot 	file creating 
slot count 	git config parses 
cluster forget 	config store 
node cluster 	aux validator find 
replicate 	position key 
node lookup 	pair replace unset 
specified node 	must found 
table replicate 	exactly config 
replicate slave 	file mmap part 
instance currently 	match written 
master 	file changed part 
assigned slots 	rest config 
keys accept 	file removed file 
replicate node 	rename parse 
slaves another 	key returns negative 
master without 	flip sign 
issues 	feed exit serves 
master cluster 	purpose addition 
slaves node 	locking contents git 
lookup specified 	config written 
node table 	git config exist 
cluster count 	yet write 
failure 	minimal version invalid 
reports node 	config file 
cluster failover 	nothing unset error 
force takeover 	store offset 
takeover also 	contain end 
implies force 	offset last match 
check 	remain match 
preconditions takeover 	found side effect 
perform initial 	make sure 
check generates 	transform valid existing 
configuration epoch 	config file 
node without 	nothing unset many 
consensus 	matches error 
claims master 	write first part 
slots broadcast 	config write 
configuration forced 	pair means unset 
failover need 	write rest 
talk master 	config committed roll 
agree 	back note 
offset failover 	since lockfile keeps 
taking without 	linked list 
coordination cluster 	created file 
config epoch 	structures isn safe 
epoch user 	free better 
allowed 	hanging around invalidate 
config epoch 	config cache 
node totally 	nothing nothing match 
fresh config 	find right 
epoch known 	length offset gobbling 
node forth 	whitespace well 
happens 	nothing empty section 
cluster creation 	names bogus 
time start 	dot must alphanumeric 
cluster every 	dash first 
node different 	dot anything goes 
node without 	stop checking 
rely 	name section removed 
conflicts resolution 	instead config 
system slow 	file means nothing 
big cluster 	rename error 
created need 	nothing section 
fsync config 	wrote section newline 
since 	skip old 
unlucky failure 	section length content 
persist config 	means declaration 
conflict resolution 	put next line 
code assign 	indent tab 
unique config 	call report error 
node 	variable means 
cluster reset 	start section find 
soft hard 	key know 
parse soft 	yet subsection must 
hard argument 	parse backwards 
soft slaves 	end since subsection 
reset 	may dots 
containing data 	subsection use fwrite 
master nodes 	buf contain 
must empty 	end show key 
dump restore 	name back 
migrate commands 	delimiter needswork 
generates 	naive pattern lowercasing 
dump format 	obviously work 
representation adding 	complex patterns like 
stream pointed 	foo bar 
rio function 	perhaps deprecate altogether 
fail serialize 	someday normalization 
rdb 	type path path 
like format 	like foobar 
consist type 	prefer store foobar 
followed serialized 	config file 
understood restore 	expand retrieving none 
write footer 	found config 
looks 	unknown home gitconfig 
like rdb 	exists know 
payload bytes 	write xdg location 
rdb version 	error even 
bytes crc 	xdg config home 
rdb version 	points sane 
crc 	location builtin 
little endian 	config usage key 
rdb version 	key regexp 
crc verify 	regexp show keys 
rdb version 	omit values 
dump 	use key regexp 
payload matches 	match delim 
one redis 	key delim term 
instance checksum 	use config 
dump payload 	use system config 
looks valid 	use local 
returned 	config given config 
otherwise err 	source actions 
returned least 	types color slot 
bytes rdb 	colorbool slot 
version crc 	end respect includes 
present verify 	show origin 
rdb 	builtin config 
version verify 	options argc min 
crc dump 	max buf 
keyname dump 	term key buf 
actually used 	items alloc 
redis cluster 	buf key key 
obvious 	values key 
complement restore 	regex ret values 
useful different 	buf key 
applications check 	color found color 
key create 	slot colorbool 
dump encoded 	slot parsed color 
representation 	def color 
transfer client 	colorbool found diff 
restore key 	color found 
ttl serialized 	color found print 
replace parse 	values item 
additional options 	matched url section 
make 	tail item 
sure key 	config values 
already exist 	matched buf buf 
check ttl 	argc argv 
makes sense 	prefix nongit user 
verify rdb 	config xdg 
version 	config config file 
data checksum 	content ret 
old key 	ret ret error 
needed create 	usage options 
key ttl 	strbuf addstr current 
migrate socket 	config origin 
cache 	type strbuf addch 
implementation take 	strbuf addstr 
map host 	current config name 
tcp socket 	quote style 
used connect 	current config name 
instance recent 	strbuf addch 
time 	show config origin 
sockets closed 	fwrite strbuf 
max number 	release show 
cache reached 	config origin strbuf 
also server 	addstr strbuf 
cron around 	addch strbuf addf 
seconds 	git config 
max num 	strbuf addstr git 
items cache 	config git 
close cached 	config strbuf addstr 
sockets sec 	strbuf addf 
migrate cached 	git config pathname 
socket 	strbuf addstr 
containing tcp 	free strbuf addstr 
socket connected 	strbuf setlen 
target instance 	strbuf addch strcmp 
possibly returning 	regexec regexec 
cached one 	alloc grow strbuf 
function 	init format 
responsible sending 	config xstrdup strlen 
errors client 	tolower tolower 
connection established 	xmalloc regcomp 
returned otherwise 	error free git 
success socket 	config parse 
returned 	key xmalloc regcomp 
caller attempt 	error free 
free usage 	git config options 
caller detects 	fwrite strbuf 
error socket 	release free free 
migrate close 	regfree free 
socket 	regfree free xstrdup 
called connection 	xstrfmt git 
created scratch 	config xstrdup git 
next time 	config git 
check already 	config xstrfmt xstrdup 
cached socket 	die strcmp 
port 	config error nonbool 
pair cached 	color parse 
socket create 	git config options 
one many 	color parse 
items drop 	die fputs 
one random 	strcmp git config 
create 	colorbool strcmp 
socket check 	git config colorbool 
connects within 	strcmp git 
specified timeout 	config colorbool git 
cache caller 	config options 
free migrate 	strcmp want color 
cached 	die die 
connection migrate 	die list insert 
host port 	xmalloc strbuf 
key dbid 	init strbuf reset 
timeout copy 	strbuf addstr 
replace multiple 	url normalize die 
keys 	xstrdup tolower 
form migrate 	strchr git config 
host port 	options format 
dbid timeout 	config fwrite 
copy replace 	strbuf release strbuf 
keys key 	release list 
key 	clear list clear 
key objects 	free free 
migrate key 	strbuf addf ident 
names used 	name ident 
rewrite command 	email strbuf detach 
del keys 	getenv parse 
support 	options error usage 
keys option 	options strcmp 
need following 	expand user path 
additional state 	xdg config 
argument index 	home die access 
first key 	warn access 
migrate 	warn git etc 
key argument 	gitconfig git 
initialization parse 	pathdup absolute path 
additional options 	xstrdup prefix 
remaining args 	filename strlen 
keys sanity 	multi bits error 
check 	usage options 
check keys 	error usage options 
least one 	multi bits 
key migrate 	error usage options 
otherwise keys 	usage options 
missing reply 	error usage options 
nokey 	error usage 
signal caller 	options check argc 
nothing migrate 	git config 
error since 	options die errno 
often due 	die check 
normal condition 	argc die die 
like 	die git 
key expiring 	config xstrdup git 
meantime connect 	path open 
error sent 	user config write 
client migrate 	str full 
socket send 	free close 
command 	die errno launch 
current already 	editor free 
selected emit 	check write check 
create restore 	argc normalize 
payload generate 	git config file 
protocol call 	gently error 
command 	check write check 
emit payload 	argc normalize 
argument serialized 	git config multivar 
dump format 	file gently 
replace option 	check write check 
restore command 	argc normalize 
specified 	git config multivar 
migrate option 	file gently 
transfer query 	check write check 
node chunks 	argc normalize 
reply restore 	git config multivar 
reply read 	file gently 
reply 	check argc 
needed read 	check argc check 
restore replies 	argc check 
index key 	argc urlmatch check 
argument replicated 	write check 
del error 	argc git config 
last 	multivar file 
dbid longer 	gently git config 
valid copy 	file gently 
option local 	check write check 
key signal 	argc git 
change populate 	config multivar file 
argument 	gently check 
vector replace 	write check argc 
old one 	git config 
socket error 	rename section file 
want retry 	die check 
rewriting command 	write check 
vector 	argc git config 
retry sure 	rename section 
nothing processed 	file die check 
failed read 	argc color 
first reply 	check argc git 
test retry 	config colorbool 
guaranteed 	git information manager 
tested conditions 	hell copyright 
translate migrate 	linus torvalds copyright 
del replication 	johannes schindelin 
aof note 	config contains key 
following call 	pairs usual 
takes 	config config files 
ownership newargv 	repo specific 
key transfer 	git config user 
acknowledged need 	wide gitconfig 
rewrite del 	xdg config file 
make safe 	etc gitconfig 
call 	use absolute 
zfree future 	path interpret relative 
socket error 	paths including 
happened want 	config file pass 
retry signal 	along values 
problem client 	including include directives 
already 	makes possible 
queued different 	query information includes 
error reported 	dequote write 
destination server 	dos like systems 
success update 	characters escape 
last dbid 	reject unknown escape 
migrate 	sequences full 
cached socket 	name already consumed 
avoid next 	need linenr 
time target 	point line parsed 
reply error 	call accurate 
already sent 	line number error 
loop 	messages require 
curretly selected 	format extension 
socket force 	feff order mark 
next time 	utf file 
socket errors 	beginning skip utf 
close cached 	encoded bom 
socket 	present sane editors 
common cached 	won put 
socket closed 	windows notepad happily 
reopening works 	tolerate bom 
shame notify 	bom file beginning 
error caller 	cool reset 
cleanup 	prior determining stem 
want perform 	truncate name 
retry retry 	back section header 
note closing 	stem prior 
migrate socket 	grabbing suffix part 
also force 	name needs 
next 	better name must 
time reallocated 	multiple pagesize 
retry retry 	config variables 
timeout never 	documentation config txt 
attempted retry 	config variables 
code jumping 	documentation config txt 
may 	config variables 
retry zero 	documentation config txt 
cleanup want 	deprecated config 
retry attempted 	variables documentation config 
cluster functions 	txt config 
related serving 	variables documentation config 
redirecting 	txt config 
clients asking 	variables documentation config 
command required 	txt source 
ask redirection 	specific fields die 
client issue 	error name 
asking actually 	callbacks fgetc ungetc 
send 	ftell top 
command target 	need initialized 
instance see 	calling function push 
redis cluster 	config file 
specification information 	parsing state stack 
command used 	pop config 
clients 	file parsing state 
enter read 	stack parse 
mode mode 	environment variable various 
slaves redirect 	possible spellings 
clients clients 	missing use def 
access read 	parse environment 
commands 	variable possibly unit 
keys served 	suffix missing 
slave master 	use val error 
readwrite command 	found nothing 
clears command 	found least one 
state pointer 	item specific 
cluster 	filename use otherwise 
node able 	follow regular 
serve command 	lookup sequence 
function succeed 	git config options 
command target 	normally returns 
either single 	positive values errors 
key 	fatal non 
even multiple 	fatal potential errors 
times like 	guarded statements 
lpoprpush mylist 	entered error possible 
mylist multiple 	ever encounter 
keys hash 	non fatal error 
slot 	means something 
slot stable 	went really wrong 
resharding progress 	stop immediately 
success function 	key may come 
returns node 	user normalize 
able serve 	querying entries hashmap 
request 	since keys 
node redirection 	fed git config 
must perfomed 	callback mechanism 
kind redirection 	already normalized 
specified setting 	simply without munging 
integer passed 	values read 
reference 	git config parameters 
error code 	follows last 
cluster redir 	one wins semantic 
ask cluster 	multiple matches 
redir moved 	queried key files 
node error 	configset returned 
code 	last list key 
cluster redir 	hack test 
none command 	programs like test 
fails returned 	dump untracked 
reason failure 	cache find stuff 
provided via 	git config 
error 	always matches never 
code cluster 	matches looking 
redir cross 	store key section 
slot request 	section part 
contains multiple 	baselen found 
keys belong 	key section would 
hash 	want know 
slot cluster 	key section looking 
redir unstable 	already know 
request contains 	section hold store 
multiple keys 	key increment 
belonging slot 	matches match made 
slot 	sure desired 
stable migration 	section fallthru error 
importing state 	code failed 
likely resharding 	rename check see 
progress cluster 	needs surrounded 
redir unbound 	pair note problematic 
request 	characters always 
addresses slot 	backslash quoted check 
bound node 	losing leading 
cluster state 	trailing follow beginning 
already fragile 	comment characters 
rely update 	configuration parser 
state 	auxiliary function sanity 
also handle 	check split 
error code 	key section variable 
optimistically handle 	name returns 
cases exec 	success invalid character 
commands common 	key section 
code 	name key store 
path everything 	key pointer 
client multi 	hold copy key 
flag exec 	lowercase section 
going error 	variable name baselen 
order single 	pointer hold 
codepath 	length section subsection 
create fake 	part since 
multi state 	key actually contains 
structure client 	section name 
multi exec 	real key 
state way 	name separated dot 
single 	know dot 
codepath check 	validate key lower 
keys hash 	matching extended 
slot obtain 	basename untouched unset 
slot node 	config regex 
associated first 	disregard key pairs 
key 	match regex 
see check 	config regex none 
slot node 	match existing 
error slot 	values one multi 
served cluster 	replace nothing 
state however 	one matching key 
state 	replaced matching 
yet updated 	key values regardless 
trapped earlier 	many removed 
process command 	pair written returns 
report error 	success function 
client migrating 	locks config 
importing 	file creating git 
slot need 	config parses 
check keys 	config store aux 
request way 	validator find 
safely serve 	position key pair 
request otherwise 	replace unset 
tryagain 	must found exactly 
error importing 	config file 
migrating state 	mmap part match 
increment counter 	written file 
every missing 	changed part rest 
key first 	config file 
key 	removed file rename 
make sure 	parse key 
exactly key 	returns negative flip 
first saw 	sign feed 
error multiple 	exit serves purpose 
keys different 	addition locking 
slots 	contents git 
flag request 	config written git 
one multiple 	config exist 
different keys 	yet write minimal 
migarting improrting 	version invalid 
slot count 	config file nothing 
keys 	unset error 
key command 	store offset contain 
serve request 	end offset 
without redirections 	last match remain 
errors hashslot 	match found 
reference migrate 	side effect make 
always 	sure transform 
works context 	valid existing config 
local node 	file nothing 
slot open 	unset many matches 
migrating importing 	error write 
state need 	first part config 
able 	write pair 
freely move 	means unset 
keys among 	write rest config 
instances keys 	committed roll 
migrating slot 	back note since 
send ask 	lockfile keeps 
redirection 	linked list created 
receiving slot 	file structures 
client correctly 	isn safe free 
flagged request 	better hanging 
asking serve 	around invalidate config 
request however 	cache nothing 
request 	nothing match find 
involves multiple 	right length 
keys option 	offset gobbling whitespace 
send tryagain 	well nothing 
error handle 	empty section names 
read client 	bogus dot 
reading 	must alphanumeric 
slave node 	dash first dot 
slave request 	anything goes 
hash slot 	stop checking name 
master serving 	section removed 
reply without 	instead config file 
redirection 	means nothing 
right node 	rename error nothing 
however node 	section wrote 
error code 	section newline skip 
moved since 	old section 
need issue 	length content means 
rediretion 	declaration put 
send client 	next line indent 
right redirection 	tab call 
code according 	report error variable 
error code 	means start 
one 	section find key 
cluster redir 	know yet 
macros cluster 	subsection must 
redir ask 	parse backwards end 
cluster redir 	since subsection 
moved error 	may dots subsection 
codes 	use fwrite 
used node 	buf contain end 
node want 	show key 
mention redirection 	name back delimiter 
moreover hashslot 	needswork naive 
hash slot 	pattern lowercasing obviously 
caused 	work complex 
redirection request 	patterns like foo 
spawns mutliple 	bar perhaps 
keys slot 	deprecate altogether someday 
slot stable 	normalization type 
currently migration 	path path like 
progress 	foobar prefer 
function called 	store foobar config 
function processing 	file expand 
clients incrementally 	retrieving none 
detect timeouts 	found config unknown 
order handle 	home gitconfig 
following 	exists know write 
client blocks 	xdg location 
blpop similar 	error even xdg 
blocking operation 	config home 
master migrates 	points sane location 
hash slot 	connect.c server 
elsewhere 	capabilities name flags 
turns slave 	flags got 
client may 	least one head 
remain blocked 	symref val 
forever max 	len sym target 
timeout time 	item symref 
waiting 	feature list len 
key change 	val item 
never happen 	src buf src 
client found 	len list 
blocked hash 	flags extra 
slot node 	shallow points orig 
longer 	list got 
handles client 	least one head 
sent redirection 	old oid 
error function 	name len name 
returns otherwise 	len buffer 
returned operation 	arg feature list 
performed 	feature lenp 
cluster unblock 	len found feature 
client right 	list feature 
error send 	feature len feature 
error unblock 	url colon 
client slot 	slash prot name 
unassigned 	hoststart removebrackets 
emitting cluster 	host end start 
error slot 	host port 
handled node 	colon end 
imported cluster.h 	portnr sockfd addr 
gossip msg 	host flags 
nodecfg 	error message sockfd 
cmd argv 	port hints 
argc hashslot 	gai cnt host 
ask hashslot 	flags error 
error code 	message sockfd port 
redis cluster 	nport cnt 
data 	host flags sockfd 
structures defines 	git proxy 
exported api 	command pos matchlen 
everything looks 	hostlen rhost 
cluster work 	name rhost len 
sha hex 	host host 
length 	port proxy host 
cluster port 	end port 
baseport port 	fork url prog 
incr following 	flags hostandport 
defines amount 	path conn 
time sometimes 	cmd target host 
expressed 	ssh tortoiseplink 
multiplicators node 	ssh host port 
timeout ending 	ssh dup 
mult slave 	conn conn code 
max data 	skip prefix 
age factor 	check refname format 
fail 	starts starts 
report validity 	check die die 
undo fail 	xmemdupz strchr 
master back 	check refname format 
additional time 	check refname 
seconds milliseconds 	format list append 
manual 	free parse 
failover master 	feature parse one 
pause manual 	symref info 
failover mult 	list sort list 
delay slave 	lookup xstrdup 
migration redirection 	list clear 
errors 	packet read die 
returned node 	initial contact 
query node 	skip prefix die 
serve request 	strlen skip 
crossslot request 	prefix oid hex 
tryagain redirection 	die die 
required 	sha append oid 
ask redirection 	hex die 
required moved 	strlen free xstrdup 
redirection required 	strcmp sha 
clusterdown state 	append check alloc 
clusterdown unbound 	oidcpy annotate 
slot 	refs symref info 
cluster link 	strlen strstr 
encapsulates everything 	isspace isspace strcspn 
needed talk 	parse feature 
remote node 	parse feature server 
link creation 	feature strchr 
time 	strchr dos 
tcp socket 	drive prefix strcmp 
file descriptor 	strcmp strcmp 
packet send 	strcmp die strstr 
buffer packet 	strchr memmove 
reception buffer 	host end strchr 
node 	strtol setsockopt 
related link 	strerror getnameinfo xsnprintf 
cluster node 	str host 
flags macros 	port memset getaddrinfo 
node master 	die gai 
node slave 	strerror socket connect 
failure 	strbuf addf 
need acknowledge 	name strerror close 
node believed 	name freeaddrinfo 
malfunctioning node 	die enable keepalive 
still exchange 	strbuf release 
first ping 	str host port 
know 	gethostbyname die 
address node 	hstrerror strtoul 
send meet 	getservbyname die memset 
message node 	htons memcpy 
master elegible 	socket connect strbuf 
replica migration 	addf inet 
reasons 	ntoa strerror close 
slave able 	inet ntoa 
failover seconds 	die enable keepalive 
structure represent 	git tcp 
elements node 	connect sock dup 
fail reports 	strcmp strlen 
node 	config error nonbool 
reporting failure 	strstr strlen 
condition time 	strlen strncmp memcmp 
last report 	xmemdupz git 
node node 	config getenv git 
creation time 	config str 
node 	host port 
name hex 	xmalloc child process 
sha size 	init argv 
cluster node 	push argv push 
last config 	argv push 
epoch observed 	start command die 
node 	strchr strtol 
slots handled 	protocol url local 
node number 	ssh host 
slots handled 	end dos drive 
node number 	prefix strchr 
slave nodes 	die xstrdup xstrdup 
master 	free signal 
pointers slave 	parse connect url 
nodes pointer 	prot name 
master node 	getenv xstrdup xstrdup 
note may 	transport check 
even node 	allowed git use 
slave 	proxy git 
master node 	proxy connect 
tables unix 	git tcp connect 
time sent 	packet write 
latest ping 	free xmalloc child 
unix time 	process init 
received 	strbuf addstr strbuf 
pong unix 	addch quote 
time fail 	buf transport check 
flag last 	allowed host 
time voted 	port port prot 
slave master 	name free 
unix 	free free getenv 
time received 	getenv xstrdup 
offset node 	basename strcasecmp strcasecmp 
starting time 	strcasecmp strcasecmp 
orphaned master 	free argv push 
condition last 	argv push 
known 	argv push argv 
repl offset 	push argv 
node latest 	push argv 
known address 	push argv push 
node latest 	transport check 
known port 	allowed argv push 
node 	start command 
tcp link 	die strbuf release 
node list 	free free 
nodes signaling 	git connection socket 
failing node 	finish command 
cluster cluster 	free normal means 
fail 	want magic 
num master 	fake tag refs 
nodes least 	heads means 
one slot 	want regular branch 
hash table 	heads tags 
name cluster 	means want tags 
node 	type bits 
structures nodes 	clear means anything 
seconds following 	symref symref 
fields used 	head refs 
take slave 	heads master symref 
state elections 	something symref 
time 	bogus pair read 
previous next 	refs end 
election number 	feature thin pack 
votes received 	feature agent 
far already 	git otherwise matched 
asked votes 	substring another 
slave 	feature keep looking 
rank current 	deprecated use 
auth request 	deprecated use jump 
epoch current 	returns connected 
election slave 	socket die ipv 
currently able 	returns connected 
failover 	socket die numeric 
see cant 	ipv core 
failover macros 	matches www 
manual failover 	kernel well gitproxy 
state common 	netcatter kernel 
manual failover 	gitproxy netcatter sample 
time 	gitproxy netcatter 
limit unixtime 	matches everybody core 
zero progress 	gitproxy none 
manual failover 	kernel read proxy 
state master 	stdout write 
slave performing 	proxy stdin extract 
manual 	protocol relevant 
failover manual 	parts specified connection 
failover state 	url caller 
slave master 	must free returned 
offset slave 	destructive transforms 
needs start 	protocol code unwrapping 
zero 	host port 
stil received 	file pwd may 
non zero 	file projects 
signal manual 	repo terminate 
failover start 	hostname point path 
requesting masters 	url like 
vote 	ssh host user 
followign fields 	repo need 
used masters 	terminate host path 
take state 	starts returns 
elections epoch 	dummy child process 
last vote 	transport protocol 
granted 	need fork child 
things cluster 	process done 
sleep num 	finish connection finish 
msg sent 	connect returned 
via cluster 	function safe call 
bus num 	finish connect 
msg 	support former returns 
rcvd via 	connect successful 
cluster bus 	dies errors hopefully 
cluster state 	changed libification 
todo sleep 	effort connection 
flags redis 	failed without cannot 
cluster 	rely waitpid 
messages header 	tell happened children 
note ping 	host information 
pong meet 	connect unless user 
messages actually 	overridden environment 
exact kind 	underlying connection commands 
packet 	die cannot 
pong reply 	connect separate original 
ping exact 	protocol components 
format ping 	prog path extended 
meet special 	host header 
ping forces 	nul note headers 
receiver 	cause older 
sender node 	git daemon servers 
already list 	crash repo 
ping pong 	local variables environment 
reply ping 	git ssh 
meet message 	shell version 
mark 	git ssh command 
node xxx 	must remain 
failing pub 	historical compatibility tty 
sub publish 	open ssh 
propagation may 	read child stdout 
failover yes 	write child 
vote 	stdin connect.h url 
another node 	prog flags 
slots configuration 	conn conn feature 
pause clients 	features feature 
manual failover 	feature len ret 
initially know 	url connected.c 
name 	quiet data quiet 
find connect 	data transport 
first node 	shallow file rev 
getsockname function 	list argv 
use address 	commit sha 
next messages 	pack len idx 
address 	file quiet 
last time 	data transport quiet 
seen port 	data shallow 
last time 	file check everything 
seen node 	connected transport 
flags copy 	strip suffix strbuf 
room 	strbuf addstr 
future improvements 	packed git strbuf 
reclare bulk 	release start 
data bulk 	command error sigchain 
data since 	push find 
structure nested 	pack entry one 
bytes 	memcpy sha 
removed count 	hex write full 
message length 	error strerror 
computation config 	close error strerror 
epoch specified 	sigchain pop 
instance name 	finish command 
slots 	check everything connected 
owner slots 	real check 
bitmap ping 	everything connected real 
meet pong 	feed commits 
cluster msg 	want verify command 
data gossip 	git rev 
structures 	list objects stdin 
fail publish 	error means 
update cluster 	everything reachable commits 
bus protocol 	locally exists 
version siganture 	connected existing refs 
cmb redis 	note validate 
cluster 	individual objects returns 
message bus 	everything connected 
total length 	non zero otherwise 
message protocol 	index pack 
version currently 	already dangling pointers 
bytes used 	pack pack 
message 	self contained 
type used 	updated pack sure 
kind messages 	good sending 
epoch accordingly 	rev list verification 
sending node 	connected.h quiet 
config epoch 	data quiet data 
master 	shallow file 
last epoch 	quiet data transport 
advertised master 	take callback 
slave master 	data next name 
replication offset 	buffer called 
node master 	returning name last 
processed 	signal eof 
replication offset 	otherwise make sure 
node slave 	store commits 
name sender 	necessary connect ancestry 
node bytes 	chain existing 
reserved future 	refs trees blobs 
usage 	commits use 
sender tcp 	non zero 
port sender 	otherwise missing objects 
node flags 	connected convert-objects.c 
cluster state 	old sha sha 
pov sender 	converted convert 
message 	convert sha sha 
flags clustermsg 	pos sha 
flag message 	high next cmp 
flags better 	buffer entry 
specify packet 	buffer sha entry 
content used 	mode newmode 
provide 	buffer size baselen 
information node 	result sha 
state master 	newlen used len 
paused manual 	path sha 
failover give 	mode slash origpath 
ack auth 	buffer size 
request 	result sha orig 
even master 	buffer orig 
api exported 	size len 
outside cluster 	buf buffer formats 
cluster config.c 	timezones fmt 
maxmemory policy 	next dst buf 
syslog 	size line 
facility loglevel 	next date len 
supervised mode 	datelen buffer 
aof fsync 	size result sha 
client buffer 	newlen buffer 
limits defaults 	size result sha 
name 	orig buffer 
val val 	orig size sha 
name seconds 	entry buffer 
changes config 	data size argc 
err totlines 	argv sha 
slaveof linenum 	entry xcalloc hashcpy 
lines 	memmove die 
argv argc 	hashcmp insert 
addresses seconds 	convert entry hashcpy 
changes logfp 	sha hex 
size yes 	die convert entry 
cmd retval 	memcpy sha 
copy 	hex isreg xmalloc 
hard soft 	strlen strchr 
soft seconds 	strtoul die convert 
flags filename 	mode memcmp 
options config 	strchr sprintf hashcpy 
buf err 	sprintf write 
orig 	subdirectory write sha 
enable vlen 	file free 
eptr val 	strlen convert binary 
seconds changes 	sha die 
vlen val 	write subdirectory isspace 
hard soft 	memset strptime 
soft 	mktime isspace memcmp 
seconds flags 	strlen strlen 
replylen pattern 	mktime strchr 
buf matches 	strchr die memcpy 
buf buf 	isdigit memcpy 
buf buf 	strchr strchr sprintf 
buf 	parse oldstyle 
flagsobj aux 	date xmalloc memcpy 
key privdata 	memcmp memcpy 
key key 	convert date line 
privdata val 	convert date 
privdata val 	line memcpy write 
state 	sha file 
option line 	free memcmp die 
dict type 	convert ascii 
option dict 	sha memcmp convert 
type option 	ascii sha 
line rewritten 	convert date lookup 
numlines 	entry read 
lines tail 	sha file die 
state line 	sha hex 
state option 	xmalloc memcpy 
linenum state 	write sha file 
option 	convert convert 
opt path 	commit die sha 
state buf 	hex free 
linenum argc 	free setup git 
argv line 	directory usage 
aux state 	sha die convert 
option 	entry sha 
line force 	hex ever two 
linenum buf 	timezones bad 
len bytes 	old format already 
state option 	format hacky 
defvalue buf 	hacky one sparse 
force 	old style 
line state 	commits date fake 
option defvalue 	committer date 
force line 	sha parent sha 
state option 	author xyz 
defvalue force 	xyz date 
line 	committer xyz xyz 
state option 	date rest 
defvalue force 	hex sha convert.c 
line state 	nul lonecr 
option defvalue 	lonelf crlf printable 
force line 	nonprintable buf 
state 	size stats size 
option defval 	stats data 
line name 	size stats ret 
force state 	data size 
force option 	convert stats path 
line state 	ret data 
line 	path ret check 
state cwd 	safe crlf 
state option 	path data crlf 
line state 	git crlf 
force option 	worktree src 
line flags 	size cmd path 
state 	data child 
option force 	process write err 
line hard 	status argv 
soft state 	cmd path dict 
force line 	path src 
addresses option 	len dst cmd 
state 	ret nbuf 
content empty 	name next smudge 
state state 	clean required 
option linenum 	key name namelen 
configfile content 	drv size 
retval padding 	cnt path src 
content 	len buf 
padded path 	ident dst dollar 
state newcontent 	path src 
retval strcasecmp 	len buf ident 
config name 	sha dollar 
config name 	spc cnt 
unknown 	check drv check 
strcasecmp strcasecmp 	drv ident 
zrealloc zfree 	conv attr name 
sdssplitlen strlen 	path ccheck 
sdstrim sdssplitargs 	path path convert 
sdsfreesplitres sdstolower 	git convert 
strcasecmp 	git filter path 
atoi strcasecmp 	src len 
atoi strcasecmp 	dst normalizing ret 
yesnotoi strcasecmp 	filter filter 
atoi strcasecmp 	required path src 
atoi strcasecmp 	len dst 
zstrdup 	path src len 
strcasecmp zstrdup 	dst ret 
strcasecmp strtol 	filter free vtbl 
strcasecmp atoi 	filter input 
atoi append 	isize output osize 
server save 	count filter 
strcasecmp 	vtbl filter 
reset server 	singleton filter filter 
save strcasecmp 	held filter 
chdir server 	input isize output 
log strerror 	osize count 
exit strcasecmp 	crlf filter crlf 
config 	vtbl crlf 
strcasecmp zfree 	filter one two 
zstrdup fopen 	buf end 
sdscatprintf sdsempty 	ptr filter input 
strerror fclose 	isize output 
strcasecmp yesnotoi 	osize cas filled 
strcasecmp 	feed remaining 
zfree zstrdup 	fed filter cas 
strcasecmp config 	cascade vtbl 
strcasecmp atoi 	one two cascade 
strcasecmp load 	filter left 
server config 	state ident str 
strcasecmp 	ident output 
atoi strcasecmp 	osize drain 
memtoll strcasecmp 	filter input isize 
config strcasecmp 	output osize 
atoi strcasecmp 	ident head filter 
sdsnew atoi 	ident ident 
strcasecmp 	vtbl sha ident 
atoi strcasecmp 	path sha 
atoi strcasecmp 	filter filter filter 
yesnotoi strcasecmp 	input isize 
yesnotoi strcasecmp 	output osize memset 
atoi strcasecmp 	gather stats 
memtoll 	convert binary gather 
resize replication 	convert stats 
backlog strcasecmp 	read blob data 
atoi strcasecmp 	cache gather 
zfree zstrdup 	convert stats ascii 
strcasecmp yesnotoi 	free strbuf 
strcasecmp 	read file 
yesnotoi strcasecmp 	gather convert stats 
yesnotoi strcasecmp 	ascii strbuf 
yesnotoi strcasecmp 	release read blob 
yesnotoi strcasecmp 	data cache 
yesnotoi strcasecmp 	memchr free quote 
atoi 	buf strbuf 
strcasecmp yesnotoi 	expand strbuf release 
strcasecmp path 	start command 
name zfree 	error sigchain push 
zstrdup strcasecmp 	write full 
yesnotoi strcasecmp 	copy close error 
config 	sigchain pop 
strcasecmp atoi 	finish command error 
strcasecmp memtoll 	strbuf release 
strcasecmp yesnotoi 	memset fflush start 
strcasecmp yesnotoi 	strbuf read 
strcasecmp strlen 	error close error 
zstrdup 	finish error 
strcasecmp zfree 	strbuf swap 
zstrdup strcasecmp 	strbuf release parse 
path name 	config key 
zfree zstrdup 	strncmp xcalloc xmemdupz 
strcasecmp memtoll 	strcmp git 
strcasecmp 	config strcmp git 
memtoll strcasecmp 	config strcmp 
strcasecmp strcasecmp 	git config memcmp 
atoi strcasecmp 	count ident 
atoi strcasecmp 	strbuf avail strbuf 
memtoll strcasecmp 	grow memchr 
memtoll 	memmove memcmp memchr 
strcasecmp memtoll 	memchr memcpy 
strcasecmp memtoll 	memmove strbuf setlen 
strcasecmp lookup 	count ident 
command dict 	strbuf detach hash 
server sdslen 	sha file 
sdsdup 	strbuf grow memchr 
dict sdsfree 	strbuf memcmp 
strcasecmp yesnotoi 	memchr memchr 
strcasecmp zfree 	memchr strbuf addstr 
zstrdup strcasecmp 	strbuf sha 
yesnotoi strcasecmp 	hex strbuf addstr 
strtoll 	strbuf free 
strcasecmp atoi 	attr attr attr 
strcasecmp atoi 	unset strcmp 
strcasecmp strtoll 	attr git attr 
strcasecmp strtoll 	git config 
strcasecmp strtoll 	git check attr 
strcasecmp 	git path 
strtoll strcasecmp 	check crlf git 
client type 	path check 
name memtoll 	crlf git path 
memtoll atoi 	check ident 
strcasecmp yesnotoi 	git path check 
strcasecmp 	convert text 
atoi strcasecmp 	eol crlf convert 
atoi strcasecmp 	attrs apply 
atoi strcasecmp 	filter convert 
keyspace events 	attrs convert attrs 
flags strcasecmp 	ident worktree 
config 	crlf worktree apply 
strcasecmp sentinel 	filter die 
handle configuration 	convert working convert 
sdsfreesplitres sdsfreesplitres 	working convert 
exit sdsempty 	git memmove free 
fopen server 	xcalloc stream 
log 	filter stream filter 
exit fgets 	stream filter 
sdscat fclose 	free stream filter 
sdscat sdscat 	free stream 
load server 	filter free stream 
config sdsfree 	filter stream 
server 	filter xmalloc skip 
info sds 	prefix isspace 
encoded server 	memcpy strbuf strbuf 
info sds 	ident drain 
encoded path 	ident drain 
name reply 	strbuf addch foreign 
error 	ident strbuf 
zfree zstrdup 	setlen strbuf addstr 
sdslen zfree 	strbuf strbuf 
zstrdup zfree 	addch strbuf addch 
zstrdup adjust 	strbuf addstr 
open files 	strbuf addch strbuf 
limit 	release free 
reply error 	xmalloc xsnprintf sha 
format size 	hex strbuf 
resize size 	init convert attrs 
reply error 	ident filter 
yesnotoi stop 	cascade filter output 
append 	eol cascade 
start append 	filter crlf filter 
reply error 	free filter 
sdssplitlen sdslen 	convert convert 
sdsfreesplitres strtoll 	file checking checking 
sdsfreesplitres reset 	use pathname 
server 	decide whether wants 
save strtoll 	interesting conversions 
strtoll append 	automatic gzip unzip 
server save 	general format 
sdsfreesplitres chdir 	conversions etc etc 
reply error 	automatic crlf 
format 	translation text attribute 
strerror sdssplitlen 	crlf option 
sdslen sdsfreesplitres 	stat bits bin 
client type 	txt bits 
name sdsfreesplitres 	unset nul crlf 
memtoll sdsfreesplitres 	counts approximations 
client 	del esc fall 
type name 	file ends 
strtoll strtoll 	eof count eof 
strtoll sdsfreesplitres 	non printable 
keyspace events 	heuristics diff 
flags refresh 	mmfile binary treat 
good 	files bare 
slaves count 	binary fall crl 
refresh good 	would restored 
slaves count 	checkout check crl 
enable watchdog 	safe crlf 
disable watchdog 	fail crl would 
zmalloc 	added checkout 
used memory 	check naked safe 
server log 	crlf fail 
free memory 	dry run source 
needed resize 	buffer nothing 
replication backlog 	analyze must would 
reply 	convert file 
error format 	index convert safer 
reply reply 	autocrlf handling 
error format 	optimization crlf nothing 
deferred multi 	convert regardless 
bulk length 	point source 
server 	analysis done sure 
info sds 	would convert 
encoded config 	dry run mode 
field config 	give answer 
field config 	grow place guessed 
field config 	already know 
field 	rejected file lone 
config field 	strip without 
config field 	looking follow naked 
config numerical 	nothing convert 
field config 	regardless crlf line 
numerical field 	endings touch 
config 	safer autocrlf handling 
numerical field 	faking place 
config numerical 	editing spawn cmd 
field config 	feed buffer 
numerical field 	contents stdin apply 
config numerical 	substitution cmd 
field 	quote path 
config numerical 	preserve spaces etc 
field config 	expand quoted 
numerical field 	path create pipeline 
config numerical 	command filter 
field config 	buffer contents child 
numerical 	cmd error 
field config 	already reported external 
numerical field 	conversion drivers 
config numerical 	configured filter name 
field config 	variable filter 
numerical field 	name smudge filter 
config 	name clean 
numerical field 	specifies command line 
config numerical 	command line 
field config 	command line interpolated 
numerical field 	way scan 
config numerical 	closing dollar 
field 	sign discard grow 
config numerical 	place line 
field config 	next dollar faking 
numerical field 	place editing 
config numerical 	step run next 
field config 	step looks 
numerical 	like bit like 
field config 	xxx step 
numerical field 	skip xxxxx possible 
config numerical 	expanded crept 
field config 	way repository cope 
numerical field 	stripping expansion 
config 	probably good idea 
numerical field 	since cause 
config numerical 	changes checkout won 
field config 	away stash 
numerical field 	keep git style 
config numerical 	ids incomplete 
field 	keyword quit 
config numerical 	loop line next 
field config 	dollar spaces 
numerical field 	unexpected places probably 
config numerical 	versioning system 
field config 	keep wasn xxxx 
numerical 	step substitute 
field config 	attr says attr 
numerical field 	use core 
config numerical 	autocrlf apply filter 
field config 	filter required 
numerical field 	succeed must die 
config 	filter fails 
field config 	original data filtering 
field config 	available supported 
field config 	yet supported yet 
field config 	crlf conversion 
field config 	skipped normalizing unless 
field 	smudge filter 
config field 	filter might 
config field 	expect crl streaming 
config field 	conversion support 
config field 	keep states nothing 
config field 	instances shared 
config 	crlf filter may 
field config 	holding onto 
field config 	see followed would 
field config 	need main 
field config 	loop otherwise emit 
field config 	output stream 
field 	told drain previous 
config field 	round saw 
config field 	followed emit processing 
stringmatch reply 	current character 
bulk reply 	may consumed last 
bulk stringmatch 	output slot 
getcwd 	need loop hold 
reply bulk 	current character 
reply bulk 	returning increment 
stringmatch sdsempty 	cascade filter input 
sdscatprintf sdscatlen 	one buf 
reply bulk 	two output already 
reply 	something feed 
bulk sdsfree 	two feed one 
stringmatch sdsempty 	upstream emit 
sdscatprintf client 	buffer know drained 
type name 	one completely 
sdscatlen reply 	tell two drain 
bulk 	nothing give 
reply bulk 	completely drained two 
sdsfree stringmatch 	ident filter 
snprintf reply 	drain upon eof 
bulk reply 	fallthru skipping 
bulk stringmatch 	keeping foreign ident 
reply 	appropriately constructed 
bulk snprintf 	filter path 
reply bulk 	contents cannot filtered 
stringmatch create 	without reading 
keyspace events 	whole thing core 
flags reply 	note would 
bulk 	crazy crlf smuge 
reply bulk 	clean ident 
decr count 	large binary blob 
stringmatch sdsjoin 	would want 
reply bulk 	slurp memory convert.h 
reply bulk 	path path 
sdsfree 	path convert git 
deferred multi 	path src 
bulk length 	len dst path 
zrealloc dict 	src len 
fetch list 	dst path convert 
create dict 	git filter 
sdsdup 	path path stream 
list node 	filter stream 
tail sdsnew 	filter stream 
dict sdsfree 	filter input isize 
fopen zmalloc 	output osize 
dict create 	convert git copyright 
dict 	google inc 
create fgets 	returns dst used 
sdstrim sdsnew 	precondition would 
strcmp rewrite 	convert git filter 
config append 	path streaming 
line sdssplitargs 	conversion support opaque 
sdsnew 	use much 
sdscatsds sdsfree 	input isize fill 
rewrite config 	output osize 
append line 	update isize osize 
sdstolower rewrite 	indicate much 
config append 	buffer space consumed 
line 	filled success 
rewrite config 	non zero error 
line number 	filters may 
option sdsfreesplitres 	need buffer 
fclose sdsnew 	input look ahead 
dict fetch 	inside decide 
rewrite 	output may consume 
config mark 	zero bytes 
processed sdsfree 	input still produce 
sdsfree list 	output feeding 
first list 	input pass input 
del node 	keep calling 
list 	function filters know 
length dict 	input coming 
sdsfree rewrite 	time produce remaining 
config append 	output buffered 
line sdsnew 	input convert copy.c 
rewrite config 	ifd ofd 
append 	buffer len dst 
line sdsfree 	src times 
snprintf snprintf 	dst src mode 
snprintf snprintf 	fdi fdo 
rewrite config 	status dst 
format memory 	src mode status 
sdscatprintf 	xread write 
sdsempty rewrite 	full stat utime 
config rewrite 	open open 
line sdscatprintf 	close copy error 
sdsempty rewrite 	strerror error 
config rewrite 	strerror close close 
line 	error strerror 
rewrite config 	adjust shared perm 
mark processed 	copy file 
strcmp sdsnew 	copy times count-objects.c 
sdscatlen sdscatrepr 	garbage size 
strlen rewrite 	garbage verbose loose 
config 	packed packed 
rewrite line 	loose loose size 
sdscatprintf sdsempty 	seen bits 
rewrite config 	seen bits path 
rewrite line 	desc path 
sdscatprintf sdsempty 	sha path 
rewrite 	data basename path 
config rewrite 	data count 
line config 	objects usage argc 
name unknown 	argv prefix 
sdscatprintf sdsempty 	human readable opts 
rewrite config 	num pack 
rewrite 	size pack loose 
line config 	buf pack 
name unknown 	buf garbage buf 
sdscatprintf sdsempty 	buf bits 
rewrite config 	msg stat warning 
rewrite 	report garbage 
line sdscatprintf 	lstat isreg loose 
sdsempty rewrite 	garbage disk 
config rewrite 	bytes sha pack 
line rewrite 	loose garbage 
config mark 	parse options 
processed 	usage options report 
getcwd rewrite 	linked checkout 
config mark 	garbage loose file 
processed rewrite 	objdir directory 
config option 	prepare packed git 
rewrite config 	open pack 
mark 	index strbuf humanise 
processed sdscatprintf 	bytes strbuf 
sdsempty rewrite 	humanise bytes strbuf 
config rewrite 	humanise bytes 
line keyspace 	strbuf addf strbuf 
events flags 	addf strbuf 
sdsnew 	addf strbuf release 
sdscatlen sdscatrepr 	strbuf release 
sdslen sdsfree 	strbuf release strbuf 
rewrite config 	humanise bytes 
rewrite line 	strbuf addf strbuf 
rewrite config 	release builtin 
format 	git count 
memory rewrite 	objects copyright junio 
config format 	hamano take 
memory sdscatprintf 	arguments flags credential-cache--daemon.c 
sdsempty client 	socket file 
type name 	item expiration entries 
rewrite 	entries entries 
config rewrite 	alloc timeout wait 
line rewrite 	entry next 
config mark 	action timeout item 
processed sdsjoin 	action timeout 
sdsnew sdscatlen 	pfd wakeup client 
sdscatsds 	client socket 
sdsfree rewrite 	path debug permissions 
config rewrite 	advice path 
line sdsempty 	path copy dir 
sdslen sdscatsds 	argc argv 
sdscatlen sdsfreesplitres 	socket path ignore 
dict 	sighup usage 
release dict 	debug options 
release zfree 	alloc grow memcpy 
dict iterator 	memset time 
dict next 	credential match lookup 
dict val 	credential time 
dict 	credential clear memcpy 
key dict 	strbuf getline 
find server 	skip prefix error 
log list 	strbuf addstr 
length list 	strbuf getline skip 
first sdsfree 	prefix error 
sdsempty 	atoi credential read 
list del 	read request 
node dict 	strcmp lookup credential 
release iterator 	strcmp exit 
open sdslen 	strcmp credential strcmp 
fstat close 	warning warning 
sdsdup 	credential cache credential 
sdsgrowzero memset 	warning credential 
write strlen 	clear strbuf 
ftruncate sdsfree 	release check expirations 
close rewrite 	poll die 
config read 	errno accept warning 
old 	strerror dup 
file rewrite 	warning strerror close 
config yes 	xfdopen xfdopen 
option rewrite 	serve one client 
config option 	fclose fclose 
rewrite config 	unix stream listen 
numerical 	die errno 
option rewrite 	fclose freopen die 
config numerical 	errno serve 
option rewrite 	cache loop close 
config bind 	xstrdup dirname 
option rewrite 	stat die safe 
config 	create leading 
option rewrite 	directories die 
config octal 	errno mkdir die 
option rewrite 	errno chdir 
config numerical 	free git config 
option rewrite 	parse options 
config 	usage options absolute 
numerical option 	path die 
rewrite config 	init socket directory 
option rewrite 	tempfile signal 
config option 	serve cache tempfile 
rewrite config 	take ownership 
yes 	pointers initially give 
option rewrite 	client seconds 
config option 	actually contact store 
rewrite config 	credential decide 
syslogfacility option 	point keeping daemon 
rewrite config 	around stick 
save 	around seconds credential 
option rewrite 	shows removed 
config numerical 	failed one 
option rewrite 	soon correct one 
config yes 	ignore error 
option rewrite 	nothing must sure 
config 	create directory 
yes option 	correct mode chmod 
rewrite config 	fact otherwise 
yes option 	race condition somebody 
rewrite config 	chdir sleep 
option rewrite 	open socket actually 
config 	care cwd 
dir option 	chdir friendly daemon 
rewrite config 	avoid tying 
slaveof option 	original cwd fails 
rewrite config 	without benefit 
option rewrite 	credential-cache.c socket got 
config 	data socket 
yes option 	daemon argv buf 
rewrite config 	socket action 
yes option 	timeout flags 
rewrite config 	buf argc argv 
numerical option 	socket path 
rewrite 	timeout usage options 
config numerical 	unix stream 
option rewrite 	connect write full 
config bytes 	die errno 
option rewrite 	shutdown read full 
config bytes 	die errno 
option 	write die start 
rewrite config 	command die 
yes option 	errno read full 
rewrite config 	die errno 
yes option 	memcmp die close 
rewrite config 	strbuf addf 
numerical 	strbuf addf strbuf 
option rewrite 	read die 
config numerical 	errno send request 
option rewrite 	die errno 
config numerical 	spawn daemon 
option rewrite 	send request die 
config 	errno strbuf 
numerical option 	release parse options 
rewrite config 	usage options 
option rewrite 	expand user path 
config numerical 	die strcmp 
option rewrite 	cache strcmp strcmp 
config 	cache strcmp 
bytes option 	cache ignore unknown 
rewrite config 	operation credential-store.c 
option rewrite 	credential match line 
config numerical 	entry found 
option rewrite 	credential buf extra 
config 	buf fns 
yes option 	fns fns argc 
rewrite config 	argv usage 
option rewrite 	fns file 
config option 	options fopen die 
rewrite config 	errno strbuf 
yes 	getline credential url 
option rewrite 	credential match 
config numerical 	match credential clear 
option rewrite 	strbuf release 
config bytes 	fclose strbuf addch 
option rewrite 	write die 
config 	file hold file 
numerical option 	update die 
rewrite config 	errno print line 
yes option 	parse credential 
rewrite config 	file commit file 
option rewrite 	die errno 
config 	strbuf addf strbuf 
yes option 	addstr urlencode 
rewrite config 	strbuf addch strbuf 
numerical option 	addstr urlencode 
rewrite config 	strbuf addch 
numerical option 	strbuf addstr urlencode 
rewrite 	strbuf addch 
config numerical 	strbuf addstr urlencode 
option rewrite 	rewrite credential 
config numerical 	file strbuf release 
option rewrite 	access store 
config numerical 	credential file store 
option 	credential file 
rewrite config 	access rewrite credential 
numerical option 	file parse 
rewrite config 	credential file umask 
notifykeyspaceevents option 	parse options 
rewrite config 	usage options list 
numerical 	append expand 
option rewrite 	user path list 
config numerical 	append nodup 
option rewrite 	xdg config home 
config numerical 	list append 
option rewrite 	nodup die 
config 	credential read die 
numerical option 	strcmp lookup 
rewrite config 	credential strcmp credential 
numerical option 	strcmp store 
rewrite config 	credential list clear 
numerical option 	sanity check 
rewrite 	storing actually sensible 
config numerical 	particular make 
option rewrite 	url without protocol 
config numerical 	field without 
option rewrite 	either host pathname 
config yes 	depending scheme 
option 	primary key without 
rewrite config 	username password 
yes option 	actually storing credential 
rewrite config 	write credential 
clientoutputbufferlimit option 	filename specified fns 
rewrite config 	items thus 
numerical 	creating sanity 
option rewrite 	check actually something 
config yes 	match input 
option rewrite 	restrictive pattern technically 
config yes 	blank credential 
option rewrite 	means erase everything 
config 	easy accidentally 
option rewrite 	send since equivalent 
config sentinel 	empty input 
option rewrite 	explicitly disallow require 
config orphaned 	pattern actual 
rewrite config 	content match found 
content 	credential ignore 
state rewrite 	unknown operation credential.c 
config overwrite 	want data 
file sdsfree 	key dot want 
rewrite config 	url matched 
release state 	flags desc prompt 
strcasecmp 	line key 
config command 	key cmd 
strcasecmp config 	want output helper 
command strcasecmp 	argv helper 
reset server 	operation cmd url 
stats reset 	colon slash 
command 	host proto end 
table stats 	memset free 
reply strcasecmp 	free free free 
reply error 	free list 
rewrite config 	clear credential init 
server log 	check check 
strerror 	check check skip 
reply error 	prefix config 
format strerror 	error nonbool strrchr 
server log 	xmemdupz credential 
reply reply 	url credential match 
error reply 	credential clear 
error 	free strcmp 
format configuration 	list append strcmp 
file parsing 	xstrdup strcmp 
config commands 	git config strcmp 
implementation copyright 	strcmp git 
salvatore sanfilippo 	config proto http 
antirez 	free strbuf 
gmail dot 	addf strbuf addf 
rights reserved 	strbuf addstr 
redistribution use 	strbuf addf credential 
source binary 	describe strbuf 
forms without 	addf strbuf addf 
modification 	git prompt 
permitted provided 	strbuf release strbuf 
following conditions 	release xstrdup 
met redistributions 	credential ask one 
source code 	credential ask 
must retain 	one strbuf getline 
copyright 	strchr warning 
notice list 	strbuf release 
conditions following 	strcmp free xstrdup 
disclaimer redistributions 	strcmp free 
binary form 	xstrdup strcmp free 
must reproduce 	xstrdup strcmp 
copyright 	free xstrdup strcmp 
notice list 	free xstrdup 
conditions following 	strcmp credential url 
disclaimer documentation 	strcmp git 
materials provided 	config strbuf release 
distribution neither 	credential write 
name 	item credential write 
redis names 	item credential 
contributors may 	write item credential 
used endorse 	write item 
promote products 	credential write item 
derived software 	start command 
without 	xfdopen credential write 
specific prior 	fclose xfdopen 
written permission 	credential read 
software provided 	fclose finish command 
copyright holders 	finish command 
contributors express 	strbuf addstr absolute 
implied 	path strbuf 
warranties including 	addstr strbuf addf 
limited implied 	strbuf addf 
warranties merchantability 	run credential helper 
fitness particular 	strcmp strbuf 
purpose disclaimed 	release credential apply 
shall 	config credential 
copyright owner 	die credential getpass 
contributors liable 	die credential 
direct indirect 	apply config credential 
incidental special 	credential apply 
exemplary consequential 	config credential free 
damages 	free credential 
including limited 	clear strstr strchr 
procurement substitute 	strchr strchrnul 
goods services 	url decode 
loss use 	mem url decode 
data profits 	mem url 
business 	decode mem xmemdupz 
interruption however 	url decode 
caused theory 	mem url decode 
liability whether 	strlen ignore 
contract strict 	lines know mean 
liability tort 	future proofs 
including 	later versions git 
negligence otherwise 	learn lines 
arising way 	helpers updated match 
use software 	match one 
even advised 	proto host proto 
possibility damage 	user host 
config 	proto user pass 
file name 	host trim 
maps output 	leading trailing 
buffer limits 	slashes path usage 
presets normal 	msg argc 
slave pubsub 	argv prefix usage 
access 	credential read 
functions name 	die strcmp credential 
match min 	fill credential 
returned name 	write strcmp credential 
match found 	approve strcmp 
returned wrapper 	credential reject usage 
config 	ignore lines 
name returning 	know mean future 
unknown insetad 	proofs later 
match used 	versions git learn 
info generation 	lines helpers 
config file 	updated match match 
parsing 	one proto 
skip comments 	host proto user 
blank lines 	host proto 
split arguments 	user pass 
skip line 	host trim leading 
resulting command 	trailing slashes 
vector 	path credential.c want 
empty execute 	data key 
config directives 	dot want url 
test able 	matched flags 
open file 	desc prompt line 
server able 	key key 
abort 	cmd want output 
problem later 	helper argv 
dead option 	helper operation cmd 
dead option 	url colon 
target command 	slash host proto 
name empty 	end memset 
command 	free free free 
table otherwise 	free free 
command different 	list clear credential 
name argc 	init check 
handled main 	check check 
need enter 	check skip prefix 
sentinel 	config error 
mode asap 	nonbool strrchr xmemdupz 
sanity checks 	credential url 
load server 	credential match credential 
configuration specified 	clear free 
filename function 	strcmp list append 
appends 	strcmp xstrdup 
additional configuration 	strcmp git config 
directives stored 	strcmp strcmp 
options config 	git config proto 
file loading 	http free 
filename options 	strbuf addf strbuf 
considered 	addf strbuf 
empty way 	addstr strbuf addf 
load server 	credential describe 
config used 	strbuf addf strbuf 
load file 	addf git 
load load 	prompt strbuf 
file 	release strbuf release 
content append 	xstrdup credential 
additional options 	ask one credential 
config implementation 	ask one 
starts config 	strbuf getline strchr 
macros chain 	warning strbuf 
special 	release strcmp free 
fields handled 	xstrdup strcmp 
general macros 	free xstrdup strcmp 
check capable 	free xstrdup 
supporting many 	strcmp free xstrdup 
perform sanity 	strcmp free 
check 	xstrdup strcmp credential 
setting config 	url strcmp 
even number 	git config strbuf 
args seconds 	release credential 
changes config 	write item 
need multiple 	credential write item 
hard 	credential write 
soft soft 	item credential write 
seconds sanity 	item credential 
check single 	write item start 
arguments either 	command xfdopen 
refuse whole 	credential write fclose 
configuration 	xfdopen credential 
accept even 	read fclose finish 
single error 	command finish 
single client 	command strbuf addstr 
present config 	absolute path 
fields config 	strbuf addstr strbuf 
field 	addf strbuf 
name numerical 	addf run credential 
fields config 	helper strcmp 
numerical field 	strbuf release credential 
name min 	apply config 
max cast 	credential die 
hint 	credential getpass die 
user accept 	credential apply 
values range 	config credential credential 
cap reasonable 	apply config 
values memory 	credential free free 
fields config 	credential clear 
memory 	strstr strchr strchr 
field name 	strchrnul url 
enumeration fields 	decode mem url 
config field 	decode mem 
name everyhing 	url decode mem 
error success 	xmemdupz url 
options 	decode mem url 
bad format 	decode strlen 
errors config 	ignore lines know 
implementation values 	mean future 
numerical values 	proofs later versions 
yes 	git learn 
values values 	lines helpers 
everything handle 	updated match match 
macros follows 	one proto 
config rewrite 	host proto user 
implementation use 	host proto 
following 	user pass host 
dictionary type 	trim leading 
store configuration 	trailing slashes path 
option mentioned 	usage msg 
old configuration 	argc argv prefix 
file like 	usage credential 
maxmemory 	read die strcmp 
list line 	credential fill 
numbers first 	credential write strcmp 
line zero 	credential approve 
sentinel config 	strcmp credential reject 
rewriting implemented 	usage ignore 
inside 	lines know mean 
sentinel rewrite 	future proofs 
config sentinel 	later versions 
option hash 	git learn lines 
function key 	helpers updated 
dup val 	match match one 
dup 	proto host 
key compare 	proto user host 
key destructor 	proto user 
val destructor 	pass host trim 
hash function 	leading trailing 
key dup 	slashes path credential.h 
val 	helpers username 
dup key 	password protocol host 
compare key 	path credential 
destructor val 	credential credential credential 
destructor config 	credential credential 
rewrite state 	credential credential url 
option 	want credential 
list config 	csum-file.c buf count 
file lines 	check buffer 
map dictionary 	ret ret 
already processed 	offset result flags 
options number 	discard cnt 
lines 	buf count offset 
current config 	left data 
current lines 	name name sink 
sds already 	check name 
added directives 	checkpoint checkpoint offset 
present original 	read full 
config 	die errno die 
file append 	memcmp die 
line current 	xwrite display throughput 
configuration state 	die die 
populate option 	errno git sha 
list line 	update flush 
numbers 	sha flush git 
map specified 	sha hashcpy 
option processed 	flush fsync 
options useful 	die close die 
unused lines 	errno read 
processed options 	full die errno 
blanked 	die close 
config file 	die errno free 
options rewrite 	crc memcpy 
process understand 	git sha update 
remain untouched 	flush sha 
read old 	throughput open die 
file 	errno open 
split lines 	die errno sha 
populate newly 	xmalloc git 
created config 	sha init sha 
rewrite state 	flush ftruncate 
caller impossible 	lseek crc csum 
read 	file copyright 
old file 	linus torvalds simple 
returned old 	file write 
file exist 	infrastructure writing 
empty state 	sha summed files 
returned read 	useful write 
old 	file want able 
file line 	verify hasn 
line populate 	messed afterwards write 
state zero 	checksum close 
init handle 	process full buffer 
comments empty 	directly without 
lines 	copy sha flush 
comment split 	called checkpoint 
arguments apparently 	csum-file.h check offset 
line unparsable 	ctx total 
reason instance 	name crc crc 
may unbalanced 	buffer offset 
quotes 	ctx sha file 
load comment 	sha file 
want lowercase 	checkpoint sha file 
config directives 	sha file 
populate state 	checkpoint name 
according content 	name name sha 
line 	file sha 
append line 	file sha file 
populate option 	sha file 
line numbers 	data data sha 
map rewrite 	write htonl 
specified configuration 	sha write sha 
option 	file checkpoint 
line progressively 	sha close flags 
uses lines 	ctype.c sane 
file already 	ctype tolower trans 
used configuration 	tbl sane 
option old 	locale independent ascii 
version 	ctype surprises 
file removing 	works chars non 
line map 	alnum nothing 
options line 	range insensitive kwset 
numbers lines 	daemon.c log 
associated given 	syslog verbose 
configuration 	reuseaddr informative errors 
option force 	daemon usage 
non zero 	paths strict paths 
line appended 	export trees 
configuration file 	path interpolated path 
usually force 	path relaxed 
option 	user path timeout 
must rewritten 	init timeout 
even present 	hostname canon hostname 
previously first 	address tcp 
time line 	port priority err 
appended configuration 	buf err 
file 	err err directory 
comment added 	hostinfo placeholder 
show starting 	ctx context directory 
point config 	rpath interp 
file generated 	path path 
config rewrite 	dir namlen restlen 
line 	slash expanded 
either used 	path context pathlen 
freed caller 	len name 
need free 	config name enabled 
way option 	overridable dir 
used previously 	msg access hook 
forced 	service dir 
use still 	path child buf 
lines old 	argv arg 
configuration file 	eol seen errors 
reuse option 	dir service 
replace line 	path enabled line 
one 	argv cld 
append line 	timeout buf argv 
write bytes 	argv argv 
way parsable 	daemon service name 
inside redis 	ena name 
conf possible 	ena hostport 
uses 	host port end 
notation rewrite 	extra args 
simple option 	buflen val vallen 
name bytes 	end host 
configuration option 	port hints gai 
rewrite yes 	addrbuf sin 
option 	addr hent addrbuf 
rewrite option 	line pktlen 
options need 	len port arg 
present configuration 	max connections 
file next 	live children next 
reboot force 	cld address 
zero 	cld addr addrlen 
rewrite numerical 	newborn cradle 
range option 	blanket next status 
rewrite octal 	pid cradle 
option rewrite 	blanket dead cld 
enumeration option 	argv incoming 
takes 	addr addrlen 
usually state 	cld buf sin 
option name 	addr buf 
addition enumeration 	sin addr signo 
option rewrite 	sockfd list 
syslog facility 	alloc family sin 
option 	len listen 
rewrite save 	addr listen port 
option note 	socklist socknum 
save parameters 	pbuf hints gai 
current config 	flags sockfd 
line save 	listen addr listen 
detected 	port socklist 
orphaned deleted 	sin sockfd flags 
resulting rdb 	listen addr 
persistence expected 	listen port socklist 
mark save 	socknum socklist 
processed server 	pfd sai sai 
saveparamslen 	sslen incoming 
zero rewrite 	cred user 
dir option 	name name pass 
always absolute 	gid cred 
paths rewrite 	user name name 
error rewrite 	listen addr 
slaveof 	listen port cred 
option master 	socklist argc 
want slaveof 	argv listen port 
config options 	listen addr 
file removed 	inetd mode name 
note cluster 	detach cred 
instance 	arg end lookup 
want slaveof 	hostname lookup 
directive inside 	hostname vsnprintf syslog 
redis conf 	getpid vfprintf 
rewrite notify 	fputc fflush start 
keyspace events 	logreport end 
option 	start logreport 
rewrite client 	end logreport exit 
output buffer 	strbuf addbuf 
limit option 	strbuf addstr canon 
rewrite bind 	hostname strbuf 
option nothing 	addstr address strbuf 
rewrite 	addbuf strbuf 
bind addresses 	addstr daemon avoid 
rewrite bind 	logerror logerror 
addr addr 	strlen strchr loginfo 
addr glue 	snprintf logerror 
together configuration 	strbuf expand strlcpy 
lines 	strbuf release 
current configuration 	loginfo logerror snprintf 
rewrite state 	enter repo 
single stripping 	enter repo logerror 
multiple empty 	strlen strlen 
lines every 	memcmp logerror packet 
cluster 	write canon 
empty lines 	hostname address 
turned single 	start command logerror 
empty line 	strbuf read 
free configuration 	logerror strbuf reset 
rewrite state 	close logerror 
end 	finish command strbuf 
rewrite process 	release strbuf 
state contains 	ltrim strbuf addstr 
remaining map 	strchr daemon 
option name 	error strbuf release 
lines original 	loginfo logerror 
config 	daemon error path 
file lines 	daemon error 
used rewrite 	access logerror daemon 
process removed 	error strbuf 
function rewrite 	addf git config 
config rewrite 	strbuf release 
line 	logerror daemon error 
lines orphaned 	run access 
replaced empty 	hook signal 
lines function 	fdopen logerror close 
iterating option 	strbuf getline 
names blanking 	logerror strbuf setlen 
lines 	strbuf release 
still associated 	fclose start command 
blank lines 	close close 
options rewrite 	copy log finish 
process understand 	command snprintf 
function overwrites 	run service command 
old 	run service 
configuration file 	command run service 
content old 	command size 
file length 	strcmp die size 
obtained content 	strcmp die 
smaller padding 	strchr die die 
added 	strrchr strbuf 
single write 	addch strbuf setlen 
call used 	sanitize client 
replace content 	strbuf tolower 
file later 	strncasecmp strlen parse 
file truncated 	host port 
length 	sanitize client canonicalize 
content way 	client die 
sure file 	memset getaddrinfo inet 
left consistent 	ntop strbuf 
state even 	addstr sanitize client 
process stopped 	strbuf addbuf 
four 	freeaddrinfo gethostbyname memset 
operations function 	htons memcpy 
returns success 	inet ntop sanitize 
otherwise returned 	client strbuf 
errno accordingly 	addstr memset strbuf 
open old 	init strbuf 
file 	init strbuf init 
create one 	strbuf init 
exist size 	strbuf release strbuf 
errno open 	release strbuf 
errno fstat 	release strbuf 
pad content 	release getenv hostinfo 
least 	init loginfo 
match old 	alarm packet read 
file size 	alarm strlen 
old file 	loginfo parse host 
bigger pad 	arg size 
content newline 	skip prefix skip 
plus 	prefix run 
many chars 	service hostinfo clear 
required write 	hostinfo clear 
content single 	logerror memcmp memcmp 
write truncate 	xcalloc memcpy 
file right 	memcpy addrcmp addrcmp 
length 	kill waitpid 
used padding 	loginfo child process 
non critical 	clear free 
error rewrite 	kill child 
configuration file 	sleep check dead 
path configuration 	children close 
file 	logerror inet ntop 
already exists 	argv pushf 
best retain 	argv pushf ntohs 
comments overall 	inet ntop 
structure configuration 	argv pushf argv 
parameters unless 	pushf ntohs 
already 	dup start command 
explicitly included 	logerror child 
old configuration 	signal setsockopt inet 
file rewritten 	ntop inet 
error returned 	ntop xsnprintf xsnprintf 
errno accordingly 	memset getaddrinfo 
otherwise 	logerror gai strerror 
step read 	socket logerror 
old config 	close setsockopt reuse 
rewrite state 	addr logerror 
step rewrite 	strerror close 
every single 	bind logerror str 
option 	strerror close 
replacing appending 	listen logerror str 
inside rewrite 	strerror close 
state rewrite 	fcntl fcntl alloc 
sentinel config 	grow freeaddrinfo 
sentinel mode 	memset htons inet 
step 	pton htonl 
orphaned lines 	socket reuse addr 
old file 	logerror strerror 
lines used 	close bind logerror 
config option 	str strerror 
longer used 	close listen logerror 
like 	str strerror 
multiple save 	close fcntl fcntl 
options duplicated 	alloc grow 
options step 	setup named sock 
generate configuration 	setup named 
file modified 	sock logerror 
state 	xcalloc signal check 
write original 	dead children 
file config 	poll logerror strerror 
command entry 	sleep accept 
point config.h 	die errno handle 
argc argv 	die initgroups 
fmt 	setgid setuid die 
copyright salvatore 	getpwnam die 
sanfilippo antirez 	getgrnam die socksetup 
gmail dot 	die drop 
rights reserved 	privileges loginfo service 
redistribution use 	loop git 
source 	setup gettext git 
binary forms 	extract argv 
without modification 	path skip prefix 
permitted provided 	list append 
following conditions 	xstrdup tolower skip 
met redistributions 	prefix strtoul 
source 	strcmp strcmp 
code must 	strcmp strcmp strcmp 
retain copyright 	skip prefix 
notice list 	skip prefix atoi 
conditions following 	skip prefix 
disclaimer redistributions 	atoi skip prefix 
binary 	atoi strcmp 
form must 	skip prefix strcmp 
reproduce copyright 	skip prefix 
notice list 	strcmp strcmp skip 
conditions following 	prefix skip 
disclaimer documentation 	prefix strcmp skip 
materials 	prefix skip 
provided distribution 	prefix skip prefix 
neither name 	enable service 
redis names 	skip prefix enable 
contributors may 	service skip 
used endorse 	prefix make 
promote 	service overridable skip 
products derived 	prefix make 
software without 	service overridable strcmp 
specific prior 	strcmp strcmp 
written permission 	usage openlog die 
software provided 	routine setvbuf 
copyright 	die die die 
holders contributors 	prepare credentials 
express implied 	die directory die 
warranties including 	freopen die 
limited implied 	errno execute daemonize 
warranties merchantability 	die sanitize 
fitness 	stdfds write file 
particular purpose 	getpid argv 
disclaimed shall 	push argv push 
copyright owner 	argv push 
contributors liable 	serve nothing list 
direct indirect 	acceptable pathname 
incidental 	prefixes git 
special exemplary 	daemon export required 
consequential damages 	take paths 
including limited 	relative one non 
procurement substitute 	defined user 
goods services 	notation allowed inserted 
loss 	user request 
use data 	git host alice 
profits business 	frotz would 
interruption however 	home alice pub 
caused theory 	git frotz 
liability whether 	user path pub 
contract 	git timeout 
strict liability 	initial timeout since 
tort including 	stderr buffered 
negligence otherwise 	mode logging different 
arising way 	processes overlap 
use software 	unless overflow rather 
even 	big buffers 
advised possibility 	got either 
damage define 	alice alice foo 
redis fstat 	rewrite alice 
fstat fstat 	alice foo allow 
test proc 	absolute allow 
filesystem 	absolute fail path 
test task 	relaxed enabled 
info test 	without prefixing path 
backtrace msg 	validation done 
nosignal test 	paths enter repo 
polling api 	appends optional 
define 	git git git 
aof fsync 	friends use 
fdatasync linux 	getcwd pub symlink 
fsync rest 	mnt pub 
define rdb 	whitelist pub say 
fsync range 	mnt pub 
sync 	say pub backwards 
file range 	compatible fallthrough 
linux otherwise 	deny security 
use plain 	cheap want readable 
fsync call 	head usable 
check use 	objects directory git 
setproctitle 	daemon export 
bsd systems 	flag says side 
support provide 	path uses 
implementation linux 	enter repo whitelist 
osx ordering 	checking need 
detection 	make sure repository 
likely define 	exported optionally 
order least 	hook choose deny 
significant first 	access repository 
vax significant 	depending phase moon 
first ibm 	ignore sigterm 
net 	good client timeout 
lsb first 	sanitize client 
word msw 	inserted filesystem 
first pdp 	path specifically disallow 
linux bsd 	slashes runs 
order sometimes 	trailing leading dots 
including 	means client 
specific header 	cannot escape path 
defines endianess 	via traversal 
end order 	like sanitize client 
order redis 	also perform 
code uses 	canonicalization make life 
define 	easier admin 
everything without 	read host supplied 
underscores must 	client connection 
determine correct 	split host port 
bit order 	colon next 
compiler next 	one locate canonical 
line 	hostname address 
intentional error 	note directory probably 
force compiles 	context sensitive 
bomb fix 	might depend 
macros crc16.c 	actual service performed 
crc tab 	gets called 
buf 	number connections grows 
len counter 	past max 
crc copyright 	connections kill newest 
georges menie 	connection duplicate 
www menie 	child give time 
copyright salvatore 	die otherwise 
sanfilippo 	empty handler systemcalls 
adapted redis 	interrupted upon 
coding style 	signal receipt sys 
rights reserved 	needs handler 
redistribution use 	rearmed note error 
source binary 	fatal fatal 
forms 	fatal ipv well 
without modification 	host better 
permitted provided 	address nothing unlimited 
following conditions 	avoid splitting 
met redistributions 	message middle 
source code 	prepare argv serving 
must 	processes git 
retain copyright 	daemon date.c mdays 
notice list 	year month 
conditions following 	day month names 
disclaimer redistributions 	weekday names 
binary form 	time minutes time 
must 	time local 
reproduce copyright 	offset eastwest time 
notice list 	timebuf diff 
conditions following 	totalmonths years months 
disclaimer documentation 	date mode 
materials provided 	type time mode 
distribution 	timebuf sign 
neither name 	name offset dst 
university california 	date str 
berkeley names 	date date offset 
contributors may 	match match 
used endorse 	match year 
promote 	month day check 
products derived 	specified num 
software without 	date end refuse 
specific prior 	future num 
written permission 	num date offset 
software provided 	gmt end 
regents 	num time match 
contributors express 	minutes hours 
implied warranties 	date offp end 
including limited 	hour min 
implied warranties 	offset date offset 
merchantability fitness 	buf sign 
particular 	date timestamp offset 
purpose disclaimed 	end stamp 
shall regents 	ofs date timestamp 
contributors liable 	offset gmt 
direct indirect 	dummy timestamp dummy 
incidental special 	offset match 
exemplary 	temp time 
consequential damages 	date timestamp errors 
including limited 	date result 
procurement substitute 	timestamp offset offset 
goods services 	sec num 
loss use 	num hour num 
data 	num num 
profits business 	num hour num 
interruption however 	hour num 
caused theory 	name number name 
liability whether 	type length 
contract strict 	date num touched 
liability 	end match 
tort including 	len len len 
negligence otherwise 	match diff 
arising way 	date num end 
use software 	number match 
even advised 	num number 
possibility 	date error ret 
damage crc 	number touched 
implementation according 	time sec date 
ccitt standards 	timestamp offset 
note antirez 	errors date error 
actually xmodem 	ret timestamp 
crc 	offset dummy sys 
algorithm following 	time gmtime 
parameters name 	localtime time strbuf 
xmodem also 	addstr strbuf 
known zmodem 	addf strbuf addf 
crc acorn 	strbuf addf 
width 	strbuf addf strbuf 
bit poly 	addf strbuf 
actually initialization 	addf strbuf addf 
reflect input 	strbuf addf 
reflect output 	strbuf release strbuf 
crc xor 	addf strbuf 
constant 	addf local 
output crc 	tzoffset strbuf reset 
output crc64.c 	strbuf addf 
crc tab 	strbuf reset gettimeofday 
crc argc 	show date 
argv unused 	relative time time 
unused 	strbuf reset 
crc redis 	strbuf addf strbuf 
uses crc 	addf abs 
variant jones 	strbuf addf strbuf 
coefficients init 	addf strbuf 
specification crc 	addftime strbuf addf 
variant 	toupper toupper 
follows name 	isalnum isalpha match 
crc jones 	match size 
width bites 	match strlen match 
poly xad 	match skip 
reflected xor 	alpha time strtol 
xffffffffffffffff 	isdigit strtol 
reflected xor 	time gmtime 
check copyright 	date date date 
salvatore sanfilippo 	date date 
antirez gmail 	strtoul nodate gmtime 
dot rights 	isdigit match 
reserved 	multi number isdigit 
redistribution use 	strtoul strtoul 
source binary 	strbuf addf strtoul 
forms without 	strtol memset 
modification permitted 	match header date 
provided following 	isalpha match 
conditions 	alpha isdigit match 
met redistributions 	digit isdigit 
source code 	match time mktime 
must retain 	strcmp strcmp 
copyright notice 	strcmp strcmp approxidate 
list conditions 	careful parse 
following 	date basic date 
disclaimer redistributions 	skip prefix 
binary form 	skip prefix 
must reproduce 	skip prefix skip 
copyright notice 	prefix skip 
list conditions 	prefix skip prefix 
following 	skip prefix 
disclaimer documentation 	skip prefix skip 
materials provided 	prefix skip 
distribution neither 	prefix die strcmp 
name redis 	parse date 
names contributors 	type skip prefix 
may 	skip prefix 
used endorse 	die xstrdup die 
promote products 	time time 
derived software 	localtime date mktime 
without specific 	localtime update 
prior written 	update date yesterday 
permission 	date time 
software provided 	date time 
copyright holders 	date time localtime 
contributors express 	isalpha match 
implied warranties 	strlen match strlen 
including limited 	match match 
implied 	strlen match update 
warranties merchantability 	match update 
fitness particular 	match update match 
purpose disclaimed 	update strtoul 
shall copyright 	isdigit match multi 
owner contributors 	number localtime 
liable 	isdigit pending number 
direct indirect 	approxidate digit 
incidental special 	isalpha approxidate alpha 
exemplary consequential 	pending number 
damages including 	update parse date 
limited procurement 	basic approxidate 
substitute 	str parse date 
goods services 	basic gettimeofday 
loss use 	approxidate str 
data profits 	git information manager 
business interruption 	hell copyright 
however caused 	linus torvalds like 
theory 	mktime without 
liability whether 	normalization wday yday 
contract strict 	algo works 
liability tort 	bounds thing passed 
including negligence 	strange parse 
otherwise arising 	thing means passed 
way 	integer even 
use software 	though means sixty 
even advised 	minutes effect 
possibility damage 	back time local 
test main 	timezone minutes 
crc64.h crc 	turn minutes turn 
argc 	hours deal 
argv ctl.c 	number days say 
ctl mtx 	weeks past 
ctl initialized 	weeks say 
ctl epoch 	months past months 
ctl stats 	give years 
node 	months years translators 
node index 	years otherwise 
children node 	years centuries probably 
astats astats 	overkill check 
cstats arena 	note doesn summer 
sstats astats 	time conversion 
arena 	world always summer 
name nodesp 	things probably 
mibp depthp 	bit ways international 
arena ind 	date line 
tcache node 	west nome central 
prof node 	alaska hawaii 
node 	standard hawaii daylight 
config node 	yukon standard 
opt node 	yukon daylight pacific 
tcache node 	standard pacific 
arena node 	daylight mountain 
arena node 	standard mountain daylight 
arena 	central standard 
node arenas 	central daylight eastern 
bin node 	standard eastern 
arenas bin 	daylight atlantic standard 
node arenas 	atlantic daylight 
bin node 	west africa greenwich 
arenas 	mean universal 
lrun node 	coordinated zulu utc 
arenas lrun 	western european 
node arenas 	british summer central 
lrun node 	european middle 
arenas hchunk 	european middle european 
node 	winter middle 
arenas hchunk 	european summer central 
node arenas 	european summer 
hchunk node 	middle european 
arenas node 	summer french winter 
prof node 	french summer 
stats 	eastern europe ussr 
arenas metadata 	zone eastern 
node stats 	european daylight west 
arenas small 	australian standard 
node stats 	west australian daylight 
arenas large 	china coast 
node 	ussr zone japan 
stats arenas 	standard ussr 
huge node 	zone eastern australian 
stats arenas 	standard eastern 
bins node 	australian daylight guam 
stats arenas 	standard ussr 
bins 	zone zealand zealand 
node stats 	standard zealand 
arenas bins 	daylight international date 
node stats 	line east 
arenas lruns 	parse month 
node stats 	weekday timezone name 
arenas 	bogus like 
lruns node 	summer use name 
stats arenas 	offset anything 
lruns node 	better bad crap 
stats arenas 	commit time 
hchunks node 	author time make 
stats 	sense specify 
arenas hchunks 	timestamp way future 
node stats 	make sure 
arenas hchunks 	later ten days 
node stats 	time date 
arenas node 	yyyy yyyy eastern 
stats 	european friends 
arenas node 	say norm giving 
stats arenas 	precedence form 
node stats 	separator european funny 
node root 	funny european 
node root 	filled part 
node 	time date yet 
astats astats 	binary see 
cstats arena 	sign bit values 
sstats astats 	seen digit 
arena astats 	time year date 
sstats astats 	seconds since 
tstats 	trigger numbers digits 
tsd refreshed 	want rule 
initialized allocated 	numbers like yyyymmdd 
resident mapped 	date check 
ret name 	special formats num 
nodesp mibp 	num num 
depthp 	none special formats 
ret elm 	guess number 
tdot dot 	meant use number 
elen node 	digits make 
pnode child 	educated guess four 
index inode 	digit year 
name 	timezone ignore 
oldp oldlenp 	lots numerals took 
newp newlen 	care digit 
ret depth 	years days months 
nodes mib 	must one 
node name 	two digits note 
mibp 	give precedence 
miblenp ret 	day month month 
mib miblen 	year numbers 
oldp oldlenp 	range always mday 
newp newlen 	unless already 
ret node 	mday iow apr 
inode 	parses april 
mib miblen 	two digit year 
oldp oldlenp 	hhmm random 
newp newlen 	crap random crap 
ret newval 	otherwise parsed 
mib miblen 	accept random crap 
oldp 	even though 
oldlenp newp 	places offset 
newlen ret 	larger hours pacific 
tsd oldarena 	kiritimati utc 
newind oldind 	something wrong hour 
newarena tcache 	part much 
mib 	larger might also 
miblen oldp 	want check 
oldlenp newp 	minutes divisible something 
newlen ret 	offset kathmandu 
oldval mib 	nepal utc parse 
miblen oldp 	like ancient 
oldlenp 	timestamp near epoch 
newp newlen 	appears part 
ret mib 	strptime crap doesn 
miblen oldp 	way require 
oldlenp newp 	rfc english day 
newlen ret 	month names 
tsd 	doesn work 
oldname mib 	correctly success stop 
miblen oldp 	end newline 
oldlenp newp 	bad crap use 
newlen ret 	mktime uses 
oldval mib 	local timezone gmtime 
miblen 	match digit 
oldp oldlenp 	may clobbered success 
newp newlen 	take usually 
ret tsd 	translates current timestamp 
tcache ind 	user really 
mib miblen 	means expire everything 
oldp 	done past 
oldlenp newp 	definition reflogs record 
newlen ret 	past nothing 
tsd tcache 	future kept historical 
ind mib 	relative time 
miblen oldp 	update days ago 
oldlenp 	haven time 
newp newlen 	yet need 
ret tsd 	current time fill 
tcache ind 	date fields 
arena ind 	needed fill date 
tsd refreshed 	fields needed 
mib 	accept zero padding 
miblen oldp 	small numbers 
oldlenp newp 	dec never dec 
newlen ret 	pending number 
mib miblen 	end see one 
oldp oldlenp 	month day 
newp 	dec screw number 
newlen ret 	overflowed bad 
dss arena 	also going feed 
ind dss 	result system 
prec old 	functions expect time 
dss prec 	often make 
match 	sure fit time 
arena mib 	well decorate.c 
miblen oldp 	obj decoration 
oldlenp newp 	size hash old 
newlen ret 	old size 
arena ind 	old hash decoration 
arena 	obj decoration 
oldval mib 	obj sha hash 
miblen oldp 	hash obj 
oldlenp newp 	xcalloc insert decoration 
newlen ret 	free grow 
arena ind 	decoration insert decoration 
arena 	hash obj 
old chunk 	decorate decorate git 
hooks chunk 	arbitrary data 
hooks old 	decoration pointer old 
chunk hooks 	one lookup 
mib miblen 	decoration pointer nothing 
ret 	lookup decorate.h 
mib miblen 	decoration name size 
oldp oldlenp 	hash obj 
newp newlen 	decoration obj 
ret narenas 	delta.h buf bufsize 
mib miblen 	index index 
oldp 	index buf bufsize 
oldlenp newp 	delta size 
newlen ret 	max delta size 
nread mib 	src buf 
miblen oldp 	src bufsize trg 
oldlenp newp 	buf trg 
newlen 	bufsize delta size 
ret oldval 	max delta 
mib miblen 	size index delta 
mib miblen 	src buf 
mib miblen 	src size delta 
mib miblen 	buf delta 
oldp 	size dst size 
oldlenp newp 	datap top 
newlen ret 	data cmd 
narenas mib 	size create delta 
miblen oldp 	index create 
oldlenp newp 	delta free delta 
newlen 	index opaque 
ret oldval 	delta index create 
mib miblen 	delta index 
oldp oldlenp 	compute index data 
newp newlen 	given buffer 
ret oldval 	returns pointer delta 
mib 	index passed 
miblen oldp 	subsequent create delta 
oldlenp newp 	calls free 
newlen ret 	delta index pointer 
filename mib 	returned failure 
miblen oldp 	given buffer must 
oldlenp 	freed altered 
newp newlen 	free delta index 
ret oldval 	called returned 
mib miblen 	pointer must 
oldp oldlenp 	freed free delta 
newp 	index free 
newlen ret 	delta index free 
sample tsd 	index created 
mib miblen 	create delta index 
mib miblen 	given pointer 
mib miblen 	must create delta 
mib 	index returned 
miblen ret 	delta index returns 
ctl named 	memory usage 
node malloc 	delta index given 
malloc memset 	pointer must 
memset memset 	create delta index 
memset 	returned create 
arena stats 	delta create delta 
merge index 	given index 
size ctl 	given buffer function 
arena clear 	may called 
ctl arena 	multiple times 
stats 	different buffers delta 
amerge ctl 	index pointer 
arena stats 	max delta size 
smerge arena 	non zero 
init malloc 	resulting delta larger 
memcpy memset 	max delta 
ctl 	size returned success 
arena init 	non pointer 
dalloc memcpy 	buffer delta data 
memcpy memcpy 	returned delta 
dalloc variable 	size updated size 
ctl arena 	returned buffer 
clear 	must freed caller 
tsd fetch 	diff delta 
arena arena 	create delta source 
arena nbound 	buffer target 
ctl arena 	buffer max delta 
refresh stats 	size non 
malloc 	zero resulting 
mutex narenas 	delta larger max 
total malloc 	delta size 
memset ctl 	returned success non 
arena init 	pointer buffer 
dalloc dalloc 	delta data returned 
dalloc 	delta size 
ctl refresh 	updated size returned 
malloc mutex 	buffer must 
unlock strchr 	freed caller patch 
strchr size 	delta recreate 
ctl named 	target buffer given 
node 	source buffer 
ctl named 	delta data success 
children strlen 	non pointer 
strncmp malloc 	target buffer returned 
strtoumax ctl 	trg bufsize 
indexed node 	updated size 
index 	failure pointer returned 
strchr strchr 	returned buffer 
size ctl 	must freed caller 
init ctl 	smallest possible 
lookup ctl 	delta size bytes 
named node 	must called 
ctl 	twice delta data 
ctl init 	buffer first 
ctl lookup 	expected source buffer 
ctl init 	size target 
ctl named 	buffer size describe.c 
node ctl 	describe usage 
named 	debug tags longformat 
children ctl 	first parent 
indexed node 	abbrev max candidates 
index ctl 	names pattern 
malloc mutex 	always dirty diff 
init malloc 	index args 
mutex 	entry peeled 
prefork malloc 	tag sha path 
mutex postfork 	prio names 
parent malloc 	peeled peeled prio 
mutex postfork 	sha tag 
child malloc 	path peeled prio 
mutex 	sha tag 
write ctl 	path oid flag 
refresh read 	data tag 
malloc mutex 	peeled annotated prio 
unlock tsd 	name depth 
fetch arena 	found order flag 
choose 	within list 
malloc mutex 	best seen commits 
write read 	parents depth 
arena arena 	sha arg last 
migrate tsd 	one sha 
tcache tcache 	cmit gave list 
arena 	matches cur 
reassociate malloc 	match seen 
mutex unlock 	commits unannotated cnt 
tcache enabled 	iter parents 
tcache enabled 	oid argc argv 
read writeonly 	prefix contains 
tcache 	options args index 
flush read 	hashcmp hashmap 
xor write 	hash sha hash 
tsd fetch 	lookup tag 
prof name 	parse tag lookup 
prof name 	tag parse 
read 	tag find commit 
prof active 	name replace 
prof active 	name xmalloc hashcpy 
read tsd 	hashmap entry 
fetch malloc 	init sha hash 
mutex tcaches 	hashmap hashcpy 
create 	free xstrdup starts 
read malloc 	wildmatch peel 
mutex unlock 	oidcmp oidcpy 
tsd fetch 	known names pop 
writeonly write 	commit parse 
tcaches flush 	commit commit list 
tsd 	insert date 
fetch writeonly 	lookup tag parse 
write tcaches 	tag die 
destroy variable 	die strcmp warning 
tsd fetch 	find unique 
arena arena 	abbrev sha die 
arena 	lookup commit 
purge arena 	reference die find 
purge writeonly 	commit name 
malloc mutex 	display name show 
arena purge 	suffix die 
malloc mutex 	oid hex hashmap 
unlock 	iter first 
malloc mutex 	hashmap iter next 
write strcmp 	lookup commit 
arena tsd 	reference gently 
fetch arena 	commit list insert 
dss prec 	pop commit 
arena 	oid hex parse 
dss prec 	commit commit 
chunk dss 	list insert date 
prec chunk 	find unique 
dss prec 	abbrev die oid 
read malloc 	hex die 
mutex 	oid hex qsort 
unlock arena 	commit list 
tsd fetch 	insert date finish 
arena dirty 	depth computation 
mult read 	free commit list 
arena dirty 	oid hex 
mult 	display name show 
malloc mutex 	suffix clear 
narenas total 	commit marks 
arena tsd 	git config parse 
fetch write 	options die 
chunk hooks 	argv init argv 
read 	pushl argv 
chunk hooks 	push argv push 
read malloc 	argv pushf 
mutex unlock 	argv pushv argv 
malloc mutex 	push cmd 
malloc mutex 	name rev hashmap 
unlock 	init rawref 
malloc mutex 	die read cache 
read malloc 	preload refresh 
mutex unlock 	index hold locked 
malloc mutex 	index update 
malloc mutex 	index able cmd 
unlock 	diff index 
arena dirty 	size describe die 
mult read 	describe display 
arena dirty 	lots verbose 
mult malloc 	info valid used 
mutex ctl 	allow lightweight 
grow 	tags unspecified diff 
read malloc 	index command 
mutex unlock 	arguments check working 
prof active 	dirty annotated 
init prof 	tag tag head 
active init 	multiple annotated 
read 	tags point commit 
prof active 	one keep 
prof active 	upon tagger date 
read writeonly 	reject anything 
write prof 	outside refs tags 
mdump prof 	unless accept 
gdump 	tags match pattern 
prof gdump 	given annotated 
read writeonly 	use annotated tags 
write tsd 	tags fall 
fetch prof 	back lightweight 
reset malloc 	ones even without 
mutex 	tags still 
malloc mutex 	remember lightweight ones 
unlock data 	give hints 
ctl mtx 	error message allows 
protects following 	refs used 
ctl stats 	exact match existing 
helpers 	diff-delta.c ptr 
named indexed 	val entry next 
nodes function 	memsize src 
prototypes non 	buf src size 
functions mallctl 	hash mask 
maximum depth 	hash buf bufsize 
handles 	hsize hmask 
indexed nodes 	entries prev val 
since currently 	hash count 
external ones 	data buffer index 
merge sum 	entry hash 
stats well 	packed entry 
merge 	packed hash mem 
sum stats 	memsize val 
well initialize 	acc keep index 
arena allocate 	index index 
extended arena 	trg buf trg 
stats initialize 	size delta 
astats 	size max size 
element swap 	outpos outsize 
merged stats 	moff msize val 
location clear 	inscnt data 
sum stats 	top data top 
since merged 	entry src 
ctl 	size left tmp 
arena refresh 	malloc memset 
allocate space 	calloc free free 
one extra 	malloc free 
arena stats 	free free 
element contains 	malloc realloc free 
summed 	free diff 
stats across 	delta generate delta 
arenas initialize 	two buffers 
stats structures 	code greatly inspired 
regardless whether 	parts lib 
ever used 	diff davide libenzi 
lazy 	http www 
initialization would 	xmailserver xdiff lib 
allow errors 	html rewritten 
cause inconsistent 	git nicolas pitre 
state viewable 	nico fluxnic 
application equivalent 	net code free 
strchrnul 	software redistribute 
children named 	modify terms gnu 
children indexed 	general license 
terminal node 	version published free 
name contains 	software foundation 
elements path 	maximum hash 
complete 	entry list hash 
lookup successful 	bucket determine 
update elm 	index hash size 
elements name 	note indexing 
refers path 	skips first allow 
ctl iterate 	optimizing rabin 
children 	polynomial initialization create 
named indexed 	delta current 
element call 	delta format encode 
ctl function 	offsets reference 
mib ctl 	buffer bits allocate 
functions lot 	lookup index 
code 	allocate count hash 
duplication following 	entries populate 
macros due 	index keep lowest 
limitations nested 	consecutive identical 
cpp macros 	blocks determine limit 
expanded ctl 	number entries 
mtx 	hash bucket 
acquired assumption 	guards pathological data 
pertinent data 	sets causing 
mutate call 	really bad hash 
arena index 	distribution entries 
range initialize 	hash bucket would 
arena 	bring computing 
necessary arena 	costs corresponding reference 
tcache associations 	target buffer 
ctl mutex 	sizes make sure 
must held 	none hash 
execution function 	buckets entries willing 
intentional 	test otherwise 
intentional ctl.h 	cull entry list 
named node 	uniformly still 
name nchildren 	preserve good repartition 
children size 	across reference 
node size 	buffer exactly hash 
initialized 	limit entries 
nthreads dss 	bucket loop 
dirty mult 	gone exactly hash 
pactive pdirty 	limit times 
astats allocated 	entered left acc 
small nmalloc 	first statement 
small 	loop contributes hash 
ndalloc small 	count hash 
nrequests small 	limit hash limit 
bstats lstats 	accumulator inner 
hstats allocated 	loop consequently run 
active metadata 	hash count 
resident 	hash limit times 
mapped narenas 	removing one 
arenas name 	element list time 
oldp oldlenp 	since acc 
newp newlen 	balances run inner 
name mibp 	loop body 
miblenp 	left entry 
mib miblen 	indeed encounter entry 
oldp oldlenp 	outer loop 
newp newlen 	create packed index 
jemalloc types 	form rather 
nchildren terminal 	linked lists coalesce 
node 	entries belonging 
aggregate stats 	one linked list 
small size 	consecutive entries 
classes bin 	sentinel indicate length 
stats nlclasses 	last hash 
elements nhclasses 	bucket maximum size 
elements 	opcode sequence 
narenas elements 	including initial header 
jemalloc structs 	plus rabin 
jemalloc externs 	window plus biggest 
jemalloc inlines 	copy store 
db.c key 	reference buffer size 
key 	store target 
key val 	buffer size 
key val 	best match far 
key key 	good enough 
reply key 	match one back 
reply key 	count slot 
val 	make copy currently 
copy retval 	limited pack 
key val 	diff-files.c diff files 
key val 	usage argc 
key key 	argv prefix rev 
keyobj key 	result options 
key 	init revisions gitmodules 
decoded callback 	config git 
removed key 	config setup revisions 
dbid saved 	strcmp strcmp 
dirty count 	strcmp strcmp usage 
key pattern 	usage read 
allkeys 	cache preload perror 
numkeys replylen 	run diff 
key keyobj 	files diff 
privdata keys 	result code git 
key val 	information manager 
sdskey cursor 	hell copyright linus 
eptr 	torvalds diff 
cursor keys 	options make sure 
node nextnode 	revision pending 
count pat 	parameter rev max 
use pattern 	count reasonable 
privdata maxiterations 	revision filtering parameters 
pos 	diff files 
vstr vlen 	combine merges asked 
vll kobj 	diff files 
filter buf 	densify user ask 
len kobj 	diff files 
cursor type 	explicitly diff-index.c diff 
flags 	cache usage 
expire samekey 	argc argv prefix 
src dst 	rev cached 
srcid dbid 	result arg 
expire key 	init revisions gitmodules 
key kde 	config git 
key 	config setup revisions 
key argv 	strcmp usage 
key basetime 	usage setup work 
unit param 	read cache 
aux output 	preload perror read 
expire ttl 	cache perror 
cmd 	run diff index 
argv argc 	diff result 
numkeys last 	code diff options 
keys cmd 	make sure 
argv argc 	one revision pending 
numkeys result 	revision filtering 
cmd 	parameters diff-lib.c sub 
argv argc 	diffopt option 
numkeys num 	dirty submodule changed 
keys cmd 	orig flags 
argv argc 	revs option 
numkeys num 	entries diff unmerged 
keys 	stage option 
cmd argv 	oldmode newmode changed 
argc numkeys 	dirty submodule 
num keys 	old sha sha 
found store 	dpath pair 
name skip 	mode num compare 
cmd 	stages path 
argv argc 	len nce stage 
numkeys num 	mode revs 
first keys 	prefix sha sha 
key hashslot 	valid mode 
key hashslot 	dirty submodule sha 
hashslot 	modep cached 
keys count 	match missing dirty 
range hashslot 	submodule diffopt 
range key 	sha mode 
hashslot zsl 	changed revs cached 
range rank 	match missing 
count 	sha mode dirty 
dict find 	submodule revs 
dict val 	old report missing 
lru clock 	cached match 
expire needed 	missing mode oldmode 
lookup key 	sha dirty 
expire 	submodule pathlen idx 
needed lookup 	revs match 
key lookup 	missing cached pair 
key read 	src idx 
reply lookup 	revs revs sha 
key write 	name cached 
reply 	opts revs cached 
sdsdup dict 	ent sha 
server info 	opt revs def 
signal list 	diff flags 
ready slot 	rev opt 
key dict 	lstat symlink leading 
find 	path namelen 
server info 	isdir isgitlink resolve 
dict replace 	gitlink match 
lookup key 	stat isgitlink diff 
write overwrite 	opt tst 
incr count 	diffopt flags submodule 
expire 	config diff 
signal modified 	opt tst diff 
key dict 	opt tst 
find dict 	diff opt tst 
random key 	submodule modified 
dict key 	diff opt tst 
create 	diff mnemonic 
sdslen dict 	prefix diff quit 
find expire 	early path 
needed decr 	match stage namelen 
count dict 	xmalloc combine 
size dict 	diff path 
dict 	size memcpy oidclr 
slot key 	memset check 
del server 	removed mode stat 
decoded create 	perror strcmp 
raw sdslen 	stage hashcpy mode 
decr 	stat show 
count overwrite 	combined diff free 
dict size 	free diff 
dict empty 	unmerge stage uptodate 
dict empty 	skip worktree 
slot key 	check removed perror 
flush 	diff addremove 
touch watched 	sha match stat 
key touch 	submodule mode 
watched keys 	stat mark uptodate 
flush dict 	diff opt 
size signal 	tst diff change 
flushed 	sha sha 
dict empty 	diffcore std 
dict empty 	diff flush diff 
slot key 	addremove uptodate 
flush reply 	check removed match 
signal flushed 	stat submodule 
empty 	mode stat stat 
reply kill 	data diff 
rdb temp 	index show file 
file rdb 	sha stat 
save expire 	data diff index 
needed signal 	show file 
modified 	hashcmp hashcmp namelen 
key notify 	xmalloc combine 
keyspace reply 	diff path size 
expire needed 	memcpy oidclr 
exists reply 	memset hashcpy hashcpy 
reply reply 	show combined 
error 	diff free 
reply error 	hashcmp diff opt 
reply random 	tst diff 
key reply 	change sha skip 
reply bulk 	worktree stage 
decr count 	diff unmerge fill 
sdslen 	filespec show 
deferred multi 	file diff index 
bulk length 	show file 
dict safe 	show modified path 
iterator dict 	match oneway 
next dict 	diff diff quit 
key 	early parse 
stringmatchlen sdslen 	indirect error sha 
create sdslen 	hex memset 
expire needed 	diff opt tst 
reply bulk 	init desc 
decr count 	unpack trees diff 
dict 	cache exit 
release iterator 	diff mnemonic 
deferred multi 	prefix diffcore fix 
bulk length 	diff index 
dict key 	diffcore std diff 
create sdslen 	flush init 
dict 	revisions copy pathspec 
key incr 	diff cache 
count dict 	exit init revisions 
key incr 	memset setup 
count dict 	revisions diff opt 
val incr 	diff opt 
count 	run diff index 
dict key 	free diff 
incr count 	opt tst copyright 
create dict 	junio hamano 
val server 	diff files work 
panic list 	entity removed 
node 	removed work entity 
tail list 	compared cache 
node tail 	entry still 
strtoul isspace 	exists latter includes 
reply error 	directory submodule 
list create 	repository exists submodule 
server 	submodule negative 
strcasecmp reply 	error already gitlink 
reply strcasecmp 	plain directory 
sdslen reply 	submodule submodule either 
list length 	something removed 
dict scan 	work otherwise directory 
intset 	submodule repository 
list node 	means blob turned 
tail create 	directory blob 
ziplist index 	removed file changed 
ziplist list 	submodule commits 
node tail 	dirty work changes 
create 	detected otherwise 
create ziplist 	dirty submodules option 
next server 	caller want 
panic list 	know submodule 
first list 	modified wants know 
node list 	conditions met 
next 	commits untracked content 
node sds 	modified content 
encoded stringmatchlen 	stage first parent 
sdslen server 	stage second 
stringmatchlen expire 	diff proper unmerged 
needed decr 	stage compensate 
count 	loop update show 
list del 	diff found 
node list 	one desired stage 
next node 	valid look 
list node 	workdir file removal 
decr count 	diff index 
list 	file entry went 
del node 	away appeared 
reply multi 	file index might 
bulk len 	actually different 
reply bulk 	working gets 
reply multi 	mix existing index 
bulk 	one pathname 
len list 	entry time index 
length list 	entry may 
first list 	single stage one 
node reply 	could also 
bulk decr 	multiple unmerged entries 
count 	idx pos 
list del 	idx give position 
node list 	number entries 
free method 	index entry examine 
list release 	work backward 
parse scan 	compatibility wart diff 
cursor 	index mean 
reply scan 	ignore merges match 
command reply 	missing revision 
dict size 	flag parsing 
reply lookup 	found revs ignore 
key read 	merges something 
reply 	added something removed 
status reply 	show difference 
strcasecmp strcasecmp 	old unpack trees 
reply prepare 	designed merging 
shutdown exit 	different source entries 
reply error 	designed primarily 
sdscmp 	source trees old 
lookup key 	index really 
write reply 	mainly used replaced 
reply incr 	result diffing 
count expire 	index important single 
lookup key 	supposed advance 
write 	pos skip already 
decr count 	processed wrapper 
reply expire 	makes readable takes 
signal modified 	care fairly 
key signal 	complex unpack 
modified key 	trees semantic requirements 
notify 	including skipping 
keyspace notify 	path matching type 
keyspace reply 	conflict cases 
rename command 	etc unpack trees 
rename command 	generates conflict 
reply error 	entry directory index 
reply 	diff standpoint 
reply lookup 	create file diff-no-index.c 
key write 	path list 
reply expire 	dir file standard 
lookup key 	input path 
write reply 	mode buf size 
expire 	name mode 
incr count 	name name mode 
reply server 	buffer buffer 
info dict 	ret len comp 
find dict 	tmp tmp 
dict find 	path dir 
server 	file tail path 
info dict 	replacement isdir 
replace raw 	isdir revs argc 
dict key 	argv prefixlen 
dict integer 	paths replacement prefix 
val dict 	opendir error 
size 	readdir dot dotdot 
dict find 	list insert 
server info 	closedir strcmp strcasecmp 
dict find 	create mode 
dict integer 	lstat error strbuf 
val incr 	read error 
count 	strerror strbuf detach 
incr count 	alloc filespec 
feed append 	fill filespec populate 
file replication 	stdin mode 
feed slaves 	mode isdir isdir 
decr count 	isdir noindex 
decr 	filespec noindex 
count expire 	filespec noindex filespec 
mstime propagate 	noindex filespec 
expire notify 	diff queue isdir 
keyspace reply 	isdir read 
lookup key 	directory contents read 
write 	directory contents 
reply mstime 	list clear strbuf 
server info 	addstr strbuf 
create rewrite 	complete strbuf addstr 
client command 	strbuf complete 
vector decr 	strbuf setlen strbuf 
count 	setlen strcmp 
signal modified 	strbuf addstr strbuf 
key notify 	addstr queue 
keyspace reply 	diff list clear 
expire reply 	list clear 
signal modified 	strbuf release 
key 	strbuf release diff 
notify keyspace 	opt tst 
expire command 	noindex filespec noindex 
mstime expire 	filespec diff 
command expire 	queue strrchr strbuf 
command mstime 	addstr strbuf 
expire 	addch strbuf addstr 
command lookup 	directory directory 
key read 	append basename append 
reply expire 	basename diff 
mstime reply 	setup strcmp strcmp 
reply ttl 	diff opt 
command 	parse die strlen 
ttl command 	strcmp xstrdup 
dict find 	prefix filename fixup 
reply expire 	paths diff 
reply reply 	opt diff setup 
unused zmalloc 	done setup 
server 	diff pager 
getkeys proc 	diff opt queue 
keys command 	diff exit 
table zfree 	diff mnemonic prefix 
unused atoi 	diffcore std 
zmalloc unused 	diff flush strbuf 
atoi 	release exit 
zmalloc unused 	diff result code 
zmalloc strcasecmp 	diff index 
strcasecmp unused 	support copyright johannes 
strcasecmp sdslen 	schindelin copyright 
zmalloc key 	junio hamano standard 
hash 	input something 
slot sdslen 	probably expose many 
zsl insert 	breakages way 
incr count 	index code bolted 
key hash 	onto diff 
slot sdslen 	callchain file created 
zsl 	file deleted 
zsl free 	emit file 
zsl create 	entire directory created 
zsl first 	deleted append 
range zsl 	basename dwim diff 
first range 	diff diff 
incr 	diff note append 
count decr 	basename diff 
count zsl 	file becomes diff 
first range 	file file 
zsl rank 	diff file file 
zsl last 	stdin spelled 
range 	path spell code 
zsl rank 	index imitates 
copyright salvatore 	diff changes changes 
sanfilippo antirez 	error diff-tree.c 
gmail dot 	log opt sha 
rights reserved 	commit commit 
redistribution 	line len sha 
use source 	pos pptr 
binary forms 	parent line 
without modification 	len sha line 
permitted provided 	len sha 
following conditions 	obj diff usage 
met 	rev opt 
redistributions source 	argc argv prefix 
code must 	sha line 
retain copyright 	opt opt read 
notice list 	stdin arg 
conditions following 	tmp saved nrl 
disclaimer 	saved dcctc 
redistributions binary 	sha lookup commit 
form must 	reference log 
reproduce copyright 	commit isspace sha 
notice list 	hex free 
conditions following 	commit list sha 
disclaimer 	hex lookup 
documentation materials 	commit commit 
provided distribution 	list insert log 
neither name 	commit isspace 
redis names 	sha hex error 
contributors may 	lookup parse 
used 	oid hex oid 
endorse promote 	hex diff 
products derived 	sha log diff 
software without 	flush strlen 
specific prior 	sha hex parse 
written permission 	stdin diff 
software 	commit stdin diff 
provided copyright 	trees error 
holders contributors 	sha hex init 
express implied 	revisions gitmodules 
warranties including 	config git config 
limited implied 	memset setup 
warranties 	revisions strcmp usage 
merchantability fitness 	usage diff 
particular purpose 	commit sha 
disclaimed shall 	diff sha log 
copyright owner 	diff flush 
contributors liable 	fgets sha hex 
direct 	fputs fflush 
indirect incidental 	diff stdin diff 
special exemplary 	result code 
consequential damages 	diff one commits 
including limited 	graft fake 
procurement substitute 	parents locally commit 
goods 	free real 
services loss 	parent list diff 
use data 	two trees 
profits business 	diff options note 
interruption however 	expect equal 
caused theory 	reverse order objects 
liability 	second one 
whether contract 	marked uninteresting diff.c 
strict liability 	diff detect 
tort including 	rename diff 
negligence otherwise 	rename limit diff 
arising way 	suppress blank 
use 	empty diff use 
software even 	color diff 
advised possibility 	context diff word 
damage level 	regex cfg 
api update 	external diff cmd 
access time 	cfg diff 
ageing 	order file cfg 
algorithm saving 	diff refresh 
child trigger 	index diff mnemonic 
copy write 	prefix diff 
madness key 	prefix diff stat 
expired context 	graph width 
master 	diff dirstat permille 
expire needed 	diff options 
returns key 	diff algorithm diff 
exist save 	colors options 
asap however 	errmsg copy 
context slave 	ret end permille 
expire 	options name 
needed really 	slot errmsg one 
expire key 	two need 
returns information 	one need two 
logical status 	res external 
key key 	diff cmd done 
expiring 	preparing name 
master order 	hex mode tempfile 
consistent view 	color diff 
master data 	rule blank eof 
however command 	preimage blank 
caller master 	eof postimage lno 
additional 	preimage lno 
safety measure 	postimage truncate label 
command invoked 	path diff 
read command 	words opt found 
safely provide 	changesp header 
consistent behavior 	data size 
clients 	count seen one 
accessign expired 	one rule 
values read 	ptr size cnt 
fashion say 	prev eol 
key non 	ecbdata rule reset 
exisitng notably 	first line 
covers 	len trailing newline 
slaves used 	trailing carriage 
scale reads 	nofirst file reset 
key caller 	line len 
increment reference 	ecbdata line len 
counter needed 	emit line 
program 	reset ecbdata line 
aborted key 	len reset 
already exists 	ecbdata line len 
overwrite existing 	reset ecbdata 
key incrementing 	line len 
reference count 	ecbdata line len 
caller 	context frag 
function modify 	func reset atat 
expire time 	msgbuf len 
existing key 	file count ecb 
program aborted 	prefix data 
key already 	size endp nneof 
present 	reset len 
high level 	context name name 
operation function 	one two 
used order 	textconv one textconv 
key whatever 	two name 
existing count 	tab name tab 
incremented 	metainfo fraginfo 
clients watc 	reset name prefix 
hing destination 	prefix data 
key notified 	one data two 
expire time 	size one 
key reset 	size two 
key 	ecbdata line prefix 
made persistent 	text alloc 
random key 	begin end orig 
form redis 	orig alloc 
keys returned 	line len buffer 
function makes 	prefix suffix 
sure 	color old ctx 
keys already 	newline diff 
expired search 	words styles minus 
another key 	plus current 
expired key 	plus last minus 
associated expiration 	opt word 
entry 	regex style newline 
deleting entry 	count buf 
expires dict 	line prefix print 
free sds 	diff words 
key shared 	priv line len 
main dictionary 	diff words 
prepare 	style minus 
stored key 	first minus len 
modified destructively 	plus first 
implement commands 	plus len minus 
like setbit 	begin minus 
append usually 	end plus begin 
ready 	plus end 
modified unless 	opt line prefix 
one two 	buffer word 
conditions shared 	regex begin end 
refcount want 	match buffer 
affect users 	word regex alloc 
encoding 	diff words 
raw found 	xpp xecfg minus 
one conditions 	plus style 
function unshared 	opt line prefix 
encoded copy 	ecbdata one 
stored key 	one ecbdata orig 
specified 	opts one 
otherwise returned 	two ecbdata 
usage caller 	diff color opt 
already obtained 	msgbuf ecb 
looking key 	line len allot 
usage pattern 	line ecbdata 
looks 	priv line len 
like lookup 	ecbdata meta 
key write 	context reset line 
key check 	prefix name 
type obj 	tab name tab 
unshare key 	old name 
point 	pfx length sfx 
caller ready 	length pfx 
modify example 	adjust slash len 
sdscat call 	len midlen 
append data 	midlen qlen qlen 
anything 	alloc name 
hooks key 	name print 
space changes 	name added deleted 
every time 	diffstat name 
key database 	name priv line 
modified function 	len diffstat 
signal 	mime boundary leader 
modified key 	width max 
called every 	change file prefix 
time flushed 	name len 
function signal 	file cnt reset 
flush called 	file pname 
type 	buf files insertions 
agnostic commands 	deletions ret 
operating key 	data options len 
space normally 	del dels 
rdb save 	max len count 
reset dirty 	width name 
want 	width graph width 
otherwise flushall 	bin width 
replicated put 	reset del 
aof exists 	line prefix extra 
key key 	shown file 
key number 	change prefix file 
keys 	name added 
existing callback 	deleted name len 
used scan 	slash total 
command order 	file added deleted 
collect elements 	data options 
returned dictionary 	total files added 
iterator 	deleted data 
list parse 	options file name 
scan cursor 	changed files 
stored cursor 	alloc permille cumulative 
valid store 	opt dir 
integer cursor 	changed baselen dir 
returns 	sources line 
otherwise err 	prefix namelen slash 
send error 	newbaselen permille 
client use 	options changed 
strtoul need 	dir name copied 
cover whole 	added damage 
cursor 	content changed data 
space command 	options changed 
scan hscan 	dir file damage 
sscan commands 	diffstat filename 
passed must 	lineno conflict marker 
hash otherwise 	size rule 
command 	status line marker 
operate dictionary 	size len 
associated current 	firstchar cnt priv 
database function 	line len 
assumes first 	data marker size 
argument client 	reset err 
arguments 	line prefix bad 
vector key 	plus data 
skips iterating 	size result size 
order parse 	bound deflated 
options hash 	stream file 
function returns 	one two prefix 
field 	delta deflated 
every element 	data orig size 
hash must 	delta size 
iterate keys 	deflate size data 
names type 	size free 
must sorted 	bytes line file 
hash 	one two 
first option 	prefix one one 
argument previous 	options one 
one cursor 	name name one 
skip key 	two xfrm 
argument needed 	msg must show 
step 	header complete 
parse options 	rewrite lbl one 
pattern always 	two meta 
matches exactly 	reset prefix 
equivalent disabling 	prefix textconv one 
step iterate 	textconv two 
collection 	header line prefix 
note encoded 	del diffopts 
ziplist intset 	xpp xecfg ecbdata 
representation hash 	name name 
table sure 	one two diffstat 
also composed 	data contents 
small 	complete rewrite xpp 
number elements 	xecfg name 
avoid taking 	name attr path 
state everything 	one two 
inside single 	data xpp xecfg 
call setting 	ecbdata blank 
cursor 	eof err path 
zero signal 	spec spec 
end iteration 	spec sha sha 
handle hash 	valid mode 
table key 	name sha 
type key 	want file pos 
type 	len size 
max number 	buf dirty flags 
iterations ten 	size err 
times specified 	buf size path 
count hash 	temp blob 
table pathological 	size sha mode 
state 	buf path 
sparsely populated 	dup name one 
avoid block 	temp argv 
much time 	name temp pgm 
cost returning 	name one 
elements pass 	two xfrm msg 
two 	complete rewrite 
pointers callback 	argv env msg 
list elements 	name one 
containing dictionary 	two must show 
possible fetch 	header use 
data type 	color reset 
dependent 	line prefix abbrev 
way step 	pgm name 
filter elements 	attr path one 
filter element 	two msg 
match pattern 	xfrm msg complete 
filter element 	rewrite must 
expired 	show header drv 
key element 	one prefix 
associted needed 	length namep otherp 
hash sorted 	pgm msg 
flat list 	one two name 
key elements 	attr path 
element 	diffstat name name 
filtered skip 	attr path 
filtered match 	options options count 
keys step 	arg arg 
reply client 	arg val len 
scan command 	end end 
completely 	opt opt 
relies scan 	argv optarg arg 
command shutdown 	opt argv 
called server 	optarg arg options 
loading dataset 	arg end 
memory need 	width name width 
make 	graph width 
sure attempt 	count argcount options 
performed save 	errmsg options 
dataset shutdown 	diff status letters 
otherwise could 	filter bit 
overwrite current 	status opt optarg 
half 	opt optch 
read data 	bit negate fmt 
also sentinel 	arg token 
mode clear 	rest opt arg 
save flag 	orig arg 
force nosave 	val options prefix 
source 	arg optarg 
dest key 	argcount path 
operation performed 	offending path num 
key exists 	scale dot 
however still 	opt opt opt 
error unexisting 	cmd diff 
key 	queued diff queue 
overwrite old 	queue one 
key creating 	two sha len 
one name 	abblen abbrev 
obtain source 	hex opt line 
target pointers 	termination inter 
back 	name termination name 
source user 	name name 
moving target 	name two diffstat 
source probably 	one msg 
error check 	opt fmt name 
element exists 	name file 
reference 	newdelete file 
zero key 	show name line 
already exists 	prefix file 
target key 	renamecopy line prefix 
moved free 	names opt 
entry source 	file line prefix 
expires 	ctx patchlen 
api expire 	line len dst 
may removed 	priv line 
corresponding entry 	len data len 
main dict 	options sha 
otherwise key 	ctx data buffer 
never 	xpp xecfg 
freed reuse 	len len options 
sds main 	sha result 
dict expire 	rename limit warning 
dict expire 	degrade warning 
time specified 	rename limit advice 
key 	varname needed 
expire associated 	degraded options 
key key 	output format separator 
non expire 	dirstat line 
asap entry 	diffstat options options 
found expire 	outq found 
dict 	one two diffopt 
means also 	outq name 
present main 	name options options 
dict safety 	opt status 
check propagate 	result opt path 
expires slaves 	options ignored 
aof 	orig flags options 
file key 	addremove mode 
expires master 	sha sha valid 
del operation 	concatpath dirty 
key sent 	submodule one two 
slaves aof 	options old 
file 	mode mode old 
enabled way 	sha sha 
key expiry 	old sha 
centralized one 	valid sha valid 
place since 	concatpath old 
aof master 	dirty submodule dirty 
slave 	submodule one 
link guarantee 	two tmp tmp 
operation ordering 	options path 
everything consistent 	pair one two 
even allow 	pgm spec 
write operations 	outsize temp argv 
expiring 	arg child 
keys expire 	buf err driver 
key expire 	outbuf size 
anything loading 	opt strcasecmp strcasecmp 
done later 	strcasecmp strcasecmp 
context lua 	strcasecmp strcasecmp strcasecmp 
script 	strcasecmp strcasecmp 
claim time 	xstrdup list split 
blocked lua 	place strcmp 
script started 	diff opt 
way key 	clr diff opt 
expire first 	clr strcmp 
time 	diff opt diff 
accessed middle 	opt clr 
script execution 	strcmp diff opt 
making propagation 	clr diff 
slaves aof 	opt strcmp diff 
consistent see 	opt clr 
issue 	strcmp diff opt 
github information 	isdigit strtoul 
running context 	isdigit isdigit strbuf 
slave asap 	addf strbuf 
slave key 	addf list clear 
expiration controlled 	free strcmp 
master 	diff opt strcmp 
send synthesized 	diff opt 
del operations 	clr strcasecmp 
expired keys 	strcasecmp git config 
still right 	strcasecmp strcasecmp 
information caller 	strcasecmp strcasecmp strcasecmp 
think 	strcmp strcmp 
key still 	git config colorbool 
valid think 	strcmp git 
key expired 	config strcmp git 
time key 	config rename 
expired key 	strcmp git config 
expires 	strcmp git 
commands command 	config strcmp git 
implementation expire 	config strcmp 
pexpire expireat 	git config strcmp 
pexpireat commad 	git config 
second argument 	strcmp git config 
may 	strcmp git 
relative absolute 	config pathname strcmp 
basetime argument 	handle ignore 
used signal 	submodules arg 
time either 	strcmp parse submodule 
variants command 	warning strcmp 
current 	parse algorithm git 
time relative 	color config 
expires unit 	git diff basic 
either unit 	config strcmp 
seconds unit 	git config userdiff 
milliseconds used 	config skip 
argv 	prefix skip prefix 
parameter basetime 	parse diff 
always specified 	color slot config 
milliseconds unix 	error nonbool 
time milliseconds 	color parse strcmp 
key expire 	strcmp git 
key 	config strcmp parse 
zero expire 	dirstat warning 
negative ttl 	strbuf release starts 
expireat timestamp 	parse submodule 
past never 	config option 
executed del 	git config quote 
load 	style quote 
aof context 	style strbuf addch 
slave instance 	quote style 
instead take 	quote style strbuf 
branch statement 	addch strbuf 
setting expire 	addstr strbuf addstr 
possibly 	strbuf detach 
past wait 	getenv diff file 
del master 	valid diff 
replicate aof 	populate filespec diff 
del key 	file valid 
exist key 	diff populate filespec 
exists 	blank line 
expire actual 	count trailing blank 
ttl otherwise 	count trailing 
api key 	blank count lines 
arguments commands 	count lines 
use keys 	fputs diff 
position 	line prefix fputs 
given command 	fputc fwrite 
table firstkey 	fputs fputc fputc 
lastkey step 	emit line 
arguments keys 	blank line emit 
command passed 	line emit 
via 	line emit line 
argc argv 	diff color 
command returns 	diff color diff 
positions key 	color diff 
arguments inside 	color memcmp memmem 
actual heap 	emit line 
allocated 	strbuf addstr strbuf 
integers length 	strbuf addstr 
returned reference 	strbuf addstr strbuf 
numkeys cmd 	strbuf addstr 
must point 	strbuf addstr 
corresponding entry 	strbuf strbuf addstr 
redis 	strbuf emit 
command table 	line strbuf release 
according command 	size die 
name argv 	size tempfile active 
function uses 	tempfile diff 
command table 	color memchr emit 
command 	del line 
specific helper 	emit line diff 
function required 	color putc 
otherwise calls 	emit line strlen 
command specific 	diff color 
function free 	diff color diff 
result 	color diff 
keys command 	line prefix diff 
helper function 	opt tst 
extract keys 	strchr strchr strbuf 
following commands 	reset strbuf 
zunionstore destkey 	reset quote 
num 	two style quote 
keys key 	two style 
key key 	fill textconv fill 
options zinterstore 	textconv memset 
destkey num 	want color whitespace 
keys key 	rule check 
key 	blank eof count 
key options 	lines count 
sanity check 	lines print line 
key command 	count print 
going reply 	line count emit 
syntax error 	rewrite lines 
keys 	emit rewrite lines 
inter store 	free free 
come two 	alloc grow memcpy 
places argv 	memchr fputs 
storage key 	fputs fputs fwrite 
argv keys 	fputs fputs 
intersect 	fputs parse 
key positions 	hunk header diff 
argv keys 	line prefix 
argv key 	color words output 
position storage 	graph prefix 
key target 	fputs diff words 
total 	write helper 
keys inter 	fputs diff words 
keys storage 	write helper 
key helper 	diff words write 
function extract 	helper regexec 
keys following 	memchr isspace isspace 
commands 	alloc grow 
eval script 	find word boundaries 
num keys 	alloc grow 
key key 	alloc grow memcpy 
key stuff 	diff line 
evalsha script 	prefix fputs diff 
num 	words write 
keys key 	helper memset 
key key 	memset diff words 
stuff sanity 	fill diff 
check key 	words fill xdi 
command going 	diff outf 
reply 	die free free 
syntax error 	color words 
key positions 	output graph prefix 
argv keys 	fputs diff 
helper function 	words write helper 
extract keys 	diff words 
sort 	show isreg userdiff 
command sort 	find path 
sort key 	userdiff find name 
store store 	diff filespec 
key first 	load driver xmalloc 
argument sort 	memcpy xcalloc 
always 	userdiff word regex 
key however 	userdiff word 
list options 	regex xmalloc 
follow sql 	regcomp die size 
alike style 	want color 
parse minimum 	diff color opt 
order 	diff color 
correctly identify 	opt diff color 
keys store 	opt diff 
option alloc 	words flush free 
places worst 	free free 
sort key 	free free regfree 
always 	free free 
present search 	output prefix truncate 
store option 	utf width 
consider options 	strchr strtol strchr 
arguments find 	strtol diff 
unknown option 	color diff color 
name 	diff color 
scan next 	diff line 
however options 	prefix strbuf reset 
arguments provide 	strchr strchr 
list order 	diff words flush 
skip right 	sane truncate 
number 	line find lno 
args end 	emit hunk 
elements note 	header putc emit 
increment num 	line fputs 
loop sure 	diff words append 
process last 	diff words 
store 	append starts diff 
option multiple 	words flush 
ones provided 	emit line fputs 
behavior sort 	emit line 
store key 	emit line emit 
obvious form 	del line 
check 	emit context line 
extended one 	emit line 
keys option 	diff color 
slot key 	strlen strlen quote 
api used 	style quote 
redis cluster 	style quote style 
order 	strbuf addstr 
obtain fast 	quote style strbuf 
way key 	detach strbuf 
belongs specified 	grow strbuf strbuf 
hash slot 	addch strbuf 
useful 	strbuf addstr strbuf 
rehashing cluster 	strbuf addch 
keys specified 	strbuf strbuf detach 
hash slot 	xcalloc alloc 
number removed 	grow xstrdup xstrdup 
items returned 	xstrdup putc 
next 	quote style strbuf 
item freeing 	detach strbuf 
protect freeing 	release pprint rename 
find first 	strbuf addf 
element range 	strbuf addf 
use rank 	strbuf addf strbuf 
first 	addch fputs 
element determine 	strbuf release diff 
preliminary count 	line prefix 
find last 	diff color opt 
element range 	diff color 
use rank 	opt diff color 
last 	opt fill 
element determine 	print name strlen 
actual count 	width width 
debug.c digest 	term columns width 
ptr len 	width strlen 
ctx hash 	strchr show name 
digest 	putc show 
digest ptr 	name scale linear 
len ctx 	scale linear 
digest digest 	scale linear show 
buf aux 	name show 
key keyobj 	graph show 
expiretime 	graph print stat 
entry eleobj 	summary diff 
ele eledigest 	line prefix print 
eptr sptr 	stat summary 
vstr vlen 	diff line prefix 
vll score 	fill print 
eleobj 	name write name 
score obj 	quoted fputs 
eledigest result 	putc putc write 
str info 	name quoted 
delay flags 	write name quoted 
ptr val 	diff line 
strenc 	prefix strlen memcmp 
extra nextra 	strchr gather 
remaining used 	dirstat strcmp diff 
avg compressed 	opt tst 
node val 	hashcmp diff 
key keys 	opt tst diff 
key 	file valid 
val buf 	diff file valid 
digest dtime 	diff populate 
utime errstr 	filespec diff populate 
sizes dbid 	filespec diffcore 
stats buf 	count changes diff 
info 	free filespec 
estr file 	data diff free 
line buf 	filespec data 
arg repr 	diff file valid 
estr file 	diff populate 
line msg 	filespec diff free 
file 	filespec data 
line addr 	diff file valid 
val log 	diff populate 
stdout log 	filespec diff free 
stdout trace 	filespec data 
msg msg 	alloc grow 
client 	qsort gather dirstat 
decoded val 	diff opt 
key line 	tst alloc grow 
logbuf start 	qsort gather 
addr end 	dirstat free free 
addr size 	free free 
start 	free isspace diff 
vect size 	color diff 
vect start 	color diff color 
end errors 	diff line 
sig info 	prefix conflict marker 
secret eip 	check whitespace 
infostring 	error free emit 
clients act 	line check 
level descr 	emit strchr strtol 
len buf 	die git 
charset sig 	deflate init git 
info secret 	deflate bound 
period 	xmalloc git 
period min 	deflate git deflate 
period act 	end deflate 
act sha 	diff delta deflate 
init sha 	free free 
update sha 	free encode fputs 
decoded 	fputc free 
xor digest 	emit binary diff 
sdslen decr 	body emit 
count xor 	binary diff body 
digest sha 	diff filespec 
init sha 	load driver diff 
update 	file valid 
sha decoded 	diff populate filespec 
mix digest 	buffer binary 
sdslen decr 	diff filespec load 
count memset 	driver diff 
dict size 	file valid diff 
dict 	filespec load 
iterator htonl 	driver userdiff 
mix digest 	textconv diff color 
dict next 	opt diff 
memset dict 	color opt diff 
key create 	line prefix 
sdslen 	diff opt tst 
mix digest 	isgitlink isgitlink 
sdslen dict 	diff color opt 
val htonl 	diff color 
mix digest 	opt show submodule 
expire mix 	summary diff 
digest 	opt tst textconv 
list type 	textconv diff 
init iterator 	mnemonic prefix diff 
list type 	opt tst 
next list 	diff file valid 
type mix 	diff file 
digest 	valid quote 
decr count 	two quote two 
list type 	diff file 
release iterator 	valid diff file 
type init 	valid strbuf 
iterator type 	addf strbuf addf 
next 	strbuf addstr 
xor digest 	strbuf addf strbuf 
decr count 	addstr strbuf 
type release 	addf strbuf addf 
iterator ziplist 	strbuf addstr 
index server 	diff filespec binary 
ziplist 	diff filespec 
next server 	binary strbuf reset 
server ziplist 	emit rewrite 
zzl score 	diff strbuf reset 
memset mix 	diff opt 
digest mix 	tst diff filespec 
digest 	binary diff 
strlen snprintf 	filespec binary 
mix digest 	isreg isreg diff 
strlen xor 	opt tst 
digest zzl 	hashcmp fill mmfile 
next dict 	fill mmfile 
iterator 	die memcmp strbuf 
dict next 	reset diff 
dict key 	opt tst emit 
dict val 	binary diff 
snprintf memset 	getenv strbuf reset 
mix digest 	fill textconv 
mix 	fill textconv diff 
digest strlen 	funcname pattern 
xor digest 	diff funcname pattern 
dict release 	memset memset 
iterator server 	memset want color 
panic hash 	whitespace rule 
type 	check blank eof 
init iterator 	diff opt 
hash type 	tst xdiff 
next memset 	find func skip 
hash type 	prefix strtoul 
current mix 	skip prefix strtoul 
digest 	init diff 
decr count 	words data xdi 
hash type 	diff outf 
current mix 	die free diff 
digest decr 	words data 
count xor 	free free xdiff 
digest 	clear find 
hash type 	func strbuf release 
release iterator 	diff free 
server panic 	filespec data diff 
xor digest 	free filespec 
xor digest 	data free free 
decr 	diff pair 
count dict 	unmerged diffstat hashcmp 
release iterator 	diff filespec 
sdscat strcasecmp 	binary diff 
strcasecmp strcasecmp 	filespec binary diff 
reply strcasecmp 	filespec size 
restart 	diff filespec size 
server reply 	diff populate 
error strcasecmp 	filespec diff populate 
zmalloc zfree 	filespec count 
reply strcasecmp 	lines count lines 
encoding server 	fill mmfile 
info 	fill mmfile die 
strcasecmp rdb 	memset memset 
save reply 	xdi diff outf 
empty rdb 	die diff 
load reply 	free filespec data 
error server 	diff free 
log 	filespec data memset 
reply strcasecmp 	whitespace rule 
flush append 	merge marker size 
file empty 	fill mmfile 
load append 	fill mmfile 
file reply 	die diff filespec 
server 	binary memset 
log reply 	memset xdi diff 
strcasecmp dict 	outf die 
find reply 	check blank eof 
dict val 	whitespace error 
str encoding 	diff free filespec 
snprintf 	data diff 
snprintf snprintf 	free filespec data 
snprintf snprintf 	diff opt 
reply status 	flexptr alloc str 
format rdb 	diff free 
saved len 	filespec data free 
estimate 	canon mode 
idle time 	hashcpy sha pack 
strcasecmp dict 	strlen cache 
find reply 	name pos 
dict val 	hashcmp isreg skip 
dict key 	worktree uptodate 
sds 	lstat match stat 
encoded reply 	strbuf addf 
error reply 	sha hex strbuf 
status format 	release strbuf 
sdslen sdsavail 	detach diff file 
sdslen sdsavail 	valid die 
strcasecmp 	isdir isgitlink diff 
reply dict 	populate gitlink 
expand snprintf 	reuse worktree file 
create strlen 	lstat xsize 
lookup key 	islnk strbuf readlink 
write decr 	strbuf detach 
count 	open xmmap close 
snprintf create 	convert git 
strlen decr 	munmap strbuf detach 
count reply 	sha info 
strcasecmp sdsempty 	die sha 
compute dataset 	hex read sha 
digest 	file die 
sdscatprintf reply 	sha hex free 
status sdsfree 	munmap diff 
strcasecmp strtod 	free filespec blob 
nanosleep reply 	free xstrdup 
strcasecmp atoi 	basename strbuf addstr 
reply 	strbuf addstr 
strcasecmp atoi 	mks tempfile strlen 
reply strcasecmp 	die errno 
sdsnewlen sdscatsds 	convert working write 
sdsmapchars sdscatlen 	full die 
reply sds 	errno close tempfile 
strcasecmp 	tempfile path 
sdsempty sdscatprintf 	sha hex xsnprintf 
sdscatprintf sdscatprintf 	strbuf release 
sdscatprintf sdscatprintf 	strbuf release free 
sdscatprintf sdscatprintf 	claim diff 
sdscatprintf reply 	tempfile diff 
bulk 	file valid xsnprintf 
sds strcasecmp 	xsnprintf isgitlink 
sdsempty reply 	reuse worktree file 
reply error 	lstat die 
sdscatprintf dict 	errno islnk strbuf 
stats sdscat 	readlink die 
sdscatprintf 	errno prep temp 
dict stats 	blob strbuf 
sdscat reply 	release sha hex 
bulk sds 	sha hex 
strcasecmp strcasecmp 	xsnprintf diff populate 
sdsempty malloc 	filespec die 
stats 	prep temp blob 
print reply 	prepare temp 
bulk sds 	file argv push 
reply error 	argv push 
format reply 	argv push argv 
error format 	push argv 
reply 	push external 
error format 	diff name external 
bug report 	diff name 
start server 	external diff name 
log server 	argv push 
log server 	argv push argv 
log 	pushf argv 
bug report 	pushf run command 
start server 	opt env 
log server 	die tempfile argv 
log server 	clear argv 
log server 	clear diff color 
log 	diff color 
sds encoded 	diff line prefix 
snprintf server 	strbuf init 
log server 	strbuf addf similarity 
log server 	index strbuf 
log server 	addf quote 
log 	style strbuf addf 
sds encoded 	quote style 
server log 	strbuf addf strbuf 
sdslen sdslen 	addf similarity 
sdscatrepr sdsempty 	index strbuf addf 
sdslen server 	quote style 
log 	strbuf addf quote 
sdsfree server 	style strbuf 
log list 	addf strbuf addf 
type length 	similarity index 
server log 	hashcmp diff opt 
type size 	tst diff 
server 	opt tst fill 
log hash 	mmfile diff 
type length 	filespec binary fill 
server log 	mmfile diff 
zset length 	filespec binary strbuf 
server log 	addf find 
bug 	unique abbrev 
report start 	strbuf addstr find 
server log 	unique abbrev 
server log 	strbuf addf strbuf 
debug info 	addf diff 
server print 	opt tst userdiff 
client 	find path 
info server 	fill metainfo want 
print server 	color run 
bug report 	external diff builtin 
start server 	diff diff 
log server 	file valid hashcpy 
log 	lstat die 
server log 	errno index path 
server log 	die hashclr 
server log 	external diff strcmp 
server log 	strip prefix 
raw server 	diff opt tst 
log 	diff pair 
server log 	unmerged run 
server log 	diff cmd diff 
server log 	fill sha 
log stack 	info diff fill 
content server 	sha info 
log 	diff file valid 
log stack 	diff file 
content server 	valid alloc filespec 
log log 	run diff 
stack content 	cmd free strbuf 
server log 	release alloc 
log 	filespec run diff 
stack content 	cmd free 
server log 	run diff cmd 
open close 	strbuf release 
backtrace mcontext 	diff pair unmerged 
eip write 	builtin diffstat 
strlen 	strcmp strip prefix 
mcontext eip 	diff fill 
backtrace symbols 	sha info 
write strlen 	diff fill sha 
backtrace symbols 	info builtin 
close direct 	diffstat diff pair 
log 	unmerged strcmp 
filedes server 	strip prefix diff 
log raw 	fill sha 
cat client 	info diff fill 
info sdsempty 	sha info 
server log 	builtin checkdiff memcpy 
sdsfree 	diff opt 
decoded server 	die diff xdl 
log decr 	tst diff 
count decoded 	xdl tst diff 
dict find 	xdl tst 
dict val 	diff opt diff 
server 	opt clr 
log server 	diff opt 
log debug 	tst diff opt 
info decr 	tst strlen 
count open 	diff opt diff 
direct log 	opt diff 
filedes 	opt read cache 
fopen fgets 	diff opt 
strchr strchr 	tst diff opt 
strstr strstr 	diff opt 
strstr strstr 	tst die isdigit 
strstr strtoul 	strtoul strchrnul 
strtoul 	strncmp isdigit strtoul 
snprintf write 	die skip 
strlen write 	prefix skip prefix 
memtest preserving 	die skip 
test write 	prefix die skip 
write fclose 	prefix strtoul 
close 	die strtoul skip 
direct log 	prefix strtoul 
filedes mcontext 	die strtoul 
eip unused 	skip prefix strtoul 
bug report 	die strtoul 
start server 	skip prefix strtoul 
log 	die strtoul 
server log 	strtoul strtoul strtoul 
server log 	parse dirstat 
server log 	die strbuf release 
server log 	parse submodule 
raw log 	die prepare filter 
stack 	bits size 
trace server 	toupper skip prefix 
log raw 	parse one 
gen redis 	token parse one 
info sdscatprintf 	token parse 
dict hash 	one token parse 
function 	one token 
seed server 	parse one token 
log raw 	parse one 
server log 	token error 
raw clients 	strcmp strcmp strcmp 
info server 	opt arg 
log 	enable patch output 
raw sdsfree 	strcmp strcmp 
sdsfree log 	enable patch output 
current client 	strcmp strcmp 
log registers 	strcmp strcmp parse 
server log 	dirstat opt 
raw 	skip prefix parse 
bio kill 	dirstat opt 
threads memtest 	skip prefix parse 
test linux 	dirstat opt 
anonymous maps 	strcmp parse dirstat 
server log 	opt strcmp 
raw 	parse dirstat opt 
server log 	skip prefix 
raw server 	parse dirstat opt 
log raw 	parse dirstat 
unlink sigemptyset 	opt strcmp 
sigaction kill 	strcmp strcmp enable 
getpid 	patch output 
server log 	strcmp strcmp strcmp 
server log 	strcmp starts 
raw server 	stat opt starts 
log raw 	starts strcmp 
unused unused 	diff scoreopt parse 
server 	error starts 
log handler 	starts strcmp diff 
log stack 	scoreopt parse 
trace server 	error strcmp strcmp 
log handler 	starts starts 
server 	strcmp diff opt 
log handler 	diff scoreopt 
setitimer sigemptyset 	parse error strcmp 
sigaction watchdog 	strcmp diff 
schedule signal 	opt strcmp diff 
watchdog schedule 	opt clr 
signal 	strcmp diff 
sigemptyset sigaction 	opt skip prefix 
copyright salvatore 	diff opt 
sanfilippo antirez 	strcmp diff xdl 
gmail dot 	strcmp diff 
rights reserved 	xdl clr strcmp 
redistribution 	strcmp diff 
use source 	xdl strcmp strcmp 
binary forms 	diff xdl 
without modification 	strcmp diff xdl 
permitted provided 	strcmp diff 
following conditions 	xdl strcmp diff 
met 	alg strcmp 
redistributions source 	diff alg parse 
code must 	opt parse 
retain copyright 	algorithm error diff 
notice list 	xdl clr 
conditions following 	strcmp enable 
disclaimer 	patch output diff 
redistributions binary 	opt strcmp 
form must 	diff opt strcmp 
reproduce copyright 	strcmp diff 
notice list 	opt strcmp diff 
conditions following 	opt strcmp 
disclaimer 	diff opt strcmp 
documentation materials 	diff opt 
provided distribution 	strcmp diff opt 
neither name 	clr diff 
redis names 	opt clr strcmp 
contributors may 	skip prefix 
used 	git config colorbool 
endorse promote 	error strcmp 
products derived 	strcmp skip prefix 
software without 	strcmp skip 
specific prior 	prefix strcmp strcmp 
written permission 	strcmp strcmp 
software 	die parse 
provided copyright 	opt strcmp diff 
holders contributors 	opt strcmp 
express implied 	diff opt strcmp 
warranties including 	diff opt 
limited implied 	strcmp diff opt 
warranties 	clr strcmp 
merchantability fitness 	diff opt strcmp 
particular purpose 	diff opt 
disclaimed shall 	clr strcmp diff 
copyright owner 	opt handle 
contributors liable 	ignore submodules arg 
direct 	skip prefix 
indirect incidental 	diff opt handle 
special exemplary 	ignore submodules 
consequential damages 	arg strcmp diff 
including limited 	opt skip 
procurement substitute 	prefix parse submodule 
goods 	opt skip 
services loss 	prefix parse 
use data 	error highlight strcmp 
profits business 	opt strtoul 
interruption however 	opt opt strcmp 
caused theory 	strcmp opt 
liability 	prefix filename strlen 
whether contract 	xstrdup parse 
strict liability 	opt parse diff 
tort including 	filter opt 
negligence otherwise 	die strcmp skip 
arising way 	prefix strtoul 
use 	parse opt parse 
software even 	opt strcmp 
advised possibility 	opt arg strcmp 
damage sha 	diff opt 
used debug 	strcmp diff opt 
digest backtrace 	strcmp diff 
debugging 	opt clr parse 
compute sha 	opt prefix 
len bytes 	filename strlen 
sha xored 	fopen die errno 
pointed digest 	skip prefix 
since xor 	skip prefix skip 
commutative 	prefix parse 
operation used 	rename score parse 
order digests 	rename score 
relative unordered 	alloc grow xcalloc 
elements digest 	diff free 
digest function 	filespec free filespec 
instead 	free sha 
computing sha 	hex find unique 
xoring digest 	abbrev strlen 
also perform 	xsnprintf xsnprintf sha 
digest digest 	hex diff 
replace old 	line prefix diff 
one 	unique abbrev 
digest digest 	diff unique 
sha digest 	abbrev similarity index 
xor sha 	strip prefix 
data function 	write name quoted 
used every 	write name 
time 	quoted strip prefix 
want preserve 	write name 
order digest 	quoted diff pair 
different digest 	unmerged diff 
also note 	file valid diff 
mixdigest foo 	file valid 
followed 	diff pair mode 
mixdigest bar 	changed strcmp 
lead different 	hashcmp diff unmodified 
digest compared 	pair diff 
obar compute 	file valid isdir 
dataset digest 	diff file 
since 	valid isdir run 
keys sets 	diff diff 
elements hashes 	unmodified pair 
elements ordered 	diff file valid 
use trick 	isdir diff 
every aggregate 	file valid isdir 
digest 	run diffstat 
xor digests 	diff unmodified pair 
elements way 	diff file 
order change 	valid isdir diff 
result list 	file valid 
instead use 	isdir run checkdiff 
feedback 	diff unmodified 
entering output 	pair diff file 
digest input 	valid sha 
order ensure 	hex diff debug 
different ordered 	filespec diff 
list result 	debug filespec diff 
different 	debug filepair 
digest start 	diff debug queue 
clean result 	diff pair 
hash dataset 	unmerged diff 
moved different 	file valid diff 
lead different 	file valid 
digest 	diff pair type 
iterate writing 	changed diff 
every entry 	pair rename strcmp 
key val 	hashcmp sha 
digest save 	error diff debug 
key associated 	queue die 
key 	diff flush checkdiff 
expire mix 	diff flush 
xor key 	raw strip prefix 
val digest 	write name 
digest result 	quoted write name 
actually sds 	quoted write 
cast 	name quoted pprint 
trigger memory 	rename similarity 
prevent aof 	index free show 
replication number 	mode change 
quicklist nodes 	diff line 
average quicklist 	prefix fputs show 
fill 	file mode 
factor quicklist 	name fputs show 
fill level 	file mode 
max ziplist 	name fputs show 
size compressed 	rename copy 
total uncompressed 	fputs show rename 
size 	copy write 
newlines errors 	name quoted similarity 
crash handling 	index show 
osx osx 	mode change isspace 
linux linux 	starts space 
linux linux 	git sha update 
osx 	git sha 
osx amd 	init memset memset 
osx linux 	memset error 
linux linux 	diff unmodified 
amd file 	pair diff file 
descriptor write 	valid isdir 
directly 	diff file valid 
redis log 	isdir diff 
write syscall 	pair unmerged diff 
used critical 	fill sha 
sections code 	info diff fill 
rest redis 	sha info 
trusted 	fill mmfile fill 
example memory 	mmfile error 
test api 	space strlen space 
call requires 	strlen snprintf 
raw close 	snprintf snprintf git 
close direct 	sha update 
log 	diff filespec binary 
filedes used 	diff filespec 
close close 	binary git sha 
direct log 	update sha 
filedes returns 	hex git 
logs stack 	sha update sha 
trace 	hex xdi 
backtrace call 	diff outf error 
function designed 	git sha 
called signal 	diff patch diff 
handlers safely 	free filepair 
log anything 	free diff queue 
generate 	clear warning 
stack trace 	warning warning check 
avoid warning 	pair status 
avoid warning 	flush one pair 
write symbols 	diff opt 
log file 	tst memset check 
cleanup 	pair status 
log information 	diff flush stat 
current client 	show numstat 
client currently 	show stats show 
served redis 	shortstats show 
may redis 	dirstat line 
serving 	free diffstat info 
client right 	show dirstat 
check first 	summary empty diff 
argument usually 	summary diff 
key found 	opt tst diff 
inside selected 	opt tst 
print 	fclose fopen die 
info associated 	errno check 
non destructive 	pair status diff 
memory test 	flush patch 
executed segfauls 	diff line prefix 
nothing nothing 	fputs check 
nothing 	pair status diff 
nothing note 	flush patch 
important close 	format callback diff 
file descriptor 	free filepair 
closing may 	free diff queue 
result unmapping 	clear fclose 
memory 	diff opt 
region testing 	tst diff opt 
log stack 	diff opt 
trace log 	clr filter bit 
info client 	tst filter 
list log 	bit tst filter 
current 	bit tst 
client log 	diff queue clear 
dump processor 	filter bit 
registers test 	tst match filter 
memory free 	diff free 
messages call 	filepair match filter 
free 	diff diff 
possibly corrupted 	free filepair free 
memory make 	isgitlink diff 
sure exit 	populate filespec diff 
right signal 	populate filespec 
end instance 	memcmp diff file 
core 	valid diff 
dumped enabled 	file valid 
backtrace logging 	diff populate filespec 
functions debugging 	diff populate 
software watchdog 	filespec diff filespec 
schedule sigalrm 	identical diff 
delivery 	queue clear diff 
specified period 	filespec check 
milliseconds timer 	stat unmatch diff 
already scheduled 	diff opt 
function schedule 	tst diff free 
specified time 	filepair free 
period 	strcmp qsort diffcore 
current timer 	skip stat 
disabled stop 	unmatch diffcore diffcore 
timer period 	rename diffcore 
automatically restart 	merge broken diffcore 
enable software 	pickaxe diffcore 
watchdog 	order diff 
specified period 	resolve rename copy 
milliseconds watchdog 	diffcore apply 
actually disabled 	filter diff opt 
setup signal 	tst diff 
handler configured 	opt diff opt 
period 	clr diff 
smaller twice 	warn rename limit 
timer period 	diff opt 
software watchdog 	tst diff opt 
work reliably 	tst diff 
fix needed 	opt tst diff 
adjust 	opt tst 
current timer 	diff opt tst 
disable software 	diff opt 
watchdog already 	tst diff opt 
disabled stop 	tst diffopt 
current timer 	flags submodule config 
signal 	diff opt 
handler sig 	tst isgitlink 
ign also 	submodule ignored diff 
pending signals 	opt tst 
queue dict.c 	strncmp alloc filespec 
size key 	alloc filespec 
type 	fill filespec fill 
priv data 	filespec diff 
ptr buf 	queue diff opt 
len hash 	tst diff 
type priv 	opt isgitlink isgitlink 
data ptr 	submodule ignored 
type 	diff opt tst 
priv data 	strncmp alloc 
ptr size 	filespec alloc filespec 
next key 	fill filespec 
val index 	fill filespec diff 
entry key 	queue diff 
val 	opt tst diff 
entry auxentry 	opt tst 
key prevde 	diff filespec 
next key 	check stat unmatch 
iter iter 	diff opt 
iter size 	strncmp alloc filespec 
key 	alloc filespec 
malloc dict 	diff queue prepare 
init dict 	temp file 
reset dict 	start command tempfile 
next power 	strbuf read 
dict init 	error close finish 
calloc 	command strbuf 
dict hash 	release tempfile tempfile 
key free 	strbuf detach 
dict key 	diff file valid 
index malloc 	diff populate 
dict hash 	filespec die die 
key 	notes cache 
dict hash 	run textconv die 
val dict 	notes cache 
dict find 	put notes 
dict hash 	cache write diff 
val dict 	opt tst 
free 	check pager config 
entry val 	setup pager 
dict hash 	copyright junio hamano 
key dict 	context metainfo 
compare hash 	fraginfo old commit 
keys dict 	whitespace funcinfo 
free 	use first digit 
entry key 	ignore digits 
dict free 	nothing give layer 
entry val 	defaults core 
free dict 	level commands git 
free entry 	diff files 
key 	never affected setting 
dict free 	diff renames 
entry val 	user happens 
free free 	configuration file like 
dict reset 	gnu diff 
dict clear 	suppress blank empty 
free 	option backwards 
dict hash 	compatibility keep track 
key dict 	files used 
compare hash 	diffing sometimes entry 
keys malloc 	refers temporary 
free dict 	file sometimes existing 
expand 	file sometimes 
dict expand 	dev filename external 
dict expand 	diff read 
needed dict 	entry currently use 
hash key 	diff tempfile 
dict compare 	instance refers temporary 
hash 	file tempfile 
keys hash 	used manage lifetime 
table implementation 	trailing newline 
file memory 	matter like 
hash tables 	fill mmfile size 
insert del 	avoid retrieving 
replace 	blob pointing end 
find random 	incomplete line 
element operations 	skip last blank 
hash tables 	line eof 
resize needed 	paint well emit 
tables power 	prefix rest 
two 	hunk header must 
size used 	begin old 
collisions handled 	always least bytes 
chaining see 	skip hunk 
source code 	header fraginfo color 
information copyright 	trailing blank 
salvatore 	func header filled 
sanfilippo antirez 	setup code 
gmail dot 	color enabled color 
rights reserved 	words algorithm 
redistribution use 	described collect 
source binary 	minus plus lines 
forms 	diff hunk 
without modification 	divided minus lines 
permitted provided 	plus lines 
following conditions 	minus lines plus 
met redistributions 	lines words 
source code 	place two mmfile 
must 	one word 
retain copyright 	line use xdiff 
notice list 	run diff 
conditions following 	two mmfile words 
disclaimer redistributions 	level diff 
binary form 	common parts file 
must 	output plus 
reproduce copyright 	side text diff 
notice list 	words current 
conditions following 	plus used trace 
disclaimer documentation 	current position 
materials provided 	plus file 
distribution 	printed diff words 
neither name 	last minus 
redis names 	used trace last 
contributors may 	minus word 
used endorse 	printed graph work 
promote products 	color words 
derived 	need output graph 
software without 	prefix line 
specific prior 	color words output 
written permission 	generally two 
software provided 	conditions output prefix 
copyright holders 	diff words 
contributors 	last minus diff 
express implied 	words current 
warranties including 	plus diff words 
limited implied 	plus text 
warranties merchantability 	ptr plus 
fitness particular 	text must start 
purpose 	line minus 
disclaimed shall 	word printed graph 
copyright owner 	prefix must 
contributors liable 	printed diff words 
direct indirect 	current plus 
incidental special 	diff words plus 
exemplary 	text ptr 
consequential damages 	diff words current 
including limited 	plus graph 
procurement substitute 	prefix must printed 
goods services 	following posix 
loss use 	requires first decremented 
data 	one len 
profits business 	function starts looking 
interruption however 	begin returns 
caused theory 	iff word found 
liability whether 	find next 
contract strict 	word find 
liability 	end word function 
tort including 	splits words 
negligence otherwise 	buffer text stores 
arising way 	list newline 
use software 	separator saves offsets 
even 	original words 
advised possibility 	buffer orig fake 
damage prototypes 	empty word 
hash functions 	store original boundaries 
hash function 	store one 
popular one 	word executes word 
bernstein 	diff accumulated 
tested best 	buffers special removal 
hash api 	hunk header 
implementation reset 	parsed need context 
hashtable already 	color words 
initialized init 	mode show word 
note 	diff words 
function called 	accumulated buffer 
destroy create 	use already loaded 
hash table 	driver fallback 
initialize hash 	settings truncated middle 
table expand 	cannot happen 
create 	cannot happen eat 
hashtable hashtable 	newline eof 
size invalid 	marker saw line 
smaller number 	nothing without 
elements already 	diff words flush 
inside hashtable 	defer processing 
copy 	end preimage lines 
elements old 	may come 
table note 	skip prefix character 
old hash 	diff suppress 
table empty 	blank empty may 
size zero 	none incomplete 
dict 	line end find 
expand creates 	common prefix 
hash table 	find common 
hash entry 	suffix common prefix 
slot element 	must end 
index pass 	slash loop run 
next 	prefix see 
element remap 	slash common prefix 
hashtable old 	cannot would 
element target 	underrun input pfx 
hash table 	mid mid 
index element 	sfx pfx pfx 
element 	sfx pfx 
already exists 	sfx sfx name 
allocates memory 	name make 
stores key 	sure least one 
hash entry 	printed change 
fields element 	path easiest way 
discarding 	scale linearly 
old key 	alloted width one 
already exists 	column shorter 
key added 	result binary 
scratch already 	diff caller may 
element key 	want print 
dict 	files changed insertions 
replace performed 	deletions omitting 
update operation 	insertions deletions probably 
element key 	less confusing 
exists dict 	skip files changed 
suceed already 	nothing added 
exists 	removed lines bug 
entry free 	git find 
old one 	longest filename max 
free old 	number changes 
one note 	shown room one 
important order 	unmerged characters 
may 	bin xxx yyy 
exactly previous 	bytes display 
one context 	change counts 
think reference 	aligned bin stop 
counting want 	scanning data 
increment decrement 	files width stat 
free 	width term 
reverse search 	columns columns total 
element unlink 	want maximum 
element list 	min max len 
found destroy 	stat name 
entire hash 	width name part 
table 	want maximum 
free elements 	min max change 
free table 	stat graph 
allocated cache 	width part also 
structure initialize 	need width 
table never 	max change nnnn 
fails 	one empty 
clear release 	column end altogether 
hash table 	width max 
need save 	change enough 
next iterator 	space use smaller 
user may 	stat name 
entry 	width width filename 
returning functions 	rest constant 
expand hash 	elements graph part 
table needed 	stat graph 
hash table 	width graph part 
empty expand 	gives filename 
intial 	constant parts graph 
size table 	standard terminal 
full dobule 	size words stat 
size hash 	width limits 
table capability 	maximum width stat 
power two 	name width 
returns 	fixes maximum width 
index free 	filename also 
slot populated 	used divide available 
hash entry 	columns aren 
given key 	enough binary 
key already 	files displayed bin 
exists 	xxx yyy 
returned expand 	bytes instead change 
hashtable needed 	count graph 
compute key 	part treated similarly 
hash search 	graph part 
slot already 	scaled total width 
contain 	small accommodate 
given key 	guaranteed minimum width 
hash tables 	filename part 
implementation file 	separators message message 
memory hash 	overflow making 
tables insert 	line longer maximum 
del 	width guarantee 
replace find 	graph part filename 
random element 	part first 
operations hash 	assign sizes wanted 
tables resize 	ignoring available 
needed tables 	width strlen 
power 	bin xxx yyy 
two size 	bytes bin 
used collisions 	width part starting 
handled chaining 	xxx fit 
see source 	graph width adjust 
code information 	adjustable widths 
copyright 	exceed maximum width 
salvatore sanfilippo 	name width 
antirez gmail 	width name area 
dot rights 	graph width 
reserved redistribution 	width graph area 
use source 	max change 
binary 	used scale graph 
forms without 	properly scale 
modification permitted 	filename scale width 
provided following 	due sanity 
conditions met 	check count 
redistributions source 	bytes report dirstat 
code 	top level 
must retain 	cases everything came 
copyright notice 	single directory 
list conditions 	directory sources sha 
following disclaimer 	changed pre 
redistributions binary 	post content identical 
form 	therefore skip 
must reproduce 	looking file contents 
copyright notice 	altogether dirstat 
list conditions 	file mode really 
following disclaimer 	need look 
documentation materials 	actual file contents 
provided 	fact sha 
distribution neither 	changed enough file 
name redis 	list results 
names contributors 	file contributing equal 
may used 	damage original 
endorse promote 	minus copied 
products 	removed material added 
derived software 	material damages 
without specific 	made preimage resulting 
prior written 	damage zero 
permission software 	know diffcore count 
provided copyright 	changes considers 
holders 	two entries identical 
contributors express 	since content 
implied warranties 	changed know must 
including limited 	kind change 
implied warranties 	force entries damage 
merchantability fitness 	happen even 
particular 	many files everything 
purpose disclaimed 	renames show 
shall copyright 	directories changes binary 
owner contributors 	files counts 
liable direct 	bytes lines must 
indirect incidental 	find way 
special 	normalize binary 
exemplary consequential 	bytes textual lines 
damages including 	following heuristic 
limited procurement 	assumes bytes per 
substitute goods 	line stupid 
services loss 	ugly cheap happen 
use 	even many 
data profits 	files everything renames 
business interruption 	show directories 
however caused 	changes line thru 
theory liability 	line marker 
whether contract 	size firstchar nothing 
strict 	could deflated 
liability tort 	delta could deflated 
including negligence 	two whichever 
otherwise arising 	smaller emit data 
way use 	encoded never 
software even 	use non valid 
advised 	filename anywhere 
possibility damage 	possible dev 
dict enable 	run diff different 
resize dict 	kind objects 
disable resize 	quite common confusing 
make possible 	crazy xdl 
enable 	interfaces crazy xdl 
disable resizing 	interfaces codepaths 
hash table 	check sides checking 
needed important 	old side 
redis use 	deliberate checking newly 
copy write 	introduced changes 
want 	side text check 
move much 	introduces crazy 
memory around 	xdl interfaces least 
child performing 	one context 
saving operations 	line report errors 
note even 	given name 
dict 	sha pair 
resize resizes 	index tells file 
prevented hash 	work contents 
table still 	prepare temp file 
allowed grow 	inflate extract 
ratio number 	read cache benchmark 
elements 	previous version 
buckets dict 	always reads cache 
force resize 	shows makes 
ratio prototypes 	things worse diff 
hash functions 	comparing two 
thomas wang 	linux kernel trees 
bit 	already work 
mix function 	diff comparisons deal 
murmur hash 	small number 
austin appleby 	files reading cache 
note code 	expensive large 
makes assumptions 	project cost outweighs 
machine 	savings inflating 
behaves read 	temporary file 
address without 	practically code helps 
crashing limitations 	used diff 
work incrementally 	cache cached read 
produce results 	cache calling 
little 	want avoid working 
endian big 	directory caller 
endian machines 	doesn need data 
mixing constants 	normal file 
generated offline 	system rather slow 
really magic 	stat open 
happen 	mmap close syscalls 
work well 	contained pack 
initialize hash 	file pack probably 
random mix 	already open 
bytes time 	faster obtain data 
hash handle 	working directory 
last 	loose objects however 
bytes input 	would tend 
mixes hash 	slower need 
ensure last 	individually opened inflated 
bytes well 	sha looking 
incorporated insensitive 	unreusable regular file 
hash 	marked unchanged 
function djb 	guarantee work matches 
hash hash 	looking matches 
api implementation 	file work reuse 
reset hash 	looking work 
table already 	rename detection pickaxe 
initialized 	operation may 
init note 	need grab data 
function called 	blob file 
destroy create 	core comparison diff 
hash table 	filespec data 
initialize hash 	size fields purpose 
table 	demote fail 
resize table 	warn allow inspecting 
minimal size 	situation instead 
contains elements 	refusing convert 
invariant used 	working format canonical 
buckets ratio 	git format 
near 	generate xxxxxx basename 
expand create 	ext entry 
hash table 	produces file entry 
hash table 	produces file 
size invalid 	borrow file work 
smaller number 	even though 
elements 	may sometimes borrow 
already inside 	contents work 
hash table 	always want one 
rehashing table 	mode mode 
size useful 	trustworthy even one 
allocate hash 	sha valid 
table 	diff file valid 
initialize pointers 	one external 
first initialization 	diff command takes 
really rehashing 	diff cmd 
first hash 	name infile 
table accept 	infile sha infile 
keys 	mode infile 
prepare second 	infile sha infile 
hash table 	mode rename 
incremental rehashing 	fallthru use colors 
performs steps 	header intended 
incremental rehashing 	external diff driver 
returns 	strip prefix 
still keys 	molest dev absolute 
move old 	paths filepair 
hash table 	changes file symlink 
otherwise returned 	needs split 
note rehashing 	deletion creation unmerged 
step 	unmerged pathchange 
consists moving 	left time say 
bucket may 	changes checking 
one key 	changed paths 
use chaining 	ignore whitespace options 
old hash 	force look 
table 	inside contents cases 
however since 	always need 
part hash 	recursive drop caller 
table may 	supplied recursive 
composed empty 	bits formats also 
spaces guaranteed 	pickaxe would 
function 	work well say 
rehash even 	recursive patches 
single bucket 	generated submodules diffed 
since visit 	work must 
max empty 	dirtiness shown output 
buckets total 	read cache 
otherwise 	die even fails 
amount work 	safe also 
would unbound 	smudge active cache 
function may 	active fails 
block time 	worry cleaning 
max number 	either full make 
empty 	sense show 
buckets visit 	first hit happened 
note rehashidx 	found make 
overflow sure 	sense exit code 
elements used 	either stuck 
move keys 	form option separate 
bucket 	form option 
old hash 	important checks error 
index hash 	cases caller 
table check 	knows dirstat related 
already rehashed 	option given 
whole table 	command line allow 
rehash 	say function 
rehash amount 	negation input haven 
time milliseconds 	initialized filter 
milliseconds function 	field another diff 
performs step 	filter start 
rehashing safe 	full bits 
iterators 	aon output format 
bound hash 	options stat 
table iterators 	stat width stat 
middle rehashing 	name width 
mess two 	stat count renames 
hash tables 	options xdiff 
otherwise 	options clear previous 
element missed 	settings flags 
duplicated function 	options misc options 
called common 	always end 
lookup update 	user says num 
operations dictionary 	divided scale 
hash 	say internally max 
table automatically 	score num 
migrates actively 	scale convert form 
used element 	arguments form 
target hash 	versions option expect 
table low 	different find 
level 	unique abbrev 
function adds 	stuffs result dots 
entry instead 	alignment function 
setting returns 	written stricter necessary 
dict entry 	support currently 
structure user 	implemented transformers idea 
make 	transformers produce 
sure fill 	diff filepairs way 
field wishes 	want filter 
function also 	clean producing output 
directly exposed 	unmerged interesting 
user api 	deletion addition mode 
called 	type change 
mainly order 	rename interesting valid 
store non 	point path 
pointers inside 	dealing change change 
hash example 	look file 
entry dict 	filesystem diffs 
raw 	patch format useful 
dict mykey 	stat diffs 
entry dict 	nothing check diffs 
integer val 	undecided point 
entry values 	dealing pair whose 
key already 	sides valid 
exists 	type either place 
returned key 	edit rename 
added hash 	copy edit rename 
entry returned 	might connected 
manipulated caller 	broken pair causing 
index element 	pathnames rename 
element 	modification otherwise see 
already exists 	source used 
allocate memory 	multiple renames decrement 
store entry 	count call 
insert element 	copy change entry 
top assumption 	happen anymore 
database 	prepare broken 
system likely 	callers ignore line 
recently added 	numbers computing 
entries accessed 	sha patch returns 
frequently hash 	upon success 
entry fields 	writes result sha 
element 	order raw 
discarding old 	stat summary patch 
key already 	name name 
exists key 	status checkdiff bits 
added scratch 	clear run 
already element 	diff flush patch 
key 	exit status 
dict replace 	setting options file 
performed update 	dev safe 
operation element 	aren supposed produce 
key exists 	output anyway 
dict suceed 	attach patch instead 
already 	report content 
exists entry 	level differences 
free old 	changes diff addremove 
one note 	diff change 
important order 	bit diff contents 
may exactly 	effect otherwise 
previous 	clear whole queue 
one context 	copying empty 
think reference 	outq end function 
counting want 	first clear 
increment decrement 	current entries queue 
free reverse 	matching ones 
dict 	check whether two 
replace raw 	filespecs mode 
simply version 	size identical entries 
dict raw 	come stat 
always returns 	info dirtiness always 
hash 	sides iow 
entry specified 	create one side 
key even 	name unknown 
key already 	mode size 
exists added 	keep ones match 
entry already 	criteria real 
existing 	differences point file 
key returned 	known modified 
see dict 	mode size name 
raw information 	one side 
search element 	unknown need inspect 
table unlink 	identical contents 
element 	caller subtract skip 
list found 	stat unmatch 
destroy entire 	determine many paths 
dictionary free 	dirty due 
elements free 	stat info mismatch 
table allocated 	note please 
cache 	keep following sync 
structure initialize 	diff combined 
table never 	see follow 
fails clear 	renames diff see 
release hash 	follow renames 
table table 	diff shall changes 
fingerprint 	submodule ignored 
bit number 	submodule changes configured 
represents state 	ignored separately 
dictionary given 	path configuration overridden 
time dict 	command line 
properties xored 	may look odd 
together 	preparation feeding 
iterator initialized 	unchanged files produce 
dict fingerprint 	diffs copy 
check fingerprint 	detection would need 
iterator released 	entries diff 
two fingerprints 	core prefixed something 
different 	like haven 
means user 	decided make difference 
iterator performed 	feeding old 
forbidden operations 	diff change 
dictionary iterating 	also effect output 
hash integers 	happens pruned 
summing 	merged rename copy 
every successive 	pairs appropriate 
integer integer 	ignore errors might 
hashing previous 	repository could 
sum basically 	save changes flush 
result hash 	end would 
hash 	need extra call 
hash way 	diffing done 
integers different 	since generating cache 
order likely 	entry slow 
hash different 	path anyway extra 
number hashing 	overhead probably 
step 	isn big deal 
use tomas 	user asked 
wang bit 	exit code either 
integer hash 	want quiet 
hash hash 	exit code 
hash hash 	definitely bother pager 
hash 	former generate 
need save 	output since still 
next iterator 	properly report 
user may 	exit code even 
entry returning 	pager run 
random entry 	could run pager 
hash 	exit code 
table useful 	since done historically 
implement randomized 	easy find 
algorithms sure 	people oneline advising 
elements indexes 	git diff 
rehashidx found 	exit code hooks 
non 	scripts builtin 
empty bucket 	git diff copyright 
linked list 	junio hamano 
need random 	blob file working 
element list 	make sure 
sane way 	one revision 
counting 	pending revision filtering 
elements random 	parameters saw 
index function 	two trees ent 
samples dictionary 	ent ent 
keys random 	uninteresting swap diff 
locations guarantee 	combine merges 
keys 	asked diff densify 
specified count 	user wants 
guarantee non 	dense one explicitly 
duplicated elements 	asked rely 
however make 	could ish rev 
effort things 	pending objects 
returned 	list also could 
pointers hash 	blobs pathspecs 
table entries 	cache files diff 
stored des 	files compare 
points dict 	two random blobs 
entry pointers 	must zero 
must 	compare blob 
room least 	working file cache 
count elements 	diff index 
argument pass 	cached diff compare 
function tell 	two filesystem 
many random 	entities aka index 
elements 	cases errors 
need function 	asked index explicitly 
returns number 	treat git 
items stored 	diff least one 
des may 	path outside 
less count 	repo command would 
hash 	executed outside 
table less 	git repository behaves 
count elements 	way git 
inside enough 	diff index acts 
elements found 	colourful diff 
reasonable amount 	replacement index 
steps 	two paths possible 
note function 	user intended 
suitable need 	inside repository operation 
good distribution 	give usage 
returned items 	message non repository 
need sample 	usage exit 
given 	index diff run 
number continuous 	exit otherwise 
elements run 	usual git diff 
kind algorithm 	scale real 
produce statistics 	terminal size respect 
however function 	stat graph 
much 	width config external 
faster dict 	textconv used 
random key 	cached pending head 
producing elements 	hand eek 
hash table 	arguments look reasonable 
tables rehashing 	diff least 
work 	one merge 
proportional count 	ent objects merge 
pick random 	ent objects 
point inside 	ents ent objects 
larger table 	ents show 
continuous empty 	diff note pick 
entries 	one merge 
far invariant 	random one sha 
dict rehashing 	name mode 
indexes already 	builtin diff usage 
visited rehashing 	opt old 
populated buckets 	mode mode old 
skip 	sha sha 
indexes idx 	old sha valid 
moreover currently 	sha valid 
range second 	old name name 
table elements 	one two 
tables current 	tmp tmp tmp 
rehashing 	revs argc 
index jump 	argv blob 
possible happens 	path revs argc 
going big 	argv blob 
small table 	mode revs argc 
range table 	argv cached 
count 	arg revs argc 
contiguous empty 	argv ent 
buckets jump 	ent swap revs 
locations reach 	argc argv 
count minimum 	ent ents parents 
collect elements 	file revs 
buckets 	argc argv options 
found non 	argc argv 
empty iterating 	prefix rev ent 
function reverse 	paths blob 
bits algorithm 	index result arg 
http graphics 	entry obj 
stanford 	name flags sha 
edu seander 	sha hashcmp 
bithacks html 	diff opt 
reverse parallel 	tst strncmp strncmp 
bit size 	alloc filespec 
must power 	alloc filespec fill 
dict 	filespec fill 
scan used 	filespec diff queue 
iterate elements 	usage guard 
dictionary iterating 	pathspec lstat die 
works following 	errno isreg 
way initially 	islnk die diff 
call 	mnemonic prefix 
function cursor 	canon mode stuff 
function performs 	change canon 
one step 	mode diffcore std 
iteration returns 	diff flush 
cursor must 	canon mode usage 
use 	stuff change 
next call 	diffcore std 
returned cursor 	diff flush strcmp 
iteration complete 	strcmp usage 
function guarantees 	usage setup work 
elements present 	read cache 
dictionary 	preload perror read 
returned start 	cache perror 
end iteration 	run diff index 
however possible 	usage diff 
elements returned 	sha log diff 
multiple times 	flush usage 
every 	sha append diff 
element returned 	combined sha 
callback argument 	clear xcalloc hold 
called privdata 	locked index 
first argument 	discard cache read 
dictionary entry 	cache refresh 
second 	cache update index 
argument works 	able strcmp 
iteration algorithm 	strcmp strcmp 
designed pieter 	strcmp strcmp usage 
noordhuis main 	error setup 
idea increment 	work read cache 
cursor 	preload perror 
starting higher 	run diff files 
order bits 	strcmp strcmp 
instead incrementing 	setup git directory 
cursor normally 	gently path 
bits cursor 	inside repo path 
reversed 	inside repo 
cursor incremented 	gitmodules config git 
bits reversed 	config init 
strategy needed 	revisions usagef diff 
hash table 	index diff 
may resized 	opt diff opt 
iteration 	die setup 
calls dict 	revisions diff setup 
hash tables 	done diff 
always power 	opt setup 
two size 	diff pager strcmp 
use chaining 	strcmp strcmp 
position 	head pending lookup 
element given 	pending parse 
table given 	deref tag die 
computing bitwise 	die hashcpy 
hash key 	die builtin diff 
size size 	files usage 
always 	builtin diff usage 
mask equivalent 	builtin diff 
taking rest 	blobs usage usage 
division hash 	builtin diff 
key size 	index builtin diff 
example current 	builtin diff 
hash 	builtin diff combined 
table size 	diff result 
mask binary 	code refresh index 
position key 	quietly copyright 
hash table 	junio hamano 
always last 	context metainfo fraginfo 
four 	old commit 
bits hash 	whitespace funcinfo use 
output forth 	first digit 
happens table 	ignore digits nothing 
changes size 	give layer 
hash table 	defaults core level 
grows 	commands git 
elements anywhere 	diff files never 
one multiple 	affected setting 
old bucket 	diff renames user 
example say 	happens configuration 
already iterated 	file like gnu 
bit 	diff suppress 
cursor mask 	blank empty option 
hash table 	backwards compatibility 
size hash 	keep track 
table resized 	files used diffing 
elements mask 	sometimes entry 
buckets 	refers temporary file 
obtain substituting 	sometimes existing 
either targeted 	file sometimes dev 
keys already 	filename external 
visited scanning 	diff read entry 
bucket smaller 	currently use 
hash 	diff tempfile instance 
table iterating 	refers temporary 
higher bits 	file tempfile used 
first inverted 	manage lifetime 
counter cursor 	trailing newline matter 
need restart 	like fill 
table 	mmfile size avoid 
size gets 	retrieving blob 
bigger iterating 	pointing end incomplete 
cursors without 	line skip 
end also 	last blank 
without combination 	line eof paint 
bits 	well emit 
already explored 	prefix rest hunk 
similarly table 	header must 
size shrinks 	begin old always 
time example 	least bytes 
going combination 	skip hunk header 
lower 	fraginfo color 
three bits 	trailing blank func 
mask size 	header filled 
already completely 	setup code color 
explored would 	enabled color 
visited sure 	words algorithm described 
tried 	collect minus 
example variations 	plus lines diff 
higher bit 	hunk divided 
need test 	minus lines plus 
wait two 	lines minus 
tables rehashing 	lines plus 
yes 	lines words place 
always iterate 	two mmfile 
smaller table 	one word line 
first test 	use xdiff 
expansions current 	run diff two 
cursor larger 	mmfile words 
table 	level diff common 
example current 	parts file 
cursor also 	output plus side 
larger table 	text diff 
size also 	words current plus 
test inside 	used trace 
larger 	current position plus 
table reduces 	file printed 
problem back 	diff words last 
one table 	minus used 
larger one 	trace last minus 
exists expansion 	word printed 
smaller 	graph work 
one limitations 	color words need 
iterator completely 	output graph 
stateless huge 	prefix line color 
advantage including 	words output 
additional memory 	generally two conditions 
used 	output prefix 
disadvantages resulting 	diff words last 
design possible 	minus diff 
elements however 	words current plus 
usually easy 	diff words 
deal application 	plus text ptr 
level 	plus text 
iterator must 	must start line 
multiple elements 	minus word 
per call 	printed graph prefix 
needs always 	must printed 
keys chained 	diff words current 
given 	plus diff 
bucket expansions 	words plus 
sure miss 	text ptr diff 
keys moving 	words current 
rehashing reverse 	plus graph prefix 
cursor somewhat 	must printed 
hard 	following posix requires 
understand first 	first decremented 
comment supposed 	one len function 
help emit 	starts looking 
entries cursor 	begin returns iff 
make sure 	word found 
smaller 	find next word 
bigger table 	find end 
emit entries 	word function splits 
cursor iterate 	words buffer 
indices larger 	text stores list 
table expansion 	newline separator 
index 	saves offsets 
pointed cursor 	original words buffer 
smaller table 	orig fake 
emit entries 	empty word store 
cursor increment 	original boundaries 
bits covered 	store one word 
smaller 	executes word 
mask bits 	diff accumulated buffers 
covered mask 	special removal 
difference non 	hunk header parsed 
zero unmasked 	need context 
bits incrementing 	color words mode 
reversed 	show word 
cursor operates 	diff words accumulated 
masked bits 	buffer use 
smaller table 	already loaded driver 
increment reverse 	fallback settings 
cursor functions 	truncated middle cannot 
expand 	happen cannot 
hash table 	happen eat 
needed incremental 	newline eof marker 
rehashing already 	saw line 
progress hash 	nothing without diff 
table empty 	words flush 
expand 	defer processing end 
initial size 	preimage lines 
reached ratio 	may come skip 
allowed resize 	prefix character 
hash table 	diff suppress blank 
setting avoid 	empty may 
ratio 	none incomplete line 
elements buckets 	end find 
safe threshold 	common prefix find 
resize doubling 	common suffix 
number buckets 	common prefix must 
hash table 	end slash 
capability 	loop run prefix 
power two 	see slash 
returns index 	common prefix 
free slot 	cannot would underrun 
populated hash 	input pfx 
entry given 	mid mid sfx 
key 	pfx pfx 
key already 	sfx pfx sfx 
exists returned 	sfx name 
note process 	name make sure 
rehashing hash 	least one 
table index 	printed change path 
always 	easiest way 
returned context 	scale linearly alloted 
second hash 	width one 
table expand 	column shorter result 
hash table 	binary diff 
needed compute 	caller may want 
key 	print files 
hash search 	changed insertions deletions 
slot already 	omitting insertions 
contain given 	deletions probably 
key debugging 	less confusing skip 
compute stats 	files changed 
hash 	nothing added removed 
entry slot 	lines bug 
generate human 	git find longest 
readable stats 	filename max 
unlike snprintf 	number changes shown 
teturn number 	room one 
characters 	unmerged characters bin 
actually written 	xxx yyy 
make sure 	bytes display change 
term end 	counts aligned 
dict resize 	bin stop scanning 
dict force 	data files 
resize 	width stat width 
ratio size 	term columns 
key type 	columns total 
priv data 	want maximum min 
ptr key 	max len 
dict 	stat name width 
hash function 	name part 
seed seed 	want maximum min 
key len 	max change 
seed data 	stat graph width 
buf len 	part also 
hash 	need width max 
type priv 	change nnnn 
data ptr 	one empty column 
type priv 	end altogether 
data ptr 	width max change 
minimal size 	enough space 
realsize 	use smaller stat 
empty visits 	name width 
nextde start 	width filename rest 
rehashes key 	constant elements 
val entry 	graph part 
key index 	stat graph width 
entry 	graph part 
key val 	gives filename constant 
entry auxentry 	parts graph 
key entry 	standard terminal size 
key nofree 	words stat 
idx prev 	width limits maximum 
table 	width stat 
key key 	name width fixes 
callback next 	maximum width 
key idx 	filename also used 
table key 	divide available 
integers hash 	columns aren enough 
iter 	binary files 
iter iter 	displayed bin xxx 
orighe listlen 	yyy bytes 
listele des 	instead change count 
count tables 	graph part 
maxsizemask maxsteps 	treated similarly 
emptylen 	graph part scaled 
mask privdata 	total width 
size key 	small accommodate guaranteed 
idx table 	minimum width 
callback buf 	filename part separators 
bufsize tableid 	message message 
chainlen 	overflow making line 
maxchainlen totchainlen 	longer maximum 
clvector buf 	width guarantee graph 
bufsize orig 	part filename 
buf orig 	part first assign 
bufsize tolower 	sizes wanted 
zmalloc 	ignoring available width 
dict init 	strlen bin 
dict reset 	xxx yyy bytes 
dict reset 	bin width 
dict rehashing 	part starting xxx 
dict expand 	fit graph 
dict 	width adjust 
next power 	adjustable widths exceed 
dict rehashing 	maximum width 
zcalloc dict 	name width width 
rehashing dict 	name area 
hash key 	graph width width 
zfree 	graph area 
dict reset 	max change used 
gettimeofday time 	scale graph 
milliseconds dict 	properly scale filename 
rehash time 	scale width 
milliseconds dict 	due sanity check 
rehash 	count bytes 
dict raw 	report dirstat top 
dict val 	level cases 
dict rehashing 	everything came single 
dict rehash 	directory directory 
step dict 	sources sha 
key 	changed pre post 
index dict 	content identical 
rehashing zmalloc 	therefore skip looking 
dict key 	file contents 
dict dict 	altogether dirstat file 
find dict 	mode really 
val 	need look actual 
dict free 	file contents 
val dict 	fact sha changed 
find dict 	enough file 
raw dict 	list results file 
rehashing dict 	contributing equal 
rehash 	damage original minus 
step dict 	copied removed 
hash key 	material added material 
dict compare 	damages made 
keys dict 	preimage resulting damage 
free key 	zero know 
dict 	diffcore count 
free val 	changes considers two 
zfree dict 	entries identical 
rehashing dict 	since content changed 
dict callback 	know must 
dict free 	kind change force 
key 	entries damage 
dict free 	happen even many 
val zfree 	files everything 
zfree dict 	renames show directories 
reset dict 	changes binary 
clear dict 	files counts bytes 
clear 	lines must 
zfree dict 	find way normalize 
rehashing dict 	binary bytes 
rehash step 	textual lines following 
dict hash 	heuristic assumes 
key dict 	bytes per line 
compare 	stupid ugly 
keys dict 	cheap happen 
rehashing dict 	even many files 
find dict 	everything renames 
val zmalloc 	show directories changes 
dict iterator 	line thru 
dict 	line marker size 
fingerprint dict 	firstchar nothing 
rehashing dict 	could deflated delta 
fingerprint zfree 	could deflated 
dict size 	two whichever smaller 
dict rehashing 	emit data 
dict 	encoded never use 
rehash step 	non valid 
dict rehashing 	filename anywhere possible 
random random 	dev run 
random dict 	diff different kind 
size dict 	objects quite 
size 	common confusing crazy 
dict rehashing 	xdl interfaces 
dict rehash 	crazy xdl 
step dict 	interfaces codepaths check 
rehashing random 	sides checking 
random dict 	old side deliberate 
size 	checking newly 
dict rehashing 	introduced changes side 
rev rev 	text check 
dict rehashing 	introduces crazy xdl 
dict expand 	interfaces least 
dict expand 	one context line 
dict 	report errors 
expand needed 	given name sha 
dict hash 	pair index 
key dict 	tells file work 
compare keys 	contents prepare 
dict rehashing 	temp file inflate 
dict 	extract read 
clear dict 	cache benchmark previous 
clear snprintf 	version always 
snprintf snprintf 	reads cache 
strlen dict 	shows makes things 
stats dict 	worse diff 
rehashing 	comparing two linux 
dict stats 	kernel trees 
hash table 	already work diff 
implementation file 	comparisons deal 
memory hash 	small number files 
tables insert 	reading cache 
del 	expensive large project 
replace find 	cost outweighs 
random element 	savings inflating temporary 
operations hash 	file practically 
tables resize 	code helps used 
needed tables 	diff cache 
power 	cached read cache 
two size 	calling want 
used collisions 	avoid working 
handled chaining 	directory caller doesn 
see source 	need data 
code information 	normal file system 
copyright 	rather slow 
salvatore sanfilippo 	stat open mmap 
antirez gmail 	close syscalls 
dot rights 	contained pack file 
reserved redistribution 	pack probably 
use source 	already open faster 
binary 	obtain data 
forms without 	working directory loose 
modification permitted 	objects however 
provided following 	would tend slower 
conditions met 	need individually 
redistributions source 	opened inflated sha 
code 	looking unreusable 
must retain 	regular file marked 
copyright notice 	unchanged guarantee 
list conditions 	work matches 
following disclaimer 	looking matches file 
redistributions binary 	work reuse 
form 	looking work rename 
must reproduce 	detection pickaxe 
copyright notice 	operation may need 
list conditions 	grab data 
following disclaimer 	blob file core 
documentation materials 	comparison diff 
provided 	filespec data size 
distribution neither 	fields purpose 
name redis 	demote fail warn 
names contributors 	allow inspecting 
may used 	situation instead refusing 
endorse promote 	convert working 
products 	format canonical git 
derived software 	format generate 
without specific 	xxxxxx basename ext 
prior written 	entry produces 
permission software 	file entry 
provided copyright 	produces file borrow 
holders 	file work 
contributors express 	even though may 
implied warranties 	sometimes borrow 
including limited 	contents work always 
implied warranties 	want one 
merchantability fitness 	mode mode trustworthy 
particular 	even one 
purpose disclaimed 	sha valid diff 
shall copyright 	file valid 
owner contributors 	one external diff 
liable direct 	command takes 
indirect incidental 	diff cmd name 
special 	infile infile 
exemplary consequential 	sha infile mode 
damages including 	infile infile 
limited procurement 	sha infile mode 
substitute goods 	rename fallthru 
services loss 	use colors 
use 	header intended external 
data profits 	diff driver 
business interruption 	strip prefix molest 
however caused 	dev absolute 
theory liability 	paths filepair changes 
whether contract 	file symlink 
strict 	needs split deletion 
liability tort 	creation unmerged 
including negligence 	unmerged pathchange left 
otherwise arising 	time say 
way use 	changes checking changed 
software even 	paths ignore 
advised 	whitespace options force 
possibility damage 	look inside 
prototypes hash 	contents cases always 
functions hash 	need recursive 
function popular 	drop caller 
one bernstein 	supplied recursive bits 
tested 	formats also 
best hash 	pickaxe would work 
api implementation 	well say 
reset hashtable 	recursive patches generated 
already initialized 	submodules diffed 
init note 	work must dirtiness 
function 	shown output 
called destroy 	read cache die 
create hash 	even fails 
table initialize 	safe also smudge 
hash table 	active cache 
expand create 	active fails worry 
hashtable 	cleaning either 
hashtable size 	full make sense 
invalid smaller 	show first 
number elements 	hit happened found 
already inside 	make sense 
hashtable copy 	exit code 
elements 	either stuck form 
old table 	option separate 
note old 	form option important 
hash table 	checks error 
empty size 	cases caller knows 
zero dict 	dirstat related 
expand 	option given command 
creates hash 	line allow 
table hash 	say function negation 
entry slot 	input haven 
element index 	initialized filter field 
pass next 	another diff 
element 	filter start full 
remap hashtable 	bits aon 
old element 	output format options 
target hash 	stat stat 
table index 	width stat name 
element element 	width stat 
already 	count renames 
exists allocates 	options xdiff options 
memory stores 	clear previous 
key hash 	settings flags options 
entry fields 	misc options 
element discarding 	always end user 
old 	says num 
key already 	divided scale say 
exists key 	internally max 
added scratch 	score num scale 
already element 	convert form 
key dict 	arguments form versions 
replace 	option expect 
performed update 	different find unique 
operation element 	abbrev stuffs 
key exists 	result dots alignment 
dict suceed 	function written 
already exists 	stricter necessary support 
entry 	currently implemented 
free old 	transformers idea 
one free 	transformers produce diff 
old one 	filepairs way 
note important 	want filter clean 
order may 	producing output 
exactly 	unmerged interesting deletion 
previous one 	addition mode 
context think 	type change rename 
reference counting 	interesting valid 
want increment 	point path dealing 
decrement free 	change change 
reverse 	look file filesystem 
search element 	diffs patch 
unlink element 	format useful stat 
list found 	diffs nothing 
destroy entire 	check diffs undecided 
hash table 	point dealing 
free 	pair whose 
elements free 	sides valid type 
table allocated 	either place 
cache structure 	edit rename copy 
initialize table 	edit rename 
never fails 	might connected broken 
clear 	pair causing 
release hash 	pathnames rename modification 
table need 	otherwise see 
save next 	source used multiple 
iterator user 	renames decrement 
may entry 	count call copy 
returning 	change entry 
functions expand 	happen anymore prepare 
hash table 	broken callers 
needed hash 	ignore line numbers 
table empty 	computing sha 
expand intial 	patch returns upon 
size 	success writes 
table full 	result sha 
dobule size 	order raw stat 
hash table 	summary patch 
capability power 	name name status 
two returns 	checkdiff bits 
index 	clear run diff 
free slot 	flush patch 
populated hash 	exit status setting 
entry given 	options file 
key key 	dev safe aren 
already exists 	supposed produce 
returned 	output anyway attach 
expand hashtable 	patch instead 
needed compute 	report content level 
key hash 	differences changes 
search slot 	diff addremove diff 
already contain 	change bit 
given 	diff contents effect 
key hash 	otherwise clear 
tables implementation 	whole queue 
file memory 	copying empty outq 
hash tables 	end function 
insert del 	first clear current 
replace 	entries queue 
find random 	matching ones check 
element operations 	whether two 
hash tables 	filespecs mode size 
resize needed 	identical entries 
tables power 	come stat info 
two 	dirtiness always 
size used 	sides iow create 
collisions handled 	one side 
chaining see 	name unknown mode 
source code 	size keep 
information copyright 	ones match criteria 
salvatore 	real differences 
sanfilippo antirez 	point file known 
gmail dot 	modified mode 
rights reserved 	size name 
redistribution use 	one side unknown 
source binary 	need inspect 
forms 	identical contents caller 
without modification 	subtract skip 
permitted provided 	stat unmatch determine 
following conditions 	many paths 
met redistributions 	dirty due stat 
source code 	info mismatch 
must 	note please keep 
retain copyright 	following sync 
notice list 	diff combined see 
conditions following 	follow renames 
disclaimer redistributions 	diff see follow 
binary form 	renames diff 
must 	shall changes submodule 
reproduce copyright 	ignored submodule 
notice list 	changes configured ignored 
conditions following 	separately path 
disclaimer documentation 	configuration overridden 
materials provided 	command line may 
distribution 	look odd 
neither name 	preparation feeding unchanged 
redis names 	files produce 
contributors may 	diffs copy detection 
used endorse 	would need 
promote products 	entries diff core 
derived 	prefixed something 
software without 	like haven decided 
specific prior 	make difference 
written permission 	feeding old diff 
software provided 	change also 
copyright holders 	effect output happens 
contributors 	pruned merged 
express implied 	rename copy pairs 
warranties including 	appropriate ignore 
limited implied 	errors might 
warranties merchantability 	repository could save 
fitness particular 	changes flush 
purpose 	end would need 
disclaimed shall 	extra call 
copyright owner 	diffing done since 
contributors liable 	generating cache 
direct indirect 	entry slow path 
incidental special 	anyway extra 
exemplary 	overhead probably isn 
consequential damages 	big deal 
including limited 	user asked exit 
procurement substitute 	code either 
goods services 	want quiet exit 
loss use 	code definitely 
data 	bother pager former 
profits business 	generate output 
interruption however 	since still properly 
caused theory 	report exit 
liability whether 	code even 
contract strict 	pager run could 
liability 	run pager 
tort including 	exit code since 
negligence otherwise 	done historically 
arising way 	easy find people 
use software 	oneline advising 
even advised 	git diff exit 
possibility 	code hooks 
damage dict 	scripts builtin git 
enable resize 	diff copyright 
dict disable 	junio hamano blob 
resize make 	file working 
possible 	make sure one 
enable disable 	revision pending 
resizing hash 	revision filtering parameters 
table needed 	saw two 
important redis 	trees ent ent 
use copy 	ent uninteresting 
write 	swap diff 
want move 	combine merges asked 
much memory 	diff densify 
around child 	user wants dense 
performing saving 	one explicitly 
operations note 	asked rely could 
even 	ish rev 
dict resize 	pending objects list 
resizes prevented 	also could 
hash table 	blobs pathspecs cache 
still allowed 	files diff 
grow ratio 	files compare two 
number 	random blobs 
elements buckets 	must zero compare 
dict force 	blob working 
resize ratio 	file cache diff 
prototypes hash 	index cached 
functions thomas 	diff compare two 
wang 	filesystem entities 
bit mix 	aka index 
function murmur 	cases errors asked 
hash austin 	index explicitly 
appleby note 	treat git diff 
code makes 	least one 
assumptions 	path outside repo 
machine behaves 	command would 
read address 	executed outside git 
without crashing 	repository behaves 
limitations work 	way git diff 
incrementally produce 	index acts 
results 	colourful diff replacement 
little endian 	index two 
big endian 	paths possible user 
machines mixing 	intended inside 
constants generated 	repository operation give 
offline really 	usage message 
magic 	non repository 
happen work 	usage exit index 
well initialize 	diff run 
hash random 	exit otherwise usual 
mix bytes 	git diff 
time hash 	scale real terminal 
handle 	size respect 
last bytes 	stat graph width 
input mixes 	config external 
hash ensure 	textconv used cached 
last bytes 	pending head 
well incorporated 	hand eek arguments 
insensitive 	look reasonable 
hash function 	diff least one 
djb hash 	merge ent 
hash api 	objects merge ent 
implementation reset 	objects ents 
hash table 	ent objects ents 
already 	show diff 
initialized init 	note pick 
note function 	one merge random 
called destroy 	one diff.c 
create hash 	diff detect rename 
table initialize 	diff rename 
hash 	limit diff suppress 
table resize 	blank empty 
table minimal 	diff use color 
size contains 	diff context 
elements invariant 	diff word regex 
used buckets 	cfg external 
ratio 	diff cmd cfg 
near expand 	diff order 
create hash 	file cfg diff 
table hash 	refresh index 
table size 	diff mnemonic prefix 
invalid smaller 	diff prefix 
number 	diff stat graph 
elements already 	width diff 
inside hash 	dirstat permille 
table rehashing 	diff options diff 
table size 	algorithm diff 
useful allocate 	colors options errmsg 
hash 	copy ret 
table initialize 	end permille options 
pointers first 	name slot 
initialization really 	errmsg one two 
rehashing first 	need one 
hash table 	need two res 
accept 	external diff 
keys prepare 	cmd done preparing 
second hash 	name hex 
table incremental 	mode tempfile color 
rehashing performs 	diff rule 
steps incremental 	blank eof preimage 
rehashing 	blank eof 
returns still 	postimage lno preimage 
keys move 	lno postimage 
old hash 	truncate label 
table otherwise 	path diff words 
returned note 	opt found 
rehashing 	changesp header data 
step consists 	size count 
moving bucket 	seen one one 
may one 	rule ptr 
key use 	size cnt prev 
chaining old 	eol ecbdata 
hash 	rule reset first 
table however 	line len 
since part 	trailing newline trailing 
hash table 	carriage nofirst 
may composed 	file reset line 
empty spaces 	len ecbdata 
guaranteed 	line len emit 
function rehash 	line reset 
even single 	ecbdata line 
bucket since 	len reset ecbdata 
visit max 	line len 
empty buckets 	reset ecbdata line 
total 	len ecbdata 
otherwise amount 	line len context 
work would 	frag func 
unbound function 	reset atat msgbuf 
may block 	len file 
time max 	count ecb prefix 
number 	data size 
empty buckets 	endp nneof reset 
visit note 	len context 
rehashidx overflow 	name name one 
sure elements 	two textconv 
used move 	one textconv two 
keys 	name tab 
bucket old 	name tab metainfo 
hash index 	fraginfo reset 
hash table 	name prefix 
check already 	prefix data one 
rehashed whole 	data two 
table 	size one size 
rehash rehash 	two ecbdata 
amount time 	line prefix text 
milliseconds milliseconds 	alloc begin 
function performs 	end orig orig 
step rehashing 	alloc line 
safe 	len buffer prefix 
iterators bound 	suffix color 
hash table 	old ctx newline 
iterators middle 	diff words 
rehashing mess 	styles minus plus 
two hash 	current plus 
tables 	last minus opt 
otherwise element 	word regex 
missed duplicated 	style newline count 
function called 	buf line 
common lookup 	prefix print 
update operations 	diff words priv 
dictionary 	line len 
hash table 	diff words style 
automatically migrates 	minus first 
actively used 	minus len plus 
element target 	first plus 
hash table 	len minus begin 
low 	minus end 
level function 	plus begin plus 
adds entry 	end opt 
instead setting 	line prefix buffer 
returns dict 	word regex 
entry structure 	begin end match 
user 	buffer word 
make sure 	regex alloc diff 
fill field 	words xpp 
wishes function 	xecfg minus plus 
also directly 	style opt 
exposed user 	line prefix 
api 	ecbdata one one 
called mainly 	ecbdata orig 
order store 	opts one two 
non pointers 	ecbdata diff 
inside hash 	color opt msgbuf 
example entry 	ecb line 
dict 	len allot line 
raw dict 	ecbdata priv 
mykey entry 	line len ecbdata 
dict integer 	meta context 
val entry 	reset line prefix 
values key 	name tab 
already 	name tab old 
exists returned 	name pfx 
key added 	length sfx length 
hash entry 	pfx adjust 
returned manipulated 	slash len len 
caller index 	midlen midlen 
element 	qlen qlen 
element already 	alloc name name 
exists allocate 	print name 
memory store 	added deleted diffstat 
entry insert 	name name 
element top 	priv line len 
assumption 	diffstat mime 
database system 	boundary leader width 
likely recently 	max change 
added entries 	file prefix name 
accessed frequently 	len file 
hash entry 	cnt reset file 
fields 	pname buf 
element discarding 	files insertions deletions 
old key 	ret data 
already exists 	options len del 
key added 	dels max 
scratch already 	len count 
element 	width name width 
key dict 	graph width 
replace performed 	bin width reset 
update operation 	del line 
element key 	prefix extra shown 
exists dict 	file change 
suceed 	prefix file name 
already exists 	added deleted 
entry free 	name len slash 
old one 	total file 
note important 	added deleted data 
order may 	options total 
exactly 	files added deleted 
previous one 	data options 
context think 	file name changed 
reference counting 	files alloc 
want increment 	permille cumulative opt 
decrement free 	dir changed 
reverse 	baselen dir 
dict replace 	sources line prefix 
raw simply 	namelen slash 
version dict 	newbaselen permille options 
raw always 	changed dir 
returns hash 	name copied added 
entry 	damage content 
specified key 	changed data options 
even key 	changed dir 
already exists 	file damage diffstat 
added entry 	filename lineno 
already existing 	conflict marker size 
key 	rule status 
returned see 	line marker size 
dict raw 	len firstchar 
information search 	cnt priv line 
element table 	len data 
unlink element 	marker size reset 
list 	err line 
found destroy 	prefix bad 
entire dictionary 	plus data size 
free elements 	result size 
free table 	bound deflated stream 
allocated cache 	file one 
structure 	two prefix delta 
initialize table 	deflated data 
never fails 	orig size delta 
clear release 	size deflate 
hash table 	size data size 
table fingerprint 	free bytes 
bit 	line file one 
number represents 	two prefix 
state dictionary 	one one options 
given time 	one name 
dict properties 	name one two 
xored together 	xfrm msg 
iterator 	must show header 
initialized dict 	complete rewrite 
fingerprint check 	lbl one 
fingerprint iterator 	two meta reset 
released two 	prefix prefix 
fingerprints different 	textconv one textconv 
means 	two header 
user iterator 	line prefix del 
performed forbidden 	diffopts xpp 
operations dictionary 	xecfg ecbdata name 
iterating hash 	name one 
integers summing 	two diffstat data 
every 	contents complete 
successive integer 	rewrite xpp xecfg 
integer hashing 	name name 
previous sum 	attr path one 
basically result 	two data 
hash hash 	xpp xecfg ecbdata 
hash 	blank eof 
way integers 	err path 
different order 	spec spec spec 
likely hash 	sha sha 
different number 	valid mode name 
hashing step 	sha want 
use 	file pos len 
tomas wang 	size buf 
bit integer 	dirty flags size 
hash hash 	err buf 
hash hash 	size path temp 
hash hash 	blob size 
need 	sha mode buf 
save next 	path dup 
iterator user 	name one temp 
may entry 	argv name 
returning random 	temp pgm name 
entry hash 	one two 
table 	xfrm msg complete 
useful implement 	rewrite argv 
randomized algorithms 	env msg 
sure elements 	name one two 
indexes rehashidx 	must show 
found non 	header use color 
empty 	reset line 
bucket linked 	prefix abbrev pgm 
list need 	name attr 
random element 	path one two 
list sane 	msg xfrm 
way counting 	msg complete rewrite 
elements 	must show 
random index 	header drv one 
function samples 	prefix length 
dictionary keys 	namep otherp pgm 
random locations 	msg one 
guarantee keys 	two name attr 
specified 	path diffstat 
count guarantee 	name name attr 
non duplicated 	path options 
elements however 	options count 
make effort 	arg arg arg 
things returned 	val len 
pointers 	end end opt 
hash table 	opt argv 
entries stored 	optarg arg opt 
des points 	argv optarg 
dict entry 	arg options arg 
pointers must 	end width 
room 	name width graph 
least count 	width count 
elements argument 	argcount options errmsg 
pass function 	options diff 
tell many 	status letters filter 
random elements 	bit status 
need 	opt optarg opt 
function returns 	optch bit 
number items 	negate fmt arg 
stored des 	token rest 
may less 	opt arg 
count hash 	orig arg val 
table 	options prefix 
less count 	arg optarg argcount 
elements inside 	path offending 
enough elements 	path num scale 
found reasonable 	dot opt 
amount steps 	opt opt cmd 
note 	diff queued 
function suitable 	diff queue queue 
need good 	one two 
distribution returned 	sha len abblen 
items need 	abbrev hex 
sample given 	opt line termination 
number 	inter name 
continuous elements 	termination name name 
run kind 	name name 
algorithm produce 	two diffstat 
statistics however 	one msg opt 
function much 	fmt name 
faster 	name file newdelete 
dict random 	file show 
key producing 	name line prefix 
elements hash 	file renamecopy 
table tables 	line prefix names 
rehashing work 	opt file 
proportional 	line prefix ctx 
count pick 	patchlen line 
random point 	len dst priv 
inside larger 	line len 
table continuous 	data len options 
empty entries 	sha ctx 
far 	data buffer xpp 
invariant dict 	xecfg len 
rehashing indexes 	len options sha 
already visited 	result rename 
rehashing populated 	limit warning 
buckets skip 	degrade warning rename 
indexes 	limit advice 
idx moreover 	varname needed degraded 
currently range 	options output 
second table 	format separator dirstat 
elements tables 	line diffstat 
current rehashing 	options options outq 
index 	found one 
jump possible 	two diffopt outq 
happens going 	name name 
big small 	options options opt 
table range 	status result 
table count 	opt path options 
contiguous 	ignored orig 
empty buckets 	flags options addremove 
jump locations 	mode sha 
reach count 	sha valid concatpath 
minimum collect 	dirty submodule 
elements buckets 	one two 
found 	options old mode 
non empty 	mode old 
iterating function 	sha sha old 
reverse bits 	sha valid 
algorithm http 	sha valid concatpath 
graphics stanford 	old dirty 
edu 	submodule dirty submodule 
seander bithacks 	one two 
html reverse 	tmp tmp options 
parallel bit 	path pair 
size must 	one two pgm 
power dict 	spec outsize 
scan 	temp argv arg 
used iterate 	child buf 
elements dictionary 	err driver outbuf 
iterating works 	size opt 
following way 	strcasecmp strcasecmp strcasecmp 
initially call 	strcasecmp strcasecmp 
function 	strcasecmp strcasecmp 
cursor function 	strcasecmp strcasecmp xstrdup 
performs one 	list split 
step iteration 	place strcmp diff 
returns cursor 	opt clr 
must use 	diff opt clr 
next 	strcmp diff 
call returned 	opt diff opt 
cursor iteration 	clr strcmp 
complete function 	diff opt clr 
guarantees elements 	diff opt 
present dictionary 	strcmp diff opt 
returned 	clr strcmp 
start end 	diff opt isdigit 
iteration however 	strtoul isdigit 
possible elements 	isdigit strbuf addf 
returned multiple 	strbuf addf 
times 	list clear free 
every element 	strcmp diff 
returned callback 	opt strcmp 
argument called 	diff opt clr 
privdata first 	strcasecmp strcasecmp 
argument dictionary 	git config strcasecmp 
entry 	strcasecmp strcasecmp 
second argument 	strcasecmp strcasecmp strcmp 
works iteration 	strcmp git 
algorithm designed 	config colorbool strcmp 
pieter noordhuis 	git config 
main idea 	strcmp git config 
increment 	rename strcmp 
cursor starting 	git config strcmp 
higher order 	git config 
bits instead 	strcmp git config 
incrementing cursor 	strcmp git 
normally bits 	config strcmp git 
cursor 	config strcmp 
reversed cursor 	git config 
incremented bits 	strcmp git config 
reversed strategy 	pathname strcmp 
needed hash 	handle ignore submodules 
table may 	arg strcmp 
resized 	parse submodule warning 
iteration calls 	strcmp parse 
dict hash 	algorithm git color 
tables always 	config git 
power two 	diff basic config 
size use 	strcmp git 
chaining 	config userdiff config 
position element 	skip prefix 
given table 	skip prefix parse 
given computing 	diff color 
bitwise hash 	slot config error 
key size 	nonbool color 
size 	parse strcmp strcmp 
always mask 	git config 
equivalent taking 	strcmp parse 
rest division 	dirstat warning strbuf 
hash key 	release starts 
size example 	parse submodule config 
current 	option git 
hash table 	config quote style 
size mask 	quote style 
binary position 	strbuf addch quote 
key hash 	style quote 
table always 	style strbuf addch 
last 	strbuf addstr 
four bits 	strbuf addstr strbuf 
hash output 	detach getenv 
forth happens 	diff file valid 
table changes 	diff populate 
size hash 	filespec diff file 
table 	valid diff 
grows elements 	populate filespec blank 
anywhere one 	line count 
multiple old 	trailing blank 
bucket example 	count trailing blank 
say already 	count lines 
iterated 	count lines fputs 
bit cursor 	diff line 
mask hash 	prefix fputs fputc 
table size 	fwrite fputs 
hash table 	fputc fputc emit 
resized elements 	line blank 
mask 	line emit line 
buckets obtain 	emit line 
substituting either 	emit line diff 
targeted keys 	color diff 
already visited 	color diff color 
scanning bucket 	diff color 
smaller 	memcmp memmem emit 
hash table 	line strbuf 
iterating higher 	addstr strbuf strbuf 
bits first 	addstr strbuf 
inverted counter 	addstr strbuf 
cursor need 	strbuf addstr strbuf 
restart 	addstr strbuf 
table size 	strbuf addstr strbuf 
gets bigger 	emit line 
iterating cursors 	strbuf release size 
without end 	die size 
also without 	tempfile active tempfile 
combination 	diff color 
bits already 	memchr emit del 
explored similarly 	line emit 
table size 	line diff color 
shrinks time 	putc emit 
example going 	line strlen diff 
combination 	color diff 
lower three 	color diff color 
bits mask 	diff line 
size already 	prefix diff 
completely explored 	opt tst strchr 
would visited 	strchr strbuf 
sure 	reset strbuf reset 
tried example 	quote two 
variations higher 	style quote two 
bit need 	style fill 
test wait 	textconv fill textconv 
two tables 	memset want 
rehashing 	color whitespace rule 
yes always 	check blank 
iterate smaller 	eof count lines 
table first 	count lines 
test expansions 	print line count 
current cursor 	print line 
larger 	count emit rewrite 
table example 	lines emit 
current cursor 	rewrite lines free 
also larger 	free alloc 
table size 	grow memcpy 
also test 	memchr fputs fputs 
inside 	fputs fwrite 
larger table 	fputs fputs fputs 
reduces problem 	parse hunk 
back one 	header diff line 
table larger 	prefix color 
one exists 	words output graph 
expansion 	prefix fputs 
smaller one 	diff words write 
limitations iterator 	helper fputs 
completely stateless 	diff words write 
huge advantage 	helper diff 
including additional 	words write helper 
memory 	regexec memchr 
used disadvantages 	isspace isspace alloc 
resulting design 	grow find 
possible elements 	word boundaries alloc 
however usually 	grow alloc 
easy deal 	grow memcpy 
application 	diff line prefix 
level iterator 	fputs diff 
must multiple 	words write helper 
elements per 	memset memset 
call needs 	diff words fill 
always keys 	diff words 
chained 	fill xdi diff 
given bucket 	outf die 
expansions sure 	free free color 
miss keys 	words output 
moving rehashing 	graph prefix fputs 
reverse cursor 	diff words 
somewhat 	write helper diff 
hard understand 	words show 
first comment 	isreg userdiff find 
supposed help 	path userdiff 
emit entries 	find name diff 
cursor make 	filespec load 
sure 	driver xmalloc 
smaller bigger 	memcpy xcalloc userdiff 
table emit 	word regex 
entries cursor 	userdiff word regex 
iterate indices 	xmalloc regcomp 
larger table 	die size want 
expansion 	color diff 
index pointed 	color opt diff 
cursor smaller 	color opt 
table emit 	diff color opt 
entries cursor 	diff words 
increment bits 	flush free free 
covered 	free free 
smaller mask 	free regfree free 
bits covered 	free output 
mask difference 	prefix truncate utf 
non zero 	width strchr 
unmasked bits 	strtol strchr 
incrementing 	strtol diff color 
reversed cursor 	diff color 
operates masked 	diff color diff 
bits smaller 	line prefix 
table increment 	strbuf reset strchr 
reverse cursor 	strchr diff 
functions 	words flush sane 
expand hash 	truncate line 
table needed 	find lno emit 
incremental rehashing 	hunk header 
already progress 	putc emit line 
hash table 	fputs diff 
empty 	words append diff 
expand initial 	words append 
size reached 	starts diff words 
ratio allowed 	flush emit 
resize hash 	line fputs emit 
table setting 	line emit 
avoid 	line emit 
ratio elements 	del line emit 
buckets safe 	context line 
threshold resize 	emit line diff 
doubling number 	color strlen 
buckets hash 	strlen quote style 
table 	quote style 
capability power 	quote style strbuf 
two returns 	addstr quote 
index free 	style strbuf detach 
slot populated 	strbuf grow 
hash entry 	strbuf strbuf addch 
given 	strbuf strbuf 
key key 	addstr strbuf strbuf 
already exists 	addch strbuf 
returned note 	strbuf detach xcalloc 
process rehashing 	alloc grow 
hash table 	xstrdup xstrdup xstrdup 
index 	putc quote 
always returned 	style strbuf 
context second 	detach strbuf release 
hash table 	pprint rename 
expand hash 	strbuf addf strbuf 
table needed 	addf strbuf 
compute 	addf strbuf addch 
key hash 	fputs strbuf 
search slot 	release diff line 
already contain 	prefix diff 
given key 	color opt diff 
debugging compute 	color opt 
stats 	diff color opt 
hash entry 	fill print 
slot generate 	name strlen width 
human readable 	width term 
stats unlike 	columns width width 
snprintf teturn 	strlen strchr 
number 	show name putc 
characters actually 	show name 
written make 	scale linear 
sure term 	scale linear scale 
end dict.c 	linear show 
size key 	name show graph 
type 	show graph 
priv data 	print stat summary 
ptr buf 	diff line 
len hash 	prefix print stat 
type priv 	summary diff 
data ptr 	line prefix fill 
type 	print name 
priv data 	write name quoted 
ptr size 	fputs putc 
next key 	putc write name 
val index 	quoted write 
entry key 	name quoted diff 
val 	line prefix 
entry auxentry 	strlen memcmp strchr 
key prevde 	gather dirstat 
next key 	strcmp diff 
iter iter 	opt tst hashcmp 
iter size 	diff opt 
key 	tst diff file 
malloc dict 	valid diff 
init dict 	file valid diff 
reset dict 	populate filespec 
next power 	diff populate filespec 
dict init 	diffcore count 
calloc 	changes diff free 
dict hash 	filespec data 
key free 	diff free filespec 
dict key 	data diff 
index malloc 	file valid diff 
dict hash 	populate filespec 
key 	diff free filespec 
dict hash 	data diff 
val dict 	file valid 
dict find 	diff populate filespec 
dict hash 	diff free 
val dict 	filespec data alloc 
free 	grow qsort 
entry val 	gather dirstat diff 
dict hash 	opt tst 
key dict 	alloc grow qsort 
compare hash 	gather dirstat 
keys dict 	free free free 
free 	free free 
entry key 	isspace diff color 
dict free 	diff color 
entry val 	diff color diff 
free dict 	line prefix 
free entry 	conflict marker check 
key 	whitespace error 
dict free 	free emit line 
entry val 	check emit 
free free 	strchr strtol 
dict reset 	die git deflate 
dict clear 	init git 
free 	deflate bound xmalloc 
dict hash 	git deflate 
key dict 	git deflate end 
compare hash 	deflate diff 
keys malloc 	delta deflate free 
free dict 	free free 
expand 	encode fputs fputc 
dict expand 	free emit 
dict expand 	binary diff body 
needed dict 	emit binary 
hash key 	diff body diff 
dict compare 	filespec load 
hash 	driver diff file 
keys hash 	valid diff 
table implementation 	populate filespec buffer 
file memory 	binary diff 
hash tables 	filespec load 
insert del 	driver diff file 
replace 	valid diff 
find random 	filespec load driver 
element operations 	userdiff textconv 
hash tables 	diff color opt 
resize needed 	diff color 
tables power 	opt diff line 
two 	prefix diff 
size used 	opt tst isgitlink 
collisions handled 	isgitlink diff 
chaining see 	color opt diff 
source code 	color opt 
information copyright 	show submodule summary 
salvatore 	diff opt 
sanfilippo antirez 	tst textconv textconv 
gmail dot 	diff mnemonic 
rights reserved 	prefix diff opt 
redistribution use 	tst diff 
source binary 	file valid 
forms 	diff file valid 
without modification 	quote two 
permitted provided 	quote two diff 
following conditions 	file valid 
met redistributions 	diff file valid 
source code 	strbuf addf 
must 	strbuf addf strbuf 
retain copyright 	addstr strbuf 
notice list 	addf strbuf addstr 
conditions following 	strbuf addf 
disclaimer redistributions 	strbuf addf strbuf 
binary form 	addstr diff 
must 	filespec binary diff 
reproduce copyright 	filespec binary 
notice list 	strbuf reset emit 
conditions following 	rewrite diff 
disclaimer documentation 	strbuf reset 
materials provided 	diff opt tst 
distribution 	diff filespec 
neither name 	binary diff filespec 
redis names 	binary isreg 
contributors may 	isreg diff opt 
used endorse 	tst hashcmp 
promote products 	fill mmfile fill 
derived 	mmfile die 
software without 	memcmp strbuf reset 
specific prior 	diff opt 
written permission 	tst emit binary 
software provided 	diff getenv 
copyright holders 	strbuf reset fill 
contributors 	textconv fill 
express implied 	textconv diff funcname 
warranties including 	pattern diff 
limited implied 	funcname pattern memset 
warranties merchantability 	memset memset 
fitness particular 	want color 
purpose 	whitespace rule check 
disclaimed shall 	blank eof 
copyright owner 	diff opt tst 
contributors liable 	xdiff find 
direct indirect 	func skip prefix 
incidental special 	strtoul skip 
exemplary 	prefix strtoul init 
consequential damages 	diff words 
including limited 	data xdi diff 
procurement substitute 	outf die 
goods services 	free diff words 
loss use 	data free 
data 	free xdiff clear 
profits business 	find func 
interruption however 	strbuf release diff 
caused theory 	free filespec 
liability whether 	data diff free 
contract strict 	filespec data 
liability 	free free 
tort including 	diff pair unmerged 
negligence otherwise 	diffstat hashcmp 
arising way 	diff filespec binary 
use software 	diff filespec 
even advised 	binary diff filespec 
possibility 	size diff 
damage prototypes 	filespec size diff 
hash functions 	populate filespec 
hash function 	diff populate filespec 
popular one 	count lines 
bernstein tested 	count lines fill 
best 	mmfile fill 
hash api 	mmfile die memset 
implementation reset 	memset xdi 
hashtable already 	diff outf die 
initialized init 	diff free 
note function 	filespec data diff 
called 	free filespec 
destroy create 	data memset 
hash table 	whitespace rule merge 
initialize hash 	marker size 
table expand 	fill mmfile fill 
create hashtable 	mmfile die 
hashtable 	diff filespec binary 
size invalid 	memset memset 
smaller number 	xdi diff outf 
elements already 	die check 
inside hashtable 	blank eof whitespace 
copy elements 	error diff 
old 	free filespec data 
table note 	diff free 
old hash 	filespec data diff 
table empty 	opt flexptr 
size zero 	alloc str diff 
dict expand 	free filespec 
creates 	data free 
hash table 	canon mode hashcpy 
hash entry 	sha pack 
slot element 	strlen cache name 
index pass 	pos hashcmp 
next element 	isreg skip worktree 
remap 	uptodate lstat 
hashtable old 	match stat strbuf 
element target 	addf sha 
hash table 	hex strbuf release 
index element 	strbuf detach 
element already 	diff file valid 
exists 	die isdir 
allocates memory 	isgitlink diff populate 
stores key 	gitlink reuse 
hash entry 	worktree file lstat 
fields element 	xsize islnk 
discarding old 	strbuf readlink strbuf 
key 	detach open 
already exists 	xmmap close 
key added 	convert git munmap 
scratch already 	strbuf detach 
element key 	sha info die 
dict replace 	sha hex 
performed 	read sha file 
update operation 	die sha 
element key 	hex free munmap 
exists dict 	diff free 
suceed already 	filespec blob free 
exists 	xstrdup basename 
entry free 	strbuf addstr strbuf 
old one 	addstr mks 
free old 	tempfile strlen die 
one note 	errno convert 
important order 	working write full 
may 	die errno 
exactly previous 	close tempfile tempfile 
one context 	path sha 
think reference 	hex xsnprintf 
counting want 	strbuf release strbuf 
increment decrement 	release free 
free 	claim diff tempfile 
reverse search 	diff file 
element unlink 	valid xsnprintf xsnprintf 
element list 	isgitlink reuse 
found destroy 	worktree file lstat 
entire hash 	die errno 
table 	islnk strbuf readlink 
free elements 	die errno 
free table 	prep temp blob 
allocated cache 	strbuf release 
structure initialize 	sha hex sha 
table never 	hex xsnprintf 
fails 	diff populate filespec 
clear release 	die prep 
hash table 	temp blob prepare 
need save 	temp file 
next iterator 	argv push 
user may 	argv push argv 
entry 	push argv 
returning functions 	push argv push 
expand hash 	external diff 
table needed 	name external diff 
hash table 	name external 
empty expand 	diff name argv 
intial 	push argv 
size table 	push argv pushf 
full dobule 	argv pushf 
size hash 	run command opt 
table capability 	env die 
power two 	tempfile argv clear 
returns 	argv clear 
index free 	diff color diff 
slot populated 	color diff 
hash entry 	line prefix strbuf 
given key 	init strbuf 
key already 	addf similarity 
exists 	index strbuf addf 
returned expand 	quote style 
hashtable needed 	strbuf addf quote 
compute key 	style strbuf 
hash search 	addf strbuf addf 
slot already 	similarity index 
contain 	strbuf addf quote 
given key 	style strbuf 
hash tables 	addf quote style 
implementation file 	strbuf addf 
memory hash 	strbuf addf similarity 
tables insert 	index hashcmp 
del 	diff opt tst 
replace find 	diff opt 
random element 	tst fill mmfile 
operations hash 	diff filespec 
tables resize 	binary fill 
needed tables 	mmfile diff filespec 
power 	binary strbuf 
two size 	addf find unique 
used collisions 	abbrev strbuf 
handled chaining 	addstr find unique 
see source 	abbrev strbuf 
code information 	addf strbuf addf 
copyright 	diff opt 
salvatore sanfilippo 	tst userdiff find 
antirez gmail 	path fill 
dot rights 	metainfo want color 
reserved redistribution 	run external 
use source 	diff builtin diff 
binary 	diff file 
forms without 	valid hashcpy lstat 
modification permitted 	die errno 
provided following 	index path die 
conditions met 	hashclr external 
redistributions source 	diff strcmp 
code 	strip prefix diff 
must retain 	opt tst 
copyright notice 	diff pair unmerged 
list conditions 	run diff 
following disclaimer 	cmd diff fill 
redistributions binary 	sha info 
form 	diff fill sha 
must reproduce 	info diff 
copyright notice 	file valid diff 
list conditions 	file valid 
following disclaimer 	alloc filespec run 
documentation materials 	diff cmd 
provided 	free strbuf release 
distribution neither 	alloc filespec 
name redis 	run diff cmd 
names contributors 	free run 
may used 	diff cmd strbuf 
endorse promote 	release diff 
products 	pair unmerged 
derived software 	builtin diffstat strcmp 
without specific 	strip prefix 
prior written 	diff fill sha 
permission software 	info diff 
provided copyright 	fill sha info 
holders 	builtin diffstat 
contributors express 	diff pair unmerged 
implied warranties 	strcmp strip 
including limited 	prefix diff fill 
implied warranties 	sha info 
merchantability fitness 	diff fill sha 
particular 	info builtin 
purpose disclaimed 	checkdiff memcpy diff 
shall copyright 	opt die 
owner contributors 	diff xdl tst 
liable direct 	diff xdl 
indirect incidental 	tst diff xdl 
special 	tst diff 
exemplary consequential 	opt diff 
damages including 	opt clr diff 
limited procurement 	opt tst 
substitute goods 	diff opt tst 
services loss 	strlen diff 
use 	opt diff opt 
data profits 	diff opt 
business interruption 	read cache diff 
however caused 	opt tst 
theory liability 	diff opt diff 
whether contract 	opt tst 
strict 	die isdigit strtoul 
liability tort 	strchrnul strncmp 
including negligence 	isdigit strtoul die 
otherwise arising 	skip prefix 
way use 	skip prefix die 
software even 	skip prefix 
advised 	die skip 
possibility damage 	prefix strtoul die 
dict enable 	strtoul skip 
resize dict 	prefix strtoul die 
disable resize 	strtoul skip 
make possible 	prefix strtoul die 
enable 	strtoul skip 
disable resizing 	prefix strtoul die 
hash table 	strtoul strtoul 
needed important 	strtoul strtoul parse 
redis use 	dirstat die 
copy write 	strbuf release parse 
want 	submodule die 
move much 	prepare filter bits 
memory around 	size toupper 
child performing 	skip prefix parse 
saving operations 	one token 
note even 	parse one token 
dict 	parse one 
resize resizes 	token parse 
prevented hash 	one token parse 
table still 	one token 
allowed grow 	parse one token 
ratio number 	error strcmp 
elements 	strcmp strcmp opt 
buckets dict 	arg enable 
force resize 	patch output strcmp 
ratio prototypes 	strcmp enable 
hash functions 	patch output strcmp 
thomas wang 	strcmp strcmp 
bit 	strcmp parse dirstat 
mix function 	opt skip 
murmur hash 	prefix parse dirstat 
austin appleby 	opt skip 
note code 	prefix parse dirstat 
makes assumptions 	opt strcmp 
machine 	parse dirstat opt 
behaves read 	strcmp parse 
address without 	dirstat opt 
crashing limitations 	skip prefix parse 
work incrementally 	dirstat opt 
produce results 	parse dirstat opt 
little 	strcmp strcmp 
endian big 	strcmp enable patch 
endian machines 	output strcmp 
mixing constants 	strcmp strcmp strcmp 
generated offline 	starts stat 
really magic 	opt starts starts 
happen 	strcmp diff 
work well 	scoreopt parse error 
initialize hash 	starts starts 
random mix 	strcmp diff scoreopt 
bytes time 	parse error 
hash handle 	strcmp strcmp starts 
last 	starts strcmp 
bytes input 	diff opt diff 
mixes hash 	scoreopt parse 
ensure last 	error strcmp 
bytes well 	strcmp diff opt 
incorporated insensitive 	strcmp diff 
hash 	opt clr strcmp 
function djb 	diff opt 
hash hash 	skip prefix diff 
api implementation 	opt strcmp 
reset hash 	diff xdl strcmp 
table already 	diff xdl 
initialized 	clr strcmp strcmp 
init note 	diff xdl 
function called 	strcmp strcmp diff 
destroy create 	xdl strcmp 
hash table 	diff xdl strcmp 
initialize hash 	diff xdl 
table 	strcmp diff alg 
resize table 	strcmp diff 
minimal size 	alg parse 
contains elements 	opt parse algorithm 
invariant used 	error diff 
buckets ratio 	xdl clr strcmp 
near 	enable patch 
expand create 	output diff opt 
hash table 	strcmp diff 
hash table 	opt strcmp strcmp 
size invalid 	diff opt 
smaller number 	strcmp diff opt 
elements 	strcmp diff 
already inside 	opt strcmp diff 
hash table 	opt strcmp 
rehashing table 	diff opt clr 
size useful 	diff opt 
allocate hash 	clr strcmp skip 
table 	prefix git 
initialize pointers 	config colorbool error 
first initialization 	strcmp strcmp 
really rehashing 	skip prefix 
first hash 	strcmp skip prefix 
table accept 	strcmp strcmp 
keys 	strcmp strcmp die 
prepare second 	parse opt 
hash table 	strcmp diff opt 
incremental rehashing 	strcmp diff 
performs steps 	opt strcmp diff 
incremental rehashing 	opt strcmp 
returns 	diff opt clr 
still keys 	strcmp diff 
move old 	opt strcmp diff 
hash table 	opt clr 
otherwise returned 	strcmp diff opt 
note rehashing 	handle ignore 
step 	submodules arg skip 
consists moving 	prefix diff 
bucket may 	opt handle ignore 
one key 	submodules arg 
use chaining 	strcmp diff 
old hash 	opt skip prefix 
table 	parse submodule 
however since 	opt skip prefix 
part hash 	parse error 
table may 	highlight strcmp opt 
composed empty 	strtoul opt 
spaces guaranteed 	opt strcmp strcmp 
function 	opt prefix 
rehash even 	filename strlen xstrdup 
single bucket 	parse opt 
since visit 	parse diff filter 
max empty 	opt die 
buckets total 	strcmp skip prefix 
otherwise 	strtoul parse 
amount work 	opt parse opt 
would unbound 	strcmp opt 
function may 	arg strcmp diff 
block time 	opt strcmp 
max number 	diff opt 
empty 	strcmp diff opt 
buckets visit 	clr parse 
note rehashidx 	opt prefix filename 
overflow sure 	strlen fopen 
elements used 	die errno skip 
move keys 	prefix skip 
bucket 	prefix skip prefix 
old hash 	parse rename 
index hash 	score parse rename 
table check 	score alloc 
already rehashed 	grow xcalloc diff 
whole table 	free filespec 
rehash 	free filespec free 
rehash amount 	sha hex 
time milliseconds 	find unique abbrev 
milliseconds function 	strlen xsnprintf 
performs step 	xsnprintf sha hex 
rehashing safe 	diff line 
iterators 	prefix diff 
bound hash 	unique abbrev diff 
table iterators 	unique abbrev 
middle rehashing 	similarity index strip 
mess two 	prefix write 
hash tables 	name quoted write 
otherwise 	name quoted 
element missed 	strip prefix write 
duplicated function 	name quoted 
called common 	diff pair unmerged 
lookup update 	diff file 
operations dictionary 	valid diff file 
hash 	valid diff 
table automatically 	pair mode changed 
migrates actively 	strcmp hashcmp 
used element 	diff unmodified pair 
target hash 	diff file 
table low 	valid isdir 
level 	diff file valid 
function adds 	isdir run 
entry instead 	diff diff unmodified 
setting returns 	pair diff 
dict entry 	file valid isdir 
structure user 	diff file 
make 	valid isdir run 
sure fill 	diffstat diff 
field wishes 	unmodified pair diff 
function also 	file valid 
directly exposed 	isdir diff file 
user api 	valid isdir 
called 	run checkdiff diff 
mainly order 	unmodified pair 
store non 	diff file valid 
pointers inside 	sha hex 
hash example 	diff debug filespec 
entry dict 	diff debug 
raw 	filespec diff 
dict mykey 	debug filepair diff 
entry dict 	debug queue 
integer val 	diff pair unmerged 
entry values 	diff file 
key already 	valid diff file 
exists 	valid diff 
returned key 	pair type changed 
added hash 	diff pair 
entry returned 	rename strcmp hashcmp 
manipulated caller 	sha error 
index element 	diff debug queue 
element 	die diff 
already exists 	flush checkdiff diff 
allocate memory 	flush raw 
store entry 	strip prefix write 
insert element 	name quoted 
top assumption 	write name quoted 
database 	write name 
system likely 	quoted pprint 
recently added 	rename similarity index 
entries accessed 	free show 
frequently hash 	mode change diff 
entry fields 	line prefix 
element 	fputs show file 
discarding old 	mode name 
key already 	fputs show file 
exists key 	mode name 
added scratch 	fputs show rename 
already element 	copy fputs 
key 	show rename copy 
dict replace 	write name 
performed update 	quoted similarity index 
operation element 	show mode 
key exists 	change isspace starts 
dict suceed 	space git 
already 	sha update git 
exists entry 	sha init 
free old 	memset memset 
one note 	memset error diff 
important order 	unmodified pair 
may exactly 	diff file valid 
previous 	isdir diff 
one context 	file valid isdir 
think reference 	diff pair 
counting want 	unmerged diff fill 
increment decrement 	sha info 
free reverse 	diff fill sha 
dict 	info fill 
replace raw 	mmfile fill mmfile 
simply version 	error space 
dict raw 	strlen space strlen 
always returns 	snprintf snprintf 
hash entry 	snprintf git sha 
specified 	update diff 
key even 	filespec binary 
key already 	diff filespec binary 
exists added 	git sha 
entry already 	update sha hex 
existing key 	git sha 
returned 	update sha hex 
see dict 	xdi diff 
raw information 	outf error git 
search element 	sha diff 
table unlink 	patch diff free 
element list 	filepair free 
found 	diff queue clear 
destroy entire 	warning warning 
dictionary free 	warning check pair 
elements free 	status flush 
table allocated 	one pair diff 
cache structure 	opt tst 
initialize 	memset check pair 
table never 	status diff 
fails clear 	flush stat 
release hash 	show numstat show 
table table 	stats show 
fingerprint bit 	shortstats show dirstat 
number 	line free 
represents state 	diffstat info show 
dictionary given 	dirstat summary 
time dict 	empty diff summary 
properties xored 	diff opt 
together iterator 	tst diff opt 
initialized 	tst fclose 
dict fingerprint 	fopen die errno 
check fingerprint 	check pair 
iterator released 	status diff flush 
two fingerprints 	patch diff 
different means 	line prefix fputs 
user 	check pair 
iterator performed 	status diff flush 
forbidden operations 	patch format 
dictionary iterating 	callback diff 
hash integers 	free filepair free 
summing every 	diff queue 
successive 	clear fclose diff 
integer integer 	opt tst 
hashing previous 	diff opt diff 
sum basically 	opt clr 
result hash 	filter bit tst 
hash hash 	filter bit 
way 	tst filter bit 
integers different 	tst diff 
order likely 	queue clear filter 
hash different 	bit tst 
number hashing 	match filter diff 
step use 	free filepair 
tomas 	match filter diff 
wang bit 	diff free 
integer hash 	filepair free isgitlink 
hash hash 	diff populate 
hash hash 	filespec diff 
hash 	populate filespec memcmp 
need save 	diff file 
next iterator 	valid diff file 
user may 	valid diff 
entry returning 	populate filespec diff 
random entry 	populate filespec 
hash 	diff filespec identical 
table useful 	diff queue 
implement randomized 	clear diff filespec 
algorithms sure 	check stat 
elements indexes 	unmatch diff diff 
rehashidx found 	opt tst 
non 	diff free filepair 
empty bucket 	free strcmp 
linked list 	qsort diffcore skip 
need random 	stat unmatch 
element list 	diffcore diffcore rename 
sane way 	diffcore merge 
counting 	broken diffcore 
elements random 	pickaxe diffcore order 
index function 	diff resolve 
samples dictionary 	rename copy diffcore 
keys random 	apply filter 
locations guarantee 	diff opt tst 
keys 	diff opt 
specified count 	diff opt clr 
guarantee non 	diff warn 
duplicated elements 	rename limit diff 
however make 	opt tst 
effort things 	diff opt tst 
returned 	diff opt 
pointers hash 	tst diff opt 
table entries 	tst diff 
stored des 	opt tst diff 
points dict 	opt tst 
entry pointers 	diff opt 
must 	tst diffopt flags 
room least 	submodule config 
count elements 	diff opt tst 
argument pass 	isgitlink submodule 
function tell 	ignored diff opt 
many random 	tst strncmp 
elements 	alloc filespec alloc 
need function 	filespec fill 
returns number 	filespec fill filespec 
items stored 	diff queue 
des may 	diff opt tst 
less count 	diff opt 
hash 	isgitlink isgitlink submodule 
table less 	ignored diff 
count elements 	opt tst strncmp 
inside enough 	alloc filespec 
elements found 	alloc filespec fill 
reasonable amount 	filespec fill 
steps 	filespec diff 
note function 	queue diff opt 
suitable need 	tst diff 
good distribution 	opt tst diff 
returned items 	filespec check 
need sample 	stat unmatch diff 
given 	opt strncmp 
number continuous 	alloc filespec alloc 
elements run 	filespec diff 
kind algorithm 	queue prepare temp 
produce statistics 	file start 
however function 	command tempfile strbuf 
much 	read error 
faster dict 	close finish command 
random key 	strbuf release 
producing elements 	tempfile tempfile strbuf 
hash table 	detach diff 
tables rehashing 	file valid diff 
work 	populate filespec 
proportional count 	die die 
pick random 	notes cache run 
point inside 	textconv die 
larger table 	notes cache put 
continuous empty 	notes cache 
entries 	write diff opt 
far invariant 	tst check 
dict rehashing 	pager config setup 
indexes already 	pager copyright 
visited rehashing 	junio hamano context 
populated buckets 	metainfo fraginfo 
skip 	old commit whitespace 
indexes idx 	funcinfo use 
moreover currently 	first digit ignore 
range second 	digits nothing 
table elements 	give layer defaults 
tables current 	core level 
rehashing 	commands git diff 
index jump 	files never 
possible happens 	affected setting 
going big 	diff renames user 
small table 	happens configuration 
range table 	file like gnu 
count 	diff suppress 
contiguous empty 	blank empty option 
buckets jump 	backwards compatibility 
locations reach 	keep track files 
count minimum 	used diffing 
collect elements 	sometimes entry refers 
buckets 	temporary file 
found non 	sometimes existing file 
empty iterating 	sometimes dev 
function reverse 	filename external diff 
bits algorithm 	read entry 
http graphics 	currently use diff 
stanford 	tempfile instance 
edu seander 	refers temporary 
bithacks html 	file tempfile used 
reverse parallel 	manage lifetime 
bit size 	trailing newline matter 
must power 	like fill 
dict 	mmfile size avoid 
scan used 	retrieving blob 
iterate elements 	pointing end incomplete 
dictionary iterating 	line skip 
works following 	last blank line 
way initially 	eof paint 
call 	well emit prefix 
function cursor 	rest hunk 
function performs 	header must begin 
one step 	old always 
iteration returns 	least bytes skip 
cursor must 	hunk header 
use 	fraginfo color trailing 
next call 	blank func 
returned cursor 	header filled 
iteration complete 	setup code color 
function guarantees 	enabled color 
elements present 	words algorithm described 
dictionary 	collect minus 
returned start 	plus lines diff 
end iteration 	hunk divided 
however possible 	minus lines plus 
elements returned 	lines minus 
multiple times 	lines plus lines 
every 	words place 
element returned 	two mmfile one 
callback argument 	word line 
called privdata 	use xdiff run 
first argument 	diff two 
dictionary entry 	mmfile words level 
second 	diff common 
argument works 	parts file output 
iteration algorithm 	plus side 
designed pieter 	text diff 
noordhuis main 	words current plus 
idea increment 	used trace 
cursor 	current position plus 
starting higher 	file printed 
order bits 	diff words last 
instead incrementing 	minus used 
cursor normally 	trace last minus 
bits cursor 	word printed 
reversed 	graph work color 
cursor incremented 	words need 
bits reversed 	output graph prefix 
strategy needed 	line color 
hash table 	words output generally 
may resized 	two conditions 
iteration 	output prefix diff 
calls dict 	words last 
hash tables 	minus diff words 
always power 	current plus 
two size 	diff words 
use chaining 	plus text ptr 
position 	plus text 
element given 	must start line 
table given 	minus word 
computing bitwise 	printed graph prefix 
hash key 	must printed 
size size 	diff words current 
always 	plus diff 
mask equivalent 	words plus text 
taking rest 	ptr diff 
division hash 	words current plus 
key size 	graph prefix 
example current 	must printed following 
hash 	posix requires 
table size 	first decremented one 
mask binary 	len function 
position key 	starts looking 
hash table 	begin returns iff 
always last 	word found 
four 	find next word 
bits hash 	find end 
output forth 	word function splits 
happens table 	words buffer 
changes size 	text stores list 
hash table 	newline separator 
grows 	saves offsets original 
elements anywhere 	words buffer 
one multiple 	orig fake empty 
old bucket 	word store 
example say 	original boundaries store 
already iterated 	one word 
bit 	executes word diff 
cursor mask 	accumulated buffers 
hash table 	special removal hunk 
size hash 	header parsed 
table resized 	need context 
elements mask 	color words mode 
buckets 	show word 
obtain substituting 	diff words accumulated 
either targeted 	buffer use 
keys already 	already loaded driver 
visited scanning 	fallback settings 
bucket smaller 	truncated middle cannot 
hash 	happen cannot 
table iterating 	happen eat newline 
higher bits 	eof marker 
first inverted 	saw line nothing 
counter cursor 	without diff 
need restart 	words flush defer 
table 	processing end 
size gets 	preimage lines may 
bigger iterating 	come skip 
cursors without 	prefix character diff 
end also 	suppress blank 
without combination 	empty may 
bits 	none incomplete line 
already explored 	end find 
similarly table 	common prefix find 
size shrinks 	common suffix 
time example 	common prefix must 
going combination 	end slash 
lower 	loop run prefix 
three bits 	see slash 
mask size 	common prefix cannot 
already completely 	would underrun 
explored would 	input pfx mid 
visited sure 	mid sfx 
tried 	pfx pfx sfx 
example variations 	pfx sfx 
higher bit 	sfx name name 
need test 	make sure 
wait two 	least one printed 
tables rehashing 	change path 
yes 	easiest way 
always iterate 	scale linearly alloted 
smaller table 	width one 
first test 	column shorter result 
expansions current 	binary diff 
cursor larger 	caller may want 
table 	print files 
example current 	changed insertions deletions 
cursor also 	omitting insertions 
larger table 	deletions probably less 
size also 	confusing skip 
test inside 	files changed nothing 
larger 	added removed 
table reduces 	lines bug git 
problem back 	find longest 
one table 	filename max number 
larger one 	changes shown 
exists expansion 	room one unmerged 
smaller 	characters bin 
one limitations 	xxx yyy 
iterator completely 	bytes display change 
stateless huge 	counts aligned 
advantage including 	bin stop scanning 
additional memory 	data files 
used 	width stat width 
disadvantages resulting 	term columns 
design possible 	columns total want 
elements however 	maximum min 
usually easy 	max len stat 
deal application 	name width 
level 	name part want 
iterator must 	maximum min 
multiple elements 	max change stat 
per call 	graph width 
needs always 	part also need 
keys chained 	width max 
given 	change nnnn 
bucket expansions 	one empty column 
sure miss 	end altogether 
keys moving 	width max change 
rehashing reverse 	enough space 
cursor somewhat 	use smaller stat 
hard 	name width 
understand first 	width filename rest 
comment supposed 	constant elements 
help emit 	graph part stat 
entries cursor 	graph width 
make sure 	graph part gives 
smaller 	filename constant 
bigger table 	parts graph standard 
emit entries 	terminal size 
cursor iterate 	words stat width 
indices larger 	limits maximum 
table expansion 	width stat name 
index 	width fixes 
pointed cursor 	maximum width 
smaller table 	filename also used 
emit entries 	divide available 
cursor increment 	columns aren enough 
bits covered 	binary files 
smaller 	displayed bin xxx 
mask bits 	yyy bytes 
covered mask 	instead change count 
difference non 	graph part 
zero unmasked 	treated similarly graph 
bits incrementing 	part scaled 
reversed 	total width small 
cursor operates 	accommodate guaranteed 
masked bits 	minimum width filename 
smaller table 	part separators 
increment reverse 	message message overflow 
cursor functions 	making line 
expand 	longer maximum width 
hash table 	guarantee graph 
needed incremental 	part filename 
rehashing already 	part first assign 
progress hash 	sizes wanted 
table empty 	ignoring available width 
expand 	strlen bin 
initial size 	xxx yyy bytes 
reached ratio 	bin width 
allowed resize 	part starting xxx 
hash table 	fit graph 
setting avoid 	width adjust adjustable 
ratio 	widths exceed 
elements buckets 	maximum width name 
safe threshold 	width width 
resize doubling 	name area graph 
number buckets 	width width 
hash table 	graph area max 
capability 	change used 
power two 	scale graph properly 
returns index 	scale filename 
free slot 	scale width 
populated hash 	due sanity check 
entry given 	count bytes 
key 	report dirstat top 
key already 	level cases 
exists returned 	everything came single 
note process 	directory directory 
rehashing hash 	sources sha changed 
table index 	pre post 
always 	content identical therefore 
returned context 	skip looking 
second hash 	file contents altogether 
table expand 	dirstat file 
hash table 	mode really need 
needed compute 	look actual 
key 	file contents fact 
hash search 	sha changed 
slot already 	enough file 
contain given 	list results file 
key debugging 	contributing equal 
compute stats 	damage original minus 
hash 	copied removed 
entry slot 	material added material 
generate human 	damages made 
readable stats 	preimage resulting damage 
unlike snprintf 	zero know 
teturn number 	diffcore count changes 
characters 	considers two 
actually written 	entries identical since 
make sure 	content changed 
term end 	know must kind 
dict resize 	change force 
dict force 	entries damage happen 
resize 	even many 
ratio size 	files everything renames 
key type 	show directories 
priv data 	changes binary 
ptr key 	files counts bytes 
dict hash 	lines must 
function 	find way normalize 
seed seed 	binary bytes 
key len 	textual lines following 
seed data 	heuristic assumes 
buf len 	bytes per line 
hash type 	stupid ugly 
priv 	cheap happen even 
data ptr 	many files 
type priv 	everything renames show 
data ptr 	directories changes 
minimal size 	line thru line 
realsize empty 	marker size 
visits 	firstchar nothing could 
nextde start 	deflated delta 
rehashes key 	could deflated two 
val entry 	whichever smaller 
key index 	emit data 
entry key 	encoded never use 
val 	non valid 
entry auxentry 	filename anywhere possible 
key entry 	dev run 
key nofree 	diff different kind 
idx prev 	objects quite 
table key 	common confusing crazy 
key 	xdl interfaces 
callback next 	crazy xdl interfaces 
key idx 	codepaths check 
table key 	sides checking old 
integers hash 	side deliberate 
iter iter 	checking newly introduced 
iter 	changes side 
orighe listlen 	text check introduces 
listele des 	crazy xdl 
count tables 	interfaces least one 
maxsizemask maxsteps 	context line 
emptylen mask 	report errors 
privdata 	given name sha 
size key 	pair index 
idx table 	tells file work 
callback buf 	contents prepare 
bufsize tableid 	temp file inflate 
chainlen maxchainlen 	extract read 
totchainlen 	cache benchmark previous 
clvector buf 	version always 
bufsize orig 	reads cache shows 
buf orig 	makes things 
bufsize tolower 	worse diff comparing 
zmalloc dict 	two linux 
init 	kernel trees already 
dict reset 	work diff 
dict reset 	comparisons deal small 
dict rehashing 	number files 
dict expand 	reading cache 
dict next 	expensive large project 
power 	cost outweighs 
dict rehashing 	savings inflating temporary 
zcalloc dict 	file practically 
rehashing dict 	code helps used 
hash key 	diff cache 
zfree 	cached read cache 
dict reset 	calling want 
gettimeofday time 	avoid working directory 
milliseconds dict 	caller doesn 
rehash time 	need data normal 
milliseconds dict 	file system 
rehash 	rather slow stat 
dict raw 	open mmap 
dict val 	close syscalls contained 
dict rehashing 	pack file 
dict rehash 	pack probably already 
step dict 	open faster 
key 	obtain data 
index dict 	working directory loose 
rehashing zmalloc 	objects however 
dict key 	would tend slower 
dict dict 	need individually 
find dict 	opened inflated sha 
val 	looking unreusable 
dict free 	regular file marked 
val dict 	unchanged guarantee 
find dict 	work matches looking 
raw dict 	matches file 
rehashing dict 	work reuse looking 
rehash 	work rename 
step dict 	detection pickaxe operation 
hash key 	may need 
dict compare 	grab data blob 
keys dict 	file core 
free key 	comparison diff filespec 
dict 	data size 
free val 	fields purpose 
zfree dict 	demote fail warn 
rehashing dict 	allow inspecting 
dict callback 	situation instead refusing 
dict free 	convert working 
key 	format canonical git 
dict free 	format generate 
val zfree 	xxxxxx basename ext 
zfree dict 	entry produces 
reset dict 	file entry produces 
clear dict 	file borrow 
clear 	file work even 
zfree dict 	though may 
rehashing dict 	sometimes borrow contents 
rehash step 	work always 
dict hash 	want one mode 
key dict 	mode trustworthy 
compare 	even one sha 
keys dict 	valid diff 
rehashing dict 	file valid 
find dict 	one external diff 
val zmalloc 	command takes 
dict iterator 	diff cmd name 
dict 	infile infile 
fingerprint dict 	sha infile mode 
rehashing dict 	infile infile 
fingerprint zfree 	sha infile mode 
dict size 	rename fallthru 
dict rehashing 	use colors header 
dict 	intended external 
rehash step 	diff driver strip 
dict rehashing 	prefix molest 
random random 	dev absolute paths 
random dict 	filepair changes 
size dict 	file symlink needs 
size 	split deletion 
dict rehashing 	creation unmerged unmerged 
dict rehash 	pathchange left 
step dict 	time say 
rehashing random 	changes checking changed 
random dict 	paths ignore 
size 	whitespace options force 
dict rehashing 	look inside 
rev rev 	contents cases always 
dict rehashing 	need recursive 
dict expand 	drop caller supplied 
dict expand 	recursive bits 
dict 	formats also pickaxe 
expand needed 	would work 
dict hash 	well say recursive 
key dict 	patches generated 
compare keys 	submodules diffed work 
dict rehashing 	must dirtiness 
dict 	shown output read 
clear dict 	cache die 
clear snprintf 	even fails 
snprintf snprintf 	safe also smudge 
strlen dict 	active cache 
stats dict 	active fails worry 
rehashing 	cleaning either 
dict stats 	full make sense 
hash table 	show first 
implementation file 	hit happened found 
memory hash 	make sense 
tables insert 	exit code either 
del 	stuck form 
replace find 	option separate form 
random element 	option important 
operations hash 	checks error cases 
tables resize 	caller knows 
needed tables 	dirstat related option 
power 	given command 
two size 	line allow say 
used collisions 	function negation 
handled chaining 	input haven 
see source 	initialized filter field 
code information 	another diff 
copyright 	filter start full 
salvatore sanfilippo 	bits aon 
antirez gmail 	output format options 
dot rights 	stat stat 
reserved redistribution 	width stat name 
use source 	width stat 
binary 	count renames options 
forms without 	xdiff options 
modification permitted 	clear previous settings 
provided following 	flags options 
conditions met 	misc options always 
redistributions source 	end user 
code 	says num divided 
must retain 	scale say 
copyright notice 	internally max score 
list conditions 	num scale 
following disclaimer 	convert form 
redistributions binary 	arguments form versions 
form 	option expect 
must reproduce 	different find unique 
copyright notice 	abbrev stuffs 
list conditions 	result dots alignment 
following disclaimer 	function written 
documentation materials 	stricter necessary support 
provided 	currently implemented 
distribution neither 	transformers idea transformers 
name redis 	produce diff 
names contributors 	filepairs way want 
may used 	filter clean 
endorse promote 	producing output unmerged 
products 	interesting deletion 
derived software 	addition mode type 
without specific 	change rename 
prior written 	interesting valid point 
permission software 	path dealing 
provided copyright 	change change 
holders 	look file filesystem 
contributors express 	diffs patch 
implied warranties 	format useful stat 
including limited 	diffs nothing 
implied warranties 	check diffs undecided 
merchantability fitness 	point dealing 
particular 	pair whose sides 
purpose disclaimed 	valid type 
shall copyright 	either place edit 
owner contributors 	rename copy 
liable direct 	edit rename might 
indirect incidental 	connected broken 
special 	pair causing pathnames 
exemplary consequential 	rename modification 
damages including 	otherwise see source 
limited procurement 	used multiple 
substitute goods 	renames decrement 
services loss 	count call copy 
use 	change entry 
data profits 	happen anymore prepare 
business interruption 	broken callers 
however caused 	ignore line numbers 
theory liability 	computing sha 
whether contract 	patch returns upon 
strict 	success writes 
liability tort 	result sha order 
including negligence 	raw stat 
otherwise arising 	summary patch name 
way use 	name status 
software even 	checkdiff bits clear 
advised 	run diff 
possibility damage 	flush patch exit 
prototypes hash 	status setting 
functions hash 	options file dev 
function popular 	safe aren 
one bernstein 	supposed produce 
tested 	output anyway attach 
best hash 	patch instead 
api implementation 	report content level 
reset hashtable 	differences changes 
already initialized 	diff addremove diff 
init note 	change bit 
function 	diff contents effect 
called destroy 	otherwise clear 
create hash 	whole queue copying 
table initialize 	empty outq 
hash table 	end function first 
expand create 	clear current 
hashtable 	entries queue matching 
hashtable size 	ones check 
invalid smaller 	whether two filespecs 
number elements 	mode size 
already inside 	identical entries come 
hashtable copy 	stat info 
elements 	dirtiness always 
old table 	sides iow create 
note old 	one side 
hash table 	name unknown mode 
empty size 	size keep 
zero dict 	ones match criteria 
expand 	real differences 
creates hash 	point file known 
table hash 	modified mode 
entry slot 	size name one 
element index 	side unknown 
pass next 	need inspect identical 
element 	contents caller 
remap hashtable 	subtract skip stat 
old element 	unmatch determine 
target hash 	many paths dirty 
table index 	due stat 
element element 	info mismatch note 
already 	please keep 
exists allocates 	following sync 
memory stores 	diff combined see 
key hash 	follow renames 
entry fields 	diff see follow 
element discarding 	renames diff 
old 	shall changes submodule 
key already 	ignored submodule 
exists key 	changes configured ignored 
added scratch 	separately path 
already element 	configuration overridden command 
key dict 	line may 
replace 	look odd preparation 
performed update 	feeding unchanged 
operation element 	files produce diffs 
key exists 	copy detection 
dict suceed 	would need entries 
already exists 	diff core 
entry 	prefixed something 
free old 	like haven decided 
one free 	make difference 
old one 	feeding old diff 
note important 	change also 
order may 	effect output happens 
exactly 	pruned merged 
previous one 	rename copy pairs 
context think 	appropriate ignore 
reference counting 	errors might repository 
want increment 	could save 
decrement free 	changes flush end 
reverse 	would need 
search element 	extra call diffing 
unlink element 	done since 
list found 	generating cache entry 
destroy entire 	slow path 
hash table 	anyway extra overhead 
free 	probably isn 
elements free 	big deal 
table allocated 	user asked exit 
cache structure 	code either 
initialize table 	want quiet exit 
never fails 	code definitely 
clear 	bother pager former 
release hash 	generate output 
table need 	since still properly 
save next 	report exit 
iterator user 	code even pager 
may entry 	run could 
returning 	run pager exit 
functions expand 	code since 
hash table 	done historically easy 
needed hash 	find people 
table empty 	oneline advising git 
expand intial 	diff exit 
size 	code hooks scripts 
table full 	builtin git 
dobule size 	diff copyright 
hash table 	junio hamano blob 
capability power 	file working 
two returns 	make sure one 
index 	revision pending 
free slot 	revision filtering parameters 
populated hash 	saw two 
entry given 	trees ent ent 
key key 	ent uninteresting 
already exists 	swap diff combine 
returned 	merges asked 
expand hashtable 	diff densify user 
needed compute 	wants dense 
key hash 	one explicitly asked 
search slot 	rely could 
already contain 	ish rev pending 
given 	objects list 
key hash 	also could blobs 
tables implementation 	pathspecs cache 
file memory 	files diff 
hash tables 	files compare two 
insert del 	random blobs 
replace 	must zero compare 
find random 	blob working 
element operations 	file cache diff 
hash tables 	index cached 
resize needed 	diff compare two 
tables power 	filesystem entities 
two 	aka index cases 
size used 	errors asked 
collisions handled 	index explicitly treat 
chaining see 	git diff 
source code 	least one path 
information copyright 	outside repo 
salvatore 	command would executed 
sanfilippo antirez 	outside git 
gmail dot 	repository behaves way 
rights reserved 	git diff 
redistribution use 	index acts 
source binary 	colourful diff replacement 
forms 	index two 
without modification 	paths possible user 
permitted provided 	intended inside 
following conditions 	repository operation give 
met redistributions 	usage message 
source code 	non repository usage 
must 	exit index 
retain copyright 	diff run exit 
notice list 	otherwise usual 
conditions following 	git diff scale 
disclaimer redistributions 	real terminal 
binary form 	size respect stat 
must 	graph width 
reproduce copyright 	config external textconv 
notice list 	used cached 
conditions following 	pending head 
disclaimer documentation 	hand eek arguments 
materials provided 	look reasonable 
distribution 	diff least one 
neither name 	merge ent 
redis names 	objects merge ent 
contributors may 	objects ents 
used endorse 	ent objects ents 
promote products 	show diff 
derived 	note pick one 
software without 	merge random 
specific prior 	one sha name 
written permission 	mode builtin 
software provided 	diff usage opt 
copyright holders 	old mode 
contributors 	mode old sha 
express implied 	sha old 
warranties including 	sha valid sha 
limited implied 	valid old 
warranties merchantability 	name name 
fitness particular 	one two tmp 
purpose 	tmp tmp 
disclaimed shall 	revs argc argv 
copyright owner 	blob path 
contributors liable 	revs argc argv 
direct indirect 	blob mode 
incidental special 	revs argc argv 
exemplary 	cached arg 
consequential damages 	revs argc argv 
including limited 	ent ent 
procurement substitute 	swap revs argc 
goods services 	argv ent 
loss use 	ents parents file 
data 	revs argc 
profits business 	argv options argc 
interruption however 	argv prefix 
caused theory 	rev ent paths 
liability whether 	blob index 
contract strict 	result arg 
liability 	entry obj name 
tort including 	flags sha 
negligence otherwise 	sha hashcmp diff 
arising way 	opt tst 
use software 	strncmp strncmp alloc 
even advised 	filespec alloc 
possibility 	filespec fill filespec 
damage dict 	fill filespec 
enable resize 	diff queue usage 
dict disable 	guard pathspec 
resize make 	lstat die errno 
possible enable 	isreg islnk 
disable 	die diff mnemonic 
resizing hash 	prefix canon 
table needed 	mode stuff change 
important redis 	canon mode 
use copy 	diffcore std diff 
write want 	flush canon 
move 	mode usage 
much memory 	stuff change diffcore 
around child 	std diff 
performing saving 	flush strcmp strcmp 
operations note 	usage usage 
even dict 	setup work read 
resize 	cache preload 
resizes prevented 	perror read cache 
hash table 	perror run 
still allowed 	diff index usage 
grow ratio 	diff sha 
number elements 	log diff flush 
buckets 	usage sha 
dict force 	append diff combined 
resize ratio 	sha clear 
prototypes hash 	xcalloc hold locked 
functions thomas 	index discard 
wang bit 	cache read 
mix 	cache refresh cache 
function murmur 	update index 
hash austin 	able strcmp strcmp 
appleby note 	strcmp strcmp 
code makes 	strcmp usage error 
assumptions machine 	setup work 
behaves 	read cache preload 
read address 	perror run 
without crashing 	diff files strcmp 
limitations work 	strcmp setup 
incrementally produce 	git directory gently 
results little 	path inside 
endian 	repo path inside 
big endian 	repo gitmodules 
machines mixing 	config git config 
constants generated 	init revisions 
offline really 	usagef diff index 
magic happen 	diff opt 
work 	diff opt 
well initialize 	die setup revisions 
hash random 	diff setup 
mix bytes 	done diff opt 
time hash 	setup diff 
handle last 	pager strcmp strcmp 
bytes 	strcmp head 
input mixes 	pending lookup pending 
hash ensure 	parse deref 
last bytes 	tag die die 
well incorporated 	hashcpy die 
insensitive hash 	builtin diff files 
function 	usage builtin 
djb hash 	diff usage builtin 
hash api 	diff blobs 
implementation reset 	usage usage builtin 
hash table 	diff index 
already 	builtin diff builtin 
initialized init 	diff builtin 
note function 	diff combined 
called destroy 	diff result code 
create hash 	refresh index 
table initialize 	quietly copyright junio 
hash 	hamano context 
table resize 	metainfo fraginfo old 
table minimal 	commit whitespace 
size contains 	funcinfo use first 
elements invariant 	digit ignore 
used buckets 	digits nothing give 
ratio 	layer defaults 
near expand 	core level commands 
create hash 	git diff 
table hash 	files never affected 
table size 	setting diff 
invalid smaller 	renames user happens 
number 	configuration file 
elements already 	like gnu diff 
inside hash 	suppress blank 
table rehashing 	empty option 
table size 	backwards compatibility keep 
useful allocate 	track files 
hash 	used diffing sometimes 
table initialize 	entry refers 
pointers first 	temporary file sometimes 
initialization really 	existing file 
rehashing first 	sometimes dev filename 
hash table 	external diff 
accept 	read entry currently 
keys prepare 	use diff 
second hash 	tempfile instance refers 
table incremental 	temporary file 
rehashing performs 	tempfile used manage 
steps incremental 	lifetime trailing 
rehashing 	newline matter like 
returns still 	fill mmfile 
keys move 	size avoid 
old hash 	retrieving blob pointing 
table otherwise 	end incomplete 
returned note 	line skip last 
rehashing 	blank line 
step consists 	eof paint well 
moving bucket 	emit prefix 
may one 	rest hunk header 
key use 	must begin 
chaining old 	old always least 
hash 	bytes skip 
table however 	hunk header fraginfo 
since part 	color trailing 
hash table 	blank func header 
may composed 	filled setup 
empty spaces 	code color enabled 
guaranteed 	color words 
function rehash 	algorithm described collect 
even single 	minus plus 
bucket since 	lines diff 
visit max 	hunk divided minus 
empty buckets 	lines plus 
total 	lines minus lines 
otherwise amount 	plus lines 
work would 	words place two 
unbound function 	mmfile one 
may block 	word line use 
time max 	xdiff run 
number 	diff two mmfile 
empty buckets 	words level 
visit note 	diff common parts 
rehashidx overflow 	file output 
sure elements 	plus side text 
used move 	diff words 
keys 	current plus used 
bucket old 	trace current 
hash index 	position plus file 
hash table 	printed diff 
check already 	words last 
rehashed whole 	minus used trace 
table 	last minus 
rehash rehash 	word printed graph 
amount time 	work color 
milliseconds milliseconds 	words need output 
function performs 	graph prefix 
step rehashing 	line color words 
safe 	output generally 
iterators bound 	two conditions output 
hash table 	prefix diff 
iterators middle 	words last minus 
rehashing mess 	diff words 
two hash 	current plus diff 
tables 	words plus 
otherwise element 	text ptr plus 
missed duplicated 	text must 
function called 	start line minus 
common lookup 	word printed 
update operations 	graph prefix 
dictionary 	must printed diff 
hash table 	words current 
automatically migrates 	plus diff words 
actively used 	plus text 
element target 	ptr diff words 
hash table 	current plus 
low 	graph prefix must 
level function 	printed following 
adds entry 	posix requires first 
instead setting 	decremented one 
returns dict 	len function starts 
entry structure 	looking begin 
user 	returns iff word 
make sure 	found find 
fill field 	next word find 
wishes function 	end word 
also directly 	function splits words 
exposed user 	buffer text 
api 	stores list 
called mainly 	newline separator saves 
order store 	offsets original 
non pointers 	words buffer orig 
inside hash 	fake empty 
example entry 	word store original 
dict 	boundaries store 
raw dict 	one word executes 
mykey entry 	word diff 
dict integer 	accumulated buffers special 
val entry 	removal hunk 
values key 	header parsed need 
already 	context color 
exists returned 	words mode show 
key added 	word diff 
hash entry 	words accumulated buffer 
returned manipulated 	use already 
caller index 	loaded driver 
element 	fallback settings truncated 
element already 	middle cannot 
exists allocate 	happen cannot happen 
memory store 	eat newline 
entry insert 	eof marker saw 
element top 	line nothing 
assumption 	without diff words 
database system 	flush defer 
likely recently 	processing end preimage 
added entries 	lines may 
accessed frequently 	come skip prefix 
hash entry 	character diff 
fields 	suppress blank empty 
element discarding 	may none 
old key 	incomplete line end 
already exists 	find common 
key added 	prefix find common 
scratch already 	suffix common 
element 	prefix must 
key dict 	end slash loop 
replace performed 	run prefix 
update operation 	see slash common 
element key 	prefix cannot 
exists dict 	would underrun input 
suceed 	pfx mid 
already exists 	mid sfx pfx 
entry free 	pfx sfx 
old one 	pfx sfx sfx 
note important 	name name 
order may 	make sure least 
exactly 	one printed 
previous one 	change path easiest 
context think 	way scale 
reference counting 	linearly alloted width 
want increment 	one column 
decrement free 	shorter result binary 
reverse 	diff caller 
dict replace 	may want 
raw simply 	print files changed 
version dict 	insertions deletions 
raw always 	omitting insertions deletions 
returns hash 	probably less 
entry 	confusing skip files 
specified key 	changed nothing 
even key 	added removed lines 
already exists 	bug git 
added entry 	find longest filename 
already existing 	max number 
key 	changes shown room 
returned see 	one unmerged 
dict raw 	characters bin xxx 
information search 	yyy bytes 
element table 	display change counts 
unlink element 	aligned bin 
list 	stop scanning data 
found destroy 	files width 
entire dictionary 	stat width 
free elements 	term columns columns 
free table 	total want 
allocated cache 	maximum min max 
structure 	len stat 
initialize table 	name width name 
never fails 	part want 
clear release 	maximum min max 
hash table 	change stat 
table fingerprint 	graph width part 
bit 	also need 
number represents 	width max change 
state dictionary 	nnnn one 
given time 	empty column end 
dict properties 	altogether width 
xored together 	max change enough 
iterator 	space use 
initialized dict 	smaller stat 
fingerprint check 	name width width 
fingerprint iterator 	filename rest 
released two 	constant elements graph 
fingerprints different 	part stat 
means 	graph width graph 
user iterator 	part gives 
performed forbidden 	filename constant parts 
operations dictionary 	graph standard 
iterating hash 	terminal size words 
integers summing 	stat width 
every 	limits maximum width 
successive integer 	stat name 
integer hashing 	width fixes maximum 
previous sum 	width filename 
basically result 	also used divide 
hash hash 	available columns 
hash 	aren enough binary 
way integers 	files displayed 
different order 	bin xxx 
likely hash 	yyy bytes instead 
different number 	change count 
hashing step 	graph part treated 
use 	similarly graph 
tomas wang 	part scaled total 
bit integer 	width small 
hash hash 	accommodate guaranteed minimum 
hash hash 	width filename 
hash hash 	part separators message 
need 	message overflow 
save next 	making line longer 
iterator user 	maximum width 
may entry 	guarantee graph part 
returning random 	filename part 
entry hash 	first assign sizes 
table 	wanted ignoring 
useful implement 	available width strlen 
randomized algorithms 	bin xxx 
sure elements 	yyy bytes 
indexes rehashidx 	bin width part 
found non 	starting xxx 
empty 	fit graph width 
bucket linked 	adjust adjustable 
list need 	widths exceed maximum 
random element 	width name 
list sane 	width width name 
way counting 	area graph 
elements 	width width graph 
random index 	area max 
function samples 	change used scale 
dictionary keys 	graph properly 
random locations 	scale filename scale 
guarantee keys 	width due 
specified 	sanity check count 
count guarantee 	bytes report 
non duplicated 	dirstat top level 
elements however 	cases everything 
make effort 	came single 
things returned 	directory directory sources 
pointers 	sha changed 
hash table 	pre post content 
entries stored 	identical therefore 
des points 	skip looking file 
dict entry 	contents altogether 
pointers must 	dirstat file mode 
room 	really need 
least count 	look actual file 
elements argument 	contents fact 
pass function 	sha changed enough 
tell many 	file list 
random elements 	results file contributing 
need 	equal damage 
function returns 	original minus copied 
number items 	removed material 
stored des 	added material 
may less 	damages made preimage 
count hash 	resulting damage 
table 	zero know diffcore 
less count 	count changes 
elements inside 	considers two entries 
enough elements 	identical since 
found reasonable 	content changed know 
amount steps 	must kind 
note 	change force entries 
function suitable 	damage happen 
need good 	even many files 
distribution returned 	everything renames 
items need 	show directories changes 
sample given 	binary files 
number 	counts bytes lines 
continuous elements 	must find 
run kind 	way normalize binary 
algorithm produce 	bytes textual 
statistics however 	lines following 
function much 	heuristic assumes bytes 
faster 	per line 
dict random 	stupid ugly cheap 
key producing 	happen even 
elements hash 	many files everything 
table tables 	renames show 
rehashing work 	directories changes line 
proportional 	thru line 
count pick 	marker size firstchar 
random point 	nothing could 
inside larger 	deflated delta could 
table continuous 	deflated two 
empty entries 	whichever smaller emit 
far 	data encoded 
invariant dict 	never use non 
rehashing indexes 	valid filename 
already visited 	anywhere possible dev 
rehashing populated 	run diff 
buckets skip 	different kind 
indexes 	objects quite common 
idx moreover 	confusing crazy 
currently range 	xdl interfaces crazy 
second table 	xdl interfaces 
elements tables 	codepaths check sides 
current rehashing 	checking old 
index 	side deliberate checking 
jump possible 	newly introduced 
happens going 	changes side text 
big small 	check introduces 
table range 	crazy xdl interfaces 
table count 	least one 
contiguous 	context line report 
empty buckets 	errors given 
jump locations 	name sha pair 
reach count 	index tells 
minimum collect 	file work contents 
elements buckets 	prepare temp 
found 	file inflate 
non empty 	extract read cache 
iterating function 	benchmark previous 
reverse bits 	version always reads 
algorithm http 	cache shows 
graphics stanford 	makes things worse 
edu 	diff comparing 
seander bithacks 	two linux kernel 
html reverse 	trees already 
parallel bit 	work diff comparisons 
size must 	deal small 
power dict 	number files reading 
scan 	cache expensive 
used iterate 	large project cost 
elements dictionary 	outweighs savings 
iterating works 	inflating temporary file 
following way 	practically code 
initially call 	helps used diff 
function 	cache cached 
cursor function 	read cache 
performs one 	calling want avoid 
step iteration 	working directory 
returns cursor 	caller doesn need 
must use 	data normal 
next 	file system rather 
call returned 	slow stat 
cursor iteration 	open mmap close 
complete function 	syscalls contained 
guarantees elements 	pack file pack 
present dictionary 	probably already 
returned 	open faster obtain 
start end 	data working 
iteration however 	directory loose objects 
possible elements 	however would 
returned multiple 	tend slower need 
times every 	individually opened 
element 	inflated sha 
returned callback 	looking unreusable regular 
argument called 	file marked 
privdata first 	unchanged guarantee work 
argument dictionary 	matches looking 
entry second 	matches file work 
argument 	reuse looking 
works iteration 	work rename detection 
algorithm designed 	pickaxe operation 
pieter noordhuis 	may need grab 
main idea 	data blob 
increment cursor 	file core comparison 
starting 	diff filespec 
higher order 	data size fields 
bits instead 	purpose demote 
incrementing cursor 	fail warn allow 
normally bits 	inspecting situation 
cursor reversed 	instead refusing convert 
cursor 	working format 
incremented bits 	canonical git 
reversed strategy 	format generate xxxxxx 
needed hash 	basename ext 
table may 	entry produces file 
resized iteration 	entry produces 
calls 	file borrow file 
dict hash 	work even 
tables always 	though may sometimes 
power two 	borrow contents 
size use 	work always want 
chaining position 	one mode 
element 	mode trustworthy even 
given table 	one sha 
given computing 	valid diff file 
bitwise hash 	valid one 
key size 	external diff command 
size always 	takes diff 
mask 	cmd name infile 
equivalent taking 	infile sha 
rest division 	infile mode 
hash key 	infile infile sha 
size example 	infile mode 
current hash 	rename fallthru use 
table 	colors header 
size mask 	intended external diff 
binary position 	driver strip 
key hash 	prefix molest dev 
table always 	absolute paths 
last four 	filepair changes file 
bits 	symlink needs 
hash output 	split deletion creation 
forth happens 	unmerged unmerged 
table changes 	pathchange left time 
size hash 	say changes 
table grows 	checking changed paths 
elements 	ignore whitespace 
anywhere one 	options force look 
multiple old 	inside contents 
bucket example 	cases always 
say already 	need recursive drop 
iterated bit 	caller supplied 
cursor 	recursive bits formats 
mask hash 	also pickaxe 
table size 	would work well 
hash table 	say recursive 
resized elements 	patches generated submodules 
mask 	diffed work 
buckets obtain 	must dirtiness shown 
substituting either 	output read 
targeted keys 	cache die even 
already visited 	fails safe 
scanning bucket 	also smudge active 
smaller 	cache active 
hash table 	fails worry cleaning 
iterating higher 	either full 
bits first 	make sense 
inverted counter 	show first hit 
cursor need 	happened found 
restart 	make sense exit 
table size 	code either 
gets bigger 	stuck form option 
iterating cursors 	separate form 
without end 	option important checks 
also without 	error cases 
combination 	caller knows dirstat 
bits already 	related option 
explored similarly 	given command line 
table size 	allow say 
shrinks time 	function negation input 
example going 	haven initialized 
combination 	filter field another 
lower three 	diff filter 
bits mask 	start full bits 
size already 	aon output 
completely explored 	format options 
would visited 	stat stat width 
sure 	stat name 
tried example 	width stat count 
variations higher 	renames options 
bit need 	xdiff options clear 
test wait 	previous settings 
two tables 	flags options misc 
rehashing 	options always 
yes always 	end user says 
iterate smaller 	num divided 
table first 	scale say internally 
test expansions 	max score 
current cursor 	num scale convert 
larger 	form arguments 
table example 	form versions option 
current cursor 	expect different 
also larger 	find unique abbrev 
table size 	stuffs result 
also test 	dots alignment 
inside 	function written stricter 
larger table 	necessary support 
reduces problem 	currently implemented transformers 
back one 	idea transformers 
table larger 	produce diff filepairs 
one exists 	way want 
expansion 	filter clean producing 
smaller one 	output unmerged 
limitations iterator 	interesting deletion addition 
completely stateless 	mode type 
huge advantage 	change rename interesting 
including additional 	valid point 
memory 	path dealing change 
used disadvantages 	change look 
resulting design 	file filesystem diffs 
possible elements 	patch format 
however usually 	useful stat diffs 
easy deal 	nothing check 
application 	diffs undecided 
level iterator 	point dealing pair 
must multiple 	whose sides 
elements per 	valid type either 
call needs 	place edit 
always keys 	rename copy edit 
chained 	rename might 
given bucket 	connected broken pair 
expansions sure 	causing pathnames 
miss keys 	rename modification otherwise 
moving rehashing 	see source 
reverse cursor 	used multiple renames 
somewhat 	decrement count 
hard understand 	call copy change 
first comment 	entry happen 
supposed help 	anymore prepare broken 
emit entries 	callers ignore 
cursor make 	line numbers 
sure 	computing sha patch 
smaller bigger 	returns upon 
table emit 	success writes result 
entries cursor 	sha order 
iterate indices 	raw stat summary 
larger table 	patch name 
expansion 	name status checkdiff 
index pointed 	bits clear 
cursor smaller 	run diff flush 
table emit 	patch exit 
entries cursor 	status setting options 
increment bits 	file dev 
covered 	safe aren supposed 
smaller mask 	produce output 
bits covered 	anyway attach patch 
mask difference 	instead report 
non zero 	content level differences 
unmasked bits 	changes diff 
incrementing 	addremove diff 
reversed cursor 	change bit diff 
operates masked 	contents effect 
bits smaller 	otherwise clear whole 
table increment 	queue copying 
reverse cursor 	empty outq end 
functions 	function first 
expand hash 	clear current entries 
table needed 	queue matching 
incremental rehashing 	ones check whether 
already progress 	two filespecs 
hash table 	mode size identical 
empty 	entries come 
expand initial 	stat info dirtiness 
size reached 	always sides 
ratio allowed 	iow create one 
resize hash 	side name 
table setting 	unknown mode size 
avoid 	keep ones 
ratio elements 	match criteria 
buckets safe 	real differences point 
threshold resize 	file known 
doubling number 	modified mode size 
buckets hash 	name one 
table 	side unknown need 
capability power 	inspect identical 
two returns 	contents caller subtract 
index free 	skip stat 
slot populated 	unmatch determine many 
hash entry 	paths dirty 
given 	due stat info 
key key 	mismatch note 
already exists 	please keep following 
returned note 	sync diff 
process rehashing 	combined see follow 
hash table 	renames diff 
index 	see follow renames 
always returned 	diff shall 
context second 	changes submodule 
hash table 	ignored submodule changes 
expand hash 	configured ignored 
table needed 	separately path configuration 
compute 	overridden command 
key hash 	line may look 
search slot 	odd preparation 
already contain 	feeding unchanged files 
given key 	produce diffs 
debugging compute 	copy detection would 
stats 	need entries 
hash entry 	diff core prefixed 
slot generate 	something like 
human readable 	haven decided make 
stats unlike 	difference feeding 
snprintf teturn 	old diff change 
number 	also effect 
characters actually 	output happens pruned 
written make 	merged rename 
sure term 	copy pairs 
end dict.h 	appropriate ignore errors 
buf len 	might repository 
type 	could save changes 
priv data 	flush end 
ptr size 	would need extra 
key val 	call diffing 
key val 	done since generating 
key key 	cache entry 
iter 	slow path anyway 
iter hash 	extra overhead 
table implementation 	probably isn big 
file memory 	deal user 
hash tables 	asked exit code 
insert del 	either want 
replace 	quiet exit code 
find random 	definitely bother 
element operations 	pager former 
hash tables 	generate output since 
resize needed 	still properly 
tables power 	report exit code 
two 	even pager 
size used 	run could run 
collisions handled 	pager exit 
chaining see 	code since done 
source code 	historically easy 
information copyright 	find people oneline 
salvatore 	advising git 
sanfilippo antirez 	diff exit code 
gmail dot 	hooks scripts 
rights reserved 	builtin git diff 
redistribution use 	copyright junio 
source binary 	hamano blob file 
forms 	working make 
without modification 	sure one revision 
permitted provided 	pending revision 
following conditions 	filtering parameters 
met redistributions 	saw two trees 
source code 	ent ent 
must 	ent uninteresting swap 
retain copyright 	diff combine 
notice list 	merges asked diff 
conditions following 	densify user 
disclaimer redistributions 	wants dense one 
binary form 	explicitly asked 
must 	rely could ish 
reproduce copyright 	rev pending 
notice list 	objects list also 
conditions following 	could blobs 
disclaimer documentation 	pathspecs cache files 
materials provided 	diff files 
distribution 	compare two random 
neither name 	blobs must 
redis names 	zero compare blob 
contributors may 	working file 
used endorse 	cache diff 
promote products 	index cached diff 
derived 	compare two 
software without 	filesystem entities aka 
specific prior 	index cases 
written permission 	errors asked index 
software provided 	explicitly treat 
copyright holders 	git diff least 
contributors 	one path 
express implied 	outside repo command 
warranties including 	would executed 
limited implied 	outside git repository 
warranties merchantability 	behaves way 
fitness particular 	git diff index 
purpose 	acts colourful 
disclaimed shall 	diff replacement index 
copyright owner 	two paths 
contributors liable 	possible user intended 
direct indirect 	inside repository 
incidental special 	operation give 
exemplary 	usage message non 
consequential damages 	repository usage 
including limited 	exit index diff 
procurement substitute 	run exit 
goods services 	otherwise usual git 
loss use 	diff scale 
data 	real terminal size 
profits business 	respect stat 
interruption however 	graph width config 
caused theory 	external textconv 
liability whether 	used cached pending 
contract strict 	head hand 
liability 	eek arguments look 
tort including 	reasonable diff 
negligence otherwise 	least one merge 
arising way 	ent objects 
use software 	merge ent 
even advised 	objects ents ent 
possibility 	objects ents 
damage unused 	show diff note 
arguments generate 	pick one 
annoying warnings 	merge random one 
initial size 	diff.h orderfile 
every hash 	pickaxe single follow 
table 	prefix prefix 
macros api 	flags touched flags 
dict hash 	filter use 
tables implementation 	color context interhunkcontext 
file memory 	opt detect 
hash tables 	rename irreversible skip 
insert 	stat unmatch 
del replace 	line termination output 
find random 	format pickaxe 
element operations 	opts rename score 
hash tables 	rename limit 
resize needed 	needed rename 
tables 	limit degraded show 
power two 	rename progress 
size used 	dirstat permille setup 
collisions handled 	abbrev error 
chaining see 	highlight prefix prefix 
source code 	length stat 
information 	sep xdl opts 
copyright salvatore 	stat width 
sanfilippo antirez 	stat name width 
gmail dot 	stat graph 
rights reserved 	width stat count 
redistribution use 	word regex 
source 	found changes found 
binary forms 	follow diff 
without modification 	options file close 
permitted provided 	file pathspec 
following conditions 	pathchange change format 
met redistributions 	callback format 
source 	callback data 
code must 	output prefix output 
retain copyright 	prefix length 
notice list 	output prefix data 
conditions following 	diff path 
disclaimer redistributions 	counter diff color 
binary 	diff options 
form must 	mime boundary leader 
reproduce copyright 	sha parent 
notice list 	sha nparent opt 
conditions following 	diff sha 
disclaimer documentation 	diff root sha 
materials 	next path 
provided distribution 	mode oid status 
neither name 	mode oid 
redis names 	elem num parent 
contributors may 	dense rev 
used endorse 	info sha parents 
promote 	dense rev 
products derived 	commit dense 
software without 	rev options diff 
specific prior 	options diff 
written permission 	options addremove mode 
software provided 	sha sha 
copyright 	valid fullpath dirty 
holders contributors 	submodule diff 
express implied 	options mode mode 
warranties including 	sha sha 
limited implied 	sha valid sha 
warranties merchantability 	valid fullpath 
fitness 	dirty submodule dirty 
particular purpose 	submodule diff 
disclaimed shall 	options path opt 
copyright owner 	argv optarg 
contributors liable 	diff options diff 
direct indirect 	options diff 
incidental 	options diff 
special exemplary 	options diff options 
consequential damages 	diff options 
including limited 	varname needed degraded 
procurement substitute 	revs option 
goods services 	revs cached diff 
loss 	options diff 
use data 	options diff options 
profits business 	rev info 
interruption however 	def diff flags 
caused theory 	driver outbuf 
liability whether 	one files insertions 
contract 	deletions diff 
strict liability 	options copyright junio 
tort including 	hamano output 
negligence otherwise 	format know flag 
arising way 	given give 
use software 	output format unused 
even 	diff filter 
advised possibility 	bits white 
damage unused 	space error highlighting 
arguments generate 	diffcore diff 
annoying warnings 	format patch support 
hash table 	diff recursion 
structure 	follow hack poor 
every dictionary 	man alternative 
two implement 	parse option allow 
incremental rehashing 	stuck form 
old table 	option separate form 
rehashing progress 	option traditional 
rehashidx 	plumbing counter grep 
number iterators 	patch diff 
currently running 	raw status letters 
safe safe 	diff raw 
iterator means 	status letters proper 
call dict 	used diffcore 
dict 	filter insn specify 
find functions 	additional restrictions 
dictionary even 	report anything 
iterating otherwise 	removed paths report 
non safe 	racily clean 
iterator dict 	paths modified fill 
next 	contents filespec 
called iterating 	respecting textconv defined 
iterator fingerprint 	userdiff driver 
misuse detection 	driver parameter must 
initial size 	come previous 
every hash 	call textconv therefore 
table 	either textconv 
macros api 	enabled note memory 
hash table 	ownership resulting 
types dict 	buffer depends whether 
type priv 	driver field 
data ptr 	memory belongs filespec 
size 	non outbuf 
key val 	points newly allocated 
key key 	buffer freed 
val key 	caller look 
key key 	userdiff driver given 
key key 	filespec textconv 
iter 	enabled otherwise result 
iter des 	passed fill 
count buf 	textconv diff diffcore-break.c 
bufsize key 	src dst 
len buf 	score merge score 
len callback 	delta size 
initval 	max size src 
privdata dict 	copied added 
type heap 	src removed score 
copy key 	outq merge 
dict type 	score score one 
heap dict 	two outq 
type 	outq isreg isreg 
heap copy 	hashcmp diff 
key hash 	populate filespec diff 
table implementation 	populate filespec 
file memory 	diffcore count 
hash tables 	changes diff queue 
insert 	clear diff 
del replace 	file valid diff 
find random 	file valid 
element operations 	type type strcmp 
hash tables 	alloc filespec 
resize needed 	diff queue alloc 
tables 	filespec diff 
power two 	queue diff free 
size used 	filespec blob 
collisions handled 	diff free filespec 
chaining see 	blob free 
source code 	diff free filespec 
information 	data diff 
copyright salvatore 	free filespec data 
sanfilippo antirez 	diff free 
gmail dot 	diff file 
rights reserved 	valid diff file 
redistribution use 	valid die 
source 	diff file valid 
binary forms 	die diff 
without modification 	file valid die 
permitted provided 	diff file 
following conditions 	valid die diff 
met redistributions 	queue diff 
source 	free filespec data 
code must 	diff free 
retain copyright 	filespec data free 
notice list 	free diff 
conditions following 	queue clear strcmp 
disclaimer 	strcmp strcmp 
redistributions binary 	merge broken diff 
form must 	diff free 
reproduce copyright 	copyright junio hamano 
notice list 	dst recorded 
conditions following 	modification src 
disclaimer 	different better recording 
documentation materials 	pair create 
provided distribution 	two criteria used 
neither name 	algorithm purposes 
redis names 	helping later rename 
contributors may 	copy take 
used 	insert account estimate 
endorse promote 	amount edit 
products derived 	edit large pair 
software without 	rename copy 
specific prior 	pick pieces match 
written permission 	files hand 
software 	would want ignore 
provided copyright 	inserts pure 
holders contributors 	complete rewrite detection 
express implied 	existing contents 
warranties including 	removed file complete 
limited implied 	rewrite sizable 
warranties 	chunk original 
merchantability fitness 	still remains result 
particular purpose 	rewrite matter 
disclaimed shall 	much little material 
copyright owner 	added file 
contributors liable 	score broken filepair 
direct 	uses latter 
indirect incidental 	definition later clean 
special exemplary 	stage find 
consequential damages 	pieces broken according 
including limited 	latter definition 
procurement substitute 	rename copy runs 
goods 	merge broken 
services loss 	pair score lower 
use data 	given criteria 
profits business 	back together operation 
interruption however 	happens according 
caused theory 	former definition minimum 
liability 	edit parameter 
whether contract 	tells amount 
strict liability 	edit required consider 
tort including 	breaking pair 
negligence otherwise 	amount deletion merge 
arising way 	score want 
use 	pair broken deletion 
software even 	even types 
advised possibility 	different error caught 
damage unused 	downstream small 
arguments generate 	filepair empty files 
annoying warnings 	renamed sanity 
initial 	compute merge score 
size every 	much removed 
hash table 	source material clean 
macros api 	stage merge 
dict hash 	surviving pair together 
tables implementation 	score less 
file 	minimum rename 
memory hash 	copy runs extent 
tables insert 	damage counts 
del replace 	inserts deletes removed 
find random 	lot without 
element operations 	adding material really 
hash 	rewrite filepair 
tables resize 	much edit insert 
needed tables 	first considered 
power two 	rewrite broken create 
size used 	filepair help 
collisions handled 	breaking file much 
chaining 	stuff added 
see source 	possibly moving contents 
code information 	another file 
copyright salvatore 	rename copy match 
sanfilippo antirez 	file score 
gmail dot 	reuse incoming parameter 
rights 	pair broken 
reserved redistribution 	according score 
use source 	subjected rename copy 
binary forms 	may survive 
without modification 	intact due lack 
permitted provided 	suitable rename 
following 	copy peer caller 
conditions met 	may calling 
redistributions source 	without rename copy 
code must 	happens merge 
retain copyright 	broken pieces back 
notice list 	one modification 
conditions 	together pair much 
following disclaimer 	computation take 
redistributions binary 	insert account start 
form must 	line file 
reproduce copyright 	lines matter lines 
notice list 	make line 
conditions 	file lines make 
following disclaimer 	line file 
documentation materials 	either way 
provided distribution 	rewrite hand lines 
neither name 	keeping lines 
redis names 	intact matter lines 
contributors 	make line 
may used 	file lines make 
endorse promote 	line file 
products derived 	either way lot 
software without 	additions rewrite 
specific prior 	merge happens latter 
written 	merge score 
permission software 	would good broken 
provided copyright 	pair score 
holders contributors 	lower merge score 
express implied 	merged back 
warranties including 	together see comment 
limited 	score merge 
implied warranties 	score diffcore deal 
merchantability fitness 	place edit 
particular purpose 	blobs anything 
disclaimed shall 	split create score 
copyright owner 	pair needs 
contributors 	merged back together 
liable direct 	survive rename 
indirect incidental 	copy also want 
special exemplary 	small files 
consequential damages 	deletion one creation 
including limited 	two diff 
procurement 	free filepair reusing 
substitute goods 	one two 
services loss 	broken pairs want 
use data 	merge must 
profits business 	half sanity check 
interruption however 	one extra 
caused 	user src side 
theory liability 	broken pair 
whether contract 	used rename 
strict liability 	source paths elsewhere 
tort including 	increment mark 
negligence otherwise 	path stays resulting 
arising 	already merged 
way use 	peer peer also 
software even 	survived rename 
advised possibility 	copy merge back 
damage unused 	together peer 
arguments generate 	survived merge peer 
annoying 	survive keep 
warnings hash 	output diffcore-delta.c hashval 
table structure 	cnt alloc 
every dictionary 	log free data 
two implement 	orig osz 
incremental rehashing 	bucket top hashval 
old 	cnt bucket 
table rehashing 	lim one accum 
progress rehashidx 	accum hashval 
number iterators 	hash buf 
currently running 	text old src 
safe safe 	dst src 
iterator 	count dst count 
means call 	delta limit 
dict dict 	src copied added 
find functions 	src count 
dictionary even 	dst count dst 
iterating otherwise 	cnt src 
non 	cnt xmalloc mult 
safe iterator 	initial free 
dict next 	memset free spanhash 
called iterating 	rehash diff 
iterator fingerprint 	filespec binary xmalloc 
misuse detection 	mult initial 
initial 	free memset spanhash 
size every 	qsort hash 
hash table 	chars hash chars 
macros api 	free free 
hash table 	idea simple 
types dict 	almost data interested 
dict.h 	text sometimes 
buf len 	deal binary data 
type priv 	cut chunks 
data ptr 	delimited sequence whichever 
size key 	comes first 
val key 	hash chunks source 
val 	buffer instances 
key key 	destination buffer means 
iter iter 	difference number 
hash table 	bytes copied source 
implementation file 	destination counts 
memory hash 	everything copied source 
tables 	destination destination 
insert del 	everything copied destination 
replace find 	added approximation 
random element 	really waste memory 
operations hash 	actually storing 
tables resize 	sequence hash 
needed 	somewhere around hashbuckets 
tables power 	count occurrences 
two size 	wild guess initial 
used collisions 	hash size 
handled chaining 	room smaller hash 
see source 	grow unused 
code 	hole much prime 
information copyright 	rather carefully 
salvatore sanfilippo 	chosen hashbase initial 
antirez gmail 	free want 
dot rights 	keep maximum hashtable 
reserved redistribution 	size current 
use 	maximum hold many 
source binary 	different values 
forms without 	overflowing hashtable size 
modification permitted 	count zero 
provided following 	compares end ignore 
conditions met 	crlf sequence 
redistributions 	text src 
source code 	diffcore-order.c order order 
must retain 	cnt orderfile 
copyright notice 	cnt pass map 
list conditions 	endp path 
following disclaimer 	orderfile obj path 
redistributions 	objs obj 
binary form 	pair orderfile strbuf 
must reproduce 	read file 
copyright notice 	die errno strbuf 
list conditions 	detach xmemdupz 
following disclaimer 	alloc strbuf reset 
documentation 	strbuf addstr 
materials provided 	wildmatch strrchr prepare 
distribution neither 	order match 
name redis 	order obj path 
names contributors 	qsort alloc 
may used 	order objects 
endorse 	free copyright junio 
promote products 	hamano one 
derived software 	line comment diffcore-pickaxe.c 
without specific 	regexp hit 
prior written 	priv line len 
permission software 	data regmatch 
provided 	hold one two 
copyright holders 	regexp kws 
contributors express 	regmatch ecbdata xpp 
implied warranties 	xecfg regexp 
including limited 	kws cnt data 
implied warranties 	regmatch flags 
merchantability 	kwsm offset one 
fitness particular 	two regexp 
purpose disclaimed 	kws one contains 
shall copyright 	two contains 
owner contributors 	regexp kws textconv 
liable direct 	one textconv 
indirect 	two ret 
incidental special 	regexp kws outq 
exemplary consequential 	needle opts 
damages including 	regex regexp kws 
limited procurement 	err cflags 
substitute goods 	errbuf regexec regexec 
services 	regexec memset 
loss use 	memset xdi diff 
data profits 	outf regexec 
business interruption 	kwsexec contains contains 
however caused 	diff file 
theory liability 	valid diff file 
whether 	valid diff 
contract strict 	opt tst textconv 
liability tort 	textconv diff 
including negligence 	unmodified pair fill 
otherwise arising 	textconv fill 
way use 	textconv diff file 
software 	valid diff 
even advised 	file valid 
possibility damage 	free free diff 
unused arguments 	free filespec 
generate annoying 	data diff free 
warnings initial 	filespec data 
size 	diff queue clear 
every hash 	pickaxe match 
table macros 	diff free filepair 
api dict 	pickaxe match 
hash tables 	diff diff free 
implementation file 	filepair free 
memory 	diff opt tst 
hash tables 	regcomp regerror 
insert del 	regfree die kwsalloc 
replace find 	diff opt 
random element 	tst kwsincr strlen 
operations hash 	kwsprep pickaxe 
tables 	regfree kwsfree copyright 
resize needed 	junio hamano 
tables power 	copyright google 
two size 	inc needswork way 
used collisions 	terminate caller 
handled chaining 	early yuck line 
see 	ought sides 
source code 	need run textual 
information copyright 	diff see 
salvatore sanfilippo 	pattern appears added 
antirez gmail 	deleted lines 
dot rights 	classic exact match 
reserved 	ignore unmerged 
redistribution use 	unmodified pair know 
source binary 	count even 
forms without 	load blobs unless 
modification permitted 	textconv play 
provided following 	two different textconv 
conditions 	filters pair 
met redistributions 	exact rename 
source code 	different textconv attributes 
must retain 	side might 
copyright notice 	generate different content 
list conditions 	showing whole 
following 	changeset needle exists 
disclaimer redistributions 	munge queue 
binary form 	otherwise clear whole 
must reproduce 	queue copying 
copyright notice 	empty outq end 
list conditions 	function first 
following 	clear current entries 
disclaimer documentation 	queue showing 
materials provided 	filepairs needle posix 
distribution neither 	people surely 
name redis 	sick might want 
names contributors 	warn care 
may 	diffcore-rename.c two pair 
used endorse 	rename dst 
promote products 	rename dst 
derived software 	alloc two first 
without specific 	last next 
prior written 	dst cmp two 
permission 	ofs two 
software provided 	first score rename 
copyright holders 	src rename 
contributors express 	src alloc first 
implied warranties 	last one 
including limited 	score next src 
implied 	cmp src 
warranties merchantability 	dst dst len 
fitness particular 	src dst 
purpose disclaimed 	score name score 
shall copyright 	src dst 
owner contributors 	minimum score max 
liable 	size delta 
direct indirect 	size size src 
incidental special 	copied added 
exemplary consequential 	delta limit 
damages including 	score dst index 
limited procurement 	src index 
substitute 	score src dst 
goods services 	entry index 
loss use 	filespec filespec srcs 
data profits 	dst index 
business interruption 	options renames target 
however caused 	best best 
theory 	score score source 
liability whether 	table index 
contract strict 	filespec entry options 
liability tort 	renames file 
including negligence 	table worst num 
otherwise arising 	create options 
way 	rename limit num 
use software 	src dst 
even advised 	cnt minimum score 
possibility damage 	copies dst 
unused arguments 	options detect 
generate annoying 	rename minimum score 
warnings 	outq rename 
hash table 	count skip unmodified 
structure every 	num create 
dictionary two 	dst cnt progress 
implement incremental 	two one 
rehashing old 	src pair free 
table 	dst dst 
rehashing progress 	strcmp find rename 
rehashidx number 	dst find 
iterators currently 	rename dst alloc 
running safe 	grow memmove 
safe iterator 	alloc filespec fill 
means 	filespec strcmp 
call dict 	alloc grow memmove 
dict find 	strlen isreg 
functions dictionary 	isreg diff 
even iterating 	populate filespec diff 
otherwise non 	populate filespec 
safe 	max size diff 
iterator dict 	populate filespec 
next called 	diff populate filespec 
iterating iterator 	size diffcore 
fingerprint misuse 	count changes die 
detection initial 	diff queue 
size 	strcmp diff populate 
every hash 	filespec hash 
table macros 	sha file sha 
api hash 	hash hashmap 
table types 	hash hash filespec 
dict type 	hashmap next 
priv 	hashcmp isreg isreg 
data ptr 	basename record 
size key 	rename pair xmalloc 
val key 	hashmap entry 
key val 	init hash 
key key 	filespec hashmap hashmap 
key 	init insert 
key key 	file table find 
iter iter 	identical files 
des count 	hashmap free score 
buf bufsize 	compare score 
key len 	compare diff opt 
buf 	tst diff 
len callback 	unmodified pair record 
initval privdata 	rename pair 
dict type 	diff file valid 
heap copy 	diff file 
key dict 	valid strcmp diff 
type 	opt tst 
heap dict 	empty blob sha 
type heap 	rename dst 
copy key 	warning diff opt 
hash table 	tst empty 
implementation file 	blob sha 
memory 	diff pair unmerged 
hash tables 	diff file 
insert del 	valid rename src 
replace find 	rename src 
random element 	find exact renames 
operations hash 	many rename 
tables 	candidates start progress 
resize needed 	delay xcalloc 
tables power 	mult diff unmodified 
two size 	pair estimate 
used collisions 	similarity basename record 
handled chaining 	better diff 
see 	free filespec blob 
source code 	diff free 
information copyright 	filespec blob display 
salvatore sanfilippo 	progress stop 
antirez gmail 	progress qsort find 
dot rights 	renames find 
reserved 	renames free 
redistribution use 	diff queue clear 
source binary 	diff pair 
forms without 	unmerged diff diff 
modification permitted 	file valid 
provided 	diff file valid 
following conditions 	locate rename 
met redistributions 	dst diff diff 
source code 	diff file 
must retain 	valid diff file 
copyright notice 	valid diff 
list 	pair broken locate 
conditions following 	rename dst 
disclaimer redistributions 	diff diff unmodified 
binary form 	pair diff 
must reproduce 	diff free filepair 
copyright notice 	diff debug 
list 	queue free diff 
conditions following 	debug queue 
disclaimer documentation 	free filespec 
materials provided 	free free copyright 
distribution neither 	junio hamano 
name redis 	table rename copy 
names 	destinations returns 
contributors may 	success found duplicate 
used endorse 	insert make 
promote products 	first table rename 
derived software 	copy src 
without specific 	files remember score 
prior 	insert make 
written permission 	first index rename 
software provided 	src index 
copyright holders 	rename dst src 
contributors express 	points file 
implied warranties 	existed original optionally 
including 	file destination 
limited implied 	dst points 
warranties merchantability 	newly created file 
fitness particular 	may quite 
purpose disclaimed 	similar want say 
shall copyright 	src renamed 
owner 	dst src copied 
contributors liable 	dst edit 
direct indirect 	applied dst compare 
incidental special 	similar representing 
exemplary consequential 	score integer max 
damages including 	score exact 
limited 	match considered better 
procurement substitute 	match anything 
goods services 	destination even call 
loss use 	function deal 
data profits 	regular files symlink 
business interruption 	renames handled 
however 	exact matches words 
caused theory 	edits renaming 
liability whether 	need check 
contract strict 	source destination sizes 
liability tort 	filled comparing 
including negligence 	already cnt data 
otherwise 	filled know 
arising way 	good avoid checking 
use software 	size zero 
even advised 	possible size really 
possibility damage 	flag say 
unused arguments 	whether size valid 
generate 	would consider 
annoying warnings 	edits change file 
initial size 	size drastically 
every hash 	delta size must 
table macros 	smaller max 
api dict 	score minimum score 
hash 	max score 
tables implementation 	min src size 
file memory 	dst size 
hash tables 	note size 
insert del 	handled already score 
replace find 	computation would 
random 	divide zero issue 
element operations 	similar percentage 
hash tables 	material dst source 
resize needed 	happen sort 
tables power 	rename similarity matrix 
two size 	score order 
used 	similar first sink 
collisions handled 	unused ones 
chaining see 	bottom find best 
source code 	source match 
information copyright 	specified destination hash 
salvatore sanfilippo 	collision non 
antirez 	regular files modes 
gmail dot 	must match 
rights reserved 	give higher scores 
redistribution use 	sources haven 
source binary 	used already 
forms without 	many identical alternatives 
modification 	pick one 
permitted provided 	find exact renames 
following conditions 	first first 
met redistributions 	round matches date 
source code 	entries second 
must retain 	round match cache 
copyright 	dirty entries 
notice list 	well sources hash 
conditions following 	table walk 
disclaimer redistributions 	destinations find best 
binary form 	source match 
must reproduce 	free hash data 
copyright 	structure entries 
notice list 	find worst one 
conditions following 	better worst 
disclaimer documentation 	one returns 
materials provided 	limit need disable 
distribution neither 	inexact rename 
name 	detection would limit 
redis names 	given instead 
contributors may 	basically test rename 
used endorse 	matrix growing 
promote products 	larger rename limit 
derived software 	square matrix 
without 	num create num 
specific prior 	src rename 
written permission 	limit rename limit 
software provided 	handles potential 
copyright holders 	overflow specially least 
contributors express 	bit integers 
implied 	running would bust 
warranties including 	limit running 
limited implied 	usable pair already 
warranties merchantability 	done either 
fitness particular 	exact fuzzy 
purpose disclaimed 	unmerged interested source 
shall 	broken really 
copyright owner 	want broken means 
contributors liable 	source actually 
direct indirect 	stays increment rename 
incidental special 	used score 
exemplary consequential 	one indicate user 
damages 	increment rename 
including limited 	used score one 
procurement substitute 	indicate user 
goods services 	nothing really want 
loss use 	cull candidates 
data profits 	list early cheap 
business 	tests order 
interruption however 	avoid deltas want 
caused theory 	exact renames 
liability whether 	calculate many renames 
contract strict 	left source 
liability tort 	files still 
including 	remain options rename 
negligence otherwise 	copies done 
arising way 	dealt exact match 
use software 	already run 
even advised 	estimate similarity need 
possibility damage 	text anymore 
unused 	cost matrix sorted 
arguments generate 	least similar 
annoying warnings 	pair point found 
hash table 	renames copies 
structure every 	recorded rename dst 
dictionary two 	original list 
implement 	still creation would 
incremental rehashing 	output create 
old table 	record turned rename 
rehashing progress 	copy already 
rehashidx number 	matching rename copy 
iterators currently 	source record 
running 	creation deletion 
safe safe 	would output record 
iterator means 	broken counterpart 
call dict 	broken create remains 
dict find 	output broken 
functions dictionary 	rename dst rename 
even 	copy move 
iterating otherwise 	one path existence 
non safe 	otherwise counterpart 
iterator dict 	broken create turned 
next called 	rename edit 
iterating iterator 	matching create begin 
fingerprint 	broken counterpart 
misuse detection 	rename copy path 
initial size 	remains usual 
every hash 	ones need kept 
table macros 	need keep 
api hash 	unmodified pairs 
table 	diffcore.h sha path 
types dict 	data cnt 
endianconv.c argc 	data size count 
argv buf 	rename used 
memrev memrev 	mode driver diff 
memrev unused 	filespec diff 
unused 	filespec diff filespec 
sprintf memrev 	diff filespec 
sprintf memrev 	diff filespec diff 
sprintf memrev 	filespec one 
endinconv endian 	two score status 
conversions utilities 	diff filepair 
functions 	diff filepair queue 
never called 	alloc diff 
directly always 	queued diff diff 
macros defined 	queue diff 
endianconv way 	filespec diff filespec 
define everything 	diff queue 
non 	diff filepair 
operation arch 	diff options diff 
already little 	options orderfile 
endian redis 	obj orig order 
tries encode 	order orderfile 
everything little 	obj path objs 
endian 	diff filespec 
things need 	diff filepair diff 
backward compatible 	queue src 
still big 	dst src count 
endian production 	dst count 
environments little 	delta limit src 
endian 	copied added 
lot conversions 	copyright junio hamano 
places ziplists 	header file 
intsets zipmaps 	diff diff transformers 
need endian 	diffcore rename 
neutral even 	diffcore pickaxe never 
memory 	include header 
since serialied 	anything internally 
rdb files 	use score rely 
directly single 	capable hold 
write without 	bits take bmerge 
additional steps 	score score 
copyright 	format two scores 
salvatore sanfilippo 	passed around 
antirez gmail 	one high bit 
dot rights 	merge low 
reserved redistribution 	bit rename copy 
use source 	similarity minimum 
binary 	minimum happen maximum 
forms without 	merge happen 
modification permitted 	file smaller reference 
provided following 	count count 
conditions met 	rename users file 
redistributions source 	mode use 
code 	sha trust mode 
must retain 	use name 
copyright notice 	read filesystem 
list conditions 	data free data 
following disclaimer 	munmap submodules 
redistributions binary 	work dirty appear 
form 	combined diff 
must reproduce 	data considered binary 
copyright notice 	means know 
list conditions 	yet etc see 
following disclaimer 	documentation diff 
documentation materials 	format txt diff 
provided 	status diff 
distribution neither 	low level diffcore 
name redis 	order setup 
names contributors 	caller setup used 
may used 	order objects 
endorse promote 	nothing nothing nothing 
products 	dir.c len 
derived software 	path fdir untracked 
without specific 	files dirs 
prior written 	file ucd 
permission software 	path len count 
provided copyright 	pattern flags 
holders 	item pattern prefix 
contributors express 	pattern len 
implied warranties 	len pattern patternlen 
including limited 	stringlen flags 
implied warranties 	match status pat 
merchantability fitness 	buf str 
particular 	buf use pat 
purpose disclaimed 	use str 
shall copyright 	pathspec max item 
owner contributors 	len pathspec 
liable direct 	len dir pathspec 
indirect incidental 	len name 
special 	namelen depth max 
exemplary consequential 	depth cpe 
damages including 	item prefix 
limited procurement 	name namelen flags 
substitute goods 	match matchlen 
services loss 	name namelen prefix 
use 	seen flags 
data profits 	exclude len name 
business interruption 	namelen prefix 
however caused 	seen dir positive 
theory liability 	negative flags 
whether contract 	matched pathspec prefix 
strict 	num errors 
liability tort 	found dup match 
including negligence 	len pattern 
otherwise arising 	patternlen flags nowildcardlen 
way use 	len baselen 
software even 	srcpos patternlen flags 
advised 	nowildcardlen path 
possibility damage 	size sha stat 
toggle bit 	pos len 
integer pointed 	data buf 
little endian 	last space dir 
big endian 	name len 
toggle 	first last cmp 
bit integer 	next dir 
pointed little 	dir dir fname 
endian big 	baselen check 
endian toggle 	index sha stat 
bit integer 	lineno size 
pointed 	buf entry pos 
little endian 	fname baselen 
big endian 	check index dir 
endianconv.h argc 	type src 
argv see 	dir fname sha 
endianconv top 	stat dir 
comments 	fname basename basenamelen 
information copyright 	pattern prefix 
salvatore sanfilippo 	patternlen flags pathname 
antirez gmail 	pathlen baselen 
dot rights 	pattern prefix 
reserved redistribution 	patternlen flags name 
use 	namelen pathname 
source binary 	pathlen basename dtype 
forms without 	exc exclude 
modification permitted 	prefix pathname pathlen 
provided following 	basename dtype 
conditions met 	exclude dir pathname 
redistributions 	pathlen basename 
source code 	dtype exclude dir 
must retain 	baselen stk 
copyright notice 	untracked current sha 
list conditions 	stat dir 
following disclaimer 	pathname dtype pathlen 
redistributions 	basename dir 
binary form 	pathname dtype exclude 
must reproduce 	pathname len 
copyright notice 	ent dir pathname 
list conditions 	len dir 
following disclaimer 	pathname len 
documentation 	endchar path pathlen 
materials provided 	simplify match 
distribution neither 	len path len 
name redis 	simplify path 
names contributors 	len pos path 
may used 	len dtype 
endorse 	dir name dir 
promote products 	untracked path 
derived software 	check cdir dir 
without specific 	untracked path 
prior written 	check cdir cdir 
permission software 	pathspec alloc 
provided 	simplify match simplify 
copyright holders 	dir path 
contributors express 	len simplify baselen 
implied warranties 	old flags 
including limited 	uts istate 
implied warranties 	istate istate dir 
merchantability 	len pathspec 
fitness particular 	root len dir 
purpose disclaimed 	path len 
shall copyright 	pathspec simplify untracked 
owner contributors 	trace untracked 
liable direct 	stats subdir dir 
indirect 	offset dir 
incidental special 	cwd path dir 
exemplary consequential 	ret path 
damages including 	flag kept dir 
limited procurement 	len kept 
substitute goods 	empty keep toplevel 
services 	submodule head 
loss use 	path flag slash 
data profits 	dirs dir 
business interruption 	stk prev info 
however caused 	exclude stat 
theory liability 	excludes file 
whether 	stat dir flags 
contract strict 	info exclude 
liability tort 	sha excludes file 
including negligence 	sha exclude 
otherwise arising 	per dir index 
way use 	check valid 
software 	sha valid stat 
even advised 	sha untracked 
possibility damage 	stat data intbuf 
variants function 	intlen untracked 
actual convertion 	ouc varbuf varint 
target host 	len len 
big 	ucd index ucd 
endian functions 	check valid 
htonu ntohu 	sha valid data 
convert specified 	end untracked 
network ordering 	untracked next end 
back big 	len pos 
endian 	pos pos 
systems ops 	sha stat stat 
example-ae.c loop 	sha data 
privdata reply 	ouc end ident 
status status 	ident len 
argc argv 	len ucd dir 
redis 	path len 
disconnect stop 	rest component len 
stop stop 	ret istate 
signal redis 	path istate path 
connect create 	istate path 
loop redis 	strcasecmp strcmp strncasecmp 
attach 	strncmp wildmatch 
redis connect 	strncmp strlen strlen 
callback redis 	strcmp wildmatch 
disconnect callback 	wildmatch strbuf strbuf 
redis command 	wildmatch strbuf 
strlen redis 	release strbuf release 
command 	guard pathspec 
main put 	common prefix 
loop scope 	len xmemdupz common 
explicitly stopped 	prefix len 
disconnect receiving 	read directory strncmp 
reply leak 	strncmp strncmp 
example-libev.c 	git fnmatch guard 
privdata reply 	pathspec within 
status status 	depth match pathspec 
argc argv 	item within 
redis disconnect 	depth match pathspec 
signal redis 	match pathspec 
connect 	strcmp error glob 
redis connect 	special simple 
callback redis 	length strlen simple 
disconnect callback 	length wildcard 
redis command 	parse exclude pattern 
strlen redis 	flexptr alloc 
command 	mem xmalloc 
loop disconnect 	alloc grow strlen 
receiving reply 	cache name 
leak example-libevent.c 	pos skip worktree 
privdata reply 	read sha 
status status 	file free xsize 
argc 	memset hashcpy 
argv redis 	free free free 
disconnect signal 	memset strncmp 
redis connect 	strlen flex alloc 
redis libevent 	mem alloc 
attach 	grow memmove invalidate 
redis connect 	gitignore invalidate 
callback redis 	gitignore open fstat 
disconnect callback 	warn inaccessible 
redis command 	close read skip 
strlen redis 	worktree file 
command 	index free xrealloc 
dispatch disconnect 	xsize fill 
receiving reply 	stat data 
leak example-libuv.c 	hashcpy close xmallocz 
privdata reply 	read full 
status status 	free close close 
argc 	match stat 
argv loop 	data racy cache 
redis disconnect 	name pos 
signal loop 	strlen stage uptodate 
redis connect 	would convert 
redis libuv 	git hashcpy hash 
attach 	sha file 
redis connect 	fill stat data 
callback redis 	skip utf 
disconnect callback 	bom trim trailing 
redis command 	spaces exclude 
strlen redis 	excludes alloc grow 
command 	memset exclude 
run disconnect 	list excludes die 
receiving reply 	excludes file 
leak example.c 	strncmp icase 
argc argv 	strncmp icase fnmatch 
reply hostname 	icase mem 
port 	strncmp icase strncmp 
timeout buf 	icase fnmatch 
atoi redis 	icase mem dtype 
connect timeout 	match basename 
redis free 	match pathname last 
exit redis 	exclude matching 
command 	list last exclude 
free reply 	matching list 
redis command 	strncmp free clear 
free reply 	exclude list 
redis command 	free strbuf init 
free reply 	strbuf setlen 
redis 	xcalloc strchr die 
command free 	lookup untracked 
reply redis 	exclude list strbuf 
command free 	last exclude 
reply redis 	matching lists 
command free 	hashclr sha strbuf 
reply 	addbuf strbuf 
redis command 	addstr strbuf detach 
free reply 	excludes hashcmp 
snprintf redis 	invalidate gitignore hashcpy 
command free 	strbuf setlen 
reply redis 	strlen strrchr prep 
command 	exclude last 
free reply 	exclude matching lists 
redis free 	last exclude 
seconds ping 	matching flex alloc 
server key 	mem cache 
key binary 	file exists alloc 
safe 	grow dir 
api two 	entry cache name 
incr create 	alloc grow 
list numbers 	dir entry isgitlink 
check inside 	strncmp isgitlink 
list disconnects 	lookup untracked 
frees 	read directory recursive 
context parse 	memcmp memcmp 
options multiline 	memcmp cache file 
enable multi 	exists uptodate 
line editing 	isgitlink cache name 
completion callback 	pos strncmp 
called 	uptodate dtype index 
every time 	dtype lstat 
user uses 	isreg isdir islnk 
tab key 	directory exists 
load history 	index excluded strbuf 
file history 	addch treat 
file 	directory strbuf complete 
plain text 	read directory 
file entries 	recursive dot dotdot 
separated newlines 	strcmp strbuf 
load history 	setlen strbuf 
startup main 	addstr simplify away 
loop 	dtype treat 
typical linenoise 	one path alloc 
application call 	grow xstrdup 
linenoise block 	stat invalidate directory 
user types 	memset match 
something presses 	stat data racy 
enter 	invalidate directory 
typed returned 	fill stat data 
malloc allocated 	invalidate directory 
linenoise user 	strbuf addch prep 
needs free 	exclude strbuf 
something history 	setlen prep exclude 
save 	memset valid 
history disk 	cached dir opendir 
historylen command 	readdir closedir 
change history 	read cached dir 
len buf 	treat path 
argc argv 	lookup untracked 
line 	read directory recursive 
prgname len 	untracked dir 
linenoise completion 	name exclude matches 
linenoise completion 	pathspec dir 
strcmp linenoise 	ignored dir name 
multi line 	untracked close 
strcmp 	cached dir strbuf 
linenoise print 	release name 
key codes 	compare alloc grow 
exit exit 	simple length 
linenoise completion 	free memchr strbuf 
callback linenoise 	setlen strbuf 
history 	directory simplify away 
load linenoise 	treat one 
linenoise history 	path strbuf release 
linenoise history 	uname die 
save strncmp 	errno strbuf addf 
atoi linenoise 	git work 
history 	strcmp ident 
max len 	strbuf reset strbuf 
free seconds 	addstr ident 
ping server 	strbuf addch xcalloc 
key key 	strbuf init 
binary safe 	untracked ident untracked 
api 	cache ident 
two incr 	untracked free untracked 
create list 	cache untracked 
numbers check 	cache free untracked 
inside list 	cache getenv 
disconnects frees 	strcmp ident untracked 
context 	warning xmalloc 
parse options 	memset hashcmp invalidate 
multiline enable 	gitignore hashcmp 
multi line 	invalidate gitignore guard 
editing completion 	pathspec symlink 
callback called 	leading path create 
every 	simplify validate 
time user 	untracked cache 
uses tab 	treat leading path 
key load 	read directory 
history file 	recursive free simplify 
history file 	qsort qsort 
plain 	trace key init 
text file 	trace key 
entries separated 	free lstat toupper 
newlines load 	toupper cmp 
history startup 	icase dir sep 
main loop 	dir sep 
typical 	dir sep xgetcwd 
linenoise application 	dir inside 
call linenoise 	free opendir readdir 
block user 	dot dotdot 
types something 	closedir resolve gitlink 
presses enter 	opendir rmdir 
typed 	strbuf complete 
returned malloc 	readdir dot dotdot 
allocated linenoise 	strbuf setlen 
user needs 	strbuf addstr lstat 
free something 	isdir dir 
history save 	recurse unlink closedir 
history 	strbuf setlen 
disk historylen 	rmdir dir recurse 
command change 	access warn 
history len 	excludes file git 
example.c argc 	path info 
argv reply 	exclude access warn 
hostname 	excludes file 
port timeout 	unlink strrchr xstrdup 
buf atoi 	rmdir strrchr 
redis connect 	free free clear 
timeout redis 	exclude list 
free exit 	free free strbuf 
redis 	release htonl 
command free 	htonl htonl 
reply redis 	htonl htonl htonl 
command free 	htonl htonl 
reply redis 	htonl ewah ewah 
command free 	stat data 
reply 	disk strbuf sha 
redis command 	ewah strbuf 
free reply 	encode varint strbuf 
redis command 	encode varint 
free reply 	strbuf strbuf strlen 
redis command 	strbuf strlen 
free 	write one dir 
reply redis 	strlen flex 
command free 	alloc mem stat 
reply snprintf 	data disk 
redis command 	stat data disk 
free reply 	hashcpy hashcpy 
redis 	htonl encode varint 
command free 	strbuf strbuf 
reply redis 	strbuf ouc 
free seconds 	size free encode 
ping server 	varint strbuf 
key key 	ewah ewah ewah 
binary 	strbuf init 
safe api 	strbuf init strbuf 
two incr 	init write 
create list 	one dir encode 
numbers check 	varint strbuf 
inside list 	strbuf addbuf ewah 
disconnects 	serialize strbuf 
frees context 	ewah serialize strbuf 
parse options 	ewah serialize 
multiline enable 	strbuf strbuf addbuf 
multi line 	strbuf addbuf 
editing completion 	strbuf addch ewah 
callback 	free ewah 
called every 	free ewah free 
time user 	strbuf release 
uses tab 	strbuf release 
key load 	strbuf release free 
history file 	untracked free 
history 	free free free 
file plain 	free untracked 
text file 	free memset decode 
entries separated 	varint alloc 
newlines load 	decode varint alloc 
history startup 	strlen xmalloc 
main 	memcpy memcpy strlen 
loop typical 	xstrdup read 
linenoise application 	one dir stat 
call linenoise 	data disk 
block user 	hashcpy stat data 
types something 	disk hashcpy 
presses 	decode varint ouc 
enter typed 	size xcalloc 
returned malloc 	strbuf init 
allocated linenoise 	strbuf load sha 
user needs 	stat load 
free something 	sha stat xstrdup 
history 	ouc size 
save history 	strlen decode varint 
disk historylen 	ewah ewah 
command change 	ewah alloc read 
history len 	one dir 
buf argc 	ewah read mmap 
argv 	ewah read 
line prgname 	mmap ewah read 
len linenoise 	mmap ewah 
completion linenoise 	bit ewah bit 
completion strcmp 	ewah bit 
linenoise multi 	free ewah free 
line 	ewah free 
strcmp linenoise 	ewah free free 
print key 	untracked cache 
codes exit 	strchr lookup 
exit linenoise 	untracked invalidate one 
completion callback 	component invalidate 
linenoise 	one directory invalidate 
history load 	one directory 
linenoise linenoise 	invalidate one component 
history linenoise 	strlen untracked 
history save 	cache invalidate path 
strncmp atoi 	untracked cache 
linenoise 	invalidate path handles 
history max 	recursive filename 
len free 	detection exclude files 
seconds ping 	index knowledge 
server key 	etc see documentation 
key binary 	technical api 
safe 	directory listing txt 
api two 	copyright linus 
incr create 	torvalds junio hamano 
list numbers 	tells read 
check inside 	directory recursive 
list disconnects 	file directory treated 
frees 	values ordered 
context parse 	significance directory contains 
options multiline 	excluded untracked 
enable multi 	files listed untracked 
line editing 	path untracked 
completion callback 	path excluded support 
called 	data structure 
every time 	opendir readdir closedir 
user uses 	wrappers helper 
tab key 	functions support ignore 
load history 	flag wildmatch 
file history 	learned fnm pathname 
file 	mode yet 
plain text 	icase path treated 
file entries 	pathspec full 
separated newlines 	wildcard words prefix 
load history 	considered common 
startup main 	prefix pathspec 
loop 	abc foo abc 
typical linenoise 	bar running 
application call 	subdir xyz common 
linenoise block 	prefix still 
user types 	xyz xuz abc 
something presses 	non icase 
enter 	returns copy longest 
typed returned 	leading path 
malloc allocated 	common among pathspecs 
linenoise user 	calculate common 
needs free 	prefix pathspec use 
something history 	optimize directory 
save 	walk read directory 
history disk 	prune match 
historylen command 	match given name 
change history 	match found 
len extent.c 	match leading directory 
size ret 	name match 
qsize 	wildcard matches 
qsize addr 	name match exactly 
addr addr 	name tells 
addr index 	returns match name 
size size 	namelen prefix 
index extent 	cut caller normal 
quantize 	call pattern 
extent node 	prefix common prefix 
size extent 	len prune 
quantize extent 	something fill directory 
node size 	match pathspec 
extent node 	prefix may shorter 
addr 	command prefix 
extent node 	match extra files 
addr extent 	extras trimmed 
node addr 	suppose pathspec foo 
extent node 	bar running 
addr round 	subdir xyz 
nearest 	common prefix empty 
chunk size 	thanks may 
actually requested 	xyz foo xyz 
normal huge 	foo user 
allocation compare 	want xyz foo 
quantized size 	foo part 
rather 	insensitive need filter 
size order 	xyz foo 
sort equally 	words trust caller 
useful extents 	comparing prefix 
address generate 	part icase involved 
red black 	exact comparison 
functions 	normally caller common 
generate red 	prefix len 
black functions 	fact exact matching 
extent.h arena 	name prefix 
addr size 	need check part 
zeroed committed 	defensive check 
achunk 	anyway common 
prof tctx 	prefix len changed 
node node 	caller introduced 
node node 	use common prefix 
node node 	len penalty 
node node 	turns high prefix 
arena 	really maybe 
node addr 	change strncmp match 
node size 	name item 
node zeroed 	prefix prefix match 
node committed 	prefix matched 
node achunk 	given name list 
node 	pathspecs returns 
tctx node 	nature closest specific 
arena addr 	match name 
size zeroed 	pathspecs caller typically 
committed node 	calls multiple 
node runs 	times pathspec seen 
dirty 	different name 
chunks dirty 	namelen entries 
node node 	index interested seeing 
node node 	pathspec matches 
node node 	names calls function 
node node 	mark left 
node 	seen pathspec element 
arena node 	indicating closest 
addr node 	type match element 
size node 	achieved seen 
zeroed node 	remains zero multiple 
committed node 	invocations means 
achunk 	nth pathspec match 
node tctx 	names could 
node arena 	indicate user mistyped 
addr size 	nth pathspec 
zeroed committed 	make exclude patterns 
node node 	optional never 
runs 	report pathspec exclude 
dirty chunks 	foo matches 
dirty node 	files make 
extent node 	sure pathspec matched 
arena extent 	otherwise error 
node addr 	caller might fed 
extent 	identical pathspec 
node size 	twice barf mistake 
extent node 	fixme parse 
zeroed extent 	pathspec eliminated duplicate 
node committed 	pathspec match 
extent node 	already length simple 
achunk 	part path 
extent node 	match limiter excluded 
prof tctx 	trailing slash 
meld meld 	one allocation instead 
jemalloc types 	make sure 
extents use 	nowildcardlen exceed real 
accessor 	patternlen frees 
functions fields 	memory within 
arena extent 	allocated exclude patterns 
came pointer 	file buffer 
extent node 	free fallthrough given 
responsible total 	subdirectory name 
region 	dir current directory 
size zeroed 	search subdir 
flag used 	dir create one 
chunk recycling 	exist dir 
code track 	name trailing slash 
whether memory 	excluded search 
zero 	given file name 
filled physical 	fname read 
memory committed 	either disk index 
extent whether 	check index 
explicitly implicitly 	non zero parse 
system overcommits 	store exclude 
satisfies 	rules compute sha 
physical memory 	exclude file 
needs demand 	fill stat 
via soft 	data disk valid 
page faults 	excludes returns 
achunk flag 	zero valid non 
used 	zero must 
validate huge 	contain good input 
allocation lookups 	content change 
arena chunks 	sha still good 
profile counters 	used core 
used huge 	excludesfile git info 
objects 	exclude lists 
linkage arena 	setup standard excludes 
runs dirty 	called dir 
chunks cache 	untracked assigned function 
rings linkage 	behaves differently 
size address 	dir untracked non 
ordered 	see validate 
linkage arena 	untracked cache matching 
huge node 	fooliteral match 
cache lists 	fnm pathname 
linkage address 	pattern implicitly front 
ordered 	baselen count 
jemalloc structs 	trailing slash may 
jemalloc externs 	may end 
jemalloc inlines 	trailing slash though 
fmacros.h copyright 	non wildcard 
salvatore sanfilippo 	part longer remaining 
antirez 	pathname surely 
gmail dot 	cannot match whole 
rights reserved 	pattern wildcard 
redistribution use 	prefix match need 
source binary 	need call 
forms without 	fnmatch scan given 
modification 	exclude list 
permitted provided 	reverse see whether 
following conditions 	pathname ignored 
met redistributions 	first match last 
source code 	list determines 
must retain 	fate returns 
copyright 	exclude list element 
notice list 	matched undecided 
conditions following 	undecided undefined scan 
disclaimer redistributions 	list last 
binary form 	match determine fate 
must reproduce 	exclude include 
copyright 	undecided undecided loads 
notice list 	per directory 
conditions following 	exclude list substring 
disclaimer documentation 	length baselen 
materials provided 	pop exclude lists 
distribution neither 	excl dirs 
name 	exclude list originate 
redis names 	directories prefix 
contributors may 	path see strbuf 
used endorse 	detach skip 
promote products 	traversing sub 
derived software 	directories parent excluded 
without 	lazy initialization 
specific prior 	call sites currently 
written permission 	memset dir 
software provided 	dir use changing 
copyright holders 	seems lots 
contributors express 	work little benefit 
implied 	read parent 
warranties including 	directories push abort 
limited implied 	directory excluded 
warranties merchantability 	read per directory 
fitness particular 	file know 
purpose disclaimed 	files added directory 
shall 	valid cached 
copyright owner 	dir executed untracked 
contributors liable 	valid gitignore 
direct indirect 	exist exclude sha 
incidental special 	skip loading 
exemplary consequential 	gitignore would 
damages 	result enoent anyway 
including limited 	dir basebuf 
procurement substitute 	gets reused traversal 
goods services 	need fname 
loss use 	remain unchanged ensure 
data profits 	src member 
business 	exclude correctly back 
interruption however 	references source 
caused theory 	file invocations exclude 
liability whether 	list provide 
contract strict 	stable strbuf detach 
liability tort 	free caller 
including 	needswork untracked cache 
negligence otherwise 	enabled prep 
arising way 	exclude first called 
use software 	valid cached 
even advised 	dir maybe many 
possibility damage 	times last 
net 	exclude matching 
bsd xopen 	cache used last 
source undefines 	exclude matching 
netbsd source 	called reading gitignore 
thus hides 	content waste 
inet aton 	called valid cached 
etc 	dir gitignore 
copyright salvatore 	sha index gitignore 
sanfilippo antirez 	modified work 
gmail dot 	could delay reading 
rights reserved 	gitignore content 
redistribution use 	absolutely need last 
source 	exclude matching 
binary forms 	careful ignore rule 
without modification 	order though 
permitted provided 	loads exclude lists 
following conditions 	directory containing 
met redistributions 	pathname scans exclude 
source 	lists determine 
code must 	whether pathname 
retain copyright 	excluded returns exclude 
notice list 	list element 
conditions following 	matched undecided loads 
disclaimer redistributions 	exclude lists 
binary 	directory containing pathname 
form must 	scans exclude 
reproduce copyright 	lists determine whether 
notice list 	pathname excluded 
conditions following 	returns otherwise use 
disclaimer documentation 	alphabetically sorted 
materials 	index look directory 
provided distribution 	name instead 
neither name 	use insensitive directory 
redis names 	hash index 
contributors may 	sorts alphabetically entry 
used endorse 	name means 
promote 	gitlink sorts end 
products derived 	directory defined 
software without 	entry files 
specific prior 	contains sort end 
written permission 	find directory 
software provided 	traversing filesystem three 
copyright 	distinct cases 
holders contributors 	ignore see directory 
express implied 	recurse one 
warranties including 	choose depends combination 
limited implied 	existing git 
warranties merchantability 	index contents flags 
fitness 	passed directory 
particular purpose 	traversal routine already 
disclaimed shall 	entries index 
copyright owner 	directory name always 
contributors liable 	recurse directory 
direct indirect 	see files already 
incidental 	directory name 
special exemplary 	gitlink always 
consequential damages 	see gitlink regardless 
including limited 	whether actual 
procurement substitute 	git directory might 
goods services 	subproject didn 
loss 	index previously sub 
use data 	cases show 
profits business 	directories show directory 
interruption however 	unless hide 
caused theory 	empty directories also 
liability whether 	need check 
contract 	contains untracked ignored 
strict liability 	files looks 
tort including 	like git directory 
negligence otherwise 	gitlinks treat 
arising way 	gitlink show directory 
use software 	otherwise recurse 
even 	len strip show 
advised possibility 	directories inexact 
damage net 	early pruning 
bsd xopen 	recursive directory reading 
source undefines 	path cannot 
netbsd source 	possibly pathspec skip 
thus 	early function 
hides inet 	tells whether excluded 
aton etc 	path matches 
fmacros.h copyright 	list interesting pathspecs 
salvatore sanfilippo 	whether path 
antirez gmail 	matched pathspecs could 
dot 	possibly ignored 
rights reserved 	excluding specified path 
redistribution use 	happen path 
source binary 	mentioned explicitly pathspec 
forms without 	path directory 
modification permitted 	prefix element pathspec 
provided 	nobody actually 
following conditions 	cares difference lnk 
met redistributions 	reg look 
source code 	directory always 
must retain 	exclude indexed files 
copyright notice 	looking directory 
list 	working three cases 
conditions following 	exists index 
disclaimer redistributions 	everything inside directory 
binary form 	working needs 
must reproduce 	index exist index 
copyright notice 	index know 
list 	stay directory check 
conditions following 	contents index 
disclaimer documentation 	know yet directory 
materials provided 	working killed 
distribution neither 	need recurse exist 
name redis 	index index 
names 	require directory either 
contributors may 	know everything 
used endorse 	inside killed without 
promote products 	recursing excluded 
derived software 	explicitly want 
without specific 	show ignored files 
prior 	ignore treat 
written permission 	one path calls 
software provided 	treat directory 
copyright holders 	check result treat 
contributors express 	directory getting 
implied warranties 	bottom verify directories 
including 	check path 
limited implied 	recurse first run 
warranties merchantability 	directory exists 
fitness particular 	index returns index 
purpose disclaimed 	nonexistent sure 
shall copyright 	changes index impact 
owner 	outcome prep 
contributors liable 	exclude called eventually 
direct indirect 	directory called 
incidental special 	much later 
exemplary consequential 	last exclude matching 
damages including 	need determine 
limited 	validity cache path 
procurement substitute 	next calls 
goods services 	nearly way prep 
loss use 	exclude designed 
data profits 	hopefully prep exclude 
business interruption 	haven invalidated 
however 	entry gone directory 
caused theory 	found untracked 
liability whether 	entries mark valid 
contract strict 	read directory 
liability tort 	currently ignore anything 
including negligence 	directories regular 
otherwise 	files symlinks git 
arising way 	doesn handle 
use software 	yet maybe change 
even advised 	day also 
possibility damage 	ignore name 
net bsd 	git even directory 
xopen 	likely change 
source undefines 	returns significant path 
netbsd source 	treatment encountered 
thus hides 	scan check file 
inet aton 	directory treated 
etc copyright 	recurse subdir instructed 
salvatore 	treat path 
sanfilippo antirez 	abort early maximum 
gmail dot 	state reached 
rights reserved 	skip dir part 
redistribution use 	path appropriate 
source binary 	result list recurse 
forms 	finished checking 
without modification 	previous git versions 
permitted provided 	may saved 
following conditions 	many nul separated 
met redistributions 	ident field 
source code 	insane manage 
must 	many locations take 
retain copyright 	care first 
notice list 	one strbuf used 
conditions following 	contain list 
disclaimer redistributions 	nul separated save 
binary form 	nul backward 
must 	compatibility flags used 
reproduce copyright 	git status 
notice list 	support git dir 
conditions following 	info exclude 
disclaimer documentation 	core excludesfile ignore 
materials provided 	rule files 
distribution 	additions command line 
neither name 	invalidate cache 
redis names 	condition also catches 
contributors may 	running setup 
used endorse 	standard excludes setting 
promote products 	dir untracked 
derived 	optimize main 
software without 	use whole git 
specific prior 	status work 
written permission 	involved treat leading 
software provided 	path use 
copyright holders 	cache subset worktree 
contributors 	pathspec support 
express implied 	could make matter 
warranties including 	even worse 
limited implied 	different flags may 
warranties merchantability 	produce different 
fitness particular 	results see treat 
purpose 	directory index 
disclaimed shall 	nonexistent without flag 
copyright owner 	may need 
contributors liable 	also cache git 
direct indirect 	file content 
incidental special 	resolve gitlink 
exemplary 	call support collecting 
consequential damages 	ignore files 
including limited 	use gitignore cache 
procurement substitute 	change gitexclude 
goods services 	everything wrong exc 
loss use 	cmdl considered 
data 	cache people skip 
profits business 	cache validate 
interruption however 	git dir info 
caused theory 	exclude core 
liability whether 	excludesfile make sure 
contract strict 	directory dropped 
liability 	saving phase check 
tort including 	create simplify 
negligence otherwise 	exclude patterns treated 
arising way 	like positive 
use software 	ones create simplify 
even advised 	usually exclude 
possibility 	patterns subset 
damage net 	positive ones impacts 
bsd xopen 	create simplify 
source undefines 	make sure untracked 
netbsd source 	cache code 
thus hides 	path disabled prep 
inet 	exclude given 
aton etc 	two normalized paths 
fpconv.c locale 	trailing slash 
point buf 	subdir outside dir 
lower nptr 	otherwise offset 
endptr localbuf 	subdir used relative 
buf 	path dir 
endbuf buflen 	hel hel yeah 
fmt precision 	dir foo 
str num 	foo foo bar 
precision buf 	foo descend 
fmt len 	nuke nested git 
snprintf 	work empty 
abort valid 	dir could 
number character 	removable even unreadable 
strtod strtod 	file disappeared 
buffer size 	wanted anyway fall 
malloc abort 	thru happy 
memcpy 	happy path stat 
strchr strtod 	fails non 
free number 	directory still exists 
format snprintf 	report uplevel 
snprintf fpconv 	error rmdir directory 
update locale 	core excludefile 
fpconv 	defaulting xdg home 
floating point 	git ignore 
conversion routines 	per repository user 
copyright mark 	preference frees 
pulford mark 	memory within dir 
kyne permission 	allocated exclude 
hereby 	lists exclude stack 
granted free 	free dir 
charge person 	number written 
obtaining copy 	untracked cache dir 
software associated 	untracked cache 
documentation files 	dir untracked cache 
software 	dir exclude 
deal software 	sha untracked reset 
without restriction 	whenever valid 
including without 	clear safety skip 
limitation rights 	non recurse 
use copy 	directories safe guard 
modify 	lists nul 
merge publish 	exclude per dir 
distribute sublicense 	covered ouc 
sell copies 	normally entry added 
software permit 	removed directory 
persons software 	invalidating directory enough 
furnished 	need touch 
subject following 	ancestors directory shown 
conditions copyright 	foo bar 
notice permission 	git status 
notice shall 	however deleting adding 
included copies 	entry may 
substantial 	cascading effect say 
portions software 	foo bar 
software provided 	file become untracked 
without warranty 	need tell 
kind express 	untracked cache dir 
implied including 	foo bar 
limited 	untracked directory bar 
warranties merchantability 	managed foo 
fitness particular 	untracked file similarly 
purpose noninfringement 	foo bar 
shall authors 	file moves untracked 
copyright holders 	tracked last 
liable 	untracked entry entire 
claim damages 	foo show 
liability whether 	foo instead 
action contract 	means invalidate past 
tort otherwise 	bar foo 
arising connection 	function traverses directories 
software 	root leaf 
use dealings 	chance one cases 
software json 	happening invalidate 
uses separator 	back root otherwise 
strtod sprintf 	invalidate leaf 
libraries locale 	may sophisticated way 
support 	checking show 
separator comma 	directories detect cases 
fpconv around 	avoid unnecessary 
issues translation 	invalidation example checking 
buffer required 	untracked entry 
lua cjson 	named bar foo 
assumes 	stick something 
locale threads 	safe simple dir.h 
within process 	len name 
doesn change 	pattern patternlen 
initialisation avoids 	nowildcardlen baselen flags 
need per 	srcpos alloc 
storage 	filebuf src excludes 
expensive checks 	prev baselen 
call theory 	exclude ucd alloc 
multibyte points 	stat sha 
possible lua 	valid dirs untracked 
cjson supports 	stat data 
utf 	untracked alloc dirs 
known locales 	dirs alloc 
single points 	untracked exclude sha 
localconv may 	name info 
safe crash 	exclude excludes file 
langinfo supported 	exclude per 
platforms 	dir ident dir 
use sprintf 	flags root 
instead locale 	dir created gitignore 
change least 	invalidated dir 
lua cjson 	invalidated dir 
won crash 	opened alloc ignored 
failing 	ignored alloc 
test might 	entries ignored exclude 
imply platform 	per dir 
buggy dtoa 	exclude list exclude 
implementation wide 	stack exclude 
characters check 	basebuf untracked info 
valid 	exclude excludes 
number character 	file unmanaged exclude 
infinity used 	files match 
find probable 	pathspec pathspec name 
end number 	namelen prefix 
doesn matter 	seen dir matched 
invalid 	pathspec prefix 
characters counted 	name namelen depth 
strtod find 	max depth 
valid number 	dir pathspec dir 
exists risk 	path len 
slightly memory 	pathspec pathname 
might 	pathlen basename dtype 
allocated parse 	dir pathname 
error occurs 	len dir name 
hex digits 	dtype dir 
exponent infinity 	name dtype dir 
calculate size 	type src 
buffer 	fname baselen check 
required strtod 	index dir 
locale conversion 	fname patternlen flags 
similar strtod 	nowildcardlen baselen 
must passed 	srcpos dir dir 
current 	subdir dir 
locale point 	name dir dir 
character guaranteed 	path flag 
called start 	path count pattern 
valid number 	flags item 
system strtod 	pattern prefix 
fine 	pathspec seen ent 
point valid 	pathspec prefix 
characters found 	seen trailing dir 
standard strtod 	len index 
duplicate number 	state index state 
buffer handle 	index state 
unusually 	untracked cache data 
large numbers 	untracked istate 
common update 	istate match pathspec 
point character 	namelen isdir 
found fmt 	isgitlink match pathspec 
must point 	see documentation 
buffer 	technical api directory 
least characters 	listing txt 
create format 	allows callers last 
precision assumes 	exclude matching 
always least 	etc determine origin 
characters available 	matching pattern 
target 	counting starts 
buffer pass 	line numbers ignore 
point character 	files decrementing 
dot snprintf 	patterns cli args 
buffer translate 	excludes file 
point characters 	parsed fresh exclude 
copy 	list appended 
target location 	relevant exclude list 
translate point 	either exc 
required fpconv.h 	dirs exc file 
lua cjson 	exclude list 
floating point 	within exc cmdl 
conversion 	exclude list 
routines buffer 	also used represent 
required store 	list exclude 
largest representation 	values passed via 
longest printed 	cli args 
characters nothing 	remember pointer exclude 
required 	file contents 
geo.c range 	free origin 
spec bits 	list path filename 
hash argv 	descriptive contents 
zobj member 	per directory exclude 
score unit 	files lazily 
argv 	read demand cached 
conversion distance 	memory one 
meters dbuf 	per exclude stack 
dlen lon 	order avoid 
lat radius 	opening parsing one 
score member 	every time 
distance 	directory traversed exclude 
zobj min 	stack parent 
max lon 	directory index exclude 
lat radius 	list within 
range origincount 	exc dirs exclude 
member eptr 	list untracked 
sptr 	cache following inputs 
vstr vlen 	sufficient determine 
vlong score 	files directory 
zsl hash 	excluded list files 
min max 	directories directory 
zobj hash 	question git dir 
lon 	index dir 
lat radius 	flags content git 
min max 	dir info 
zobj lon 	exclude content core 
lat radius 	excludesfile content 
neighbors last 	lack gitignore parent 
processed 	directories git 
gpb elements 	work check flag 
argc argv 	read directory 
hash bits 	recursive dir hide 
score val 	empty directories 
type key 	first input directory 
storekey 	mtime many 
storedist zobj 	filesystems directory 
args member 	mtime stat data 
conversion withcoords 	field updated 
sort count 	files direct subdirs 
remaining arg 	added removed 
georadius 	second one hooked 
result length 	cache invalidate 
returned items 	path whenever file 
option length 	submodule added 
zobj maxelelen 	removed directory invalidate 
znode score 	directory remaining 
elelen 	inputs easy sha 
ele geoalphabet 	could used 
zobj score 	verify contents exclude 
hash buf 	sha info 
idx zobj 	exclude sha excludes 
score meter 	file sha 
zobj 	data dirs good 
score score 	sha means 
xyxy zmalloc 	directory gitignore 
zrealloc sdsfree 	dir flags must 
zfree zfree 	match dir 
geohash decode 	flags untracked cache 
lat 	ignored statistics 
wgs reply 	exclude info maintain 
reply sds 	three groups 
sdscatprintf sdsempty 	exclude pattern lists 
zset score 	exc cmdl 
decode geohash 	lists patterns explicitly 
strcmp 	given command 
strcmp strcmp 	line exc dirs 
strcmp reply 	lists patterns 
error reply 	obtained per directory 
extract unit 	ignore files 
reply snprintf 	exc file lists 
reply 	patterns fallback 
bulk buffer 	ignore files git 
decode geohash 	info exclude 
geohash distance 	core excludesfile 
radius wgs 	contains multiple exclude 
geo append 	lists single 
zzl 	list per source 
first range 	temporary variables 
ziplist next 	used loading per 
zzl score 	directory exclude 
zsl lte 	lists exclude stack 
max ziplist 	points top 
sdsfromlonglong 	exclude stack basebuf 
sdsnewlen geo 	contains full 
append within 	path current sub 
radius sdsfree 	directory traversal 
zzl next 	exclude points matching 
zsl first 	exclude directory 
range 	excluded enable untracked 
zsl lte 	file cache 
max sdsfromlonglong 	ordering constants significant 
sdsdup geo 	higher numbered 
append within 	match types 
radius sdsfree 	signifying closer specific 
geohash 	matches lower 
align bits 	numbered match types 
geohash align 	populating seen 
bits scores 	implement matching logic 
geo hash 	dir excluded 
box geo 	list attr path 
points 	matches tries 
range hashiszero 	path empty directories 
members geo 	along ignores 
hash box 	enoent prefix part 
sort asc 	pattern must 
reply error 	contains wildcards dirent.c 
zcalloc 	dir handle 
create raw 	stat ent fdata 
incr count 	name pattern 
extract lat 	fdata len dir 
reply decr 	err dir 
count zfree 	fdata lasterr 
geohash 	dir xwcstoutf xutftowcs 
encode wgs 	path dir 
geohash align 	sep find first 
bits create 	file last 
sdsfromlonglong incr 	error err win 
count replace 	posix xmalloc 
client 	finddata dirent find 
command vector 	next file 
zadd command 	finddata dirent last 
lookup key 	error err 
read reply 	win posix find 
check type 	close free 
extract 	includes type find 
lat reply 	first file 
lat member 	handle index convert 
reply error 	utf name 
reply error 	utf file 
extract distance 	type win find 
reply 	data convert 
strcasecmp strcasecmp 	name utf check 
strcasecmp strcasecmp 	length max 
strcasecmp strcasecmp 	path append optional 
reply reply 	wildcard open 
error strcasecmp 	find handle initialize 
strcasecmp 	dir structure 
reply reply 	copy first dir 
error geohash 	entry errno 
areas radius 	mingw first entry 
wgs geo 	dirent already 
create members 	opendir next entry 
neighbors 	convert win 
reply geo 	find data dirent 
free qsort 	posix says 
qsort reply 	shouldn errno readdir 
multi bulk 	find files 
len reply 	another error 
multi 	dirent.h type name 
bulk len 	dirname dir 
reply bulk 	dir file type 
sds reply 	prevent lstat 
distance reply 	readdir file name 
reply multi 	utf conversion 
bulk 	dirent editor.c editor 
len reply 	terminal terminal 
human reply 	dumb path buffer 
human create 	env editor 
zset sdslen 	args ret sig 
create incr 	getenv getenv 
count 	strcmp getenv getenv 
zsl insert 	git editor 
server dict 	error strcmp start 
zset convert 	command error 
ziplist needed 	sigchain push sigchain 
key decr 	push finish 
count 	command sigchain 
notify keyspace 	pop sigchain pop 
signal modified 	error strbuf 
key notify 	read file error 
keyspace reply 	strerror entry.c 
geo free 	path path len 
georadius 	state buf 
georadius lookup 	len path dir 
key read 	origlen path 
reply check 	mode size path 
type reply 	tempfile symlink 
multi bulk 	state path filter 
len 	state tempfile 
zset score 	fstat done statbuf 
reply decode 	result path 
geohash reply 	state tempfile mode 
geohash encode 	ifmt ret 
reply bulk 	fstat done buf 
buffer 	size wrote 
lookup key 	newsize filter 
read reply 	path len skiplen 
check type 	slash state 
reply multi 	topath path changed 
bulk len 	xmallocz dirs 
zset 	path mkdir unlink 
score reply 	warn mkdir 
decode geohash 	die errno free 
reply reply 	opendir die 
multi bulk 	errno readdir dot 
len reply 	dotdot strbuf 
human 	addch strbuf addstr 
reply human 	lstat die 
extract unit 	errno isdir subtree 
reply reply 	unlink die 
lookup key 	errno strbuf setlen 
read reply 	closedir rmdir 
check 	die errno 
type zset 	open read sha 
score zset 	file free 
score reply 	xsnprintf mkstemp create 
decode geohash 	file fstat 
decode geohash 	reliable fstat open 
reply 	output stream 
reply distance 	blob fstat output 
geohash distance 	close unlink 
copyright matt 	stream filter streaming 
stancliff matt 	write entry 
genges copyright 	read blob entry 
salvatore 	error sha 
sanfilippo antirez 	hex symlink free 
gmail rights 	error strerror 
reserved redistribution 	convert working free 
use source 	strbuf detach 
binary forms 	open output free 
without 	error strerror 
modification permitted 	write full 
provided following 	fstat output close 
conditions met 	free error 
redistributions source 	error mkdir error 
code must 	error lstat 
retain 	fill stat cache 
copyright notice 	info dirs 
list conditions 	path lstat write 
following disclaimer 	entry strbuf 
redistributions binary 	reset strbuf strbuf 
form must 	namelen check 
reproduce 	path match stat 
copyright notice 	isdir isgitlink 
list conditions 	error subtree unlink 
following disclaimer 	error strerror 
documentation materials 	create directories write 
provided distribution 	entry checkout 
neither 	index prefix dir 
name redis 	dir allowed 
names contributors 	symlink existing 
may used 	directory state dir 
endorse promote 	len test 
products derived 	path components prefix 
software 	stat function 
without specific 	instead lstat function 
prior written 	already directory 
permission software 	mkdir would fail 
provided copyright 	could already 
holders contributors 	symlink something exists 
express 	therefore unlink 
implied warranties 	one time create 
including limited 	directory use 
implied warranties 	fstat path name 
merchantability fitness 	convert git 
particular purpose 	format working format 
disclaimed 	like lstat 
shall copyright 	refuses follow symlinks 
owner contributors 	path skipping 
liable direct 	skiplen write 
indirect incidental 	contents working topath 
special exemplary 	instead writing 
consequential 	working file named 
damages including 	temporary file 
limited procurement 	created function name 
substitute goods 	returned topath 
services loss 	must able hold 
use data 	least temporary 
profits 	filename length bytes 
business interruption 	unlink old 
however caused 	file one right 
theory liability 	permissions including 
whether contract 	umask nasty emulate 
strict liability 	hand much 
tort 	easier system right 
including negligence 	thing gitlink 
otherwise arising 	alone environment.c 
way use 	trust executable bit 
software even 	trust ctime 
advised possibility 	check stat symlinks 
damage 	abbrev ignore 
things exported 	unchanged prefer symlink 
zset geo 	refs bare 
since part 	repository cfg log 
redis requires 	updates warn 
close zset 	ambiguous refs warn 
introspection 	refname ambiguity 
file following 	paranoia repository format 
commands geoadd 	version repository 
coordinates geoset 	format precious objects 
georadius search 	git commit 
radius coordinates 	encoding git log 
geoset 	output encoding 
georadiusbymember search 	shared repository apply 
radius geoset 	whitespace apply 
member position 	ignorewhitespace git 
geo implementation 	attributes file zlib 
create geo 	compression level 
points 	core compression level 
gets allocated 	core compression 
first geo 	seen fsync files 
append call 	packed git 
entry pointer 	window size packed 
caller populate 	git limit 
data 	delta cache limit 
destroy geo 	big file 
created geo 	threshold pager program 
create helpers 	pager use 
input argument 	color editor program 
helper take 	askpass program 
pointer 	excludes file check 
latitude arg 	replace refs 
use next 	git replace whitespace 
arg longitude 	rule cfg 
parse error 	notes name 
err returned 	grafts replace parents 
otherwise 	core apply 
input argument 	sparse checkout merge 
helper decode 	log config 
lat zset 	precomposed unicode startup 
member score 	info pack 
returns successful 	size limit cfg 
decoding 	protect hfs 
otherwise err 	protect ntfs comment 
returned check 	line comment 
unit argument 	line core preload 
matches one 	index ignore 
known units 	untracked cache config 
returns 	git work 
conversion factor 	cfg work len 
meters need 	git dir 
divide meters 	git common dir 
conversion factor 	git dir 
convert right 	git index 
unit 	file git graft 
unit valid 	file git 
error reported 	env git index 
client less 	env git 
zero returned 	graft env git 
input argument 	common dir 
helper 	env local repo 
extract dinstance 	env raw 
specified two 	buf components envvar 
arguments starting 	git dir 
argv shouldbe 	path fromenv gitfile 
form number 	shallow file 
unit 	replace namespaced git 
dinstance specified 	work initialized 
unit success 	work limit pattern 
conversino populated 	mode name 
coefficient use 	namesz sha path 
order convert 	xstrdup strbuf 
meters 	addstr strbuf 
unit error 	split strbuf reset 
less zero 	strcmp strbuf 
returned reply 	addf strbuf list 
much accuracy 	free check 
use returning 	refname format die 
location 	strbuf addch 
distances meters 	strbuf detach getenv 
away nicer 	xstrfmt xstrdup 
meters away 	getenv read gitfile 
provide digits 	xstrdup common 
dot returned 	dir strbuf detach 
decently 	git path 
accurate even 	env git path 
unit kilometer 	env git 
helper function 	path env getenv 
geo points 	getenv xstrdup 
range given 	expand getenv 
sorted 	strlen getenv alternate 
score representing 	shallow file 
point another 	git work setup 
point center 	git env 
search radius 	setup git env 
appends entry 	starts git 
geo 	real path strcmp 
point specified 	die xstrdup 
geo point 	real path setup 
within search 	git env 
area returns 	snprintf directory git 
point included 	mkstemp mode 
reids 	snprintf directory safe 
err outside 	create leading 
decode note 	directories xmkstemp mode 
geohash distance 	snprintf directory 
radius wgs 	sha hex open 
takes 	safe create 
arguments reverse 	leading directories 
order longitude 	open setup git 
first latitude 	env setup 
later append 	git env setenv 
element query 	error setup 
redis 	git env commit 
sorted extract 	output encoding 
elements min 	put git config 
max appending 	variables file 
geo point 	programs link config 
structures gparray 	parser without 
command 	link rest git 
returns number 	particular need 
elements added 	bring libz etc 
elements farest 	unless needed 
radius specified 	even might want 
coordinates included 	know git 
ability 	directory etc unspecified 
function append 	unspecified see 
existing points 	probe utf 
important good 	pathname composition character 
performances querying 	begins commented 
radius performed 	line user editable 
multiple 	file subject 
queries sorted 	stripspace parallel index 
later need 	stat data 
sort via 	preload hack test 
qsort similarly 	programs like 
need able 	test dump untracked 
reject 	cache ensure 
points outside 	modify untracked cache 
search radius 	reading use 
area asap 	otherwise setup git 
order allocate 	dir gently 
process points 	git config repository 
needed 	local git 
minex include 	environment variables see 
min range 	cache details 
maxex exclude 	core bare 
max range 	see work note 
min val 	works used 
max 	work added primarily 
nothing exists 	support git 
starting min 	clone work repository 
results fell 	created meant 
range know 	flip different work 
element exists 	trees umask 
ziplist 	job restrictive write 
always succeed 	permission slow 
nothing exists 	path mkstemp implementations 
starting min 	erase failure 
results abort 	slow path ewah 
node longer 	bitmapc self 
range 	size rlw offset 
compute sorted 	self self 
scores min 	self number 
inclusive max 	added runlen self 
exclusive query 	number self 
order retrieve 	data current num 
elements 	self buffer 
inside specified 	number negate literals 
area hash 	self run 
two scores 	len self word 
returned reference 	self dist 
min max 	self callback payload 
want 	pos pointer 
compute sorted 	word len self 
scores include 	self self 
elements inside 	word next parent 
specified geohash 	self pointer 
hash many 	word literals ewah 
bits 	ewah rlw 
specified hash 	rlw literals prey 
step step 	predator index 
example hash 	negate words 
binary since 	ewah ewah rlw 
score bits 	rlw literals 
want 	prey predator index 
every element 	ewah ewah 
binary min 	rlw rlw literals 
score use 	prey predator 
initial hash 	index negate words 
left shifted 	ewah ewah 
enough 	rlw rlw literals 
bit later 	prey predator 
increment bit 	index bitmap pool 
prefis see 	bitmap pool 
hash bits 	size self self 
statement prefix 	crc size 
align 	realloc buffer grow 
bits maximum 	buffer push 
excluded search 	rlw run bit 
everything two 	rlw size 
following scores 	rlw run 
represented binary 	bit rlw words 
included 	rlw run 
excluded obtain 	bit buffer push 
members min 	rlw rlw 
max geohash 	run bit rlw 
bounding box 	running len 
populate geo 	min size rlw 
geo 	running len 
points calling 	buffer push rlw 
geo points 	rlw run 
range number 	bit rlw running 
points added 	len buffer 
search eight 	push rlw rlw 
neighbors 	run bit 
self geohash 	rlw running len 
box neighbor 	empty words 
hashbox matching 	rlw words buffer 
members potential 	push rlw 
result list 	rlw words 
huge 	buffer push rlw 
radius range 	words rlw 
used adjacent 	words buffer push 
neighbors leading 	rlw words 
duplicated elements 	min size rlw 
skip every 	words buffer 
range 	grow memcpy buffer 
one processed 	push rlw 
previously sort 	rlw words rlw 
comparators qsort 	running len 
adist bdist 	rlw run bit 
doubles comparator 	rlw run 
returns 	bit rlw run 
commands geoadd 	bit rlw 
key lat 	running len rlw 
name lat 	running len 
name lat 	buffer push 
name check 	rlw rlw running 
arguments 	len rlw 
number sanity 	run bit rlw 
need odd 	words rlw 
number arguments 	run bit rlw 
got far 	run bit 
zadd key 	rlw running len 
score 	rlw running 
ele key 	len rlw words 
create argument 	empty word 
vector call 	eword empty word 
zadd order 	empty words 
score pairs 	rlw words rlw 
requested 	running len 
zset score 	rlw running len 
actually encoded 	eword rlw 
version lat 	words rlw words 
turn coordinates 	empty word 
score element 	rlw run 
call 	bit rlw running 
zadd work 	len callback 
georadius key 	rlw running len 
radius unit 	rlw words 
withdist withhash 	callback xmalloc alloc 
withcoord asc 	ewah clear 
desc 	free free rlw 
count count 	running len 
store key 	rlw words rlw 
storedist key 	run bit 
georadiusbymember key 	eword read rlw 
member radius 	read rlw 
unit 	rlw xor run 
options store 	bit rlw 
storedist look 	words rlwit init 
requested zset 	rlwit init 
find lat 	rlwit word size 
use radius 	rlwit word 
search 	size rlwit 
inquiry type 	discharge ewah empty 
extract radius 	words rlwit 
units arguments 	discard first words 
discover populate 	min size 
optional parameters 	ewah rlwit discard 
trap 	first words 
options compatible 	rlwit discard first 
store storedist 	words rlwit 
count without 	word size rlwit 
ordering make 	discharge rlwit 
much sense 	discharge max size 
force 	rlwit init 
asc ordering 	rlwit init rlwit 
count specified 	word size 
sorting requested 	rlwit word size 
neighbor geohash 	ewah empty 
boxes radius 	words rlwit discard 
search 	first words 
search zset 	rlwit discard 
matching points 	first words rlwit 
matching results 	discharge ewah 
user gets 	empty words rlwit 
empty reply 	discard first 
process 	words min size 
optional requested 	ewah rlwit 
sorting target 	discard first words 
key results 	rlwit discard 
user options 	first words rlwit 
self contained 	word size 
nested 	rlwit discharge empty 
multibulk replies 	rlwit discharge 
need track 	empty max size 
many nested 	rlwit init 
replies multibulk 	rlwit init rlwit 
len send 	word size 
exactly 	rlwit word size 
result length 	ewah empty 
result either 	words rlwit 
zset members 	discard first words 
nested multi 	rlwit discard 
bulk reply 	first words rlwit 
containing 	discharge ewah 
zset member 	empty words rlwit 
additional options 	discard first 
user enabled 	words min size 
request send 	ewah rlwit 
results back 	discard first words 
caller 	rlwit discard 
fix according 	first words rlwit 
unit options 	word size 
option length 	rlwit discharge rlwit 
sub result 	discharge empty 
nested multi 	max size rlwit 
bulk 	init rlwit 
account result 	init rlwit 
target key 	word size rlwit 
create sorted 	word size 
results fix 	ewah empty words 
according unit 	rlwit discard 
refcount 	first words rlwit 
since reference 	discard first 
skiplist dict 	words rlwit discharge 
georadius wrapper 	ewah empty 
function georadiusbymember 	words rlwit discard 
wrapper function 	first words 
geohash 	min size ewah 
key ele 	rlwit discard 
ele ele 	first words rlwit 
returns characters 	discard first 
geohash representation 	words rlwit word 
position specified 	size rlwit 
elements 	discharge rlwit discharge 
look requested 	max size 
zset geohash 	ewah ewah 
elements one 	free ewah clear 
bulk reply 	copyright git 
missing elements 	hub inc copyright 
format 	daniel lemire 
use geocoding 	cliff moon david 
bit different 	intosh robert 
standard since 	becho google inc 
use initial 	veronika zenz 
latitude range 	program free software 
normal 	redistribute modify 
geohashing algorithm 	terms gnu general 
uses decode 	license published 
position encode 	free software foundation 
standard ranges 	either version 
order output 	license option later 
valid 	version program 
geohash decode 	distributed hope useful 
encode geopos 	without warranty 
key ele 	without even 
ele ele 	implied warranty merchantability 
returns two 	fitness particular 
items 	purpose see gnu 
arrays representing 	general license 
position element 	details received copy 
specified arguments 	gnu general 
missing elements 	license along program 
returned look 	write free 
requested 	software foundation inc 
zset report 	franklin street 
elements one 	fifth floor boston 
bulk reply 	usa sanity 
missing elements 	check check completed 
decode geodist 	stream todo 
key 	zero count optimization 
ele ele 	ewah ioc 
unit distance 	self write write 
meters otherwise 	self write 
accordig unit 	fun data 
points ele 	dump words per 
ele 	dump bitsize 
one elements 	word count rlw 
missing returned 	pos buffer 
check unit 	words left buf 
extract otherwise 	len self 
meters look 	user data data 
requested 	len self 
zset scores 	self map len 
need otherwise 	ptr self 
returned decode 	dump words per 
compute distance 	dump bitsize 
geo.h structures 	word count rlw 
used 	pos buffer 
inside geo 	words left write 
order represent 	write write 
points points 	write htonl 
earth geohash.c 	write fun htonl 
xlo ylo 	write fun 
interleaved 	htonll write fun 
range lat 	htonll write 
range range 	fun htonl write 
lat range 	fun write 
longitude latitude 	ewah serialize strbuf 
step hash 	ewah serialize 
lat 	realloc memcpy ntohll 
offset offset 	ewah clear 
longitude latitude 	read ntohl read 
step hash 	ntohl realloc 
longitude latitude 	read ntohll read 
step hash 	ntohll read 
range 	ntohl copyright git 
lat range 	hub inc 
hash area 	copyright daniel lemire 
step hash 	cliff moon 
sep lat 	david intosh 
scale scale 	robert becho google 
ilato 	inc veronika 
ilono hash 	zenz program free 
area hash 	software redistribute 
area area 	modify terms gnu 
hash area 	general license 
hash hash 	published free software 
hash 	foundation either 
hash neighbors 	version license option 
rangepiszero rangepiszero 	later version 
interleave geohash 	program distributed hope 
coord range 	useful without 
geohash encode 	warranty without even 
geohash 	implied warranty 
encode type 	merchantability fitness particular 
hashiszero rangeiszero 	purpose see 
rangeiszero deinterleave 	gnu general license 
geohash coord 	details received 
range geohash 	copy gnu 
decode 	general license along 
geohash decode 	program write 
type geohash 	free software foundation 
decode type 	inc franklin 
geohash decode 	street fifth floor 
area lat 	boston usa 
geohash 	bit bit size 
decode lat 	map bit 
type geohash 	number compressed bit 
move geohash 	words bit 
move geohash 	position rlw bit 
move geohash 	bit size 
move 	map bit number 
geohash move 	compressed bit 
geohash move 	words bit compressed 
geohash move 	words bit 
geohash move 	position rlw copy 
geohash move 	raw data 
geohash 	bitmap whole 
move geohash 	chunk little endian 
move geohash 	platform perform 
move geohash 	endianness conversion separate 
move geohash 	pass ensure 
move geohash 	loading aligned words 
move 	bit bit 
geohash move 	size map bit 
copyright yinqiwen 	number compressed 
yinqiwen gmail 	bit words bit 
copyright matt 	compressed words 
stancliff matt 	bit position rlw 
genges 	ewah rlwc 
copyright salvatore 	ewah discard max 
sanfilippo antirez 	negate index 
gmail rights 	rlw words rlw 
reserved redistribution 	words rlw 
use source 	running len 
binary 	rlw run bit 
forms without 	next word 
modification permitted 	rlwit words rlwit 
provided following 	word size 
conditions met 	next word rlwit 
redistributions source 	words rlwit 
code 	word size ewah 
must retain 	empty words 
copyright notice 	ewah dirty words 
list conditions 	rlwit discard 
following disclaimer 	first words rlwit 
redistributions binary 	word size 
form 	ewah empty words 
must reproduce 	rlwit word 
copyright notice 	size rlwit discard 
list conditions 	first words 
following disclaimer 	rlwit word size 
documentation materials 	copyright git 
provided 	hub inc 
distribution neither 	copyright daniel lemire 
name redis 	cliff moon 
names contributors 	david intosh robert 
may used 	becho google 
endorse promote 	inc veronika zenz 
products 	program free 
derived software 	software redistribute modify 
without specific 	terms gnu 
prior written 	general license published 
permission software 	free software 
provided copyright 	foundation either version 
holders 	license option 
contributors express 	later version program 
implied warranties 	distributed hope 
including limited 	useful without warranty 
implied warranties 	without even 
merchantability fitness 	implied warranty merchantability 
particular 	fitness particular 
purpose disclaimed 	purpose see 
shall copyright 	gnu general license 
owner contributors 	details received 
liable direct 	copy gnu general 
indirect incidental 	license along 
special 	program write free 
exemplary consequential 	software foundation 
damages including 	inc franklin street 
limited procurement 	fifth floor 
substitute goods 	boston usa ewok.h 
services loss 	buffer buffer 
use 	size alloc size 
data profits 	bit size 
business interruption 	rlw self self 
however caused 	self self 
theory liability 	write fun self 
whether contract 	self self 
strict 	strbuf self self 
liability tort 	map len 
including negligence 	self self 
otherwise arising 	self callback payload 
way use 	self buffer 
software even 	buffer size pointer 
advised 	compressed literals 
possibility damage 	parent next ewah 
hashing works 	ewah ewah 
like divide 	ewah ewah ewah 
world buckets 	ewah ewah 
label 	self number self 
one interleave 	buffer number 
lower bits 	negate self word 
bits even 	words word 
positions bits 	alloc self pos 
odd must 	self pos 
initially 	self pos self 
less https 	self self 
graphics stanford 	self bitmap ewah 
edu seander 	self self 
bithacks html 	self self 
interleave bmn 	callback data self 
reverse 	copyright git 
interleave process 	hub inc copyright 
derived http 	daniel lemire 
stackoverflow questions 	cliff moon david 
constraints epsg 	intosh robert 
epsg osgeo 	becho google inc 
geocode 	veronika zenz 
north south 	program free software 
pole check 	redistribute modify 
basic arguments 	terms gnu general 
sanity error 	license published 
trying index 	free software foundation 
outside 	either version 
supported constraints 	license option later 
convert point 	version program 
step size 	distributed hope 
hash lat 	useful without warranty 
lat part 	without even 
deinterleaved 	implied warranty merchantability 
hash shift 	fitness particular 
part hash 	purpose see gnu 
divide step 	general license 
coordinate multiply 	details received copy 
times scale 	gnu general 
min 	license along program 
absolute coordinate 	write free 
geohash.h range 	software foundation inc 
lat range 	franklin street 
range lat 	fifth floor boston 
range longitude 	usa use 
latitude 	builtin popcountll gcc 
step hash 	implementation notoriously 
longitude latitude 	slow platforms see 
step hash 	http gcc 
longitude latitude 	gnu bugzilla 
step hash 	show bug cgi 
range 	builtin ctzll 
lat range 	available allocate ewah 
hash area 	compressed bitmap 
hash area 	clear bits bitmap 
hash area 	free resize 
area hash 	memory free memory 
hash 	bitmap logical 
hash hash 	bitwise negation place 
neighbors copyright 	bitmap operation 
yinqiwen yinqiwen 	linear time size 
gmail copyright 	bitmap call 
matt stancliff 	given callback position 
matt 	every single 
genges copyright 	bit bitmap efficient 
salvatore sanfilippo 	operation fully 
antirez gmail 	decompress bitmap given 
rights reserved 	bit bitmap 
redistribution use 	bit position 
source 	pos way bitmap 
binary forms 	compressed bit 
without modification 	cannot unset later 
permitted provided 	furthermore since 
following conditions 	bitmap uses streaming 
met redistributions 	compression bits 
source 	incrementally ewah bitmap 
code must 	ewah bitmap 
retain copyright 	ewah bitmap ewah 
notice list 	bitmap ewah 
conditions following 	bitmap failed raised 
disclaimer redistributions 	initialize iterator 
binary 	run bitmap uncompressed 
form must 	form iterator 
reproduce copyright 	stack allocated underlying 
notice list 	bitmap must 
conditions following 	freed iteration ewah 
disclaimer documentation 	bitmap bitmap 
materials 	ewah ewah 
provided distribution 	iterator ewah iterator 
neither name 	init bitmap 
redis names 	every single word 
contributors may 	bitmap uncompressed 
used endorse 	form single words 
promote 	bits bit 
products derived 	represents actual bit 
software without 	bitmap word 
specific prior 	words left direct 
written permission 	word access 
software provided 	uncompressed old school 
copyright 	bitmap efficiently 
holders contributors 	compressed ewah bitmap 
express implied 	ewok rlwh 
warranties including 	word word word 
limited implied 	word word 
warranties merchantability 	word word 
fitness 	self buffer size 
particular purpose 	pointer word 
disclaimed shall 	start word words 
copyright owner 	running len 
contributors liable 	word offset running 
direct indirect 	bit bitmap 
incidental 	max negate eword 
special exemplary 	eword rlw 
consequential damages 	running len rlw 
including limited 	words copyright 
procurement substitute 	git hub inc 
goods services 	copyright daniel 
loss 	lemire cliff moon 
use data 	david intosh 
profits business 	robert becho google 
interruption however 	inc veronika 
caused theory 	zenz program free 
liability whether 	software redistribute 
contract 	modify terms 
strict liability 	gnu general license 
tort including 	published free 
negligence otherwise 	software foundation either 
arising way 	version license 
use software 	option later version 
even 	program distributed 
advised possibility 	hope useful without 
damage bits 	warranty without 
limits epsg 	even implied warranty 
epsg osgeo 	merchantability fitness 
success failed 	particular purpose see 
geohash 	gnu general 
geohash helperc 	license details received 
deg rad 	copy gnu 
earth radius 	general license along 
meters mercator 	program write 
max mercator 	free software foundation 
min 	inc franklin 
ang ang 	street fifth 
range meters 	floor boston usa 
lat step 	exec cmdc 
longitude latitude 	argv exec path 
radius meters 	argv path 
bounds 	path prefix prefix 
lonr latr 	argv slash 
distance min 	exec path env 
latitude max 	path old 
latitude min 	path path argv 
longitude max 	argv nargv 
longitude 	cmd argc argv 
difference longitude 	arg param 
longitude latitude 	absolute path xstrdup 
radius meters 	absolute path 
range lat 	strip path suffix 
range radius 	strip path 
hash 	suffix strip path 
neighbors area 	suffix trace 
min lon 	strbuf addf 
max lon 	strbuf detach find 
min lat 	last dir 
max lat 	sep xstrndup setenv 
bounds 	getenv system 
steps longitude 	path strbuf absolute 
latitude radius 	path strbuf 
meters hash 	addch getenv path 
bits lon 	git exec 
lat lon 	path strbuf addstr 
lat 	strbuf addstr 
lat lon 	setenv strbuf release 
lat lon 	argv push 
radius distance 	argv pushv prepare 
radius distance 	git cmd 
deg rad 	trace argv sane 
deg 	execvp trace 
rad asin 	strerror argv clear 
sin cos 	start arg 
rad deg 	end error 
rad deg 	execv git cmd 
rad deg 	propagate setting 
rad 	external programs returns 
deg geohash 	highest priority 
bounding box 	location look git 
geohash estimate 	programs execvp 
steps radius 	ever fails exec 
geohash coord 	cmdh exec 
range 	path path argv 
geohash encode 	argv cmd 
geohash neighbors 	path terminated git 
geohash coord 	exec cmd 
range geohash 	fast-export.c fast export 
decode gzero 	usage progress 
gzero 	fake missing tagger 
gzero gzero 	use done 
gzero gzero 	feature data 
gzero gzero 	full extra refs 
gzero gzero 	refspecs refspecs 
gzero gzero 	anonymize opt arg 
geohash 	unset opt 
areas radius 	arg unset idnums 
deg rad 	last idnum 
deg rad 	commit parent hash 
deg rad 	orig orig 
deg rad 	len anon anon 
sin 	len data 
sin asin 	map generate orig 
sqrt cos 	len key 
cos geohash 	ret path map 
distance geohash 	generate end 
distance radius 	component len mark 
copyright 	mark mark 
yinqiwen yinqiwen 	decoration counter size 
gmail copyright 	counter sha 
matt stancliff 	size buf 
matt genges 	eaten name name 
copyright salvatore 	len len 
sanfilippo 	len cmp path 
antirez gmail 	need quote 
rights reserved 	path len counter 
redistribution use 	path paths 
source binary 	anon old len 
forms without 	counter sha 
modification 	sha len options 
permitted provided 	data ospec 
following conditions 	spec begin end 
met redistributions 	needle bol 
source code 	eol old len 
must retain 	counter refname 
copyright 	prefixes refs anon 
notice list 	old counter 
conditions following 	idents old len 
disclaimer redistributions 	counter beg 
binary form 	end buffers 
must reproduce 	buffer split end 
copyright 	header ident 
notice list 	len commit rev 
conditions following 	saved output 
disclaimer documentation 	format commit buffer 
materials provided 	author author 
distribution neither 	end committer committer 
name 	end encoding 
redis names 	message reencoded refname 
contributors may 	mark old 
used endorse 	len counter commits 
promote products 	revs commit 
derived software 	name tag size 
without 	buf tagger 
specific prior 	tagger end message 
written permission 	message size 
software provided 	tagged tagged mark 
copyright holders 	tags signature 
contributors express 	full name 
implied 	tag info sha 
warranties including 	commit full 
limited implied 	name commit name 
warranties merchantability 	file mark 
fitness particular 	deco input file 
purpose disclaimed 	line mark 
shall 	line end mark 
copyright owner 	end sha 
contributors liable 	commit refspec argc 
direct indirect 	argv prefix 
incidental special 	revs commits commit 
exemplary consequential 	filename lastimportid 
damages 	refspecs list options 
including limited 	refspecs str 
procurement substitute 	strcmp strcmp strcmp 
goods services 	strcmp strcmp 
loss use 	strcmp error 
data profits 	strcmp strcmp strcmp 
business 	error memcmp 
interruption however 	hashmap init hashmap 
caused theory 	entry init 
liability whether 	memhash hashmap xmalloc 
contract strict 	hashmap entry 
liability tort 	init xstrdup generate 
including 	hashmap put 
negligence otherwise 	strchrnul anonymize mem 
arising way 	strbuf strbuf 
use software 	addch decoration mark 
even advised 	ptr mark 
possibility damage 	lookup decoration ptr 
conversion 	mark strbuf 
ardb project 	addf strbuf detach 
file started 	sha lookup 
https github 	anonymize blob lookup 
yinqiwen ardb 	blob read 
blob src 	sha file 
geo 	die sha hex 
geohash helper 	check sha 
cpp brief 	signature die sha 
usual constant 	hex parse 
brief earth 	buffer die sha 
quatratic mean 	hex mark 
radius 	next fwrite die 
wgs must 	errno sha 
estimate steps 	hex show progress 
encoding decoding 	free strlen 
always decode 	strlen memcmp quote 
geo step 	style quote 
max 	style strchr strbuf 
make sure 	addf strbuf 
range included 	detach print path 
worst wider 	anonymize path 
range torwards 	print path strbuf 
poles note 	reset xcalloc 
possible 	put anonymize 
better approximation 	mem qsort print 
computing distance 	path putchar 
meridians latitude 	print path putchar 
trick frame 	print path 
valid range 	putchar hashcmp isgitlink 
step 	sha hex 
equal compare 	anonymize sha lookup 
step compare 	mark print 
bits note 	path putchar die 
lazy accounting 	memmem strlen 
coordinates near 	strlen strlen strchrnul 
poles 	strbuf addf 
calculate distance 	strbuf detach strcmp 
haversin great 	strbuf reset 
circle distance 	size skip prefix 
formula geohash 	strbuf addstr 
helperh range 	anonymize path xstrfmt 
meters 	strbuf addf 
lat longitude 	strbuf detach 
latitude radius 	size strbuf reset 
meters bounds 	strchr die 
longitude latitude 	strbuf split ident 
radius meters 	line anonymize 
longitude 	mem strbuf strbuf 
latitude radius 	addch strbuf 
meters longitude 	strbuf addstr parse 
latitude radius 	commit die 
meters hash 	commit buffer strstr 
lon lat 	die oid 
lon 	hex strchrnul strstr 
lat radius 	die oid 
distance radius 	hex strchrnul strstr 
distance copyright 	find encoding 
yinqiwen yinqiwen 	mark parse commit 
gmail copyright 	die diff 
matt 	sha diff 
stancliff matt 	root sha isgitlink 
genges copyright 	export blob 
salvatore sanfilippo 	anonymize refname anonymize 
antirez gmail 	ident line 
rights reserved 	anonymize ident line 
redistribution 	mark next 
use source 	anonymize commit message 
binary forms 	encoding utf 
without modification 	reencode strlen strlen 
permitted provided 	free unuse 
following conditions 	commit buffer mark 
met 	log diff 
redistributions source 	flush show progress 
code must 	strbuf addf 
retain copyright 	strbuf detach unshown 
notice list 	parent handle 
conditions following 	commit warning oid 
disclaimer 	hex read 
redistributions binary 	sha file 
form must 	die oid hex 
reproduce copyright 	memmem strlen 
notice list 	memmem strlen strchrnul 
conditions following 	anonymize ident 
disclaimer 	line anonymize refname 
documentation materials 	anonymize mem 
provided distribution 	strstr die oid 
neither name 	hex warning 
redis names 	oid hex warning 
contributors may 	oid hex 
used 	mark die oid 
endorse promote 	hex die 
products derived 	oid hex die 
software without 	oid hex 
specific prior 	mark starts parse 
written permission 	list append 
software 	die dwim strlen 
provided copyright 	apply refspecs 
holders contributors 	free commit 
express implied 	warning export blob 
warranties including 	warning list 
limited implied 	append handle tag 
warranties 	anonymize refname 
merchantability fitness 	mark show progress 
particular purpose 	fopen writing 
disclaimed shall 	die errno ptr 
copyright owner 	mark oid 
contributors liable 	hex ferror fclose 
direct 	error fopen 
indirect incidental 	die errno fgets 
special exemplary 	strchr die 
consequential damages 	strtoumax sha hex 
including limited 	die sha 
procurement substitute 	info die sha 
goods 	hex lookup 
services loss 	commit die sha 
use data 	hex error 
profits business 	sha hex 
interruption however 	mark fclose sha 
caused theory 	hex usage 
liability 	options git config 
whether contract 	init revisions 
strict liability 	parse options setup 
tort including 	revisions usage 
negligence otherwise 	options alloc parse 
arising way 	fetch refspec 
use 	list clear free 
software even 	marks tags 
advised possibility 	duplicates prepare revision 
damage geohash 	walk die 
helper hpp 	diff opt revision 
hash.c file 	unshown parent 
code 	handle commit handle 
part hasher 	tail handle 
https code 	tags duplicates handle 
google smhasher 	deletes export 
subject mit 	marks free 
license http 	refspec git fast 
www 	export builtin 
opensource licenses 	command copyright johannes 
mit license 	schindelin basically 
php email 	keep cache repeatedly 
addresses associated 	replace anonymized 
source code 	another actual generation 
revision 	farmed generate 
history belong 	function anonymize component 
austin appleby 	path individually 
revision history 	paths share common 
ranges therefore 	root paths 
copyright license 	cached via anonymize 
taken 	mem repeated 
copyright austin 	lookups since intptr 
appleby permission 	use ideally 
hereby granted 	would want 
free charge 	transformation blob data 
person 	unreversible would 
obtaining copy 	still size data 
software associated 	relationship blobs 
documentation files 	delta packing behavior 
software deal 	original first 
software without 	last requirements probably 
restriction 	mutually exclusive 
including without 	take easy way 
limitation rights 	generate arbitrary 
use copy 	content need cache 
modify merge 	result anonymize 
publish distribute 	mem since already 
sublicense 	handle blob 
sell copies 	content caching marks 
software permit 	strcmp sort 
persons software 	want move ename 
furnished subject 	entries last 
following conditions 	references file 
copyright 	appear output renamed 
notice permission 	file copied 
notice shall 	renamed commit avoid 
included copies 	sha handle 
substantial portions 	files directory first 
software software 	deleted directory 
provided 	changes file symlink 
without warranty 	fallthrough links 
kind express 	refer objects another 
implied including 	repositories output 
limited warranties 	sha verbatim prefixes 
merchantability fitness 	found intact 
particular 	tags remain tags 
purpose noninfringement 	forth also 
shall authors 	master special since 
copyright holders 	reveal anything 
liable claim 	interesting even bother 
damages liability 	cache commit 
whether 	messages unlikely 
action contract 	repeated verbatim interesting 
tort otherwise 	strategy anonymize 
arising connection 	names email addresses 
software use 	keep timestamps 
dealings software 	intact influence things 
hash 	like traversal 
keys form 	order revealing skip 
seed hash 	committer author 
result variant 	tagger etc export 
variant variant 	referenced blobs 
hashbytes key 	remember marks trees 
computed 	fast export 
expected reached 	output thus way 
reached hash 	output tags 
variant bits 	trees tags tags 
variable variable 	trees etc 
memset memset 	simply omit tags 
memset 	handle tags 
hash memcpy 	fallthru fallthru 
hash memcpy 	handle tag tagged 
hash memcpy 	filtered due 
reached hash 	paths specified ignore 
memcpy hash 	tag altogether 
memcpy 	handle nested tags 
hash memcpy 	obj tag 
reached reached 	nested tags already 
hash variant 	handled updated 
hash variant 	commit lets make 
verify hash 	sure gets 
variant 	properly updated eventually 
verify hash 	create refs 
variant verify 	pointing already seen 
test file 	commits commits 
code part 	handle encodings fast-import.c 
hasher https 	idx next 
code 	next pool 
google smhasher 	next free end 
subject mit 	entries marked 
license http 	sets shift data 
www opensource 	offset depth 
licenses mit 	next pool next 
license 	free end 
php email 	space next atom 
addresses associated 	str len 
source code 	str dat name 
revision history 	mode sha 
belong austin 	entry capacity entry 
appleby 	count delta 
revision history 	depth entries entry 
ranges therefore 	capacity next 
copyright license 	avail table next 
taken copyright 	branch active 
austin appleby 	next branch name 
permission 	branch last 
hereby granted 	commit num 
free charge 	notes sha next 
person obtaining 	tag name 
copy software 	pack sha next 
associated documentation 	sha prev 
files 	next buf max 
software deal 	depth max 
software without 	packsize force update 
restriction including 	pack compression 
without limitation 	level pack compression 
rights use 	seen alloc 
copy 	count marks count 
modify merge 	count type 
publish distribute 	duplicate count type 
sublicense sell 	delta count 
copies software 	type delta count 
permit persons 	attempts type 
software 	count branch count 
furnished subject 	branch load 
following conditions 	count failure 
copyright notice 	pack edges show 
permission notice 	stats argc 
shall included 	argv mem pool 
copies 	alloc total 
substantial portions 	allocd mem pool 
software software 	atom table 
provided without 	atom cnt atom 
warranty kind 	table pack 
express implied 	idx opts pack 
including 	pack file 
limited warranties 	pack data packs 
merchantability fitness 	pack size 
particular purpose 	entry alloc blocks 
noninfringement shall 	table marks 
authors copyright 	export marks file 
holders 	marks file 
liable claim 	marks file stream 
damages liability 	marks file 
whether action 	ignore missing 
contract tort 	relative marks paths 
otherwise arising 	last blob 
connection 	entry alloc avail 
software use 	entry avail 
dealings software 	table avail table 
hash keys 	old max 
form seed 	active branches cur 
hash result 	active branches 
hash.c 	branch table branch 
file code 	table active 
part hasher 	branches first tag 
https code 	last tag 
google smhasher 	whenspec command buf 
subject mit 	unread command 
license 	buf cmd hist 
http www 	cmd tail 
opensource licenses 	free cmd 
mit license 	save next mark 
php email 	data seen 
addresses associated 	data command require 
source 	termination checkpoint 
code revision 	requested cat blob 
history belong 	rpt mark 
austin appleby 	err loc rpt 
revision history 	err zombie 
ranges therefore 	message signo cnt 
copyright 	sha sha 
license taken 	sha len len 
copyright austin 	count size 
appleby permission 	len len idnum 
hereby granted 	idnum orig 
free charge 	idnum len name 
person 	name cnt 
obtaining copy 	cnt amt tmp 
software associated 	file hdr 
documentation files 	pack tmpfile 
software deal 	idx last curr 
software without 	index name 
restriction 	name keep msg 
including without 	keep name 
limitation rights 	running cur pack 
use copy 	sha idx 
modify merge 	name store checkpoint 
publish distribute 	len sha 
sublicense 	mark buf buf 
sell copies 	sha hdrlen 
software permit 	offset checkpoint status 
persons software 	cnt sizep 
furnished subject 	str modep mode 
following conditions 	root sha 
copyright 	myoe size buf 
notice permission 	maxlen root 
notice shall 	del root sha 
included copies 	mode newtree 
substantial portions 	root sha 
software software 	mode subtree slash 
provided 	root backup 
without warranty 	leaf allow root 
kind express 	slash root 
implied including 	leaf allow root 
limited warranties 	slash msg 
merchantability fitness 	transaction old sha 
particular 	err old 
purpose noninfringement 	cmit cmit msg 
shall authors 	name err 
copyright holders 	transaction mark saved 
liable claim 	errno line 
damages liability 	mark end sha 
whether 	stdin eof 
action contract 	term limit len 
tort otherwise 	res data 
arising connection 	term term len 
software use 	len length 
dealings software 	src result 
hash 	orig src endp 
keys form 	num buf 
seed hash 	ltgt name len 
result variant 	ident last 
variant variant 	sha mark buf 
hashbytes key 	len min 
computed 	commit num notes 
expected reached 	fanout hex 
reached hash 	sha fanout path 
variant bits 	orig root 
variable variable 	root hex sha 
memset memset 	hex sha 
memset 	len fullpath fullpath 
hash memcpy 	len fanout 
hash memcpy 	leaf tmp hex 
hash memcpy 	sha len 
reached hash 	tmp fullpath len 
memcpy hash 	num notes 
memcpy 	sha realpath 
hash memcpy 	root fanout hex 
reached reached 	sha path 
hash variant 	endptr mark end 
hash variant 	mark mark 
verify hash 	end endp sha 
variant 	mode data 
verify hash 	endp rename endp 
variant verify 	leaf old 
test file 	fanout sha commit 
code part 	sha path 
hasher https 	data fanout commit 
code 	mark commit 
google smhasher 	size buf buf 
subject mit 	size size 
license http 	buf sha idnum 
www opensource 	size buf 
licenses mit 	count idnum 
license 	size buf arg 
php email 	msg author 
addresses associated 	committer merge list 
source code 	merge count 
revision history 	prev fanout fanout 
belong austin 	next arg 
appleby 	msg tagger mark 
revision history 	sha arg 
ranges therefore 	buf size sha 
copyright license 	line size 
taken copyright 	buf output sha 
austin appleby 	sha size 
permission 	buf sha mode 
hereby granted 	sha path 
free charge 	line type root 
person obtaining 	leaf endp 
copy software 	path marks stream 
associated documentation 	ignore missing 
files 	fmt option 
software deal 	arg endptr depth 
software without 	branches marks 
restriction including 	edges option feature 
without limitation 	stream arg 
rights use 	feature option indexversion 
copy 	packsizelimit fast 
modify merge 	usage argc argv 
publish distribute 	duplicate count 
sublicense sell 	fputs fputs sha 
copies software 	fputs fputc 
permit persons 	sha hex sha 
software 	hex sha 
furnished subject 	hex fputs fputc 
following conditions 	fputc git 
copyright notice 	pathdup getpid fopen 
permission notice 	error strerror 
shall included 	free getpid getppid 
copies 	show date 
substantial portions 	time date 
software software 	mode fputc fputs 
provided without 	fputs fputc 
warranty kind 	fputc fputs fputs 
express implied 	fputs fputs 
including 	fputs fputc fputc 
limited warranties 	fputs fputs 
merchantability fitness 	fputc fputs fputs 
particular purpose 	fputc fputs 
noninfringement shall 	fputs write branch 
authors copyright 	report fputc 
holders 	fputs fputs fputs 
liable claim 	sha hex 
damages liability 	fputc fputs fputc 
whether action 	fputc fputs 
contract tort 	fputs dump marks 
otherwise arising 	helper fputc 
connection 	fputs fputs fclose 
software use 	free vsnprintf 
dealings software 	fputs fputs 
hash keys 	fputc write crash 
form seed 	report end 
hash result 	packfile unkeep packs 
hash.h 	dump marks 
key len 	exit memset sigemptyset 
seed key 	sigaction xmalloc 
len seed 	alloc objects hashcpy 
key len 	hashcmp hashcmp 
seed key 	xmalloc xmalloc pool 
len 	alloc memset 
seed hash 	strlen pool alloc 
key len 	memcpy pool 
seed data 	calloc pool calloc 
nblocks blocks 	die str 
tail key 	strncmp pool alloc 
len 	memcpy str 
seed data 	strlen strcmp 
nblocks blocks 	str strlen lookup 
tail key 	branch die 
len seed 	check refname format 
data nblocks 	die pool 
blocks 	calloc pool strdup 
tail key 	entries pool 
len seed 	alloc entries release 
hash hashes 	entry release 
kqu kqu 	content content memcpy 
hash block 	release content 
hash 	alloc release content 
rotl hash 	recursive content 
rotl hash 	entry memcpy sha 
rotl hash 	dup content 
fmix hash 	odb mkstemp flex 
block hash 	alloc str 
block 	sha htonl htonl 
hash block 	sha write 
hash block 	realloc alloc 
hash rotl 	die write idx 
hash rotl 	file free 
hash rotl 	odb pack keep 
hash 	die errno 
rotl hash 	write die strlen 
rotl hash 	close die 
rotl hash 	errno snprintf directory 
rotl hash 	sha hex 
rotl hash 	finalize file die 
rotl 	snprintf directory 
hash rotl 	sha hex finalize 
hash rotl 	file die 
hash rotl 	free snprintf directory 
hash fmix 	sha hex 
hash fmix 	unlink warn clear 
hash 	delta cache 
fmix hash 	close pack windows 
fmix kqu 	sha close 
kqu hash 	fixup pack 
block hash 	header footer close 
block hash 	keep pack 
rotl 	create index packed 
hash rotl 	git strlen 
hash rotl 	die install packed 
hash rotl 	git sha 
hash rotl 	hex sha hex 
hash rotl 	fputc fflush 
hash 	close unlink warn 
fmix hash 	free strbuf 
fmix hash 	release end packfile 
hash following 	start packfile 
hash function 	sha file truncate 
murmur hash 	die errno 
placed 	xmalloc xmalloc cycle 
domain austin 	packfile sha 
appleby see 	file checkpoint snprintf 
http code 	die git 
google smhasher 	sha init 
details jemalloc 	git sha update 
types 	crc begin 
jemalloc structs 	git deflate init 
jemalloc externs 	encode pack 
implementation body 	header die fread 
tail finalization 	feof die 
body tail 	git sha update 
finalization 	git deflate 
body tail 	sha write die 
finalization api 	git deflate 
jemalloc inlines 	end git sha 
help.h command 	hashcpy insert 
groups name 	insert mark truncate 
summary 	pack find 
since automatically 	sha pack truncate 
generated generate 	pack crc 
command help 	end free 
edit hiredis.c 	free close pack 
type task 	windows sha 
str 	flush unpack entry 
len task 	content sha 
elements task 	find die sha 
task functions 	hex gfi 
type reply 	unpack entry die 
task str 	sha hex 
len 	read sha file 
parent buf 	die sha 
task elements 	hex entry grow 
parent task 	content mode 
parent task 	die sha hex 
parent type 	atom strlen 
str 	hashcpy hashcpy free 
len buf 	name compare 
size len 	name compare qsort 
cbuf sbuf 	qsort strbuf 
bytes len 	reset strbuf 
pos len 	grow strbuf addf 
dec 	strbuf sha 
mult len 	load store find 
len cur 	isdir mktree 
prv cur 	mktree store hashcpy 
obj len 	release entry 
cur obj 	isdir die hashclr 
len 	hashcpy release 
bytelen success 	content recursive strchrnul 
cur obj 	die isdir 
elements root 	die load strncmp 
cur buf 	icase isdir 
len newbuf 	hashcmp hashcpy release 
reply 	content recursive 
len len 	isdir hashclr isdir 
target format 	content load 
cmd pos 	content hashclr grow 
curarg newarg 	content entry 
touched newargv 	atom hashclr 
argc 	content content hashcpy 
totlen arg 	hashclr strchrnul 
size intfmts 	load strncmp icase 
format cpy 	isdir isdir 
target format 	load content hashclr 
len 	memcpy release 
target argc 	content recursive hashclr 
argv argvlen 	hashclr strchrnul 
cmd pos 	die load strncmp 
len totlen 	icase isdir 
type str 	load content memcpy 
len 	sha dup 
port port 	content sha read 
port port 	hashclr sha 
source addr 	lookup commit reference 
path path 	gently lookup 
path buf 	commit reference gently 
nread 	error merge 
done nwritten 	bases warning 
reply reply 	sha hex sha 
wdone aux 	hex transaction 
cmd len 	begin transaction update 
newbuf cmd 	transaction commit 
len 	transaction free error 
format cmd 	strbuf release 
len format 	transaction free strbuf 
ret argc 	release update 
argv argvlen 	branch transaction begin 
cmd len 	error strbuf 
reply 	reset strbuf addf 
format format 	transaction update 
reply argc 	error transaction commit 
argv argvlen 	error transaction 
calloc free 	free strbuf release 
reply free 	strbuf release 
free 	dump marks helper 
free create 	sha hex 
reply malloc 	hold file 
free reply 	update error strerror 
memcpy create 	fdopen file 
reply calloc 	rollback file error 
free 	strerror dump 
reply create 	marks helper commit 
reply create 	file error 
reply free 	strerror fopen die 
sdsfree strlen 	errno fgets 
memcpy snprintf 	strchr die strtoumax 
snprintf 	sha hex 
snprintf snprintf 	die find die 
snprintf snprintf 	sha hex 
isprint snprintf 	insert insert mark 
snprintf chrtos 	fclose strbuf 
snprintf redis 	detach strbuf getline 
reader 	starts starts 
error redis 	parse argv 
reader error 	free skip prefix 
seek newline 	parse mark 
read line 	skip prefix parse 
create integer 	cat blob 
read 	fgetc ungetc skip 
create redis 	prefix strtoumax 
reader error 	read next command 
oom move 	strbuf reset 
next task 	skip prefix die 
seek newline 	skip prefix 
read 	xstrdup strbuf detach 
create nil 	strbuf getline 
create redis 	die strcmp strbuf 
reader error 	addbuf strbuf 
oom move 	addch free strtoumax 
next task 	die strbuf 
redis 	fread feof die 
reader error 	skip optional 
read line 	strtoul strtoul 
read create 	strbuf addstr strcspn 
nil redis 	die die 
reader error 	strcspn die die 
oom 	strbuf validate 
move next 	raw date die 
task create 	parse date 
redis reader 	die strcmp die 
error oom 	datestamp strbuf 
move next 	detach parse data 
task 	store strbuf 
read bytes 	release stream blob 
redis reader 	skip optional 
error protocol 	read next command 
process line 	parse mark 
item process 	parse store blob 
bulk 	release content 
item process 	recursive load die 
multi bulk 	memcpy memcpy 
item calloc 	memcpy sha 
sdsempty free 	hex construct path 
free sdsfree 	fanout strcmp 
free 	content die content 
sdsavail sdsfree 	isdir load 
sdsempty sdscatlen 	change note fanout 
redis reader 	change note 
error oom 	fanout strtoumax die 
sdslen process 	parse mark 
item 	die parse mark 
sdsrange sdslen 	die mode 
intlen sdsempty 	die die find 
realloc bulklen 	mark parse 
sdslen sdsempty 	mark space hashcpy 
sdscatlen arg 	skip prefix 
strlen 	sha hex die 
sdscatlen arg 	find die 
arg sdscatlen 	strbuf reset unquote 
sdscat isdigit 	style die 
isdigit copy 	isdir hashcmp 
strchr arg 	content isgitlink die 
strchr 	die isdir 
arg strchr 	die strbuf addstr 
arg strchr 	read next 
arg strchr 	command parse store 
strchr arg 	blob die 
end memcpy 	isdir die content 
sdscatvprintf 	replace content 
end realloc 	strbuf reset unquote 
bulklen sdslen 	style die 
sdsfree intlen 	content strbuf reset 
malloc sprintf 	unquote style 
sprintf sdslen 	die strchr die 
memcpy 	strbuf die 
sdslen sdslen 	strbuf reset unquote 
sdsfree free 	style die 
sdsfree free 	memset content 
sdsfree free 	content die content 
start redisv 	replace content 
format 	change note fanout 
command end 	convert num 
intlen strlen 	notes fanout find 
bulklen malloc 	mark parse 
sprintf strlen 	mark space hashcpy 
sprintf memcpy 	skip prefix 
strlen 	sha hex die 
memcpy strerror 	find die 
calloc sdsempty 	lookup branch sha 
redis reader 	die hashcpy 
create close 	parse mark eol 
sdsfree redis 	find mark 
reader 	die hashcpy sha 
free free 	read reference 
redis free 	die free die 
redis context 	strbuf addstr 
init redis 	read next 
context connect 	command parse store 
tcp 	blob die 
redis context 	sha die die 
init redis 	construct path 
context connect 	fanout sha hex 
tcp redis 	content sha 
context init 	convert num notes 
redis 	fanout construct 
context connect 	path fanout sha 
tcp redis 	hex content 
context init 	release content recursive 
redis context 	hashclr hashclr 
connect bind 	load die sha 
tcp 	hex memcmp 
redis context 	sha hex die 
init redis 	sha hex 
context connect 	hashcpy sha hashclr 
unix redis 	hashclr read 
context init 	reference parse 
redis 	commit free skip 
context connect 	prefix hashcpy 
unix redis 	lookup branch die 
context init 	hashcpy hashcpy 
redis context 	hashcpy parse mark 
connect unix 	eol find 
redis 	mark die hashcmp 
context init 	hashcpy gfi 
redis context 	unpack entry parse 
timeout redis 	commit free 
keep alive 	parse existing sha 
read redis 	parse existing 
error 	sha die hashcmp 
redis error 	release content 
redis reader 	recursive read next 
feed redis 	command skip 
error sdslen 	prefix xmalloc lookup 
write sdslen 	branch hashcpy 
redis 	parse mark 
error sdslen 	eol find mark 
sdsfree sdsempty 	die hashcpy 
sdsrange sdslen 	sha read reference 
redis reader 	die free 
reply redis 	die read next 
error 	command lookup 
redis reply 	branch branch read 
reader redis 	next command 
buffer write 	parse mark skip 
redis buffer 	prefix parse 
read redis 	ident read next 
reply 	command skip 
reader sdscatlen 	prefix parse ident 
redis error 	read next 
redis append 	command die parse 
command redisv 	data read 
format command 	next command 
redis 	parse parse merge 
error redis 	unload one 
append command 	branch load branch 
free free 	convert num 
start redisv 	notes fanout skip 
append command 	prefix file 
end 	change skip prefix 
redis format 	file change 
command argv 	skip prefix file 
redis error 	change skip 
redis append 	prefix file change 
command free 	skip prefix 
free 	note change strcmp 
redis reply 	file change 
redisv append 	deleteall skip prefix 
command redis 	parse read 
block reply 	next command convert 
start redisv 	num notes 
command 	fanout change 
end redis 	note fanout store 
append command 	hashcpy strbuf 
argv redis 	reset strbuf addf 
block reply 	sha hex 
copyright salvatore 	sha strbuf addf 
sanfilippo 	sha hex 
antirez gmail 	strbuf addf sha 
dot copyright 	hex free 
pieter noordhuis 	strbuf addf strbuf 
pcnoordhuis gmail 	addbuf free 
dot rights 	free store pool 
reserved 	alloc memset 
redistribution use 	pool strdup read 
source binary 	next command 
forms without 	skip prefix die 
modification permitted 	lookup branch 
provided following 	sha die hashcpy 
conditions 	parse mark 
met redistributions 	eol find 
source code 	mark hashcpy sha 
must retain 	find sha 
copyright notice 	info die die 
list conditions 	read next 
following 	command skip prefix 
disclaimer redistributions 	parse ident 
binary form 	read next command 
must reproduce 	parse data 
copyright notice 	strbuf reset strbuf 
list conditions 	addf sha 
following 	hex strbuf addf 
disclaimer documentation 	strbuf addch 
materials provided 	strbuf addbuf free 
distribution neither 	store lookup 
name redis 	branch hashclr hashclr 
names contributors 	hashclr release 
may 	content recursive branch 
used endorse 	read next 
promote products 	command parse 
derived software 	write full die 
without specific 	errno read 
prior written 	sha file gfi 
permission 	unpack entry 
software provided 	strbuf reset strbuf 
copyright holders 	addf sha 
contributors express 	hex cat blob 
implied warranties 	write strbuf 
including limited 	release free die 
implied 	sha hex 
warranties merchantability 	die sha hex 
fitness particular 	strbuf reset 
purpose disclaimed 	strbuf addf sha 
shall copyright 	hex cat 
owner contributors 	blob write strbuf 
liable 	release cat 
direct indirect 	blob write cat 
incidental special 	blob write 
exemplary consequential 	strbuf attach 
damages including 	free die find 
limited procurement 	mark parse 
substitute 	mark eol die 
goods services 	snprintf sha 
loss use 	hex cat blob 
data profits 	write find 
business interruption 	mark parse mark 
however caused 	eol die 
theory 	hashcpy sha hex 
liability whether 	die die 
contract strict 	find cat blob 
liability tort 	die sha 
including negligence 	hex insert die 
otherwise arising 	gfi unpack 
way 	entry read sha 
use software 	file die 
even advised 	sha hex 
possibility damage 	strlen sha hex 
functions build 	strlen die 
reply keep 	strlen sha hex 
mind 	strlen die 
function returning 	free find find 
interpreted oom 	mark parse 
create reply 	mark space die 
free reply 	hashcpy sha 
nothing free 	hex die find 
copy 	die dereference 
clear input 	isgitlink isdir strbuf 
buffer errors 	reset strbuf 
reset task 	addstr quote style 
stack error 	strbuf addch 
find pointer 	strbuf reset strbuf 
position 	addf sha 
len character 	hex quote style 
pos followed 	strbuf addch 
note strchr 	cat blob 
cannot used 	write die parse 
doesn allow 	treeish dataref 
search 	entry hashcpy sha 
limited length 	load strbuf 
buffer searched 	reset unquote style 
might trailing 	die die 
character found 	content isdir store 
found searching 	print release 
read 	content recursive release 
starting assumption 	entry cycle 
terminated ambiguously 	packfile dump branches 
returns unexpected 	dump tags 
input happen 	dump marks skip 
skip stack 	optional fwrite 
empty 	fputc fflush skip 
reset type 	optional absolute 
next item 	path xstrdup xstrdup 
anything type 	git path 
error status 	die read 
reply root 	marks make fast 
include 	path safe 
nil always 	create leading directories 
created buffer 	strcmp strcmp 
contains entire 	strcmp die strtoul 
bulk item 	strchr die 
include proceed 	arg die arg 
obj 	make fast 
created reply 	path safe create 
root error 	leading directories 
nested multi 	arg die fclose 
bulks depth 	fopen die 
modify task 	errno skip prefix 
stack 	git parse 
elements reply 	warning warning skip 
root check 	prefix git 
need read 	parse skip prefix 
type could 	option depth 
consume process 	skip prefix 
typed 	option active branches 
item avoid 	skip prefix 
warning early 	option export pack 
reader erroneous 	edges starts 
state copy 	starts skip prefix 
provided buffer 	option date 
destroy 	format skip prefix 
buffer empty 	option marks 
quite large 	skip prefix option 
buf since 	marks skip 
free larger 	prefix option export 
one target 	marks strcmp 
pointer 	strcmp strcmp strcmp 
early reader 	strcmp strcmp 
erroneous state 	strcmp strcmp die 
buffer empty 	parse one 
never reply 	feature die 
first item 	die parse one 
process 	option die 
stack empty 	git config git 
process items 	config git 
reply asap 	die config git 
error occurred 	config git 
discard part 	die config git 
buffer 	config git 
consumed least 	config strcmp skip 
avoid unnecessary 	prefix die 
calls memmove 	parse one option 
sds emit 	parse one 
reply one 	feature skip prefix 
calculate 	option cat 
number bytes 	blob die usage 
needed represent 	read marks 
integer helper 	git extract argv 
calculates bulk 	path git 
length given 	setup gettext 
certain 	strcmp usage setup 
length command 	git directory 
position command 	reset pack idx 
current argument 	option git 
current argument 	pack config alloc 
touched abort 	objects strbuf 
target 	init xcalloc xcalloc 
build command 	xcalloc pool 
accordingly protocol 	calloc pool alloc 
curarg put 	prepare packed 
argv overwritten 	git start packfile 
newarg even 	die routine 
touched 	checkpoint signal read 
detect format 	next command 
flags field 	strcmp parse blob 
width precision 	skip prefix 
copy list 	parse skip prefix 
consuming arg 	parse commit 
integer 	skip prefix 
conversion without 	parse tag skip 
modifiers conversion 	prefix parse 
without modifiers 	reset branch strcmp 
size gets 	parse checkpoint 
promoted size 	strcmp starts parse 
gets 	progress skip 
promoted size 	prefix parse feature 
size update 	skip prefix 
current position 	parse option starts 
note outer 	die checkpoint 
blocks increment 	parse argv feof 
twice 	die end 
compensate last 	packfile dump branches 
argument needed 	dump tags 
clear curarg 	unkeep packs dump 
put curargv 	marks fclose 
free bytes 	size size pack 
needed 	report see 
hold multi 	documentation git 
bulk count 	fast txt maintained 
build command 	documentation format 
protocol level 	stdin stream stream 
need check 	cmd cmd 
cmd 	blob commit tag 
since last 	reset branch 
statement fail 	checkpoint progress blob 
anyway defensive 	blob mark 
possible format 	file content file 
command according 	content data 
redis 	commit commit str 
protocol function 	mark author 
takes format 	name email committer 
similar represents 	name email 
terminated want 	commit msg commit 
interpolate 	ish merge 
represents binary 	commit ish 
safe need 	file change commit 
provide pointer 	msg data 
length bytes 	quoted path file 
size examples 	change file 
len 	clr file del 
redis format 	file rnm 
command target 	file cpy file 
mykey len 	obm file 
redis format 	inm file clr 
command target 	deleteall file 
mykey 	del path str 
myval myvallen 	file rnm 
format command 	path str path 
according redis 	str file 
protocol function 	cpy path str 
takes number 	path str 
arguments 	file obm mode 
arguments lengths 	hexsha idnum 
latter strlen 	path str 
used compute 	file inm mode 
argument lengths 	path str 
command position 	data note obm 
command 	hexsha idnum 
calculate number 	commit ish note 
bytes needed 	inm commit 
command build 	ish data tag 
command protocol 	tag tag 
level redis 	str commit ish 
err 	tagger name 
may lack 	email tag msg 
description connect 	tag msg 
redis instance 	data reset branch 
error field 	reset str 
error returned 	commit ish checkpoint 
context 	checkpoint progress 
error function 	progress note first 
reply functions 	idnum stream 
given used 	subsequent idnums 
read write 	gaps values cause 
timeout blocking 	stream parser 
socket 	reserve space gapped 
enable connection 	values idnum 
keep alive 	updated future issuing 
use function 	mark directive 
handle read 	old idnum mark 
descriptor read 	mark idnum 
bytes 	data delimited data 
socket feed 	exact data 
reply parser 	note delim may 
function called 	must contain 
may use 	data line may 
redis context 	contain data 
read 	must exactly delim 
reply see 	delimited data 
reply available 	data delim data 
early context 	line delim 
seen error 	note declen 
later write 	indicates length binary 
output 	data bytes 
buffer socket 	declen include preceding 
returns redis 	binary data 
buffer empty 	exact data data 
part buffer 	declen binary 
succesfully written 	data note quoted 
socket 	style quoting 
buffer empty 	supporting common escapes 
write operation 	nnn nnn 
done given 	octal note characters 
returns redis 	must actually 
err error 	escaped protect stream 
occured 	formatting otherwise 
trying write 	values utf commit 
sets errstr 	ish str 
hold appropriate 	hexsha sha exp 
error early 	str idnum 
context seen 	str sha 
error 	exp str sha 
later helper 	exp tag 
function reply 	str tag path 
reader error 	str path 
context otherwise 	quoted path mode 
read pending 	declen bit 
replies 	ascii notation bigint 
blocking context 	integer ascii 
flush output 	notation binary data 
buffer read 	file content 
reply write 	interpreted raw rfc 
done read 	raw rfc 
reply 	valid rfc date 
reply helper 	time ascii 
function redis 	space character ascii 
append command 	newline character 
family functions 	note colon 
write formatted 	must precede numerical 
command 	assigned idnum 
output buffer 	distinguish tag name 
family used 	git permit 
need call 	tag idnum bigint 
redis reply 	path git 
retrieve reply 	style file path 
replies 	git name 
pub sub 	refs heads moz 
helper function 	gecko experiment 
redis command 	tag git tag 
family functions 	name firefox 
write formatted 	sha exp valid 
command 	git sha 
output buffer 	expression hexsha sha 
given context 	hexadecimal format 
blocking immediately 	note name email 
read reply 	utf however 
reply pointer 	name must 
context 	contain email must 
non blocking 	contain following 
reply pointer 	name valid git 
used command 	author committer 
simply appended 	name email valid 
write buffer 	git author 
returns 	committer email time 
reply reply 	since epoch 
succesfully retrieved 	seconds ascii notation 
returns otherwise 	git style 
returned blocking 	timezone note comments 
context error 	mark cat 
field 	blob requests may 
context hiredis.h 	appear anywhere 
buf len 	input within data 
reply reply 	command form 
target format 	data command always 
target format 	escapes related 
target 	input comment 
argc argv 	processing clear starts 
argvlen port 	comment must 
port port 	first character line 
port source 	preceded mark 
addr path 	mark idnum cat 
path 	blob cat 
path done 	blob hexsha idnum 
reply reply 	hexsha idnum 
cmd len 	path str comment 
format format 	ascii newline 
argc argv 	abuse setuid bit 
argvlen 	directories mean 
format format 	delta must match 
argc argv 	avail content 
argvlen copyright 	must match content 
salvatore sanfilippo 	configured limits 
antirez gmail 	output stats misc 
dot 	counters memory 
copyright pieter 	pools atom 
noordhuis pcnoordhuis 	management pack file 
gmail dot 	generated table 
rights reserved 	objects written last 
redistribution use 	blob management 
source 	branch data tag 
binary forms 	data input 
without modification 	stream parsing signal 
permitted provided 	handling write 
following conditions 	output cat blob 
met redistributions 	commands windows 
source 	example round uintmax 
code must 	alignment build 
retain copyright 	table packfile core 
notice list 	git machinery 
conditions following 	print boundary carry 
disclaimer redistributions 	delta across 
binary 	packfiles zero 
form must 	nothing determine checkpoint 
reproduce copyright 	needs current 
notice list 	pack cannot carry 
conditions following 	delta pack 
disclaimer documentation 	nothing determine checkpoint 
materials 	zero calls 
provided distribution 	must guarded find 
neither name 	find mark 
redis names 	ensure entry passed 
contributors may 	written process 
used endorse 	instance unpack entry 
promote 	offset avoiding 
products derived 	need corresponding idx 
software without 	file unpacking 
specific prior 	rule works use 
written permission 	obj delta 
software provided 	within packfiles created 
copyright 	fast must 
holders contributors 	usually comes 
express implied 	giving unknown sha 
warranties including 	find undefined 
limited implied 	mark find mark 
warranties merchantability 	callers must 
fitness 	test condition use 
particular purpose 	standard read 
disclaimed shall 	sha file happens 
copyright owner 	pack must 
contributors liable 	max pack usually 
direct indirect 	find mark 
incidental 	mark reloaded existing 
special exemplary 	marks file 
consequential damages 	referencing fast process 
including limited 	instance write 
procurement substitute 	packfile callers must 
goods services 	test condition 
loss 	use read sha 
use data 	file instead 
profits business 	stored packfile 
interruption however 	writing modified since 
caused theory 	last time 
liability whether 	scanned back read 
contract 	previously written 
strict liability 	old window covered 
tort including 	pack size 
negligence otherwise 	pack size data 
arising way 	stale valid 
use software 	closing windows updating 
even 	packfile length 
advised possibility 	ensures read newly 
damage size 	written data 
list timeval 	offer bytes additional 
error occurs 	end packfile 
err flag 	core unpacker code 
context 	assumes footer 
hold type 	present file end 
error occured 	must promise 
redis err 	least bytes 
means error 	within window maps 
use errno 	actually create 
variable 	footer swap need 
find wrong 	versions sha 
values errstr 	alone avoid modifying 
field hold 	preimage used 
description error 	writing parent directory 
read write 	replacing subdir 
end 	completely different one 
file protocol 	good delta 
error memory 	besides thrown away 
everything connection 	entries needed 
type blocking 	make delta explicitly 
non blocking 	disable deltas 
least 	subtree names file 
significant bit 	subdirectory file 
flags field 	symlink matching 
redis context 	name parent directory 
connection may 	exists cannot 
disconnected free 	exist need deleted 
second 	marks file 
bit flags 	exist zero needswork 
field context 	perhaps check 
connected api 	reasonable values ensure 
might disconnect 	space delimiter 
cleanly flush 	even name interested 
output 	either existing 
buffer read 	note entries entries 
subsequent replies 	exactly hex 
disconnecting flag 	chars path including 
means commands 	directory separators 
come connection 	directory entries may 
terminated 	contain note 
replies read 	entries hex chars 
flag specific 	path also 
api means 	path component 
context clean 	note entry must 
soon possible 	multiple chars 
flag 	may note entry 
callback executed 	subdir containing 
flag context 	notes note entry 
one subscriptions 	counting mode 
flag monitor 	rename note entry 
mode active 	correct location 
max 	rename fullpath realpath 
unused reader 	subdir may 
buffer seconds 	contain note entries 
reply returned 	may reallocated 
redis command 	current content given 
redis reply 	pointer parse 
integer 	mark reference idnum 
type redis 	bigint first 
reply integer 	character endptr complain 
length used 	following character 
redis reply 	expected either 
error redis 	space end parse 
reply 	mark reference 
number elements 	complain end parse 
redis reply 	mark reference 
elements vector 	demanding trailing space 
redis reply 	pointer space 
number elements 	used data makes 
multibulk 	gcc happy 
container index 	git track empty 
parent holds 	non toplevel 
user generated 	directories accept sha 
read task 	without checking 
parent task 	expected another repository 
user 	path subdir 
settable arbitrary 	loading branch traverse 
field state 	count real 
protocol parser 	number notes expensive 
error flags 	non note 
error representation 	refs means 
error 	recently loaded notes 
applicable read 	refs might 
buffer buffer 	incorrectly num notes 
cursor buffer 	consequently old 
length max 	fanout might wrong 
length unused 	fix traversing 
buffer 	counting number notes 
index current 	num notes 
read task 	notes truly empty 
temporary reply 	calculation take 
pointer api 	invoke change note 
protocol parser 	fanout counting 
backwards 	mode parse notemodify 
compatibility removed 	command dataref 
big version 	used data makes 
bump function 	gcc happy 
free reply 	commit ish nothing 
objects hiredis 	insert ensure 
returns 	branch active 
functions format 	loaded file change 
command according 	build commit 
protocol context 	tagger tag payload 
connection redis 	message build 
error flags 	tag output batch 
error 	one cat 
representation error 	file mark cat 
applicable write 	blob cache 
buffer protocol 	easy pack written 
reader blocking 	peel one 
context function 	layer mark sha 
first 	see show 
checks unconsumed 	missing path mode 
replies returns 	type name 
one otherwise 	tab path ish 
flushes output 	path directory 
buffer socket 	preparation would 
reads 	sha zero saved 
reply non 	save simplicity 
blocking context 	read previous mark 
unconsumed replies 	file die 
write formatted 	feature supported die 
command output 	feature supported 
buffer 	nothing feature ignore 
use functions 	non git 
blocking mode 	options argv hasn 
pipeline commands 	parsed yet 
write command 	fast exportc first 
output buffer 	commit done 
use 	postimage report buffer 
functions blocking 	postimage initialized 
mode pipeline 	path path mode 
commands issue 	path mode 
command redis 	dataref revision author 
blocking context 	log timestamp 
identical 	note firstnote 
calling redis 	loglen committish dataref 
append command 	gitsvnline revision 
followed redis 	author log uuid 
reply function 	url timestamp 
error performing 	local empty revision 
request 	rev path 
otherwise reply 	path line input 
non blocking 	header len 
context identical 	type end len 
calling redis 	input old 
append command 	data old mode 
always 	ret preimage 
huge.c ptr 	response data mode 
node ptr 	len input 
node ptr 	response mode dataref 
node tsd 	tab response 
arena size 	end rev path 
zero 	mode dataref 
tcache usize 	path mode 
tsd arena 	dataref mode old 
size alignment 	mode old 
zero tcache 	data len input 
ret usize 	postimage len 
node 	buffer tmpfile init 
zeroed ptr 	buffer fdinit 
usize huge 	die errno buffer 
dalloc junk 	deinit die 
ptr oldsize 	errno putchar putchar 
usize min 	quote style 
usize 	putchar fast export 
max zero 	modify fast 
usize usize 	export truncate quote 
next node 	style putchar 
arena chunk 	strlen fwrite fputc 
hooks pre 	snprintf uintmax 
zeroed 	strlen fwrite quote 
post zeroed 	style putchar 
sdiff ptr 	fflush quote 
oldsize usize 	style fflush buffer 
node arena 	read line 
chunk hooks 	buffer ferror die 
cdiff 	errno die 
pre zeroed 	buffer ferror die 
post zeroed 	errno die 
sdiff ptr 	ends error strstr 
oldsize usize 	error strtoumax 
zero node 	strlen strlen error 
arena 	memchr strlen 
zeroed subchunk 	strlen error maximum 
zeroed chunk 	type error 
ptr oldsize 	error overflows die 
usize min 	sliding view 
usize max 	init init postimage 
zero 	buffer tmpfile 
tsd arena 	rewind die 
usize alignment 	fflush response line 
zero tcache 	parse cat 
tsd arena 	response line die 
ptr oldsize 	check preimage 
usize 	overflow strbuf addstr 
alignment zero 	check preimage 
tcache ret 	overflow strlen strlen 
copysize tsd 	check preimage 
ptr tcache 	overflow svndiff apply 
node arena 	die overflows 
ptr 	move window die 
ptr size 	die buffer 
node arena 	tmpfile prepare read 
ptr tctx 	die strbuf 
node arena 	release fwrite fputc 
ptr tctx 	die buffer 
node 	skip bytes die 
arena ptr 	read buffer 
chunk lookup 	copy bytes 
extent node 	die read fputc 
achunk extent 	strlen strlen 
node addr 	strlen die die 
extent 	strlen die 
node achunk 	strlen memchr die 
chunk chunk 	strbuf rev 
deregister huge 	parse response response 
palloc unlikely 	line active 
ipallocztm 	commit parse response 
cacheline ceiling 	response line 
arena choose 	apply delta buffer 
unlikely arena 	skip bytes 
chunk alloc 	strlen strlen buffer 
huge idalloctm 	copy bytes 
extent 	fputc licensed two 
node init 	clause bsd 
huge node 	style license see 
arena chunk 	license details 
dalloc huge 	needswork move 
idalloctm malloc 	fast export init 
mutex 	mode must 
elm tail 	path old file 
insert malloc 	path file 
mutex unlock 	read remainder preimage 
unlikely memset 	trailing newline 
unlikely memset 	room newline svn 
unlikely 	symlink blobs 
chunk dss 	start link missing 
memset jemalloc 	mode blob 
huge node 	dataref fast exporth 
extent node 	path path 
arena extent 	mode dataref committish 
node 	dataref revision 
zeroed unlikely 	author log timestamp 
memset chunk 	note revision 
purge wrapper 	author log uuid 
chunk ceiling 	url timestamp 
malloc mutex 	local revision 
extent 	mode len input 
node size 	data mode 
extent node 	old mode old 
size extent 	data len 
node zeroed 	input rev path 
malloc mutex 	mode dataref 
unlock 	path mode dataref 
arena chunk 	file rev 
ralloc huge 	returns errno enoent 
similar unlikely 	fetch-pack.c transfer 
memset unlikely 	unpack limit fetch 
memset huge 	unpack limit 
node 	unpack limit prefer 
extent node 	ofs delta 
arena extent 	done fetch fsck 
node zeroed 	objects transfer 
chunk hooks 	fsck objects 
chunk ceiling 	agent supported shallow 
chunk 	alternate shallow 
ceiling split 	file marked rev 
chunk ceiling 	list non 
chunk ceiling 	common revs multi 
unlikely huge 	ack use 
dalloc junk 	sideband allow unadvertised 
chunk 	request commit 
purge wrapper 	mark refname sha 
chunk addr 	refname oid 
chunk ceiling 	flag data refname 
chunk addr 	oid flag 
offset malloc 	data commit ancestors 
mutex 	dont parse 
extent node 	parents commit mark 
size extent 	parents args 
node zeroed 	line args buf 
malloc mutex 	unused args 
unlock arena 	count flush 
chunk 	limit args result 
ralloc huge 	sha refs 
shrink huge 	fetching retval sha 
node extent 	vain got 
node arena 	got ready req 
malloc mutex 	buf state 
extent 	len remote remote 
node zeroed 	hex line 
malloc mutex 	arg sha ack 
unlock arena 	commit hex 
chunk ralloc 	ack complete sha 
huge expand 	commit refname 
malloc 	oid flag data 
mutex extent 	args cutoff 
node size 	args refs sought 
malloc mutex 	sought newlist 
unlock unlikely 	newtail next keep 
memset chunk 	cmp sha 
ceiling 	unused args 
memset chunk 	refs sought sought 
ceiling chunk 	retval cutoff 
ceiling unlikely 	commit remote data 
memset chunk 	ret args 
ceiling chunk 	pack lockfile demux 
ceiling 	keep cmd 
huge ralloc 	name header pass 
move expand 	header cmd 
chunk ceiling 	ret hostname args 
chunk ceiling 	orig sought 
huge ralloc 	sought pack lockfile 
move 	sha agent 
expand chunk 	feature agent len 
ceiling chunk 	setup names 
ceiling chunk 	src dst item 
ceiling chunk 	args sought 
ceiling huge 	sought status extra 
ralloc 	extra args 
move similar 	conn dest 
chunk ceiling 	sought sought shallow 
chunk ceiling 	pack lockfile 
huge ralloc 	cpy parse commit 
move shrink 	prio queue 
huge 	put deref tag 
malloc huge 	parse rev 
palloc huge 	list push rev 
ralloc move 	list insert 
huge ralloc 	deref tag parse 
move helper 	clear commit 
memcpy 	marks rev list 
isqalloc huge 	push parse 
node extent 	commit mark common 
node arena 	prio queue 
huge node 	parse commit rev 
unset malloc 	list push 
mutex 	mark common packet 
malloc mutex 	read line 
unlock huge 	starts starts 
dalloc junk 	die strcmp skip 
extent node 	prefix sha 
addr extent 	hex strstr strstr 
node 	strstr die 
size arena 	send sideband packet 
chunk dalloc 	flush write 
huge extent 	die rev list 
node arena 	insert die 
extent node 	alternate lookup sha 
addr 	hex strbuf 
extent node 	addstr strbuf addstr 
size idalloctm 	strbuf addstr 
extent node 	strbuf addstr strbuf 
arena huge 	addstr strbuf 
node huge 	addstr strbuf addstr 
node 	strbuf addstr 
extent node 	strbuf addstr 
arena malloc 	strbuf addf git 
mutex extent 	user agent 
node size 	sanitized packet buf 
malloc mutex 	write strbuf 
unlock 	release packet buf 
huge node 	write strbuf 
extent node 	release packet flush 
arena malloc 	repository shallow 
mutex extent 	write shallow commits 
node prof 	packet buf 
tctx 	write packet buf 
malloc mutex 	flush send 
unlock huge 	request packet read 
node extent 	line skip 
node arena 	prefix sha hex 
malloc mutex 	die shallow 
extent 	skip prefix sha 
node prof 	hex die 
tctx malloc 	lookup die 
mutex unlock 	parse die unregister 
huge prof 	shallow die 
tctx prof 	die send request 
tctx 	strbuf setlen 
size overflow 	rev packet buf 
allocate one 	write sha 
contiguous chunks 	hex sha hex 
request allocate 	packet buf 
extent node 	flush send request 
track 	strbuf setlen 
chunk copy 	next flush consume 
zero zeroed 	shallow list 
pass copy 	ack sha hex 
chunk alloc 	lookup commit 
possible make 	die sha hex 
correct 	sha hex 
junk zero 	packet buf write 
fill decisions 	mark common 
insert node 	clear prio 
huge bother 	queue packet buf 
junk filling 	write send 
chunk 	request strbuf release 
isn unmapped 	consume shallow 
increase usize 	list ack sha 
incorporate extra 	hex parse 
nothing fill 	parse commit list 
necessary shrinking 	insert mark 
update 	complete oid hex 
size huge 	pop recent 
allocation update 	commit starts check 
zeroed fill 	refname format 
necessary growing 	strcmp starts free 
split excess 	sha hex 
chunks 	hashcmp copy mark 
update size 	complete file 
huge allocation 	parse alternate commit 
update zeroed 	list sort 
zap excess 	date mark 
chunks copy 	recent complete commits 
zero 	deref tag 
zeroed chunk 	lookup rev list 
pass copy 	push mark 
chunk alloc 	common filter refs 
possible make 	lookup sha 
correct junk 	hex sha hex 
zero 	sigchain push 
fill decisions 	recv sideband close 
update size 	sigchain pop 
huge allocation 	memset start die 
allocations must 	read pack 
huge avoid 	header die ntohl 
move 	argv push 
attempt expand 	argv push argv 
allocation place 	push argv 
time usize 	push argv 
min avoid 	push argv push 
moving allocation 	gethostname xsnprintf 
existing 	argv pushf getpid 
chunk size 	argv push 
accommodates size 	argv push argv 
attempt shrink 	push argv 
allocation place 	pushf ntohl ntohl 
avoid moving 	argv push 
allocation 	start command die 
usize oldsize 	index pack 
different enough 	lockfile close finish 
need use 	command die 
different size 	finish die strcmp 
fall back 	copy list 
allocating 	sort list qsort 
space copying 	repository shallow 
huge.h tsd 	server supports die 
arena size 	server supports 
zero tcache 	server supports 
tsd arena 	server supports server 
size 	supports server 
alignment zero 	supports server supports 
tcache ptr 	server supports 
oldsize usize 	server supports server 
min usize 	supports server 
max zero 	supports server supports 
tsd 	server feature 
arena ptr 	everything local packet 
oldsize usize 	flush find 
alignment zero 	common warning packet 
tcache huge 	flush setup 
dalloc junk 	alternate shallow setup 
tsd 	temporary shallow 
ptr tcache 	pack die git 
ptr ptr 	config git 
ptr ptr 	config git config 
tctx ptr 	git config 
jemalloc types 	git config 
jemalloc 	git config fetch 
structs jemalloc 	pack config 
externs jemalloc 	list insert list 
inlines hyperloglog.c 	clear unlink 
magic encoding 	warn git path 
notused card 	shallow rollback 
registers 	file commit file 
invalid hll 	sha file 
err key 	sha append setup 
len seed 	alternate shallow 
data end 	commit file sha 
ele elesize 	clear nonexistent 
regp 	shallow sha append 
hash bit 	assign shallow 
index count 	commits refs sha 
registers ele 	clear sha 
elesize oldcount 	append sha append 
count index 	setup alternate 
registers 	shallow commit 
ezp reg 	file sha clear 
dense hdr 	sha clear 
oldhdr runlen 	xcalloc assign shallow 
regval end 	commits refs 
ele elesize 	free sha clear 
hdr 	fetch pack 
oldcount count 	setup duplicates refs 
sparse end 	packet flush 
prev next 	die prepare shallow 
index first 	info fetch 
span runlen 	pack reprepare packed 
oplen 	git update 
seq last 	shallow clear shallow 
len curval 	info remember 
seqlen oldlen 	update flag allocation 
deltalen scanlen 	sending many 
len dense 	ack give 
retval 	traversing history allow 
sparse sparselen 	specifying sha 
ezp invalid 	tip allow request 
runlen regval 	sha reachable 
registers ezp 	possibly hidden function 
word bytes 	marks rev 
hdr 	ancestors common cases 
invalid alpha 	desirable mark 
initialized bias 	ancestors example server 
ele elesize 	yet know 
hdr max 	common next rev 
hll hdr 	send ignoring 
val 	common send ignore 
end runlen 	ancestors send 
regval hdr 	ignore ancestors send 
sparselen aux 	also ancestors 
xzero hdr 	sent depth back 
hdr retval 	duplicate shallow 
hdr 	unshallow commands 
card max 	every time block 
registers invalid 	lines exchanged 
max hdr 	complete ancestor local 
bitcounters hdr 	tell tell 
bytecounters val 	ancestors already know 
relerr 	use lookup 
checkpoint seed 	interested know reachable 
ele abserr 	already scanned 
maxerr cmd 	make sure parsed 
hdr val 	shallow aren 
end decoded 	stateless rpc need 
runlen 	retain headers 
regval encodingstr 	keep one window 
conv murmur 	ahead side 
hash hll 	wait ack next 
pat len 	one need 
hll dense 	replay next rpc 
hll 	request peer 
dense hll 	knows common 
dense sdsnewlen 	give error fetch 
hll sparse 	completely empty 
zero hll 	repo broken repository 
sparse zero 	trash definitely 
len 	definitely append unmatched 
hll sparse 	requests list 
xzero hll 	already may mean 
sparse xzero 	sync side 
len hll 	time guess wrong 
sparse val 	mark complete 
len 	remote refs common 
hll sparse 	refs mark 
val hll 	common yet server 
dense sdsfree 	told first 
sdsfree hll 	talking upload pack 
pat len 	subprocess reads 
sds 	spits band stderr 
make room 	feeds band 
sdslen hll 	demux closed 
sparse zero 	start command cloning 
hll sparse 	unusual common 
zero len 	commit already unshallow 
hll 	remote shallow 
sparse val 	clone objects repo 
hll sparse 	worry accept 
val len 	shallow points exist 
hll sparse 	pack iow 
xzero len 	repo pack reprepare 
hll 	packed git 
sparse xzero 	remote also shallow 
hll sparse 	git shallow 
zero hll 	may updated refs 
sparse zero 	accepted make 
len hll 	sure shallow roots 
sparse 	actually reachable 
xzero hll 	refs remote also 
sparse xzero 	shallow check 
len hll 	safe update 
sparse val 	without updating git 
len hll 	shallow copy 
sparse 	refs cmdline growable 
val hll 	list append 
sparse val 	refs standard input 
hll sparse 	stateless rpc 
val hll 	mode use pkt 
sparse xzero 	line read 
hll 	stdin flush packet 
sparse zero 	read stdin 
hll sparse 	one per line 
val hll 	eof heads 
sparse xzero 	pull given consumed 
hll sparse 	matching remote 
zero 	otherwise git fetch 
hll sparse 	remote would 
val hll 	silently succeed 
sparse val 	without issuing error 
hll sparse 	fetch pack 
val hll 	usage sought alloc 
sparse 	name oid 
val sdslen 	argc argv prefix 
memmove sds 	ret dest 
incr len 	sought alloc sought 
memcpy hll 	pack lockfile 
sparse xzero 	pack lockfile ptr 
hll 	conn args 
sparse zero 	shallow arg line 
hll sparse 	line flags 
val hll 	oid hex oidclr 
sparse val 	alloc oidcpy 
hll sparse 	alloc grow packet 
val 	trace identity 
hll sparse 	memset starts starts 
val len 	strcmp strcmp 
hll sparse 	strcmp strcmp 
val len 	strcmp strcmp strcmp 
hll sparse 	strcmp strcmp 
val 	strcmp starts strtol 
memmove sds 	strcmp strcmp 
incr len 	strcmp strcmp strcmp 
hll invalidate 	strcmp usage 
cache hll 	usage sought entry 
sparse dense 	packet read 
hll 	line sought entry 
dense server 	strbuf getline 
hll sparse 	sought entry strbuf 
zero hll 	release git 
sparse zero 	connect remote heads 
len hll 	fetch pack 
sparse 	fflush fflush close 
xzero hll 	close finish 
sparse xzero 	connect error oid 
len hll 	hex remember 
sparse val 	update flag 
len hll 	allocation sending many 
sparse 	ack give 
val hll 	traversing history allow 
dense sum 	specifying sha 
hll sparse 	tip allow request 
sum sdslen 	sha reachable 
hll raw 	possibly hidden function 
sum 	marks rev 
server panic 	ancestors common cases 
log hll 	desirable mark 
dense hll 	ancestors example server 
sparse hll 	yet know 
dense 	common next rev 
hll sparse 	send ignoring 
zero hll 	common send ignore 
sparse zero 	ancestors send 
len hll 	ignore ancestors send 
sparse xzero 	also ancestors 
hll 	sent depth 
sparse xzero 	back duplicate shallow 
len hll 	unshallow commands 
sparse val 	every time block 
len hll 	lines exchanged 
sparse val 	complete ancestor local 
sdsnewlen 	tell tell 
hll sparse 	ancestors already know 
xzero server 	use lookup 
create memcpy 	interested know reachable 
check type 	already scanned 
len len 	make sure parsed 
reply 	shallow aren 
sds sdsnew 	stateless rpc need 
lookup key 	retain headers 
write create 	keep one window 
hll hll 	ahead side 
reply unshare 	wait ack 
hll 	next one need 
sdslen reply 	replay next 
sds sdsnew 	rpc request peer 
signal modified 	knows common 
key notify 	give error fetch 
keyspace hll 	completely empty 
invalidate 	repo broken repository 
cache reply 	trash definitely 
memset lookup 	definitely append unmatched 
key read 	requests list 
hll reply 	already may mean 
hll merge 	sync side 
reply 	time guess wrong 
sds sdsnew 	mark complete 
reply hll 	remote refs common 
count lookup 	refs mark 
key write 	common yet server 
reply hll 	told first 
reply 	talking upload 
unshare hll 	pack subprocess reads 
valid cache 	spits band 
hll count 	stderr feeds band 
reply sds 	demux closed 
sdsnew signal 	start command cloning 
modified 	unusual common 
key reply 	commit already unshallow 
memset lookup 	remote shallow 
key read 	clone objects repo 
hll reply 	worry accept 
hll merge 	shallow points exist 
reply 	pack iow 
sds sdsnew 	repo pack reprepare 
lookup key 	packed git 
write create 	remote also shallow 
hll unshare 	git shallow 
hll sparse 	may updated refs 
dense 	accepted make 
reply sds 	sure shallow 
sdsnew hll 	roots actually reachable 
dense hll 	refs remote 
invalidate cache 	also shallow check 
signal modified 	safe update 
key 	without updating git 
notify keyspace 	shallow copy 
reply sdsnewlen 	refs cmdline growable 
rand hll 	list append 
dense hll 	refs standard input 
dense reply 	stateless rpc 
error 	mode use pkt 
format memset 	line read 
create hll 	stdin flush packet 
sqrt rand 	read stdin 
rand hll 	one per line 
dense hll 	eof heads 
reply 	pull given consumed 
error hll 	matching remote 
count hll 	otherwise git 
count reply 	fetch remote would 
error hll 	silently succeed 
count ceil 	without issuing error 
reply 	fetch-pack.c transfer 
error format 	unpack limit fetch 
reply sdsfree 	unpack limit 
decr count 	unpack limit prefer 
lookup key 	ofs delta 
write reply 	done fetch fsck 
error 	objects transfer 
hll reply 	fsck objects agent 
unshare strcasecmp 	supported shallow 
hll sparse 	alternate shallow file 
dense reply 	marked rev 
sds sdsnew 	list non common 
reply 	revs multi 
multi bulk 	ack use 
len hll 	sideband allow unadvertised 
dense reply 	request commit 
strcasecmp sdsempty 	mark refname sha 
reply error 	refname oid 
hll 	flag data refname 
sparse zero 	oid flag 
hll sparse 	data commit ancestors 
zero len 	dont parse 
sdscatprintf hll 	parents commit mark 
sparse xzero 	parents args 
hll 	line args buf 
sparse xzero 	unused args 
len sdscatprintf 	count flush limit 
hll sparse 	args result 
val len 	sha refs fetching 
hll sparse 	retval sha 
val 	vain got got 
sdscatprintf sdstrim 	ready req 
reply bulk 	buf state 
buffer sdslen 	len remote remote 
sdsfree strcasecmp 	hex line 
reply status 	arg sha ack 
strcasecmp 	commit hex 
hll sparse 	ack complete sha 
dense reply 	commit refname 
sds sdsnew 	oid flag data 
reply reply 	args cutoff 
error format 	args refs sought 
reply 	sought newlist 
error format 	newtail next keep 
hyperloglog redis 	cmp sha 
hyper log 	unused args refs 
log probabilistic 	sought sought 
cardinality approximation 	retval cutoff commit 
file 	remote data 
algorithm exported 	ret args pack 
redis commands 	lockfile demux 
copyright salvatore 	keep cmd 
sanfilippo antirez 	name header pass 
gmail dot 	header cmd 
rights 	ret hostname args 
reserved redistribution 	orig sought 
use source 	sought pack lockfile 
binary forms 	sha agent 
without modification 	feature agent len 
permitted provided 	setup names 
following 	src dst item 
conditions met 	args sought 
redistributions source 	sought status extra 
code must 	extra args 
retain copyright 	conn dest sought 
notice list 	sought shallow 
conditions 	pack lockfile cpy 
following disclaimer 	parse commit 
redistributions binary 	prio queue put 
form must 	deref tag 
reproduce copyright 	parse rev 
notice list 	list push rev 
conditions 	list insert 
following disclaimer 	deref tag parse 
documentation materials 	clear commit 
provided distribution 	marks rev list 
neither name 	push parse 
redis names 	commit mark common 
contributors 	prio queue 
may used 	parse commit rev 
endorse promote 	list push 
products derived 	mark common packet 
software without 	read line 
specific prior 	starts starts die 
written 	strcmp skip 
permission software 	prefix sha hex 
provided copyright 	strstr strstr 
holders contributors 	strstr die send 
express implied 	sideband packet 
warranties including 	flush write 
limited 	die rev list 
implied warranties 	insert die 
merchantability fitness 	alternate lookup sha 
particular purpose 	hex strbuf 
disclaimed shall 	addstr strbuf addstr 
copyright owner 	strbuf addstr 
contributors 	strbuf addstr strbuf 
liable direct 	addstr strbuf 
indirect incidental 	addstr strbuf addstr 
special exemplary 	strbuf addstr 
consequential damages 	strbuf addstr strbuf 
including limited 	addf git 
procurement 	user agent sanitized 
substitute goods 	packet buf 
services loss 	write strbuf release 
use data 	packet buf 
profits business 	write strbuf 
interruption however 	release packet flush 
caused 	repository shallow 
theory liability 	write shallow commits 
whether contract 	packet buf 
strict liability 	write packet buf 
tort including 	flush send 
negligence otherwise 	request packet read 
arising 	line skip 
way use 	prefix sha hex 
software even 	die shallow 
advised possibility 	skip prefix sha 
damage redis 	hex die 
hyper log 	lookup die parse 
log 	die unregister 
implementation following 	shallow die die 
ideas use 	send request 
bit hash 	strbuf setlen rev 
function proposed 	packet buf 
order limited 	write sha 
cardinalities 	hex sha hex 
cost additional 	packet buf 
bit per 	flush send request 
use bit 	strbuf setlen 
registers great 	next flush consume 
level accuracy 	shallow list 
total 	ack sha hex 
per key 	lookup commit 
use redis 	die sha hex 
data type 	sha hex 
type introduced 	packet buf write 
attempt made 	mark common 
compress 	clear prio queue 
data structure 	packet buf 
also algorithm 	write send request 
used original 	strbuf release 
hyper log 	consume shallow list 
log algorithm 	ack sha 
difference 	hex parse 
bit hash 	parse commit list 
function used 	insert mark 
correction performed 	complete oid hex 
values near 	pop recent 
heule nunkesser 	commit starts check 
hall 	refname format 
hyper log 	strcmp starts free 
log practice 	sha hex 
algorithmic engineering 	hashcmp copy mark 
state art 	complete file 
cardinality estimation 	parse alternate commit 
algorithm 	list sort 
flajolet ric 	date mark recent 
fusy gandouet 	complete commits 
meunier hyperloglog 	deref tag lookup 
analysis near 	rev list 
optimal cardinality 	push mark common 
estimation 	filter refs 
algorithm redis 	lookup sha 
uses two 	hex sha hex 
representations dense 	sigchain push 
representation every 	recv sideband close 
entry represented 	sigchain pop 
bit 	memset start die 
integer sparse 	read pack 
representation run 	header die ntohl 
length compression 	argv push 
suitable representing 	argv push argv 
hyper log 	push argv 
logs 	push argv push 
many registers 	argv push 
memory efficient 	gethostname xsnprintf argv 
way hll 	pushf getpid 
header dense 	argv push argv 
sparse representation 	push argv 
header 	push argv 
follows hyll 	pushf ntohl ntohl 
cardin first 	argv push 
bytes magic 	start command die 
bytes hyll 	index pack 
one encoding 	lockfile close finish 
currently 	command die 
hll dense 	finish die strcmp 
hll sparse 	copy list 
three used 	sort list qsort 
bytes cardin 	repository shallow 
field bit 	server supports die 
integer 	server supports 
stored little 	server supports server 
endian format 	supports server 
latest cardinality 	supports server supports 
computed reused 	server supports 
data structure 	server supports server 
modified 	supports server 
since last 	supports server 
computation useful 	supports server supports 
high probabilities 	server feature 
hlladd operations 	everything local packet 
modify actual 	flush find 
data 	common warning packet 
structure hence 	flush setup 
approximated cardinality 	alternate shallow setup 
significant bit 	temporary shallow 
significant cached 	pack die git 
cardinality means 	config git 
data 	config git config 
structure modified 	git config 
reuse cached 	git config git 
must recomputed 	config fetch 
dense representation 	pack config list 
dense representation 	insert list 
used 	clear unlink warn 
redis following 	git path 
bits counters 	shallow rollback 
encoded one 	file commit file 
starting lsb 	sha file 
msb next 	sha append setup 
bytes 	alternate shallow 
needed sparse 	commit file sha 
representation sparse 	clear nonexistent 
representation encodes 	shallow sha append 
registers run 	assign shallow 
length encoding 	commits refs sha 
composed 	clear sha 
three opcodes 	append sha append 
two one 	setup alternate 
one two 	shallow commit file 
bytes opcodes 	sha clear 
called zero 	sha clear xcalloc 
xzero 	assign shallow 
val zero 	commits refs free 
opcode represented 	sha clear 
xxxxxx bit 	fetch pack 
integer represented 	setup duplicates refs 
six bits 	packet flush 
xxxxxx 	die prepare shallow 
plus means 	info fetch 
registers opcode 	pack reprepare packed 
represent contiguous 	git update 
registers xzero 	shallow clear shallow 
opcode represented 	info remember 
two 	update flag allocation 
bytes xxxxxx 	sending many 
yyyyyyyy bit 	ack give traversing 
integer represented 	history allow 
bits xxxxxx 	specifying sha tip 
significant bits 	allow request 
yyyyyyyy 	sha reachable possibly 
least significant 	hidden function 
bits plus 	marks rev 
means registers 	ancestors common cases 
opcode represent 	desirable mark 
contiguous registers 	ancestors example server 
val 	yet know 
opcode represented 	common next rev 
vvvvvxx contains 	send ignoring 
bit integer 	common send ignore 
representing bit 	ancestors send 
integer representing 	ignore ancestors send 
number 	also ancestors 
contiguous registers 	sent depth back 
vvvvv obtain 	duplicate shallow 
run length 	unshallow commands every 
integers vvvvv 	time block 
must incremented 	lines exchanged complete 
one 	ancestor local 
opcode represent 	tell tell ancestors 
values repeated 	already know 
times sparse 	use lookup 
representation represent 	interested know reachable 
registers greater 	already scanned 
however 	make sure parsed 
unlikely find 	shallow aren 
hll cardinality 	stateless rpc need 
sparse representation 	retain headers 
still memory 	keep one window 
efficient dense 	ahead side 
representation 	wait ack next 
happens hll 	one need 
converted dense 	replay next rpc 
representation sparse 	request peer 
representation purely 	knows common give 
positional example 	error fetch 
sparse 	completely empty repo 
representation empty 	broken repository 
hll xzero 	trash definitely definitely 
hll non 	append unmatched 
zero registers 	requests list 
position respectively 	already may mean 
represented 	sync side 
following three 	time guess wrong 
opcodes xzero 	mark complete 
registers val 	remote refs common 
zero registers 	refs mark 
val registers 	common yet server 
registers 	told first 
xzero registers 	talking upload pack 
example sparse 	subprocess reads 
representation used 	spits band stderr 
bytes instead 	feeds band 
order represent 	demux closed start 
hll 	command cloning 
registers general 	unusual common commit 
low cardinality 	already unshallow 
big win 	remote shallow clone 
terms space 	objects repo 
efficiency traded 	worry accept 
cpu 	shallow points exist 
time since 	pack iow 
sparse representation 	repo pack reprepare 
slower access 	packed git 
following table 	remote also shallow 
shows average 	git shallow 
cardinality 	may updated refs 
bytes used 	accepted make 
samples per 	sure shallow roots 
cardinality representable 	actually reachable 
registers big 	refs remote also 
dense representation 	shallow check 
size 	safe update without 
used sample 	updating git 
dense representation 	shallow copy refs 
uses bytes 	cmdline growable 
big win 	list append refs 
cardinality bigger 	standard input 
cardinalities 	stateless rpc 
constant times 	mode use pkt 
involved updating 	line read 
sparse representation 	stdin flush packet 
justified memory 	read stdin 
savings exact 	one per line 
maximum 	eof heads 
length sparse 	pull given consumed 
representation implementation 	matching remote 
switches dense 	otherwise git fetch 
representation configured 	remote would 
via define 	silently succeed without 
server 	issuing error 
hll sparse 	fetch pack usage 
max bytes 	sought alloc 
hyll hll 	name oid argc 
dense hll 	argv prefix 
sparse reserved 	ret dest 
future 	sought alloc sought 
use must 	pack lockfile 
zero cached 	pack lockfile ptr 
cardinality little 	conn args 
endian data 	shallow arg line 
bytes 	line flags 
cached cardinality 	oid hex oidclr 
msb used 	alloc oidcpy 
signal validity 	alloc grow packet 
cached greater 	trace identity 
smaller error 	memset starts starts 
registers 	strcmp strcmp 
mask index 	strcmp strcmp strcmp 
enough count 	strcmp strcmp 
leading zeroes 	strcmp strcmp strcmp 
dense encoding 	starts strtol 
sparse encoding 	strcmp strcmp strcmp 
used 	strcmp strcmp 
internally never 	strcmp usage 
exposed low 	usage sought entry 
level bit 	packet read 
macros macros 	line sought entry 
access dense 	strbuf getline 
representation 	sought entry strbuf 
need bit 	release git 
counters bit 	connect remote heads 
bytes use 	fetch pack 
macros make 	fflush fflush close 
sure code 	close finish 
inlined 	connect error oid 
since speed 	hex remember 
critical especially 	update flag allocation 
order compute 	sending many 
approximated cardinality 	ack give traversing 
hllcount need 	history allow 
access 	specifying sha tip 
registers reason 	allow request 
also want 	sha reachable 
avoid conditionals 	possibly hidden function 
code path 	marks rev 
note representation 	ancestors common cases 
significant 	desirable mark 
bit msb 	ancestors example server 
every left 	yet know 
start bits 	common next rev 
lsb msb 	send ignoring 
forth passing 	common send ignore 
next 	ancestors send 
example want 	ignore ancestors send 
access counter 	also ancestors 
pos illustration 	sent depth back 
index first 	duplicate shallow 
containing data 	unshallow commands every 
pos 	time block 
position first 	lines exchanged complete 
bit counting 	ancestor local 
lsb given 	tell tell 
pos right 	ancestors already know 
shift bits 	use lookup 
initial 	interested know reachable 
right shift 	already scanned 
pos left 	make sure parsed 
shift bits 	shallow aren 
bits bits 	stateless rpc need 
initial left 	retain headers 
shift 	keep one window 
bits two 	ahead side 
bits clean 	wait ack next 
higher order 	one need 
bits interested 	replay next rpc 
right shifted 	request peer 
left 	knows common give 
shifted different 	error fetch 
example like 	completely empty 
pos bit 	repo broken repository 
counter actually 	trash definitely 
contained single 	definitely append unmatched 
pos 	requests list 
pos right 	already may mean 
shift bits 	sync side 
shift practice 	time guess wrong 
left shift 	mark complete 
next bits 	remote refs common 
even 	refs mark 
use effect 	common yet server 
clearing bits 	told first 
result affacted 	talking upload pack 
setting bit 	subprocess reads 
complex val 	spits band stderr 
want 	feeds band 
already right 	demux closed start 
range need 	command cloning 
two steps 	unusual common 
one need 	commit already unshallow 
clear bits 	remote shallow 
need 	clone objects repo 
bitwise bits 	worry accept 
pos first 	shallow points exist 
create mask 	pack iow 
clear bits 	repo pack reprepare 
position initialize 	packed git 
mask 	remote also shallow 
left shift 	git shallow 
bits invert 	may updated refs 
result mask 	accepted make 
starts mask 	sure shallow roots 
left shift 	actually reachable 
bits 	refs remote also 
mask invert 	shallow check 
bitwise mask 	safe update without 
bitwise val 	updating git 
left shifted 	shallow copy 
bits bits 	refs cmdline growable 
focus 	list append 
next initial 	refs standard input 
build mask 	stateless rpc 
start right 	mode use pkt 
shift bits 	line read 
invert mask 	stdin flush packet 
mask 	read stdin 
right shift 	one per line 
bits mask 	eof heads 
bitwise mask 	pull given consumed 
clear old 	matching remote 
bits bitwise 	otherwise git fetch 
val 	remote would 
left shifted 	silently succeed without 
bits note 	issuing error 
access last 	fetch-pack.h uploadpack unpacklimit 
counter also 	depth args 
access sds 	conn dest 
always 	sought sought shallow 
term exists 	pack lockfile 
skip conditional 	sought represents remote 
need allocate 	references updated 
explicitly store 	names found remote 
position regnum 	marked fetch.c 
variable 	builtin fetch usage 
target bytes 	fetch prune 
position regnum 	config prune append 
val bytes 	dry run 
macros access 	force keep multiple 
sparse representation 	update head 
macros 	verbosity recurse submodules 
parameter expected 	unshallow update 
pointer xxxxxx 	shallow max children 
vvvvvxx xxxxxx 	depth upload 
hyper log 	pack rla 
log algorithm 	gtransport gsecondary submodule 
hash 	prefix recurse 
function murmur 	submodules shown url 
hash bit 	refmap alloc 
version modified 	refmap refmap opt 
redis order 	arg unset 
provide result 	opt arg unset 
big 	builtin fetch 
little endian 	options signo head 
archs endian 	remote refs 
neutral given 	branch tail old 
element hyper 	tail refspec 
log log 	refname oid flag 
returns 	cbdata list 
length pattern 	item old oid 
element hash 	head sha 
side effect 	transport head tail 
regp index 	existing refs 
element hashes 	remote refs 
count 	item transport refspecs 
number zeroes 	refspec count 
starting bit 	tags autotags map 
hll registers 	tail oref 
power two 	tail remote refs 
corresponding first 	fetch refspec 
bit 	fetch refspec remote 
use index 	branch merge 
max run 	action check old 
bits note 	msg rla 
ending sequence 	transaction err ret 
zeroes must 	conflict remote 
included 	remote display updated 
count find 	current branch 
count smallest 	pretty msg name 
count possible 	quickref quickref 
zeroes bit 	data sha raw 
first position 	url remote 
count 	name map 
may sound 	commit url len 
like inefficient 	note kind 
actually average 	url filename want 
high probabilities 	status merge 
find iterations 	status marker map 
index 	transport map 
make sure 	ret refs count 
loop terminates 	map raw 
first bit 	url url len 
used address 	result stale 
initialized since 	refs url dangling 
count 	msg refnames 
pattern dense 	map current branch 
representation implementation 	filename transport 
element dense 	name remote transport 
hyperloglog data 	transport map 
structure actually 	transport refs count 
nothing 	existing refs 
added max 	map autotags 
pattern counter 	retcode peer item 
subset element 	old oid 
belongs incremented 	tail remote priv 
needed registers 	list name 
expected 	list key priv 
room hll 	wordlen name 
registers plus 	list prev remote 
additional right 	argv list 
requirement met 	result argv errcode 
sds automatically 	name remote 
since 	argc argv refs 
implicitly terminated 	refspec exit 
function always 	code argc argv 
succeed however 	prefix list 
result operation 	remote result argv 
approximated cardinality 	arg options 
changed 	parse fetch recurse 
returned otherwise 	submodules arg 
returned update 	strcmp git 
element produced 	config git config 
longer run 	alloc grow 
zeroes compute 	transport unlock pack 
sum 	transport unlock 
reg dense 	pack unlock pack 
representation pre 	sigchain pop 
computer table 	branch merge matches 
values reg 	memset fetch 
indexed reg 	map list insert 
side 	xmalloc oidcpy 
effect integer 	hashcmp transport remote 
pointed ezp 	refs starts 
number zero 	ends file fetch 
registers redis 	sha file 
use registers 	fetch sha file 
bits 	fetch list 
code works 	list list 
values modifying 	insert list clear 
defines target 	sha file 
take faster 	fetch alloc alloc 
path unrolled 	oidcpy list 
loops 	clear transport remote 
handle registers 	refs fetch 
per iteration 	map parse fetch 
additional parens 	refspec fetch 
allow compiler 	map fetch map 
optimize code 	die branch 
loss 	branch merge config 
precision relevant 	strcmp fetch 
floating point 	map strcmp merge 
math commutative 	config remote 
increment end 	die fetch map 
loop precomputed 	find non 
reg 	local tags duplicates 
times sparse 	getenv snprintf 
representation implementation 	transaction begin 
convert hll 	transaction update transaction 
sparse representation 	commit transaction 
given input 	free strbuf release 
dense 	transaction free 
representation representations 	error strbuf release 
represented sds 	branch prettify 
input representation 	refname sha info 
freed side 	die oid 
effect function 	hex oidcmp strbuf 
returns 	addf transport 
sparse representation 	summary strcmp bare 
valid otherwise 	repository oid 
err returned 	strbuf addf transport 
representation corrupted 	summary oid 
representation already 	starts update strbuf 
right 	addf transport 
one asap 	summary lookup commit 
create right 	reference gently 
size filled 	lookup commit 
zero bytes 	reference gently starts 
note cached 	starts check 
cardinality 	submodule commits update 
side effect 	strbuf addf 
exactly cardinality 	transport summary merge 
empty hll 	bases strbuf 
copy magic 	unique abbrev strbuf 
cached cardinality 	addstr strbuf 
read 	unique abbrev check 
sparse representation 	submodule commits 
non zero 	update strbuf addf 
registers accordingly 	strbuf release 
sparse representation 	strbuf unique abbrev 
valid expect 	strbuf addstr 
find 	strbuf unique abbrev 
idx hll 	check submodule 
registers free 	commits update strbuf 
old representation 	addf strbuf 
one element 	release strbuf 
sparse hyperloglog 	addf transport summary 
data 	hashcpy git 
structure actually 	path fetch head 
nothing added 	fopen error 
max pattern 	strerror transport anonymize 
counter subset 	url xstrdup 
element belongs 	check everything connected 
incremented 	error warning 
needed holding 	lookup commit reference 
hll function 	gently alloc 
requires reference 	oidcpy oidcpy strcmp 
order able 	starts starts 
enlarge needed 	starts strlen strncmp 
success 	strbuf reset 
function returns 	strbuf addf strbuf 
cardinality changed 	addf oid 
element updated 	hex fputs 
error representation 	fputc fputc strbuf 
invalid returned 	reset update 
side 	local free strbuf 
effect function 	addf error 
may promote 	strbuf release free 
hll representation 	fclose check 
sparse dense 	everything connected quickfetch 
happens requires 	transport fetch 
representable 	refs store updated 
sparse representation 	refs transport 
resulting size 	unlock pack stale 
would greater 	heads transport 
server hll 	anonymize url xstrdup 
sparse max 	strlen strncmp 
bytes 	list append refs 
update element 	list clear 
produced longer 	transport summary prettify 
run zeroes 	refname warn 
count big 	dangling symref 
representable sparse 	free free refs 
representation 	branch bare 
dense representation 	repository strcmp die 
updating sparse 	git path 
representation sometimes 	fetch head fopen 
may need 	writing error 
enlarge buffer 	strerror fclose transport 
bytes 	option die 
worst xzero 	warning transport transport 
split xzero 	verbosity option 
val xzero 	option option option 
make sure 	prepare transport 
enough space 	transport option transport 
right 	option fetch 
pointers take 	refs transport disconnect 
execution function 	die truncate 
valid time 	fetch head map 
step need 	check current 
locate opcode 	branch list 
need 	lookup oidcpy transport 
modify check 	option prune 
update actually 	refs prune refs 
needed points 	fetch refs 
previos opcode 	free refs free 
end loop 	refs find 
points 	non local tags 
next opcode 	backfill tags 
end loop 	free refs list 
span number 	clear list 
registers covered 	append skip prefix 
opcode performance 	strcmp strcspn 
critical 	list append xstrndup 
loop sparse 	git config 
representation sorting 	remote remote configured 
conditionals least 	list append 
frequent opcode 	argv push argv 
many bytes 	push argv 
sparse 	push argv 
faster xzero 	push argv push 
opcode covers 	argv push 
index invalid 	argv push argv 
format cache 	push argv 
current opcode 	push argv push 
type 	argv push 
avoid macro 	argv push truncate 
something change 	fetch head 
also cache 	argv pushl options 
run length 	argv argv 
opcode step 	push run command 
loop 	opt error 
first stores 	argv pop argv 
index first 	clear die 
covered current 	prepare transport xcalloc 
opcode pointed 	strcmp die 
next prev 	xstrfmt sigchain 
store 	push common atexit 
respectively next 	parse fetch 
previous opcode 	refspec fetch free 
opcode respectively 	refspec transport 
last first 	disconnect packet trace 
span number 	identity strbuf 
registers 	addstr strbuf addf 
covered current 	git config 
opcode different 	parse options die 
cases order 	repository shallow 
update data 	die xstrfmt atoi 
structure place 	die parse 
without 	fetch recurse submodules 
generating scratch 	arg config 
val opcode 	fetch recurse submodules 
already count 	gitmodules config 
update needed 	git config die 
regardless val 	die remote 
run 	fetch multiple 
length field 	remote fetch one 
pfadd returns 	remote die 
since changes 	fetch multiple remote 
performed val 	die fetch 
opcode len 	multiple remote fetch 
representing 	one options 
less count 	argv fetch populated 
update since 	submodules argv 
trivial another 	clear list clear 
trivial handle 	close packs 
zero opcode 	argv pushl argv 
len 	push run 
replace val 	command opt argv 
opcode len 	clear git 
general cases 	fetch unspecified unspecified 
complex requires 	prune git 
updated either 	fetch refmap origin 
currently 	foo used 
represented val 	tell command 
opcode len 	store anywhere fetched 
zero opcode 	remote tracking 
len xzero 	branch need fetch 
opcode cases 	anyway allow 
original 	branch branch name 
opcode must 	merge honored 
split muliple 	git pull fail 
opcodes worst 	branch name 
xzero split 	merge misconfigured point 
middle 	nonexisting branch 
resuling xzero 	indeed called git 
val xzero 	pull notice 
resulting sequence 	misconfiguration entry resulting 
max length 	fetch head 
bytes perform 	marked merging peeled 
split 	always follows 
writing sequence 	matching see peeled 
buffer newlen 	want fetch 
length later 	mark entry 
sequence inserted 	list one ignore 
place old 	setting item 
one 	non previously saw 
possibly moving 	followed peeled 
right bytes 	reference need check 
sequence longer 	lightweight tag 
older one 	want fetch skip 
last covered 	duplicates refs 
sequence 	already may lightweight 
handle splitting 	tag needs 
zero xzero 	see needs fetching 
handle splitting 	tags remote 
val step 	refs list list 
substitute sequence 	refs fetched 
old 	unless already decided 
one note 	ignore item 
already allocated 	opportunistically updated references 
space sds 	merge everything 
calling sds 	command line 
make room 	tags refs happen 
step 	fetching via 
merge adjacent 	command line arguments 
values possible 	destination might 
representation updated 	missing different remote 
however resulting 	tracking would 
representation may 	derived configured refspec 
optimal 	cases want 
adjacent val 	take opportunity update 
opcodes sometimes 	configured remote 
merged single 	tracking reference however 
one scan 	want mention 
upcodes starting 	entries fetch head 
prev 	would simply 
need two 	duplicates existing entries 
adjacent val 	fetch head 
opcodes merge 	ignore compute 
len fits 	entries refspecs specified 
val opcode 	command line 
max 	list following refspecs 
len merge 	resulting tags 
reiterate without 	option one latter 
incrementing order 	fetch head 
merge merged 	merge removed duplicates 
right invalidate 	favor one 
cached 	opportunistic entries fetch 
cardinality promote 	head ignore 
dense representation 	use defaults note 
corrupted hll 	merge implies 
need call 	non branch remote 
hll dense 	name remote 
perform 	fetching given branch 
operation conversion 	name remote 
however result 	given branch name 
must since 	merge note 
need convert 	merge implies 
sparse dense 	non branch remote 
requires 	name also 
updated note 	fetch tags append 
turn means 	refs updated 
pfadd make 	opportunistically head okay 
sure command 	update head 
propagated slaves 	old head isn 
aof 	empty nicely 
sparse dense 	describe fetching remote 
convertion performed 	name likely 
slaves well 	follow standard layout 
compute sum 	end list 
reg sparse 	pass fetch head 
representation 	status type 
pre computer 	order merged entries 
table values 	written merge 
reg indexed 	lets readers use 
reg side 	fetch head 
effect integer 	refname refer 
pointed 	merged fall write 
ezp number 	anything fetch 
zero registers 	head would want 
increment end 	bypass transfer 
loop increment 	altogether everything going 
end loop 	fetch already 
times 	exists connected locally 
hyper log 	deepening shallow 
log count 	clone already objects 
core algorithm 	reachable running 
approximated count 	rev list good 
computed function 	exit status 
uses 	bypass fetch really 
lower level 	need perform 
hll dense 	claiming failure ensure 
sum hll 	perform network 
sparse sum 	exchange deepen history 
functions helpers 	appending truncate 
compute 	fetch head 
sum reg 	prune refspecs specified 
part computation 	explicitly via 
representation specific 	command line configuration 
rest common 	care whether 
sum operation 	tags specified neither 
data 	tags tags 
type used 	specified automated tag 
internally speedup 	following split 
pfcount multiple 	list white space 
keys reg 	command line 
times every 	request record command 
zero 	line reflog 
hll approximated 	need strict transport 
cardinality harmonic 	option validate 
mean registers 	arguments use remote 
values hdr 	arguments assumed 
points start 	remotes groups 
sds 	single remote one 
representing holding 	remote zero 
hll representation 	one remotes names 
sparse representation 	strdup strndup 
hll valid 	files-backend.c name orig 
integer pointed 	name old 
invalid 	oid oid peeled 
non zero 	alloc sorted 
otherwise left 	cache entries flag 
untouched hll 	subdir name 
count supports 	dirname dir dir 
special encoding 	refname len 
hll 	cache dirname len 
raw hdr 	incomplete dir 
registers point 	entry entry dir 
hll registers 	pos child 
element useful 	entry refname sha 
order speedup 	flag check 
pfcount 	name dir 
called multiple 	entry dir entry 
keys need 	dir cache 
work bit 	dirname len incomplete 
integers encoding 	direntry one 
number registers 	two dir len 
equal 	str key 
precompute reg 	ent key ent 
small table 	cmp dir 
order speedup 	refname len key 
computation sum 	dir subdirname 
reg reg 	len mkdir entry 
reg 	index entry 
compute sum 	dir refname mkdir 
muliply inverse 	slash dirnamelen 
alpha raw 	subdir dir refname 
estimate use 	entry index 
linearcounting algorithm 	entry dir refname 
small 	refname len 
cardinalities larger 	entry index 
values hyper 	entry dir dirname 
log log 	dir dir 
raw approximation 	last entry entry 
used since 	current trim 
linear 	flags data entry 
counting error 	data data 
starts increase 	old current retval 
however hyper 	dir offset 
log log 	data entry retval 
shows strong 	subdir dir 
bias 	dir data retval 
range compensate 	cmp subdir 
linearcounting polynomial 	subdir subdir dir 
regression bias 	entry skip 
range way 	conflicting refname entry 
compute bias 	vdata data 
given 	refname extras skip 
cardinality correct 	dir err 
according apply 	slash extra 
correction use 	refname pos dirname 
correction verified 	ret data 
apply correction 	root referrers validity 
since 	next loose 
use bit 	packed name packlock 
function bit 	packed refs 
counters apply 	packed refs refs 
correction needed 	packed refs 
since would 	refs submodule refs 
require 	submodule refs 
huge approach 	submodule refs packed 
call hll 	refs header 
dense hll 	line sha dir 
sparse according 	last line 
hll encoding 	sha refname traits 
invalid 	flag refs 
representation merge 	packed refs 
computing max 	file packed cache 
registers hll 	refs refname 
hyper log 	sha packed cache 
log hll 	dirname dir 
hll 	refs dirnamelen refname 
registers registers 	path path 
pointed max 	baselen sha flag 
hll must 	read refs 
already validated 	refs refname sha 
via hll 	dir refs 
reply 	refname sha recursion 
way hyper 	len buffer 
log log 	path path refname 
sparse found 	sha retval 
invalid err 	submodule refs refname 
returned otherwise 	refname resolve 
function 	flags sha flags 
always succeeds 	entry refname 
hyper log 	resolve flags 
log commands 	sha flags refname 
create hll 	path contents 
always create 	depth bad name 
hll 	path buf 
sparse encoding 	save errno refname 
upgraded dense 	resolve flags 
representation needed 	sha flags refname 
populate sparse 	contents path 
representation many 	ret flag refs 
xzero 	data packed 
opcodes needed 	cache loose dir 
represent registers 	packed dir 
create actual 	retval refs trim 
check valid 	flags data 
hll representation 	data submodule data 
otherwise 	oid flag 
reply client 	data submodule data 
error err 	data submodule 
key exists 	data prefix 
check type 	data prefix data 
error already 	broken flag 
sent 	submodule prefix data 
magic hyll 	data data 
dense representation 	buf ret data 
length match 	old sha 
exactly tests 	mustexist err save 
passed pfadd 	errno path 
ele 	refname old sha 
ele ele 	extras skip 
ele create 	flags type err 
key exact 	file orig 
length hold 	file orig refname 
hll data 	last errno 
structure 	type lflags mustexist 
sdsnewlen passed 	resolve flags 
guaranteed bytes 	attempts remaining refname 
initialized zero 	sha peeled 
perform low 	entry data 
level operation 	flags timeout configured 
every 	timeout packed 
element pfcount 	cache packed cache 
approximated cardinality 	error save 
multi key 	errno packed cache 
keys cardinality 	next sha 
multiple keys 	name flags packed 
specified 	refs prune 
pfcount actually 	entry data packed 
computes cardinality 	entry tag 
merge specified 	name transaction err 
compute hll 	flags cbdata 
max special 	refnames err packed 
encoding 	refname ret 
check type 	removed flag err 
size empty 	loose filename 
hll non 	res refnames err 
existing merge 	result refname 
hll max 	newrefname attempts 
hhl 	remaining path ret 
setting max 	newname extras 
max max 	skip err packed 
hll compute 	refs loose 
cardinality resulting 	refs sha err 
cardinality single 	sha logmsg 
hll 	flags err oldrefname 
user specified 	newrefname logmsg 
single key 	sha orig sha 
either cached 	logmoved loginfo 
compute one 	log symref err 
update cache 	path result 
key 	refname logfile err 
cardinality zero 	force create 
since element 	logfd oflags refname 
added otherwise 	force create 
would key 	err ret 
hlladd creates 	old sha sha 
side 	committer msg 
effect check 	msglen written maxlen 
cached cardinality 	len logrec 
valid cached 	refname old sha 
recompute update 	sha msg 
cached considered 	logfile flags err 
read 	logfd result 
command even 	oflags refname old 
data structure 	sha sha 
modified since 	msg flags err 
cached may 	refname old 
modified given 	sha sha msg 
hll 	flags err 
redis need 	ret sha err 
propagate change 	term sha 
pfmerge dest 	logmsg flags err 
src src 	old msg 
src src 	head sha 
compute 	head flag head 
hll max 	log err 
maximum max 	target ret path 
registers write 	refname target 
target variable 	logmsg err sha 
later check 	refname target 
type 	logmsg refname target 
size empty 	logmsg err 
hll non 	ret refname refname 
existing merge 	data osha 
hll max 	nsha email end 
hhl setting 	message timestamp 
max 	bob scan refname 
max max 	data logfp 
hll create 	pos tail cnt 
unshare destination 	nread buf 
key needed 	endp scanp refname 
create key 	data logfp 
exact 	ret name 
length hold 	data retval oldlen 
hll data 	oid data 
structure sdsnewlen 	retval name refnames 
passed guaranteed 	err transaction 
bytes initialized 	err updates refs 
zero 	affected refnames 
key exists 	update reason overwriting 
sure right 	symref write 
type size 	err update update 
since merging 	refname oid 
different check 	flags data affected 
support 	refnames transaction 
dense objects 	err updates affected 
destination write 	refnames update 
resulting hll 	update flags prune 
destination hll 	policy newlog 
registers invalidate 	last kept sha 
cached 	osha nsha 
generate pfadd 	email timestamp 
pfmerge semantical 	message data policy 
simplicity since 	refname sha 
theory mass 	flags prepare prune 
elements testing 	cleanup policy 
debugging 	data reflog log 
pfselftest command 	file status 
performs self 	type err err 
test hll 	update read 
registers implementation 	loose refs strcmp 
something easy 	search dir 
test 	create dir entry 
within outside 	entry dir 
test access 	read loose refs 
registers test 	check refname 
conceived test 	format die flex 
different counters 	alloc str 
data 	hashcpy oidclr 
structure accessible 	clear dir free 
setting values 	alloc grow 
result correct 	strcmp free entry 
retained affect 	free flex 
adjacent values 	alloc mem strcmp 
hll 	strncmp sort 
counters byes 	dir bsearch search 
size random 	dir create 
values check 	dir entry entry 
able retrieve 	dir dir 
values test 	strchr strchr search 
approximation 	subdir find 
error test 	containing dir search 
adds unique 	dir strlen 
elements check 	strlen xmemdupz find 
estimated always 	containing dir 
reasonable bounds 	free find containing 
check 	dir search 
error smaller 	dir memmove 
times expected 	free entry find 
standard error 	containing dir 
make unlikely 	entry dir strcmp 
test fail 	die oidcmp 
bad 	die warning qsort 
run test 	dup free 
performed dense 	entry sha file 
sparse time 	error starts 
also verifying 	resolves dir sort 
computed cardinality 	dir entry 
make 	dir entry dir 
sure small 	entry dir 
cardinalities use 	strcmp dir dir 
sparse encoding 	sort dir 
check dense 	sort dir entry 
sparse representations 	dirs die 
agree 	dir sort dir 
check error 	entry dir 
adjust max 	prime dir 
error expect 	dir list strbuf 
cardinality since 	grow strlen 
time time 	strchr strchr strbuf 
statistically 	search dir 
likely much 	list strbuf addf 
higher error 	list list 
due collision 	strbuf addf strbuf 
resulting positive 	addch search 
success pfdebug 	dir dir strbuf 
subcommand 	addstr strbuf 
key args 	addch search dir 
different debugging 	dir sort 
related operations 	dir entry dir 
hll implementation 	strbuf addf 
pfdebug getreg 	find descendant strbuf 
key 	addf strbuf 
force propagation 	release free entry 
encoding change 	stat validity 
pfdebug decode 	clear free 
key pfdebug 	die release packed 
encoding key 	cache free 
pfdebug 	entry flex alloc 
todense key 	str strcmp 
force propagation 	lookup cache create 
encoding change 	cache sha 
intset.c pos 	hex isspace isspace 
enc pos 	strbuf getwholeline 
pos 	skip prefix strstr 
encoding len 	strstr parse 
size pos 	line check refname 
mid cur 	format refname 
curenc newenc 	safe die hashclr 
length prepend 	create entry 
src 	starts sha hex 
dst bytes 	hashcpy strbuf 
encoding success 	release git 
valenc pos 	pathdup submodule git 
success valenc 	pathdup stat 
pos 	validity check clear 
len valenc 	packed cache 
pos estr 	xcalloc acquire packed 
file line 	cache create 
bits size 	dir entry fopen 
mask encoding 	stat validity 
argc 	update fileno read 
argv success 	packed refs 
inserts size 	dir fclose free 
bits start 	dir packed 
memcpy memrev 	dir packed cache 
ifbe memcpy 	packed cache 
memrev 	die packed dir 
ifbe memcpy 	create entry 
memrev ifbe 	strlen strbuf git 
intset encoded 	path submodule 
intrev ifbe 	strbuf git 
intrev ifbe 	path opendir strbuf 
memrev 	release strbuf 
ifbe memrev 	init strbuf readdir 
ifbe memrev 	ends strbuf 
ifbe zmalloc 	addstr strbuf addstr 
intrev ifbe 	stat isdir 
intrev ifbe 	strbuf addch entry 
zrealloc 	dir create 
intrev ifbe 	dir entry hashclr 
intset intrev 	resolve gitlink 
ifbe intrev 	read full hashclr 
ifbe intset 	sha check 
intset intrev 	refname format refname 
ifbe 	safe die 
intset encoding 	hashclr entry dir 
intrev ifbe 	create entry 
intrev ifbe 	strbuf setlen strbuf 
intset resize 	setlen strbuf 
intrev ifbe 	release strbuf 
intset 	release closedir create 
intset encoded 	dir entry 
intset intset 	entry dir dir 
intrev ifbe 	create dir 
intrev ifbe 	entry dir packed 
intrev ifbe 	refs find 
intrev 	hashcpy strlen git 
ifbe intrev 	pathdup submodule 
ifbe memmove 	git pathdup open 
intset encoding 	free resolve 
intrev ifbe 	gitlink packed read 
intset upgrade 	close isspace 
intset 	sha hex strncmp 
search intset 	isspace resolve 
resize intrev 	gitlink recursive strlen 
ifbe intrev 	strbuf lookup 
ifbe intset 	cache nonbare repository 
move tail 	dir strbuf 
intset 	release create 
intrev ifbe 	cache strbuf release 
intrev ifbe 	resolve gitlink 
intset encoding 	recursive find packed 
intrev ifbe 	refs packed 
intset search 	hashcpy hashclr check 
intrev 	refname format 
ifbe intset 	refname safe strbuf 
move tail 	reset strbuf 
intset resize 	git path lstat 
intrev ifbe 	resolve missing 
intset encoding 	loose hashclr islnk 
intrev 	strbuf reset 
ifbe intset 	strbuf readlink starts 
search intset 	check refname 
rand intrev 	format strbuf swap 
ifbe intrev 	hashclr isdir 
ifbe intset 	open strbuf reset 
intrev 	strbuf read 
ifbe intrev 	close close 
ifbe intrev 	strbuf rtrim starts 
ifbe gettimeofday 	sha hex 
intset rand 	isspace hashclr isspace 
rand rand 	strbuf reset 
intset 	strbuf addstr hashclr 
intrev ifbe 	check refname 
intrev ifbe 	format refname safe 
srand time 	resolve strbuf 
unused unused 	release strbuf release 
intset encoding 	peel strcmp 
intset 	peel entry hashcpy 
encoding intset 	read full 
encoding intset 	packed peel entry 
encoding intset 	hashcpy peel 
encoding intset 	loose refs find 
encoding intset 	containing dir 
encoding 	prime dir 
intset encoding 	packed cache acquire 
intset encoding 	packed cache 
intset encoding 	packed dir find 
intset intset 	containing dir 
intset intset 	sort dir sort 
intset 	dir entry 
intset intset 	dirs sort dir 
rand intrev 	entry dir 
ifbe check 	sort dir entry 
consistency intset 	dir release 
intset intrev 	packed cache git 
ifbe 	env entry 
intset intrev 	resolve gitlink read 
ifbe intset 	full head 
find intset 	head cache strlen 
find check 	cache strlen 
consistency intset 	strlen strbuf addf 
intset 	git strbuf 
intrev ifbe 	release rollback 
intset intrev 	file free free 
ifbe intset 	free read 
find intset 	full strbuf addf 
find check 	hashclr hashcmp 
consistency 	strbuf addf sha 
intset intset 	hex sha 
intrev ifbe 	hex dir recursively 
intset intrev 	sha xcalloc 
ifbe intset 	resolve strbuf git 
find intset 	path empty 
find 	directories verify refname 
check consistency 	available dir 
intset intset 	loose refs strbuf 
intrev ifbe 	addf resolve 
intset intrev 	verify refname available 
ifbe intset 	dir loose 
find 	refs strbuf addf 
intset find 	strerror oid 
check consistency 	verify refname 
intset intset 	available dir packed 
intrev ifbe 	refs xcalloc 
intset intrev 	xstrdup xstrdup strbuf 
ifbe 	git path 
intset find 	safe create leading 
intset find 	directories strbuf 
check consistency 	addf hold file 
intset intset 	update unable 
intrev ifbe 	message verify unlock 
intset 	strbuf release 
intrev ifbe 	strbuf release die 
intset find 	sha hex 
intset find 	die sha hex 
check consistency 	error write 
create check 	packed entry git 
consistency 	config hold 
usec intset 	file update timeout 
search rand 	git path 
usec intset 	packed cache 
rand intset 	acquire packed cache 
intset find 	packed cache 
rand 	die fdopen file 
intset intset 	die errno 
find check 	die entry dir 
consistency copyright 	packed dir 
pieter noordhuis 	commit file release 
pcnoordhuis gmail 	packed cache 
dot 	packed cache die 
copyright salvatore 	rollback file 
sanfilippo antirez 	release packed cache 
gmail dot 	clear packed 
rights reserved 	cache starts type 
redistribution use 	resolves peel 
source 	entry die oid 
binary forms 	hex find 
without modification 	oidcpy create 
permitted provided 	entry oidcpy flex 
following conditions 	alloc str 
met redistributions 	hashcpy rmdir git 
source 	path check 
code must 	refname format transaction 
retain copyright 	begin transaction 
notice list 	transaction commit transaction 
conditions following 	free error 
disclaimer redistributions 	strbuf release transaction 
binary 	free strbuf 
form must 	release empty parents 
reproduce copyright 	prune memset 
notice list 	packed refs packed 
conditions following 	refs entry 
disclaimer documentation 	dir loose refs 
materials 	commit packed 
provided distribution 	refs die errno 
neither name 	prune refs 
redis names 	packed packed 
contributors may 	refs unable message 
used endorse 	git path 
promote 	packed refs entry 
products derived 	rollback packed 
software without 	refs commit packed 
specific prior 	refs strbuf 
written permission 	addf strerror locked 
software provided 	file path 
copyright 	unlink msg free 
holders contributors 	repack without 
express implied 	refs error error 
warranties including 	error strbuf 
limited implied 	release strbuf reset 
warranties merchantability 	strbuf git 
fitness 	path safe create 
particular purpose 	leading directories 
disclaimed shall 	error rename git 
copyright owner 	path empty 
contributors liable 	directories error 
direct indirect 	error strerror strbuf 
incidental 	release packed 
special exemplary 	refs loose refs 
consequential damages 	verify refname 
including limited 	available dir verify 
procurement substitute 	refname available 
goods services 	dir lstat git 
loss 	path islnk 
use data 	error resolve error 
profits business 	error rename 
interruption however 	available rename git 
caused theory 	path git 
liability whether 	path error strerror 
contract 	error read 
strict liability 	full strbuf git 
tort including 	path empty 
negligence otherwise 	directories strbuf release 
arising way 	error error 
use software 	rename tmp 
even 	log sha basic 
advised possibility 	error strbuf 
damage note 	release hashcpy write 
encodings ordered 	lockfile commit 
intset enc 	update error strbuf 
intset enc 	release sha 
intset 	basic error strbuf 
enc required 	release write 
encoding provided 	lockfile commit update 
pos given 	error strbuf 
encoding pos 	release rename git 
configured encoding 	path git 
pos 	path error strerror 
configured encoding 	rename git 
create empty 	path git path 
intset resize 	error strerror 
intset search 	close file 
position found 	commit file strbuf 
sets 	git path 
pos position 	autocreate reflog safe 
within intset 	create leading 
present intset 	directories strbuf addf 
sets pos 	strerror open 
position inserted 	empty directories strbuf 
never 	addf open 
found empty 	strbuf addf strerror 
check know 	adjust shared 
cannot find 	perm close log 
know insert 	setup strbuf 
position upgrades 	release strlen strlen 
intset 	xmalloc xsnprintf 
larger encoding 	sha hex sha 
inserts given 	hex copy 
integer first 	reflog msg write 
encoding resize 	full free 
upgrade back 	bare repository 
front 	log setup open 
overwrite values 	log write 
note prepend 	git committer info 
variable used 	strbuf addf 
make sure 	strerror close close 
empty space 	strbuf addf 
either 	strerror files log 
beginning end 	write log 
intset beginning 	write strbuf release 
end insert 	parse strbuf 
integer intset 	addf sha hex 
upgrade encoding 	unlock branch 
necessary 	strbuf addf sha 
need upgrade 	hex unlock 
know either 	file write full 
appended prepended 	sha hex 
lies outside 	write full close 
range existing 	strbuf addf 
values 	file path 
always succeeds 	unlock clear loose 
need curry 	cache log 
success abort 	write strcmp log 
already present 	write strbuf 
call populate 	detach strbuf addf 
pos 	free unlock 
right position 	strcmp resolve strcmp 
insert cannot 	log write 
found integer 	error strbuf release 
intset know 	commit error 
overwrite tail 	unlock unlock locked 
update 	file path 
length determine 	unlink symlink free 
whether belongs 	read log 
random member 	write error strbuf 
sets given 	release create 
position position 	symlink update symref 
range 	reflog fdopen 
function returns 	file error 
range returns 	strerror update symref 
intset length 	reflog commit 
intset blob 	error strerror sha 
size bytes 	basic error 
intset.h 	strbuf release create 
success success 	symref locked 
pos argc 	unlock lstat git 
argv copyright 	path isreg 
pieter noordhuis 	path git path 
pcnoordhuis gmail 	sha hex 
dot 	sha hex strchr 
copyright salvatore 	strtoul isdigit 
sanfilippo antirez 	isdigit isdigit isdigit 
gmail dot 	strtol fopen 
rights reserved 	git path fseek 
redistribution use 	error strerror 
source 	ftell fseek error 
binary forms 	strerror fread 
without modification 	error strerror 
permitted provided 	find beginning line 
following conditions 	strbuf splice 
met redistributions 	show one reflog 
source 	ent strbuf 
code must 	reset strbuf splice 
retain copyright 	show one 
notice list 	reflog ent strbuf 
conditions following 	reset strbuf 
disclaimer redistributions 	splice die fclose 
binary 	strbuf release 
form must 	fopen git path 
reproduce copyright 	strbuf getwholeline 
notice list 	show one reflog 
conditions following 	ent fclose 
disclaimer documentation 	strbuf release opendir 
materials 	git path 
provided distribution 	readdir ends 
neither name 	strbuf addstr stat 
redis names 	git path 
contributors may 	isdir strbuf addch 
used endorse 	reflog read 
promote 	full error strbuf 
products derived 	setlen closedir 
software without 	strbuf init reflog 
specific prior 	strbuf release 
written permission 	strcmp strbuf addf 
software provided 	die list 
copyright 	append list sort 
holders contributors 	update reject 
express implied 	duplicates sha sha 
warranties including 	basic strbuf 
limited implied 	detach strbuf addf 
warranties merchantability 	free hashcmp 
fitness 	write lockfile strbuf 
particular purpose 	detach strbuf 
disclaimed shall 	addf free 
copyright owner 	close strbuf addf 
contributors liable 	commit update 
direct indirect 	loose list append 
incidental 	repack without 
special exemplary 	refs unlink warn 
consequential damages 	git path 
including limited 	clear loose cache 
procurement substitute 	unlock list 
goods services 	clear list clear 
loss 	list die 
use data 	list append list 
profits business 	sort update 
interruption however 	reject duplicates rawref 
caused theory 	die sha 
liability whether 	die verify refname 
contract 	available packed 
strict liability 	refs strbuf addf 
tort including 	strerror sha 
negligence otherwise 	packed commit 
arising way 	packed refs strbuf 
use software 	addf strerror 
even 	list clear prune 
advised possibility 	sha hex 
damage intset 	sha hex hashcpy 
jemalloc.c opt 	memset sha 
abort opt 	basic error strbuf 
junk opt 	release reflog 
junk 	exists unlock git 
alloc opt 	pathdup hold 
junk free 	file update unable 
opt quarantine 	message error 
opt redzone 	strbuf release fdopen 
opt utrace 	file error 
opt 	file path strerror 
xmalloc opt 	prepare reflog 
zero opt 	ent cleanup sha 
narenas valgrind 	close file 
ncpus arenas 	error strerror 
arenas narenas 	write full file 
total 	sha hex 
narenas malloc 	write str full 
init state 	file close 
index size 	error file path 
tab size 	rollback file 
index tab 	commit file error 
malloc 	strerror commit 
initializer malloc 	error free unlock 
initializer init 	rollback file 
init init 	free unlock information 
initialized init 	used along 
size zero 	information entry describe 
metadata 	single cached 
ptr metadata 	reference data structure 
size ptr 	occurs embedded 
size num 	entry entry 
size num 	flag dir zero 
size ptr 	name reference 
ind 	resolves may tag 
arena narenas 	isbroken issymref 
arenas ind 	name referred last 
arena narenas 	reference symlink 
tsd ind 	chain knows peeled 
arena tsd 	field holds 
ind 	peeled reference reference 
tsd oldind 	known peelable 
newind oldarena 	see documentation peel 
newarena ind 	exact definition 
nthreads tsd 	peelable information used 
ind arena 	along information 
tsd 	entry describe level 
ind init 	hierarchy references 
missing arena 	data structure occurs 
arenas cache 	embedded entry 
narenas cache 	entry flag 
narenas actual 	dir entry flag 
arenas 	incomplete determines 
cache bypassp 	whether references directory 
tsd ret 	already read 
choose first 	entry flag incomplete 
tsd tsd 	unset directory 
tsd arena 	loose packed references 
tsd 	already read 
arenas cache 	entry flag incomplete 
tsd tsd 	directory loose 
narenas arena 	references hasn read 
tcache name 	yet subdirectories 
result 	entries within directory 
opts klen 	stored within 
vlen accept 	growable pointers entries 
opts msg 	entries alloc 
klen vlen 	entries sorted sorted 
buf opts 	component name 
klen 	strcmp order 
vlen linklen 	remaining entries unsorted 
saved errno 	loose references 
linkname envname 	read lazily one 
match ret 	directory time 
tsd usize 	directory loose references 
tctx 	read references 
tsd usize 	directory stored incomplete 
tctx size 	stubs created 
tsd usize 	subdirectories subdirectories read 
ret tsd 	reading triggered 
jemalloc silence 	dir entries index 
init 	sorted sorted 
tsd alignment 	name entries appended 
usize tctx 	list unsorted 
tsd alignment 	sorted required thus 
usize tctx 	avoid need 
memptr alignment 	sort list addition 
size 	every reference 
min alignment 	pointer cache 
ret tsd 	contains dir bit 
usize result 	values entry 
posix memalign 	flag issymref ispacked 
ret err 	isbroken bad 
tsd 	name values see 
usize tctx 	refs field 
tsd usize 	entry peeled entry 
tctx ret 	contains correct 
tsd num 	peeled reference might 
size jemalloc 	sha reference 
silence 	tag broken entry 
init tsd 	represents directory 
old ptr 	references entry yet 
old usize 	read disk 
usize tctx 	used dir entries 
tsd old 	representing loose 
ptr 	references entry 
old usize 	represents either reference 
usize prof 	subdirectory references 
active old 	directory reference represented 
tctx tctx 	entry flags 
tsd ptr 	dir containing subdir 
tcache 	member holds 
usize jemalloc 	entries directory read 
silence init 	far flags 
tsd ptr 	incomplete directory subdirectories 
usize tcache 	haven read 
jemalloc silence 	yet incomplete used 
init 	loose reference 
realloc ptr 	directories references represented 
tsd tsd 	entry flags 
size flags 	dir unset member 
usize alignment 	describes reference 
zero tcache 	flag member entry 
arena 	level also 
arena ind 	needed interpret 
tsd size 	contents field words 
flags usize 	much use 
alignment zero 	without enclosing entry 
tcache arena 	reference names 
tsd 	cannot end slash 
usize alignment 	directories names 
zero tcache 	always stored trailing 
arena tsd 	slash top 
usize alignment 	level directory always 
zero tcache 	denoted two 
arena 	nice consequences entries 
tsd size 	subdir sorted 
flags usize 	lexicographically name usually 
alignment zero 	references whole 
tcache arena 	generated lexicographic order 
tctx tsd 	traversing left 
size 	right depth first 
flags usize 	order names 
alignment zero 	references subdirectories 
tcache arena 	cannot conflict therefore 
tsd usize 	presence empty 
tsd old 	subdirectory block creation 
ptr 	similarly named 
old usize 	reference fact reference 
usize alignment 	names leading 
zero tcache 	components conflict separate 
arena tctx 	issue regulated 
tsd old 	verify refname available 
ptr 	please note 
old usize 	name field contains 
size alignment 	fully qualified 
usize zero 	reference subdirectory name 
tcache arena 	space could 
prof active 	saved storing relative 
old 	names would 
tctx tctx 	require full names 
rallocx ptr 	generated fly 
old usize 	iterating would 
size extra 	callback functions always 
alignment zero 	able name 
usize 	passed freed iteration 
ptr old 	issymref ispacked 
usize size 	flags dir flags 
extra alignment 	dir full 
zero tctx 	name reference refs 
usize tsd 	heads master 
ptr 	full name directory 
old usize 	trailing slash 
size extra 	refs heads manually 
alignment zero 	refs bisect 
usize max 	per worktree might 
usize prof 	appear directory 
active 	listing refs main 
old tctx 	repo use 
tctx ptr 	dir might trigger 
size extra 	reading loose 
flags tsd 	refs entry 
usize old 	end dir unsorted 
usize 	entry always 
jemalloc silence 	stored directly dir 
init alignment 	recursion subdirectories 
zero usize 	done optimize entries 
ptr flags 	added order 
tsd tcache 	clear free entries 
size 	dir recursively 
flags usize 	create entry specified 
ptr size 	dirname dirname 
flags tsd 	name directory trailing 
tcache usize 	slash refs 
name oldp 	heads top level 
oldlenp 	directory index 
newp newlen 	entry given refname 
name mibp 	dir non 
miblenp mib 	recursively sorting 
miblen oldp 	dir necessary entry 
oldlenp newp 	found dir 
newlen 	must already complete 
write cbopaque 	search directory 
opts ptr 	entry directly within 
ret malloc 	dir without 
mutex init 	recursing sort dir 
unlikely quarantine 	necessary subdirname 
alloc 	must directory name 
hook unlikely 	end mkdir 
malloc init 	create directory missing 
hard unlikely 	otherwise desired 
malloc initialized 	directory cannot found 
malloc init 	dir must 
hard 	already complete since 
malloc init 	dir complete 
unlikely malloc 	absence subdir means 
init iallocztm 	subdir really 
idalloctm ialloc 	doesn exist 
idalloc unlikely 	therefore create empty 
ialloc 	record mark 
unlikely ialloc 	record complete refname 
unlikely idalloc 	reference name 
malloc cacheline 	find dir within 
ceiling memcpy 	dir hold 
dalloc arena 	refname refname directory 
malloc 	name ends 
mutex arena 	dir dir must 
init locked 	represent top 
malloc mutex 	level directory must 
unlock malloc 	already complete 
mutex malloc 	sort dirs recurse 
mutex 	subdirectories necessary 
unlock tsd 	mkdir create missing 
nominal tsd 	directories otherwise 
arena malloc 	desired directory cannot 
mutex arena 	found find 
bind locked 	entry given 
malloc 	name dir sorting 
mutex unlock 	dirs recursing 
malloc mutex 	subdirectories necessary name 
malloc mutex 	found corresponds 
unlock tsd 	directory entry entry 
arena malloc 	given name 
mutex 	dir recursing subdirectories 
malloc mutex 	necessary refname 
unlock malloc 	name directory ends 
mutex malloc 	directory contents 
mutex unlock 	removal successful number 
tsd arena 	entries remaining 
tsd 	directory entry contained 
arenas cache 	deleted entry 
tsd narenas 	name found please 
cache narenas 	note function 
total dalloc 	deletes entry cache 
tsd arenas 	filesystem ensure 
cache 	cache entries 
tsd narenas 	might symbolic references 
cache tsd 	removed entry 
arenas cache 	updated containing dir 
bypassp tsd 	entries might 
nominal malloc 	made empty removal 
malloc 	dir must 
mutex malloc 	represent top level 
mutex unlock 	directory must 
tsd nominal 	already complete refname 
tsd arenas 	represents reference 
cache tsd 	directory trailing slash 
narenas 	otherwise directory 
cache malloc 	representing refname rather 
mutex memcpy 	one containing 
malloc mutex 	entry dir unsorted 
unlock memset 	recursing subdirectories 
arena init 	necessary dir 
malloc 	must represent top 
mutex arena 	level directory 
init locked 	success emit warning 
malloc mutex 	iff name 
unlock arena 	sha die name 
bind locked 	different sha 
malloc 	duplicate name make 
mutex unlock 	sure conflict 
arena bind 	impossible construction sort 
tsd arena 	entries dir 
arena unbind 	non recursively already 
tsd arenas 	sorted duplicate 
cache 	entries check also 
tsd arenas 	prevents passing 
cache dalloc 	zero length qsort 
malloc mutex 	problem platforms 
tcache stats 	duplicates include broken 
merge malloc 	references iteration 
mutex 	iff reference 
unlock malloc 	described entry resolved 
stats print 	database emit 
issetugid getenv 	warning referred exist 
system info 	current performance 
sysconf malloc 	hack iterating references 
write 	functions current 
malloc write 	current reference entry 
malloc write 	calling callback 
malloc unlikely 	function callback function 
unlikely readlink 	calls peel 
errno secure 	peel first checks 
getenv 	whether reference 
reached malloc 	peeled current reference 
conf next 	usually returns 
strncmp strncmp 	reference peeled version 
chunk dss 	available avoids 
prec malloc 	refname lookup common 
conf 	handle one 
error malloc 	reference style 
conf error 	iteration calling entry 
conf match 	store old 
conf match 	recursive call call 
conf match 	reference dir 
conf 	index range offset 
match conf 	index dir 
match malloc 	recurse subdirectories index 
conf error 	range sorting 
conf match 	iterating function sort 
malloc conf 	dir sorted 
error 	beforehand called references 
malloc conf 	including broken 
error malloc 	ones call reference 
initialized malloc 	dir dir 
initialized malloc 	order refname recurse 
mutex unlock 	subdirectories entry 
malloc 	appears dir dir 
mutex prof 	process version 
boot malloc 	dir input 
conf init 	dirs must already 
atexit malloc 	sorted subdirs 
write abort 	sorted needed called 
boot 	references including 
chunk boot 	broken ones directories 
ctl boot 	descend parallel 
prof boot 	references ignore one 
arena boot 	dir load 
tcache boot 	refs dir memory 
malloc 	cache hard 
mutex init 	work loading loose 
memset arena 	refs done 
init malloc 	dir need recurse 
mutex malloc 	sub directories 
init hard 	even need care 
locked 	sorting traversal 
malloc mutex 	order matter 
unlock malloc 	reference named refname 
mutex unlock 	could created 
malloc ncpus 	without conflicting name 
pthread atfork 	existing reference 
malloc 	dir see verify 
write abort 	refname available 
malloc mutex 	information sake comments 
mutex boot 	function suppose 
malloc alloc 	refname refs foo 
memset init 	bar expand 
init 	dirname prefix including 
malloc mutex 	trailing slash 
malloc init 	still leading dir 
hard needed 	refname refs 
malloc mutex 	foo reference name 
unlock malloc 	conflict unless 
init 	skip found reference 
hard locked 	whose name 
malloc mutex 	proper prefix 
unlock malloc 	refname refs foo 
tsd boot 	skip otherwise 
malloc mutex 	search next component 
unlock 	look directory 
prof boot 	refs foo come 
malloc mutex 	empty know 
unlock malloc 	nothing whole prefix 
init hard 	even still 
recursible malloc 	search conflicts extras 
init 	directory refs 
hard finish 	foo nothing whole 
malloc mutex 	prefix need 
unlock malloc 	looking conflicting references 
mutex unlock 	need looking 
malloc tsd 	conflicting extras leaf 
boot 	refname refs 
imalloc arena 	foo bar point 
prof promoted 	searching reference 
imalloc prof 	name refname 
alloc prep 	isn considered conflict 
prof active 	still need 
unlocked 	check references whose 
unlikely imalloc 	names refs 
prof sample 	foo bar conflict 
imalloc unlikely 	found directory 
prof alloc 	named refname refs 
rollback prof 	foo bar 
malloc 	problem iff contains 
unlikely malloc 	skip count 
init tsd 	references data structure 
fetch unlikely 	instance including 
imalloc prof 	pointer cache packed 
unlikely imalloc 	data freed 
imalloc 	reference count nonzero 
body unlikely 	iff packed 
unlikely malloc 	refs file associated 
write abort 	instance currently 
errno likely 	locked writing 
isalloc tsd 	points associated owned 
allocatedp 	somebody referrer 
utrace jemalloc 	count also incremented 
valgrind malloc 	file locked 
ipalloc arena 	decremented unlocked metadata 
prof promoted 	packed refs 
ipalloc prof 	cache read future 
alloc 	need repository 
prep prof 	full libification submodule 
active unlocked 	name main 
unlikely imemalign 	repo allocate length 
prof sample 	rather flex 
ipalloc unlikely 	main cache initialized 
prof 	correctly used 
alloc rollback 	main packed refs 
prof malloc 	file increment 
unlikely malloc 	reference count packed 
init tsd 	refs decrease 
fetch unlikely 	reference count 
unlikely 	packed refs goes 
malloc write 	zero free 
abort unlikely 	packed refs otherwise 
imemalign prof 	create submodule 
ipalloc unlikely 	cache caches pointer 
likely isalloc 	cache specified 
tsd 	submodule main repository 
allocatedp utrace 	use submodule 
unlikely malloc 	returned structure allocated 
write abort 	initialized necessarily 
unlikely imemalign 	populated freed length 
errno jemalloc 	peeled reference 
valgrind 	line packed refs 
malloc isalloc 	including eol 
icalloc arena 	packed refs header 
prof promoted 	line write 
icalloc prof 	perhaps traits 
alloc prep 	added later trailing 
prof 	space required 
active unlocked 	parse one line 
unlikely icalloc 	packed refs 
prof sample 	file write sha 
icalloc unlikely 	sha pointer 
prof alloc 	refname within line 
rollback 	terminated problem 
prof malloc 	answer everything happens 
unlikely malloc 	answer length 
init tsd 	sha hex representation 
fetch unlikely 	space hex 
unlikely unlikely 	name newline end 
icalloc 	line read 
prof unlikely 	packed refs file 
icalloc unlikely 	dir comment 
unlikely malloc 	line form pack 
write abort 	refs may 
errno likely 	contain zero 
isalloc 	traits interpret traits 
tsd allocatedp 	follows traits 
utrace jemalloc 	probably references peeled 
valgrind malloc 	file contains 
iralloc arena 	peeled reference use 
prof promoted 	peeled references 
iralloc 	refs tags peeled 
prof active 	peeled file 
unlocked prof 	references outside refs 
tctx prof 	tags probably 
alloc prep 	peeled even could 
unlikely irealloc 	find peeled 
prof 	reference use fully 
sample iralloc 	peeled references 
unlikely prof 	file peeled peeled 
alloc rollback 	inversely important 
prof realloc 	references file peeled 
malloc initialized 	recorded peelable 
isalloc 	trait typically 
prof free 	written alongside peeled 
isalloc tsd 	compatibility older 
deallocatedp unlikely 	clients require peeled 
iqalloc jemalloc 	fully peeled 
valgrind free 	perhaps traits later 
malloc 	well regardless 
initialized prof 	file header said 
free tsd 	definitely know 
deallocatedp unlikely 	reference packed cache 
isqalloc jemalloc 	specified cache 
valgrind free 	creating necessary reference 
utrace 	memory packed 
likely tsd 	reference cache may 
fetch ifree 	called packed 
tcache unlikely 	refs file locked 
imemalign jemalloc 	see packed 
valgrind 	refs actually write 
malloc unlikely 	packed refs 
imemalign jemalloc 	file call 
valgrind malloc 	commit packed refs 
mallocx align 	read loose 
specified mallocx 	references dirname dir 
zero 	without recursing 
tcaches mallocx 	dirname must end 
tcache tcache 	dir must 
mallocx arena 	directory entry corresponding 
arena unlikely 	dirname silently 
likely tcache 	ignore astronomically unlikely 
imallocx 	sha sha 
flags decode 	actual consider appearance 
hard unlikely 	loose reference 
ipalloct unlikely 	file repo corruption 
icalloct imalloct 	probably due 
imallocx flags 	software bug mark 
arena 	top level 
prof promoted 	directory complete 
imallocx flags 	read subdirectory hold 
unlikely imallocx 	references create 
flags decode 	incomplete entry refs 
prof alloc 	allow recursive 
prep 	symbolic refs within 
prof active 	reason though 
unlocked likely 	called resolve gitlink 
imallocx flags 	recursive failed 
imallocx prof 	read loose refs 
sample unlikely 	cache refs 
prof 	find refname packed 
alloc rollback 	refs file 
prof malloc 	submodule detached head 
likely unlikely 	old fashioned 
imalloc unlikely 	symlink symref entry 
imallocx flags 	given refname 
decode 	packed references exist 
hard imallocx 	loose file 
flags unlikely 	doesn exist 
malloc init 	check packed options 
tsd fetch 	forwarded resolve 
imallocx prof 	safe loose reference 
imallocx 	file exist 
prof unlikely 	check packed reference 
isalloc tsd 	reference packed 
allocatedp utrace 	reference either function 
jemalloc valgrind 	needs meaningful 
malloc mallocx 	errno failure dwim 
zero 	uses isbroken 
unlikely malloc 	distinguish missing refs 
write abort 	refs present 
utrace iralloct 	invalid complain latter 
arena prof 	stderr know 
promoted iralloct 	whether exists isbroken 
prof 	yet might 
active unlocked 	loop back avoid 
prof tctx 	race condition 
prof alloc 	first lstat 
prep unlikely 	file read link 
irallocx prof 	file somebody 
sample 	changes type file 
iralloct unlikely 	file directory 
prof alloc 	symlink lstat reading 
rollback isalloc 	want report 
prof realloc 	error rather starting 
ixalloc isalloc 	lstat follow 
ixallocx 	normalized refs symlinks 
helper prof 	hand inconsistent 
active unlocked 	lstat retry directory 
prof tctx 	anything open 
prof alloc 	use inconsistent lstat 
prep unlikely 	retry symbolic 
ixallocx 	please note fetch 
prof sample 	head second 
ixallocx helper 	line containing data 
prof alloc 	peel entry 
rollback prof 	possible peel 
realloc mallocx 	status repeel peel 
align 	entry even 
malloc initialized 	old peeled already 
malloc init 	stored call 
tsd fetch 	function packed reference 
isalloc unlikely 	entry might 
unlikely unlikely 	stale might even 
ixallocx 	refer since 
prof ixallocx 	garbage collected entry 
helper unlikely 	knows peeled 
tsd allocatedp 	status unchanged peel 
tsd deallocatedp 	peeled peel 
jemalloc valgrind 	non tag otherwise 
realloc 	peel invalid 
utrace malloc 	reference packed read 
initialized malloc 	entry cache 
init ivsalloc 	hope already know 
isalloc malloc 	peeled optimization 
initialized tsd 	packed references 
fetch 	forcing filling loose 
unlikely tcaches 	reference cache 
mallocx tcache 	could expensive loose 
tcache utrace 	references anyway 
ifree tsd 	usually knows peeled 
fetch likely 	call reference 
mallocx 	specified cache omitting 
align specified 	references containing 
malloc initialized 	dir called references 
inallocx isalloc 	including broken 
tsd fetch 	ones ever returns 
unlikely tcaches 	non zero 
mallocx 	stop iteration otherwise 
tcache tcache 	must make 
utrace isfree 	sure loose refs 
unlikely malloc 	read accessing 
init inallocx 	packed refs 
unlikely malloc 	file avoids race 
init 	condition loose 
ctl byname 	refs migrated packed 
unlikely malloc 	refs file 
init ctl 	simultaneous process memory 
nametomib unlikely 	view migration 
malloc init 	packed cache takes 
ctl 	care making 
bymib stats 	sure view date 
print malloc 	disk call 
initialized malloc 	reference specified cache 
init ivsalloc 	refname begins 
isalloc malloc 	trim non zero 
init 	trim many 
malloc initialized 	characters beginning refname 
malloc initialized 	passing refname 
ctl prefork 	flags include broken 
prof prefork 	include broken 
malloc mutex 	references iteration 
prefork 	ever returns non 
arena prefork 	zero stop 
chunk prefork 	iteration otherwise free 
prefork malloc 	atexit still 
initialized malloc 	looks verify reference 
initialized postfork 	locked old 
parent 	sha fail reference 
chunk postfork 	doesn exist 
parent arena 	mustexist success error 
postfork parent 	write error 
malloc mutex 	message err errno 
postfork parent 	negative want 
prof 	create file directory 
postfork parent 	empty directory 
ctl postfork 	directory contains empty 
parent malloc 	directories locks 
initialized postfork 	returning success failure 
child chunk 	failure errno 
postfork 	something meaningful 
child arena 	trying foo used 
postfork child 	foo bar 
malloc mutex 	exist normal empty 
postfork child 	directory foo 
prof postfork 	remain exist creating 
child 	make sure 
ctl postfork 	existing packed whose 
child data 	name begins 
runtime configuration 	refname packed whose 
options initialized 	name proper 
process running 	prefix refname success 
inside 	fall maybe 
valgrind protects 	somebody deleted one 
arenas initialization 	directories leading 
arenas narenas 	file write entry 
total arenas 	packed refs 
used service 	file specified refname 
external 	peeled non 
requests elements 	write entry 
arenas necessarily 	peeled entry writes 
used arenas 	entry packed 
created lazily 	refs file packed 
needed arenas 	refs file 
narenas 	writing flags passed 
used automatic 	hold file 
multiplexing threads 	update success errors 
arenas arenas 	errno appropriately 
narenas narenas 	nonzero current packed 
total used 	refs holding 
application 	packed refs file 
takes action 	modified since 
create allocate 	last read automatically 
arenas read 	invalidate cache 
initialization read 	read packed refs 
initialization common 	file increment 
jnz 	reference count 
used initializing 	prevent freed write 
recursively allocate 	current version 
used avoid 	packed refs cache 
initialization races 	memory disk 
another constructor 	packed refs file 
binary 	must already 
mallctl setup 	locked writing see 
chunk hooks 	packed refs 
may end 	zero success errors 
running one 	errno nonzero 
malloc init 	rollback lockfile packed 
hard 	refs file 
crash trying 	discard memory packed 
uninitialized force 	reference cache 
initialization malloc 	packed refs file 
init hard 	read anew 
well care 	needed function called 
atomicity 	entry run 
accessed init 	loose references 
initialized since 	loose reference packed 
really matters 	entry packed 
early process 	cache reference pruned 
creation separate 	also prune 
normally 	pack refs data 
starts anything 	pack per 
input pointer 	worktree refs always 
realloc request 	pack tags 
size result 	pack symbolic broken 
pointer function 	refs packed 
prototypes 	cache entry equivalent 
functions referenced 	loose entry 
prior definition 	overwrite existing packed 
begin miscellaneous 	entry info 
support functions 	loose entry schedule 
tsd initialization 	loose reference 
safely 	pruning requested empty 
done side 	parents spare 
effect deallocation 	refs immediate 
possible nothing 	subdirs note munges 
deallocate tls 	name refs 
data via 	heads tags tolerate 
free 	duplicate slashes 
writing tls 	see check refname 
would cause 	format make 
write free 	sure nobody touched 
memory corruption 	unlink rewrite 
quarantine facility 	packed refs file 
gets 	omitting refs 
used side 	listed refnames error 
effect deallocation 	packed refs 
make best 	unchanged write error 
effort attempt 	message err 
initializing tsd 	nonzero refs refnames 
hooking 	needn sorted 
allocation events 	err must look 
functions used 	packed avoid 
instead mcd 	locking nothing 
alloc situations 	refname exists packed 
cannot tolerate 	refs refnames 
tls 	cache packed entries 
variable access 	disappeared acquiring 
free bsd 	write remains loose 
libc uses 	loose file 
bootstrap functions 	name lockfile name 
bootstrap senstive 	minus failed 
situations 	rewrite packed refs 
cannot tolerate 	file loose 
tls variable 	refs might expose 
access tls 	obsolete packed 
allocation early 	reference might even 
data structure 	point garbage 
initialization 	collected people contrib 
create arena 	git workdir 
insert arenas 	git logs 
index ind 	refs path git 
expand arenas 	logs refs 
necessary deallocate 	may live another 
arenas 	device iow 
came malloc 	avoid cross device 
alloc another 	rename errors 
may already 	temporary renamed log 
initialized arenas 	must live 
ind arena 	logs refs success 
actually 	fall rename 
initialize arena 	existing directory ought 
deallocate old 	result isdir 
cache small 	solaris gives enotdir 
allocate cache 	sheesh maybe 
missing function 	another process deleted 
must 	one directories 
always tell 	path newrefname beginning 
truth even 	create reflog 
slow oom 	force create 
cleanup note 	reflog created certain 
tsd nominal 	refs autocreate 
check 	reflog returns non 
recursive allocation 	zero otherwise 
avoidance note 	create regardless name 
arenas cache 	fill err 
bypass check 	failure write sha 
way copy 	open lockfile 
cache 	close lockfile errors 
possible actual 	rollback lockfile 
number arenas 	fill err commit 
increased since 	change loose 
narenas total 	reference already written 
called causes 	loose reference 
correctness 	lockfile also update 
issues unless 	reflogs necessary 
two threads 	specified lockmsg special 
concurrently execute 	hack branch 
arenas extend 	updated directly 
mallctl trust 	head points may 
mallctl 	happen remote 
synchronization prevent 	side push example 
read refreshed 	logically head 
cache init 	reflog updated solution 
arena necessary 	implies reverse 
slow path 	symref information finding 
called 	symrefs pointing 
arena choose 	given branch would 
choose first 	rather costly 
arena lowest 	rare direct update 
number threads 	branch worth 
assigned record 	cheat check head 
index 	cover usage 
first uninitialized 	scenarios even ones 
arena extant 	error check 
arenas use 	commit check ferror 
possible discontinuities 	old name 
terms initialized 	email time 
versus 	tab msg corrupt 
uninitialized arenas 	keep scanning 
due arena 	backwards either beginning 
mallctl use 	buffer end 
unloaded arena 	previous line jump 
least loaded 	end fill 
arena 	next block end 
arenas already 	looking end 
initialized initialize 	file terminating previous 
arena nothing 	line beginning 
nothing nothing 	buffer newline end 
nothing merge 	previous line 
stats 	know complete line 
extant threads 	starting prefix 
racy since 	onto prior data 
individual threads 	collected line 
recording tcache 	process start buffer 
stats events 	start file 
consequence 	previous line 
stats may 	everything one process 
slightly date 	end loop 
time reported 	start buffer file 
threads allocate 	read backwards 
tcache stats 	means middle line 
merge 	note may 
locks bins 	even newline means 
code introduced 	exact end 
acquires arena 	previous line rather 
bin locks 	spot middle 
opposite order 	save away combined 
deadlocks 	data next 
may result 	read call reflog 
end miscellaneous 	indicated name 
support functions 	name must empty 
begin initialization 	end name 
functions look 	used scratch 
ahead 	space contents restored 
one character 	silently ignore 
next time 	fail refname appears 
function called 	transaction acquire 
end input 	locks verify old 
cleanly reached 	values provided 
input 	check values valid 
remains optimistically 	write values 
already consumed 	lockfiles ready activated 
comma one 	keep one 
exists automatically 	lockfile open time 
configure valgrind 	avoid running 
processing 	file descriptors reference 
options valgrind 	already desired 
option remains 	need write freed 
jemalloc compatibility 	upon failure 
reasons runtime 	write lockfile didn 
configuration use 	write anything 
options 	lockfile close 
compiled program 	free file descriptor 
configuration specified 	perform updates 
use contents 	first live commits 
etc malloc 	remain referenced 
conf symbolic 	freed commit update 
link 	freed commit 
name configuration 	update perform deletes 
specified restore 	updates safely 
errno nothing 	completed fail refname 
opts already 	appears transaction 
initialized malloc 	really undefined call 
conf 	function active 
environment variable 	repository existing references 
configuration specified 	locking changing 
chunks always 	packed refs simultaneous 
require least 	processes might 
one header 	change reference time 
page 	existing loose 
many size 	versions references 
data pages 	setting would precedence 
possibly additional 	values remote 
page presence 	helpers create remote 
redzones order 	head master 
simplify 	branches calling function 
options processing 	really check 
use conservative 	none references creating 
bound accommodates 	already exists 
constraints init 	reflog file locked 
must held 	holding reference 
another 	plus might need 
initialized allocator 	update reference 
one acquired 	updateref specified even 
init initializing 	though holding 
recursively allocating 	git dir logs 
busy wait 	reflog locking 
initializing 	implications use file 
completes init 	machinery anyway 
must held 	lot work 
print statistics 	need including cleaning 
exit create 	program exits 
enough scaffolding 	unexpectedly doesn make 
allow 	sense adjust 
recursive allocation 	reference pointed symbolic 
malloc ncpus 	expiring entries 
initialize one 	symbolic reference reflog 
arena rest 	update reference 
lazily created 	remaining reflog entries 
arena 	fmt-merge-msg.c fmt 
choose hard 	merge msg usage 
initialize data 	use branch 
structures may 	desc key branch 
trigger recursive 	tag branch 
allocation init 	head status sha 
must 	data srcs 
held linux 	origins alloc 
threads pthread 	given commit used 
atfork allocates 	table given 
init must 	commit table given 
held smp 	commit line 
systems 	merge parents len 
create one 	origin data 
arena per 	src origin src 
cpu make 	data item 
sure arenas 	pulling head sha 
allocated 	len singular 
practice limit 	plural list name 
enough allow 	desc people 
allocator function 	buffer name buf 
ctl machinery 	name name 
fail allocate 	end elem field 
memory 	people commit 
far lower 	buffer people kind 
limits allocate 	label authors 
initialize arenas 	committers name 
zero practice 	origin data head 
always pre 	rev opts 
zeroed 	count commit branch 
since mmap 	subjects authors 
sure copy 	committers flags sha 
pointer one 	limit ctx 
arena already 	current branch sep 
initialized end 	src data 
initialization 	subsep tagbuf sig 
functions begin 	buf len 
malloc compatible 	tag body first 
functions make 	tag tagbuf 
sure alignment 	sha size len 
large enough 	buf sig 
power 	tagline result head 
avoid division 	parents head 
know isn 	commit len newline 
possible overflow 	sha parent 
multiplication neither 	obj cmit 
operand uses 	opts pos head 
significant 	sha current 
half bits 	branch current branch 
size size 	free merge 
overflow realloc 	parents len newline 
ptr equivalent 	head rev 
free ptr 	argc argv prefix 
realloc 	inpath message 
size equivalent 	shortlog len options 
malloc size 	output ret 
end malloc 	opts strcmp strcmp 
compatible functions 	git config 
begin non 	error strcmp git 
standard 	config git 
functions malloc 	config hashcmp hashcmp 
malloc macro 	find merge 
magic detect 	parent alloc grow 
jemalloc defs 	hashcpy hashcpy 
define malloc 	strlen starts 
malloc 	sha hex find 
glibc provides 	merge parent 
rtld deepbind 	xcalloc hashcpy strstr 
flag dlopen 	unsorted list 
make possible 	lookup list append 
inconsistently reference 	xcalloc init 
libc 	src data starts 
malloc compatible 	list append 
functions https 	starts list append 
bugzilla mozilla 	skip prefix 
show bug 	list append list 
cgi definitions 	append strcmp 
interpose 	strcmp strlen xmemdupz 
hooks glibc 	xstrfmt strcmp 
functions actually 	list append strbuf 
passed extra 	addf strbuf 
argument caller 	addstr strbuf 
address ignored 	addf strbuf addf 
end 	read branch 
non standard 	desc strchrnul strbuf 
functions begin 	addf strbuf 
non standard 	complete line strbuf 
functions allocation 	release strstr 
move possible 	strlen strchrnul isspace 
size 	xmemdupz list 
smaller would 	lookup list insert 
guarantee requested 	integral free 
alignment alignment 	commit buffer record 
constraint serendipitously 	person buf 
satisfied additionally 	unuse commit buffer 
old 	integral integral 
usize may 	strbuf addf strbuf 
current usize 	addf integral 
place large 	integral strbuf addf 
reallocation therefore 	integral git 
query actual 	author info 
usize 	git committer info 
usize isn 	skip prefix 
knowable ixalloc 	starts strbuf addf 
returns extra 	people count 
non zero 	qsort qsort credit 
therefore compute 	people credit 
maximum 	people deref tag 
possible use 	parse sha 
prof alloc 	hex setup revisions 
prep decide 	pending pending 
whether capture 	prepare revision walk 
backtrace prof 	die revision 
realloc 	record person record 
use actual 	person record 
usize decide 	person format commit 
whether sample 	message strbuf 
clamp extra 	ltrim list append 
necessary avoid 	oid hex 
size 	list append 
extra overflow 	strbuf detach people 
check size 	info strbuf 
overflow end 	addf strbuf addf 
non standard 	branch desc 
functions following 	strbuf addf strbuf 
functions 	addf clear 
used threading 	commit marks clear 
libraries protection 	commit marks 
malloc fork 	free commit list 
application creates 	list clear 
allocation main 	list clear list 
calls 	clear strbuf 
fork main 	addstr strbuf addstr 
followed memory 	strbuf addstr 
allocation child 	strbuf addstr strbuf 
process race 	addstr print 
occur results 	joined strbuf addstr 
deadlock 	print joined 
within child 	strbuf addstr 
main may 	print joined strbuf 
forked created 	addstr print 
partially initialized 	joined strcmp strbuf 
allocator ordinarily 	addf strcmp 
jemalloc 	strbuf addch strbuf 
prevents fork 	addf strstr 
malloc races 	strbuf strbuf complete 
via following 	line strbuf 
functions registers 	addch strbuf commented 
initialization pthread 	lines read 
atfork 	sha file parse 
course good 	signature verify 
allocator isn 	buffer strbuf addstr 
fully initialized 	fmt tag 
fork time 	signature strbuf addch 
following library 	strbuf commented 
constructor 	lines strlen strbuf 
solution problem 	insert strbuf 
may still 	release strbuf 
possible trigger 	addch strbuf commented 
deadlock described 	lines strlen 
would involve 	fmt tag signature 
forking 	strbuf release 
via library 	free strbuf addch 
constructor runs 	strbuf addbuf 
jemalloc runs 	strbuf release strchr 
acquire mutexes 	strlen sha 
safe order 	hex parse peel 
release 	type commit 
mutexes fork 	list insert merge 
completed release 	parent lookup 
mutexes fork 	commit commit list 
completed jemalloc 	insert reduce 
declsh disable 	heads pop commit 
warnings 	hashcmp memset 
deprecated system 	resolve refdup 
functions jemalloc 	die starts find 
jemalloc macrosh 	merge parents 
jemalloc always 	strchr strlen handle 
jemalloc used 	line die 
within 	fmt merge msg 
header files 	title fmt 
functions functions 	merge msg sigs 
inlining enabled 	lookup commit 
single definition 	die init revisions 
library functions 	strbuf complete 
inlining 	line shortlog strbuf 
disabled jemalloc 	complete line 
always jemalloc 	free free git 
use files 	config parse 
denoted functions 	options usage options 
always regardless 	strcmp fopen 
whether 	die errno strbuf 
inlining enabled 	read fileno 
disable inlining 	die errno 
make debugging 	strbuf addstr memset 
profiling easier 	fmt merge 
junk.c malloc 	msg write full 
conf 	merge data 
arena dalloc 	per repository merged 
junk small 	tips came 
orig arena 	know know inefficient 
dalloc junk 	won pulling 
large orig 	merging hundreds heads 
huge 	time anyway 
dalloc junk 	subsumed parents point 
orig watch 	line points 
junking saw 	beginning comment branch 
junking ptr 	frotz git 
bin info 	repository git find 
ptr 	repository name 
usize ptr 	point src list 
usize min 	merge count 
max prev 	committer tip 
arena ralloc 	committer merely annotated 
junk large 	skip merge 
orig 	use merge parent 
recently trimmed 	name want 
size shrink 	contaminate field yet 
size ptr 	current branch 
old usize 	line fmt-merge-msg.h merge 
usize detected 	log config 
redzone 	key fmt merge 
corruption ptr 	msg fopen.c 
usize offset 	path mode fopen 
arena redzone 	fopen fstat 
corruption orig 	fileno fclose isdir 
arena dalloc 	fclose order 
junk 	following two lines 
small orig 	important fread 
arena dalloc 	reads directories undefined 
junk large 	including git 
orig huge 	compat avoid 
dalloc junk 	redefinition fopen within 
orig 	git compat 
mallocx ptr 	necessary since fopen 
sallocx xallocx 	macro platforms 
watch junking 	may compiler options 
rallocx ptr 	example aix 
watch junking 	fopen fopen large 
dallocx 	files defined 
test skip 	previous technique merely 
test junk 	undefining fopen 
test skip 	including git compat 
test junk 	inadequate for-each-ref.c 
test skip 	usage argc argv 
test 	prefix format 
junk nallocx 	sorting tail quote 
arena ralloc 	style filter 
junk large 	opts memset 
orig shrink 	memset parse options 
size mallocx 	error usage 
ptr 	options multi bits 
rallocx shrink 	error usage 
size ptr 	options verify format 
ptr test 	usage options 
skip test 	sorting git config 
skip mallocx 	filter refs 
ptr 	sort show item 
dallocx mallocx 	clear warn 
ptr sallocx 	ambiguous refs fsck.c 
dallocx test 	downcased msg 
conditions junk 	type text len 
filling actually 	fsck msg 
occurs 	type options path 
nuanced enough 	skiplist sorted 
doesn make 	buffer sha result 
sense duplicate 	str msg 
decision logic 	msg type 
test code 	options msg msg 
actually 	type type 
check region 	msg type options 
junk filled 	values free 
nothing test 	done equal msg 
underflow test 	report data 
overflow junk 	options desc entry 
allocc 	res result 
junk freec 	commit data options 
lapi.c lua 	parents res 
ident idx 	result tag data 
func func 	options obj 
func size 	data options mode 
res 	name mode 
panicf old 	name len len 
idx idx 	len cmp 
idx idx 	item options retval 
func idx 	sha full 
idx idx 	path empty 
idx 	name dot dotdot 
idx idx 	dotgit zero 
index index 	pad bad modes 
index index 	dup entries 
index index 	properly sorted desc 
idx idx 	mode name 
res 	mode name sha 
num idx 	data size 
idx len 	obj options buffer 
idx idx 	ident obj 
idx idx 	options end commit 
idx len 	buffer size 
fmt 	options sha sha 
argp ret 	graft parent 
fmt ret 	count author count 
argp idx 	err commit 
idx key 	data size options 
idx idx 	buffer ret 
narray 	tag data 
nrec objindex 	size options sha 
obj res 	ret buffer 
idx idx 	eol tag data 
idx key 	size options 
idx idx 	tagged obj data 
objindex 	size options 
obj idx 	obj msg type 
res nargs 	message strlen 
nresults func 	xmalloc tolower strcmp 
func nresults 	open die 
nargs nresults 	read full die 
errfunc 	errno sha 
status func 	hex die sha 
func func 	append hashcmp 
status reader 	close strcmp strcmp 
data chunkname 	strcmp die 
status writer 	parse msg 
data 	parse msg type 
status data 	parse msg 
res idx 	die parse msg 
size val 	type die 
funcindex name 	alloc fsck msg 
val funcindex 	type xstrdup 
name 	strcspn tolower strcmp 
val api 	die init 
check cast 	skiplist die fsck 
api check 	msg type 
registry curr 	free strbuf addch 
func sethvalue 	tolower strbuf 
curr 	addch strbuf addstr 
func cast 	parse init 
hvalue curr 	desc entry isgitlink 
func setobj 	isdir walk 
api incr 	lookup isreg islnk 
top lua 	walk lookup 
lua 	blob error 
checkstack lua 	oid hex parse 
unlock lua 	commit walk 
api checknelems 	walk parse tag 
api check 	walk fsck 
api check 	walk fsck walk 
setobj 	commit fsck 
lua unlock 	walk tag error 
lua lua 	oid hex 
unlock lua 	strlen strlen memcmp 
lua check 	isdir isdir 
lua newthread 	init desc entry 
setthvalue 	extract sha 
api incr 	strchr strcmp strcmp 
top lua 	strcmp hfs 
unlock luai 	dotgit ntfs dotgit 
userstatethread cast 	update entry 
lua api 	verify ordered report 
check 	report report 
setnilvalue api 	report report 
check lua 	report report report 
unlock lua 	report report 
index adr 	report report strchrnul 
api checkvalidindex 	report strcspn 
setobjs 	report report report 
lua unlock 	strcspn report 
lua index 	report report date 
adr api 	overflows strtoul 
checkvalidindex setobjs 	report report isdigit 
setobjs lua 	isdigit isdigit 
unlock 	isdigit report verify 
lua lua 	headers skip 
runerror api 	prefix report sha 
checknelems index 	hex report 
adr api 	skip prefix sha 
checkvalidindex curr 	hex report 
func 	lookup commit graft 
api check 	commit list 
ttistable hvalue 	count report 
lua barrier 	report skip prefix 
setobj lua 	fsck ident 
barrier curr 	report report skip 
func 	prefix report 
lua unlock 	fsck ident report 
lua setobj 	sha hex 
index adr 	commit buffer fsck 
api incr 	commit buffer 
top lua 	unuse commit buffer 
unlock 	read sha 
index adr 	file report report 
ttype unused 	verify headers 
index adr 	skip prefix report 
iscfunction index 	sha hex 
adr tonumber 	report skip prefix 
lua 	report strchr 
type index 	report type gently 
adr ttisuserdata 	report skip 
ttislightuserdata index 	prefix report 
adr index 	strchr report strbuf 
adr lua 	addf check 
rawequal 	refname format report 
obj lua 	skip prefix 
index adr 	report fsck ident 
index adr 	strbuf release 
equalobj lua 	free report fsck 
unlock lua 	tag buffer 
index 	report fsck fsck 
adr index 	commit fsck 
adr lua 	tag report warning 
lessthan lua 	oid hex 
unlock index 	error oid hex 
adr tonumber 	fatal errors 
nvalue 	errors warnings infos 
index adr 	reported warnings 
tonumber nvalue 	ignored convert 
lua number 	lower without underscores 
integer index 	entries ordered 
adr isfalse 	path order means 
index 	directory entry 
adr ttisstring 	ordered adding slash 
lua lua 	end directory 
tostring lua 	called ordered file 
unlock lua 	called sorts 
check index 	first len characters 
adr 	need order 
lua unlock 	next one turn 
tsvalue svalue 	directory entry 
index adr 	git write used 
ttype tsvalue 	write nonsense 
uvalue lua 	entries name one 
getn 	blob one 
hvalue lua 	make sure duplicate 
lua tostring 	entries standard 
tsvalue lua 	modes nonstandard 
unlock index 	early honored full 
adr iscfunction 	mode bits 
clvalue 	find separates header 
index adr 	body body 
ttype rawuvalue 	crime want see 
pvalue index 	terminating last 
adr ttisthread 	header line shallow 
thvalue index 	commit early 
adr 	tags contain tagger 
ttype hvalue 	lines warn 
clvalue thvalue 	data type obj 
lua touserdata 	mark reachable 
lua setnilvalue 	calls callers function 
api incr 	non obj 
top 	hence references parent 
lua unlock 	fld safe 
lua setnvalue 	reference parent safe 
api incr 	error already 
top lua 	displayed check 
unlock 	single reachable obviously 
lua setnvalue 	want parsed 
cast num 	pack file didn 
api incr 	full fsck 
top lua 	pack forget check 
unlock lua 	single unreachable 
lua 	missing unreachable ignore 
check setsvalue 	like miss 
lua newlstr 	since reached want 
api incr 	complain unreachable 
top lua 	since exist unreachable 
unlock lua 	exists show 
pushnil 	asked since something 
lua pushlstring 	prunable used 
strlen lua 	means nothing points 
lua check 	including unreachable 
lua pushvfstring 	objects words tip 
lua unlock 	unreachable objects 
lua 	usually commit 
lua check 	got dropped starting 
start lua 	points interesting 
pushvfstring end 	random unreachable objects 
lua unlock 	show even 
lua lua 	user hasn asked 
check 	unreachable objects 
api checknelems 	deleted branch mistake 
lua cclosure 	prime candidate 
getcurrenv setobj 	start looking example 
setclvalue lua 	otherwise unreachable 
iswhite obj 	unreachable points ignore 
gco 	interesting showed 
api incr 	interesting cases traverse 
top lua 	pending reachable 
unlock lua 	objects look requirements 
setbvalue api 	warn missing 
incr top 	objects rest 
lua 	despite error heads 
unlock lua 	isn really 
setpvalue api 	fatal mean unreachable 
incr top 	longer makes 
lua unlock 	sense since everything 
lua setthvalue 	obviously unreachable 
api 	definition showing dangling 
incr top 	objects valid 
lua unlock 	though dangling objects 
lua index 	likely lost 
adr api 	heads print warning 
checkvalidindex lua 	clear show 
gettable 	unreachable flag detached 
lua unlock 	head directory 
lua index 	name minus trailing 
adr api 	slash verify 
checkvalidindex setsvalue 	gives error messages 
lua lua 	error printed 
gettable 	lookup given 
api incr 	head information ones 
top lua 	git refs 
unlock lua 	also consider index 
index adr 	file implies 
api check 	cache show root 
ttistable 	show tags 
setobj lua 	show unreachable include 
hvalue lua 	reflogs check 
unlock lua 	full connectivity check 
index adr 	strict keep 
api check 	cache objects fsck 
ttistable 	walk options 
setobj lua 	fsck obj options 
getnum hvalue 	head oid 
api incr 	head points errors 
top lua 	found write 
unlock lua 	lost found verbose 
lua 	show progress 
check sethvalue 	show dangling 
lua api 	path obj msg 
incr top 	type err 
lua unlock 	obj err obj 
lua index 	type message 
adr 	pending obj type 
ttype hvalue 	data options 
uvalue ttype 	parent obj obj 
sethvalue api 	result progress 
incr top 	result entry obj 
lua unlock 	obj type 
lua 	data options obj 
index adr 	obj filename 
api checkvalidindex 	obj max obj 
ttype sethvalue 	obj item 
clvalue sethvalue 	commit tag sha 
uvalue setobj 	obj fsck 
thvalue 	obj buffer refs 
setnilvalue api 	refname sha 
incr top 	obj osha 
lua unlock 	nsha email timestamp 
lua api 	message data 
checknelems index 	refname logname oid 
adr 	flag data 
api checkvalidindex 	refname oid flag 
lua settable 	data obj 
lua unlock 	sha path data 
lua api 	basename path 
checknelems index 	data path progress 
adr 	path progress 
api checkvalidindex 	flag error err 
setsvalue lua 	obj fsck 
lua settable 	usage fsck opts 
lua unlock 	argc argv 
lua api 	prefix heads alt 
checknelems 	namelen name 
index adr 	count progress 
api check 	arg sha obj 
ttistable setobj 	mode blob 
lua hvalue 	obj strcmp git 
lua barriert 	config pathname 
hvalue 	strbuf addf free 
lua unlock 	fsck msg 
lua api 	types strbuf release 
checknelems index 	skip prefix 
adr api 	fsck msg type 
check ttistable 	git config 
setobj 	oid hex objreport 
lua setnum 	objreport oid 
hvalue lua 	hex objerror file 
barriert hvalue 	oid hex 
lua unlock 	oid hex mark 
lua api 	parse fsck 
checknelems 	walk free buffer 
index adr 	start progress 
api checkvalidindex 	delay traverse 
ttisnil api 	one display progress 
check ttistable 	stop progress 
hvalue ttype 	sha pack file 
hvalue 	oid hex 
lua objbarriert 	oid hex oid 
hvalue uvalue 	hex git 
lua objbarrier 	pathdup oid hex 
rawuvalue ttype 	safe create 
lua unlock 	leading directories error 
lua 	free fopen 
api checknelems 	die errno stream 
index adr 	blob fileno 
api checkvalidindex 	die errno oid 
api check 	hex fclose 
ttistable ttype 	die errno free 
clvalue 	oid hex 
hvalue uvalue 	check reachable check 
hvalue sethvalue 	unreachable traverse 
thvalue hvalue 	reachable max 
lua objbarrier 	index indexed check 
gcvalue hvalue 	oid hex 
lua 	fsck walk objerror 
unlock lua 	fsck free 
api checknelems 	buffer free commit 
checkresults lua 	buffer oid 
call adjustresults 	hex oid hex 
lua unlock 	oid hex 
cast 	parse error sha 
lua call 	hex fsck 
lua api 	obj sha lookup 
checknelems checkresults 	mark reachable 
index adr 	error sha hex 
api checkvalidindex 	sha hex 
savestack 	sha hex fsck 
lua pcall 	handle reflog 
savestack adjustresults 	sha fsck handle 
lua unlock 	reflog sha 
cast lua 	reflog ent 
cclosure getcurrenv 	parse error oid 
setclvalue 	hex branch 
api incr 	error mark reachable 
top setpvalue 	oid fsck 
api incr 	handle rawref reflog 
top lua 	fsck sha 
call lua 	starts display progress 
lua 	start progress 
pcall savestack 	loose file objdir 
lua unlock 	display progress 
lua lua 	stop progress resolve 
init lua 	error strcmp 
protectedparser lua 	starts error oid 
unlock 	error parse 
lua api 	error sha hex 
checknelems lfunction 	mark reachable 
lua dump 	objerror fsck cache 
clvalue lua 	parse options 
unlock lua 	isatty git 
lua 	config fsck head 
fullgc cast 	link fsck 
cast cast 	dir directory prepare 
lua step 	alt odb 
lua unlock 	strbuf fsck dir 
lua api 	strbuf release 
checknelems 	prepare packed git 
lua errormsg 	open pack 
lua unlock 	index start progress 
lua index 	verify pack 
adr api 	stop progress sha 
check ttistable 	lookup mark 
lua 	reachable error heads 
next hvalue 	read cache 
api incr 	isgitlink lookup blob 
top lua 	mark reachable 
unlock lua 	fsck cache 
api checknelems 	check connectivity fatal 
lua 	errors errors 
check lua 	warnings infos reported 
concat cast 	warnings ignored 
setsvalue lua 	convert lower without 
newlstr api 	underscores entries 
incr top 	ordered path order 
lua 	means directory 
unlock lua 	entry ordered adding 
lua unlock 	slash end 
lua lua 	directory called ordered 
unlock lua 	file called 
lua check 	sorts first len 
lua 	characters need 
newudata getcurrenv 	order next one 
setuvalue api 	turn directory 
incr top 	entry git write 
lua unlock 	used write 
ttisfunction clvalue 	nonsense entries 
getstr 	name one blob 
lua aux 	one make 
upvalue index 	sure duplicate entries 
adr setobj 	standard modes 
api incr 	nonstandard early honored 
top lua 	full mode 
unlock 	bits find separates 
lua index 	header body 
adr api 	body crime want 
checknelems aux 	see terminating 
upvalue setobj 	last header line 
lua barrier 	shallow commit 
clvalue 	early tags contain 
lua unlock 	tagger lines 
lapi roberto 	warn data type 
exp lua 	obj mark 
api see 	reachable calls callers 
copyright notice 	function non 
lua 	obj hence 
pseudo indices 	references parent fld 
enclosing function 	safe reference 
use table 	parent safe error 
environment stack 	already displayed 
overflow basic 	check single reachable 
stack 	obviously want 
manipulation subtract 	parsed pack file 
index index 	didn full 
negative test 	fsck pack forget 
incompatible code 	check single 
function upvalue 	unreachable missing unreachable 
access 	ignore like 
functions stack 	miss since reached 
may call 	want complain 
tag method 	unreachable since exist 
may call 	unreachable exists 
tag method 	show asked since 
lua 	something prunable 
tostring may 	used means 
create conversion 	nothing points including 
failed previous 	unreachable objects 
call may 	words tip unreachable 
reallocate stack 	objects usually 
lua 	commit got dropped 
tostring may 	starting points 
create push 	interesting random unreachable 
functions stack 	objects show 
ensure functions 	even user hasn 
lua stack 	asked unreachable 
functions 	objects deleted branch 
stack lua 	mistake prime 
pop index 	candidate start looking 
pop load 	example otherwise 
call functions 	unreachable unreachable points 
run lua 	ignore interesting 
code 	showed interesting 
execute call 	cases traverse pending 
data call 	reachable objects 
function called 	look requirements warn 
execute call 	missing objects 
data ccall 	rest despite error 
push 	heads isn 
function push 	really fatal mean 
argument garbage 	unreachable longer 
collection function 	makes sense since 
values expressed 	everything obviously 
kbytes bytes 	unreachable definition showing 
end 	dangling objects 
cycle signal 	valid though dangling 
invalid option 	objects likely 
miscellaneous functions 	lost heads print 
avoid warnings 	warning clear 
elements key 	show unreachable flag 
push 	detached head 
empty nothing 	directory name 
lapi.h lapi 	minus trailing slash 
roberto exp 	verify gives 
auxiliary functions 	error messages error 
lua api 	printed lookup 
see 	given head information 
copyright notice 	ones git 
lua latency.c 	refs also consider 
privdata key 	index file 
key key 	implies cache fsck.c 
privdata val 	downcased msg 
latency 	type text len 
time series 	fsck msg 
dict type 	type options path 
buf latency 	skiplist sorted 
prev reset 	buffer sha result 
resets sum 	str msg 
delta 	msg type options 
report advise 	msg msg 
better advise 	type type 
slowlog enabled 	msg type options 
advise slowlog 	values free 
tuning advise 	done equal msg 
slowlog 	report data 
inspect advise 	options desc entry 
disk contention 	res result 
advise scheduler 	commit data options 
advise data 	parents res 
writeback advise 	result tag data 
appendfsync 	options obj 
advise local 	data options mode 
disk advise 	name mode 
ssd advise 	name len len 
write load 	len cmp 
info advise 	item options retval 
advise 	sha full 
large objects 	path empty name 
advise mass 	dot dotdot 
eviction advise 	dotgit zero 
relax fsync 	pad bad modes 
policy advise 	dup entries 
disable 	properly sorted desc 
thp advices 	mode name 
eventnum fork 	mode name sha 
quality replylen 	data size 
last seq 	obj options buffer 
graph max 	ident obj 
elapsed 	options end commit 
buf graph 	buffer size 
report resets 	options sha sha 
unused strcmp 	graft parent 
dict gen 	count author count 
hash function 	err commit 
strlen 	data size options 
fopen fgets 	buffer ret 
fclose fclose 	tag data 
strstr zmalloc 	size options sha 
smap bytes 	ret buffer 
field dict 	eol tag data 
create 	size options 
dict fetch 	tagged obj data 
time zmalloc 	size options 
memset dict 	obj msg type 
zstrdup time 	message strlen 
dict safe 	xmalloc tolower strcmp 
iterator 	open die 
dict next 	read full die 
dict key 	errno sha 
strcasecmp dict 	hex die sha 
dict release 	append hashcmp 
iterator dict 	close strcmp strcmp 
fetch 	strcmp die 
time sdsempty 	parse msg parse 
dict size 	msg type 
sdscat dict 	parse msg 
safe iterator 	die parse msg 
dict next 	type die 
dict 	alloc fsck msg 
key dict 	type xstrdup 
val sdscat 	strcspn tolower strcmp 
analyze latency 	die init 
sdscatprintf strcasecmp 	skiplist die fsck 
sdscatprintf strcasecmp 	msg type 
strcasecmp 	free strbuf addch 
strcasecmp strcasecmp 	tolower strbuf 
strcasecmp strcasecmp 	addch strbuf addstr 
strcasecmp strcasecmp 	parse init 
strcasecmp strcasecmp 	desc entry isgitlink 
strcasecmp strcasecmp 	isdir walk 
strcasecmp 	lookup isreg islnk 
sdscatlen dict 	walk lookup 
release iterator 	blob error oid 
thp anon 	hex parse 
huge pages 	commit walk 
size sdscat 	walk parse tag 
sdscat 	walk fsck 
sdscat sdscat 	walk fsck walk 
sdscatprintf sdscatprintf 	commit fsck 
sdscat sdscat 	walk tag error 
sdscat sdscat 	oid hex 
sdscat sdscat 	strlen strlen memcmp 
sdscat 	isdir isdir 
sdscat sdscat 	init desc entry 
sdscat sdscat 	extract sha 
sdscat sdscat 	strchr strcmp strcmp 
deferred multi 	strcmp hfs 
bulk length 	dotgit ntfs dotgit 
reply 	update entry 
multi bulk 	verify ordered report 
len reply 	report report 
reply deferred 	report report report 
multi bulk 	report report 
length reply 	report report 
multi 	report report strchrnul 
bulk len 	report strcspn 
dict size 	report report report 
dict iterator 	strcspn report 
dict next 	report report date 
dict key 	overflows strtoul 
dict 	report report isdigit 
val reply 	isdigit isdigit 
multi bulk 	isdigit report verify 
len reply 	headers skip 
bulk reply 	prefix report sha 
reply reply 	hex report 
dict 	skip prefix sha 
release iterator 	hex report 
create sparkline 	lookup commit graft 
sequence sdsempty 	commit list 
time snprintf 	count report report 
snprintf snprintf 	skip prefix 
snprintf 	fsck ident 
sparkline sequence 	report report skip 
sample sdscatprintf 	prefix report 
sdscatlen sdscatlen 	fsck ident report 
sparkline render 	sha hex 
free 	commit buffer fsck 
sparkline sequence 	commit buffer 
strcasecmp dict 	unuse commit buffer 
fetch reply 	read sha 
multi bulk 	file report report 
len latency 	verify headers 
command 	skip prefix report 
reply samples 	sha hex 
strcasecmp dict 	report skip prefix 
find dict 	report strchr 
val dict 	report type gently 
key latency 	report skip 
command 	prefix report 
gen sparkeline 	strchr report strbuf 
reply bulk 	addf check 
sdsfree strcasecmp 	refname format report 
latency command 	skip prefix 
reply latest 	report fsck ident 
events 	strbuf release 
strcasecmp create 	free report fsck 
latency report 	tag buffer 
reply bulk 	report fsck fsck 
buffer sdslen 	commit fsck 
sdsfree strcasecmp 	tag report warning 
reply 	oid hex 
latency reset 	error oid hex 
latency reset 	fatal errors 
reply reply 	errors warnings infos 
reply error 	reported warnings 
format latency 	ignored convert lower 
monitor 	without underscores 
allows easily 	entries ordered 
observe sources 	path order means 
latency redis 	directory entry 
instance latency 	ordered adding slash 
command different 	end directory 
latency 	called ordered file 
sources monitored 	called sorts 
like disk 	first len characters 
execution commands 	need order 
fork system 	next one turn 
call forth 	directory entry 
copyright 	git write used 
salvatore sanfilippo 	write nonsense 
antirez gmail 	entries name one 
dot rights 	blob one 
reserved redistribution 	make sure duplicate 
use source 	entries standard 
binary 	modes nonstandard early 
forms without 	honored full 
modification permitted 	mode bits 
provided following 	find separates header 
conditions met 	body body 
redistributions source 	crime want see 
code 	terminating last 
must retain 	header line shallow 
copyright notice 	commit early 
list conditions 	tags contain tagger 
following disclaimer 	lines warn 
redistributions binary 	data type obj 
form 	mark reachable 
must reproduce 	calls callers function 
copyright notice 	non obj 
list conditions 	hence references parent 
following disclaimer 	fld safe 
documentation materials 	reference parent safe 
provided 	error already 
distribution neither 	displayed check single 
name redis 	reachable obviously 
names contributors 	want parsed 
may used 	pack file didn 
endorse promote 	full fsck 
products 	pack forget check 
derived software 	single unreachable 
without specific 	missing unreachable ignore 
prior written 	like miss 
permission software 	since reached want 
provided copyright 	complain unreachable 
holders 	since exist unreachable 
contributors express 	exists show 
implied warranties 	asked since something 
including limited 	prunable used 
implied warranties 	means nothing points 
merchantability fitness 	including unreachable 
particular 	objects words tip 
purpose disclaimed 	unreachable objects 
shall copyright 	usually commit 
owner contributors 	got dropped starting 
liable direct 	points interesting 
indirect incidental 	random unreachable objects 
special 	show even 
exemplary consequential 	user hasn asked 
damages including 	unreachable objects 
limited procurement 	deleted branch mistake 
substitute goods 	prime candidate 
services loss 	start looking example 
use 	otherwise unreachable 
data profits 	unreachable points ignore 
business interruption 	interesting showed 
however caused 	interesting cases traverse 
theory liability 	pending reachable 
whether contract 	objects look requirements 
strict 	warn missing 
liability tort 	objects rest despite 
including negligence 	error heads 
otherwise arising 	isn really 
way use 	fatal mean unreachable 
software even 	longer makes 
advised 	sense since everything 
possibility damage 	obviously unreachable 
dictionary type 	definition showing dangling 
latency events 	objects valid 
hash function 	though dangling objects 
key dup 	likely lost 
val 	heads print warning 
dup key 	clear show 
compare key 	unreachable flag detached 
destructor val 	head directory 
destructor utility 	name minus trailing 
functions returns 	slash verify 
transparent 	gives error messages 
huge pages 	error printed 
support enabled 	lookup given head 
kernel otherwise 	information ones 
unable check 	git refs 
returned report 	also consider index 
amount 	file implies 
anon huge 	cache show root 
pages smap 	show tags 
bytes function 	show unreachable include 
non zero 	reflogs check 
process targeted 	full connectivity check 
thp 	strict keep 
support likely 	cache objects fsck 
memory usage 	walk options 
latency issues 	fsck obj options 
latency api 	head oid 
latency monitor 	head points errors 
initialization 	found write 
need create 	lost found verbose 
dictionary time 	show progress 
series time 	show dangling path 
serie craeted 	obj msg 
demand order 	type err 
avoid 	obj err obj 
list maintain 	type message 
specified sample 	pending obj type 
specified time 	data options 
series function 	parent obj obj 
usually called 	result progress 
via 	result entry obj 
latency sample 	obj type 
needed macro 	data options obj 
adds sample 	obj filename 
latency higher 	obj max obj 
server latency 	obj item 
monitor 	commit tag sha 
threshold create 	obj fsck 
time series 	obj buffer refs 
exist previous 	refname sha 
sample second 	obj osha 
update old 	nsha email timestamp 
sample 	message data 
latency old 	refname logname oid 
one reset 	flag data 
data specified 	refname oid flag 
events data 	data obj 
note even 	sha path data 
reset 	basename path 
makes code 	data path progress 
simpler small 	path progress 
max number 	flag error err 
events latency 	obj fsck 
reporting doctor 	usage fsck opts 
analyze 	argc argv 
samples avaialble 	prefix heads alt 
given structure 	namelen name 
populate different 	count progress arg 
metrics average 	sha obj 
mad min 	mode blob 
max 	obj strcmp git 
forth check 	config pathname 
latency definition 	strbuf addf free 
latenct stat 	fsck msg 
info specified 	types strbuf release 
elements structure 	skip prefix 
populate 	fsck msg type 
zero values 	git config 
first pass 	oid hex objreport 
populate everything 	objreport oid 
mad track 	hex objerror file 
oldest time 	oid hex 
period 	oid hex mark 
far avg 	parse fsck 
actually sum 	walk free buffer 
latencies period 	start progress 
oldest time 	delay traverse one 
need make 	display progress 
first 	stop progress 
average second 	sha pack file 
range seconds 	oid hex 
second pass 	oid hex oid 
compute mad 	hex git 
create human 	pathdup oid hex 
readable 	safe create 
report latency 	leading directories error 
events redis 	free fopen 
instance better 	die errno stream 
machines enable 	blob fileno 
slowlog reconfigure 	die errno oid 
slowlog 	hex fclose 
check slowlog 	die errno free 
lower disk 	oid hex 
contention intrinsic 	check reachable check 
latency data 	unreachable traverse 
writeback fsync 	reachable max index 
rewrites 	indexed check 
avoid remote 	oid hex 
disks use 	fsck walk objerror 
ssd drive 	fsck free 
print info 	buffer free commit 
aof write 	buffer oid 
load 	hex oid hex 
use higher 	oid hex 
deletion large 	parse error sha 
objects avoid 	hex fsck 
mass eviction 	obj sha lookup 
keys appendfsync 	mark reachable 
always 	error sha hex 
slow anon 	sha hex 
huge pages 	sha hex fsck 
detected asap 	handle reflog 
latency engine 	sha fsck handle 
disabled looks 	reflog sha 
like 	reflog ent parse 
never enabled 	error oid 
far show 	hex branch 
events stats 	error mark reachable 
related comment 	oid fsck 
depending values 	handle rawref reflog 
fork 	fsck sha 
potentially commands 	starts display progress 
fast command 	start progress 
aof expire 	loose file objdir 
cycle eviction 	display progress 
cycle non 	stop progress resolve 
advices 	error strcmp 
suggestions accumulated 	starts error oid 
far better 	error parse 
slow log 	error sha hex 
intrinsic latency 	mark reachable 
aof disk 	objerror fsck cache 
latency 	parse options 
latency command 	isatty git 
implementation latency 	config fsck head 
command helper 	link fsck 
produce time 	dir directory prepare 
delay reply 	alt odb 
samples 	strbuf fsck dir 
memory specified 	strbuf release 
time series 	prepare packed git 
latency command 	open pack 
helper produce 	index start progress 
reply latest 	verify pack 
subcommand 	stop progress sha 
listing last 	lookup mark 
latency sample 	reachable error heads 
every type 	read cache 
registered far 	isgitlink lookup blob 
update min 	mark reachable 
max 	fsck cache check 
use label 	connectivity fatal 
number seconds 	errors errors 
minutes hours 	warnings infos reported 
days ago 	warnings ignored 
happened latency 	convert lower without 
command 	underscores entries 
implementations latency 	ordered path order 
samples time 	means directory 
latency samples 	entry ordered adding 
specified latency 	slash end 
latest latest 	directory called ordered 
latency 	file called 
events classes 	sorts first len 
latency doctor 	characters need 
returns human 	order next one 
readable analysis 	turn directory 
instance latency 	entry git write 
latency 	used write 
graph provide 	nonsense entries name 
ascii graph 	one blob 
latency specified 	one make 
latency history 	sure duplicate entries 
latency graph 	standard modes 
latency 	nonstandard early honored 
latest latency 	full mode 
doctor latency 	bits find separates 
reset common 	header body 
error user 	body crime want 
asks latency 	see terminating 
information 	last header line 
latency.h time 	shallow commit 
latency idx 	early tags contain 
max samples 	tagger lines 
time high 	warn data type 
avg min 	obj mark 
max 	reachable calls callers 
mad samples 	function non 
period latency 	obj hence references 
latency latency 	parent fld 
monitor api 	safe reference 
header file 	parent safe error 
see 	already displayed 
latency information 	check single reachable 
copyright salvatore 	obviously want 
sanfilippo antirez 	parsed pack file 
gmail dot 	didn full 
rights reserved 	fsck pack forget 
redistribution 	check single 
use source 	unreachable missing unreachable 
binary forms 	ignore like 
without modification 	miss since reached 
permitted provided 	want complain 
following conditions 	unreachable since exist 
met 	unreachable exists 
redistributions source 	show asked since 
code must 	something prunable 
retain copyright 	used means 
notice list 	nothing points including 
conditions following 	unreachable objects 
disclaimer 	words tip unreachable 
redistributions binary 	objects usually 
form must 	commit got dropped 
reproduce copyright 	starting points 
notice list 	interesting random unreachable 
conditions following 	objects show 
disclaimer 	even user hasn 
documentation materials 	asked unreachable 
provided distribution 	objects deleted branch 
neither name 	mistake prime 
redis names 	candidate start looking 
contributors may 	example otherwise 
used 	unreachable unreachable points 
endorse promote 	ignore interesting 
products derived 	showed interesting cases 
software without 	traverse pending 
specific prior 	reachable objects 
written permission 	look requirements warn 
software 	missing objects 
provided copyright 	rest despite error 
holders contributors 	heads isn 
express implied 	really fatal mean 
warranties including 	unreachable longer 
limited implied 	makes sense since 
warranties 	everything obviously 
merchantability fitness 	unreachable definition showing 
particular purpose 	dangling objects 
disclaimed shall 	valid though dangling 
copyright owner 	objects likely 
contributors liable 	lost heads print 
direct 	warning clear 
indirect incidental 	show unreachable flag 
special exemplary 	detached head 
consequential damages 	directory name minus 
including limited 	trailing slash 
procurement substitute 	verify gives 
goods 	error messages error 
services loss 	printed lookup 
use data 	given head information 
profits business 	ones git 
interruption however 	refs also consider 
caused theory 	index file 
liability 	implies cache fsck.h 
whether contract 	options msg 
strict liability 	msg type options 
tort including 	values msg 
negligence otherwise 	msg type obj 
arising way 	type message 
use 	walk error func 
software even 	msg type 
advised possibility 	skiplist obj data 
damage history 	options obj 
length every 	data size options 
monitored representation 	callback function 
latency 	fsck walk 
sample sampling 	type expected type 
time latency 	obj everything 
observed milliseconds 	error signaled abort 
use time 	error signaled 
force bytes 	abort callback fsck 
usage 	type fsck 
everywhere latency 	error fsck warn 
milliseconds latency 	descend linked 
time series 	child objects error 
given index 	processing callback 
next sample 	lead abort first 
store 	signaled error 
max latency 	errors everything passed 
observed latest 	data local 
history latency 	read gc.c builtin 
statistics structure 	usage pack 
absolute max 	refs prune 
observed 	reflogs aggressive depth 
since latest 	aggressive window 
reset average 	threshold pack limit 
current samples 	detach prune 
min current 	expire prune worktrees 
samples max 	expire pack 
current 	refs cmd reflog 
samples mean 	repack prune 
absolute deviation 	prune worktrees rerere 
number non 	pidfile log 
zero samples 	pack garbage seen 
number seconds 	bits path 
since 	key output signo 
first latency 	path objdir 
monitoring macros 	dir ent threshold 
start monitoring 	num loose 
current time 	needed cnt force 
end monitoring 	ret pid 
compute 	host pid 
difference current 	pidfile path locking 
time check 	host exit 
amount time 	ret argc argv 
elapsed sample 	prefix aggressive 
elapsed time 	quiet force name 
configured 	pid daemonized 
threshold time 	builtin options unlink 
nested latency 	warn list 
lauxlib.c narg 	clear list append 
extramsg narg 	git config 
tname msg 	strcmp approxidate approxidate 
narg 	git die 
tag level 	config fstat file 
fmt argp 	commit file 
narg def 	rollback file fflush 
lst name 	process log 
tname 	file process log 
tname space 	file sigchain 
mes narg 	pop git 
narg narg 	config strcmp git 
len narg 	config git 
def len 	config git config 
narg 	git config 
narg def 	git config git 
narg narg 	config git 
def obj 	config date git 
obj libname 	config date 
size libname 	git config directory 
nup 	snprintf warning 
size topop 	opendir readdir strspn 
wild idx 	closedir prepare 
fname szhint 	packed git strcmp 
toget toplen 	argv push 
size fnameindex 	argv push argv 
serr 	pushf many 
filename filename 	packs repack option 
status readstatus 	many loose 
fnameindex size 	objects run 
buff size 	hook tempfile active 
name ptr 	gethostname xsnprintf 
osize 	git pathdup hold 
nsize lua 	file update 
getstack lua 	fopen memset fstat 
error lua 	fileno time 
getinfo strcmp 	fscanf strcmp kill 
lua error 	fclose rollback 
lua 	file free strbuf 
error lua 	addf getpid 
pushfstring lua 	write full strbuf 
lua argerror 	release commit 
lua typerror 	file tempfile free 
lua lua 	strbuf read 
getstack 	file git path 
lua getinfo 	error git 
lua pushfstring 	path strbuf release 
lua pushliteral 	run command 
start lua 	opt error 
lua pushvfstring 	run command opt 
end 	error strcmp 
lua concat 	usage options argv 
lua error 	pushl argv 
lua optstring 	pushl argv pushl 
lua checkstring 	argv pushl 
strcmp lua 	argv pushl argv 
argerror 	pushl config 
lua pushfstring 	bare repository parse 
lua getfield 	options usage 
lua isnil 	options argv push 
lua pop 	argv pushf 
lua newtable 	argv pushf argv 
lua 	push need 
pushvalue lua 	report last error 
setfield lua 	repack daemonize 
touserdata lua 	repack option 
getmetatable lua 	repo die hold 
getfield lua 	file update 
rawequal 	git path dup 
lua pop 	file sigchain 
lua typerror 	push common atexit 
lua checkstack 	repack run 
lua error 	command opt error 
lua type 	argv push 
tag 	argv push run 
error lua 	command opt 
type lua 	error argv push 
argerror lua 	run command 
tolstring tag 	opt error run 
error lua 	command opt 
isnoneornil 	error reprepare packed 
strlen lua 	git clean 
checklstring lua 	pack garbage many 
tonumber lua 	loose objects 
isnumber tag 	warning git 
error lua 	builtin command cleanup 
opt 	unreachable files 
lua tointeger 	optimize repository copyright 
lua isnumber 	james bowes 
tag error 	git copyright shawn 
lua opt 	pearce quickly 
lua getmetatable 	check needed estimating 
lua 	many loose 
pushstring lua 	objects sha evenly 
rawget lua 	distributed check 
isnil lua 	one reasonable estimate 
pop lua 	perhaps check 
abs index 	size pack count 
lua 	small ones 
getmetafield lua 	setting negative disable 
pushvalue lua 	automatic many 
call lua 	loose objects many 
openlib libsize 	packs run 
lua findtable 	repack many 
lua 	packs run repack 
getfield lua 	otherwise tell 
istable lua 	caller need success 
pop lua 	hostname running 
findtable lua 	already locked hour 
error lua 	limit generous 
pushvalue 	never take hand 
lua setfield 	really need 
lua lua 	strict limit running 
insert lua 	one day 
pushvalue lua 	late big problem 
pushcclosure lua 	force used 
setfield 	manual user verifies 
lua pop 	running gentle 
lua type 	concurrent remote hosts 
lua tointeger 	least intrusive 
lua pop 	possible failure daemonize 
lua getfield 	foreground quiet 
lua 	get-tar-commit-id.c builtin 
isnil lua 	tar commit usage 
pop lua 	argc argv 
newtable lua 	prefix buffer header 
pushvalue lua 	content comment 
setmetatable lua 	usage read full 
pushliteral 	die skip 
lua setfield 	prefix write full 
lua pushvalue 	die errno 
lua setfield 	copyright rene scharfe 
abs index 	ustar header 
lua pushliteral 	extended header content 
lua 	gettext.c retval 
rawget checkint 	poison requested fmt 
lua pushliteral 	buf ret 
lua pushinteger 	charset domain podir 
lua rawset 	utf getenv 
getsizes lua 	setlocale strcmp 
pushvalue 	strcmp getenv start 
lua pushinteger 	vsnprintf end 
lua rawset 	setlocale locale charset 
lua pop 	bind textdomain 
abs index 	codeset test vsnprintf 
lua pushliteral 	setlocale getenv 
lua 	bindtextdomain setlocale setlocale 
rawget checkint 	init gettext 
getsizes lua 	charset textdomain strcmp 
pushvalue lua 	utf strwidth 
rawget checkint 	strlen copyright arnfj 
lua objlen 	bjarmason guess 
strlen 	user preferred languages 
lua buffinit 	language environment 
strstr lua 	variable messages locale 
addlstring lua 	category gettext 
addstring lua 	defined result colon 
addstring lua 	separated list 
pushresult 	like trick 
lua tostring 	arranges messages emitted 
lua pushvalue 	user requested 
strchr strlen 	encoding avoids setting 
lua pushlstring 	ctype environment 
lua rawget 	whole program primarily 
lua 	done avoid 
isnil lua 	bug vsnprintf gnu 
pop lua 	library triggered 
createtable lua 	vsnprintf broken error 
pushlstring lua 	git repository 
pushvalue lua 	inspecting utf locale 
settable 	commit contains 
lua istable 	iso encoded author 
lua pop 	name locale 
lua bufflen 	aware vsnprintf won 
lua pushlstring 	interpolate format 
lua strlen 	argument due mismatch 
lua 	data encoding 
strlen lua 	locale even 
concat emptybuffer 	wasn bug wouldn 
adjuststack lua 	want use 
addchar lua 	ctype point require 
addlstring strlen 	auditing code 
emptybuffer 	uses functions whose 
lua concat 	semantics modified 
lua tolstring 	ctype setting messages 
bufffree memcpy 	creates problem 
lua pop 	since declare encoding 
emptybuffer lua 	files gettext 
insert 	implementation recode user 
adjuststack abs 	locale without 
index lua 	ctype emit something 
isnil lua 	like git 
pop lua 	init icelandic locale 
rawgeti lua 	til git 
tointeger 	lind hlagh git 
lua pop 	gettext knows 
lua rawgeti 	encoding file 
lua rawseti 	haven told user 
lua objlen 	encoding non 
lua rawseti 	ascii characters encoded 
abs 	question marks 
index lua 	luck ctype environment 
rawgeti lua 	call langinfo 
rawseti lua 	bind textdomain codeset 
pushinteger lua 	suffices tell 
rawseti feof 	gettext encoding emit 
fread 	say til 
strerror lua 	git lind hlagh 
tostring lua 	git equivalent 
pushfstring lua 	iso emitted iso 
lua gettop 	locale change 
lua pushliteral 	way advantages setting 
lua 	ctype talk 
pushfstring fopen 	user language 
errfile getc 	encoding without major 
getc getc 	drawbacks changed 
freopen errfile 	semantics functions rely 
getc ungetc 	however foreign 
lua 	functions message catalogs 
load lua 	aren neat 
tostring ferror 	trick still problem 
fclose lua 	call perror 
settop errfile 	include stdio include 
lua lua 	locale include 
load 	errno main setlocale 
lua loadbuffer 	messages setlocale 
strlen free 	ctype errno enodev 
realloc lua 	perror test 
tostring lua 	running give message 
newstate lua 	question marks 
atpanic 	language utf test 
lauxlib roberto 	test kein 
exp auxiliary 	passendes ger 
functions building 	gefunden vsnprintf bug 
lua libraries 	since glibc 
see copyright 	could simply ctype 
notice 	environment would 
lua file 	make things like 
uses official 	external perror 
api lua 	messages work see 
function declared 	gettext setlocale 
could written 	sanity gettext tests 
application 	regression tests 
function free 	http sourceware bugzilla 
list references 	show bug 
convert stack 	cgi content type 
index positive 	text plain 
error report 	charset utf taken 
functions 	number columns 
stack frame 	current locale gettext.h 
count self 	strlen use 
error self 	gettext poison 
argument check 	gettext ngettext copyright 
function level 	arnfj bjarmason 
info 	skeleton implementation gettext 
info information 	git replace 
available registry 	something uses libintl 
name name 	wraps gettext 
already use 	translations mark msgid 
previous top 	translation translate 
create 	strictly speaking lead 
metatable registry 	invalid used 
name metatable 	way foo expand 
userdata metatable 	foo valid 
correct metatable 	initializer right hand 
correct metatables 	side must 
error 	without parentheses many 
avoid warnings 	compilers accept 
avoid extra 	language extension allow 
test avoid 	mistakes like 
extra test 	msgs one 
metatable metatable 	two three notice 
metafield 	missing comma 
metatable metafield 	one lines forcing 
check whether 	compilation error 
lib already 	parenthesised one two 
exists loaded 	silently turned 
libname found 	onetwo git-compat-util.h interval 
previous 	path path 
result variable 	path path prefix 
create one 	err err 
exist loaded 	attribute attribute attribute 
libname table 	attribute attribute 
loaded table 	die routine routine 
move 	routine str 
library table 	prefix str prefix 
upvalues copy 	buf len 
upvalues top 	suffix suflen str 
upvalues getn 	suffix len 
setn size 	str suffix 
arrays 	len start length 
size table 	prot flags 
nil create 	offset start length 
size metatable 	stat stat 
metatable mode 	stat buf count 
store numeric 	offset buf 
field 	count haystack needle 
use use 	herror haystack 
sizes sizes 	haystacklen needle needlelen 
sizes sizes 	str maxsize 
push prefix 	format str maxsize 
push replacement 	format src 
place 	dst src dst 
pattern push 	size handler 
last suffix 	str size size 
field nil 	size data 
table field 	len str 
table field 	len ptr size 
field 	nmemb size 
non table 	start length prot 
table problematic 	flags offset 
part name 	start length prot 
previous table 	flags offset 
buffer manipulation 	path flags buf 
put 	len buf 
nothing stack 	len buf len 
number levels 	offset path 
concat fit 	mode mode mode 
buffer put 	limit pattern 
stack put 	name namesz sha 
buffer 	path len 
stack stack 	offset src src 
nil unique 	len ret 
reference first 	str len dst 
free element 	max fmt 
freelist stack 	tolower trans 
free 	tbl sane ctype 
element list 	high lower 
freelist free 	result result nmemb 
elements create 	size compar 
reference freelist 	path file err 
freelist load 	path mode 
functions 	path path mode 
index filename 	flag path 
stack unix 	mode flag path 
exec file 	time time 
skip first 	dir sep strrchr 
line binary 	strlen memcmp 
file 	strlen strip suffix 
reopen binary 	mem strip 
mode skip 	suffix overflows die 
eventual close 	mult overflows 
file even 	die die xcalloc 
errors ignore 	memcpy xstrdup 
results 	die sane 
lua load 	istest sane istest 
avoid warnings 	strchr strtoul 
lauxlib.h libname 	strtol derived linux 
nup libname 	features test 
obj obj 	macro header convenience 
narg 	macros test 
tname numarg 	versions gcc compatible 
extramsg num 	compiler use 
arg num 	like git gnuc 
arg def 	prereq code 
num arg 	requiring gcc later 
arg 	endif see 
def num 	compiler known support 
arg arg 	flexible members 
def msg 	empty empty older 
narg narg 	gnu extension 
tname tname 	otherwise safer bit 
lvl 	wasteful traditional 
fmt narg 	style build 
def lst 	zero build time 
filename buff 	dependency expression 
name idx 	cond compile time 
fname szhint 	condition must 
lauxlib 	compile fail condition 
roberto exp 	isn evaluated 
auxiliary functions 	compiler used expression 
building lua 	example define 
libraries see 	foo foo foo 
copyright notice 	build zero 
lua 	offsetof foo arr 
extra error 	degrades pointer 
code lua 	different type size 
load useful 	number elements 
macros buffer 	visible whose size 
manipulation current 	want work 
position 	pointers arrays 
buffer number 	declared function parameters 
stack level 	correct compiler 
compatibility compatibility 	support usage cause 
system pre 	build error 
defined references 	see build zero 
lbaselib.c 	macro integer 
level opt 	overflow undefined helper 
level opts 	macro detect 
optsnum res 	sum two integers 
status chunkname 	overflow requires 
fname size 	returns multiplication overflow 
status 	types must 
cname fname 	match must note 
status status 	macro evaluates 
validproxy funcs 	twice checks integer 
statnames narg 	bit approximation 
status nres 	length representation type 
funcs 	solaris xopen 
name lua 	extended header 
gettop lua 	file forces programs 
getglobal lua 	xpg defeating 
pushvalue lua 	xopen source setting 
pushvalue lua 	say xpg 
call 	xpg also solaris 
lua tostring 	xpg programs 
lua error 	must compiled compiler 
lua lua 	non xpg 
fputs fputs 	programs must compiled 
lua pop 	pre compiler 
fputs 	glibc aix need 
lua optint 	open bsd 
lua checkany 	needs islnk aix 
lua isnumber 	needs min 
lua pushnumber 	msvc stops windows 
lua tonumber 	including winsock 
lua 	strcasecmp pull windows 
checkstring lua 	compatibility stuff 
argcheck strtoul 	ilp save 
isspace lua 	bet however llp 
pushnumber lua 	llp needs 
pushnil lua 	resp size needs 
optint 	match exceed 
lua settop 	take everybody aix 
lua isstring 	defines list 
lua lua 	source used mac 
pushvalue lua 	systems netdb 
concat lua 	would given systems 
error 	systems limits 
lua checkany 	would given systems 
lua getmetatable 	gnu hurd 
lua pushnil 	sentinel attribute valid 
lua getmetafield 	gcc version 
lua type 	general helper functions 
lua 	apple common 
checktype lua 	crypto openssl callers 
argcheck lua 	aware constant 
getmetafield lua 	help gcc 
error lua 	wuninitialized analysis restrict 
settop 	trick gcc 
lua setmetatable 	though compilers may 
lua isfunction 	support variadic 
lua pushvalue 	macros since trying 
lua optint 	help gcc 
lua checkint 	anyway compilers fall 
lua 	back function 
argcheck lua 	usual str begins 
getstack lua 	found prefix 
argerror lua 	parameter str strlen 
getinfo lua 	prefix point 
isnil lua 	right prefix otherwise 
error 	untouched examples 
getfunc lua 	extract branch name 
iscfunction lua 	fail branch 
pushvalue lua 	skip prefix 
getfenv lua 	refs heads branch 
checktype getfunc 	skip prefix 
lua 	present otherwise use 
pushvalue lua 	whole skip 
isnumber lua 	prefix name refs 
tonumber lua 	heads name 
pushthread lua 	buf ends suffix 
insert lua 	subtract length 
setfenv 	suffix len otherwise 
lua iscfunction 	len untouched 
lua setfenv 	str ends suffix 
lua error 	len size 
lua lua 	without suffix otherwise 
checkany lua 	len size 
checkany 	note nul terminate 
lua pushboolean 	str length 
lua rawequal 	mmap use win 
lua checktype 	mmap mmap 
lua checkany 	use win 
lua settop 	mmap must multiple 
lua 	pagesize mmap 
rawget lua 	must multiple pagesize 
checktype lua 	mmap forward 
checkany lua 	decl remind twin 
checkany lua 	cache changes 
settop lua 	function used compat 
rawset 	pread include 
lua pushinteger 	cache functions help 
lua getgccount 	allocate structs 
lua checkoption 	flex arrays copy 
lua optint 	data directly 
lua lua 	example foo bar 
lua 	name flex 
pushnumber lua 	foo flex alloc 
pushboolean lua 	mem name 
pushnumber lua 	src len allocate 
checkany lua 	foo contents 
pushstring lua 	src name 
lua 	field resulting automatically 
checktype lua 	zero flex 
settop lua 	field nul terminated 
next lua 	whether incoming 
pushnil lua 	src buffer flexptr 
checktype lua 	variants operate 
pushvalue 	structs use flex 
lua upvalueindex 	arrays want 
lua pushvalue 	store pointer extra 
lua pushnil 	data allocated 
lua checkint 	block example foo 
lua checktype 	name bar 
lua 	foo flex alloc 
pushinteger lua 	str name 
rawgeti lua 	src name point 
isnil lua 	block memory 
checktype lua 	freed along pointer 
pushvalue lua 	repointed anywhere 
upvalueindex 	str variants 
lua pushvalue 	accept parameter rather 
lua pushinteger 	ptr len 
lua pushnil 	combination note macros 
lua insert 	evaluate first 
lua checklstring 	parameter multiple times 
lua 	must assignable 
optstring load 	lvalue silence wuninitialized 
aux lua 	offset calculation 
loadbuffer lua 	ctype kwset users 
optstring load 	sane ctype 
aux lua 	locale works chars 
loadfile 	negative values 
lua checkstack 	would accepted strtoul 
lua pushvalue 	since obvious 
lua call 	implementation list would 
lua isnil 	make pointer 
lua isstring 	stack frame simple 
lua 	assignment work 
replace lua 	many systems 
tolstring lua 	portable preserves errno 
error lua 	prints message 
optstring lua 	gives warning enoent 
checktype lua 	returns success 
settop 	includes trying unlink 
lua load 	exist tries 
load aux 	unlink file returns 
lua optstring 	unlink succeeded 
lua gettop 	file already didn 
lua loadfile 	exist returns 
lua 	appends message err 
error lua 	suitable error 
call lua 	err buf error 
gettop lua 	preserves errno 
checkany lua 	prints message gives 
toboolean lua 	warning enoent 
error 	returns success 
lua optstring 	includes trying directory 
lua gettop 	exist calls 
lua checktype 	correct function unlink 
lua optint 	rmdir warn 
lua opt 	supplied file mode 
lua 	call access 
getn lua 	warn error missing 
checkstack lua 	file enoent 
error lua 	enotdir warn inaccessible 
rawgeti lua 	file ought 
rawgeti lua 	accessible git-credential-gnome-keyring.c result 
gettop 	result user 
lua type 	data data done 
lua tostring 	done keyring 
lua pushinteger 	done result data 
lua checkint 	protocol host 
lua argcheck 	port path username 
lua 	password name 
checkany lua 	entries password 
pcall lua 	data result item 
gettop lua 	result entries 
pushboolean lua 	password data result 
insert lua 	credential helper 
gettop 	ops buf line 
lua checkany 	len key 
lua settop 	key name basename 
lua insert 	argc argv 
lua pcall 	ret cred main 
lua pushboolean 	context main 
lua 	context iteration gnome 
replace lua 	keyring item 
gettop lua 	wait request completion 
checkany lua 	strdup strdup 
callmeta lua 	keyring gnome keyring 
type lua 	find network 
pushstring 	password sync free 
lua tostring 	critical gnome 
lua pushvalue 	keyring result 
lua pushstring 	message gnome keyring 
lua toboolean 	memory free 
lua pushliteral 	gnome keyring memory 
lua 	strdup strdup 
pushfstring lua 	gnome keyring network 
lua topointer 	password list 
lua settop 	free keyring gnome 
lua newuserdata 	keyring network 
lua toboolean 	password sync free 
lua 	critical gnome 
isboolean lua 	keyring result message 
newtable lua 	keyring gnome 
pushvalue lua 	keyring find network 
pushboolean lua 	password sync 
rawset lua 	free critical gnome 
upvalueindex 	keyring result 
lua getmetatable 	message gnome keyring 
lua rawget 	item sync 
lua upvalueindex 	gnome keyring 
lua toboolean 	network password list 
lua pop 	free critical 
lua 	gnome keyring result 
argcheck lua 	message memset 
getmetatable lua 	free free free 
setmetatable lua 	free gnome 
status lua 	keyring memory free 
getstack lua 	credential init 
gettop 	gnome keyring memory 
lua tothread 	alloc fgets 
lua argcheck 	strlen strchr warning 
lua pushstring 	gnome keyring 
costatus costatus 	memory free strcmp 
lua checkstack 	free strdup 
lua 	strcmp free strdup 
error lua 	strrchr atoi 
pushfstring lua 	strcmp free 
xmove lua 	strdup strcmp free 
setlevel lua 	strdup strcmp 
resume lua 	gnome keyring memory 
gettop 	free gnome 
lua checkstack 	keyring memory strdup 
lua error 	gnome keyring 
lua xmove 	memory free credential 
lua xmove 	write item 
lua tothread 	credential write item 
lua 	strrchr usage 
argcheck auxresume 	exit application name 
lua gettop 	strcmp credential 
lua pushboolean 	read credential write 
lua insert 	credential clear 
lua pushboolean 	copyright john szakmeister 
lua 	john szakmeister 
insert lua 	net philipp hartmann 
tothread lua 	pah program 
upvalueindex auxresume 	free software 
lua gettop 	redistribute modify terms 
lua isstring 	gnu general 
lua 	license published free 
lua insert 	software foundation 
lua concat 	either version license 
lua error 	option later 
lua newthread 	version program distributed 
lua argcheck 	hope useful 
lua 	without warranty without 
isfunction lua 	even implied 
iscfunction lua 	warranty merchantability fitness 
pushvalue lua 	particular purpose 
xmove lua 	see gnu general 
cocreate lua 	license details 
pushcclosure 	received copy gnu 
lua lua 	general license 
gettop lua 	along program write 
pushthread lua 	free software 
pushnil lua 	foundation inc 
pushcfunction lua 	temple place suite 
pushcclosure 	boston usa 
lua setfield 	credits gnome keyring 
lua pushvalue 	api handling 
lua setglobal 	originally written john 
lua lua 	szakmeister ported 
pushliteral lua 	credential helper api 
setglobal 	philipp hartmann 
auxopen auxopen 	modern gnome keyring 
lua createtable 	support ancient 
lua pushvalue 	gnome keyring circ 
lua setmetatable 	rhel gnome 
lua pushliteral 	keyring seems introduced 
lua 	gnome features 
setfield lua 	roughly around gnome 
pushcclosure lua 	months ubuntu 
setglobal open 	used gnome think 
lua lbaselib 	sure distro 
roberto exp 	used existence 
basic 	non existence gnome 
library see 	keyring seems 
copyright notice 	like decent thing 
lua system 	use indicator 
support stdout 	ancient gnome keyring 
function need 	returns denied 
define 	entry found setting 
print function 	match denied 
following model 	prevent reporting denied 
changing fputs 	errors erase 
put proper 	operations still report 
place console 	denied errors 
window 	store support really 
log file 	ancient gnome 
instance number 	keyring circ rhel 
arguments function 	guess glib 
called print 	version glib 
result pop 	roughly gnome released 
result 	gnome keyring 
standard conversion 	credential api simplified 
least one 	git credential 
valid digit 	gnome keyring functions 
skip trailing 	create special 
spaces invalid 	keyring option path 
trailing 	given domain 
characters number 	authtype pick first 
extra information 	one list 
metatable returns 	sanity check storing 
either metatable 	actually sensible 
field present 	particular make url 
metatable 	without protocol 
function env 	field without either 
change environment 	host pathname 
current create 	depending scheme primary 
argument isn 	key without 
one generator 	username password 
state 	actually storing credential 
initial next 	domain authtype 
generator state 	sanity check actually 
initial put 	something match 
error message 	input restrictive pattern 
nil plus 	technically blank 
error 	credential means erase 
message reader 	everything easy 
load function 	accidentally send since 
lua load 	equivalent empty 
uses stack 	input explicitly disallow 
stuff reader 	require pattern 
cannot 	actual content match 
change stack 	domain authtype 
top instead 	pick first one 
keeps resulting 	list matches 
reserved slot 	table helper operation 
inside stack 	callbacks used 
avoid 	credential helper 
warnings function 	main function credential 
call save 	functions ignore 
reserved stack 	lines know mean 
slot avoid 	future proofs 
warnings function 	later versions git 
eventual 	learn lines 
name plus 	helpers updated match 
one reserved 	write username 
slot empty 	password lookup operation 
range number 	callback unsupported 
elements means 	operation given ignore 
arith 	silently perform 
overflow push 	credential operation git-credential-osxkeychain.c 
arg avoiding 	protocol host 
overflow problems 	path username password 
push arg 	port err 
status results 	msg ret buf 
put 	len item 
error function 	list attr 
function called 	buf len item 
status results 	item buf 
metafield use 	colon argc argv 
create proxy 	usage start 
metatable 	vsnprintf end exit 
create metatable 	strdup die 
mark valid 	fwrite putchar sec 
metatable weaktable 	keychain item 
check weaktable 	copy content write 
metatable metatable 	item sec 
valid 	keychain item free 
coroutine library 	content sec 
running suspended 	keychain find internet 
normal resumed 	password write 
another coroutine 	item find username 
frames running 	item sec 
initial 	keychain item free 
state error 	content sec 
occured error 	keychain find 
flag move 	internet password sec 
yielded values 	keychain item 
move error 	sec keychain internet 
message 	password keychain 
error flag 	item fgets strcmp 
error message 	strlen strchr 
resume returns 	die strcmp strcmp 
error extra 	strcmp strcmp 
info propagate 	strcmp strcmp strcmp 
error 	strcmp exit 
move function 	strcmp strchr atoi 
top move 	xstrdup strcmp 
function main 	xstrdup strcmp xstrdup 
coroutine open 	strcmp xstrdup 
lib table 	die read credential 
version 	strcmp find 
ipairs pairs 	internet password 
need auxiliary 	strcmp internet password 
functions upvalues 	strcmp internet 
newproxy needs 	password keychain account 
weaktable upvalue 	domain require 
table 	least protocol host 
metatable metatable 	removal git 
mode newproxy 	give want something 
lcode.c previous 	fancy use 
pfrom pto 	keychain manager store 
jpc first 	complete credentials 
nret 	yet handle protocols 
dest jmp 	otherwise ignore 
offset offset 	unknown action git-credential-wincred.c 
list node 	err msg 
reg list 	size ret advapi 
list vtarget 	cred write 
reg 	cred enumerate cred 
dtarget next 	free cred 
list target 	wusername password 
list list 	protocol host path 
next newstack 	target wbuf 
reg idx 	wlen buf len 
oldsize 	str find 
nresults jump 	pos ptarget want 
reg reg 	delim last 
key func 	delim pos start 
cond temp 	len ptarget 
cond temp 	want delim ptarget 
line 	want delim 
line nelems 	cred target creds 
tostore opcode 	num creds 
getarg getarg 	cred creds num 
setarg lua 	creds str 
code abc 	wlen wstr buf 
lua 	len argc 
code lua 	argv usage start 
concat lua 	vsnprintf end 
code abc 	exit malloc 
lua code 	malloc die load 
abc lua 	library die 
jump 	proc address proc 
lua abs 	address proc 
lua syntaxerror 	address proc address 
setarg getarg 	die wide 
test mode 	multi xmalloc wide 
opcode getjump 	multi die 
getjumpcontrol 	fwrite putchar free 
opcode getjumpcontrol 	wcsstr wcsstr 
opcode getarg 	wcsstr last wcsstr 
setarg create 	wcslen wcslen 
abc getarg 	wcslen wcsncmp match 
getarg getjump 	part last 
patchtestreg 	match part last 
getjump patchtestreg 	wcscmp match 
fixjump fixjump 	part match part 
patchlistaux lua 	match part 
patchtohere lua 	last match 
patchlistaux lua 	part match part 
getlabel 	cred enumerate 
lua concat 	match cred write 
getjump fixjump 	item wcslen 
lua syntaxerror 	write item cred 
cast lua 	free wcslen 
checkstack isk 	cred write die 
lua 	cred enumerate 
freereg lua 	match cred cred 
ttisnumber lua 	cred free 
lua rawequal 	multi wide xmalloc 
obj cast 	multi wide 
nvalue cast 	fgets strlen strchr 
nvalue 	strchr die 
setnvalue cast 	strcmp utf utf 
num lua 	dup strcmp 
growvector setnilvalue 	utf utf 
setobj lua 	dup strcmp utf 
barrier setsvalue 	utf dup 
addk 	strcmp utf utf 
setnvalue addk 	dup strcmp 
setbvalue addk 	utf utf dup 
setnilvalue sethvalue 	die die 
addk setarg 	setmode fileno setmode 
getcode setarg 	fileno read 
getcode 	credential load cred 
setarg getcode 	funcs wcscpy 
lua reserveregs 	wcsncat size wcsncat 
getarg getcode 	size wcsncat 
setarg getcode 	size wcsncat size 
lua 	wcsncat size 
code abc 	wcsncat size wcsncat 
lua code 	size strcmp 
freereg freereg 	credential strcmp store 
lua code 	credential strcmp 
abc lua 	erase credential 
setoneret 	git credential helper 
lua getlabel 	windows credential 
lua code 	manager common helpers 
abc lua 	min doesn 
dischargevars lua 	wincred need define 
nil lua 	stuff load 
code 	function pointers match 
abc lua 	optional expected 
code lua 	delimiter target consuming 
code lua 	matched text 
number getcode 	updating target pointer 
setarg lua 	find start 
code 	delimiter end delim 
abc lua 	empty match 
lua reserveregs 	text delimiter end 
discharge reg 	host optional 
discharge reg 	followed path update 
lua concat 	ptarget either 
hasjumps 	found delimiter 
need need 	need match search 
lua jump 	first credential 
code label 	matches username strip 
code label 	trailing git 
lua patchtohere 	use binary pipes 
lua 	avoid crlf 
getlabel patchlistaux 	issues prepare target 
patchlistaux lua 	unique key 
dischargevars freeexp 	credential otherwise ignore 
lua reserveregs 	unknown action 
exp reg 	git.c git usage 
lua 	git info 
dischargevars hasjumps 	git startup info 
exp reg 	use pager 
lua exp 	orig cwd env 
nextreg hasjumps 	names orig 
lua exp 	env save restore 
anyreg 	env balance 
lua dischargevars 	external argv 
lua exp 	argc envchanged orig 
val nil 	argv cmd 
lua number 	cwd argcp argv 
rkask rkask 	saved errno 
lua 	count option count 
exp anyreg 	argv command 
freeexp exp 	unused nongit child 
reg lua 	cmd option 
exp anyreg 	argc argv status 
lua code 	help prefix 
abc 	nongit commands argv 
lua exp 	len argc 
anyreg lua 	argv cmd builtin 
code lua 	argv cmd 
exp lua 	tmp status argcp 
code abc 	argv done 
lua 	unblock argc 
freeexp lua 	argv cmd done 
exp anyreg 	help xgetcwd 
freeexp lua 	size getenv xstrdup 
reserveregs lua 	chdir die 
code abc 	errno free size 
lua 	strcmp setenv 
exp freeexp 	free unsetenv setenv 
getjumpcontrol lua 	setup pager 
test mode 	strcmp strcmp skip 
opcode opcode 	prefix git 
opcode setarg 	argv exec path 
getarg 	puts git 
getcode opcode 	exec path exit 
condjump getarg 	strcmp puts 
discharge anyreg 	system path exit 
freeexp condjump 	strcmp puts 
lua dischargevars 	system path exit 
invertjump 	strcmp puts 
jumponcond lua 	system path 
concat lua 	exit strcmp strcmp 
patchtohere lua 	strcmp strcmp 
dischargevars jumponcond 	setenv strcmp usage 
lua concat 	setenv skip 
lua 	prefix setenv strcmp 
patchtohere lua 	usage setenv 
dischargevars invertjump 	skip prefix setenv 
discharge anyreg 	strcmp usage 
freeexp lua 	setenv skip prefix 
code abc 	setenv strcmp 
lua 	xgetcwd setenv free 
removevalues removevalues 	setenv strcmp 
lua exp 	usage git config 
isnumeral isnumeral 	push parameter 
luai numadd 	strcmp setenv strcmp 
luai numsub 	setenv strcmp 
luai 	setenv strcmp setenv 
nummul luai 	strcmp setenv 
numdiv luai 	strcmp alternate 
nummod luai 	shallow file strcmp 
numpow luai 	usage chdir 
numunm lua 	die errno usage 
luai 	save env 
numisnan constfolding 	setup git directory 
lua exp 	gently lookup 
lua exp 	commit pager choice 
freeexp freeexp 	restore env 
freeexp freeexp 	argv push argv 
lua 	pushv run 
code abc 	command exit die 
lua exp 	errno split 
lua exp 	cmdline die split 
freeexp freeexp 	cmdline strerror 
condjump isnumeral 	handle options die 
lua 	memmove die 
exp anyreg 	strcmp die trace 
codearith codenot 	argv realloc 
lua exp 	memcpy restore 
anyreg codearith 	env strcmp setup 
lua lua 	git directory 
goiftrue 	setup git directory 
lua goiffalse 	gently check 
lua exp 	pager config trace 
nextreg isnumeral 	repo setup 
lua exp 	commit pager choice 
lua exp 	setup work 
lua 	trace argv fstat 
lua dischargevars 	fileno isfifo 
lua concat 	issock fflush die 
lua lua 	errno ferror 
dischargevars lua 	die fclose die 
concat lua 	errno size 
exp 	strcmp builtin strip 
val opcode 	suffix xmemdupz 
getcode lua 	strip extension strcmp 
getarg getcode 	builtin exit 
freeexp setarg 	run builtin 
getcode lua 	check pager config 
exp 	commit pager 
nextreg codearith 	choice strbuf addf 
codearith codearith 	trace argv 
codearith codearith 	run command opt 
codearith codearith 	exit strbuf 
codecomp codecomp 	release handle builtin 
codecomp 	execv dashed 
codecomp codecomp 	external handle sigemptyset 
codecomp lua 	sigaddset sigprocmask 
dischargejpc lua 	signal git extract 
growvector lua 	argv path 
growvector lua 	sanitize stdfds restore 
mode 	sigpipe git 
lua mode 	setup gettext trace 
lua mode 	command performance 
lua code 	skip prefix 
create abc 	handle builtin die 
lua mode 	handle options 
mode 	skip prefix commit 
lua mode 	pager choice 
lua code 	list common cmds 
create lua 	help exit 
lua code 	setup path run 
abc lua 	argv exit 
code 	help unknown cmd 
abc lua 	strerror legacy 
code cast 	reasons version help 
lcode roberto 	commands written 
exp code 	prepended make look 
generator lua 	like flags 
see 	check remaining flags 
copyright notice 	normal exit 
lua jumps 	insert command name 
current position 	require working 
function start 	present anything 
positions already 	uses needs run 
clean 	setup reading 
connect optimization 	configuration file git 
save list 	dir may 
jumps keep 	repo avoid somebody 
hold returns 	closed stdout 
current marks 	ignore write errors 
jump 	pipes sockets 
target avoid 	check enospc eio 
wrong optimizations 	errors turn 
consecutive instructions 	git cmd help 
basic block 	git help 
point represents 	cmd argv must 
end 	git command 
list end 	argv belongs caller 
list turn 	may reused 
offset absolute 	subsequent loop iterations 
position check 	save argv 
whether list 	restore error 
jump 	fail command found 
produce produce 	otherwise pass 
inverted found 	along status code 
cannot patch 	tried futzed 
instructions put 	environment longer safe 
already jump 	invoke builtins 
target 	directly general spawn 
find last 	dashed externals 
element constant 	needswork figure cases 
found create 	safe avoid 
entry cannot 	spawning process external 
use nil 	ones could 
key 	works around insanity 
instead use 	overriding git 
table represent 	log git show 
nil expression 	log show 
open function 	many parts git 
call expression 	subprograms communicate 
open 	via pipe 
function call 	expect upstream pipe 
relocate simple 	die sigpipe 
result one 	downstream pipe need 
available somewhere 	read written 
instructions may 	third party programs 
jump 	ignore block 
targets nothing 	sigpipe reason forget 
put jump 	restore sigpipe 
list position 	handling spawning git 
whole expression 	carefully orchestrated 
position eventual 	machinery restore way 
load 	sigpipe handled 
position eventual 	expect always open 
load exp 	file descriptors 
already reg 	avoid clobbering files 
local put 	die also 
constant fit 	avoids messing 
operand 	pipes dup onto 
constant fit 	stdin stdout 
arg constant 	stderr child processes 
right range 	spawn git 
put invalid 	xxxx git xxxx 
kind store 	obviously cannot 
previous 	take flags git 
last jump 	xxxx cannot 
always nothing 	execute externally since 
insert last 	would thing 
jump list 	directly call builtin 
last jump 	handler die 
always 	one cannot handle 
nothing insert 	look flags 
last jump 	translate help version 
list cannot 	commands user 
happen interchange 	didn specify command 
lists attempt 	give help 
divide 	use path 
attempt divide 	find git commands 
constant folding 	prepend higher 
len attempt 	precedence paths exec 
produce exchange 	path option 
args replace 	git exec path 
cannot 	environment gitexecdir 
operate non 	makefile build time 
numeric constants 	gmtime.c timep 
cannot operate 	result timep result 
constants operand 	ret git 
must stack 	gmtime memset gmtime 
list 	rather free 
must closed 	bsd gmtime simply 
list must 	leaves untouched 
closed operand 	encounters overflow since 
must stack 	mday cannot 
change put 	otherwise zero test 
instruction 	quickly gpg-interface.c 
code save 	configured signing 
corresponding line 	key gpg program 
information free 	sigc result 
registers list 	check sigc buf 
values lcode.h 	found next 
line 	payload plen signature 
key nresults 	slen sigc 
first nret 	gpg output gpg 
list target 	status status 
list nelems 	sigc flags output 
tostore lcode 	buf size 
roberto 	eol len key 
exp code 	buffer signature 
generator lua 	signing key gpg 
see copyright 	args len 
notice lua 	bottom payload payload 
marks end 	size signature 
patch 	signature size gpg 
list invalid 	output gpg 
absolute address 	status gpg 
list link 	args gpg path 
would link 	ret buf 
element grep 	pbuf free free 
order 	free free 
opr change 	free size skip 
enums ldblib.c 	prefix strstr 
arg fname 	strlen xmemdupz strchrnul 
arg options 	xmemdupz verify 
arg name 	buffer xmemdupz strbuf 
arg 	detach strbuf 
name key 	detach parse gpg 
hook hooknames 	output strbuf 
smask count 	release strbuf release 
mask mask 	fputs fputs 
smask arg 	starts starts memchr 
mask 	free xstrdup 
count func 	strcmp signing 
smask arg 	key strcmp config 
buff mask 	error nonbool 
hook buffer 	xstrdup git committer 
level firstpart 	info start 
arg 	command error sigchain 
dblib lua 	push write 
pushvalue lua 	full close close 
checkany lua 	finish command 
getmetatable lua 	error close strbuf 
pushnil lua 	read close 
type 	sigchain pop finish 
lua argcheck 	command error 
lua settop 	strbuf setlen git 
lua pushboolean 	mkstemp error 
lua setmetatable 	strerror write full 
lua checkany 	error strerror 
lua 	close start command 
getfenv lua 	unlink error 
checktype lua 	write full 
settop lua 	close strbuf read 
setfenv lua 	close strbuf 
error lua 	read close finish 
lua 	command unlink 
pushstring lua 	warn strstr strbuf 
setfield lua 	release iterate 
pushinteger lua 	search trust messages 
setfield lua 	followed key 
isthread lua 	signer information look 
tothread 	gpg content 
lua pushvalue 	tag whose payload 
lua lua 	followed detached 
xmove lua 	signature offset embedded 
setfield getthread 	detached signature 
lua optstring 	begins end data 
lua 	signature create 
isnumber lua 	detached signature contents 
getstack lua 	buffer append 
tointeger lua 	signature buffer 
pushnil lua 	signature strbuf instance 
isfunction lua 	would cause 
pushfstring 	detached signature appended 
lua tostring 	end username 
lua pushvalue 	signingkey bad program 
lua xmove 	could terminated 
lua argerror 	gpg exits without 
lua getinfo 	reading write 
lua 	gets sigpipe strip 
argerror lua 	line endings 
createtable strchr 	windows run gpg 
settabss settabss 	see payload 
settabsi settabsi 	matches detached signature 
settabss strchr 	gpg output 
settabsi 	receives diagnostic output 
strchr settabsi 	gpg gpg 
strchr settabss 	status receives status 
settabss strchr 	output gpg 
treatstackoption strchr 	matter used 
treatstackoption getthread 	gpg-interface.h payload gpg 
lua 	output gpg 
getstack lua 	status result signer 
checkint lua 	key sigc 
argerror lua 	buf size signature 
getlocal lua 	check buffer 
checkint lua 	signature signing key 
xmove 	payload payload 
lua pushstring 	size signature signature 
lua pushvalue 	size gpg 
lua pushnil 	output gpg status 
getthread lua 	payload plen 
getstack lua 	signature slen sigc 
checkint 	sigc flags 
lua argerror 	possible result result 
lua checkany 	untrusted good 
lua settop 	good bad graph.c 
lua xmove 	graph graph 
lua pushstring 	show strbuf 
lua 	commit color column 
setlocal lua 	colors column 
checkint lua 	colors max colors 
checkint lua 	colors max 
checktype lua 	color col commit 
iscfunction lua 	revs num 
getupvalue 	parents width expansion 
lua setupvalue 	row commit 
lua pushstring 	index prev commit 
lua insert 	index column 
auxupvalue lua 	capacity num columns 
checkany auxupvalue 	num columns 
lua 	mapping size columns 
pushlightuserdata lua 	columns mapping 
rawget lua 	mapping column color 
pushlightuserdata lua 	opt data 
rawget lua 	graph msgbuf 
isfunction lua 	opt graph graph 
pushstring 	update state 
lua pushinteger 	graph num columns 
lua pushnil 	graph commit 
lua lua 	graph orig list 
getinfo lua 	graph parents 
call strchr 	graph graph graph 
strchr 	commit graph 
strchr lua 	commit mapping index 
pushlightuserdata lua 	graph commit 
rawget lua 	existing columns max 
istable lua 	cols graph 
pop lua 	parent tmp columns 
createtable 	max columns 
lua pushlightuserdata 	mapping idx seen 
lua pushvalue 	commit columns 
lua rawset 	col commit old 
getthread lua 	mapping idx 
isnoneornil lua 	graph commit 
settop 	parent graph target 
lua checkstring 	graph chars 
lua checktype 	written extra graph 
lua optint 	graph graph 
makemask gethooktable 	num expansion rows 
lua pushlightuserdata 	seen chars 
lua 	written col graph 
pushvalue lua 	graph dashless 
rawset lua 	commits col num 
pop lua 	num dashes 
sethook getthread 	graph seen chars 
lua gethookmask 	written col 
lua 	col commit graph 
gethook lua 	commit graph 
pushliteral gethooktable 	seen chars written 
lua pushlightuserdata 	col col 
lua rawget 	commit parents par 
lua lua 	column graph 
pushstring 	tmp mapping 
unmakemask lua 	used horizontal horizontal 
pushinteger lua 	edge horizontal 
gethookcount fputs 	edge target target 
fgets strcmp 	target graph 
lua 	graph col graph 
loadbuffer strlen 	commit finished 
lua pcall 	graph msgbuf shown 
fputs lua 	commit line 
tostring fputs 	graph msgbuf graph 
lua settop 	msgbuf graph 
getthread 	msgbuf shown graph 
lua isnumber 	show strbuf 
lua tointeger 	graph show commit 
lua pop 	msg strbuf 
lua gettop 	addstr column color 
lua pushliteral 	code strbuf 
lua 	addch strbuf addstr 
isstring lua 	column color 
pushliteral lua 	code strbuf 
pushliteral lua 	reset graph padding 
getstack lua 	line xmalloc 
getstack lua 	graph column colors 
pushliteral 	alloc alloc 
lua getstack 	alloc alloc realloc 
lua pushliteral 	realloc realloc 
lua getinfo 	realloc commit action 
lua pushfstring 	graph interesting 
lua pushfstring 	graph interesting next 
lua 	interesting parent 
pushfstring lua 	want color graph 
pushfstring lua 	current column 
pushliteral lua 	color graph find 
pushfstring lua 	commit color 
concat lua 	graph ensure capacity 
gettop 	first interesting 
lua concat 	parent next 
lua gettop 	interesting parent graph 
lua ldblib 	increment column 
roberto exp 	color graph insert 
lua debug 	columns graph 
api 	insert columns graph 
see copyright 	update width 
notice lua 	first interesting parent 
metatable level 	next interesting 
range table 	parent graph update 
range range 	columns strbuf 
cannot 	addf strbuf write 
touch upvalues 	column strbuf 
lua turn 	addch graph pad 
hooks hook 	horizontally strbuf 
hook table 	addstr graph pad 
hooks external 	horizontally graph 
hook 	update state graph 
hook hook 	update state 
table eventual 	strbuf write 
returns size 	column strbuf addf 
first part 	strbuf write 
stack size 	column strbuf write 
second 	column strbuf 
part stack 	write column strbuf 
still eventual 	write column 
level may 	strbuf addch graph 
function message 	pad horizontally 
levels levels 	graph update state 
keep 	strbuf addch 
going many 	strbuf addstr revision 
levels find 	mark strbuf 
last levels 	write column strbuf 
name main 	write column 
function tail 	graph output commit 
call 	graph draw 
ldebug.c name 	octopus merge strbuf 
func mask 	write column 
count level 	strbuf write 
status name 	column strbuf write 
limit name 	column strbuf 
name 	write column strbuf 
lineinfo status 	addch graph 
status func 	pad horizontally graph 
check arg 	update state 
mode lastpc 	graph mapping correct 
reg last 	graph update 
dest 	state graph update 
dest nup 	state first 
stackpos name 	interesting parent find 
name name 	column commit 
kind temp 	strbuf write column 
msg buff 	next interesting 
line 	parent find column 
errfunc fmt 	commit strbuf 
argp lua 	write column strbuf 
rel func 	addch strbuf 
currentpc getline 	write column 
func resethookcount 	strbuf addch strbuf 
cast 	write column 
lua lua 	strbuf addch graph 
cast lua 	pad horizontally 
unlock lua 	graph mapping correct 
func getluaproto 	graph update 
lua getlocalname 	state graph update 
currentpc 	state strbuf 
findlocal lua 	addch strbuf write 
lua pushobject 	column strbuf 
lua unlock 	write column strbuf 
findlocal lua 	write column 
setobjs lua 	graph pad horizontally 
unlock 	graph mapping 
getstr lua 	correct graph update 
chunkid lua 	state graph 
chunkid setnilvalue 	output padding 
lua setbvalue 	line graph output 
lua setnum 	skip line 
sethvalue 	graph output pre 
incr top 	commit line 
info tailcall 	graph output commit 
funcinfo currentline 	line graph 
getfuncname lua 	output post merge 
luai apicheck 	line graph 
ttisfunction 	output collapsing line 
clvalue lua 	graph next 
ttisfunction clvalue 	line strbuf write 
auxgetinfo strchr 	column strbuf 
setnilvalue setclvalue 	addchars strbuf addch 
incr top 	graph pad 
strchr 	horizontally graph commit 
collectvalidlines lua 	finished graph 
unlock check 	show padding graph 
check check 	commit finished 
check check 	graph next 
check opcode 	line fwrite putchar 
opcode 	strbuf setlen 
check getarg 	strbuf release graph 
check precheck 	next line 
opcode getarg 	fwrite strbuf release 
check checkreg 	graph padding 
mode getarg 	line fwrite strbuf 
getarg 	release graph 
check check 	commit finished graph 
arg mode 	next line 
mode check 	fwrite strbuf setlen 
check arg 	graph commit 
mode mode 	finished putchar strbuf 
getarg 	release api 
mode check 	output padding line 
getarg mode 	graph similar 
check opcode 	graph next line 
getarg check 	however guaranteed 
test mode 	never print 
test 	current commit line 
mode check 	instead commit 
check opcode 	line next simply 
check check 	output line 
opcode getarg 	vertical padding extending 
check check 	branch lines 
ttisstring 	downwards leaving otherwise 
checkreg check 	unchanged print 
check checkreg 	strbuf stdout graph 
checkreg checkreg 	non lines 
check checkopenop 	first prefixed graph 
checkreg checkreg 	output strbuf 
checkreg 	ends newline output 
check check 	end newline 
check opcode 	graph line printed 
check check 	newline strbuf 
check checkopenop 	empty output printed 
checkreg symbexec 	since first 
isk 	line include 
ttisstring indexk 	graph output caller 
svalue indexk 	responsible printing 
lua func 	line graph perhaps 
currentpc lua 	via graph 
getlocalname symbexec 	show commit graph 
lua 	show oneline 
opcode getarg 	calling graph show 
lua ttisstring 	strbuf todo 
svalue getarg 	limit number columns 
getarg getobjname 	similar way 
getarg kname 	gitk reach specified 
getarg 	number columns 
getstr getarg 	omit sections columns 
kname lua 	parent commit 
lua func 	column color optionally 
currentpc opcode 	print column 
opcode opcode 	index column colors 
getobjname 	commit currently 
getarg ttype 	processed rev 
isinstack getobjname 	info used current 
cast lua 	traversal number 
runerror lua 	interesting parents commit 
runerror ttisstring 	note actual 
ttisnumber 	number parents count 
lua ttisstring 	excludes parents 
ttisnumber lua 	won printed graph 
typeerror lua 	output determined 
tonumber lua 	graph interesting width 
typeerror ttype 	graph output 
ttype 	commit rows commit 
lua runerror 	padded width 
lua runerror 	messages printed graph 
lua currentline 	output aligned 
lua chunkid 	next expansion row 
getstr getluaproto 	print state 
lua 	graph pre 
pushfstring restorestack 	commit current output 
ttisfunction lua 	state tells 
setobjs setobjs 	kind line graph 
incr top 	next line 
lua call 	output output state 
lua 	previous line 
start addinfo 	output primarily used 
lua pushvfstring 	determine first 
end lua 	merge line appear 
errormsg ldebug 	last line 
roberto exp 	previous commit index 
debug 	column refers 
see copyright 	commit none incoming 
notice lua 	columns refer 
function lua 	commit equal num 
function active 	columns commit 
lua functions 	index previously displayed 
current 	commit used 
line information 	determine first 
function called 	line merge graph 
asynchronous signal 	output appear 
turn hooks 	last line previous 
lua function 	commit maximum 
skip 	number columns stored 
lost tail 	columns columns 
calls level 	arrays also half 
found level 	number entries 
lost tail 	stored mapping mapping 
call level 	arrays number 
local 	columns also called 
variable lua 	branch lines 
function inside 	places number columns 
stack pop 	columns number 
found handled 	entries mapping column 
lua getinfo 	state output 
invalid 	current commit column 
option skip 	state output 
pop function 	current commit 
tail call 	valid state graph 
symbolic execution 	collapsing tracks 
code checker 	current state character 
invalid 	output line 
instruction open 	state graph collapsing 
call stores 	entry character 
position last 	empty non negative 
instruction changed 	integer character 
reg points 	contains branch line 
neutral 	integer indicates 
instruction check 	target position branch 
jump setlist 	line maps 
count tricky 	current column positions 
count previous 	desired positions 
setlist may 	maximum capacity always 
invalid 	column capacity 
setlist must 	temporary computing next 
way back 	mapping state 
first even 	outputting mapping 
previous setlist 	line stored part 
even looks 	git graph 
like 	simply allocate temporary 
one change 	time output 
check skip 	collapsing line current 
jump check 	column color 
jump registers 	used stored index 
least two 	column colors 
operands 	start column color 
least one 	maximum since 
result control 	always increment first 
variable space 	commit output 
results affect 	way start first 
regs full 	commit allocate 
check 	reasonably large number 
jump forward 	columns automatically 
skip lastpc 	grow columns 
jump num 	later need room 
returns affect 	diff output 
registers num 	prefix callback make 
returns 	diff output 
tracing execute 	align graph lines 
pseudo instructions 	returns commit 
lua function 	printed graph output 
local symbolic 	otherwise revs 
execution index 	boundary commits whose 
move 	children shown 
name key 	always interesting even 
index upvalue 	uninteresting treesame 
index key 	flags otherwise use 
index useful 	commit action 
name found 	see commit interesting 
calling 	revs first 
function lua 	parent first parent 
unknown calling 	interesting none 
function useful 	others next 
name found 	interesting commit orig 
ansi way 	commit parents 
check 	ignore first parent 
whether pointer 	interesting otherwise 
points first 	call next interesting 
operand wrong 	parent next 
lua code 	interesting parent update 
file line 	graph column 
information 	color commit already 
error handling 	columns list 
function move 	need update mapping 
argument push 	correctly commit 
function call 	isn already columns 
ldebug.h opname 	compute width 
fmt 	needed display graph 
ldebug roberto 	commit maximum 
exp auxiliary 	width needed row 
functions debug 	rows padded 
module see 	width compute 
copyright notice 	number columns widest 
lua 	row count 
ldo.c previous 	existing column graph 
status errcode 	num columns 
oldtop inuse 	column added commit 
status errcode 	even current 
oldstack newsize 	commit parents printed 
oldstack 	still takes 
realsize newsize 	column added column 
oldci line 	current commit 
hook top 	part graph num 
top actual 	parents current 
nfixargs htab 	commit already graph 
nvar 	columns counted 
func funcr 	column takes spaces 
func nresults 	swap graph 
funcr nargs 	columns graph columns 
first result 	graph columns 
first result 	contains state 
res 	previous commit columns 
wanted func 	contains state 
results first 	commit use old 
arg msg 	columns storage 
nargs status 	compute columns list 
nresults func 	commit one 
old 	update columns mapping 
top status 	information commit 
oldn ccalls 	one first make 
old old 	sure enough 
allowhooks old 	room graph num 
errfunc oldtop 	columns graph 
buff 	num parents columns 
name name 	next commit 
status setsvalue 	clear graph mapping 
lua newliteral 	populate graph 
setsvalue lua 	columns graph 
newliteral setobjs 	mapping parents commit 
lua 	may already 
cast lua 	graph columns graph 
realloc lua 	columns contain 
close lua 	single entry commit 
seterrorobj restore 	graph mapping 
stack limit 	contain information current 
luai 	branch line 
cast resetstack 	supposed end collapsing 
lua unlock 	performed merge 
panic exit 	start childless column 
gco gco 	increment current 
lua lua 	color always need 
reallocvector 	increment mapping 
correctstack lua 	idx least even 
reallocvector lua 	interesting parents 
reallocstack lua 	current commit always 
reallocstack lua 	takes least 
lua realloc 	spaces shrink 
lua 	mapping size minimum 
runerror savestack 	necessary compute 
savestack cast 	graph width commit 
lua checkstack 	commit count 
lua lua 	many interesting parents 
unlock hook 	commit store 
lua 	old commit index 
lua restorestack 	prev commit 
restorestack setnilvalue 	index graph update 
lua lua 	columns update 
check lua 	graph commit index 
checkstack lua 	commit call 
setobj 	graph update columns 
lua setnum 	update columns 
setnvalue lua 	columns mapping update 
setstr lua 	graph state 
newliteral cast 	note call graph 
num setobjs 	update state 
setnilvalue 	since want 
sethvalue lua 	update graph prev 
iswhite obj 	state line 
gco lua 	graph state ever 
gettmbyobj savestack 	printed previous 
ttisfunction lua 	commit didn graph 
typeerror 	padding state 
setobjs incr 	never finished output 
top restorestack 	graph skip 
setobj ttisfunction 	print line indicate 
tryfunc savestack 	portion graph 
clvalue lua 	missing parents may 
checkstack 	need print 
restorestack cast 	extra rows commit 
adjust varargs 	expand branch 
restorestack inc 	lines around make 
lua setnilvalue 	room need 
lua callhook 	branch row right 
lua 	commit less 
checkstack inc 	parents immediately 
restorestack lua 	print commit line 
lua callhook 	mapping date 
lua unlock 	entry target greater 
curr func 	target greater 
lua 	target printed look 
lua poscall 	correct next 
savestack lua 	row additional spaces 
callhook lua 	end strbuf 
lua callhook 	lines particular commit 
restorestack callrethooks 	width way 
setobjs 	fields printed right 
setnilvalue lua 	graph remain 
runerror lua 	aligned entire commit 
lua precall 	could conceivable 
lua execute 	called commit caller 
lua check 	bug invokes 
cast 	graph next line 
lua lua 	immediately graph 
precall lua 	init without 
lua lua 	first calling graph 
opcode opcode 	update without 
lua poscall 	outputting anything output 
lua 	padding row 
execute cast 	leaves branch lines 
setsvalue lua 	unchanged output 
incr top 	ellipsis indicate portion 
lua unlock 	graph missing 
lua 	function formats row 
resume error 	increases space 
resume error 	around commit multiple 
luai userstateresume 	parents make 
lua lua 	room called parents 
rawrunprotected cast 	need extra 
lua 	rows every parent 
seterrorobj lua 	graph expansion 
lua unlock 	row tracks 
luai userstateyield 	current expansion row 
lua lua 	range num 
runerror lua 	expansion rows output 
unlock 	row first 
saveci lua 	line pre commit 
rawrunprotected restorestack 	output previous 
lua close 	commit merge commit 
lua seterrorobj 	ended graph 
restoreci restore 	post merge state 
stack 	branch lines 
limit cast 	graph prev commit 
lua lookahead 	index printed 
lua check 	previous line print 
lua parser 	line otherwise 
lua lclosure 	print branch lines 
hvalue 	increment graph 
lua newupval 	expansion row move 
setclvalue incr 	state graph 
top lua 	commit necessary 
initbuffer lua 	boundary commits print 
pcall savestack 	see boundary 
lua 	commits revs boundary 
freebuffer ldo 	revision mark 
roberto exp 	handles cases without 
stack call 	draw octopus 
structure lua 	merge number characters 
see copyright 	written dashless 
notice 	commits represents number 
lua error 	parents need 
recovery functions 	dashes edges fit 
chain list 	neatly commit 
jump buffers 	output row containing 
error code 	commit iterate 
error 	including graph num 
message current 	columns since 
top overflow 	current commit may 
undo overflow 	existing columns 
close eventual 	happens current 
pending closures 	commit doesn children 
chain 	already processed 
error handler 	way merge commit 
restore old 	graph pre 
error handler 	commit stage way 
size enough 	merges first 
overflow handling 	line output commit 
overflow 	check see 
tail call 	previous line output 
debug information 	graph post 
ensure minimum 	merge branch line 
stack size 	coming commit 
cannot call 	may output branch 
hooks 	line line 
inside hook 	instead makes output 
compat old 	look nicer 
style vararg 	update graph state 
number extra 	output post 
arguments create 	merge row 
arg 	since current commit 
table put 	merge find 
extra arguments 	columns parent commits 
arg table 	columns use 
store counter 	format edges update 
field move 	graph state 
parameters 	clear mapping since 
position first 	update columns 
argument position 	always inserts leftmost 
first argument 	column first 
arg parameter 	branch target location 
open hole 	always either 
inside 	current location left 
stack func 	current location 
previous call 	never move branches 
may change 	right makes 
stack tag 	graph much 
method function 	legible since whenever 
called 	branches cross 
func function 	one moving directions 
check function 	column already 
tag method 	correct place nothing 
lua function 	left move 
prepare call 	left one isn 
varargs 	already edge 
vararg function 	moving horizontally one 
previous call 	variable target 
may change 	index graph column 
stack enter 	therefore target 
function starting 	actual screen column 
point 	first horizontal 
hooks already 	line branch line 
incremented correct 	left already 
function call 	target combine line 
ensure minimum 	since share 
stack size 	parent commit 
enter 	anything output mapping 
function actual 	since existing 
call yielding 	branch line already 
next call 	taken care 
may change 	branch line left 
stack lua 	isn target 
function 	need cross space 
tail calls 	left branch 
res position 	always empty branch 
result restore 	left space 
restore savedpc 	eventual target mark 
move results 	branch horizontal 
correct 	edge prevent edges 
place iff 	moving horizontally 
wanted lua 	mapping may smaller 
multret call 	old mapping 
function lua 	output line mapping 
function called 	info mappings 
func 	first segment 
arguments stack 	won next line 
right function 	swap mapping 
returns results 	mapping graph mapping 
stack starting 	indicates branch 
original function 	lines already correct 
position 	positions done 
error handing 	otherwise need collapse 
stack error 	branch lines 
lua function 	together output row 
call start 	containing commit 
coroutine resuming 	iterate including graph 
previous 	num columns 
common finish 	since current commit 
interrupted execution 	may existing 
call complete 	columns happens current 
correct top 	commit doesn 
multiple results 	children already processed 
yielded 	update graph 
inside hook 	prev state 
execution error 	since output padding 
mark dead 	line showing 
protect stack 	diff merge parents 
slots error 	called parent 
occurred 	without graph update 
close eventual 	called simply 
pending closures 	output single padding 
execute parser 	line print 
data parser 	strbuf line line 
buffer used 	display graph 
scanner 	info line first 
initialize eventual 	graph print 
upvalues ldo.h 	message buffer message 
name line 	buffer cmit 
func nresults 	fmt oneline cmit 
func results 	fmt userformat 
func 	already missing 
oldtop first 	terminating newline formats 
result newsize 	show commit 
newsize errcode 	message output needed 
errcode oldtop 	commit show 
ldo roberto 	doesn terminating newline 
exp 	print one 
stack call 	start remainder graph 
structure lua 	output line 
see copyright 	ends newline output 
notice lua 	graph.h colors 
results lua 	colors max opt 
precall 	graph commit 
initiated call 	graph commit finished 
lua function 	graph graph 
call function 	graph graph graph 
funtion yielded 	graph show 
type functions 	commit msg graph 
ran 	pointer opaque 
runprotected ldump.c 	structure custom 
size size 	scheme column colors 
size size 	column color 
data strip 	scheme inserts ansi 
lua unlock 	color escapes 
writer 	colorize graph various 
lua dump 	color escapes 
dump dump 	stored entry corresponds 
dump dump 	color last 
mem getstr 	entry denotes escape 
dump dump 	resetting color 
dump 	back generating graph 
block getstr 	inserted various 
dump dump 	column characters function 
ttype ttype 	allows enable 
dump bvalue 	custom color escapes 
dump number 	colors max 
nvalue 	argument index last 
dump rawtsvalue 	reset entry 
lua dump 	functions must 
dump function 	called graph init 
dump vector 	called note 
dump dump 	function isn used 
dump 	git outside 
dump dump 	graph used git 
dump dump 	http git 
dump dump 	cgit use html 
dump dump 	colors create 
dump dump 	git graph update 
dump 	git graph 
code dump 	commit cause graph 
constants dump 	begin outputting 
debug lua 	lines commit next 
header dump 	time graph 
block dump 	next line called 
header 	graph update 
dump function 	called graph commit 
ldump roberto 	finished returns 
exp save 	next call 
precompiled lua 	graph next line 
chunks see 	output ellipsis 
copyright 	indicate portion graph 
notice lua 	missing determine 
include trailing 	graph finished outputting 
cannot happen 	lines current 
dump lua 	commit returns graph 
function precompiled 	next line 
chunk 	needs called graph 
lfunc.c nelems 	update called 
nelems level 	returns lines needed 
level size 	commit returned 
local number 	graph next line 
cast lua 	may still 
malloc 	called without calling 
size cclosure 	graph update 
lua link 	merely output appropriate 
obj gco 	vertical padding 
cast cast 	graph output 
lua malloc 	next line graph 
size 	formats next 
lclosure lua 	graph line specified 
link obj 	strbuf terminated 
gco cast 	newline returns line 
lua lua 	includes current 
link obj 	commit otherwise graph 
gco 	next line 
setnilvalue ngcotouv 	exactly time graph 
lua isdead 	update called 
obj gco 	note function isn 
changewhite obj 	used git 
gco lua 	outside graph used 
lua 	git http 
white obj 	git cgit wrap 
gco lua 	html around 
lua unlinkupval 	graph lines 
lua free 	graph show helper 
ngcotouv obj 	functions printing 
gco 	stdout graph non 
lua isblack 	print history 
isdead lua 	graph stdout including 
freeupval unlinkupval 	line containing 
setobj lua 	commit print terminating 
linkupval lua 	newline last 
lua 	line graph non 
link obj 	print one 
gco lua 	line history graph 
freearray lua 	stdout print 
freearray lua 	terminating newline last 
freearray lua 	line graph 
freearray 	non print one 
lua freearray 	line vertical 
lua freearray 	graph padding stdout 
lua free 	print terminating 
size cclosure 	newline last 
size lclosure 	line graph non 
lua 	print rest 
freemem getstr 	history graph commit 
lfunc roberto 	stdout print 
exp auxiliary 	terminating newline last 
functions manipulate 	line print 
prototypes closures 	commit message strbuf 
see 	remainder graph 
copyright notice 	stdout similar graph 
lua found 	show strbuf 
corresponding upvalue 	always prints remainder 
dead ressurect 	graph strbuf 
found create 	ends newline output 
one 	printed graph 
current lives 	show commit msg 
stack chain 	end newline 
proper position 	strbuf missing terminating 
link uvhead 	newline including 
list uvhead 	empty output 
list 	printed graph show 
open open 	commit msg 
list free 	also missing terminating 
upvalue open 	newline graph 
list free 	grep.c grep defaults 
upvalue current 	opt run 
lives 	opt arg opt 
link upvalue 	color opt 
gcroot list 	prefix def grep 
look local 	commit pattern 
variable line 	type grep pattern 
line function 	type option 
func 	create grep pat 
returns found 	tail pat 
variable active 	len append header 
found lfunc.h 	grep pattern 
nelems nelems 	append grep pattern 
level level 	append grep 
func 	pat opt 
local number 	pat ret error 
lfunc roberto 	opt error 
exp auxiliary 	erroffset options line 
functions manipulate 	eol match 
prototypes closures 	eflags ovector ret 
see 	flags opt 
copyright notice 	line eol match 
lua lgc.c 	eflags len 
deadmem curr 	opt err errbuf 
weakkey weakvalue 	grep pat 
mode max 	list list list 
used 	list list 
used lim 	opt left right 
iskey count 	opt header 
curr deadmask 	expr opt header 
newsize udata 	expr opt 
oldah oldt 	opt left 
udsize 	opt data size 
old old 	color opt 
lim lua 	sign opt name 
ttisnil gval 	line eol 
iscollectable gkey 	match kwsm offset 
setttype gkey 	preg line 
lua 	eol match eflags 
iswhite isdead 	line eol 
white gray 	match eflags hit 
gco gray 	bol eol 
black markobject 	eol field len 
markobject gco 	match one 
gco 	pattern match expr 
markvalue gray 	eval match 
black gco 	expr match line 
gco gco 	match next 
gco lua 	pattern next match 
makewhite reallymarkobject 	opt bol 
iswhite 	eol name 
isfinalized gco 	lno sign rest 
fasttm gco 	match color 
markfinalized gco 	line color buf 
sizeudata gco 	match eflags 
markfinalized gco 	grep use locks 
markobject 	grep attr 
gfasttm ttisstring 	mutex grep read 
strchr svalue 	mutex opt 
strchr svalue 	bol eol xecfg 
cast obj 	buf opt 
gco markvalue 	bol lno eol 
sizenode 	opt bol 
gnode lua 	end lno funcname 
ttype gkey 	lno funcname 
ttisnil gval 	needed eol sign 
ttisnil gval 	opt opt 
removeentry lua 	left lno bol 
ttisnil 	lno bol 
gkey markvalue 	last bol 
gkey markvalue 	earliest hit opt 
gval stringmark 	buf size 
markvalue stringmark 	driver buf size 
markobject stringmark 	opt collect 
markobject 	hits bol left 
markvalue lua 	lno last 
markobject markobject 	hit binary match 
cast cast 	count lookahead 
lua realloc 	show function textconv 
condhardstacktests lua 	xecfg eol 
realloc 	hit buf opt 
lua reallocstack 	opt buf 
condhardstacktests lua 	size grep source 
reallocstack markvalue 	init filename 
lua markvalue 	data size memset 
setnilvalue checkstacksizes 	color color 
lua 	color color color 
isgray gray 	color color 
black gco 	color strcmp 
traversetable black 	strcmp strcmp strcmp 
gray sizenode 	strcmp die 
gco traverseclosure 	userdiff config strcmp 
size 	git config 
cclosure size 	strcmp parse pattern 
lclosure gco 	type arg 
black gray 	strcmp git config 
traversestack gco 	strcmp git 
traverseproto lua 	config strcmp git 
propagatemark 	config colorbool 
iscollectable ttisstring 	strcmp strcmp strcmp 
stringmark rawtsvalue 	strcmp strcmp 
iswhite gcvalue 	strcmp strcmp strcmp 
ttisuserdata isfinalized 	strcmp config 
uvalue gco 	error nonbool color 
lua 	parse color 
testbit testbit 	parse config 
testbit iscleared 	error nonbool color 
setnilvalue sizenode 	parse memset 
gnode ttisnil 	strlen color color 
gval iscleared 	color color 
key 	color color color 
tval iscleared 	color create 
gval setnilvalue 	grep pat xmalloc 
gval removeentry 	append header 
lua freeproto 	grep pattern append 
gco lua 	grep pat 
freeclosure 	xsnprintf xsnprintf die 
gco lua 	pcre compile 
freeupval gco 	compile regexp failed 
lua free 	pcre study 
gco lua 	die pcre exec 
gco gco 	size die 
lua 	pcre free pcre 
freethread gco 	free die 
lua freemem 	memchr regex 
sizestring gco 	special kwsalloc kwsalloc 
lua freemem 	kwsincr kwsprep 
sizeudata gco 	compile pcre regexp 
lua 	regcomp regerror 
otherwhite sweepwholelist 	regfree compile regexp 
gco lua 	failed xcalloc 
isdead testbit 	compile pattern die 
makewhite lua 	die xcalloc 
isdead bitmask 	compile pattern die 
freeobj 	compile pattern 
cast lua 	atom compile pattern 
resize lua 	die compile 
sizebuffer lua 	pattern die xcalloc 
sizebuffer lua 	compile pattern 
resizebuffer rawgco 	compile pattern die 
makewhite 	xcalloc compile 
fasttm setobj 	pattern fputc fputc 
setuvalue lua 	indent dump 
call gctm 	grep pat 
bitmask sweepwholelist 	dump grep expression 
sweepwholelist 	indent dump 
markobject markobject 	grep expression dump 
markvalue markvalue 	grep expression 
registry markmt 	indent dump grep 
lua isgray 	expression dump 
obj gco 	grep expression indent 
markvalue 	dump grep 
remarkupvals propagateall 	expression fflush xcalloc 
lua iswhite 	xcalloc die 
obj gco 	die compile regexp 
markobject markmt 	compile pattern 
propagateall propagateall 	atom die grep 
lua 	expr grep 
separateudata marktmu 	expr grep expr 
propagateall cleartable 	prep header 
cast otherwhite 	patterns compile regexp 
markroot propagatemark 	compile pattern 
atomic sweepwholelist 	expr die 
lua 	grep splice grep 
sweeplist check 	expr compile 
sizes lua 	grep patterns real 
gctm lua 	dump grep 
singlestep setthreshold 	expression free pattern 
lua lua 	expr free 
singlestep 	pattern expr free 
markroot singlestep 	pattern expr 
setthreshold lua 	free kwsfree free 
isblack iswhite 	pcre regexp 
isdead isdead 	regfree free free 
lua lua 	free pattern 
ttype 	expr isalnum want 
reallymarkobject makewhite 	color output 
obj gco 	strlen output output 
lua isblack 	strlen output 
isdead lua 	output output color 
black gray 	output color 
lua 	strlen output 
white obj 	kwsexec regexec fixmatch 
gco isgray 	pcrematch regmatch 
gray black 	output output color 
lua barrier 	output output 
makewhite lua 	color output output 
lgc 	color strlen 
roberto exp 	output output color 
garbage collector 	strlen output 
see copyright 	sep snprintf output 
notice lua 	color strlen 
dead key 	output sep next 
udata 	match output 
never gray 	color output color 
closed open 	output color 
upvalues never 	output pthread mutex 
black may 	pthread mutex 
marked left 	unlock grep 
previous 	source load driver 
move dead 	xdiff find 
udata need 	func find func 
finalization list 	isalpha match 
tmudata bother 	funcname show line 
need finalization 	match funcname 
must 	match funcname show 
call method 	funcname line 
link curr 	show line patmatch 
end tmudata 	fwrite grep 
list list 	source load alloc 
empty creates 	filespec fill 
circular 	filespec fill filespec 
list weak 	die grep 
mode really 	read fill textconv 
weak clear 	grep read 
bits must 	unlock free filespec 
cleared put 	grep source 
appropriate 	clear data 
list empty 	grep source load 
entries marks 	driver grep 
conditional may 	attr userdiff textconv 
happen prototype 	grep attr 
still created 	unlock grep source 
mark 	binary grep 
literals mark 	source binary die 
upvalue names 	memset lookahead 
mark nested 	fill textconv grep 
protos mark 	look ahead 
local variable 	end line match 
names 	line show 
mark upvalues 	name output output 
mark upvalues 	color strlen 
number use 	output show pre 
part stack 	context show 
use handling 	funcname line show 
overflow 	line match 
touch stacks 	funcname show 
still big 	line show name 
enough still 	xdiff clear 
big enough 	find func output 
traverse one 	color strlen 
gray 	output sep snprintf 
turning black 	output strlen 
returns quantity 	grep source clr 
traversed table 	hit marker 
weak keep 	grep source chk 
gray next 	hit marker 
function 	grep source grep 
tells whether 	source init 
key cleared 	grep source grep 
weak table 	source clear 
non collectable 	free free free 
objects never 	grep source 
removed 	clear data free 
weak tables 	grep read 
behave values 	read sha 
never removed 	file grep read 
objects really 	unlock error 
collected cannot 	sha hex lstat 
keep 	error strerror 
userdata finalized 	isreg xsize open 
keep keys 	xmallocz read 
values values 	full error strerror 
never weak 	close free 
clear collected 	close grep source 
entries 	load file 
weaktables collected 	grep source load 
non empty 	sha die 
entry entry 	grep attr userdiff 
table sweep 	find path 
open upvalues 	userdiff find name 
dead 	grep attr 
make white 	unlock grep 
next cycle 	source load driver 
must erase 	grep source 
curr first 	load buffer binary 
element list 	initialize grep 
adjust 	defaults hardcoded defaults 
first check 	could compiler 
size hash 	without initializers code 
table big 	gets unwieldy 
check size 	unreadable read configuration 
buffer buffer 	file store 
big 	grep defaults initialize 
first element 	one instance 
udata tmudata 	grep opt copy 
last element 	values read 
root list 	configuration information earlier 
stop debug 	call git 
hooks 	config grep config 
tag method 	fall atom 
avoid steps 	use libpcre 
restore hooks 	use libpcre regcomp 
restore threshold 	cannot accept 
call tag 	patterns consider pattern 
methods 	containing nul 
mask collect 	atom atom atom 
elements free 	match beginning 
lists mark 	must either beginning 
root make 	line word 
table traversed 	boundary last must 
main 	word similarly 
stack total 	match end must 
size userdata 	either end 
finalized remark 	line word boundary 
occasional upvalues 	next must 
maybe dead 	word words consist 
threads 	least one 
traverse objects 	character could one 
cautch write 	match line 
barrier remarkupvals 	first match 
remark weak 	might strict word 
tables mark 	match later 
running 	ones could forward 
mark basic 	next possible 
metatables remark 	start next position 
gray separate 	following non 
userdata finalized 	word call collect 
mark preserved 	hits without 
userdata 	extended atom protects 
remark propagate 	access gitattributes 
preserveness collected 	machinery safe git 
objects weak 	attr mutex 
tables flip 	protecting access rewind 
current white 	need look 
first 	even back find 
estimate lua 	function signature 
checkmemory start 	back forward punt 
collection gray 	complex stuff 
objects finish 	punt header 
mark phase 	stuff find beginning 
nothing 	line textconv 
sweep end 	intimately tied diff 
sweep phase 	filespecs pretend 
nothing sweep 	one could unify 
end sweep 	grep source 
phase end 	diff filespec structs 
collection 	mess could 
limit lim 	away fill textconv 
gcstepmul reset 	remotely safe 
sweep marks 	may load objects 
sweep elements 	behind scenes 
returning white 	modifies diff tempfile 
reset 	structure normal 
collector lists 	fill textconv usage 
finish pending 	diff machinery 
sweep phase 	would keep 
must keep 	textconv buf separate 
invariant restore 	diff filespec 
invariant 	much grep code 
mind mark 	passes around 
white avoid 	grep source assumes 
barriers make 	buf pointer 
table gray 	beginning thing searching 
link upvalue 	install textconv 
rootgc 	version grep source 
list closed 	taking care 
upvalues need 	leak existing buffer 
barrier sweep 	show hunk 
phase sweep 	marks first file 
turning white 	threads easily 
lgc.h 	identify first file 
lgc roberto 	always put 
exp garbage 	hunk marks skip 
collector see 	first one 
copyright notice 	later work 
lua possible 	done might shared 
states 	textconv cache 
garbage collector 	data safe know 
userful bit 	result textconv 
tricks layout 	text care binary 
bit use 	handling unmatch 
marked field 	look ahead skips 
bit 	quickly line 
white type 	possibly next hit 
bit white 	call need 
type bit 	something skipping current 
black bit 	line response 
userdata finalized 	unmatch current line 
bit 	inside post 
tables weak 	context window show 
keys bit 	current line 
tables weak 	context around previous 
values bit 	hit doesn 
collected bit 	hit grep 
main 	foo bla list 
lg chunkc 	lines either 
malloc conf 	inversion done outside 
mallocx ptr 	hit line 
dallocx test 	haven shown pre 
make sure 	context lines 
opt 	would need show 
chunk clamping 	last hit 
sufficient practice 	within post context 
test program 	need show 
fail debug 	line see hit 
assertion initialization 	want show 
abort 	needswork real grep 
rather test 	foo gives 
soft failing 	many bar lines 
clamping insufficient 	feels mostly 
libev.h watcher 	useless sometimes useful 
revents watcher 	maybe make 
revents 	another option 
privdata loop 	suppress hit markers 
privdata loop 	meaningful top 
privdata loop 	level node top 
privdata loop 	level nodes 
privdata redis 	hit markers see 
handle 	hits two 
read redis 	pass grep check 
handle write 	buffer wide 
start stop 	match otherwise toplevel 
start stop 	terms hit 
redis libev 	bit differently first 
del 	clear hit 
read redis 	markers user provided 
libev del 	buf intact 
write free 	builtin git grep 
malloc init 	copyright junio 
init copyright 	hamano use one 
pieter 	producer threads 
noordhuis pcnoordhuis 	consumer threads 
gmail dot 	producer adds work 
rights reserved 	items todo 
redistribution use 	consumers pick work 
source binary 	items range 
forms 	todo done todo 
without modification 	start todo 
permitted provided 	work items processed 
following conditions 	consumer haven 
met redistributions 	written result stdout 
source code 	yet work 
must 	items todo start 
retain copyright 	todo end 
notice list 	waiting picked consumer 
conditions following 	ranges modulo 
disclaimer redistributions 	todo size work 
binary form 	items added 
must 	protects variables 
reproduce copyright 	signalled work item 
notice list 	added todo 
conditions following 	signalled result one 
disclaimer documentation 	work item 
materials provided 	written stdout signalled 
distribution 	finished everything 
neither name 	skip leading hunk 
redis names 	mark first 
contributors may 	file wait work 
used endorse 	done wake 
promote products 	consumer threads see 
derived 	work pthreads 
software without 	valid worktree file 
specific prior 	cache entry 
written permission 	identical even worktree 
software provided 	file modified 
copyright holders 	use cache version 
contributors 	instead compensate 
express implied 	loop control 
warranties including 	ignore empty line 
limited implied 	like grep 
warranties merchantability 	paths must exist 
fitness particular 	working pattern 
purpose 	specified take first 
disclaimed shall 	unrecognized non 
copyright owner 	option pattern follows 
contributors liable 	must zero 
direct indirect 	valid refs exists 
incidental special 	existing paths 
exemplary 	pattern first unrecognized 
consequential damages 	non option 
including limited 	beginning refs list 
procurement substitute 	continues exists 
goods services 	paths die way 
loss use 	beginning skip 
data 	separator know cannot 
profits business 	separating revisions 
interruption however 	pathnames haven 
caused theory 	even patterns yet 
liability whether 	first unrecognized 
contract strict 	non option token 
liability 	check revs 
tort including 	paths rev rest 
negligence otherwise 	paths grep 
arising way 	usage num threads 
use software 	threads source 
even advised 	done todo todo 
possibility 	start todo 
damage nothing 	end todo done 
attached something 	work added 
already attached 	grep mutex cond 
create container 	cond write 
context events 	cond result skip 
functions 	first line 
start stop 	work ret old 
listening events 	done len 
initialize read 	arg hit 
write events 	opt opt buf 
libevent.h arg 	size opt 
arg 	err hit read 
privdata privdata 	sha file 
privdata privdata 	opt sha filename 
privdata redis 	name len 
handle read 	path pathbuf hit 
redis handle 	opt filename 
write 	buf hit opt 
del del 	data len 
del del 	path list opt 
free malloc 	prefix path 
copyright pieter 	list child status 
noordhuis pcnoordhuis 	opt pathspec 
gmail 	cached hit opt 
dot rights 	pathspec len 
reserved redistribution 	check attr 
use source 	hit entry old 
binary forms 	baselen len 
without modification 	sub data size 
permitted 	opt pathspec 
provided following 	obj name path 
conditions met 	data size 
redistributions source 	hit len opt 
code must 	pathspec list 
retain copyright 	hit real obj 
notice 	opt pathspec 
list conditions 	exc std dir 
following disclaimer 	hit opt 
redistributions binary 	arg unset grep 
form must 	opt endp 
reproduce copyright 	opt arg unset 
notice 	grep opt 
list conditions 	stdin patterns lno 
following disclaimer 	opt arg 
documentation materials 	unset grep 
provided distribution 	opt opt arg 
neither name 	unset grep 
redis 	opt opt arg 
names contributors 	unset grep 
may used 	opt opt arg 
endorse promote 	unset grep 
products derived 	opt opt arg 
software without 	unset grep 
specific 	opt argc argv 
prior written 	prefix hit 
permission software 	opt exclude seen 
provided copyright 	dashdash external 
holders contributors 	grep allowed ignored 
express implied 	pager opt 
warranties 	list pathspec path 
including limited 	list dummy 
implied warranties 	use index pattern 
merchantability fitness 	type arg 
particular purpose 	options fallback 
disclaimed shall 	arg sha pager 
copyright 	len buf 
owner contributors 	use exclude pthread 
liable direct 	mutex pthread 
indirect incidental 	mutex unlock grep 
special exemplary 	pthread cond 
consequential damages 	wait size grep 
including 	unlock grep 
limited procurement 	size write die 
substitute goods 	grep source 
services loss 	clear pthread cond 
use data 	signal pthread 
profits business 	cond signal grep 
interruption 	unlock work 
however caused 	grep source grep 
theory liability 	source clear 
whether contract 	data work done 
strict liability 	free grep 
tort including 	patterns free 
negligence 	strbuf pthread mutex 
otherwise arising 	init pthread 
way use 	mutex init pthread 
software even 	mutex init 
advised possibility 	pthread cond init 
damage nothing 	pthread cond 
attached 	init pthread cond 
something already 	init size 
attached create 	strbuf init xcalloc 
container context 	grep opt 
events functions 	dup compile grep 
start 	patterns pthread 
stop listening 	create die strerror 
events initialize 	grep pthread 
install read 	cond wait pthread 
write events 	cond broadcast 
libuv.h handle 	grep unlock pthread 
status 	free pthread 
events privdata 	mutex destroy 
privdata privdata 	pthread mutex destroy 
privdata handle 	pthread mutex 
privdata loop 	destroy pthread cond 
redis handle 	destroy pthread 
read 	cond destroy pthread 
redis handle 	cond destroy 
write poll 	grep config git 
start poll 	color config 
start poll 	strcmp git config 
stop poll 	die quote 
start 	path relative strbuf 
poll start 	insert strbuf 
poll stop 	addstr work strbuf 
free close 	release grep 
malloc memset 	source init strbuf 
poll init 	release grep 
linenoise.c 	source grep 
unsupported term 	source clear quote 
completion callback 	path relative 
orig termios 	strbuf addstr work 
rawmode mlmode 	strbuf release 
atexit registered 	grep source init 
history 	strbuf release 
max len 	grep source grep 
history len 	source clear 
history ifd 	list append xstrndup 
ofd buf 	argv push 
buflen prompt 	run command exit 
plen 	read cache 
pos oldpos 	isreg intent path 
len cols 	match skip 
maxrows history 	worktree stage grep 
index line 	sha grep 
term raw 	file stage strcmp 
ifd 	entry entry 
ofd buf 	len entry 
cols rows 	interesting strbuf isreg 
ifd ofd 	grep sha 
start cols 	isdir read sha 
seq nread 	file die 
nwritten 	sha hex strbuf 
saved str 	addch init 
len copy 	desc grep free 
cvec len 	strbuf setlen 
len seq 	grep sha grep 
plen buf 	read read 
len 	reference grep read 
pos seq 	unlock die 
plen rows 	oid hex strlen 
rpos rpos 	strbuf init 
col old 	strbuf strbuf addch 
rows dir 	init desc 
old 	grep strbuf release 
pos diff 	free die 
stdin stdout 	deref tag 
buf buflen 	grep memset setup 
prompt nread 	standard excludes 
seq aux 	fill directory dir 
quit 	path match 
nread buf 	grep file strtol 
buflen prompt 	error strcmp 
count prompt 	fopen die errno 
buf count 	strbuf getline 
len line 	append grep pat 
linecopy 	fclose strbuf 
len tocopy 	release append grep 
filename filename 	pattern append 
buf getenv 	grep pattern append 
strcasecmp isatty 	grep pattern 
atexit tcgetattr 	append grep pattern 
tcsetattr 	append grep 
tcsetattr write 	pattern init grep 
read sscanf 	defaults git 
ioctl cursor 	config grep 
position write 	init parse options 
cursor position 	grep commit 
snprintf 	pattern type git 
write strlen 	config setup 
write fflush 	git directory strcmp 
free free 	append grep 
completion callback 	pattern git pager 
linenoise beep 	list append 
strlen 	die compile grep 
refresh line 	patterns sha 
refresh line 	context parse die 
read free 	verify non 
completions linenoise 	filename path strcmp 
beep refresh 	die start 
line 	threads verify filename 
snprintf free 	parse pathspec 
completions strlen 	die strlen 
malloc memcpy 	dir sep strcmp 
realloc free 	list append 
realloc memcpy 	strcmp strcmp strbuf 
free 	addf strcmp 
strlen init 	list append strbuf 
snprintf append 	detach setup 
strlen append 	pager die die 
strlen append 	grep directory 
snprintf append 	die setup work 
strlen 	grep cache 
snprintf append 	die grep objects 
strlen write 	wait run 
free strlen 	pager free grep 
init lndebug 	patterns initialize 
snprintf append 	grep defaults hardcoded 
strlen 	defaults could 
lndebug snprintf 	compiler without initializers 
append strlen 	code gets 
lndebug snprintf 	unwieldy unreadable 
append strlen 	read configuration file 
append strlen 	store grep 
append 	defaults initialize one 
lndebug append 	instance grep 
snprintf append 	opt copy values 
strlen lndebug 	read configuration 
lndebug snprintf 	information earlier call 
append strlen 	git config 
lndebug 	grep config fall 
snprintf snprintf 	atom use 
append strlen 	libpcre use libpcre 
lndebug write 	regcomp cannot 
free refresh 	accept patterns consider 
multi line 	pattern containing 
refresh 	nul atom atom 
single line 	atom match 
write refresh 	beginning must either 
line memmove 	beginning line 
refresh line 	word boundary 
refresh line 	last must word 
refresh 	similarly match 
line refresh 	end must either 
line refresh 	end line 
line free 	word boundary next 
strdup strncpy 	must word 
strlen refresh 	words consist least 
line 	one character 
memmove refresh 	could one match 
line memmove 	line first 
refresh line 	match might strict 
memmove refresh 	word match 
line strlen 	later ones could 
columns 	forward next 
linenoise history 	possible start next 
write read 	position following 
complete line 	non word call 
free linenoise 	collect hits 
edit move 	without extended 
end 	atom protects access 
linenoise edit 	gitattributes machinery 
backspace linenoise 	safe git attr 
edit free 	mutex protecting 
refresh line 	access rewind need 
linenoise edit 	look even 
move 	back find function 
left linenoise 	signature back 
edit move 	forward punt complex 
right linenoise 	stuff punt 
edit history 	header stuff find 
next linenoise 	beginning line 
edit 	textconv intimately tied 
history next 	diff filespecs 
read read 	pretend one could 
read linenoise 	unify grep 
edit linenoise 	source diff 
edit history 	filespec structs mess 
next 	could away 
linenoise edit 	fill textconv remotely 
history next 	safe may 
linenoise edit 	load objects behind 
move right 	scenes modifies 
linenoise edit 	diff tempfile structure 
move 	normal fill 
left linenoise 	textconv usage diff 
edit move 	machinery would 
home linenoise 	keep textconv buf 
edit move 	separate diff 
end linenoise 	filespec much grep 
edit 	code passes 
move home 	around grep source 
linenoise edit 	assumes buf 
move end 	pointer beginning thing 
linenoise edit 	searching install 
insert refresh 	textconv version 
line 	grep source taking 
refresh line 	care leak 
linenoise edit 	existing buffer show 
move home 	hunk marks 
linenoise edit 	first file threads 
move end 	easily identify 
linenoise 	first file always 
clear screen 	put hunk 
refresh line 	marks skip first 
linenoise edit 	one later 
prev word 	work done might 
enable raw 	shared textconv 
mode 	cache data safe 
memset read 	know result 
memmove memcmp 	textconv text care 
isprint fflush 	binary handling 
disable raw 	unmatch look ahead 
mode isatty 	skips quickly 
fgets 	line possibly 
strlen enable 	next hit call 
raw mode 	need something 
linenoise edit 	skipping current line 
disable raw 	response unmatch 
mode unsupported 	current line inside 
term 	post context 
fflush fgets 	window show current 
strlen strdup 	line context 
linenoise raw 	around previous hit 
strdup free 	doesn hit 
free disable 	grep foo bla 
raw 	list lines 
mode free 	either inversion done 
history malloc 	outside hit 
memset strcmp 	line haven shown 
strdup free 	pre context 
memmove malloc 	lines would need 
free 	show last 
memset memcpy 	hit within 
free fopen 	post context need 
fclose fopen 	show line 
fgets strchr 	see hit want 
strchr linenoise 	show needswork 
history 	real grep foo 
fclose linenoise 	gives many 
guerrilla line 	bar lines feels 
editing library 	mostly useless 
idea line 	sometimes useful maybe 
editing lib 	make another 
needs 	option suppress hit 
lines code 	markers meaningful 
find latest 	top level node 
source code 	top level 
http github 	nodes hit markers 
antirez linenoise 	see hits 
number 	two pass grep 
crazy assumptions 	check buffer 
happen unix 	wide match 
computers around 	otherwise toplevel terms 
copyright salvatore 	hit bit 
sanfilippo antirez 	differently first clear 
gmail 	hit markers 
dot copyright 	user provided buf 
pieter noordhuis 	intact builtin 
pcnoordhuis gmail 	git grep copyright 
dot rights 	junio hamano 
reserved redistribution 	use one producer 
use 	threads consumer 
source binary 	threads producer adds 
forms without 	work items 
modification permitted 	todo consumers pick 
provided following 	work items 
conditions met 	range todo done 
redistributions 	todo start 
source code 	todo work 
must retain 	items processed consumer 
copyright notice 	haven written 
list conditions 	result stdout yet 
following disclaimer 	work items 
redistributions 	todo start todo 
binary form 	end waiting 
must reproduce 	picked consumer ranges 
copyright notice 	modulo todo 
list conditions 	size work items 
following disclaimer 	added protects 
documentation 	variables signalled work 
materials provided 	item added 
distribution software 	todo signalled result 
provided copyright 	one work 
holders contributors 	item written stdout 
express implied 	signalled finished 
warranties 	everything skip leading 
including limited 	hunk mark 
implied warranties 	first file 
merchantability fitness 	wait work done 
particular purpose 	wake consumer 
disclaimed shall 	threads see work 
copyright 	pthreads valid 
holder contributors 	worktree file cache 
liable direct 	entry identical 
indirect incidental 	even worktree file 
special exemplary 	modified use 
consequential damages 	cache version instead 
including 	compensate loop 
limited procurement 	control ignore empty 
substitute goods 	line like 
services loss 	grep paths must 
use data 	exist working 
profits business 	pattern specified take 
interruption 	first unrecognized 
however caused 	non option pattern 
theory liability 	follows must 
whether contract 	zero valid 
strict liability 	refs exists existing 
tort including 	paths pattern 
negligence 	first unrecognized non 
otherwise arising 	option beginning 
way use 	refs list continues 
software even 	exists paths 
advised possibility 	die way beginning 
damage references 	skip separator 
http 	know cannot separating 
invisible island 	revisions pathnames 
net xterm 	haven even patterns 
ctlseqs ctlseqs 	yet first 
html http 	unrecognized non option 
www waylabs 	token check 
www 	revs paths rev 
products wizcon 	rest paths 
html todo 	grep.c grep defaults 
list filter 	opt run 
bogus ctrl 	opt arg 
combinations win 	opt color opt 
support 	prefix def 
bloat history 	grep commit pattern 
search like 	type grep 
ctrl readline 	pattern type option 
list escape 	create grep 
sequences used 	pat tail pat 
program 	len append 
everything three 	header grep pattern 
sequences order 	append grep 
cheap may 	pattern append grep 
flickering effect 	pat opt 
slow terminal 	pat ret error 
lesser 	opt error 
sequences compatible 	erroffset options line 
erase line 	eol match 
sequence esc 	eflags ovector 
effect missing 	ret flags opt 
clear cursor 	line eol 
end 	match eflags len 
line effect 	opt err 
clear beginning 	errbuf grep pat 
line cursor 	list list 
effect clear 	list list list 
entire line 	opt left 
cuf 	right opt header 
ursor forward 	expr opt 
sequence esc 	header expr opt 
effect moves 	opt left 
cursor forward 	opt data size 
chars cub 	color opt 
ursor 	sign opt name 
backward sequence 	line eol 
esc effect 	match kwsm offset 
moves cursor 	preg line 
backward chars 	eol match 
following used 	eflags line eol 
terminal 	match eflags 
width getting 	hit bol eol 
width tiocgwinsz 	eol field 
ioctl fails 	len match one 
dsr device 	pattern match 
status report 	expr eval match 
sequence 	expr match 
esc effect 	line match next 
reports current 	pattern next 
cusor position 	match opt bol 
esc row 	eol name 
column multi 	lno sign rest 
line 	match color 
mode enabled 	line color buf 
also use 	match eflags 
additional escape 	grep use locks 
sequence however 	grep attr 
multi line 	mutex grep 
editing 	read mutex opt 
disabled cuu 	bol eol 
cursor sequence 	xecfg buf opt 
esc effect 	bol lno 
moves cursor 	eol opt bol 
chars cud 	end lno 
cursor 	funcname lno funcname 
sequence esc 	needed eol 
effect moves 	sign opt opt 
cursor chars 	left lno 
linenoise clear 	bol lno bol 
screen called 	last bol 
two 	earliest hit opt 
additional escape 	buf size 
sequences used 	driver buf size 
order clear 	opt collect 
screen position 	hits bol left 
cursor home 	lno last 
position 	hit binary 
cup cursor 	match count lookahead 
position sequence 	show function 
esc effect 	textconv xecfg eol 
moves cursor 	hit buf 
upper left 	opt opt buf 
corner 	size grep 
erase display 	source init filename 
sequence esc 	data size 
effect clear 	memset color color 
whole screen 	color color 
order restore 	color color color 
exit 	color strcmp 
atexit function 	strcmp strcmp strcmp 
check restore 	strcmp die 
needed multi 	userdiff config strcmp 
line mode 	git config 
single line 	strcmp parse 
atexit 	pattern type arg 
time linenoise 	strcmp git 
state structure 	config strcmp git 
represents state 	config strcmp 
line editing 	git config colorbool 
pass state 	strcmp strcmp 
functions 	strcmp strcmp strcmp 
implementing specific 	strcmp strcmp 
editing functionalities 	strcmp strcmp config 
terminal stdin 	error nonbool 
file descriptor 	color parse color 
terminal stdout 	parse config 
file 	error nonbool color 
descriptor edited 	parse memset 
line buffer 	strlen color color 
edited line 	color color 
buffer size 	color color color 
prompt 	color create 
display prompt 	grep pat 
length current 	xmalloc append header 
cursor position 	grep pattern 
previous refresh 	append grep pat 
cursor position 	xsnprintf xsnprintf 
current 	die pcre compile 
edited line 	compile regexp 
length number 	failed pcre study 
columns terminal 	die pcre 
maximum num 	exec size die 
rows used 	pcre free 
far 	pcre free die 
multiline mode 	memchr regex 
history index 	special kwsalloc kwsalloc 
currently editing 	kwsincr kwsprep 
ctrl ctrl 	compile pcre regexp 
ctrl ctrl 	regcomp regerror 
ctrl 	regfree compile regexp 
ctrl ctrl 	failed xcalloc 
tab ctrl 	compile pattern 
ctrl enter 	die die xcalloc 
ctrl ctrl 	compile pattern 
ctrl ctrl 	die compile pattern 
ctrl 	atom compile 
escape backspace 	pattern die compile 
debugging macro 	pattern die 
low level 	xcalloc compile pattern 
terminal handling 	compile pattern 
use multi 	die xcalloc compile 
line 	pattern fputc 
mode terminal 	fputc indent dump 
name list 	grep pat 
terminals know 	dump grep expression 
able understand 	indent dump 
basic escape 	grep expression dump 
sequences 	grep expression 
raw mode 	indent dump grep 
magic shit 	expression dump 
modify original 	grep expression 
mode input 	indent dump grep 
modes parity 	expression fflush 
check 	xcalloc xcalloc die 
strip start 	die compile 
stop output 	regexp compile pattern 
control output 	atom die 
modes disable 	grep expr grep 
post processing 	expr grep 
control 	expr prep header 
modes bit 	patterns compile 
chars local 	regexp compile pattern 
modes choing 	expr die 
canonical extended 	grep splice grep 
functions signal 	expr compile 
chars 	grep patterns real 
control chars 	dump grep 
condition min 	expression free pattern 
number bytes 	expr free 
timer want 	pattern expr 
read every 	free pattern expr 
single 	free kwsfree 
without timeout 	free pcre regexp 
timer put 	regfree free 
terminal raw 	free free pattern 
mode flushing 	expr isalnum 
even check 	want color output 
late 	strlen output 
use esc 	output strlen output 
escape sequence 	output output 
query horizontal 	color output color 
cursor position 	strlen output 
error returned 	kwsexec regexec fixmatch 
success 	pcrematch regmatch 
position cursor 	output output color 
report cursor 	output output 
location read 	color output 
response esc 	output color strlen 
rows cols 	output output 
parse 	color strlen output 
number columns 	sep snprintf 
current terminal 	output color strlen 
fails ioctl 	output sep 
failed query 	next match output 
terminal initial 	color output 
position 	color output color 
restore later 	output pthread 
right margin 	mutex pthread mutex 
position restore 	unlock grep 
position recover 	source load driver 
clear screen 	xdiff find 
used 	func find func 
handle ctrl 	isalpha match 
nothing avoid 	funcname show line 
warning beep 	match funcname 
used completion 	match funcname 
nothing complete 	show funcname line 
choices 	show line 
already shown 	patmatch fwrite grep 
completion free 	source load 
list completion 	alloc filespec fill 
option populated 	filespec fill 
linenoise completion 	filespec die grep 
helper 	read fill 
function linenoise 	textconv grep read 
edit called 	unlock free 
user types 	filespec grep source 
tab key 	clear data 
order complete 	grep source load 
currently 	driver grep 
input state 	attr userdiff textconv 
editing encapsulated 	grep attr 
pointed linenoise 	unlock grep source 
state structure 	binary grep 
described structure 	source binary 
definition 	die memset lookahead 
show completion 	fill textconv 
original buffer 	grep look ahead 
tab escape 	end line 
show original 	match line show 
buffer update 	name output 
buffer 	output color strlen 
last read 	output show 
character callback 	pre context show 
function called 	funcname line 
tab completion 	show line match 
function used 	funcname show 
callback 	line show name 
function registered 	xdiff clear 
user order 	find func output 
completion options 	color strlen 
given input 	output sep snprintf 
user typed 	output strlen 
tab 	grep source 
see example 	clr hit marker 
source code 	grep source 
easy understand 	chk hit marker 
example line 	grep source 
editing define 	grep source init 
simple 	grep source 
append buffer 	grep source clear 
structure heap 	free free 
allocated append 	free grep source 
useful order 	clear data 
write escape 	free grep read 
sequences 	read sha 
buffer flush 	file grep read 
standard output 	unlock error 
single call 	sha hex lstat 
avoid flickering 	error strerror 
effects single 	isreg xsize 
line 	open xmallocz read 
low level 	full error 
line refresh 	strerror close free 
rewrite currently 	close grep 
edited line 	source load file 
accordingly buffer 	grep source 
content 	load sha die 
cursor position 	grep attr 
number columns 	userdiff find path 
terminal cursor 	userdiff find 
left edge 	name grep attr 
write prompt 	unlock grep 
current 	source load driver 
buffer content 	grep source 
erase right 	load buffer binary 
move cursor 	initialize grep 
original position 	defaults hardcoded defaults 
recover write 	could compiler 
error 	without initializers 
multi line 	code gets unwieldy 
low level 	unreadable read 
line refresh 	configuration file store 
rewrite currently 	grep defaults 
edited line 	initialize one instance 
accordingly 	grep opt 
buffer content 	copy values read 
cursor position 	configuration information 
number columns 	earlier call git 
terminal rows 	config grep 
used current 	config fall atom 
buf 	use libpcre 
cursor relative 	use libpcre regcomp 
row rpos 	cannot accept 
refresh colum 	patterns consider pattern 
position zero 	containing nul 
update maxrows 	atom atom atom 
needed 	match beginning 
first step 	must either 
clear lines 	beginning line word 
used start 	boundary last 
going last 	must word similarly 
row every 	match end 
row 	must either end 
clear clean 	line word 
top line 	boundary next must 
write prompt 	word words 
current buffer 	consist least one 
content end 	character could 
screen 	one match line 
prompt need 	first match 
emit newline 	might strict word 
move prompt 	match later 
first column 	ones could forward 
move cursor 	next possible 
right 	start next position 
position current 	following non 
cursor relative 	word call 
row till 	collect hits without 
reach expected 	extended atom 
positon column 	protects access gitattributes 
recover 	machinery safe 
write error 	git attr mutex 
calls two 	protecting access 
low level 	rewind need look 
functions refresh 	even back 
single line 	find function signature 
refresh 	back forward 
multi line 	punt complex stuff 
according selected 	punt header 
mode insert 	stuff find beginning 
character cursor 	line textconv 
current position 	intimately tied diff 
error 	filespecs pretend 
writing terminal 	one could 
returned otherwise 	unify grep source 
mlmode avoid 	diff filespec 
full update 	structs mess could 
line trivial 	away fill 
move 	textconv remotely safe 
cursor left 	may load 
move cursor 	objects behind scenes 
right move 	modifies diff 
cursor start 	tempfile structure normal 
line move 	fill textconv 
cursor 	usage diff machinery 
end line 	would keep 
substitute currently 	textconv buf separate 
edited line 	diff filespec 
next previous 	much grep code 
history entry 	passes around 
specified 	grep source assumes 
dir update 	buf pointer 
current history 	beginning thing 
entry overwrite 	searching install textconv 
next one 	version grep 
show entry 	source taking care 
character 	leak existing 
right cursor 	buffer show hunk 
without altering 	marks first 
cursor position 	file threads easily 
basically happens 	identify first 
keyboard key 	file always put 
backspace 	hunk marks 
implementation previosu 	skip first one 
word maintaining 	later work 
cursor start 	done might shared 
current word 	textconv cache 
function core 	data safe know 
line 	result textconv 
editing capability 	text care binary 
linenoise expects 	handling unmatch 
already raw 	look ahead 
mode every 	skips quickly line 
key pressed 	possibly next 
returned 	hit call need 
asap read 	something skipping 
resulting put 	current line response 
buf user 	unmatch current 
type enter 	line inside post 
ctrl typed 	context window 
function 	show current line 
returns length 	context around 
current buffer 	previous hit doesn 
populate linenoise 	hit grep 
state pass 	foo bla list 
functions implementing 	lines either 
specific 	inversion done outside 
editing functionalities 	hit line 
buffer starts 	haven shown pre 
empty make 	context lines 
sure always 	would need 
space nulterm 	show last hit 
latest 	within post 
history entry 	context need show 
always current 	line see 
buffer initially 	hit want show 
empty autocomplete 	needswork real 
callback returns 	grep foo gives 
error 	many bar 
reading otherwise 	lines feels mostly 
character handled 	useless sometimes 
next errors 	useful maybe make 
read next 	another option 
character enter 	suppress hit markers 
ctrl 	meaningful top 
backspace ctrl 	level node top 
ctrl right 	level nodes 
cursor line 	hit markers see 
empty act 	hits two 
end file 	pass grep 
ctrl 	check buffer wide 
swaps current 	match otherwise 
character previous 	toplevel terms hit 
ctrl ctrl 	bit differently 
ctrl ctrl 	first clear hit 
escape sequence 	markers user 
read 	provided buf intact 
next two 	builtin git 
bytes representing 	grep copyright junio 
escape sequence 	hamano use 
use two 	one producer threads 
calls handle 	consumer threads 
slow 	producer adds work 
terminals returning 	items todo 
two chars 	consumers pick work 
different times 	items range 
esc sequences 	todo done 
extended escape 	todo start todo 
read 	work items 
additional key 	processed consumer haven 
right left 	written result 
home end 	stdout yet work 
esc sequences 	items todo 
home end 	start todo end 
ctrl 	waiting picked 
whole line 	consumer ranges modulo 
ctrl current 	todo size 
end line 	work items added 
ctrl start 	protects variables 
line ctrl 	signalled work item 
end 	added todo 
line ctrl 	signalled result one 
clear screen 	work item 
ctrl previous 	written stdout signalled 
word special 	finished everything 
mode used 	skip leading 
linenoise 	hunk mark first 
order print 	file wait 
scan codes 	work done wake 
screen debugging 	consumer threads 
development purposes 	see work pthreads 
implemented linenoise 	valid worktree 
example 	file cache entry 
program keycodes 	identical even 
option shift 	worktree file modified 
left insert 	use cache 
current right 	version instead compensate 
left edge 	loop control 
manually 	ignore empty line 
raw mode 	like grep 
function calls 	paths must exist 
line editing 	working pattern 
function linenoise 	specified take first 
edit stdin 	unrecognized non 
file 	option pattern 
descriptor raw 	follows must zero 
mode tty 	valid refs 
read file 	exists existing paths 
pipe interactive 	pattern first 
editing high 	unrecognized non option 
level 	beginning refs 
function main 	list continues exists 
api linenoise 	paths die 
library function 	way beginning skip 
checks terminal 	separator know 
basic capabilities 	cannot separating revisions 
checking 	pathnames haven 
blacklist stupid 	even patterns yet 
terminals later 	first unrecognized 
either calls 	non option token 
line editing 	check revs 
function uses 	paths rev rest 
dummy 	paths grep 
fgets able 	usage num 
type something 	threads threads source 
even desperate 	done todo 
conditions history 	todo start todo 
free history 	end todo 
reset 	done work added 
used exit 	grep mutex 
avoid memory 	cond cond write 
leaks reported 	cond result 
valgrind exit 	skip first line 
fix terminal 	work ret 
initial 	old done len 
conditions api 	arg hit 
call entry 	opt opt buf 
linenoise history 	size opt 
uses pointers 	err hit read 
shifted memmoved 	sha file 
history 	opt sha 
max length 	filename name len 
reached order 	path pathbuf 
older entry 	hit opt filename 
make room 	buf hit 
one exactly 	opt data len 
suitable 	path list 
huge histories 	opt prefix path 
work well 	list child 
hundred entries 	status opt pathspec 
circular buffer 	cached hit 
smarter bit 	opt pathspec len 
complex 	check attr 
handle initialization 	hit entry old 
first call 	baselen len 
duplicated lines 	sub data size 
heap allocated 	opt pathspec 
copy line 	obj name path 
history 	data size 
reached max 	hit len 
length older 	opt pathspec list 
line maximum 	hit real 
length history 	obj opt pathspec 
function called 	exc std 
even 	dir hit opt 
already history 	arg unset 
function make 	grep opt endp 
sure retain 	opt arg 
latest len 	unset grep opt 
elements history 	stdin patterns 
length 	lno opt arg 
smaller amount 	unset grep 
items already 	opt opt arg 
inside history 	unset grep 
copy everything 	opt opt arg 
free elements 	unset grep 
use 	opt opt arg 
save history 	unset grep 
specified file 	opt opt 
success returned 	arg unset grep 
otherwise returned 	opt argc 
load history 	argv prefix hit 
specified 	opt exclude 
file file 	seen dashdash external 
exist zero 	grep allowed 
returned operation 	ignored pager opt 
performed file 	list pathspec 
exists 	path list dummy 
operation succeeded 	use index 
returned otherwise 	pattern type arg 
error returned 	options fallback 
linenoise.h prompt 	arg sha pager 
line len 	len buf 
filename 	use exclude pthread 
filename linenoise 	mutex pthread 
guerrilla line 	mutex unlock grep 
editing library 	pthread cond 
idea line 	wait size 
editing lib 	grep unlock grep 
needs 	size write 
lines code 	die grep source 
see linenoise 	clear pthread 
information copyright 	cond signal pthread 
salvatore sanfilippo 	cond signal 
antirez gmail 	grep unlock work 
dot 	grep source 
copyright pieter 	grep source clear 
noordhuis pcnoordhuis 	data work 
gmail dot 	done free grep 
rights reserved 	patterns free 
redistribution use 	strbuf pthread mutex 
source 	init pthread 
binary forms 	mutex init pthread 
without modification 	mutex init 
permitted provided 	pthread cond 
following conditions 	init pthread cond 
met redistributions 	init pthread 
source 	cond init size 
code must 	strbuf init 
retain copyright 	xcalloc grep opt 
notice list 	dup compile 
conditions following 	grep patterns pthread 
disclaimer redistributions 	create die 
binary 	strerror grep pthread 
form must 	cond wait 
reproduce copyright 	pthread cond broadcast 
notice list 	grep unlock 
conditions following 	pthread free pthread 
disclaimer documentation 	mutex destroy 
materials 	pthread mutex destroy 
provided distribution 	pthread mutex 
software provided 	destroy pthread cond 
copyright holders 	destroy pthread 
contributors express 	cond destroy 
implied warranties 	pthread cond destroy 
including 	grep config 
limited implied 	git color config 
warranties merchantability 	strcmp git 
fitness particular 	config die quote 
purpose disclaimed 	path relative 
shall copyright 	strbuf insert strbuf 
holder 	addstr work 
contributors liable 	strbuf release grep 
direct indirect 	source init 
incidental special 	strbuf release grep 
exemplary consequential 	source grep 
damages including 	source clear quote 
limited 	path relative 
procurement substitute 	strbuf addstr work 
goods services 	strbuf release 
loss use 	grep source init 
data profits 	strbuf release 
business interruption 	grep source 
however 	grep source clear 
caused theory 	list append 
liability whether 	xstrndup argv push 
contract strict 	run command 
liability tort 	exit read cache 
including negligence 	isreg intent 
otherwise 	path match skip 
arising way 	worktree stage 
use software 	grep sha grep 
even advised 	file stage 
possibility damage 	strcmp entry entry 
linenoise linit.c 	len entry 
lualibs 	interesting strbuf isreg 
lib lua 	grep sha 
pushcfunction lua 	isdir read sha 
pushstring lua 	file die 
call linit 	sha hex strbuf 
roberto exp 	addch init 
initialization 	desc grep 
libraries lua 	free strbuf setlen 
see copyright 	grep sha 
notice lua 	grep read read 
liolib.c fnames 	reference grep 
filename arg 	read unlock die 
filename 	oid hex 
filename mode 	strlen strbuf init 
filename mode 	strbuf strbuf 
findex mode 	addch init desc 
filename idx 	grep strbuf 
toclose filename 	release free die 
rlen 	deref tag 
first nargs 	grep memset setup 
success sucess 	standard excludes 
arg nargs 	fill directory dir 
status mode 	path match 
modenames offset 	grep file strtol 
mode 	error strcmp 
modenames res 	fopen die 
iolib flib 	errno strbuf getline 
fname cls 	append grep 
lua pushboolean 	pat fclose strbuf 
lua pushnil 	release append 
lua 	grep pattern append 
pushfstring strerror 	grep pattern 
lua pushfstring 	append grep pattern 
strerror lua 	append grep 
pushinteger lua 	pattern append grep 
pushfstring strerror 	pattern init 
lua 	grep defaults git 
argerror lua 	config grep 
tostring lua 	init parse options 
checkany lua 	grep commit 
touserdata lua 	pattern type git 
getfield lua 	config setup 
getmetatable 	git directory 
lua rawequal 	strcmp append grep 
lua pushnil 	pattern git 
lua pushliteral 	pager list append 
lua pushliteral 	die compile 
tofilep lua 	grep patterns sha 
error 	context parse 
lua newuserdata 	die verify non 
lua getmetatable 	filename path 
lua setmetatable 	strcmp die start 
lua pushnil 	threads verify 
lua pushliteral 	filename parse pathspec 
tofilep 	die strlen 
lua pclose 	dir sep strcmp 
pushresult tofilep 	list append 
fclose pushresult 	strcmp strcmp strbuf 
lua getfenv 	addf strcmp 
lua getfield 	list append strbuf 
lua 	detach setup 
tocfunction lua 	pager die 
isnone lua 	die grep directory 
rawgeti tofile 	die setup 
aux close 	work grep cache 
tofilep aux 	die grep 
close 	objects wait run 
tofilep lua 	pager free 
pushliteral lua 	grep patterns initialize 
pushfstring lua 	grep defaults 
checkstring lua 	hardcoded defaults could 
optstring newfile 	compiler without 
fopen 	initializers code gets 
pushresult lua 	unwieldy unreadable 
checkstring lua 	read configuration file 
optstring newfile 	store grep 
lua popen 	defaults initialize one 
pushresult newfile 	instance grep 
tmpfile 	opt copy values 
pushresult lua 	read configuration 
rawgeti lua 	information earlier 
touserdata lua 	call git config 
error lua 	grep config 
isnoneornil lua 	fall atom use 
tostring 	libpcre use 
newfile fopen 	libpcre regcomp cannot 
fileerror tofile 	accept patterns 
lua pushvalue 	consider pattern containing 
lua rawseti 	nul atom 
lua rawgeti 	atom atom match 
iofile 	beginning must 
iofile lua 	either beginning line 
pushvalue lua 	word boundary 
pushboolean lua 	last must word 
pushcclosure tofile 	similarly match 
aux lines 	end must either 
lua 	end line 
isnoneornil lua 	word boundary next 
rawgeti lines 	must word 
lua checkstring 	words consist 
newfile fopen 	least one character 
fileerror aux 	could one 
lines 	match line first 
lua gettop 	match might 
fscanf lua 	strict word match 
pushnumber lua 	later ones 
pushnil getc 	could forward next 
ungetc lua 	possible start 
pushlstring 	next position following 
lua buffinit 	non word 
lua prepbuffer 	call collect hits 
fgets lua 	without extended 
pushresult lua 	atom protects access 
objlen strlen 	gitattributes machinery 
lua 	safe git attr 
addsize lua 	mutex protecting 
addsize lua 	access rewind 
pushresult lua 	need look even 
buffinit lua 	back find 
prepbuffer fread 	function signature back 
lua 	forward punt 
addsize lua 	complex stuff punt 
pushresult lua 	header stuff 
objlen lua 	find beginning line 
gettop clearerr 	textconv intimately 
read line 	tied diff filespecs 
lua 	pretend one 
checkstack lua 	could unify grep 
type lua 	source diff 
tointeger test 	filespec structs mess 
eof read 	could away 
chars lua 	fill textconv remotely 
tostring 	safe may 
lua argcheck 	load objects behind 
read number 	scenes modifies 
read line 	diff tempfile 
read chars 	structure normal fill 
lua argerror 	textconv usage 
ferror 	diff machinery would 
pushresult lua 	keep textconv 
pop lua 	buf separate diff 
pushnil read 	filespec much 
getiofile read 	grep code passes 
tofile lua 	around grep 
touserdata 	source assumes buf 
lua upvalueindex 	pointer beginning 
lua error 	thing searching install 
read line 	textconv version 
ferror lua 	grep source taking 
error strerror 	care leak 
lua 	existing buffer show 
toboolean lua 	hunk marks 
upvalueindex lua 	first file threads 
settop lua 	easily identify 
pushvalue lua 	first file 
upvalueindex aux 	always put hunk 
close 	marks skip 
lua gettop 	first one later 
lua type 	work done 
lua tonumber 	might shared textconv 
lua checklstring 	cache data 
fwrite pushresult 	safe know result 
write 	textconv text 
getiofile write 	care binary handling 
tofile tofile 	unmatch look 
lua checkoption 	ahead skips quickly 
lua optlong 	line possibly 
fseek pushresult 	next hit call 
lua 	need something 
pushinteger ftell 	skipping current line 
tofile lua 	response unmatch 
checkoption lua 	current line inside 
optinteger setvbuf 	post context 
pushresult pushresult 	window show 
fflush 	current line context 
getiofile pushresult 	around previous 
fflush tofile 	hit doesn hit 
lua newmetatable 	grep foo 
lua pushvalue 	bla list lines 
lua setfield 	either inversion 
lua 	done outside hit 
newfile lua 	line haven 
pushvalue lua 	shown pre context 
rawseti lua 	lines would 
pushvalue lua 	need show last 
setfenv lua 	hit within 
setfield 	post context need 
lua createtable 	show line 
lua pushcfunction 	see hit want 
lua setfield 	show needswork 
createmeta newfenv 	real grep 
lua replace 	foo gives many 
lua 	bar lines 
newfenv createstdfile 	feels mostly useless 
createstdfile createstdfile 	sometimes useful 
lua pop 	maybe make another 
lua getfield 	option suppress 
newfenv lua 	hit markers meaningful 
setfenv 	top level 
lua pop 	node top level 
liolib roberto 	nodes hit 
exp standard 	markers see hits 
system library 	two pass 
see copyright 	grep check buffer 
notice 	wide match 
lua calls 	otherwise toplevel terms 
lua api 	hit bit 
may change 	differently first clear 
file creating 	hit markers 
file handles 	user provided 
always 	buf intact builtin 
creates closed 	git grep 
file handle 	copyright junio hamano 
opening actual 	use one 
file memory 	producer threads consumer 
error file 	threads producer 
left 	adds work items 
opened file 	todo consumers 
handle currently 	pick work items 
closed function 	range todo 
close standard 	done todo start 
files stdin 	todo work 
stdout 	items processed consumer 
stderr function 	haven written 
close popen 	result stdout yet 
files function 	work items 
close regular 	todo start todo 
files make 	end waiting 
sure 	picked consumer 
argument file 	ranges modulo todo 
ignore closed 	size work 
files function 	items added protects 
separated environment 	variables signalled 
defines correct 	work item added 
close 	todo signalled 
popen files 	result one work 
check valid 	item written 
file handle 	stdout signalled finished 
current close 	everything skip 
close file 	leading hunk mark 
finished 	first file 
check valid 	wait work done 
file handle 	wake consumer 
arguments iterate 	threads see work 
input read 	pthreads valid 
result removed 	worktree file cache 
read 	entry identical 
fails eof 	even worktree 
close buffer 	file modified use 
check whether 	cache version 
read something 	instead compensate loop 
include eol 	control ignore 
close 	empty line like 
buffer read 	grep paths 
least eol 	must exist working 
much read 	pattern specified 
number chars 	take first unrecognized 
actually read 	non option 
read 	pattern follows must 
much time 	zero valid 
cannot read 	refs exists existing 
asked still 	paths pattern 
read chars 	first unrecognized non 
end count 	option beginning 
eof 	refs list continues 
close buffer 	exists paths 
arguments result 	die way 
ensure stack 	beginning skip separator 
space results 	know cannot 
auxlib buffer 	separating revisions pathnames 
number 	haven even 
line file 	patterns yet first 
read max 	unrecognized non 
size chars 	option token check 
always success 	revs paths 
last result 	rev rest paths 
push 	grep.h next 
nil instead 	origin pattern patternlen 
file already 	regexp pcre 
closed eof 	regexp pcre extra 
generator created 	info kws 
file close 	hit atom unary 
optimization 	left right 
could done 	pattern list 
exactly error 	pattern tail header 
create metatable 	list header 
file handles 	tail pattern expression 
push metatable 	prefix prefix 
metatable 	length regexp linenum 
index metatable 	invert ignore 
file methods 	status name unmatch 
copy environment 	name count 
create environment 	word regexp match 
fields input 	debug binary 
output 	allow textconv extended 
close open 	use reflog 
library create 	filter pcre relative 
files close 	pathname following 
function files 	name color max 
pop environment 	depth funcname 
files 	funcbody extended regexp 
create environment 	option pattern 
popen fenv 	type option 
popen pop 	color context color 
popen llex.c 	filename color 
lua tokens 	function color lineno 
newsize 	color match 
token token 	context color match 
msg token 	selected color 
buff msg 	selected color sep 
str old 	regflags pre 
source seminfo 	context post context 
old 	last shown 
seminfo count 	show hunk mark 
seminfo sep 	file heading 
cont del 	priv opt data 
seminfo seminfo 	size output 
sep sep 	priv grep opt 
lua 	prefix grep 
lexerror lua 	pattern type option 
resizebuffer cast 	grep commit 
lua lua 	pattern type 
fix lua 	append grep pat 
strlen cast 	append grep 
lua 	pattern append header 
iscntrl lua 	grep pattern 
pushfstring lua 	opt opt opt 
pushfstring save 	buf size 
lua buffer 	name buf size 
lua token 	path driver 
str 	grep source init 
lua chunkid 	opt opt 
getstr lua 	opt grep use 
pushfstring lua 	locks grep 
pushfstring txt 	attr mutex grep 
token lua 	read mutex 
lua 	pthread mutex pthread 
lexerror lua 	mutex unlock 
newlstr lua 	must end attribute 
setstr ttisnil 	lookups mutex 
setbvalue lua 	used around 
check lua 	access attributes machinery 
curr 	opt use 
newline next 	threads must initialized 
curr newline 	destroyed callers 
next lua 	hash-object.c sha type 
syntaxerror lua 	flags buf 
resizebuffer next 	ret type path 
strchr 	flags literally 
save next 	sha path type 
lua bufflen 	vpath flags 
lua buffer 	literally type filters 
localeconv buffreplace 	flags literally 
lua 	buf unquoted argc 
str lua 	argv prefix 
buffer buffreplace 	hash usage type 
lua lexerror 	hashstdin stdin 
lua isdigit 	paths filters 
isdigit save 	literally flags vpath 
next 	hash options 
check next 	prefix length errstr 
check next 	arg strbuf 
isalnum save 	read hash sha 
next save 	file literally 
buffreplace lua 	strbuf release fstat 
str 	hash literally 
lua buffer 	index type die 
trydecpoint lua 	sha hex 
save next 	maybe flush die 
save next 	open die 
save next 	errno hash strbuf 
curr 	getline strbuf 
newline inclinenumber 	reset unquote style 
lua lexerror 	die strbuf 
skip sep 	swap hash strbuf 
save next 	release strbuf 
lua lexerror 	release parse 
skip 	options setup git 
sep save 	directory strlen 
next save 	prefix filename git 
inclinenumber lua 	config error 
resetbuffer save 	usage options hash 
next next 	prefix filename 
lua 	hash hash stdin 
newstring lua 	paths git 
buffer lua 	information manager hell 
bufflen save 	copyright linus 
next lua 	torvalds copyright junio 
lexerror lua 	hamano create 
lexerror 	corrupt objects debugging 
next save 	needs bypass 
inclinenumber isdigit 	data conversion performed 
save next 	type limitation 
isdigit next 	imposed index callees 
lua lexerror 	hashmap.c str 
save 	hash str 
save next 	hash buf len 
save next 	hash ucbuf 
save next 	buf len hash 
lua newstring 	ucbuf map 
lua buffer 	size map keydata 
lua 	map key 
bufflen lua 	map newsize oldsize 
resetbuffer inclinenumber 	oldtable next 
next next 	map key keydata 
skip sep 	unused unused 
lua resetbuffer 	unused map function 
read 	initial size 
lua resetbuffer 	size map free 
curr newline 	entries iter 
next skip 	map key keydata 
sep read 	map entry 
lua lexerror 	map entry map 
next 	key keydata 
next next 	old map 
next next 	entry old map 
next next 	iter iter 
next read 	current ent len 
save next 	data keydata 
check 	data len map 
next check 	key xcalloc 
next isdigit 	cmpfn alloc table 
read numeral 	bucket free 
isspace lua 	bucket entry alloc 
curr newline 	table hashmap 
next 	iter init hashmap 
isdigit read 	iter next 
numeral isalpha 	free free memset 
isalnum save 	find entry 
next lua 	ptr entry bucket 
newstring lua 	rehash find 
buffer 	entry ptr 
lua bufflen 	rehash hashmap hashmap 
next llex 	memcmp hashmap 
lua llex 	init hashmap entry 
llex roberto 	init memhash 
exp lexical 	hashmap flex alloc 
analyzer 	mem hashmap 
see copyright 	entry init hashmap 
notice lua 	implementation hash 
order reserved 	key mappings grow 
reserved words 	shrink load 
never collected 	factor percent calculate 
reserved 	resize thresholds 
word entry 	size shrink threshold 
str make 	must slightly 
sure str 	smaller grow threshold 
collected skip 	resize factor 
skip look 	prevent erratic resizing 
ahead 	thus divide 
token initialize 	resize factor 
buffer read 	calculate initial table 
first lexical 	size allocate 
analyzer format 	table entry fix 
error update 	size rehash 
point 	appropriate existing entry 
separator updated 	fix size 
separator format 	rehash appropriate initialize 
error correct 	pool hashmap 
point options 	lookup interned pool 
undo change 	found create 
error 	hashmap.h buf buf 
message lua 	buf len 
number optional 	buf len sha 
exponent sign 	hash next 
follow locale 	hash table cmpfn 
point format 	size tablesize 
error 	grow shrink map 
update point 	next tablepos 
separator avoid 	map function 
warnings cont 	initial size map 
used skip 	free entries 
starts newline 	entry hash map 
skip 	key keydata 
avoid warnings 	map entry map 
skip skip 	entry map 
avoid wasting 	entry map key 
space avoid 	keydata map 
warnings avoid 	hash keydata key 
warnings 	map iter 
save error 	iter map iter 
next loop 	data len 
handles xxx 	memcpy hashmap entry 
skip delimiter 	init hashmap 
comment skip 	hashmap iter init 
sep 	hashmap iter 
may dirty 	next memintern strlen 
buffer comment 	implementation hash 
comment reserved 	key mappings 
word reserved 	see documentation technical 
word single 	api hashmap 
tokens 	txt fnv functions 
look ahead 	equivalent sha 
token use 	safe platforms support 
one discharge 	reads data 
read next 	structures hashmap functions 
token llex.h 	hashmap entry 
lua 	functions hashmap iter 
tokens source 	functions interning 
str msg 	help.c cmds name 
token token 	len ent 
llex roberto 	cmds cmds cmds 
exp lexical 	excludes cmp 
analyzer 	cmds colopts list 
see copyright 	copts name 
notice lua 	buf cmds path 
maximum length 	prefix dir 
reserved word 	buf len 
warning change 	ent entlen prefix 
order 	main cmds 
enumeration grep 	cmds env path 
order reserved 	exec path 
terminal symbols 	paths path colon 
denoted reserved 	colopts main 
words terminal 	cmds cmds exec 
symbols 	path elem 
number reserved 	elem longest current 
words token 	grp autocorrect 
names semantics 	aliases cmds old 
information current 	bad interpreter 
character charint 	advice cmd best 
input 	similarity main 
line counter 	cmds cmds cmp 
line last 	candidate assumed 
token consumed 	argc argv 
current token 	prefix similar refs 
look ahead 	refname oid 
token 	flags data branch 
func state 	remote similar 
parser input 	refs cmd error 
stream buffer 	suggested refs 
tokens current 	flex alloc mem 
source name 	alloc grow 
locale 	free free strcmp 
point llimits.h 	strcmp free 
llimits roberto 	strcmp free list 
exp limits 	append memset 
basic types 	print columns list 
installation dependent 	clear stat 
definitions 	isreg open read 
see copyright 	strcmp strcmp 
notice lua 	close opendir strbuf 
chars used 	addf readdir 
small naturals 	skip prefix 
reserved characters 	strbuf setlen strbuf 
maximum 	addstr executable 
safety conversion 	strlen strip suffix 
pointer integer 	cmdname closedir 
hashing problem 	strbuf release getenv 
integer cannot 	git exec 
hold whole 	path list commands 
pointer 	dir qsort 
type ensure 	uniq xstrdup strchr 
maximum alignment 	strcmp list 
result usual 	commands dir free 
argument conversion 	qsort uniq 
lua number 	exclude cmds git 
assertions 	exec path 
house debugging 	putchar pretty print 
avoid warnings 	cmdnames putchar 
type machine 	putchar pretty print 
instructions must 	cmdnames putchar 
least bytes 	strcmp size 
see 	strlen strlen qsort 
details lopcodes 	size puts 
maximum stack 	size mput strlen 
lua function 	puts strcmp 
minimum size 	strcmp git config 
table must 	skip prefix 
power 	cmdname strlen git 
minimum size 	config strcmp 
buffer macro 	alloc grow free 
control inclusion 	memset memset 
hard tests 	memset git config 
stack reallocation 	load command 
lmathlib.c 	list cmd list 
dmin dmax 	cmd list 
mathlib lua 	qsort uniq strcmp 
pushnumber fabs 	die size 
lua checknumber 	strcmp size starts 
lua pushnumber 	levenshtein qsort 
sin 	die similar 
lua checknumber 	enough clean cmdnames 
lua pushnumber 	sleep millisec 
sinh lua 	similar enough exit 
checknumber lua 	strrchr skip 
pushnumber cos 	prefix strcmp list 
lua 	append guess 
checknumber lua 	refs list clear 
pushnumber cosh 	exit always 
lua checknumber 	enable column display 
lua pushnumber 	consult column 
tan lua 	layout strategy stuff 
checknumber 	stat lstat 
lua pushnumber 	cannot trust executable 
tanh lua 	bit peek 
checknumber lua 	file instead dos 
pushnumber asin 	executables start 
lua checknumber 	also use 
lua 	aliases command lookup 
pushnumber acos 	empirically derived 
lua checknumber 	magic number abuses 
lua pushnumber 	cmdname len 
atan lua 	levenshtein distance avoid 
checknumber lua 	compiler stupidity 
pushnumber 	exact match means 
atan lua 	command reason 
checknumber lua 	exec ing gave 
checknumber lua 	enoent probably 
pushnumber ceil 	bad interpreter line 
lua checknumber 	candidate appear 
lua 	common cmds list 
pushnumber floor 	yes one 
lua checknumber 	common commands use 
lua pushnumber 	entry common 
fmod lua 	cmds give prefix 
checknumber lua 	match good 
checknumber 	score skip 
modf lua 	count prefix matches 
checknumber lua 	still counting 
pushnumber lua 	prefix matches everything 
pushnumber lua 	ambiguous count 
pushnumber sqrt 	similar ones still 
lua 	counting format 
checknumber lua 	kept stable compatibility 
pushnumber pow 	external projects 
lua checknumber 	rely output git 
lua checknumber 	version remote 
lua pushnumber 	branch name deemed 
log 	similar builtin 
lua checknumber 	help command emacsclient 
lua pushnumber 	prints version 
log lua 	number stderr bother 
checknumber lua 	checking emacsclient 
pushnumber exp 	version seems always 
lua 	exits code 
checknumber lua 	works emacsclient 
pushnumber lua 	version simpler launch 
checknumber lua 	konqueror kfmclient 
pushnumber lua 	always put path 
checknumber lua 	old path 
pushnumber 	end man system 
frexp lua 	wide paths 
checknumber lua 	find manual page 
pushinteger lua 	old path 
pushnumber ldexp 	need delimiter unable 
lua checknumber 	check git 
lua 	documentation directory open 
checkint lua 	html defined 
gettop lua 	platform specific way 
checknumber lua 	see example 
checknumber lua 	compat mingw use 
pushnumber lua 	script web 
gettop 	browse display html 
lua checknumber 	leaks exec 
lua checknumber 	bellow done 
lua pushnumber 	ignore remaining args 
lua number 	next name 
rand lua 	next info name 
gettop 	html path 
lua pushnumber 	show show guides 
lua checkint 	colopts builtin 
lua argcheck 	help options builtin 
lua pushnumber 	help usage 
floor lua 	name viewer buffer 
checkint 	process argv 
lua checkint 	version path page 
lua argcheck 	man page 
lua pushnumber 	path page display 
floor lua 	man page 
error srand 	filename len path 
lua 	page cmd 
checkint lua 	page shell 
lua pushnumber 	cmd name name 
lua setfield 	len name 
lua pushnumber 	len name len 
lua setfield 	name len 
lua 	name subkey namelen 
getfield lua 	main cmds 
setfield lmathlib 	cmds git cmd 
roberto exp 	path old 
standard mathematical 	path git man 
library see 	path name 
copyright 	page info git 
notice lua 	cmd viewer 
number arguments 	page fallback git 
number arguments 	cmd page 
avoids rare 	page path page 
needed also 	free path 
systems 	git cmd page 
sun rand 	page path 
may larger 	name help 
rand max 	longest argc argv 
check number 	prefix nongit 
arguments arguments 	strcmp strcmp strcmp 
number 	die strcasecmp 
upper limit 	start command error 
lower upper 	strbuf read 
limits open 	close finish command 
math library 	starts strbuf 
lmem.c block 	release error strbuf 
size 	strlen atoi 
size elems 	strbuf release error 
limit errormsg 	strbuf release 
newblock newsize 	check emacsclient version 
block osize 	strbuf addf 
nsize lua 	execlp warning strerror 
runerror 	getenv strip 
lua reallocv 	suffix xstrfmt basename 
lua runerror 	strbuf addf 
lua frealloc 	execlp warning 
lua lua 	strerror execlp warning 
lmem roberto 	strerror strbuf 
exp 	addf execl warning 
memory manager 	strerror flex 
see copyright 	alloc str strncasecmp 
notice lua 	strncasecmp strncasecmp 
realloc function 	flex alloc mem 
frealloc ptr 	xstrdup supported 
size 	man viewer man 
osize size 	viewer info 
nsize osize 	warning supported man 
old size 	viewer warning 
nsize size 	man viewer info 
lua ensures 	parse config 
ptr 	key strcmp config 
iff osize 	error nonbool 
frealloc creates 	man viewer path 
block size 	strcmp config 
frealloc frees 	error nonbool 
block specific 	man viewer cmd 
frealloc 	starts git 
must particularly 	column config strcmp 
frealloc nothing 	config error 
equivalent free 	nonbool parse help 
ansi frealloc 	format strcmp 
returns cannot 	config error nonbool 
create 	xstrdup strcmp 
reallocate area 	config error nonbool 
reallocation equal 	man viewer 
smaller size 	starts man viewer 
cannot fail 	info git 
cannot cannot 	config builtin load 
grow 	command list 
even little 	cmdlist cmdlist starts 
still least 	git command 
one free 	xstrfmt xstrfmt getenv 
place minimum 	system path 
size update 	strbuf addstr 
everything 	strbuf addch strbuf 
avoid warnings 	addstr free 
allocation routine 	setenv strbuf release 
lmem.h block 	man viewer 
oldsize size 	info strcasecmp exec 
block size 	man man 
size 	strcasecmp exec woman 
elem limit 	emacs strcasecmp 
errormsg lmem 	exec man konqueror 
roberto exp 	exec man 
memory manager 	cmd warning cmd 
see copyright 	page getenv 
notice 	setup man path 
lua avoid 	exec viewer 
warnings loadlib.c 	exec viewer exec 
lib path 	viewer die 
lib sym 	cmd page 
lib path 	setenv system path 
lib 	execlp die 
lib sym 	system path strstr 
buff nsize 	stat mkpath 
error buffer 	isreg die strbuf 
lib path 	init strbuf 
lib lib 	addf free execl 
sym 	git cmd 
err str 	cmd page html 
err file 	page path 
err err 	open html size 
num ret 	strlen strlen 
lib path 	puts size mput 
img 	strlen puts 
ret mod 	putchar parse options 
lib sym 	git config 
nss lib 	load command list 
path lib 	list commands 
sym path 	list common 
plib 	guides help list 
lib path 	common cmds 
sym reg 	help setup git 
path init 	directory gently 
stat filename 	git config parse 
path 	help format 
name pname 	lookup git command 
path filename 	free show 
filename filename 	man page show 
name modname 	info page 
funcname mark 	show html page 
funcname 	always enable 
name filename 	column display consult 
funcname filename 	column layout 
name stat 	strategy stuff stat 
name sentinel 	lstat cannot 
name modname 	trust executable bit 
dot 	peek file 
modname loaded 	instead dos 
fieldname envname 	executables start also 
def path 	use aliases 
funcs funcs 	command lookup empirically 
loaders dlclose 	derived magic 
dlopen 	number abuses cmdname 
lua pushstring 	len levenshtein 
dlerror dlsym 	distance avoid compiler 
lua pushstring 	stupidity exact 
dlerror module 	match means command 
file name 	reason exec 
strrchr 	ing gave enoent 
lua error 	probably bad 
lua gsub 	interpreter line candidate 
lua tostring 	appear common 
lua last 	cmds list yes 
error format 	one common 
message 	commands use entry 
lua pushstring 	common cmds 
lua pushfstring 	give prefix 
free library 	match good score 
load library 	skip count 
pusherror proc 	prefix matches still 
address 	counting prefix 
pusherror link 	matches everything ambiguous 
edit error 	count similar 
lua pushstring 	ones still counting 
link module 	format kept 
dyld present 	stable compatibility external 
lua 	projects rely 
pushliteral create 	output git version 
file image 	remote branch 
file link 	name deemed similar 
module destroy 	builtin help 
file image 	command emacsclient prints 
pusherror 	version number 
lua pushstring 	stderr bother 
errorfromcode lookup 	checking emacsclient version 
symbol module 	seems always 
lua pushfstring 	exits code works 
address symbol 	emacsclient version 
lua 	simpler launch konqueror 
pushliteral lua 	kfmclient always 
pushliteral lua 	put path old 
pushfstring lua 	path end 
gettable lua 	man system wide 
isnil lua 	paths find 
touserdata 	manual page old 
lua pop 	path need 
lua newuserdata 	delimiter unable check 
lua getmetatable 	git documentation 
lua setmetatable 	directory open html 
lua pushfstring 	defined platform 
lua 	specific way see 
pushvalue lua 	example compat 
settable lua 	mingw use 
checkudata unloadlib 	script web browse 
load sym 	display html 
lua pushcfunction 	leaks exec bellow 
lua 	done ignore 
checkstring lua 	remaining args help.c 
checkstring loadfunc 	cmds name 
lua pushnil 	len ent cmds 
lua insert 	cmds cmds 
lua pushstring 	excludes cmp cmds 
fopen 	colopts list 
fclose strchr 	copts name buf 
strlen lua 	cmds path 
pushlstring lua 	prefix dir buf 
gsub lua 	len ent 
getfield lua 	entlen prefix main 
tostring 	cmds cmds 
lua error 	env path exec 
lua lua 	path paths 
pushliteral pushnexttemplate 	path colon 
lua gsub 	colopts main cmds 
lua tostring 	cmds exec 
lua 	path elem elem 
readable lua 	longest current 
pushfstring lua 	grp autocorrect aliases 
lua concat 	cmds old 
lua error 	bad interpreter advice 
lua tostring 	cmd best 
lua 	similarity main cmds 
tostring lua 	cmds cmp 
checkstring findfile 	candidate assumed argc 
lua loadfile 	argv prefix 
loaderror strchr 	similar refs refname 
lua gsub 	oid flags 
lua 	data branch remote 
pushfstring lua 	similar refs 
lua checkstring 	cmd error suggested 
findfile mkfuncname 	refs flex 
loadfunc loaderror 	alloc mem 
lua checkstring 	alloc grow free 
strchr 	free strcmp 
lua pushlstring 	strcmp free strcmp 
findfile lua 	free list 
tostring mkfuncname 	append memset print 
loadfunc loaderror 	columns list 
lua pushfstring 	clear stat isreg 
lua 	open read 
checkstring lua 	strcmp strcmp close 
getfield lua 	opendir strbuf 
istable lua 	addf readdir skip 
error lua 	prefix strbuf 
lua getfield 	setlen strbuf addstr 
lua 	executable strlen 
isnil lua 	strip suffix cmdname 
pushfstring lua 	closedir strbuf 
checkstring lua 	release getenv 
settop lua 	git exec path 
getfield lua 	list commands 
getfield 	dir qsort uniq 
lua toboolean 	xstrdup strchr 
lua touserdata 	strcmp list commands 
lua error 	dir free 
lua getfield 	qsort uniq exclude 
lua istable 	cmds git 
lua 	exec path putchar 
error lua 	pretty print 
lua pushliteral 	cmdnames putchar putchar 
lua rawgeti 	pretty print 
lua isnil 	cmdnames putchar strcmp 
lua error 	size strlen 
lua 	strlen qsort size 
tostring lua 	puts size 
pushstring lua 	mput strlen puts 
call lua 	strcmp strcmp 
isfunction lua 	git config 
isstring lua 	skip prefix cmdname 
concat 	strlen git 
lua pop 	config strcmp alloc 
lua pushlightuserdata 	grow free 
lua setfield 	memset memset memset 
lua pushstring 	git config 
lua call 	load command list 
lua 	cmd list 
isnil lua 	cmd list qsort 
setfield lua 	uniq strcmp 
getfield lua 	die size strcmp 
touserdata lua 	size starts 
pushboolean lua 	levenshtein qsort die 
pushvalue 	similar enough 
lua setfield 	clean cmdnames sleep 
lua getstack 	millisec similar 
lua getinfo 	enough exit strrchr 
lua iscfunction 	skip prefix 
lua error 	strcmp list 
lua 	append guess refs 
lua pushvalue 	list clear 
lua setfenv 	exit always enable 
lua pop 	column display 
lua pushvalue 	consult column layout 
lua pushvalue 	strategy stuff 
lua 	stat lstat cannot 
call lua 	trust executable 
pushvalue lua 	bit peek file 
setfield lua 	instead dos 
pushstring lua 	executables start also 
setfield strrchr 	use aliases 
lua 	command lookup empirically 
pushlstring lua 	derived magic 
setfield lua 	number abuses cmdname 
checkstring lua 	len levenshtein 
gettop lua 	distance avoid compiler 
getfield lua 	stupidity exact 
getfield 	match means 
lua istable 	command reason exec 
lua pop 	ing gave 
lua findtable 	enoent probably bad 
lua error 	interpreter line 
lua pushvalue 	candidate appear common 
lua 	cmds list 
setfield lua 	yes one common 
getfield lua 	commands use 
isnil lua 	entry common cmds 
pop lua 	give prefix 
pop modinit 	match good score 
lua 	skip count 
pushvalue setfenv 	prefix matches still 
dooptions lua 	counting prefix 
checktype lua 	matches everything ambiguous 
getmetatable lua 	count similar 
createtable lua 	ones still counting 
pushvalue 	format kept 
lua setmetatable 	stable compatibility 
lua pushvalue 	external projects rely 
lua setfield 	output git 
getenv lua 	version remote branch 
pushstring lua 	name deemed 
gsub 	similar builtin help 
lua setprogdir 	command emacsclient 
lua setfield 	prints version number 
lua newmetatable 	stderr bother 
lua pushcfunction 	checking emacsclient version 
lua setfield 	seems always 
lua 	exits code works 
lua getfield 	emacsclient version 
lua setfield 	simpler launch konqueror 
lua pushvalue 	kfmclient always 
lua replace 	put path old 
lua createtable 	path end 
lua 	man system 
pushcfunction lua 	wide paths find 
rawseti lua 	manual page 
setfield setpath 	old path need 
setpath lua 	delimiter unable 
pushliteral lua 	check git documentation 
setfield 	directory open 
lua findtable 	html defined platform 
lua setfield 	specific way 
lua newtable 	see example compat 
lua setfield 	mingw use 
lua pushvalue 	script web browse 
lua 	display html 
lua pop 	leaks exec bellow 
loadlib roberto 	done ignore 
exp library 	remaining args next 
loader lua 	name next 
see copyright 	info name html 
notice 	path show 
lua module 	show guides 
contains implementation 	colopts builtin help 
loadlib unix 	options builtin 
systems dlfcn 	help usage name 
implementation darwin 	viewer buffer 
mac 	process argv version 
implementation windows 	path page 
stub systems 	man page path 
prefix open 	page display 
functions libraries 	man page filename 
separator open 	len path 
functions 	page cmd page 
libraries error 	shell cmd 
codes loadfunc 	name name len 
implementation loadlib 	name len 
dlfcn dlfcn 	name len name 
available linux 	len name 
sun 	subkey namelen main 
solaris irix 	cmds cmds 
free bsd 	git cmd 
net bsd 	path old path 
aix hpux 	git man 
probably unix 	path name page 
flavors 	info git 
least emulation 	cmd viewer page 
layer top 	fallback git 
functions implementation 	cmd page page 
loadlib windows 	path page 
functions original 	free path git 
mac 	cmd page 
darwin implementation 	page path name 
mac appends 	help longest 
function names 	argc argv prefix 
would rare 	nongit strcmp 
prevents crashing 	strcmp strcmp die 
happens 	strcasecmp start 
fallback systems 	command error strbuf 
avoid warnings 	read close 
avoid warnings 	finish command 
avoid warnings 	starts strbuf release 
check library 	error strbuf 
registry 	strlen atoi strbuf 
entry entry 	release error 
yet create 	strbuf release check 
one tag 	emacsclient version 
method calls 	strbuf addf execlp 
library unloadlib 	warning strerror 
function 	getenv strip suffix 
lib handle 	xstrfmt basename 
mark library 	strbuf addf execlp 
closed unable 	warning strerror 
load library 	execlp warning strerror 
unable find 	strbuf addf 
function 	execl warning strerror 
function errors 	flex alloc 
loaded function 	str strncasecmp 
error error 	strncasecmp strncasecmp flex 
message stack 	alloc mem 
top nil 	xstrdup supported man 
error 	viewer man 
message require 	viewer info warning 
function open 	supported man 
file open 	viewer warning man 
failed skip 	viewer info 
separators templates 	parse config key 
find 	strcmp config 
next separator 	error nonbool man 
error accumulator 	viewer path 
path file 	strcmp config error 
exist readable 	nonbool man 
file name 	viewer cmd starts 
file 	git column 
name entry 	config strcmp config 
possible error 	error nonbool 
message found 	parse help 
library found 	format strcmp config 
path library 	error nonbool 
loaded 	xstrdup strcmp config 
successfully gsub 	error nonbool 
result library 	man viewer starts 
found path 	man viewer 
library loaded 	info git config 
successfully root 	builtin load 
root 	command list cmdlist 
found real 	cmdlist starts 
error function 	git command xstrfmt 
found found 	xstrfmt getenv 
loaded table 	system path strbuf 
index check 	addstr strbuf 
loops 	addch strbuf addstr 
already loaded 	free setenv 
must load 	strbuf release man 
iterate available 	viewer info 
loaders error 	strcasecmp exec 
message accumulator 	man man strcasecmp 
loader 	exec woman 
call find 	emacs strcasecmp exec 
module module 	man konqueror 
loaded successfully 	exec man cmd 
loader returned 	warning cmd 
error message 	page getenv setup 
accumulate 	man path 
loaded name 	exec viewer exec 
sentinel pass 	viewer exec 
name argument 	viewer die cmd 
module run 	page setenv 
loaded module 	system path execlp 
non 	die system 
nil loaded 	path strstr stat 
name returned 	mkpath isreg 
module use 	die strbuf init 
result extra 	strbuf addf 
copy returned 	free execl 
loaded 	git cmd cmd 
name module 	page html 
function calling 	page path open 
function option 	html size 
function module 	strlen strlen puts 
module module 	size mput 
look 	strlen puts putchar 
last dot 	parse options 
module name 	git config load 
name full 	command list 
module name 	list commands list 
minus last 	common guides 
part 	help list common 
index loaded 	cmds help 
table loaded 	setup git directory 
modname found 	gently git 
previous result 	config parse 
variable create 	help format lookup 
one 	git command 
exist loaded 	free show man 
modname table 	page show 
check whether 	info page show 
table already 	html page 
name field 	always enable column 
table 	display consult 
initialized module 	column layout strategy 
initialize create 	stuff stat 
metatable index 	lstat cannot trust 
auxiliary mark 	executable bit 
use environment 	peek file instead 
variable 	dos executables 
use replace 	start also use 
auxmark auxmark 	aliases command 
path create 	lookup empirically derived 
type loadlib 	magic number 
create table 	abuses cmdname 
create 	len levenshtein distance 
loaders table 	avoid compiler 
fill pre 	stupidity exact match 
defined loaders 	means command 
put field 	reason exec ing 
loaders field 	gave enoent 
path 	probably bad interpreter 
field cpath 	line candidate 
store config 	appear common cmds 
information field 	list yes 
loaded field 	one common commands 
preload open 	use entry 
lib 	common cmds give 
table table 	prefix match 
lobject.c lua 	good score skip 
nilobject log 	count prefix 
result endptr 	matches still counting 
str fmt 	prefix matches 
argp 	everything ambiguous 
buff buff 	count similar ones 
buff fmt 	still counting 
msg argp 	format kept stable 
source bufflen 	compatibility external 
len cast 	projects rely output 
ttype 	git version 
ttype ttype 	remote branch name 
luai numeq 	deemed similar 
nvalue nvalue 	builtin help command 
bvalue bvalue 	emacsclient prints 
pvalue pvalue 	version number stderr 
lua 	bother checking 
iscollectable gcvalue 	emacsclient version seems 
gcvalue lua 	always exits 
str number 	code works emacsclient 
cast num 	version simpler 
strtoul isspace 	launch konqueror kfmclient 
setsvalue 	always put 
lua incr 	path old 
top pushstr 	path end man 
strchr setsvalue 	system wide 
lua newlstr 	paths find manual 
incr top 	page old 
arg 	path need delimiter 
pushstr cast 	unable check 
arg pushstr 	git documentation directory 
setnvalue cast 	open html 
num arg 	defined platform specific 
incr top 	way see 
setnvalue 	example compat mingw 
cast num 	use script 
arg incr 	web browse display 
top sprintf 	html leaks 
arg pushstr 	exec bellow done 
pushstr 	ignore remaining 
pushstr pushstr 	args help.h alloc 
lua concat 	cnt len 
cast svalue 	name num 
start lua 	cmd prefix main 
pushvfstring end 	cmds cmds 
strncpy 	cmds name len 
strlen strcpy 	cmds excludes 
strcat strcat 	cmds name colopts 
strcspn strcpy 	main cmds 
strncat strcat 	cmds cmd error 
strcat strcat 	putchar also 
lobject 	used similarity index 
roberto exp 	help require 
functions lua 	excludes sorted list 
objects see 	call die 
copyright notice 	suspected user mistyped 
lua converts 	command give 
integer 	suggested correct refs 
floating point 	help hex.c 
represented eeeeexxx 	hexval table 
real xxx 	hex sha val 
eeeee eeeee 	hex oid 
xxx otherwise 	buffer sha hex 
expoent 	buf val 
converts back 	sha bufno hexbuffer 
must conversion 	oid hexval 
failed maybe 	hexval sha hex 
hexadecimal constant 	sha hex 
common invalid 	sha hex hex 
trailing 	caught val 
characters function 	hex nul avoid 
handles formats 	reading past 
enough space 	end hstrerror.c err 
first ensures 	buffer snprintf 
termination source 	http-backend.c content type 
source 	content length 
skip last 	last modified getanyfile 
part file 	max request 
name stop 	buffer query 
first newline 	name config name 
must truncate 	rpc service 
lobject.h 	query name name 
lua nilobject 	fmt buffer 
result fmt 	args code msg 
argp fmt 	name name 
source len 	name err err 
lobject roberto 	type buf 
exp 	type name buf 
type definitions 	alloc buf 
lua objects 	name name name 
see copyright 	name svc 
notice lua 	name svc name 
tags values 	svc user 
visible 	alloc buf cnt 
lua extra 	prog name 
tags non 	buffer input stream 
values collectable 	full request 
objects common 	buf buf 
header collectable 	cnt ret prog 
objects 	name buf 
macro form 	argv buffer input 
included objects 	encoding user 
common header 	host gzipped request 
form lua 	cld name 
values tagged 	oid flag data 
values 	name nons 
macros test 	buf arg service 
type macros 	name buf 
access values 	argv svc refname 
debug macros 	oid flag 
values different 	data buf unused 
types 	target target 
sets according 	nons arg buf 
destination stack 	arg objdirlen 
stack stack 	buf cnt accepted 
stack table 	type actual 
table table 	type service 
index 	name argv svc 
stack elements 	buf dead 
headers table 	err buf pathinfo 
ensures maximum 	root path 
alignment ensures 	method pattern argc 
maximum alignment 	argv method 
local 	dir cmd cmd 
udata function 	arg proto 
prototypes constants 	getenv xcalloc url 
used function 	decode parameter 
functions defined 	name url decode 
inside function 	parameter list 
map 	lookup list insert 
opcodes source 	free list 
lines information 	lookup parameters start 
local variables 	vsnprintf end 
upvalue names 	die write 
size size 	die format write 
number 	format write 
upvalues masks 	format write show 
style vararg 	date date 
first point 	mode hdr str 
variable active 	hdr str 
first point 	hdr str hdr 
variable 	str time 
dead upvalues 	hdr date hdr 
points stack 	date hdr 
closed linked 	str write die 
list open 	http status 
closures tables 	hdr nocache end 
chaining 	headers start 
means tagmethod 	vfprintf end exit 
present log 	http status 
size node 	hdr nocache end 
part free 	headers start 
position position 	vfprintf end 
size 	exit forbidden hdr 
module operation 	hdr str 
hashing size 	end headers write 
always power 	die git 
lopcodes.c lua 	pathdup xmalloc open 
opnames lua 	found strerror 
opmodes 	fstat die errno 
lopcodes roberto 	hdr hdr 
exp see 	str hdr date 
copyright notice 	end headers 
lua order 	xread die errno 
mode opcode 	write die 
move 	close free free 
loadk loadbool 	getanyfile hdr 
loadnil getupval 	nocache send local 
getglobal gettable 	file getanyfile 
setglobal setupval 	hdr cache forever 
settable newtable 	send local 
self 	file getanyfile 
sub mul 	hdr cache forever 
div mod 	send local 
pow unm 	file getanyfile hdr 
len concat 	cache forever 
jmp test 	send local file 
testset 	git config 
call tailcall 	git config size 
forloop forprep 	strbuf addf 
tforloop setlist 	git config strbuf 
close closure 	reset strbuf 
vararg lopcodes.h 	release skip prefix 
lua 	forbidden size 
opmodes lua 	strcmp forbidden getenv 
opnames lopcodes 	forbidden xmalloc 
roberto exp 	read full free 
opcodes lua 	die alloc 
machine see 	realloc memset git 
copyright 	inflate init 
notice lua 	gzip read 
instructions numbers 	request xread die 
instructions opcode 	git inflate 
first bits 	die write full 
instructions following 	die git 
fields 	inflate end close 
bits bits 	free read 
bits bits 	request die errno 
together argument 	write full 
represented excess 	die close free 
number minus 	getenv getenv 
exactly 	getenv strcmp strcmp 
maximum argument 	getenv argv 
max represented 	pushf getenv argv 
max represented 	pushf start 
max half 	command exit close 
maximum corresponding 	inflate request 
argument 	copy request 
basic instruction 	close finish command 
format size 	exit strip 
position opcode 	parse strbuf addf 
arguments limits 	oid hex 
opcode arguments 	deref tag strbuf 
use 	addf oid 
manipulate arguments 	hex parameter hdr 
must fit 	nocache service 
luai bitsint 	strbuf addf hdr 
bits sign 	str end 
creates mask 	headers packet write 
bits 	packet flush 
position creates 	run service getanyfile 
mask bits 	namespaced send 
position following 	strbuf strbuf release 
macros help 	resolve strip 
manipulate instructions 	strbuf addf strbuf 
macros 	addf oid 
operate indices 	hex getanyfile 
bit means 	head namespaced send 
constant means 	strbuf strbuf 
test whether 	release strlen directory 
constant gets 	getanyfile prepare 
index 	packed git strbuf 
constant code 	grow strbuf 
constant index 	addf strbuf addch 
invalid fits 	hdr nocache 
bits kst 	send strbuf strbuf 
constant constant 	release getenv 
table 	strcmp http status 
isk kst 	hdr nocache 
indexk grep 	end headers format 
order change 	write exit 
enums name 	service strbuf reset 
args description 	strbuf addf 
kst 	check content type 
nil gbl 	hdr nocache 
kst gbl 	strbuf reset 
kst size 	strbuf addf hdr 
length see 	str end 
note nil 	headers run service 
fpf 	strbuf release 
close variables 	vreportf http status 
stack closure 	hdr nocache 
kproto vararg 	end headers exit 
notes call 	getenv getenv 
top number 	getenv die daemon 
returns 	avoid die 
call sets 	end url slash 
top last 	strbuf addstr 
result next 	strbuf detach xstrdup 
open instruction 	die getenv 
call setlist 	git setup gettext 
may 	git extract 
use top 	argv path die 
vararg use 	routine die 
actual number 	recursing routine 
varargs top 	die strcmp getdir 
like call 	size regcomp 
top 	die regexec strcmp 
setlist top 	getenv strcmp 
next instruction 	http status hdr 
real comparisons 	str strcmp 
specifies condition 	http status hdr 
test accept 	nocache end 
skips 	headers xmemdupz regfree 
next instruction 	found setup 
jump masks 	path enter repo 
instruction properties 	found getenv 
format bits 	access found http 
mode bits 	config git 
arg 	env imp basically 
mode bits 	strbuf read 
arg mode 	hit max request 
bit instruction 	buffer die 
bit test 	rather reject 
argument used 	maliciously large request 
argument 	chew infinite 
used argument 	memory read read 
jump offset 	full means 
argument constant 	hit eof otherwise 
constant opcode 	grow nothing 
names number 	left read service 
list 	name successfully 
items accumulate 	reported failure http-fetch.c 
setlist instruction 	http fetch 
loslib.c filename 	usage argc argv 
filename fromname 	walker commits 
toname buff 	stdin commits write 
err 	commit url 
key key 	arg history verbosely 
key res 	recover git 
key res 	setup gettext 
stm reslen 	git extract argv 
buff cat 	path usage 
catnames 	strcmp strcmp usage 
syslib lua 	walker targets 
pushboolean lua 	stdin warning str 
pushnil lua 	end url 
pushfstring strerror 	slash setup git 
lua pushinteger 	directory git 
lua 	config http init 
pushinteger system 	http walker 
lua optstring 	walker fetch walker 
lua checkstring 	targets free 
pushresult lua 	walker free http 
checkstring lua 	cleanup free 
checkstring 	http-push.c http push 
pushresult rename 	usage pushing 
lua tmpnam 	aborted remote dir 
lua error 	exists push 
lua pushstring 	verbosely push 
lua pushstring 	force dry run 
getenv 	helper status 
lua checkstring 	objects url path 
lua pushnumber 	path len 
clock lua 	info refs update 
pushinteger lua 	info refs 
setfield lua 	info packs packs 
pushboolean 	locks repo 
lua setfield 	obj url dest 
lua getfield 	headers buffer 
lua isnil 	curl result errorstr 
lua toboolean 	http code 
lua pop 	user data slot 
lua 	next request 
getfield lua 	queue head name 
isnumber lua 	len cdata 
tointeger lua 	ctx tag closed 
error lua 	user data 
pop lua 	url owner 
optstring 	token tmpfile suffix 
lua opt 	start time 
time gmtime 	timeout refreshing next 
localtime lua 	path user 
pushnil strcmp 	data flags dentry 
lua createtable 	name dentry 
setfield 	flags parent buf 
setfield setfield 	curl url 
setfield setfield 	custom req curl 
setfield setfield 	url custom 
setfield setboolfield 	req buffer write 
lua buffinit 	dav token 
lua 	headers request request 
addchar strftime 	callback data 
lua addlstring 	request request slot 
lua pushresult 	obj req 
lua isnoneornil 	request hex slot 
time lua 	request target 
checktype 	check request 
lua settop 	preq request hex 
getfield getfield 	slot buf 
getfield getfield 	hdr unpacked len 
getfield getfield 	hdrlen size 
getboolfield mktime 	stream request slot 
time 	dav headers 
lua pushnil 	slot results dav 
lua pushnumber 	headers current 
lua pushnumber 	time time remaining 
difftime time 	request entry 
lua checknumber 	request preq obj 
time 	req fail 
lua optnumber 	running queue unused 
lua optstring 	request parent 
lua checkoption 	obj request obj 
lua pushstring 	request target 
setlocale exit 	ret sha 
lua 	obj ctx tag 
optint lua 	closed flags 
loslib roberto 	ctx tag closed 
exp standard 	sha ctx 
operating system 	token sha arg 
library see 	refname user 
copyright 	data name atts 
notice lua 	ctx old 
calls lua 	namelen len user 
api may 	data name 
change push 	ctx user data 
nil time 	len ctx 
date 	path timeout slot 
operations year 	results buffer 
month day 	buffer url timeout 
hour min 	header dav 
sec wday 	headers ctx escaped 
yday isdst 	saved character 
undefined 	parser slot 
field utc 	results prev dav 
skip invalid 	headers next 
date number 	signo path flags 
fields conversion 	user func 
specifier big 	user data path 
enough 	sha hex 
conversion result 	parent path sha 
called without 	ctx tag 
args current 	closed path url 
time make 	path flags 
sure table 	user func user 
top 	data url 
lparser.c token 	slot results buffer 
limit msg 	buffer dav 
varname oldsize 	headers ctx parser 
name nvars 	parent path 
tolevel name 	hex val slot 
oldsize 	results buffer 
level varname 	buffer dav 
nvars nexps 	headers ctx flags 
extra reg 	escaped parser 
isbreakable func 	obj entry blob 
oldsize buff 	obj obj 
name 	desc entry revs 
lexstate funcstate 	commit count 
key tostore 	entry obj name 
reg key 	sha slot 
val rkkey 	results buffer dav 
line nparams 	headers remote 
needself 	refs refname obj 
line args 	buf buffer 
nparams line 	slot results dav 
line key 	headers path 
key left 	url ret path 
right limit 	symref sha 
uop 	url buffer name 
nextop token 	head sha 
prev extra 	remote head 
conflict nvars 	branch pattern force 
nexps upval 	refs remote 
line whileinit 	head sha symref 
condexit 	match patlen 
line condexit 	slot results url 
repeat init 	name namelen 
line nvars 	argc argv request 
isnum prep 	next request 
endfor varname 	refspec refspec info 
line 	revs branch 
indexname nvars 	force objects send 
line line 	refs local 
varname condexit 	refs arg path 
line flist 	commit argv 
escapelist nvars 	strbuf addstr xml 
nexps 	quoted strbuf 
needself line 	detach curl 
needself first 	easy setopt curl 
nret line 	easy setopt 
islast lua 	curl easy setopt 
newstring getstr 	curl easy 
lua 	setopt curl easy 
syntaxerror lua 	setopt curl 
pushfstring lua 	easy setopt curl 
token str 	easy setopt 
lua pushfstring 	curl easy setopt 
lua pushfstring 	curl easy 
lua 	setopt curl easy 
lexerror lua 	setopt curl 
next error 	easy setopt curl 
expected check 	easy setopt 
lua next 	curl easy setopt 
testnext error 	curl easy 
expected 	setopt curl easy 
lua syntaxerror 	setopt finish 
lua pushfstring 	request http 
lua token 	request start active 
str lua 	slot release 
token 	http request release 
str check 	request oid 
lua next 	hex remote url 
init exp 	active slot 
lua codestring 	curl setup http 
str checkname 	curl easy 
lua 	setopt start active 
growvector lua 	slot free 
objbarrier lua 	find sha pack 
checklimit cast 	oid hex 
getlocvar getlocvar 	release request sha 
lua lua 	hex oid 
checklimit 	hex http pack 
lua growvector 	request strcmp 
lua objbarrier 	release http pack 
lua cast 	request release 
cast getlocvar 	request start 
init exp 	active slot release 
searchvar 	http pack 
init exp 	request release request 
markupval singlevaraux 	oid hex 
indexupvalue str 	read sha file 
checkname singlevaraux 	xsnprintf git 
lua hasmultret 	deflate init git 
lua 	deflate bound 
setreturns lua 	strbuf init git 
reserveregs lua 	deflate git 
exp nextreg 	deflate git deflate 
lua reserveregs 	end free 
lua nil 	strbuf addstr append 
lua 	remote url 
lexerror lua 	strbuf detach append 
removevars lua 	remote url 
code abc 	strbuf strbuf detach 
lua lua 	active slot 
lua patchtohere 	curl setup 
lua 	http start active 
growvector lua 	slot free 
objbarrier init 	active slot curl 
exp lua 	setup http 
code lua 	curl slist append 
code abc 	curl slist 
lua 	append curl easy 
newproto lua 	setopt start 
sethvalue incr 	active slot free 
top setptvalue 	dav token 
incr top 	headers active slot 
removevars lua 	curl setup 
ret 	http curl easy 
lua reallocvector 	setopt start 
lua reallocvector 	active slot run 
lua reallocvector 	active slot 
lua reallocvector 	time curl slist 
lua reallocvector 	free time 
lua 	refresh free 
reallocvector lua 	free check locks 
lua checkcode 	curl slist 
lua anchor 	free free start 
token lua 	put oid 
setinput lua 	hex start move 
open 	oid hex 
func lua 	oid hex release 
next chunk 	request oid 
check close 	hex finish http 
func lua 	request release 
lua lua 	http request release 
lua 	request start 
exp anyreg 	fetch packed finish 
lua next 	http pack 
checkname lua 	request release http 
indexed lua 	pack request 
next expr 	release request 
lua 	start fetch loose 
exp val 	start put 
checknext lua 	start mkcol check 
checklimit checkname 	locks remote 
yindex checknext 	list xmalloc fill 
lua exp 	active slots 
expr 	step active slots 
lua code 	check locks 
abc lua 	remote list find 
exp lua 	sha pack 
exp nextreg 	xmalloc fill active 
lua setlist 	slots step 
hasmultret 	active slots http 
lua setmultret 	info packs 
lua setlist 	lookup parse list 
lua exp 	contains list 
nextreg lua 	insert strcmp strcmp 
setlist expr 	strcmp strcmp 
lua 	xstrdup strcmp 
checklimit lua 	skip prefix strtol 
code abc 	strcmp xstrdup 
init exp 	git sha init 
init exp 	git sha 
lua exp 	update strlen git 
nextreg 	sha memcpy 
checknext testnext 	sha hex strchr 
testnext lua 	strlen strlen 
closelistfield lua 	xrealloc xsnprintf free 
lookahead listfield 	user func 
recfield recfield 	strchr user func 
listfield 	strlen strlen 
check match 	free xmemdupz xstrfmt 
lastlistfield setarg 	strchr strlen 
lua setarg 	active slot curl 
lua testnext 	setup http 
localvar str 	start active slot 
checkname 	run active 
lua next 	slot free 
localvarliteral lua 	free strchr xml 
syntaxerror lua 	entities ident 
adjustlocalvars cast 	email strbuf addf 
lua reserveregs 	free xsnprintf 
open 	curl slist append 
func checknext 	curl slist 
localvarliteral adjustlocalvars 	append active slot 
parlist checknext 	curl setup 
chunk check 	http curl easy 
match close 	setopt curl 
func 	easy setopt xcalloc 
pushclosure expr 	start active 
testnext lua 	slot run active 
exp nextreg 	slot xml 
expr lua 	parser create xcalloc 
syntaxerror lua 	xml user 
next 	data xml element 
explist lua 	handler xml 
setmultret check 	character data 
match constructor 	handler xml parse 
codestring lua 	free xml 
next lua 	error xml error 
syntaxerror 	code xml 
lua hasmultret 	parser free curl 
lua exp 	slist free 
nextreg init 	strbuf release strbuf 
exp lua 	release free 
code abc 	free free free 
lua 	time dav 
fixline lua 	token headers active 
next expr 	slot curl 
check match 	setup http curl 
lua dischargevars 	easy setopt 
singlevar lua 	start active slot 
syntaxerror 	run active 
prefixexp field 	slot curl 
lua exp 	slist free free 
anyreg yindex 	free free 
lua indexed 	free unlock remote 
lua next 	locks sigchain 
checkname 	pop strlen memcpy 
lua self 	memcpy sha 
funcargs lua 	hex strcmp skip 
exp nextreg 	prefix sha 
funcargs init 	hex objpath one 
exp codestring 	remote strcmp 
init 	one remote strcmp 
exp init 	str end 
exp init 	url slash user 
exp check 	func strcmp 
condition lua 	remote user func 
init exp 	strcmp strstr 
lua 	strchr strncmp error 
code abc 	xstrdup strcmp 
constructor lua 	strcmp free 
next body 	xstrfmt xstrdup strbuf 
primaryexp lua 	addf curl 
next enterlevel 	slist append curl 
getunopr 	slist append 
lua next 	active slot curl 
subexpr lua 	setup http 
prefix simpleexp 	curl easy setopt 
getbinopr lua 	curl easy 
next lua 	setopt start active 
infix 	slot run 
subexpr lua 	active slot xml 
posfix leavelevel 	parser create 
subexpr enterblock 	xcalloc xml user 
chunk lua 	data xml 
leaveblock lua 	element handler xml 
code 	character data 
abc lua 	handler xml parse 
reserveregs check 	free xml 
condition testnext 	error xml 
primaryexp check 	error code xml 
conflict lua 	parser free 
checklimit 	free free strbuf 
assignment checknext 	release strbuf 
explist adjust 	release curl slist 
assign lua 	free remote 
setoneret lua 	xml entities strbuf 
storevar init 	addf free 
exp 	curl slist append 
lua storevar 	curl slist 
expr lua 	append active slot 
goiftrue lua 	curl setup 
syntaxerror lua 	http curl easy 
code abc 	setopt curl 
lua 	easy setopt start 
concat lua 	active slot 
jump lua 	run active slot 
next lua 	xml parser 
getlabel cond 	create xcalloc 
enterblock checknext 	xml user data 
block 	xml element 
lua patchlist 	handler xml parse 
lua jump 	free xml 
check match 	error xml error 
leaveblock lua 	code xml 
patchtohere lua 	parser free error 
getlabel 	error error 
enterblock enterblock 	strbuf release strbuf 
lua next 	release curl 
chunk check 	slist free xmalloc 
match cond 	one parse 
leaveblock lua 	die oid hex 
patchlist 	one init 
breakstat lua 	desc entry type 
patchtohere leaveblock 	process lookup 
lua patchlist 	process blob 
lua jump 	lookup blob free 
leaveblock expr 	buffer revision 
lua 	process send request 
exp nextreg 	one process 
adjustlocalvars checknext 	process blob die 
lua code 	oid hex 
lua jump 	send request dav 
enterblock adjustlocalvars 	token headers 
lua 	strbuf addf sha 
reserveregs block 	hex active 
leaveblock lua 	slot curl setup 
patchtohere lua 	http curl 
code lua 	easy setopt start 
code abc 	active slot 
lua 	run active slot 
fixline lua 	strbuf release 
patchlist lua 	strbuf release alloc 
jump localvarliteral 	http fetch 
localvarliteral localvarliteral 	free file 
localvar checknext 	lookup unknown oid 
exp 	hex fetch 
checknext exp 	request remote alloc 
testnext exp 	http fetch 
lua code 	free parse oid 
lua number 	hex free 
lua reserveregs 	strbuf addf oid 
forbody 	hex deref 
localvarliteral localvarliteral 	tag strbuf addf 
localvarliteral localvar 	oid hex 
testnext localvar 	free remote dav 
str checkname 	token headers 
checknext adjust 	active slot curl 
assign 	setup http 
explist lua 	curl easy setopt 
checkstack forbody 	start active 
enterblock lua 	slot run active 
next str 	slot strbuf 
checkname fornum 	release xstrfmt 
forlist 	http strbuf error 
lua syntaxerror 	free xstrfmt 
lua lua 	http strbuf die 
check match 	free free 
leaveblock lua 	hashclr strbuf rtrim 
next cond 	skip prefix 
checknext 	xmemdupz sha hex 
block test 	strbuf release 
block lua 	lookup commit die 
concat lua 	lookup commit 
jump lua 	die merge bases 
patchtohere test 	strlen strlen 
block 	memcmp error error 
lua concat 	fetch symref 
lua jump 	error strcmp error 
lua patchtohere 	fetch symref 
lua next 	error sha error 
block lua 	sha file 
concat 	error sha 
lua patchtohere 	hex oid error 
check match 	file error 
localvar str 	oid hex verify 
checkname init 	merge error 
exp lua 	xstrfmt active slot 
reserveregs 	curl setup 
adjustlocalvars body 	http start active 
lua storevar 	slot run 
getlocvar testnext 	active slot free 
localvar str 	error free 
checkname testnext 	error fill active 
explist 	slots fill 
adjust assign 	function finish active 
adjustlocalvars singlevar 	slots fill 
field field 	active slots git 
lua next 	setup gettext 
funcname body 	git extract argv 
lua 	path xcalloc 
storevar lua 	strcmp strcmp 
fixline primaryexp 	strcmp strcmp strcmp 
setarg getcode 	strcmp strcmp 
assignment lua 	strcmp usage strstr 
next block 	str end 
follow 	url slash strlen 
explist hasmultret 	strchr strlen 
lua setmultret 	die usage die 
opcode getcode 	setup git 
lua getarg 	directory memset http 
getcode lua 	init locking 
exp 	available sigchain push 
anyreg lua 	common remote 
exp nextreg 	exists remote exists 
lua lua 	remote error 
ret ifstat 	fetch indices local 
whilestat lua 	heads dav 
next 	remote heads 
block check 	run request queue 
match forstat 	remote branch 
repeatstat funcstat 	match push refs 
lua next 	oid remote 
testnext localfunc 	branch error oidcmp 
localstat 	oid file 
retstat lua 	newer error oidcpy 
next breakstat 	strcmp oid 
exprstat enterlevel 	hex oid hex 
block follow 	remote argv 
statement testnext 	push argv push 
lua 	argv push 
leavelevel lparser 	oid hex oid 
roberto exp 	argv pushf 
lua parser 	oid hex init 
see copyright 	revisions setup 
notice lua 	git directory setup 
nodes 	revisions prepare 
block list 	revision walk 
list active 	die mark edges 
blocks chain 	uninteresting delta 
list jumps 	finish active slots 
loop active 	run request 
locals 	queue update remote 
outside breakable 	unlock remote 
structure variable 	check locks argv 
block upvalue 	clear update 
block loop 	remote info refs 
prototypes recursive 	unlock remote 
non 	free http cleanup 
terminal functions 	release request 
one found 	dav methods dav 
levels variable 	flags dav 
look current 	xml properties dav 
level local 	request body 
used 	templates remember update 
upval found 	flag allocation 
current level 	allow recursive 
upper one 	symbolic refs within 
local upval 	reason though 
upvalue level 	flags control remote 
info 	processing flags 
points name 	remote passes callback 
includes call 	functions dav 
last exp 	token headers options 
provides difference 	request started 
close last 	abort request error 
expression 	make sure 
block either 	isn another open 
controls scope 	request pack 
breaks never 	request started abort 
free registers 	request error 
linked list 	compress first header 
funcstates 	nothing data 
registers always 	nothing keep locks 
valid anchor 	active url 
table constants 	reused move 
prototype avoid 	put fetching packed 
collected last 	necessary fetch 
token 	known exist locally 
read anchored 	already request 
defunct function 	queue keep locks 
must reanchor 	active push 
table prototype 	known exist remote 
stack main 	already request 
func 	queue ignore remote 
always vararg 	objects exist 
read first 	locally make sure 
token grammar 	leading directories 
rules field 	exist remote extract 
name skip 	hex sharded 
dot 	filename skip ensure 
colon index 	collection names 
expr skip 	end slash 
rules constructors 	needswork remote ignores 
last list 	info refs 
item read 	remote side heed 
table 	information file 
descriptor total 	instead trying determine 
number record 	refs remote 
elements total 	file system badly 
number elements 	even know 
number elements 	packed refs subproject 
pending 	commit repository 
stored recfield 	attempt recovery fetch 
name exp 	copy doesn 
exp token 	exist locally may 
free registers 	required updating 
list item 	server info later 
flush 	cut trailing 
items pending 	newline symref refname 
count last 	otherwise sha 
expression unknown 	find remote 
number elements 	branch matching specified 
constructor yet 	branch name 
fix 	remote head must 
stack top 	symref exactly 
may listfields 	foolproof remote symlink 
recfields expression 	symref look 
constructor item 	like symref remote 
recfield constructor 	branch must 
part 	remote head run 
listfield initial 	extra sanity 
size initial 	checks forced remote 
table size 	head must 
parlist param 	resolve known remote 
param parlist 	branch must 
empty 	resolve known remote 
param name 	branch must 
param use 	ancestor remote head 
arg name 	send request 
reserve parameters 	verify dav 
body parlist 	compliance support check 
chunk 	whether remote 
end explist 	server info files 
expr expr 	list local 
least one 	remote heads validate 
expression funcargs 	refspecs remote 
explist arg 	branch specified match 
list 	remote know 
empty funcargs 	remote ancestor trying 
constructor funcargs 	push either 
must use 	way losing commits 
seminfo next 	remote end 
call 	likely date begin 
open call 	remote branch 
close last 	revision info refspec 
argument call 	ignored generate 
function arguments 	list objects need 
leaves unless 	pushed push 
changed 	missing objects 
one result 	remote would convenient 
expression parsing 	time pack 
prefixexp name 	first appropriate update 
expr primaryexp 	remote branch 
prefixexp name 	went well update 
exp 	remote server 
name funcargs 	info appropriate http-walker.c 
funcargs field 	got indices 
exp name 	packs next walker 
funcargs funcargs 	sha repo 
simpleexp number 	req next walker 
nil 	url buffer 
constructor function 	slot http specific 
body primaryexp 	url got 
vararg need 	alternates alt queue 
arg constructor 	head walker 
left priority 	callback data 
binary 	walker obj req 
right priority 	slot req 
order opr 	obj req callback 
power concat 	data obj 
right associative 	req walker data 
equality inequality 	alt obj 
order 	req entry walker 
logical priority 	obj req 
unary operators 	walker sha newreq 
subexpr simpleexp 	tail data 
unop subexpr 	callback data alt 
binop subexpr 	req walker 
binop 	cdata slot tail 
binary priority 	data posn 
higher limit 	okay serverlen newalt 
expand operators 	colon colon 
priorities higher 	slash target walker 
limit read 	buffer url 
sub 	slot alt 
expression higher 	req cdata walker 
priority first 	repo ret 
untreated rules 	walker repo sha 
statements block 	target ret 
chunk structure 	results preq obj 
chain 	req walker 
variables left 	repo sha hex 
hand side 	ret obj 
assignment variable 	req req walker 
local upvalue 	sha data 
indexed check 	altbase walker data 
whether 	walker data 
assignment local 	alt alt next 
variable local 	url data 
variable needed 	walker http request 
previous assignment 	start active 
table save 	slot release http 
original 	request finish 
local safe 	http request 
place use 	walker say sha 
safe copy 	hex process 
previous assignment 	http request missing 
eventual position 	target fetch 
save 	alternates release http 
local variable 	request start 
conflict previous 	request finish request 
assignment use 	error free 
safe copy 	sha file start 
conflict previous 	request xmalloc 
assignment 	hashcpy fill active 
use safe 	slots step 
copy make 	active slots strbuf 
copy assignment 	reset strbuf 
primaryexp assignment 	addf curl easy 
assignment explist 	setopt start 
extra 	active slot missing 
values close 	target fwrite 
last expression 	buffer strstr 
avoid assignment 	strchr memcmp strlen 
cond exp 	memcmp strchr 
read condition 	strchr strchr strbuf 
falses 	strbuf xmalloc 
equal whilestat 	strbuf detach step 
cond block 	active slots 
end skip 	strbuf addf active 
conditions finish 	slot curl 
loop repeatstat 	easy setopt curl 
repeat 	easy setopt 
block cond 	curl easy setopt 
loop block 	start active 
scope block 	slot run active 
skip repeat 	slot strbuf 
read condition 	release strbuf release 
inside 	http info 
scope block 	packs fetch indices 
upvalues finish 	find sha 
scope close 	pack sha 
loop complete 	hex sha hex 
semantics upvalues 	http pack 
condition 	request start active 
finish scope 	slot run 
repeat finish 	active slot error 
loop forbody 	error finish 
block control 	http pack request 
variables scope 	release http 
declared 	pack request release 
variables end 	request sha 
scope declared 	hex hashcmp error 
variables pretend 	sha file 
starts loop 	abort http request 
fornum name 	abort request 
exp 	step active slots 
exp exp 	start request 
forbody initial 	run active 
limit optional 	slot close error 
step step 	missing target 
forlist name 	error error hashcmp 
name 	error error 
explist forbody 	sha file name 
create control 	release http 
variables create 	request release request 
declared variables 	fetch http 
extra space 	fetch pack fetch 
call 	alternates error 
generator forstat 	sha hex http 
fornum forlist 	fetch free 
end scope 	free free xmalloc 
loop control 	xmalloc xmalloc 
variables skip 	xstrdup strlen fill 
first 	function request 
variable name 	started abort request 
loop scope 	error use 
jumps point 	alternates necessary 
test block 	reusing slot non 
elseif cond 	http alternates 
block 	counts http git 
skip elseif 	host pub 
part ifstat 	scm linux git 
cond block 	memcpy dst 
elseif cond 	serverlen copy git 
block block 	host relative 
end 	url chop corresponding 
cond block 	number subpath 
elseif cond 	data concatenate result 
block skip 	code first 
patch correct 	drops data drops 
line info 	one data 
part 	one path iow 
debug information 	one extra 
see variable 	dropped data path 
point stat 	dropped wrong 
local name 	alternate http 
name explist 	git host pub 
funcname 	scm linux 
name field 	git borrow http 
name funcstat 	git host 
function funcname 	pub scm linus 
body skip 	git linus 
function definition 	git objects need 
happens 	two borrow 
first line 	direct neighbour server 
stat func 	got removed 
assignment stat 	give skip objects 
func call 	end another 
statement uses 	request already started 
results 	fetching alternates 
stat assignment 	wait arrive processing 
stat explist 	request curl 
registers returned 	message nothing already 
values skip 	fetched start 
values optional 	fetch use 
values 	callback process result 
tail call 	since another 
values one 	request may fail 
single values 	need alternates 
must stack 	loaded continuing obj 
active values 	req req 
may 	might change fetching 
needed error 	alternates callback 
messages stat 	process response therefore 
ifstat stat 	shortcut variable 
whilestat stat 	req used done 
block end 	slots silent 
skip 	probably pack http.c 
stat forstat 	git curl 
stat repeatstat 	ipresolve git curl 
stat funcstat 	ipresolve active 
stat localstat 	requests http 
skip local 	verbose http post 
local 	buffer min 
function stat 	curl sessions curl 
retstat must 	session count 
last statement 	max requests curlm 
stat breakstat 	curl curl 
skip must 	errorstr curl ssl 
last 	verify curl 
statement avoid 	ssl ssl cert 
warnings chunk 	ssl cipherlist 
stat free 	ssl version name 
registers lparser.h 	ssl version 
buff name 	ssl key ssl 
lparser 	capath ssl 
roberto exp 	pinnedkey ssl cainfo 
lua parser 	curl low 
see copyright 	speed limit curl 
notice lua 	low speed 
expression descriptor 	time curl 
info 	ftp epsv curl 
index constant 	http proxy 
nval numerical 	curl proxy http 
info local 	proxy authmethod 
info index 	name curlauth param 
upvalue upvalues 	proxy auth 
info 	curl proxyuserpwd curl 
index table 	cookie file 
aux index 	curl save cookies 
name info 	http auth 
table aux 	http proactive auth 
index info 	user agent 
instruction 	curl empty auth 
info instruction 	cert auth 
info result 	ssl cert password 
info instruction 	required http 
info instruction 	auth methods pragma 
patch list 	header pragma 
exit 	header active 
patch list 	queue head cached 
exit defined 	accept language 
lparser state 	ptr eltsize nmemb 
needed generate 	buffer size 
code given 	buffer handle cmd 
function 	clientp buffer 
current function 	ptr eltsize nmemb 
header table 	buffer size 
find reuse 	buffer ptr eltsize 
elements enclosing 	nmemb strbuf 
function lexical 	slot slot num 
state 	messages slot 
copy lua 	curl message curl 
state chain 	result result 
current blocks 	result result client 
next position 	type len 
code equivalent 	result allowed protocols 
ncode 	url envname 
last jump 	val remote 
target list 	url proactive auth 
pending jumps 	low speed 
first free 	limit low speed 
number elements 	time normalized 
number 	url config http 
elements number 	max requests 
elements locvars 	slot next slot 
number active 	newslot num 
local variables 	transfers slot curlm 
upvalues declared 	result num 
variable 	transfers data next 
stack lstate.c 	fill cfg 
lua newvector 	data fill linkp 
lua newvector 	slot fill 
setnilvalue lua 	num transfers curlm 
freearray lua 	result slot 
freearray 	readfds writefds 
unused stack 	excfds max timeout 
init sethvalue 	finished curl 
lua sethvalue 	timeout slot slot 
registry lua 	buf buf 
lua resize 	url hex two 
lua 	digit prefix 
init lua 	url hex two 
init lua 	digit prefix 
fix lua 	buf results slot 
newliteral resethookcount 	results curl 
setnilvalue lua 	info buf ptr 
close 	ret raw 
lua freeall 	name len raw 
lua obj 	type charset 
gco lua 	buf max places 
lua freearray 	max language 
lua freebuffer 	tags max accept 
freestack 	language header 
lua frealloc 	size language 
fromstate state 	tags num langs 
size tostate 	tag last 
lua malloc 	buf len max 
state size 	places format 
lua 	buf curl pos 
link obj 	buf url 
gco preinit 	result target options 
state stack 	slot results 
init setobj 	headers buf accept 
resethookcount lua 	language ret 
iswhite 	posn raw asked 
obj gco 	got tail 
lua close 	tail len url 
lua luai 	result target 
userstatefree freestack 	options ret url 
lua freemem 	result options 
fromstate 	url filename options 
state size 	ret tmpfile 
state size 	result options 
tostate bit 	url buffer ret 
mask lua 	sha url 
white bits 	url tmp buf 
preinit 	packs head 
state setnilvalue 	sha url pack 
registry lua 	tmp idx 
initbuffer obj 	ret url packs 
gco lua 	head options 
rawrunprotected close 	url data buf 
state 	sha preq 
luai userstateopen 	preq lst tmp 
unused lua 	idx len 
call gctm 	argv target url 
lua lua 	prev posn 
close lua 	buf preq ptr 
separateudata 	eltsize nmemb 
lua rawrunprotected 	data expn size 
lua luai 	posn freq 
userstateclose close 	retval url 
state lstate 	sha hex filename 
roberto exp 	prevfile prevlocal 
state 	prev buf prev 
see copyright 	read prev 
notice lua 	posn freq dir 
main combines 	freq freq 
state state 	freq freq memcpy 
initialize call 	strbuf closedown 
info 	active slot curl 
initialize stack 	easy getinfo 
initialize first 	curl easy getinfo 
function entry 	curl easy 
open parts 	getinfo callback func 
may cause 	curl multi 
memory 	info read curl 
allocation errors 	multi handle 
init stack 	finish active slot 
table globals 	curl multi 
registry initial 	info read 
size table 	strcmp git config 
close 	strcmp git 
upvalues collect 	config strcmp git 
objects init 	config strcmp 
stack share 	git config strcmp 
table globals 	git config 
close upvalues 	strcmp git config 
mark 	pathname strcmp 
unfinished state 	git config pathname 
memory allocation 	strcmp git 
error free 	config strcmp git 
state call 	config strcmp 
metamethods udata 	git config strcmp 
main 	git config 
closed close 	strcmp git config 
upvalues separate 	strcmp git 
udata metamethods 	config strcmp 
error function 	git config strcmp 
metamethods repeat 	git config 
errors 	strcmp git config 
lstate.h status 	strcmp git 
top savedpc 	config strcmp git 
stack last 	config strcmp 
stack end 	git config strcmp 
stacksize size 	git config 
ccalls 	strcmp git config 
ccalls hookmask 	strcmp git 
allowhook basehookcount 	config pathname warning 
hookcount hook 	git config 
env openupval 	curl easy setopt 
gclist error 	credential fill 
jmp 	curl easy setopt 
errfunc gch 	curl easy 
lstate roberto 	setopt strbuf addf 
exp state 	curl easy 
see copyright 	setopt free 
notice lua 	xstrdup curl easy 
defined 	setopt curl 
ldo table 	easy setopt strbuf 
globals registry 	addstr urlencode 
extra stack 	strbuf addch strbuf 
space handle 	addstr urlencode 
calls extras 	strbuf detach curl 
number 	easy setopt 
elements informations 	credential fill proxyauth 
call function 	name password 
function index 	getenv size strcmp 
stack top 	curl easy 
function expected 	setopt size warning 
number 	curl easy 
results function 	setopt curl easy 
number tail 	setopt xstrdup 
calls lost 	xstrdup xstrdup credential 
entry state 	fill curl 
shared threads 	easy setopt 
state 	setsockopt warning strerror 
hash table 	curl easy 
function reallocate 	setopt curl easy 
memory auxiliary 	init die 
data frealloc 	curl easy setopt 
state garbage 	curl easy 
collector 	setopt curl easy 
position sweep 	setopt curl 
strt list 	easy setopt curl 
collectable objects 	easy setopt 
position sweep 	curl easy setopt 
rootgc list 	init curl 
gray 	http auth getenv 
objects list 	getenv size 
objects traversed 	strcmp curl easy 
atomically list 	setopt size 
weak tables 	warning getenv getenv 
cleared last 	curl easy 
element 	setopt curl 
list userdata 	easy setopt cert 
temporary buffer 	password curl 
concatentation number 	easy setopt curl 
bytes currently 	easy setopt 
allocated estimate 	curl easy setopt 
number 	curl easy 
bytes actually 	setopt curl easy 
use much 	setopt curl 
behind schedule 	easy setopt curl 
size pause 	easy setopt 
successive granularity 	curl easy setopt 
called 	curl easy 
unprotected errors 	setopt curl easy 
head linked 	setopt curl 
list open 	easy setopt transport 
upvalues metatables 	allowed transport 
basic types 	allowed transport 
tag 	allowed transport allowed 
method names 	curl easy 
per state 	setopt transport restrict 
first free 	protocols warning 
slot stack 	getenv curl easy 
current 	setopt curl 
function call 	easy setopt git 
info current 	user agent 
function savedpc 	curl easy setopt 
current function 	curl easy 
last free 	setopt strcmp getenv 
slot 	getenv getenv 
stack stack 	getenv getenv curl 
points end 	easy setopt 
call info 	starts curl easy 
size number 	setopt starts 
nested calls 	curl easy setopt 
nested 	starts curl 
calls resuming 	easy setopt 
coroutine table 	strstr credential url 
globals temporary 	strbuf addf 
place environments 	credential url strbuf 
list open 	release curl 
upvalues 	easy setopt getenv 
stack current 	getenv curl 
error recover 	easy setopt init 
point current 	curl proxy 
error handling 	auth curl keepalive 
function stack 	getenv url 
index 	normalize git config 
collectable objects 	free curl 
macros convert 	init die xstrdup 
specific macro 	curl slist 
convert lua 	append curl slist 
lstring.c newsize 	append getenv 
newhash 	atoi curl multi 
next str 	init die 
str step 	getenv env 
lua newvector 	env env env 
gco lmod 	env getenv 
lua cast 	strtol getenv strtol 
lmod 	getenv credential 
lua freearray 	url getenv starts 
lua toobig 	curl handle 
cast lua 	curl multi handle 
malloc lua 	curl easy 
white memcpy 	cleanup free curl 
lmod 	easy cleanup 
obj gco 	curl multi cleanup 
cast lua 	curl cleanup 
resize lmod 	curl slist free 
rawgco memcmp 	curl slist 
getstr isdead 	free free memset 
changewhite 	strlen free 
newlstr lua 	free free memset 
toobig cast 	strlen free 
lua malloc 	free curl 
lua white 	multi perform process 
obj gco 	curl messages 
lstring 	xmalloc curl handle 
roberto exp 	curl easy 
table keeps 	duphandle curl easy 
handled lua 	setopt curl 
see copyright 	easy setopt curl 
notice lua 	easy setopt 
cannot 	curl easy setopt 
resize traverse 	curl easy 
rehash node 	setopt curl easy 
list save 	setopt curl 
next position 	easy setopt curl 
chain ending 	easy setopt 
chain 	curl easy setopt 
entry crowded 	curl easy 
seed hash 	setopt curl 
chars compute 	easy setopt curl 
hash may 	easy setopt 
dead found 	curl easy setopt 
finalized 	curl easy 
chain udata 	setopt init curl 
list main 	http auth 
lstring.h newsize 	curl multi handle 
str lstring 	curl multi 
roberto exp 	perform xmalloc fill 
table 	curl easy 
keep handled 	cleanup curl multi 
lua see 	perform process 
copyright notice 	curl messages fill 
lua lstrlib.c 	active slots 
pos len 	step active slots 
start 	curl multi 
end posi 	timeout zero zero 
pose size 	zero curl 
level res 	multi fdset 
sig cont 	curl easy perform 
res res 	finish active 
res 	slot closedown active 
level res 	slot curl 
len previous 	multi handle curl 
res init 	easy cleanup 
nlevels find 	fill active slots 
init anchor 	run active 
res 	slot end url 
src newstart 	slash needs 
news srcl 	quote strbuf addf 
src max 	strbuf addch 
anchor arg 	strbuf detach end 
strfrmt form 	url slash 
form 	strbuf addf strbuf 
spec top 	addf append 
arg sfl 	remote url strbuf 
strfrmt strfrmt 	detach snprintf 
end form 	credential approve 
buff strlib 	credential approve missing 
lua 	target credential 
checklstring lua 	reject credential reject 
pushinteger lua 	strlcpy curl 
checklstring posrelat 	easy strerror start 
lua checkinteger 	active slot 
posrelat lua 	snprintf run active 
optinteger 	slot handle 
lua pushlstring 	curl result strbuf 
lua pushliteral 	reset curl 
lua checklstring 	easy getinfo strbuf 
lua buffinit 	addstr strlen 
lua addchar 	strncasecmp isspace strbuf 
lua 	addch strbuf 
pushresult lua 	reset strbuf grow 
checklstring lua 	isspace strbuf 
buffinit lua 	addch tolower strbuf 
addchar tolower 	reset isspace 
uchar lua 	extract param 
pushresult 	isspace starts strbuf 
lua checklstring 	addstr preferred 
lua buffinit 	languages isalnum strbuf 
lua addchar 	addch realloc 
toupper uchar 	strbuf detach realloc 
lua pushresult 	xsnprintf strbuf 
lua 	addstr strbuf addstr 
checklstring lua 	strbuf addstr 
checkint lua 	strbuf addf strbuf 
buffinit lua 	free free 
addlstring lua 	write accept language 
pushresult lua 	strbuf detach 
checklstring 	xsnprintf curl easy 
posrelat lua 	setopt active 
optinteger posrelat 	slot curl easy 
lua optinteger 	setopt curl 
lua error 	easy setopt curl 
lua checkstack 	easy setopt 
lua 	curl easy 
pushinteger uchar 	setopt ftello curl 
lua gettop 	easy setopt 
lua buffinit 	http opt request 
lua checkint 	remainder curl 
lua argcheck 	easy setopt accept 
uchar 	language curl 
lua addchar 	slist append strbuf 
uchar lua 	addstr strbuf 
pushresult lua 	addstr curl easy 
addlstring lua 	setopt curl 
checktype lua 	slist append curl 
settop 	easy setopt 
lua buffinit 	curl easy setopt 
lua dump 	curl easy 
lua error 	setopt run one 
lua pushresult 	slot curlinfo 
lua error 	strbuf extract 
lua 	content type strbuf 
error lua 	release curlinfo 
error lua 	strbuf curl slist 
lua error 	free strbuf 
lua tolower 	release strcmp skip 
isalpha iscntrl 	prefix die 
isdigit 	strlen strcmp strbuf 
islower ispunct 	reset strbuf 
isspace isupper 	http request update 
isalnum isxdigit 	url redirect 
islower match 	credential url strbuf 
uchar uchar 	reset die 
uchar 	credential fill http 
uchar match 	request http 
uchar matchbracketclass 	request reauth strbuf 
uchar lua 	addf fopen 
error singlematch 	error http request 
uchar match 	reauth fclose 
match 	finalize file 
singlematch uchar 	strbuf release quote 
lua error 	url http 
match capture 	strbuf strbuf rtrim 
close match 	oid hex 
check capture 	starts xstrdup strbuf 
size 	release free 
memcmp start 	sha hex end 
capture start 	url slash 
capture end 	strbuf addf sha 
capture matchbalance 	hex strbuf 
lua error 	detach strbuf addf 
lua 	sha pack 
lua classend 	index name strbuf 
matchbracketclass uchar 	detach http 
matchbracketclass uchar 	file error free 
isdigit uchar 	free pack 
match capture 	index parse pack 
uchar 	index sha 
classend singlematch 	pack index 
uchar match 	name fetch pack 
max expand 	index parse 
max expand 	pack index unlink 
min expand 	free verify 
memchr 	pack index close 
memcmp lua 	pack index 
pushlstring lua 	finalize file sha 
error lua 	pack index 
error lua 	name free end 
pushinteger lua 	url slash 
pushlstring 	strbuf addstr strbuf 
lua checkstack 	detach http 
push onecapture 	strbuf starts starts 
lua checklstring 	sha hex 
lua checklstring 	fetch setup pack 
posrelat lua 	index free 
optinteger 	fclose free free 
size lua 	close pack 
toboolean strpbrk 	index fclose 
lmemfind lua 	strip suffix die 
pushinteger lua 	xstrfmt run 
pushinteger match 	command unlink unlink 
lua 	free unlink 
pushinteger lua 	sha pack index 
pushinteger push 	name finalize 
captures push 	file sha pack 
captures lua 	name finalize 
pushnil str 	file sha pack 
find 	index name 
aux str 	free install packed 
find aux 	git free 
lua tolstring 	xcalloc end url 
lua upvalueindex 	slash strbuf 
lua tostring 	addf sha hex 
lua 	strbuf detach 
upvalueindex lua 	snprintf sha 
tointeger lua 	pack name fopen 
upvalueindex match 	error active 
lua pushinteger 	slot curl easy 
lua replace 	setopt curl 
lua 	easy setopt curl 
upvalueindex push 	easy setopt 
captures lua 	curl easy setopt 
checkstring lua 	ftello sha 
checkstring lua 	hex http opt 
settop lua 	request remainder 
pushinteger 	free free xwrite 
lua pushcclosure 	git inflate 
lua error 	git sha update 
lua lua 	sha hex 
lua tolstring 	xcalloc hashcpy sha 
lua addchar 	file name 
isdigit 	snprintf snprintf unlink 
uchar lua 	warn rename 
addchar lua 	unlink warn 
addlstring push 	error open strrchr 
onecapture lua 	mkdir open 
addvalue lua 	error strerror git 
type 	inflate init 
lua pushvalue 	git sha init 
push captures 	remote url 
lua call 	open xread fwrite 
push onecapture 	sha file 
lua gettable 	close unlink warn 
lua 	memset git 
toboolean lua 	inflate init git 
pop lua 	sha init 
pushlstring lua 	lseek ftruncate error 
isstring lua 	strerror active 
error lua 	slot curl easy 
lua 	setopt curl 
addvalue lua 	easy setopt curl 
checklstring lua 	easy setopt 
checkstring lua 	curl easy 
type lua 	setopt curl easy 
optint lua 	setopt http 
argcheck 	opt request remainder 
lua buffinit 	free free 
match lua 	close process http 
addchar lua 	request warning 
addlstring lua 	stat unlink warn 
pushresult lua 	git inflate 
pushinteger 	end git sha 
lua checklstring 	unlink warn 
lua addchar 	hashcmp unlink warn 
lua addchar 	finalize file 
lua addchar 	sha file name 
lua addlstring 	unlink warn 
lua 	release http request 
addlstring lua 	close free 
addchar lua 	release active slot 
addchar strchr 	curlauth digest 
size lua 	corresponding command 
error isdigit 	line option curl 
uchar 	included curlauth 
isdigit uchar 	use curlopt keypasswd 
isdigit uchar 	store slot 
isdigit uchar 	results read slot 
isdigit uchar 	reused run 
lua error 	callback appropriate fall 
strncpy 	back ones 
strlen strcpy 	note ever single 
lua gettop 	credentials given 
lua checklstring 	program run worry 
lua buffinit 	updating buffer 
lua addchar 	setting initial must 
lua 	free able 
addchar lua 	curlopt proxyauth curlauth 
argerror scanformat 	curl sockopt 
sprintf lua 	exists since 
checknumber addintlen 	curl supported older 
sprintf lua 	curl versions 
checknumber 	verify authenticity peer 
addintlen sprintf 	certificate name 
lua checknumber 	cert must match 
sprintf lua 	tried connect 
checknumber addquoted 	curl also examines 
lua checklstring 	variables fallback 
strchr 	need query order 
lua pushvalue 	decide whether 
lua addvalue 	prompt missing password 
sprintf lua 	init curl 
error lua 	proxy auth unlike 
lua lua 	many common 
addlstring 	environment variables historically 
strlen lua 	lowercase appears 
pushresult lua 	curl know implemented 
createtable lua 	uppercase variants 
pushliteral lua 	later corrected 
pushvalue lua 	take http proxy 
setmetatable 	lowercase also 
lua pop 	curl lowercase versions 
lua pushvalue 	historical quasi 
lua setfield 	standard take precedence 
lua pop 	curl wait 
lua lua 	slot open queue 
getfield 	full know 
lua setfield 	must something since 
createmetatable lstrlib 	added something 
roberto exp 	happen curl multi 
standard library 	timeout returns 
operations pattern 	pathologically timeout curl 
matching 	multi fdset 
see copyright 	returns file descriptors 
notice lua 	read see 
macro unsign 	commit message details 
character relative 	helpers modifying 
position negative 	creating see 
means 	failing http code 
back end 	curle turned 
empty interval 	failonerror keep server 
values overflow 	custom error 
number arguments 	response translate code 
pattern matching 	failure normally 
init 	curl already put 
source end 	reason phrase 
source total 	server curl errorstr 
number captures 	unfortunately without 
finished unfinished 	failonerror lost give 
look skip 	numeric status 
escapes 	code check extract 
skip matches 	content type 
ends balance 	parameter raw positioned 
counts maximum 	start potential 
expand item 	parameter whitespace already 
keeps trying 	removed name 
match 	name parameter 
maximum repetitions 	appended extract normalized 
didn match 	version content 
reduce repetition 	type spaces suppressed 
one repetition 	letters lowercased 
match failed 	trailing parameters note 
undo 	silently even 
capture close 	invalid whitespace example 
capture match 	text plain 
failed undo 	specifically forbidden rfc 
capture optimize 	text plain 
tail recursion 	reasonable output keeps 
start 	code simple 
capture position 	charset argument store 
capture end 	charset parameter 
capture balanced 	example text plain 
match frontier 	charset utf 
points next 	text plain utf 
match 	text plain 
capture results 	text plain 
match end 	max places must 
pattern match 	larger larger 
succeeded last 	smaller minimum http 
pattern check 	specification allows 
end 	see http tools 
pattern item 	ietf html 
points next 	rfc section accept 
optional match 	language header 
repetitions repetitions 	language preferred split 
repetitions minimum 	colon separated 
match 	preferred languages language 
empty everywhere 	tags collect 
avoids negative 	language tag skip 
search inside 	codeset modifier 
memchr cannot 	unnecessary parts write 
found already 	accept language 
correct 	header buf 
found level 	won freed compute 
whole match 	places free 
number pushed 	language tags last 
request special 	one accept 
characters plain 	language header indicates 
search 	user preferred 
start end 	languages examples language 
found empty 	language accept 
match least 	language language utf 
one position 	latin accept 
found skip 	language language utf 
esc 	accept language 
capture accumulated 	language utf accept 
result nil 	language language 
keep original 	http request targets 
text result 	update url 
accumulator non 	appropriate deduced redirects 
empty 	seen requesting 
match skip 	url starting 
number substitutions 	url asked parameter 
maximum size 	url asked 
formatted item 	curl access must 
len format 	begin got 
valid 	parameter url curl 
flags format 	reported ended 
specification maximum 	returns updated url 
size format 	otherwise basic 
specification accounts 	strategy compare asked 
plus 	find bits 
margin error 	specific request strip 
skip flags 	bits got 
skip width 	example http example 
digits skip 	foo git 
precision digits 	ask http example 
format 	foo git 
item store 	info refs might 
format store 	end https 
formatted item 	example foo 
skip addsize 	git info refs 
end precision 	would want 
formatted 	url become https 
keep original 	example foo 
skip addsize 	git note assumes 
end also 	sane redirect 
treat cases 	scheme entirely possible 
llh create 	example end 
metatable 	url even end 
dummy metatable 	info refs 
pop dummy 	simply punt much 
library index 	scheme unlikely 
metamethod pop 	represent real git 
metatable open 	repository means 
library 	likely abort anyway 
ltable.c dummynode 	insane redirect 
key key 	scheme keep error 
key key 	previous request 
nums narray 	may put 
twotoi key 	cruft output stream 
nums 	clear making 
nums ttlg 	next request know 
ause lim 	strbuf enough 
nums pnasize 	satisfy current callers 
totaluse ause 	downloads url 
size size 	stores result given 
lsize 	file previous 
nasize nhsize 	interrupted download detected 
oldasize oldhsize 	previous temporary 
nold old 	file still around 
nasize nsize 	download resumed 
nasize nums 	helpers fetching packs 
totaluse 	parse pack 
narray nhash 	index already issued 
key othern 	error message 
key key 	parse pack 
key key 	index already issued 
key key 	error message 
key 	data present previous 
luai numeq 	transfer attempt 
gnode memcpy 	resume left helpers 
hashmod ttype 	fetching objects 
hashnum nvalue 	loose could failed 
hashstr rawtsvalue 	due lazy 
hashboolean 	directory creation mkdir 
bvalue hashpointer 	last path 
pvalue hashpointer 	component previous temp 
gcvalue ttisnumber 	file present 
nvalue lua 	process already fetched 
number luai 	reset inflate 
numeq 	sha error reading 
cast num 	previous temp 
ttisnil arrayindex 	file also rewind 
mainposition lua 	beginning local 
rawequal obj 	file successfully 
key tval 	processed data previous 
ttype 	fetch attempt 
gkey iscollectable 	fetch data already 
gcvalue gkey 	http.h curl 
gcvalue cast 	result http code 
gnode gnext 	auth avail 
lua runerror 	http connectcode curl 
lua 	use curl 
findindex ttisnil 	result http code 
setnvalue cast 	finished results 
num setobj 	callback data data 
sizenode ttisnil 	next buf 
gval gnode 	posn ptr eltsize 
setobj 	nmemb strbuf 
key tval 	ptr eltsize nmemb 
gnode setobj 	strbuf ptr 
gval gnode 	eltsize nmemb strbuf 
lua arrayindex 	handle cmd 
ceillog ttisnil 	clientp slot 
sizenode 	slot slot results 
ttisnil gval 	data fill 
countint key 	remote url proactive 
tval lua 	auth git 
reallocvector setnilvalue 	curl ipresolve active 
cast ceillog 	requests http 
lua 	verbose http post 
runerror twoto 	buffer http 
lua newvector 	auth curl errorstr 
gnode gnext 	code result 
setnilvalue gkey 	buf url hex 
setnilvalue gval 	two digit 
cast 	prefix url hex 
gnode setarrayvector 	two digit 
setnodevector ttisnil 	prefix content type 
setobjt lua 	charset effective 
setnum lua 	url url url 
reallocvector twoto 	result options 
ttisnil 	url packs 
gval setobjt 	head url target 
lua key 	lst packfile 
tval gval 	tmpfile slot target 
lua freearray 	url preq 
twoto sizenode 	preq url tmpfile 
resize 	localfile curl 
numusearray numusehash 	result errorstr http 
countint computesizes 	code sha 
resize lua 	real sha stream 
lua link 	zret rename 
obj gco 	slot url sha 
cast 	freq freq 
cast setarrayvector 	freq freq detect 
setnodevector lua 	url version 
freearray sizenode 	multi transfer usable 
lua freearray 	implementation define 
lua free 	symbol accordingly 
ttisnil 	shouldn makefile user 
gkey mainposition 	via cflags 
ttisnil gval 	nothing nothing curlopt 
getfreepos rehash 	use ssl 
lua lua 	known curlopt ftp 
mainposition key 	ssl constants 
tval 	known curlftpssl curl 
gnext gnext 	request read 
gnext gnext 	write callbacks slot 
setnilvalue gval 	lifecycle functions 
gnext gnext 	run one slot 
gnext gkey 	completion blocking 
gkey 	manner similar curl 
lua barriert 	easy perform 
lua ttisnil 	would work want 
gval gval 	use want 
cast num 	intermingle calls curl 
hashnum ttisnumber 	multi curl 
gkey 	easy file 
luai numeq 	url ever use 
nvalue gkey 	one http 
gval gnext 	https url ftp 
hashstr ttisstring 	url helpers 
gkey rawtsvalue 	modifying creating options 
gkey 	http non 
gval gnext 	returns content type 
ttype lua 	response non 
getstr rawtsvalue 	content type non 
nvalue lua 	returns charset 
number luai 	parameter content type 
numeq 	none present 
cast num 	returns empty non 
nvalue lua 	returns url 
getnum mainposition 	ended including redirects 
lua rawequal 	followed url 
obj key 	effective url non 
tval 	url munged 
gval gnext 	reflect redirections 
lua cast 	going requested url 
ttisnil lua 	effective url 
runerror ttisnumber 	see definition update 
luai numisnan 	url redirect 
nvalue 	details values http 
lua runerror 	requests url 
newkey lua 	stores result strbuf 
getnum cast 	result pointer 
setnvalue cast 	http head request 
num newkey 	made instead 
lua 	helpers fetching packs 
getstr cast 	helpers fetching 
setsvalue newkey 	http ident.c git 
ttisnil lua 	name git 
getnum ttisnil 	email git date 
lua getnum 	email bogus 
ttisnil 	name bogus ident 
lua getnum 	use config 
ttisnil ttisnil 	committer ident 
unbound search 	explicitly given author 
mainposition ltable 	ident explicitly 
roberto exp 	given ident config 
lua 	given bogus 
tables hash 	fallback name src 
see copyright 	buf mailname 
notice lua 	mailnamebuf host status 
implementation tables 	hints bogus 
aka arrays 	buf email bogus 
objects 	email src 
hash tables 	len split line 
tables keep 	len span 
elements two 	status env hint 
parts part 	name email 
hash part 	date str flag 
non 	ident strict 
negative integer 	want date want 
keys candidates 	name name 
kept part 	email flag 
actual size 	flag user ident 
largest least 	explicitly given 
half 	data begin end 
slots use 	begin end 
hash uses 	len len min 
mix chained 	cmp cmp 
scatter table 	getpwuid getuid gecos 
brent variation 	strbuf addch 
main 	strbuf addch toupper 
invariant tables 	strbuf addstr 
element main 	fopen warning strerror 
position original 	strbuf getline 
position hash 	ferror warning strerror 
gives colliding 	strbuf release 
element 	fclose strbuf addbuf 
main position 	strbuf release 
hence even 	fclose memset 
load factor 	getaddrinfo strchr strbuf 
reaches performance 	addstr freeaddrinfo 
remains good 	gethostbyname strchr strbuf 
max 	addstr gethostname 
size part 	warning strerror strbuf 
maxbits types 	addstr strchr 
better avoid 	strbuf addstr canonical 
modulus power 	name strbuf 
tend many 	addf strbuf addstr 
factors 	strbuf addch 
number ints 	mailname host domainname 
inside lua 	copy gecos 
number key 	xgetpwuid self strbuf 
hash lua 	trim getenv 
numbers avoid 	strbuf addstr copy 
problems 	email xgetpwuid 
returns main 	self strbuf trim 
position element 	datestamp crud 
table index 	strlen crud 
hash returns 	strbuf grow memset 
index key 	isspace isspace 
key 	strspn isspace strspn 
appropriate key 	ident name 
live part 	fputs die die 
table otherwise 	fputs die 
key match 	xgetpwuid self ident 
condition returns 	email fputs 
index 	die die strbuf 
key table 	reset strbuf 
traversals first 	addstr without crud 
goes elements 	strbuf addstr 
part elements 	strbuf addstr without 
hash part 	crud strbuf 
beginning 	addch strbuf addch 
traversal signalled 	parse date 
first iteration 	die strbuf addstr 
key inside 	ident date 
part yes 	fmt ident 
index corrected 	getenv getenv fmt 
check 	ident getenv 
whether key 	getenv getenv getenv 
somewhere chain 	getenv fmt 
key may 	ident getenv getenv 
dead already 	getenv ident 
use next 	sufficient ident sufficient 
key 	strcmp git 
index hash 	config strcmp config 
table hash 	error nonbool 
elements numbered 	strbuf reset strbuf 
ones key 	addstr strcmp 
found avoid 	config error nonbool 
warnings 	strbuf reset 
find original 	strbuf addstr memcmp 
element first 	buf cmp 
part non 	buf cmp ident 
nil hash 	create git 
part non 	lines form 
nil 	name email date 
elements rehash 	copyright linus 
number elements 	torvalds traditionally gecos 
smaller number 	field office 
elements part 	phone numbers etc 
optimal size 	separated commas 
part 	also stands capitalized 
half elements 	form login 
present optimal 	name sorry donald 
size till 	success ipv 
elements smaller 	make fake email 
part elements 	address name 
already 	hostname domainname read 
counted key 	etc mailname 
appropriate index 	debian copy destination 
count summation 	avoid special 
nums count 	characters crud 
traverse keys 	end crud beginning 
slice 	crud end 
counter adjust 	copy rest buffer 
upper limit 	avoid special 
elements count 	characters act delimiters 
count elements 	identification line 
range total 	crud never len 
number 	maximum reverse 
elements summation 	fmt ident given 
nums elements 	ident line 
hash part 	split fields allow 
use common 	caller parse 
dummynode positions 	signal success returning 
free 	date fields 
save old 	result still input 
hash part 	line name 
must grow 	email part reading 
create hash 	reflog entry 
part appropriate 	human readable 
size 	name look end 
part must 	line find 
shrink insert 	trailing mail address 
elements vanishing 	even though 
slice shrink 	already know split 
insert elements 	mail end 
hash 	help cases broken 
part free 	idents extra 
old nums 	somewhere email address 
number keys 	note assuming 
reset counts 	timestamp never note 
count keys 	always find 
part 	going front always 
keys integer 	hit split 
keys count 	mail end closing 
keys hash 	bracket imap-send.c 
part count 	verbosity use curl 
extra key 	imap send 
compute 	usage imap 
size part 	send options buf 
resize table 	blen fmt 
computed sizes 	strp fmt len 
temporary values 	tmp name 
kept malloc 	tunnel host port 
fails 	folder user 
could find 	pass use ssl 
free place 	ssl verify 
inserts key 	use html auth 
hash table 	method server 
first check 	ssl sock bytes 
whether 	offset buf 
key main 	uidnext caps rcaps 
position free 	nexttag num 
check whether 	progress pending progress 
colliding node 	progress append 
main position 	buf name uidvalidity 
move 	imap prefix 
colliding node 	ctx cmd 
empty place 	prompt ctx cmd 
put key 	response ctx 
main position 	data dlen uid 
otherwise colliding 	next cmd 
node 	tag cap list 
main position 	ctx tcmd 
key goes 	func func sock 
empty position 	ret sslerr 
free place 	sock use tls 
cannot find 	verify host 
free 	pattern cert hostname 
place grow 	len subj 
table insert 	cname found num 
key grown 	subj alt 
table colliding 	names subj alt 
node main 	name sock 
position 	use tls 
yes move 	verify meth meth 
colliding node 	ctx ret 
free position 	cert sock buf 
find previous 	len sock 
redo chain 	buf len sock 
place 	start msg 
copy colliding 	msg ret buf 
node free 	blen fmt 
pos next 	ret ctx fmt 
also goes 	imap cmd 
free colliding 	bufl buf ctx 
node 	fmt cmdp 
main position 	ctx fmt cmdp 
node free 	level imap 
position chain 	cmd arg ctx 
position search 	imap arg 
function integers 	ctx tcmd imap 
key 	cmdp pcmdp 
key sizearray 	cmd arg 
check whether 	arg resp resp 
key somewhere 	tag ictx 
chain search 	imap ctx challenge 
function check 	user pass 
whether 	resp len encoded 
key somewhere 	len decoded 
chain main 	len hmac hash 
search function 	hex response 
index use 	response challenge challenge 
specialized version 	user pass 
check 	ctx cmd prompt 
whether key 	ret response 
somewhere chain 	srvc folder cred 
zero present 	ctx imap 
index find 	arg rsp preauth 
present overflow 	tunnel hints 
table 	gai portstr addr 
built bad 	addr msg 
purposes resort 	lastc ctx 
linear search 	msg imap prefix 
binary search 	box ret 
find boundary 	msg buf content 
table 	type pre 
boundary integer 	open pre close 
index non 	body msgs 
nil nil 	msgs count msgs 
nil boundary 	msg ofs 
part binary 	data len val 
search 	server msgs 
must find 	total msg ctx 
boundary hash 	ofs percent 
part hash 	srvc curl path 
part empty 	auth server 
easy ltable.h 	msgs total ofs 
key 	msgbuf curl 
key key 	res percent prev 
key key 	len argc 
key narray 	argv msgs 
lnhash nasize 	total nongit vsnprintf 
key key 	die die 
ltable 	xmemdupz err error 
roberto exp 	err error 
lua tables 	ssl error perror 
hash see 	ssl socket 
copyright notice 	perror perror strchr 
lua ltablib.c 	strcasecmp stack 
max 	ext general name 
pos pos 	num general 
lsep last 	name strlen host 
sep res 	matches general 
tab funcs 	name pop free 
aux getn 	subject name 
lua 	error name text 
checktype lua 	nid error 
pushvalue lua 	strlen host matches 
pushinteger lua 	error ssl 
rawgeti lua 	library init 
call 	ssl load error 
lua isnil 	method method 
lua pop 	ssl socket perror 
lua checktype 	ssl ctx 
lua checktype 	ssl ctx verify 
lua pushnil 	ssl ctx 
lua 	verify paths ssl 
next lua 	socket perror 
pushvalue lua 	ssl ssl socket 
pushvalue lua 	perror ssl 
pushvalue lua 	rfd ssl socket 
call lua 	perror ssl 
isnil 	wfd ssl socket 
lua pop 	perror ssl 
lua checktype 	tlsext host name 
lua pushnil 	warning ssl 
lua next 	connect socket 
lua pop 	perror ssl peer 
lua 	certificate error 
type lua 	verify hostname ssl 
tonumber lua 	read xread 
pushnumber lua 	socket perror close 
pushinteger aux 	close ssl 
getn lua 	write write full 
checktype 	socket perror 
lua setn 	close close ssl 
lua checkint 	shutdown ssl 
lua error 	free close close 
lua lua 	memmove socket 
pushvalue aux 	read puts start 
getn 	vprintf end 
lua gettop 	fflush start vfprintf 
lua checkint 	end isspace 
lua rawgeti 	strchr isspace start 
lua rawseti 	vsnprintf die 
lua error 	end xmalloc 
lua 	nfvasprintf memset cmd 
lua setn 	result nfsnprintf 
lua rawseti 	nfsnprintf cap starts 
aux getn 	socket write 
lua optint 	free free free 
lua setn 	cap socket 
lua 	write free socket 
rawgeti lua 	write free 
rawgeti lua 	free start issue 
rawseti lua 	imap cmd 
pushnil lua 	end cmd result 
rawseti lua 	start issue 
rawgeti 	imap cmd end 
lua isstring 	cmd result 
lua error 	isspace skip imap 
lua lua 	list isspace 
lua addvalue 	skip imap list 
lua optlstring 	next arg 
lua 	size strcmp 
checktype lua 	strchr next arg 
optint lua 	strcmp next 
opt lua 	arg atoi strcmp 
getn lua 	next arg 
buffinit addfield 	atoi strcmp parse 
lua 	capability strcmp 
addlstring addfield 	isspace strcmp next 
lua pushresult 	arg atoi 
lua rawseti 	next arg atoi 
lua rawseti 	buffer gets 
lua isnil 	next arg next 
lua 	arg strcmp 
pushvalue lua 	skip list skip 
pushvalue lua 	list skip 
pushvalue lua 	list strcmp strcmp 
call lua 	strcmp strcmp 
toboolean lua 	parse response code 
pop 	strcmp parse 
lua lessthan 	capability next 
lua rawgeti 	arg offsetof socket 
lua rawgeti 	write free 
sort comp 	cont socket write 
lua pop 	atoi next 
lua 	arg strcmp strcmp 
rawgeti lua 	starts parse 
rawgeti sort 	response code done 
comp lua 	free free 
pop lua 	free imap exec 
rawgeti sort 	socket shutdown 
comp 	free imap close 
lua pop 	server free 
lua rawgeti 	strlen xmalloc evp 
lua pushvalue 	decode block 
lua rawgeti 	die hmac init 
lua rawgeti 	strlen evp 
lua 	hmac update 
error lua 	hmac hmac ctx 
pop lua 	cleanup hexchar 
rawgeti lua 	hexchar xstrfmt strlen 
error lua 	xmallocz encoded 
pop lua 	size evp encode 
pop 	block die 
lua rawgeti 	die cram socket 
lua rawgeti 	write strlen 
auxsort aux 	strlen error free 
getn lua 	xcalloc xcalloc 
checkstack lua 	imap info argv 
isnoneornil 	push start 
lua checktype 	command die imap 
lua settop 	info snprintf 
auxsort lua 	memset imap info 
ltablib roberto 	getaddrinfo gai 
exp library 	strerror imap info 
table 	socket getnameinfo 
manipulation see 	imap info 
copyright notice 	connect close perror 
lua function 	freeaddrinfo memset 
argument argument 	htons imap info 
nil result 	gethostbyname perror 
first 	imap info socket 
key function 	imap info 
key result 	inet ntoa ntohs 
first key 	connect close 
first empty 	perror fputs dup 
element insert 	ssl socket 
element 	connect close imap 
called arguments 	info buffer 
insert element 	gets next arg 
end argument 	next arg 
position grow 	strcmp strcmp parse 
necessary move 	response code 
elements 	imap exec cap 
size pos 	imap exec 
position outside 	ssl socket 
bounds nothing 	connect imap exec 
result pos 	imap info 
pos pos 	xstrdup xstrdup xstrdup 
nil 	xstrdup credential 
last interval 	fill xstrdup xstrdup 
empty quicksort 	cap strcmp 
algorithms modula 	cap memset imap 
robert sedgewick 	exec imap 
addison wesley 	warn imap exec 
function 	credential approve 
compensate function 	credential clear imap 
compensate function 	exec imap 
tail recursion 	exec imap info 
sort elements 	credential reject 
swap elements 	credential clear imap 
elements 	close store 
pivot need 	xmallocz strbuf attach 
sort invariant 	crlf memset 
repeat repeat 	strbuf detach 
pop pivot 	strcmp imap exec 
swap pivot 	strstr strbuf 
adjust 	strbuf addstr strbuf 
smaller half 	addch strbuf 
larger one 	addstr strbuf addstr 
call recursively 	xml quoted 
smaller one 	strbuf addstr strbuf 
repeat routine 	release feof 
larger 	strbuf fread ferror 
one smaller 	starts strstr 
argument make 	strstr strstr strstr 
sure two 	starts strchr 
arguments ltm.c 	strstr strbuf git 
lua typenames 	config git 
lua 	config git config 
eventname events 	git config 
ename lua 	git die config 
lua fix 	starts starts 
lua getstr 	starts xstrdup 
lua ttisnil 	git config git 
cast 	config git 
ttype hvalue 	config git config 
uvalue ttype 	git config 
lua getstr 	imap open store 
ltm roberto 	split msg 
exp tag 	wrap html imap 
methods 	store msg 
see copyright 	imap close store 
notice lua 	curl init 
order never 	die curl easy 
collect names 	init die 
function used 	curl easy setopt 
macro 	curl easy 
fasttm optimized 	setopt strbuf addstr 
absence tag 	strbuf addch 
methods tag 	strbuf addstr 
method cache 	curl easy setopt 
fact ltm.h 	strbuf release 
lua 	curl easy setopt 
typenames events 	warning strbuf 
ename ltm 	addstr strbuf addstr 
roberto exp 	curl easy 
tag methods 	setopt strbuf release 
see copyright 	curl easy 
notice 	setopt curl easy 
lua warning 	setopt curl 
change order 	easy setopt curl 
enumeration grep 	easy setopt 
order last 	curl easy setopt 
tag method 	getenv curl 
fast 	easy setopt setup 
access number 	curl curl 
elements lua.c 	easy setopt split 
progname pname 	msg wrap 
msg status 	html crlf 
msg narg 	curl easy setopt 
clear 	curl curl 
status argv 	easy perform curl 
narg argc 	easy strerror 
name status 	curl easy cleanup 
name status 	curl cleanup 
name firstline 	git extract argv 
status 	path git 
lmsg msg 	setup gettext setup 
firstline buffer 	git directory 
prmt status 	gently git imap 
status oldprogname 	config parse 
argv status 	options usage options 
fname 	warning warning 
narg argv 	read message count 
argv chunk 	messages append 
filename init 	msgs imap curl 
argc argv 	append msgs 
status argv 	imap append 
script 	msgs imap git 
argc argv 	imap send 
status lua 	drops patches imap 
sethook lua 	drafts folder 
error signal 	derived isync mbsync 
lua sethook 	mailbox synchronizer 
lua 	copyright michael elkins 
lua lua 	mutt copyright 
fflush fflush 	oswald buddenhagen ossi 
lua isnil 	users net 
lua tostring 	copyright theodore tytso 
message lua 	mit edu 
pop 	copyright mike cormack 
lua isstring 	program free 
lua getfield 	software redistribute modify 
lua istable 	terms gnu 
lua pop 	general license published 
lua getfield 	free software 
lua 	foundation either 
isfunction lua 	version license option 
pop lua 	later version 
pushvalue lua 	program distributed hope 
pushinteger lua 	useful without 
call lua 	warranty without even 
gettop 	implied warranty 
lua pushcfunction 	merchantability fitness particular 
lua insert 	purpose see 
signal lua 	gnu general license 
pcall signal 	details received 
lua lua 	copy gnu general 
message 	license along 
lua checkstack 	program write free 
lua pushstring 	software foundation 
lua createtable 	inc temple place 
lua pushstring 	suite boston 
lua rawseti 	usa available 
lua 	option strictly opt 
loadfile docall 	name tunnel 
report lua 	host port folder 
loadbuffer strlen 	user pass 
docall report 	use ssl ssl 
lua getglobal 	verify use 
lua 	html auth method 
pushstring report 	responses capability 
docall lua 	results command queue 
getfield lua 	big put 
tostring lua 	last currently open 
pop lua 	mailbox foreign 
tolstring 	maybe preset dns 
strstr lua 	subject alt 
lua pop 	names common name 
prompt lua 	sni rfc 
readline strlen 	open ssl document 
lua pushfstring 	function implementation 
lua 	returns success 
pushstring lua 	failure calling lerr 
freeline lua 	make sure 
settop pushline 	hostname matches certificate 
lua loadbuffer 	simple line 
lua tostring 	buffering make sure 
lua 	enough data 
strlen incomplete 	read sequence shift 
pushline lua 	used bytes 
pushliteral lua 	terminate next line 
insert lua 	reached sublist 
concat lua 	quoted atom response 
saveline 	code rfc 
lua loadline 	says messages must 
docall report 	displayed user 
lua gettop 	rfc response personal 
lua getglobal 	mailboxes others 
lua insert 	mailboxes shared mailboxes 
lua 	unhandled response 
pcall lua 	data least 
gettop message 	two words ignore 
lua pushfstring 	needswork previously 
lua lua 	handled num exists 
tostring lua 	num recent 
settop 	probably unintended side 
fputs fflush 	effect ignores 
getargs lua 	unrecognized two word 
setglobal strcmp 	responses imap 
strcmp lua 	send doesn ever 
loadfile lua 	read messages 
insert 	mailboxes days consider 
docall lua 	eliminating happen 
pop report 	last command underway 
notail notail 	enforces round 
notail lua 	trip strcmp bad 
lua dostring 	arg reached 
lua 	hexchar cram functions 
dolibrary getenv 	code isync 
dofile dostring 	project http 
lua touserdata 	isync net length 
lua lua 	challenge encoded 
openlibs lua 	good enough upper 
handle 	bound challenge 
luainit collectargs 	decoded result response 
print usage 	user digest 
print version 	hex open connection 
runargs handle 	imap server 
script dotty 	ipv read greeting 
lua 	capabilities may 
stdin tty 	changed capabilities cram 
print version 	preauth check 
dotty dofile 	target mailbox exists 
lua open 	insert characters 
message lua 	necessary msg ensure 
cpcall 	every character 
report lua 	msg preceded 
close lua 	first pass tally 
roberto exp 	size need 
lua stand 	added second pass 
alone interpreter 	write note 
see 	loop otherwise identical 
copyright notice 	first pass 
lua unused 	store msg imap 
arg another 	also detach 
sigint happens 	free data msg 
lstop terminate 	data leaving 
process 	msg data empty 
action message 	headers body 
keep intact 	wrapping needed copy 
pass error 	next message 
message skip 	msgs starting offset 
function traceback 	ofs msg 
call 	update ofs start 
debug traceback 	following message 
function index 	iff message 
push traceback 	successfully copied read 
function put 	messages write 
chunk args 	imap server index-pack.c 
traceback 	index pack 
function force 	usage idx size 
complete garbage 	hdr size 
collection errors 	type real type 
count total 	delta depth 
number arguments 	child obj data 
number 	size first 
arguments script 	last ofs first 
input line 	ofs last 
ends newline 	cache cache used 
first line 	pack offset 
starts change 	obj sha obj 
input 	objects obj 
repeat gets 	stat ofs deltas 
complete line 	deltas nothread 
cannot lines 	data objects 
input line 	ofs deltas deltas 
two lines 	deltas alloc 
line 	resolved deltas threads 
result print 	stdin strict 
clear stack 	fsck fsck options 
collect arguments 	verbose show 
stdin check 	stat check self 
argument extra 	contained connected 
characters 	progress input buffer 
end option 	input offset 
option invalid 	input len consumed 
option option 	bytes deepest 
stop file 	delta input ctx 
fails status 	input crc 
stop 	input output curr 
collector initialization 	pack data 
open libraries 	dispatched threads active 
invalid args 	read mutex 
executes stdin 	counter mutex 
file create 	work mutex deepest 
state 	delta mutex 
lua.h panicf 	type cas mutex 
idx idx 	key mutex 
idx idx 	mutex obj type 
idx idx 	data options 
idx idx 	obj size type 
idx 	max foreign 
idx idx 	min ret bytes 
idx idx 	pack name 
idx idx 	tmp file hdr 
idx idx 	offset format 
idx idx 	offset format buf 
idx 	data retain 
len idx 	data delta type 
idx idx 	unpack entry 
idx idx 	data obj ofs 
fmt argp 	offset sha 
fmt idx 	sha size 
idx 	offset shift data 
idx idx 	obj consume 
narr nrec 	data len data 
objindex idx 	inbuf stream 
idx idx 	status obj compare 
idx idx 	ofs delta 
objindex 	bases find ofs 
idx nargs 	delta find 
nresults nargs 	ofs delta children 
nresults errfunc 	compare delta 
func reader 	bases find delta 
chunkname writer 	find delta 
data 	children entry buf 
nresults narg 	buf size 
data idx 	buf size data 
level funcindex 	data len 
funcindex func 	entry data 
mask count 	size sha obj 
name 	delta delta 
namewhat source 	alloc raw delta 
currentline nups 	obj result 
linedefined lastlinedefined 	data delta data 
src lua 	compare swap 
roberto exp 	type prev child 
lua 	result child 
extensible extension 	result prev delta 
language lua 	delta delta 
puc rio 	delta obj obj 
brazil http 	data sha 
www 	delays ofs delta 
lua see 	delta sha 
copyright notice 	obj data obj 
end file 	ret obj 
mark precompiled 	fix thin pack 
code esc 	curr pack 
lua 	pack sha 
option multiple 	read sha tail 
returns lua 	sha msg 
pcall lua 	unresolved objects initial 
call pseudo 	size stream 
indices status 	status outbuf append 
functions 	obj pack 
read write 	sorted pos obj 
blocks loading 	pack name 
dumping lua 	curr pack name 
chunks prototype 	index name 
memory allocation 	curr index name 
functions 	keep name 
basic types 	keep msg sha 
minimum lua 	report name 
stack available 	err keep keep 
function extra 	msg len 
include file 	buf len opts 
type 	opts idx 
numbers lua 	idx opts 
type integer 	pack name stat 
functions state 	baseobjects chain 
manipulation basic 	histogram obj bobj 
stack manipulation 	argc argv 
access 	prefix stat curr 
functions stack 	index pack 
push functions 	name keep msg 
stack functions 	keep name 
lua stack 	buf idx objects 
functions stack 	opts pack 
lua 	sha foreign arg 
load call 	end hdr 
functions load 	len len pthread 
run lua 	mutex pthread 
code coroutine 	mutex unlock init 
functions garbage 	recursive mutex 
collection 	pthread mutex init 
function options 	pthread mutex 
miscellaneous functions 	init pthread 
useful macros 	mutex init pthread 
compatibility macros 	mutex init 
functions hack 	pthread key create 
debug 	xcalloc open 
api codes 	die errno pthread 
masks activation 	mutex destroy 
record functions 	pthread mutex destroy 
called debuger 	pthread mutex 
specific events 	destroy pthread mutex 
local 	destroy pthread 
field method 	mutex destroy close 
lua main 	pthread key 
tail number 	free die oid 
upvalues part 	hex sha 
active function 	info die oid 
copyright 	hex die 
lua puc 	oid hex 
rio rights 	max index check 
reserved permission 	indexed write 
hereby granted 	die git sha 
free charge 	update memmove 
person 	die flush xread 
obtaining copy 	die die 
software associated 	errno display throughput 
documentation files 	die crc 
software deal 	overflows die odb 
software without 	mkstemp xstrdup 
restriction 	open die errno 
including without 	open die 
limitation rights 	errno git sha 
use copy 	init fill 
modify merge 	htonl die pack 
publish distribute 	version die 
sublicense 	ntohl ntohl use 
sell copies 	start vsnprintf 
software permit 	end die 
persons software 	pthread getspecific pthread 
furnished subject 	setspecific xcalloc 
following conditions 	free data data 
copyright 	free data 
notice permission 	data data prune 
notice shall 	data data 
included copies 	free data crc 
substantial portions 	fill use 
software software 	fill use hashcpy 
provided 	fill use 
without warranty 	fill use msb 
kind express 	bad fill 
implied including 	use bad bad 
limited warranties 	unpack entry 
merchantability fitness 	data xmallocz xmalloc 
particular 	memset git 
purpose noninfringement 	inflate init xpread 
shall authors 	data die 
copyright holders 	errno die 
liable claim 	git inflate git 
damages liability 	inflate consume 
whether 	free free die 
action contract 	git inflate 
tort otherwise 	end free free 
arising connection 	unpack data 
software use 	free xmalloc read 
dealings software 	istream die 
luac.c 	sha hex die 
listing dumping 	sha hex 
stripping output 	memcmp die sha 
output progname 	hex memset 
message message 	open istream die 
argc argv 	sha hex 
version 	unpack data close 
size argc 	istream free 
argv argc 	delta type alloc 
argv filename 	grow data 
argc argv 	pack data 
exit strerror 	prune data data 
exit 	data pack 
lua exit 	patch delta free 
usage lua 	bad data 
usage exit 	prune data free 
toproto lua 	deepest delta 
newproto setptvalue 	deepest delta unlock 
incr 	data pack 
top lua 	data patch delta 
newliteral lua 	free bad 
newvector lua 	hash sha file 
newvector toproto 	sha counter 
create create 	counter unlock find 
abc 	delta children 
create abc 	find ofs delta 
unused fwrite 	children free 
lua touserdata 	link data 
lua checkstack 	alloc data compare 
fatal lua 	swap type 
loadfile 	die resolve delta 
fatal lua 	free data 
tostring combine 	alloc data resolve 
lua print 	delta free 
fopen cannot 	data unlink data 
lua lua 	find unresolved 
dump 	deltas free hashcmp 
lua unlock 	alloc data 
ferror cannot 	find unresolved deltas 
fclose cannot 	data counter 
doargs usage 	display progress counter 
lua open 	unlock work 
fatal 	delta type work 
lua cpcall 	unlock work 
fatal lua 	unlock resolve start 
tostring lua 	progress unpack 
close luac 	raw entry 
lhf exp 	alloc grow hashcpy 
lua 	sha free 
compiler saves 	display progress stop 
bytecodes files 	progress flush 
also list 	git sha hashcmp 
bytecodes see 	fill die 
copyright notice 	use fstat die 
lua 	errno isreg 
program name 	lseek die sha 
output file 	die qsort 
list bytecodes 	qsort start progress 
dump bytecodes 	getenv init 
strip debug 	pthread create die 
information 	strerror pthread 
output file 	cleanup delta type 
name actual 	resolve display 
output file 	progress stop progress 
name actual 	flush die 
program name 	realloc memset 
end 	sha fix unresolved 
options keep 	deltas strbuf 
end options 	addf stop progress 
skip end 	msg strbuf 
options use 	release sha close 
stdin list 	hashcpy fixup 
output 	pack header footer 
file parse 	hashcmp die 
strip debug 	die git deflate 
information show 	init git 
version unknown 	deflate sha write 
option luaconf.h 	die git 
luaconf 	deflate end alloc 
roberto exp 	qsort alloc 
configuration file 	data read sha 
lua see 	file check 
copyright notice 	sha signature die 
lua search 	sha hex 
find 	append obj 
configurable definitions 	pack find unresolved 
lua ansi 	deltas display 
controls use 	progress free close 
non ansi 	fsync die 
features change 	close die errno 
define 	strlen odb 
want lua 	pack keep open 
avoid use 	die errno 
non ansi 	write die write 
feature library 	die close 
needs extra 	die errno snprintf 
library 	directory sha 
ldl needs 	hex finalize file 
extra libraries 	die chmod 
need extra 	snprintf directory sha 
library lua 	hex finalize 
use posix 	file die chmod 
includes 	sha hex 
functionallity listed 	snprintf sha 
open system 	hex write die 
interfaces extension 	xwrite strcmp 
xsi change 	git config die 
define system 	strcmp git 
xsi 	config die warning 
compatible lua 	git config 
path lua 	ntohl check pack 
cpath names 	index ptr 
environment variables 	alloc grow ntohl 
lua check 	qsort packed 
paths 	git strlen die 
lua init 	open pack 
name environment 	index die read 
variable lua 	anomalous offsets 
checks initialization 	close pack index 
code change 	free xcalloc 
want 	delta type 
different names 	sha hex delta 
lua path 	type sha 
path lua 	hex putchar strcmp 
uses look 	usage reset 
lua libraries 	pack idx option 
lua 	git config 
cpath path 	chdir die strcmp 
lua uses 	strcmp strcmp 
look libraries 	skip prefix fsck 
change machine 	msg types 
non conventional 	strcmp strcmp strcmp 
directory 	strcmp strcmp 
hierarchy want 	starts starts strtoul 
install libraries 	usage warning 
non conventional 	starts htonl htonl 
directories windows 	strtoul die 
exclamation mark 	htonl strtoul die 
path 	strcmp strcmp 
replaced path 	usage starts 
directory executable 	strtoul die strtoul 
file current 	die usage 
process lua 	usage usage die 
dirsep directory 	strip suffix 
separator 	die strbuf strbuf 
submodules change 	addstr strip 
machine use 	suffix die strbuf 
directory separator 	strbuf addstr 
windows windows 	die read idx 
lua automatically 	option online 
uses 	cpus open pack 
lua pathsep 	file parse 
character separates 	pack header xcalloc 
templates path 	xcalloc xcalloc 
lua path 	parse pack objects 
mark marks 	resolve deltas 
substitution 	conclude pack free 
points lua 	free check 
execdir windows 	objects show 
path replaced 	pack info alloc 
executable directory 	write idx 
lua igmark 	file free close 
mark 	free strbuf 
ignore bulding 	release strbuf release 
luaopen function 	free free 
name change 	always read chunks 
reason system 	mutex conditional 
cannot use 	variable statically initialized 
characters 	windows content 
one characters 	linked must must 
common character 	already present 
file directory 	database discard current 
names probably 	buffer used 
need change 	content make sure 
lua 	least min 
integer integral 	bytes available buffer 
type used 	pointer buffer 
lua pushinteger 	make sure 
lua tointeger 	sufficiently large wrap 
change ptrdiff 	header consistency 
adequate 	check inflated first 
machine machines 	encountered need 
ptrdiff gives 	free memory buf 
good choice 	deleted caller 
lua api 	function part find 
mark core 	unresolved deltas 
api 	two walkers going 
functions lualib 	opposite ways 
api mark 	first one find 
standard library 	unresolved deltas 
functions change 	traverses parent node 
need define 	children deflating 
functions 	nodes along way 
special way 	however memory 
instance want 	deflated nodes 
create one 	limited delta cache 
windows dll 	limit point 
core libraries 	parent node deflated 
may 	content may 
want use 	freed second walker 
following definition 	function goes 
define lua 	current node top 
build dll 	parent necessary 
often libs 	deflate node normal 
together 	situation parent 
core luai 	node would already 
func mark 	deflated needs 
functions exported 	apply delta worst 
outside modules 	scenario parent 
luai data 	node longer deflated 
mark 	running delta 
variables exported 	cache limit need 
outside modules 	deflate parents 
change need 	possibly top 
mark special 	deflated objects subject 
way elf 	freed exceed 
gcc 	delta cache limit 
versions later 	like find 
mark hidden 	unresolved deltas need 
optimize access 	make sure 
lua compiled 	last node freed 
shared library 	standard compare 
empty 	swap atomically check 
lua describes 	whether type 
error messages 	want swap otherwise 
quote program 	untouched first 
elements change 	pass find locations 
want different 	objects calculate 
appearance 	sha non delta 
lua idsize 	objects remember 
gives maximum 	sha offset deltas 
size description 	large blobs 
source function 	check later 
debug information 	check pack integrity 
change 	input file 
want different 	reached end second 
size stand 	pass non 
alone configuration 	delta objects look 
lua stdin 	used deltas 
tty detects 	used uncompress apply 
whether 	deltas recursively 
standard input 	checking resulting used 
tty whether 	deltas sort 
running lua 	deltas sha offset 
interactively change 	fast searching 
better definition 	third pass append 
non 	objects convert 
posix non 	thin pack full 
windows systems 	pack required 
stdin tty 	write sha flush 
lua prompt 	remaining pack 
prompt used 	sha since 
stand 	many unresolved deltas 
alone lua 	may well 
lua prompt 	objects unresolved deltas 
continuation prompt 	really want 
used stand 	include smallest number 
alone lua 	objects would 
change 	cover much delta 
want different 	possible picking 
prompts also 	trunc deltas first 
change prompts 	allowing deltas 
dynamically assigning 	resolve without additional 
globals prompt 	objects since 
prompt 	objects found deltas 
lua progname 	depending good 
name stand 	heuristic start resolving 
alone lua 	deltas order 
program change 	position pack 
stand alone 	mimic git unpack 
interpreter 	objects write 
different name 	last part input 
system able 	buffer stdout 
detect name 	address offset table 
automatically lua 	header fan 
maxinput maximum 	sha table crc 
length 	table address 
input line 	offset table real 
stand alone 	offset ntohl 
interpreter change 	idx high octets 
need longer 	ntohl idx 
lines lua 	low octets idx 
readline 	zero read 
defines show 	attributes existing idx 
prompt read 	file rid 
line standard 	idx file need 
input lua 	anymore needswork 
saveline defines 	extract bit 
save 	free pack name 
read line 	sha file 
history lua 	perhaps shouldn matter 
freeline defines 	much know 
free line 	haven installed pack 
read lua 	hence never 
readline 	read anything zero 
change want 	good bad 
improve functionality 	experiment showed threads 
gnu readline 	mean faster 
history facilities 	caller know pack 
non empty 	self contained 
line 	inet ntopc src 
history show 	dst size 
prompt line 	fmt nprinted src 
luai gcpause 	dst size 
defines pause 	len words src 
garbage collector 	dst size 
cycles 	snprintf strlcpy 
percentage change 	memset inet ntop 
want run 	strlen snprintf 
faster slower 	size strlcpy inet 
higher values 	ntop inet 
mean larger 	ntop copyright internet 
pauses 	software consortium 
mean slower 	permission use copy 
collection also 	modify distribute 
change dynamically 	software purpose without 
wait memory 	fee hereby 
next luai 	granted provided copyright 
gcmul 	notice permission 
defines speed 	notice appear copies 
garbage collection 	software provided 
relative memory 	internet software consortium 
allocation percentage 	disclaims warranties 
change 	regard software including 
want change 	implied warranties 
granularity garbage 	merchantability fitness 
collection higher 	shall internet software 
values mean 	consortium liable 
coarser collections 	special direct indirect 
represents 	consequential damages 
infinity step 	damages whatsoever resulting 
performs full 	loss use 
collection also 	data profits whether 
change dynamically 	action contract 
runs twice 	negligence tortious action 
speed 	arising connection 
memory allocation 	use performance software 
lua compat 	warning even 
getn controls 	consider trying compile 
compatibility old 	system fine 
getn behavior 	world vax inet 
change 	ntop src 
define want 	dst size format 
exact compatibility 	address dst 
behavior setn 	notes uses 
getn lua 	statics takes addr 
lua compat 	input author 
loadlib 	paul vixie errno 
controls compatibility 	snprintf inet 
loadlib change 	ntop src dst 
undefined soon 	size convert 
need loadlib 	binary address presentation 
function function 	printable format 
still 	author paul vixie 
available loadlib 	note need 
lua compat 	least large enough 
vararg controls 	contain specified 
compatibility old 	size systems like 
vararg feature 	crays thing 
change 	integer variable bits 
undefined soon 	keep mind 
programs use 	think function 
access vararg 	coded use pointer 
parameters instead 	overlays world 
old arg 	vax preprocess copy 
table 	input bytewise 
lua compat 	wordwise find longest 
mod controls 	run src 
compatibility old 	shorthanding format result 
math mod 	inside best 
function change 	run following initial 
undefined 	run real 
soon programs 	hex address encapsulated 
use math 	trailing run 
fmod instead 	check overflow copy 
math mod 	done inet 
lua compat 	ntop src dst 
lstr 	size convert 
controls compatibility 	network format address 
old nesting 	presentation format 
facility change 	pointer presentation 
want old 	format address dst 
behaviour undefine 	see errno 
turn 	author paul vixie 
advisory error 	notreached inet 
nesting lua 	ptonc src dst 
compat gfind 	src dst 
controls compatibility 	src dst digits 
old gfind 	saw digit 
name 	octets tmp pch 
change undefined 	src dst 
soon rename 	xdigits tmp endp 
gfind gmatch 	colonp xdigits 
lua compat 	curtok saw xdigit 
openlib controls 	val pch 
compatibility 	src dst strchr 
old lua 	memcpy memset 
openlib behavior 	strchr strchr inet 
change undefined 	pton memcpy 
soon replace 	inet pton 
lua uses 	inet pton copyright 
lua 	internet software 
openlib luai 	consortium permission use 
apicheck macro 	copy modify 
used lua 	distribute software purpose 
api change 	without fee 
luai apicheck 	hereby granted provided 
want 	copyright notice 
lua perform 	permission notice appear 
checks parameters 	copies software 
gets api 	provided internet software 
calls may 	consortium disclaims 
slow interpreter 	warranties regard software 
bit 	including implied 
may quite 	warranties merchantability fitness 
useful debugging 	shall internet 
code interfaces 	software consortium liable 
lua useful 	special direct 
redefinition use 	indirect consequential 
luai 	damages damages whatsoever 
bitsint defines 	resulting loss 
number bits 	use data profits 
change lua 	whether action 
cannot automatically 	contract negligence tortious 
detect number 	action arising 
bits 	connection use performance 
machine probably 	software warning 
need change 	even consider trying 
avoid overflows 	compile system 
comparison least 	fine world vax 
bits luai 	inet pton 
integer 	src dst like 
least bits 	inet aton 
luai integer 	without hexadecimal shorthand 
least bits 	src valid 
luai umem 	dotted quad 
integer big 	notice touch dst 
enough 	unless returning 
count total 	author paul vixie 
memory used 	inet pton 
lua luai 	src dst convert 
mem integer 	presentation level 
big enough 	address network order 
count 	binary form 
total memory 	src valid rfc 
used lua 	address notice 
change weird 	touch dst unless 
reason definitions 	returning full 
good enough 	address silently ignored 
machine 	credit inspired 
definitions part 	mark andrews author 
always works 	paul vixie 
may waste 	leading requires special 
space machines 	handling seen 
bit longs 	inet pton 
probably 	since memmove erroneously 
need change 	fail handle 
bit ints 	overlapping regions shift 
luai maxcalls 	hand isc 
limits number 	net pton src 
nested calls 	dst convert 
change 	presentation format usually 
need really 	means ascii 
deep recursive 	printable network format 
calls limit 	usually kind 
arbitrary purpose 	binary format address 
stop infinite 	valid specified 
recursion 	address family address 
exhausting memory 	wasn valid 
luai maxcstack 	dst untouched error 
limits number 	occurred dst 
lua stack 	untouched author paul 
slots function 	vixie notreached 
use 	init-db.c init 
change need 	bare repository init 
lots lua 	shared repository 
stack space 	init dir git 
functions limit 	link path 
arbitrary purpose 	dir path baselen 
stop 	baselen git 
functions consume 	exists subdir lnk 
unlimited stack 	dir path 
space must 	path len dir 
smaller lua 	free git 
registryindex change 	dir work path 
smaller 	buf path 
values following 	repo version junk 
definitions system 	reinit filemode 
small stack 	work path baselen 
may want 	git dir 
change larger 	real git dir 
values 	exist git 
system large 	dir src 
stack limits 	dir flags reinit 
rigid constants 	git dir 
control size 	buf len git 
stack allocated 	dir slash 
arrays 	cwd cwd git 
used compiler 	dir opt 
interpreter others 	arg unset init 
limit maximum 	usage argc 
number recursive 	argv prefix git 
calls compiler 	dir real 
interpreter 	git dir work 
perform values 	dir flags 
large may 	init options mkdir 
cause stack 	tried saved 
overflow forms 	cwd git dir 
deep constructs 	parent rel 
luai 	safe create 
maxccalls maximum 	dir readdir strbuf 
depth nested 	setlen strbuf 
calls syntactical 	setlen strbuf addstr 
nested non 	strbuf addstr 
terminals program 	lstat die errno 
luai 	lstat die 
maxvars maximum 	errno isdir opendir 
number local 	die errno 
variables per 	strbuf addch strbuf 
function must 	addch copy 
smaller luai 	templates closedir islnk 
maxupvalues 	strbuf readlink 
maximum number 	die errno symlink 
upvalues per 	die errno 
function must 	strbuf release isreg 
smaller lual 	copy file 
buffersize buffer 	die errno error 
size 	getenv system 
used lauxlib 	path free 
buffer system 	strbuf addstr strbuf 
lua number 	complete opendir 
type numbers 	warning strbuf addstr 
lua change 	git config 
following 	file strbuf setlen 
definitions want 	warning strbuf 
build lua 	addstr git dir 
number type 	strbuf complete 
different may 	copy templates closedir 
also need 	free strbuf 
change 	release strbuf release 
lua number 	strcmp git 
lua number 	config pathname strcmp 
integer luai 	strcmp skip 
uacnumber result 	prefix strcmp safe 
usual argument 	create dir 
conversion 	git path buf 
number lua 	safe create 
number scan 	dir git 
format reading 	path buf safe 
numbers lua 	create dir 
number fmt 	git path buf 
format 	git config 
writing numbers 	copy templates git 
lua number 	config adjust 
str converts 	shared perm git 
number luai 	dir adjust 
maxnumber str 	shared perm git 
maximum 	path buf 
size previous 	adjust shared perm 
conversion lua 	git path 
str number 	buf adjust shared 
converts number 	perm git 
digits sign 	path buf git 
point 	path buf 
luai num 	access readlink create 
macros define 	symref exit 
primitive operations 	xsnprintf git 
numbers lua 	config git path 
number macro 	buf lstat 
convert 	chmod lstat chmod 
lua number 	git config 
lua number 	bare repository git 
integer macro 	config git 
convert lua 	work git config 
number lua 	git config 
integer 	needs work config 
change know 	git dir 
faster way 	git config git 
convert lua 	path buf 
number rounding 	close xmkstemp unlink 
method without 	symlink lstat 
throwing 	islnk unlink git 
errors system 	config git 
pentium machines 	path buf access 
naive typecast 	git config 
extremely slow 	probe utf 
alternative worth 	pathname composition strbuf 
trying 	release strbuf 
pentium resort 	addstr directory safe 
trick microsoft 	create dir 
compiler use 	strbuf setlen strbuf 
assembler next 	addstr safe 
trick work 	create dir strbuf 
pentium 	setlen strbuf 
sometimes clashes 	addstr safe create 
direct idiosyncrasy 	dir strbuf 
option always 	release stat die 
works may 	stat die 
slow luai 	xstrdup real path 
user 	git dir 
alignment type 	real path git 
requires maximum 	dir real 
alignment change 	path stat 
system requires 	isreg read gitfile 
alignments larger 	isdir die 
instance 	rename die errno 
system supports 	write file 
doubles must 	git dir separate 
aligned boundaries 	git dir 
probably need 	safe create dir 
change luai 	bare repository 
luai 	check repository format 
define lua 	create files 
handling change 	create directory xsnprintf 
prefer use 	xsnprintf xsnprintf 
longjmp setjmp 	die git config 
even want 	git config 
use 	strlen strcmp xgetcwd 
longjmp setjmp 	strcmp free 
instead regular 	strcmp strrchr strcmp 
longjmp setjmp 	git config 
lua handles 	perm parse 
errors exceptions 	options absolute path 
compiling 	xstrdup real 
code longjmp 	path chdir safe 
setjmp asked 	create leading 
use longjmp 	directories die errno 
setjmp otherwise 	mkdir die 
exceptions dummy 	errno die errno 
variable 	usage xgetcwd 
unix longjmp 	setenv free getenv 
setjmp efficient 	getenv die 
handling jumps 	guess repository type 
lua maxcaptures 	strrchr xstrndup 
maximum number 	xstrdup real path 
captures 	free xgetcwd 
pattern pattern 	git work git 
matching change 	work access 
need captures 	git work die 
limit arbitrary 	errno git 
lua tmpnam 	work git 
function 	work git dir 
library uses 	init init 
create temporary 	git information manager 
name lua 	hell copyright 
tmpnambufsize maximum 	linus torvalds note 
size name 	git hooks 
created 	file exists repository 
lua tmpnam 	initialized etc 
change alternative 	core git templates 
tmpnam considered 	hooks update 
insecure want 	would cause git 
original tmpnam 	init fail 
anyway 	think sane means 
lua uses 	templates ship 
tmpnam posix 	along way git 
available uses 	organized really 
mkstemp lua 	carefully chosen make 
popen spawns 	sure correct 
process 	vintage git 
connected current 	dir directly inside 
one file 	working git 
streams change 	find need worktree 
way implement 	explicitly create 
system lua 	git refs heads 
define 	tags look 
library system 	init templatedir first 
lua use 	copy templates 
change lua 	might config file 
problems choosing 	would want 
appropriate library 	read installing reading 
system 	existing config 
platform either 	may overwrote would 
windows dll 	created user 
mac dyld 	umask shared repository 
unix dlopen 	settings would 
system kind 	need fix 
unix 	create symlink git 
good chance 	head master 
dlopen lua 	branch exist yet 
dlopen work 	forces creation 
use dlopen 	config file check 
also need 	filemode trustability 
adapt 	allow config file 
src makefile 	check symlink 
probably adding 	supported work good 
ldl linker 	check filesystem 
options lua 	insensitive make sure 
automatically change 	symlinks resolved 
makefile 	moving target repo 
ldl must 	later separate 
also dlua 	git dir check 
use dlopen 	see repository 
want kind 	version right note 
library undefine 	newly created 
options 	repository config 
win gets 	file fail catching 
lua dll 	attempt reinitialize 
mac gets 	repository old tool 
lua dyld 	spell configuration 
luai extraspace 	read older version 
allows 	git note 
user specific 	use octal numbers 
data lua 	share modes 
state data 	compatibility values perm 
goes lua 	perm everybody 
state pointer 	force mode translators 
change 	first either 
define really 	reinitialized existing initialized 
need must 	empty second 
multiple maximum 	shared last verbatim 
alignment required 	directory name 
machine luai 	git dir git 
userstate 	init always 
allow user 	bare git 
specific actions 	dir pwd git 
threads change 	init git 
defined luai 	dir git git 
extraspace need 	dir something 
something 	git usually otherwise 
extra created 	often bare 
deleted resumed 	point guessing want 
yielded lua 	share area 
intfrmlen length 	number branches advantages 
modifier integer 	save space 
conversions 	sharing sha objects 
format lua 	hand might 
intfrm integer 	make lookup slower 
type correspoding 	messier judge 
previous length 	one per managed 
modifier change 	directory point 
system 	haven read configuration 
supports support 	know shared 
local configuration 	repository always 
use space 	play safe fallthru 
redefinitions without 	git work 
modifying main 	makes sense conjunction 
part 	git dir 
file lualib.h 	without bare error 
lualib roberto 	early git 
exp lua 	directory contents interpret-trailers.c 
standard libraries 	git interpret 
see copyright 	trailers usage argc 
notice 	argv prefix 
lua key 	place trim empty 
file handle 	trailers options 
type open 	parse options process 
previous libraries 	trailers die 
lua bitc 	process trailers list 
idx 	clear builtin 
hexdigits buf 	git interpret 
bit funcs 	trailers copyright christian 
msg lua 	couder chriscool 
tonumber lua 	tuxfamily khash.h hash 
checknumber bits 	upper mit 
lua 	license copyright attractive 
isnumber lua 	chaos attractor 
typerror barg 	live permission hereby 
barg lua 	granted free 
isnone barg 	charge person obtaining 
lua 	copy software 
pushlstring lua 	associated documentation files 
pushnumber barg 	software deal 
lua error 	software without restriction 
lua lua 	including without 
newlib lua 	limitation rights use 
bit 	copy modify 
bit operations 	merge publish distribute 
library lua 	sublicense sell 
http bitop 	copies software 
luajit copyright 	permit persons software 
mike pall 	furnished subject 
rights 	following conditions copyright 
reserved permission 	notice permission 
hereby granted 	notice shall included 
free charge 	copies substantial 
person obtaining 	portions software software 
copy software 	provided without 
associated 	warranty kind express 
documentation files 	implied including 
software deal 	limited warranties merchantability 
software without 	fitness particular 
restriction including 	purpose noninfringement shall 
without limitation 	authors copyright 
rights 	holders liable claim 
use copy 	damages liability 
modify merge 	whether action contract 
publish distribute 	tort otherwise 
sublicense sell 	arising connection 
copies software 	software use dealings 
permit 	software function 
persons software 	uses buckets bytes 
furnished subject 	working space 
following conditions 	instead key val 
copyright notice 	buckets requested 
permission notice 	size small hash 
shall 	table size 
included copies 	changed shrink expand 
substantial portions 	rehash expand 
software software 	otherwise shrink rehashing 
provided without 	needed kick 
warranty kind 	process sort like 
express 	cuckoo hashing 
implied including 	kick existing element 
limited warranties 	mark deleted 
merchantability fitness 	old hash table 
particular purpose 	write element 
noninfringement shall 	jump loop 
authors 	shrink hash table 
copyright holders 	free working 
liable claim 	space update hash 
damages liability 	table clear 
whether action 	deleted elements expand 
contract tort 	hash table 
otherwise 	todo implement automatically 
arising connection 	shrinking resize 
software use 	already support shrinking 
dealings software 	speed present 
mit license 	deleted touch keys 
http www 	present deleted 
opensource 	convenient macros function 
licenses mit 	test whether 
license php 	bucket contains data 
msvc stuck 	param pointer 
last century 	hash table khash 
doesn stdint 	name param 
convert 	iterator bucket 
argument bit 	khint containing data 
type bit 	otherwise function 
type right 	key given iterator 
shifts implementation 	param pointer 
defined per 	hash table khash 
facto 	name param 
standard arithmetic 	iterator bucket khint 
right shifts 	key type 
two complement 	keys function given 
behaviour required 	iterator param 
test perform 	pointer hash table 
simple 	khash name 
self test 	param iterator bucket 
lua cjsonc 	khint type 
json token 	values discussion hash 
type name 	sets calling 
escape cfg 	results segfault 
args 	function val function 
optindex setting 	start iterator 
min max 	param pointer hash 
errmsg optindex 	table khash 
setting options 	name start iterator 
options cfg 	khint function 
cfg 	end iterator param 
cfg cfg 	pointer hash 
cfg old 	table khash name 
setting options 	end iterator 
cfg cfg 	khint function number 
cfg cfg 	elements hash 
cfg 	table param pointer 
json lindex 	hash table 
reason json 	khash name number 
lindex escstr 	elements hash 
str len 	table khint function 
cfg json 	number buckets 
max 	hash table 
items cfg 	param pointer hash 
current depth 	table khash 
json cfg 	name number buckets 
current depth 	hash table 
json cfg 	khint function iterate 
current 	entries hash 
depth json 	table param pointer 
length comma 	hash table 
cfg json 	khash name param 
lindex num 	kvar variable 
len cfg 	key assigned param 
current 	vvar variable 
depth json 	assigned param code 
comma keytype 	block code 
cfg current 	execute function iterate 
depth json 	values hash 
len cfg 	table param pointer 
local 	hash table 
encode buf 	khash name 
encode buf 	param vvar variable 
json len 	assigned param 
json token 	code block code 
hex hex 	execute khash 
digit 	kwset.c llink rlink 
utf codepoint 	trie label 
json utf 	balance accepting links 
codepoint surrogate 	parent next 
low len 	fail depth shift 
escape len 	maxshift obstack 
token 	words trie mind 
json errtype 	maxd delta 
json token 	next target mind 
escape json 	trans trans 
json token 	kwset kws text 
endptr json 	len kwset 
token 	trie label link 
token json 	depth links 
exp token 	last treefails 
found json 	treedelta hasevery treenext 
json slots 	kws kwset 
json token 	curr trans delta 
json 	fail last 
token json 	next kws text 
token json 	size kwset 
token json 	len kws text 
len reg 	len kwsmatch 
nup err 	kwset next trie 
reg 	accept beg 
func lua 	lim mch lmch 
touserdata lua 	delta end 
upvalueindex lua 	qlim trans kws 
error lua 	text size 
argcheck lua 	kwsmatch kwset ret 
gettop 	kws kwset 
lua gettop 	xmalloc obstack 
lua pushnil 	init obstack alloc 
json fetch 	kwsfree obstack 
config lua 	alloc obstack alloc 
isnil lua 	obstack free 
checkinteger 	abort abort abort 
snprintf lua 	enqueue enqueue 
argcheck lua 	memset obstack alloc 
pushinteger lua 	enqueue treedelta 
isnil lua 	treefails hasevery treenext 
isboolean lua 	memcpy memcpy 
toboolean 	memchr bmexec cwexec 
lua checkoption 	obstack free 
lua pushboolean 	free file copied 
lua pushstring 	commit gnu 
json arg 	grep git repository 
init json 	small changes 
option 	made adapt code 
json integer 	git kwset 
option json 	search keywords 
integer option 	copyright free software 
json arg 	foundation inc 
init json 	program free software 
integer 	redistribute modify 
option json 	terms gnu general 
arg init 	license published 
json integer 	free software foundation 
option json 	either version 
arg init 	option later version 
json 	program distributed 
integer option 	hope useful without 
json arg 	warranty without 
init json 	even implied warranty 
option strbuf 	merchantability fitness 
init strbuf 	particular purpose see 
free 	gnu general 
lua error 	license details received 
json arg 	copy gnu 
init json 	general license 
option json 	along program write 
verify invalid 	free software 
number 	foundation inc franklin 
setting json 	street fifth 
arg init 	floor boston usa 
json option 	written august 
json verify 	mike haertel author 
invalid number 	may reached 
setting 	email address mike 
lua touserdata 	mit edu 
strbuf free 	mail mike haertel 
lua newuserdata 	free software 
lua newtable 	foundation algorithm implemented 
lua pushcfunction 	routines bears 
lua 	startling resemblance one 
setfield lua 	discovered beate 
setmetatable strbuf 	commentz walter although 
init strbuf 	identical see 
free lua 	matching algorithm 
error lua 	fast average technical 
lua 	report ibm 
type lua 	germany scientific center 
tolstring strbuf 	heidelberg tiergartenstrasse 
ensure empty 	heidelberg germany see 
length strbuf 	also aho 
append strbuf 	corasick efficient matching 
append 	aid bibliographic 
strbuf append 	search cacm june 
strbuf append 	vol describes 
lua pushnil 	failure function used 
lua next 	balanced edges 
lua type 	labels leaving given 
lua 	trie node 
tonumber floor 	left link must 
lua pop 	first field 
lua pop 	right link 
json encode 	larger labels trie 
lua checkstack 	node pointed 
strbuf 	edge label edge 
free lua 	difference depths 
error strbuf 	subtrees node trie 
append strbuf 	representing reversed 
append lua 	keywords word index 
rawgeti json 	accepted word 
append 	zero edges leaving 
data lua 	node parent 
pop strbuf 	node list trie 
append lua 	nodes level 
tonumber isinf 	order aho corasick 
isnan json 	failure function 
encode 	depth node root 
isnan strbuf 	shift function 
append mem 	search failures max 
isinf isnan 	shift self 
strbuf append 	descendants structure 
mem strbuf 	returned opaquely caller 
ensure 	containing everything 
empty length 	obstack node allocation 
fpconv fmt 	number words 
strbuf empty 	trie trie minimum 
ptr strbuf 	depth accepting 
extend length 	node maximum depth 
strbuf 	node delta 
append lua 	table rapid search 
pushnil lua 	table children 
next strbuf 	root target one 
append lua 	used boyer 
type strbuf 	moore search one 
append 	character translation 
json append 	table allocate initialize 
number strbuf 	keyword returning 
append mem 	opaque pointer memory 
json append 	available upper 
strbuf append 	bound valid 
json 	bit exact bit 
encode json 	given contents 
append data 	keyword success error 
lua pop 	message otherwise 
strbuf append 	descend trie built 
lua type 	reversed keywords 
json 	character character installing 
append json 	nodes necessary 
append number 	descend outgoing links 
lua toboolean 	trie node 
strbuf append 	looking current character 
mem strbuf 	keeping track 
append 	path followed current 
mem json 	character doesn 
check encode 	outgoing link trie 
depth lua 	node build 
length json 	trie node install 
append json 	link current 
append 	trie node 
strbuf append 	install node parent 
mem lua 	back fixing 
touserdata strbuf 	balance flags rebalance 
append mem 	pointer rotations 
json encode 	necessary mark node 
json 	reached accepting 
fetch config 	encoding index number 
lua argcheck 	word keyword 
lua gettop 	far keep track 
strbuf init 	longest shortest 
strbuf reset 	keyword enqueue trie 
json 	nodes referenced 
append data 	given given queue 
strbuf lua 	compute aho 
pushlstring strbuf 	corasick failure function 
free hexdigit 	trie nodes 
decode hex 	referenced given given 
decode 	failure function 
hex codepoint 	parent well 
utf strbuf 	last resort failure 
append mem 	node find 
strbuf reset 	chain fails going 
json token 	back root 
error 	first node descendant 
json append 	current label 
unicode escape 	delta entries links 
json token 	given preexisting 
error json 	delta larger current 
token error 	depth every 
strbuf 	label compute vector 
append strbuf 	indexed character 
ensure strbuf 	code trie nodes 
strncasecmp strncasecmp 	referenced given 
fpconv strtod 	compute shift trie 
json token 	node well 
error 	delta table 
json token 	next cache given 
error json 	keyword initial 
next token 	values delta table 
json invalid 	changed later 
number json 	delta entry given 
token 	character smallest 
error json 	depth node outgoing 
next number 	edge labeled 
token strncmp 	character check use 
strncmp strncmp 	simple boyer 
json invalid 	moore algorithm instead 
number 	hairy commentz 
json next 	walter algorithm looking 
number token 	one extract 
json token 	trie build boyer 
error strbuf 	moore delta 
free lua 	boy easy compared 
error 	find minimal 
lua checkstack 	delta shift 
strbuf free 	might make backwards 
lua error 	match failed 
json decode 	traverse nodes trie 
descend lua 	level order 
newtable 	simultaneously computing delta 
json next 	table failure 
token json 	function shift function 
decode ascend 	enqueue immediate 
json parse 	descendants level order 
error lua 	queue update 
pushlstring 	delta table descendants 
json next 	node compute 
token json 	failure function descendants 
parse error 	node update 
json next 	shifts node current 
token json 	node chain 
process 	fails back root 
lua rawset 	current node 
json next 	outgoing edge 
token json 	fail doesn shift 
decode ascend 	fail larger 
json parse 	difference depths current 
error 	node accepting 
json next 	shift fail descendants 
token json 	larger difference 
decode descend 	depths traverse trie 
lua newtable 	level order 
json next 	fixing nodes whose 
token 	shift exceeds 
json decode 	inherited maxshift create 
ascend json 	vector indexed 
process lua 	character code outgoing 
rawseti json 	links root 
next token 	node fix things 
json 	translation table 
decode ascend 	fast boyer moore 
json parse 	search significance 
error json 	initial offset 
next token 	skip loop bug 
lua pushlstring 	initial offset 
lua 	happens characters left 
pushnumber lua 	search carefully 
pushboolean json 	avoid ever producing 
parse context 	bounds pointer 
json parse 	hairy multiple search 
context lua 	initialize copies 
pushlightuserdata 	look easy ways 
json parse 	given known 
error lua 	match find longest 
argcheck lua 	possible match 
gettop json 	anchored starting point 
fetch config 	nearly verbatim 
lua 	copy preceding main 
checklstring lua 	search loops 
error strbuf 	search given 
json next 	text match member 
token json 	given keyword 
process json 	pointer first character 
next 	matching substring 
token json 	match found foundlen 
parse error 	non store 
strbuf free 	referenced location length 
lua checkstack 	matching substring 
lua pushvalue 	similarly foundidx non 
lua 	store referenced 
pushcclosure lua 	location index number 
setfield lua 	particular keyword 
pop lua 	matched free components 
argcheck lua 	given keyword 
gettop lua 	kwset.h index offset 
pushvalue 	size kwsmatch 
lua upvalueindex 	file copied commit 
lua insert 	gnu grep 
lua pcall 	git repository 
lua pushnil 	small changes made 
lua insert 	adapt code 
lua 	git kwset header 
error fpconv 	declaring keyword 
init lua 	library copyright free 
newtable json 	software foundation 
create config 	inc program free 
lua setfuncs 	software redistribute 
lua 	modify terms gnu 
pushlightuserdata lua 	general license 
setfield lua 	published free software 
pushliteral lua 	foundation either 
setfield lua 	version option later 
pushliteral 	version program 
lua setfield 	distributed hope useful 
lua cjson 	without warranty 
lua pushcfunction 	without even implied 
lua setfield 	warranty merchantability 
lua getfield 	fitness particular 
lua 	purpose see gnu 
pushcclosure lua 	general license 
setfield lua 	details received copy 
cjson lua 	gnu general 
pushvalue lua 	license along program 
setglobal lua 	write free 
cjson 	software foundation inc 
safe lua 	franklin street 
cjson json 	fifth floor boston 
support lua 	usa written 
copyright mark 	august mike haertel 
pulford mark 	author may 
kyne 	reached email address 
permission hereby 	mike mit 
granted free 	edu mail mike 
charge person 	haertel free 
obtaining copy 	software foundation index 
software associated 	number matching 
documentation 	keyword offset 
files software 	submatch length submatch 
deal software 	opaque pointer 
without restriction 	newly allocated keyword 
including without 	enough memory 
limitation rights 	cannot obtained argument 
use 	non specifies 
copy modify 	table character translations 
merge publish 	applied pattern 
distribute sublicense 	search text incrementally 
sell copies 	extend keyword 
software permit 	include given success 
persons 	error message 
software furnished 	remember index number 
subject following 	keyword included 
conditions copyright 	keyword completely built 
notice permission 	prepare use 
notice shall 	success error 
included 	message search given 
copies substantial 	buffer member 
portions software 	keyword pointer leftmost 
software provided 	longest match 
without warranty 	found match found 
kind express 	foundlen non 
implied 	store length matching 
including limited 	substring integer 
warranties merchantability 	points similarly foundindex 
fitness particular 	non store 
purpose noninfringement 	index particular keyword 
shall authors 	found therein 
copyright 	deallocate given keyword 
holders liable 	associated storage 
claim damages 	levenshtein.c len row 
liability whether 	row row 
action contract 	dummy strlen alloc 
tort otherwise 	alloc alloc 
arising 	free free 
connection software 	free function damerau 
use dealings 	levenshtein algorithm 
software caveats 	calculate distance basically 
json values 	says many 
represented lightuserdata 	letters need swapped 
since 	substituted deleted 
lua tables 	added least idea 
cannot contain 	build distance 
nil compare 	matrix substrings avoid 
cjson invalid 	large space 
utf characters 	complexity last three 
detected 	rows kept 
passed untouched 	memory swaps higher 
required utf 	cost one 
error checking 	deletion plus one 
done outside 	insertion two 
library javascript 	rows would needed 
comments 	stage denotes 
part json 	length current 
spec currently 	substring distance calculated 
supported note 	row holds 
decoding slower 	current row row 
encoding lua 	previous row 
spends 	substring length row 
significant time 	row words 
managing tables 	start big loop 
parsing json 	row contains 
since difficult 	damerau levenshtein distance 
know sizes 	substring length 
ahead 	substring length big 
time workaround 	loop determine 
solaris platforms 	minimum cost paths 
missing isinf 	calculating costs 
decoding encode 	path ending characters 
buf allocated 	respectively given 
used 	last operation substitution 
encode keep 	swap deletion 
buffer encode 	insertion implementation 
temporary storage 	allows costs weighted 
configuration ensure 	wap substitution 
correct number 	insertion aka deletion 
arguments 	note algorithm 
provided pad 	calculates distance iff 
nil allow 	substitution swap 
functions simply 	deletion insertion levenshtein.h 
check arg 	swap penalty 
find whether 	substitution penalty insertion 
argument 	penalty deletion 
provided process 	penalty line-log.c extra 
integer options 	prealloc dst 
configuration functions 	src dst src 
process enumerated 	start end 
arguments configuration 	diff diff next 
function 	list path 
configures handling 	insertion point cmp 
extremely sparse 	list path 
arrays convert 	begin end 
convert extremely 	diff start count 
sparse arrays 	start count 
objects 	data parent target 
otherwise error 	cbdata xpp 
ratio always 	xecfg ecb diff 
allow sparse 	diff offset 
never allow 	src target parent 
sparse use 	diff touched 
ratio 	touched tmp tmp 
safe always 	revs commit 
use max 	found obj commit 
index safe 	spec mode 
configures maximum 	sha spec lines 
number nested 	line ends 
arrays 	size cur ends 
objects allowed 	data spec 
encoding configures 	lines line 
maximum number 	ends data line 
nested arrays 	commit prefix 
objects allowed 	args lines ends 
encoding 	data item 
configures number 	ranges name part 
precision converting 	range part 
doubles text 	full name spec 
configures json 	end anchor 
encoding buffer 	ret ret prev 
persistence 	src src 
init free 	cmp revs commit 
buffer setting 	range old 
changed create 	revs commit revs 
method clean 	commit ret 
strbuf decoding 	rev prefix args 
init 	commit range 
tag characters 	paths dst src 
error tokens 	range keep 
require processing 	deletions outq 
update characters 	range opt queue 
require processing 	commit parent 
inf 	line ends data 
ininity nan 	prefix first 
number lookup 	line ends data 
table parsing 	color reset 
escape characters 	begin end opt 
error unicode 	prefix rev 
parsing 	range lines lines 
required encoding 	ends pair 
json append 	diff opt prefix 
args lua 	reset frag 
state json 	meta old context 
strbuf lua 	start end 
stack 	start end cur 
index returns 	last rev 
nothing doesn 	range rev pair 
lua stack 	range diff 
worst len 	tmp diff 
unicode escapes 	file parent file 
buffer 	target pair 
reused constantly 	range rev queue 
small excess 	range changed 
pages won 	pairdiff pair rev 
hit anyway 	commit range 
gains speedup 	rev commit range 
find 	parent queue 
size top 	parent range changed 
lua stack 	rev commit 
pure elements 	range diffqueues cand 
table startkey 	parents nparents 
table key 	changed rev commit 
integer 	range changed 
must non 	commit list free 
integer key 	alloc grow 
encode excessively 	range grow free 
sparse arrays 	range init 
objects enabled 	memcpy range 
ensure 	release range grow 
enough slots 	range append 
free traverse 	qsort range check 
table key 	invariants range 
push potential 	grow range append 
error message 	range append 
unlike 	range init range 
decode key 	init range 
still stack 	release range release 
lua checkstack 	memset range 
called hence 	init range release 
extra slot 	diff free 
lua 	filepair line log 
error required 	data clear 
next check 	free strcmp search 
lua checkstack 	line log 
fails won 	data range 
cause crash 	append free xcalloc 
due 	range append 
extra stack 	range append range 
reserve slots 	append memset 
would still 	memset memset xdi 
improper use 	diff ranges 
api json 	overlap range append 
append 	range append 
args lua 	range append xmalloc 
state json 	diff ranges 
strbuf size 	init diff ranges 
passwd lua 	filter touched 
top stack 	range difference range 
prevent 	shift diff 
encoding invalid 	range range release 
numbers encode 	range release 
invalid numbers 	deref tag die 
handle nan 	die die 
separately since 	entry die 
platforms 	fill filespec diff 
may encode 	populate filespec 
nan encode 	die sha hex 
invalid numbers 	alloc alloc 
table startkey 	grow realloc skip 
table key 	range arg 
never 	die xstrndup prefix 
returns table 	path strlen 
key table 	alloc filespec fill 
key serialise 	blob sha 
lua data 	fill line ends 
json remaining 	search line 
types 	log data parse 
lua tfunction 	range arg 
lua tuserdata 	die die line 
lua tthread 	log data 
lua tlightuserdata 	insert free filespec 
cannot serialised 	free sort 
never 	merge range 
returns use 	xmalloc line log 
buffer reuse 	data init 
existing buffer 	range copy xstrdup 
decoding force 	line log 
lowercase convert 	data copy one 
ascii 	line log 
hex digit 	data copy one 
numeric digit 	strcmp xmalloc 
note returns 	line log data 
error invalid 	init xstrdup 
hex digits 	range range copy 
including 	lookup decoration 
converts unicode 	line log data 
codepoint utf 	merge free 
returns utf 	line log data 
length bytes 	line log 
utf xxxxxxx 	data copy decoration 
xxxxx 	lookup decoration 
xxxxxx xxxx 	free line 
xxxxxx xxxxxx 	log data decoration 
xxx xxxxxx 	lookup decoration 
xxxxxx xxxxxx 	range check invariants 
called index 	check single 
pointing 	commit parse lines 
beginning utf 	line range 
code escape 	argv push argv 
xxxx guaranteed 	detach parse 
exist remaining 	pathspec free memcpy 
hex characters 	diff queue 
may 	clear diff queue 
missing translate 	clear diff 
utf append 	file valid diff 
temporary token 	diff free 
must advance 	filepair strcmp diff 
index next 	diff free 
character 	filepair free 
processed returns 	diff file valid 
success error 	diff queue 
surrogate pairs 	clear diff sha 
require utf 	filter diffs 
bytes fetch 	paths diff might 
utf 	rename diffcore 
code unit 	std filter diffs 
utf surrogate 	paths move 
pairs take 	diff queue nth 
following form 	line nth 
yyyyyyyyyy high 	line fputs fputs 
bits 	putchar fwrite 
codepoint low 	fputs putchar fputs 
bits codepoint 	output prefix 
check surrogate 	output prefix diff 
pair high 	color diff 
low error 	color diff color 
surrogate 	diff color 
high ensure 	diff color 
next code 	diff color fill 
unicode escape 	line ends 
fetch next 	fill line ends 
codepoint error 	print line 
code 	print line print 
low surrogate 	line print 
calculate unicode 	line free free 
codepoint convert 	puts output 
codepoint utf 	prefix dump diff 
append bytes 	hacky one 
advance 	strcmp diff populate 
parse index 	filespec diff 
caller must 	populate filespec diff 
ensure next 	ranges init 
skip json 	collect diff die 
tmp temporary 	free xstrdup 
strbuf 	range init range 
used accumulate 	map across 
decoded json 	diff range 
tmp sized 	release range move 
handle json 	diff ranges 
containing premature 	release xmalloc diff 
end 	free filepair 
handle escapes 	free line log 
fetch escape 	data copy 
character translate 	process diff filepair 
escape code 	strcmp diff 
append tmp 	filepair dup memcpy 
skip 	free lookup 
append normal 	line range show 
character translated 	log dump 
single character 	diff hacky queue 
unicode escapes 	diffs process 
handled eat 	files line range 
quote 	commit list 
json numbers 	count alloc alloc 
take following 	alloc queue 
form json 	diffs process 
next number 	files line range 
token uses 	clear commit 
strtod 	line range commit 
allows forms 	list append 
numbers starting 	free free free 
infinity infinity 	diffqueues line 
hexadecimal numbers 	range clear commit 
numbers leading 	line range 
zeros 	free free free 
json invalid 	diffqueues lookup 
number detects 	line range process 
numbers may 	ranges ordinary 
pass strtod 	commit process ranges 
error checking 	merge commit 
allowed 	process ranges arbitrary 
strict json 	commit free 
json invalid 	rewrite parents either 
number may 	initialization would 
pass numbers 	fine dst 
cause strtod 	must uninitialized tack 
generate 	range end 
error reject 	could simply start 
numbers starting 	start types 
skip minus 	check ranges non 
sign exists 	empty sorted 
reject numbers 	non overlapping place 
starting 	pass sorting 
leading zeros 	merging ranges range 
hex leading 	establish invariants 
zero ordinary 	ranges user output 
number reject 	cursor range 
inf nan 	sets sets line 
pass 	numbers used 
numbers may 	merge searches meet 
still invalid 	common ancestor 
strtod skip 	also ranges 
processed number 	consolidated canonical form 
fills token 	overlapping adjacent 
pointer 	ranges merged empty 
json parse 	ranges removed 
temporary error 	cannot make ranges 
json ptr 	may change 
pointer error 	grow exhausted exhausted 
eat whitespace 	empty range 
store 	difference range sets 
location token 	pass interesting 
required throwing 	ranges target side 
errors unexpected 	diff removes 
tokens syntax 	ranges commit responsible 
errors advance 	exhausted note 
pointer 	takes ownership path 
error end 	happens caller 
found known 	needs handy debugging 
single character 	removing silences 
token advance 	unused function 
index process 	warning given diff 
characters 	interesting ranges 
triggered unknown 	determine hunks diff 
must use 	touch overlap 
strncmp match 	least one interesting 
front json 	ranges target 
json must 	adjust line counts 
lowercase 	account lines 
strict numbers 	added removed diff 
disabled either 	given diff 
allowed infinity 	interesting ranges map 
since longer 	ranges across 
following spec 	diff observe target 
decode 	commit takes 
invalid numbers 	blame target side 
enabled attempt 	ranges every 
process numbers 	pair ranges diff 
know invalid 	touched latter 
json inf 	parent side 
hex 	shrink fit elements 
required generate 	merge two 
appropriate token 	range sets across 
error otherwise 	files owned 
bad tokens 	pathspec stderr diff 
invalid number 	might rename 
token 	found creation diff 
starts isn 	queued diff 
recognised function 	queue two path 
call memory 	scan ahead 
allocated supported 	determine last diff 
temporary parser 	falls range 
json 	compute parent hunk 
tmp json 	headers know 
token exist 	diff correct line 
stack somewhere 	numbers hunks 
lua error 	suffices shift start 
jmp release 	end according 
stack 	line numbers 
note token 	first last hunk 
index display 	fall range 
starting slots 	output diff hunk 
required table 	range needswork 
key 	manually building diff 
handle empty 	right thing 
objects push 	log built diff 
key fetch 	pipeline unlike 
key handle 	functions destructively operates 
context slots 	range needswork 
required 	apply heuristics prevent 
table handle 	mismatches store 
empty arrays 	away diff later 
arr handle 	output tuck 
context lua 	ranges got input 
setting nil 	since commit 
table 	caused diff 
hence pointer 	needswork enough around 
lightuserdata used 	something interesting 
instead detect 	merges currently invocation 
unicode utf 	merge parent 
see rfc 	trashes previous one 
sec 	diff needswork 
cjson support 	tramples data structures 
simple data 	owned parent 
type hence 	take blame follow 
first character 	path history 
guaranteed ascii 	needswork leaking like 
worst 	sieve single 
still enough 	parent took blame 
detect whether 	candidates loop 
wrong encoding 	parents needswork evil 
use ensure 	merge detection 
temporary buffer 	stuff needswork leaking 
hold 	like sieve 
entire means 	line-log.h start 
longer need 	end alloc ranges 
length checks 	parent target 
since decoded 	range prealloc range 
must smaller 	range start 
entire 	end range start 
json ensure 	end range 
input left 	next path status 
initialisation compatibility 	ranges arg 
lua lua 	alloc arg args 
setfuncs used 	pair diff 
create 	rev prefix args 
module table 	rev rev 
functions json 	commit range start 
config first 	end lines 
upvalue code 	numbered starting ranges 
borrowed lua 	include start 
source 	exclude end ranges 
fill table 	ranges must 
given functions 	always disjoint 
copy upvalues 	sorted diff encoded 
top closure 	pre post 
upvalues upvalues 	image ranges files 
call 	differ pair 
target function 	ranges corresponds hunk 
mode supplied 	range includes 
args assumes 	start excludes end 
target function 	range must 
returns single 	begin end last 
non 	added range 
nil convert 	place pass sorting 
thrown errors 	merging ranges 
nil error 	range sort make 
message deliberately 	ranges disjoint 
error invalid 	linked list interesting 
arguments 	files associated 
pcall function 	ranges list must 
stored upvalue 	kept sorted 
since custom 	path simplicity 
error handler 	even though highly 
remaining errors 	redundant line 
memory 	log data owns 
related cjson 	path line 
module table 	log line-range.c spec 
initialise number 	nth line 
conversions cjson 	data lines begin 
module table 	ret term 
functions 	line num reg 
config data 	error regexp 
upvalue cjson 	match nline errbuf 
module name 	xecfg bol 
version fields 	eol buf xecfg 
cjson safe 	start regexp 
module 	reg error match 
table fix 	bol eol 
method cjson 	errbuf arg 
table cjson 	nth line data 
table cjson 	lines anchor 
safe table 	begin end path 
lua 	pattern term 
cmsgpackc ptr 	drv xecfg start 
len aux 	reg error 
test testp 	regexp errbuf bol 
target osize 	eol arg 
nsize buf 	nth line data 
buf 	lines anchor 
len newsize 	begin end path 
buf cursor 	tmp arg 
len buf 	strtol die strtol 
len hdr 	die nth 
hdrlen buf 	line regcomp regexec 
buf 	nth line 
enclen buf 	regfree regerror die 
enclen buf 	find func 
enclen buf 	isalpha regexec 
len buf 	regerror die match 
buf buf 	funcname xstrndup 
buf 	nth line userdiff 
level buf 	find path 
level buf 	xcalloc xdiff find 
level len 	func regcomp 
max stacktop 	regerror die find 
buf level 	funcname matching 
buf 	regexp die nth 
buf level 	line die 
nargs buf 	nth line nth 
len index 	line match 
len limit 	funcname regfree free 
offset len 	free parse 
cnt 	range funcname parse 
decode offset 	loc parse 
offset limit 	loc parse range 
offset argc 	funcname parse 
err total 	loc parse 
results cmds 	loc parse one 
lua 	item option 
getallocf local 	begin applicable relative 
realloc realloc 	range anchors 
realloc memcpy 	absolute anchors ignore 
realloc realloc 	parsing parse 
buf append 	loc called parsing 
buf 	begin must 
append memcpy 	negative number absolute 
memrevifle buf 	line relative 
append memcpy 	start range anchors 
memrevifle buf 	beginning file 
append buf 	represented parsing begin 
append 	must positive 
buf append 	line number immediately 
buf append 	following line 
lua tolstring 	computed allow something 
encode bytes 	mean starting 
lua toboolean 	something lines 
buf 	something lines ending 
append lua 	something could 
tonumber lua 	regexp form scan 
tointeger encode 	interested regex 
lua tonumber 	spec term regexp 
equivalent encode 	input human 
lua 	terms determine extent 
integer encode 	line matched 
lua objlen 	funcname line skip 
lua rawlen 	range arg 
encode lua 	input human terms 
pushnumber lua 	compensate numbering 
gettable 	line-range.h arg nth 
encode lua 	line data 
type lua 	lines anchor begin 
pushnil lua 	end path 
next lua 	arg parse one 
pop encode 	item begin 
map 	end option 
lua pushnil 	notional file data 
lua next 	consisting lines 
lua pushvalue 	lines nth line 
encode lua 	callback used 
type encode 	determine start line 
lua 	lno inside 
type lua 	data caller expected 
gettop lua 	already suitable 
pushnil lua 	map hand make 
next lua 	constant time 
pop lua 	lookup anchor line 
type 	relative range 
lua tonumber 	specifications anchored absolute 
equivalent lua 	ranges unaffected 
isinteger lua 	returns success error 
tointeger lua 	actual range 
settop lua 	stored begin 
settop 	end counting starts 
table encode 	error caller 
lua table 	show usage message 
encode lua 	scan past 
table map 	range argument could 
buf append 	parsed parse 
lua 	range arg help 
type encode 	caller determine 
lua encode 	start filename file 
lua encode 	syntax returns 
lua number 	pointer first character 
lua isinteger 	part argument 
encode 	obviously malformed line 
lua integer 	range line 
encode lua 	bufferc buf filename 
number encode 	buf buf 
lua table 	buf err buf 
encode lua 	buf pos 
lua 	buf buf 
pop lua 	buf end buf 
gettop lua 	size buf 
argerror buf 	nbytes buffer done 
lua pushvalue 	len buf 
encode lua 	nbytes buffer done 
type 	len fopen 
lua pushlstring 	fdopen tmpfile ferror 
buf free 	ferror fclose 
lua concat 	rewind ftell error 
lua newtable 	strerror fseek 
lua pushnumber 	error strerror ferror 
decode 	fgetc fgets 
lua type 	strlen feof strbuf 
lua settable 	fread feof 
lua newtable 	ferror fread fwrite 
decode lua 	ferror buffer 
type decode 	skip bytes feof 
lua 	ferror fread 
type lua 	licensed two 
settable cur 	clause bsd style 
need lua 	license see 
checkstack cur 	license details read 
need lua 	line without 
pushunsigned 	trailing newline error 
cur consume 	data exhausted 
cur need 	newline end file 
lua pushinteger 	fine line 
cur consume 	probably saner way 
cur need 	deal error 
lua 	line bufferh line 
pushunsigned cur 	buffer infile 
consume cur 	buf filename buf 
need lua 	buf buf 
pushinteger cur 	buf buf buf 
consume cur 	buf buf 
need 	buf len buf 
lua pushunsigned 	len buf 
cur consume 	len prepare 
cur need 	write returns number 
lua pushinteger 	bytes read 
cur consume 	necessarily written list-objects.c 
cur 	revs blob 
need lua 	show path name 
pushunsigned cur 	data obj 
consume cur 	pathlen revs sha 
need lua 	show path 
pushnumber lua 	name data revs 
pushinteger 	show name 
cur consume 	data obj desc 
lua pushnil 	entry baselen 
cur consume 	commit revs show 
lua pushboolean 	edge parents 
cur consume 	parent revs show 
lua 	edge list 
pushboolean cur 	commit obj 
consume cur 	commit revs revs 
need cur 	show commit 
need memcpy 	show data commit 
memrevifle lua 	pending obj 
pushnumber 	name path die 
cur consume 	strbuf addstr 
cur need 	show strbuf setlen 
cur need 	die parse 
lua pushlstring 	gently die oid 
cur consume 	hex strbuf 
cur 	addstr show strbuf 
need cur 	addch init 
need lua 	desc entry entry 
pushlstring cur 	interesting isdir 
consume cur 	process lookup isgitlink 
need cur 	process gitlink 
consume 	process blob lookup 
cur need 	blob strbuf 
lua pushlstring 	setlen free 
cur consume 	buffer mark uninteresting 
cur need 	show edge 
cur consume 	mark uninteresting show 
decode 	edge mark 
lua cur 	edge parents uninteresting 
need cur 	mark uninteresting 
consume decode 	show edge pending 
lua cur 	strbuf init 
need cur 	revision pending show 
consume 	commit show 
decode lua 	process process blob 
hash cur 	die oid 
need cur 	hex clear strbuf 
consume decode 	release processing 
lua hash 	gitlink entry currently 
lua 	nothing since 
pushunsigned cur 	recurse subproject could 
consume lua 	eventually flag 
pushinteger cur 	actually would 
consume cur 	involve subproject actually 
need lua 	see subproject 
pushlstring 	already added alternates 
cur consume 	list process 
cur consume 	commit tag gitlink 
decode lua 	points recursively 
cur consume 	however unclear whether 
decode lua 	really ever 
hash 	reason see superprojects 
lua checklstring 	subprojects unified 
lua error 	pool potentially resulting 
lua error 	totally humongous 
cur init 	pack avoiding whole 
decode lua 	point gitlinks 
type 	first place note 
lua error 	could follow 
lua error 	link whether necessarily 
lua pushinteger 	makes sense 
lua insert 	ever ever 
unpack full 	another issue nothing 
lua 	uninteresting boundary 
optinteger lua 	commit may parsed 
pop lua 	yet going 
gettop unpack 	show anyway list-objects.h 
full lua 	rev info 
checkinteger lua 	rev info ll-merge.c 
optinteger 	name description 
lua pop 	recursive next cmdline 
lua gettop 	drv unused 
unpack full 	result path orig 
lua gettop 	orig name 
lua pushvalue 	src name src 
lua 	name opts 
upvalueindex lua 	marker size stolen 
insert lua 	drv unused 
pcall lua 	result path 
gettop lua 	orig orig name 
pushnil lua 	src name 
insert 	src name opts 
lua newtable 	marker size 
lua pushcfunction 	xmp drv unused 
lua setfield 	result path 
lua pushliteral 	unused orig orig 
lua setfield 	name src 
lua 	name src name 
pushliteral lua 	opts marker 
setfield lua 	size merge drv 
pushliteral lua 	src path 
setfield lua 	len result path 
pushliteral lua 	orig orig 
setfield 	name src name 
luaopen create 	src name 
lua pushvalue 	opts marker size 
lua setglobal 	temp cmd 
luaopen cmsgpack 	dict path 
lua getfield 	args status user 
lua 	merge user 
pushcclosure lua 	merge tail merge 
setfield lua 	key name 
pushvalue lua 	namelen merge attr 
setglobal allows 	name path 
preprocessor directive 	check path strbuf 
max 	result buf 
nesting max 	path ancestor ancestor 
tables nesting 	label label 
check integer 	label opts check 
without loss 	opts driver 
precision size 	name marker size 
pointer 	driver path 
equal integer 	check marker size 
bits message 	warning buffer 
pack implementation 	binary buffer binary 
bindings lua 	buffer binary 
copyright salvatore 	binary merge 
sanfilippo 	memset xdl merge 
antirez gmail 	xdl merge 
http github 	xsnprintf xmkstemp write 
antirez lua 	full die 
cmsgpack message 	errno close quote 
pack specification 	buf die 
check 	create temp create 
following web 	temp create 
site http 	temp xsnprintf strbuf 
wiki msgpack 	expand run 
display msgpack 	command opt open 
format specification 	fstat xmallocz 
see 	read full free 
copyright notice 	close unlink 
end file 	warn strbuf release 
changelog feb 	strbuf release 
ver initial 	strcmp git config 
release feb 	parse config 
ver 	key strncmp 
tables encoding 	xcalloc xmemdupz strcmp 
improved feb 	git config 
ver minor 	strcmp error xstrdup 
bug fixing 	strcmp git 
feb ver 	config git config 
module 	initialize merge 
renamed lua 	attr attr attr 
cmsgpack lua 	unset strcmp 
msgpack apr 	size strcmp git 
ver lua 	attr git 
support minor 	attr git check 
bug 	attr renormalize 
fix apr 	buffer free strbuf 
ver multiple 	detach normalize 
pack unpack 	file normalize file 
lua allocator 	normalize file 
efficiency endian 	git path check 
conversion 	merge atoi 
use floats 	find merge 
doubles conversions 	driver find merge 
performed endian 	driver git 
independent fashion 	attr git check 
thing need 	attr atoi 
function 	low level way 
swaps binary 	core file 
arch little 	merge copyright junio 
endian left 	hamano built 
untouched otherwise 	low levels tentative 
reverse memory 	merge result 
bytes 	common ancestor merge 
arch little 	fallthru xtheirs 
endian given 	xours cleanly merged 
conceptual simplicity 	otherwise got 
lua build 	conflict use favor 
system prefer 	user defined 
check 	low level 
endianess runtime 	merge driver support 
performance difference 	merge merge 
acceptable big 	driver configuration items 
endian nothing 	interested anything 
buffer simple 	merge name variable 
implementation 	especially want 
buffers operation 	look variables merge 
supported creating 	summary merge 
empty buffers 	tool merge verbosity 
appending bytes 	find existing 
buffer uses 	one might processing 
preallocation 	merge name 
every realloc 	seeing merge name 
append behavior 	merge name 
old size 	driver specifies command 
size buf 	line command 
realloc 	line command line 
free cursor 	interpolated following 
simple data 	tokens given 
structure used 	shell temporary file 
parsing basically 	name merge 
create cursor 	temporary file name 
pointer 	version temporary 
length possible 	file name branches 
access current 	version conflict 
position cursor 	marker length original 
check remaining 	path safely 
length cursor 	quoted shell external 
left 	merge driver 
consume cur 	write results file 
consume cursor 	named signal 
len advance 	done zero exit 
subtract left 	status way 
additional field 	ll-merge.h xdl opts 
cursor 	result buf 
error zero 	path ancestor ancestor 
initialization used 	label label 
report errors 	label opts 
enough data 	path low level 
complete operation 	way core 
bad 	file merge favor 
data format 	favor merge 
enough room 	lockfile.c path path 
error cursor 	depth link 
common across 	path flags filename 
code macro 	path flags 
make 	timeout multiplier remaining 
code look 	random initialized 
bit simpler 	backoff wait path 
low level 	err buf 
encoding fix 	path err buf 
raw ieee 	path flags 
format 	timeout ret result 
single precision 	path save 
floats ieee 	errno strbuf setlen 
ieee positive 	strbuf readlink 
fixnum negative 	absolute path 
fixnum fix 	strbuf reset trim 
fix 	last path 
map map 	component strbuf addbuf 
map lua 	strbuf reset 
types encoding 	strbuf addstr resolve 
lua built 	symlink strbuf 
bit integer 	addstr create tempfile 
type 	strbuf release 
lua lower 	file srand getpid 
bit doubles 	file rand 
need detect 	sleep millisec strbuf 
may representable 	addf absolute 
lua convert 	path strerror strbuf 
lua 	addf absolute 
table message 	path strerror unable 
pack list 	message die 
convert lua 	file timeout 
table message 	unable die strbuf 
pack key 	addstr tempfile 
map 	path strcmp die 
first step 	strbuf setlen 
count keys 	strbuf detach locked 
table way 	file path 
lua api 	commit file free 
need iterate 	free copyright 
first 	junio hamano path 
time note 	absolute relative 
alternative would 	path name last 
single run 	path name 
hack buffer 	element path leaving 
insert map 	preceding path 
opcodes 	empty root directory 
message pack 	path empty 
hackish lib 	back past trailing 
keep key 	slashes backwards 
next iteration 	slash beginning 
step two 	allow recursive symbolic 
actually 	links within 
encoding map 	reason though path 
stack key 	contains path 
stack key 	might symlink path 
key encode 	symlink attempt 
key encode 	overwrite path real 
val 	file directory 
returns lua 	may may exist 
table top 	following chain 
stack exclusively 	symlinks necessary otherwise 
composed keys 	path unmodified 
numerical keys 	best effort routine 
total 	error occurs 
number elements 	path either left 
without hole 	unmodified name 
middle stack 	different symlink symlink 
top function 	chain started 
entry stack 	original path 
key 	absolute path simply 
stack key 	replaces link 
check valid 	relative path replace 
comparing indexes 	last element 
total number 	make sure errno 
elements count 	contains meaningful 
also 	error constants defining 
max index 	gaps attempts 
encountered max 	file first backoff 
reach code 	period approximately 
indexes also 	initial backoff milliseconds 
note repeated 	longest backoff 
keys 	period approximately backoff 
table max 	max multiplier 
count sure 	initial backoff milliseconds 
keys form 	locking path 
count included 	retrying quadratic backoff 
length returns 	least timeout 
non 	milliseconds timeout 
zero least 	locking file exactly 
key serialize 	timeout indefinitely 
message pack 	success failure held 
list otherwise 	failure due 
use map 	timeout back backoff 
limit 	backoff recursion 
encoding nested 	meaningful errno failure 
tables specified 	lockfile.h tempfile 
maximum depth 	path flags timeout 
survive called 	path flags 
circular references 	path err buf 
tables 	path err 
packs arguments 	mode path hold 
stream multiple 	file update 
upacking later 	timeout fdopen tempfile 
returns error 	tempfile path 
arguments provided 	tempfile tempfile 
copy 	close tempfile reopen 
argument top 	tempfile rename 
stack encode 	tempfile tempfile file 
processing encode 	write locks 
function pops 	used git lockfile 
stack complete 	api serves 
reuse 	two purposes mutual 
buffer next 	exclusion atomic 
operation setting 	file updates want 
free count 	change file 
total buffer 	create lockfile filename 
size current 	write file 
position 	contents rename lockfile 
zero concatenate 	destination filename 
nargs buffers 	create filename file 
together decoding 	creat excl 
key decode 	notice fail somebody 
message pack 	already locked 
raw 	file atomically 
pointed cursor 	rename lockfile destination 
lua type 	commit changes 
left result 	unlock file automatic 
stack elements 	cruft removal 
must resize 	program exits file 
stack 	changes committed 
fit values 	want make sure 
way determine 	lockfile done 
many objects 	remembering lockfiles created 
msgpack unpack 	linked list 
front request 	setting atexit handler 
larger 	signal handler 
stack iteration 	clean lockfiles mechanism 
stack big 	ensures outstanding 
enough stack 	lockfiles cleaned program 
require resize 	exits including 
doubles size 	die called program 
nil 	terminated signal 
raw raw 	please note 
raw map 	lockfiles block writers 
map types 	readers block 
idenitified first 	guaranteed see either 
positive fixnum 	old contents 
negative 	file contents file 
fixnum fix 	assuming filesystem 
raw fix 	rename atomically heavy 
map fix 	lifting done 
map number 	tempfile module see 
objects unpacked 	tempfile calling 
match 	sequence caller allocates 
exits requesting 	file either 
negative lim 	variable heap initialized 
invalid loop 	zeros use 
decode could 	structure call hold 
stream multiple 	file family 
top 	functions belongs lockfile 
level values 	subsystem storage 
serialized together 	must remain 
left remaining 	valid throughout life 
size input 	program cannot 
buffer subtract 	use stack variable 
entire 	hold structure 
buffer size 	attempts create lockfile 
unprocessed size 	calling hold 
next start 	file update writes 
offset offset 	content destination 
processed entire 	file either writing 
buffer 	file descriptor 
results returned 	returned hold file 
arg elements 	functions also 
still place 	available via calling 
lua takes 	fdopen file 
care returning 	file pointer open 
elements 	file writing 
args one 	file stdio finished 
arg stack 	writing caller 
function insert 	close file 
first position 	descriptor rename lockfile 
increase count 	destination calling 
one 	commit file commit 
make room 	file close 
offset variable 	file descriptor lockfile 
pop offset 	calling rollback 
may exist 	file close file 
variable pop 	descriptor without 
offset 	removing renaming lockfile 
may exist 	calling close 
adds function 	file later call 
bottom stack 	commit file 
call function 	commit file rollback 
position manually 	file reopen 
construct 	file even lockfile 
module table 	committed rolled 
instead relying 	back file 
newlib metadata 	must freed altered 
name globally 	caller however 
wrap functions 	may reused pass 
safe 	another call 
handler name 	hold file update 
globally copyright 	program exits 
salvatore sanfilippo 	commit file commit 
rights reserved 	file rollback 
permission hereby 	file called tempfile 
granted 	module close 
free charge 	lockfile thereby rolling 
person obtaining 	back uncommitted 
copy software 	changes need close 
associated documentation 	file descriptor 
files software 	obtained hold file 
deal 	function calling 
software without 	close file see 
restriction including 	tempfile information 
without limitation 	covers lockfile 
rights use 	tempfile helper functions 
copy modify 	particular state 
merge 	diagram cleanup machinery 
publish distribute 	implemented tempfile 
sublicense sell 	module error handling 
copies software 	hold file 
permit persons 	functions file descriptor 
software furnished 	success failure 
subject 	unless die error 
following conditions 	used see 
copyright notice 	flags errors errno 
permission notice 	describes reason 
shall included 	failure errors reported 
copies substantial 	passing errno 
portions 	unable message unable 
software software 	die similarly 
provided without 	commit file commit 
warranty kind 	file close 
express implied 	file success 
including limited 	failure errno appropriately 
warranties 	best roll 
merchantability fitness 	back lockfile appended 
particular purpose 	filename derive 
noninfringement shall 	lockfile name flags 
authors copyright 	following flags 
holders liable 	passed hold file 
claim 	update already 
damages liability 	taken file die 
whether action 	error message 
contract tort 	flag specified trying 
otherwise arising 	file already 
connection software 	locked returns caller 
use 	usually symbolic 
dealings software 	links destination path 
lua structc 	resolved means 
dummy endian 	lockfile created adding 
fmt opt 	resolved path 
fmt len 	upon commit 
opt 	resolved path overwritten 
size opt 	however deref 
fmt msg 	lockfile created adding 
arg endian 	path argument 
size buff 	option used example 
size endian 	detaching symbolic 
temp 	reference backwards compatibility 
fmt arg 	reasons symbolic 
totalsize opt 	link containing name 
size toalign 	referred reference 
buff endian 	attempt create lockfile 
issigned size 	file path 
mask 	file descriptor writing 
fmt data 	error file 
pos opt 	currently locked retry 
size issigned 	quadratic backoff 
res fmt 	least timeout 
pos opt 	milliseconds timeout exactly 
size 	timeout retry 
thislib isdigit 	indefinitely flags argument 
isdigit lua 	error handling 
error getnum 	described attempt create 
getnum lua 	lockfile file 
error getnum 	path file descriptor 
isp 	writing error 
lua error 	flags argument error 
lua pushfstring 	handling described 
lua argerror 	append appropriate error 
lua checknumber 	message buf 
lua addlstring 	following failure hold 
lua 	file update 
checkstring defaultoptions 	path err errno 
lua pushnil 	failing call 
lua buffinit 	emit appropriate error 
optsize gettoalign 	message die 
lua addchar 	following failure 
putinteger 	hold file update 
lua addchar 	path err 
lua checknumber 	errno failing call 
correctbytes lua 	associate stdio 
addlstring lua 	stream lockfile must 
checknumber correctbytes 	still open 
lua 	without rolling back 
addlstring lua 	lockfile error 
checklstring lua 	stream closed automatically 
argcheck lua 	close file 
addlstring lua 	called file committed 
addchar controloptions 	rolled back 
lua 	path lockfile pointer 
pushresult uinttype 	field within 
lua checkstring 	file freed path 
lua checklstring 	file locked 
lua optinteger 	specified file caller 
defaultoptions lua 	must free 
settop 	memory lockfile 
optsize gettoalign 	still open close 
lua argcheck 	file pointer 
lua checkstack 	opened fdopen file 
islower getinteger 	without renaming 
lua pushnumber 	lockfile file locked 
memcpy 	upon success 
correctbytes lua 	failure close negative 
pushnumber memcpy 	roll back 
correctbytes lua 	file usually commit 
pushnumber lua 	file commit 
isnumber lua 	file rollback file 
error 	eventually called 
lua tonumber 	close file succeeds 
lua pop 	open lockfile 
lua argcheck 	closed close file 
lua pushlstring 	yet committed 
memchr lua 	rolled back used 
error 	implement sequence 
lua pushlstring 	operations like 
controloptions lua 	following file write 
pushinteger lua 	contents lockfile 
gettop lua 	close file cause 
checkstring defaultoptions 	contents written 
optsize 	disk pass name 
gettoalign lua 	lockfile another 
argerror lua 	program allow nobody 
argerror isalnum 	inspect contents 
controloptions lua 	wrote still holding 
pushinteger lua 	reopen file 
library 	reopen lockfile make 
packing unpacking 	updates contents 
structures roberto 	commit file make 
exp see 	version permanent 
copyright notice 	commit change represented 
end file 	close file 
valid 	descriptor file 
formats big 	pointer still open 
endian little 	rename lockfile 
endian num 	destination upon success 
alignment pading 	failure roll 
size integer 	back file errno 
size 	failing call 
size sequence 	close rename bug 
chars packing 	call commit 
means whole 	file file currently 
unpacking means 	locked like 
use previous 	commit file rename 
read 	lockfile provided 
number length 	path path must 
zero terminated 	filesystem file 
ignored basic 	roll back close 
integer type 	file descriptor 
corresponding version 	file pointer lockfile 
maximum 	call rollback 
size bytes 	file file 
integral types 	already committed rolled 
power dummy 	back lockfile 
structure alignment 	log-tree.c name decoration 
requirements endian 	decoration loaded 
options 	decoration flags decoration 
number cases 	colors decorate 
need alignment 	color slot slot 
number bytes 	name slot 
needed align 	name decoration obj 
element size 	refname oid 
size 	flags data obj 
current position 	original oid 
len respect 	graft data commit 
max alignment 	flags commit 
options control 	abbrev parent opt 
endianess alignment 	commit abbrev 
ignore 	decoration list head 
white spaces 	branch name 
mark separate 	unused rru 
arguments buffer 	flags decoration commit 
integer types 	use color 
zero end 	prefix separator suffix 
format 	decoration current 
negative signal 	head color commit 
extension integer 	color reset 
types copyright 	opt commit number 
lua puc 	result filename 
rio rights 	subject info suffix 
reserved 	start len 
permission hereby 	max len filename 
granted free 	commit info 
charge person 	ctx subject opt 
obtaining copy 	commit subject 
software associated 	extra headers need 
documentation 	bit cte 
files software 	subject extra headers 
deal software 	name buffer 
without restriction 	buffer subject 
including without 	buffer buffer filename 
limitation 	opt status 
rights use 	bol color reset 
copy modify 	eol opt 
merge publish 	commit payload signature 
distribute sublicense 	gpg output 
sell copies 	status sha commit 
software 	nth parent 
permit persons 	commit commit extra 
software furnished 	data opt 
subject following 	sha tag verify 
conditions copyright 	message status 
notice permission 	nth payload size 
notice 	gpg message 
shall included 	offset opt commit 
copies substantial 	opt msgbuf 
portions software 	log parent abbrev 
software provided 	commit extra 
without warranty 	headers ctx 
kind 	raw notebuf opt 
express implied 	saved fmt 
including limited 	pch msg opt 
warranties merchantability 	commit opt 
fitness particular 	commit log showed 
purpose noninfringement 	log parents 
shall 	oid parent opt 
authors copyright 	commit log 
holders liable 	shown strcasecmp strcasecmp 
claim damages 	strcasecmp strcasecmp 
liability whether 	strcasecmp parse decorate 
action contract 	color slot 
tort 	config error nonbool 
otherwise arising 	color parse 
connection software 	lookup decoration starts 
use dealings 	oid hex 
software lundump.c 	strlen warning 
size size 	parse name decoration 
buff 	parse starts 
name lua 	starts starts strcmp 
pushfstring lua 	strcmp name 
lua read 	decoration parse name 
load load 	decoration lookup 
load load 	commit name decoration 
lua 	head commit 
openspace load 	graft find unique 
block lua 	abbrev lookup 
newlstr load 	decoration find unique 
lua newvector 	abbrev resolve 
load vector 	starts strcmp strbuf 
load 	addstr prettify 
lua newvector 	refname strbuf addstr 
setnilvalue load 	diff color 
setnilvalue setbvalue 	decorate color name 
load setnvalue 	decoration current 
load number 	pointed head 
setsvalue 	strbuf addstr strbuf 
load error 	addstr strbuf 
load lua 	addstr strbuf addstr 
newvector load 	decorate color 
function load 	strbuf addstr show 
lua newvector 	name strbuf 
load 	addstr strbuf addstr 
vector load 	strbuf addstr 
lua newvector 	strbuf addstr strbuf 
load load 	addstr decorate 
load load 	color show name 
lua newvector 	strbuf addstr 
load 	strbuf addstr strbuf 
error lua 	addstr strbuf 
newproto setptvalue 	addstr format decorations 
incr top 	fputs strbuf 
load load 	release strlen strbuf 
load load 	addf strbuf 
load 	addf strbuf 
load load 	setlen strbuf addstr 
load code 	format commit 
load constants 	message fmt output 
load debug 	subject strbuf 
lua checkcode 	release oid hex 
lua 	snprintf digits 
header load 	number snprintf graph 
block memcmp 	show oneline 
load header 	graph show oneline 
load function 	graph show 
lua newliteral 	oneline snprintf strbuf 
memcpy 	addf fmt 
lundump roberto 	output commit snprintf 
exp load 	strbuf release 
precompiled lua 	diff color opt 
chunks see 	diff color 
copyright notice 	opt strchrnul graph 
lua 	show oneline 
trailing load 	parse commit 
precompiled chunk 	verify buffer strbuf 
make header 	addstr show 
endianness lua 	sig lines strbuf 
number integral 	release strbuf 
lundump.h 	release strbuf release 
buff name 	hashcmp hash 
data strip 	sha file lookup 
full lundump 	tag strbuf 
roberto exp 	init parse tag 
load precompiled 	buffer strbuf 
lua 	addstr common merge 
chunks see 	oidcmp strbuf 
copyright notice 	addf parent strbuf 
lua load 	addf strbuf 
one chunk 	addf parse signature 
lundump make 	verify buffer 
header 	strbuf addstr 
lundump dump 	show sig lines 
one chunk 	strbuf release 
ldump print 	mergetag graph show 
one chunk 	commit put 
print header 	revision mark fputs 
binary 	find unique 
files lua 	abbrev show parents 
header binary 	show children 
files official 	show decorations graph 
format size 	commit finished 
header binary 	putchar graph show 
files 	remainder putchar 
lvm.c obj 	graph show padding 
num obj 	putchar graph 
mask oldpc 	show commit log 
npc newline 	write email 
res result 	headers fputs diff 
key 	color opt 
val loop 	fputs put 
res key 	revision mark fputs 
val loop 	find unique 
temp oldval 	abbrev show parents 
res temp 	show children 
len 	find unique abbrev 
res res 	fputs diff 
total last 	color opt show 
top buffer 	decorations putchar 
tempb tempc 	putchar graph show 
nexeccalls res 	oneline show 
nresults 	reflog message show 
aux func 	signature show 
pfunc step 	mergetag cached commit 
idx limit 	buffer format 
init plimit 	display notes log 
pstep last 	output encoding 
val 	strbuf detach xcalloc 
ncl nup 	non ascii 
ttisnumber ttisstring 	fmt name 
lua str 	getenv getenv log 
svalue setnvalue 	output encoding 
ttisnumber nvalue 	pretty print commit 
lua 	append signoff 
number str 	strbuf addstr strbuf 
setsvalue lua 	addstr graph 
resethookcount lua 	show oneline graph 
callhook func 	show commit 
rel getline 	msg fwrite commit 
getline 	format empty 
rel lua 	graph show padding 
callhook savestack 	putchar strbuf 
setobj setobj 	release free diffcore 
setobj lua 	std diff 
checkstack lua 	queue empty diff 
call 	flush show 
restorestack setobjs 	log commit format 
setobj setobj 	empty output 
setobj setobj 	prefix fwrite 
lua checkstack 	putchar diff flush 
lua call 	diff combined 
ttistable 	merge diff opt 
hvalue lua 	tst parse 
ttisnil fasttm 	commit die saved 
setobj ttisnil 	parents diff 
lua gettmbyobj 	root sha log 
lua typeerror 	diff flush 
ttisfunction 	diff combined parse 
call mres 	commit die 
lua runerror 	diff sha log 
ttistable hvalue 	diff flush 
lua ttisnil 	parse commit die 
fasttm setobj 	diff sha 
lua 	log diff flush 
barriert ttisnil 	line log 
lua gettmbyobj 	print log 
lua typeerror 	diff show log 
ttisfunction call 	maybe flush 
setobj lua 	die local remote 
runerror 	tag stash 
lua gettmbyobj 	head grafted comparing 
ttisnil lua 	ignore config 
gettmbyobj ttisnil 	sets tolower match 
call mres 	letters values 
fasttm fasttm 	documented documentation config 
lua 	txt consistency 
rawequal obj 	love consistent log 
lua gettmbyobj 	uses diff 
ttisnil lua 	opt tst determining 
gettmbyobj lua 	whether use 
rawequal obj 	color showing commit 
call 	sha use 
mres isfalse 	check decorate head 
getstr getstr 	output also 
strcoll strlen 	branch points 
ttype ttype 	find decoration entry 
lua ordererror 	current branch 
ttisnumber 	first find head 
luai numlt 	resolve find 
nvalue nvalue 	matching current branch 
ttisstring strcmp 	list caller 
rawtsvalue rawtsvalue 	makes sure funny 
call order 	color calling 
lua 	format decorations extended 
ordererror ttype 	makes sure 
ttype lua 	current head show 
ordererror ttisnumber 	head current 
luai numle 	head would appeared 
nvalue nvalue 	skipping entry 
ttisstring 	current unknown never 
strcmp rawtsvalue 	error message 
rawtsvalue call 	already given could 
order call 	good signature 
order lua 	good otherwise 
ordererror lua 	couldn verify shown 
ttype 	bad use 
ttype ttype 	terminator already handled 
luai numeq 	record termination 
nvalue nvalue 	end last record 
bvalue bvalue 	otherwise diffopt 
pvalue pvalue 	line termination character 
uvalue 	entries first 
uvalue comp 	iow separator entries 
uvalue uvalue 	entries separated 
hvalue hvalue 	newline output look 
comp hvalue 	human readable 
hvalue gcvalue 	last entry ended 
gcvalue 	newline print 
call mres 	graph output newline 
isfalse ttisstring 	otherwise end 
ttisnumber tostring 	completely blank line 
call bin 	look like 
lua concaterror 	gap graph 
tsvalue 	entry separator newline 
tostring tsvalue 	output primarily 
tostring tsvalue 	intended programmatic consumption 
lua runerror 	never want 
lua openspace 	extra graph output 
tsvalue memcpy 	entry separator 
svalue 	history graph requested 
setsvalue lua 	print graph 
newlstr lua 	commit line print 
tonumber lua 	header line 
tonumber nvalue 	header setup revisions 
setnvalue luai 	ensures opt 
numadd 	reflog info opt 
setnvalue luai 	graph cannot 
numsub setnvalue 	need worry printing 
luai nummul 	graph info 
setnvalue luai 	pretty printed message 
numdiv setnvalue 	opt missing 
luai 	newline msgbuf 
nummod setnvalue 	doesn end newline 
luai numpow 	including empty 
setnvalue luai 	showing verbose header 
numunm lua 	log message 
call bin 	pretty oneline format 
lua 	would want 
aritherror lua 	extra newline end 
lua clvalue 	log diff 
traceexec lua 	diffstat output readability 
lua lua 	may shown 
lua checkopenop 	three dashes line 
opcode 	early notes 
setobjs setobj 	log message want 
setbvalue getarg 	blank line 
getarg setnilvalue 	notes without extra 
getarg setobj 	three dashes 
sethvalue lua 	line otherwise 
ttisstring 	show three dashes 
protect lua 	line showing 
gettable protect 	patch diffstat extra 
lua gettable 	blank line 
rkc sethvalue 	three dashes line 
lua ttisstring 	show diff 
protect 	commit printed log 
lua settable 	info messages 
getarg setobj 	root commit one 
lua barrier 	parent generate 
protect lua 	merge log entry 
settable rkb 	first parent 
rkc 	showing summary diff 
getarg getarg 	others merged 
sethvalue lua 	show individual diffs 
lua lua 	show parent 
protect lua 	info log info 
check setobjs 	next parent 
protect 	log-tree.h commit 
lua gettable 	parent slot name 
rkc arith 	rev info 
arith arith 	rev info rev 
arith arith 	info commit 
arith ttisnumber 	rev info opt 
nvalue 	commit use 
setnvalue luai 	color prefix separator 
numunm protect 	suffix opt 
arith isfalse 	commit opt commit 
setbvalue ttype 	subject extra 
setnvalue cast 	headers need bit 
num 	cte flags 
lua getn 	strbuf commit rev 
hvalue setnvalue 	info strbuf 
cast num 	subject rev info 
tsvalue getarg 	log.c date 
getarg setobjs 	mode abbrev commit 
dojump 	show root 
getarg rkb 	follow decoration 
rkc isfalse 	style decoration given 
getarg dojump 	use mailmap 
getarg isfalse 	config fmt patch 
getarg setobjs 	subject prefix 
dojump 	fmt pretty builtin 
getarg getarg 	log usage 
getarg lua 	rev prefix args 
precall getarg 	opt arg 
lua getarg 	unset option arg 
lua precall 	unset data 
lua 	rev argc argv 
close setobjs 	prefix rev 
lua clvalue 	opt mailmap line 
getarg lua 	builtin log 
close lua 	options argc argv 
poscall lua 	prefix rev 
lua 	opt rev list 
lua opcode 	commit flags 
nvalue luai 	rev stage 
numadd nvalue 	early output timer 
nvalue luai 	revs list 
numlt luai 	show header commit 
numle 	signal rev 
luai numle 	rev rev commit 
dojump getarg 	saved nrl 
setnvalue setnvalue 	saved dcctc slot 
tonumber lua 	name argc 
runerror lua 	argv prefix rev 
tonumber 	opt buf 
lua runerror 	len rev sha 
lua tonumber 	rev obj 
lua runerror 	name sha obj 
lua setnvalue 	context buf 
luai numsub 	size sha rev 
nvalue 	size buf 
nvalue dojump 	offset offset 
getarg setobjs 	sha pathname mode 
setobjs setobjs 	stage context 
protect lua 	rev opt argc 
call getarg 	argv prefix 
ttisnil 	rev objects opt 
setobjs dojump 	match count 
getarg getarg 	ret name argc 
getarg cast 	argv prefix 
cast runtime 	rev opt rev 
check ttistable 	opt argc 
hvalue 	argv prefix rev 
lua resizearray 	opt fmt 
setobj lua 	patch suffix numbered 
setnum lua 	number attach 
barriert lua 	extra hdr extra 
close getarg 	extra item 
lua 	len signoff signature 
lclosure opcode 	signature file 
getarg lua 	config cover 
opcode lua 	letter config output 
findupval getarg 	directory realstdout 
setclvalue protect 	output directory outdir 
lua 	offset commit 
check getarg 	subject rev quiet 
cast protect 	filename suffix 
lua checkstack 	len rev ids 
setobjs setnilvalue 	check rev 
lvm roberto 	commit flags flags 
exp 	info buf 
lua machine 	buf branch name 
see copyright 	desc rev 
notice lua 	positive branch oid 
limit table 	tip oid 
tag method 	full branch rev 
chains 	use stdout 
avoid loops 	origin list branch 
call linehook 	name quiet 
enter function 	committer body 
jump back 	msg log encoding 
loop enter 	opts need 
line 	bit cte head 
push function 	buf msg 
argument argument 	prefix output directory 
push function 	builtin format 
argument argument 	patch usage keep 
argument table 	subject opt 
primitive 	arg unset subject 
result nil 	prefix opt 
tag method 	arg unset numbered 
repeat table 	cmdline opt 
primitive result 	opt arg unset 
nil tag 	opt arg 
method 	unset opt arg 
repeat avoid 	unset dir 
pointing inside 	opt arg unset 
table may 	opt arg 
rehash first 	unset rev 
operand second 	opt arg unset 
operand 	rev opt 
metamethod metatables 	arg unset opt 
metamethods metamethod 	arg unset 
metamethods metamethod 	opt arg unset 
different metamethods 	opt arg 
equal index 	unset argc argv 
first 	prefix commit 
finished finished 	list rev opt 
smaller finished 	total use 
longer len 	stdout start number 
comparing first 	numbers ignore 
must call 	upstream cover letter 
number 	boundary count 
elements handled 	binary diff zero 
pass least 	commit origin 
second empty 	reply ids 
result first 	buf use patch 
least two 	format quiet 
values 	reroll count branch 
many possible 	name builtin 
collect total 	format patch options 
length concat 	sprefix check 
got create 	head sha buf 
repeat result 	msgid shown 
left 	arg revs flags 
macros common 	sha commit 
tasks lua 	cherry usage sign 
execute used 	commit verbose 
possible stack 	abbrev buf argc 
reallocation 	argv prefix 
entry point 	revs ids commit 
main loop 	list current 
interpreter hook 	branch upstream head 
warning several 	limit abbrev 
calls may 	options sign 
realloc 	git config maybe 
stack invalidate 	strcmp strcmp 
skip next 	strcmp isatty pager 
instruction next 	use parse 
assignment may 	decoration style die 
change metamethod 	list append 
previous 	commit format diff 
instruction top 	opt diff 
restart lua 	opt diff opt 
execute lua 	parse date 
function function 	format parse options 
precall called 	setup revisions 
adjust 	die memset userformat 
results previous 	find requirements 
instruction top 	init display notes 
tail call 	diff opt 
put frame 	tst xcalloc read 
place previous 	mailmap load 
one 	decorations line 
previous frame 	log init setup 
previous function 	pager cmd 
index move 	log init defaults 
frame correct 	cmd log 
top one 	init finish putchar 
call 	sort topological 
lost frame 	order simplify commit 
function precall 	estimate commit 
called previous 	count show early 
function running 	header log 
yes execution 	commit setitimer memset 
increment 	sigemptyset sigaction 
index jump 	setitimer estimate commit 
back update 	count signal 
index external 	show early header 
index next 	setup early 
steps may 	output prepare revision 
errors 	walk die 
call func 	finish early 
args state 	output revision log 
index previous 	commit free 
call may 	commit buffer free 
change stack 	commit list 
loop 	diff opt tst 
save control 	diff result 
variable jump 	code strcmp git 
back needs 	config strcmp 
space pre 	git config strcmp 
alloc previous 	git config 
call 	strcmp git config 
may change 	strcmp parse 
stack lvm.h 	decoration style strcmp 
obj obj 	git config 
key val 	strcmp git config 
key val 	skip prefix 
nexeccalls 	parse decorate color 
total last 	config strcmp 
lvm roberto 	git config 
exp lua 	grep config git 
machine see 	gpg config 
copyright notice 	git diff config 
lua 	init grep 
lzf.h data 	defaults git config 
len data 	init revisions 
len data 	memset cmd log 
len data 	init cmd 
len copyright 	log walk user 
marc 	info log 
alexander lehmann 	output encoding strbuf 
schmorp schmorp 	release fflush 
redistribution use 	diff opt touched 
source binary 	diff opt 
forms without 	tst stream blob 
modifica 	sha context 
tion permitted 	die textconv 
provided following 	stream blob die 
conditions met 	write die 
redistributions source 	read sha file 
code must 	error sha 
retain 	hex starts show 
copyright notice 	tagger fwrite 
list conditions 	free isdir init 
following disclaimer 	grep defaults 
redistributions binary 	git config memset 
form must 	init revisions 
reproduce 	memset cmd log 
copyright notice 	init cmd 
list conditions 	log walk show 
following disclaimer 	blob putchar 
documentation materials 	diff color opt 
provided distribution 	diff color 
software 	opt show tag 
provided author 	parse error 
express implied 	oid hex 
warranties including 	putchar diff color 
limited implied 	opt diff 
warranties mer 	color opt read 
chantability 	recursive cmd 
fitness particular 	log walk error 
purpose disclaimed 	free init 
shall author 	grep defaults git 
liable direct 	config init 
indirect incidental 	revisions init reflog 
spe 	walk memset 
cial exemplary 	cmd log init 
consequential damages 	defaults cmd 
including limited 	log init finish 
procurement substitute 	cmd log 
goods services 	walk diff opt 
loss 	tst diff 
use data 	opt init grep 
profits business 	defaults git 
interruption however 	config init 
caused theory 	revisions memset cmd 
liability whether 	log init 
contract 	cmd log walk 
strict liability 	strlen strncasecmp 
tort including 	list append strncasecmp 
negligence oth 	list append 
erwise arising 	list append strcmp 
way use 	die header 
software 	strcmp git config 
even advised 	strcmp config 
possibility damage 	error nonbool list 
alternatively contents 	append strcmp 
file may 	config error nonbool 
used terms 	list append 
gnu 	strcmp strcmp strcmp 
general license 	strcmp strcmp 
gpl version 	strcasecmp git config 
later version 	strcmp xstrdup 
provisions gpl 	xstrdup strcmp 
applicable instead 	strcasecmp strcasecmp git 
wish 	config strcmp 
allow use 	git config strcmp 
version file 	git config 
terms gpl 	strcmp git config 
allow others 	pathname strcmp 
use version 	strcasecmp git config 
file 	strcmp git 
bsd license 	config git log 
indicate decision 	config strlen 
deleting provisions 	strbuf addstr error 
replace notice 	strbuf complete 
provisions required 	strbuf addf fmt 
gpl 	output commit 
provisions recipient 	fmt output subject 
may use 	freopen error 
version file 	strbuf release 
either bsd 	die lookup commit 
gpl lzf 	reference lookup 
extremely 	commit reference die 
fast free 	init patch 
compression decompression 	ids init revisions 
method http 	pending pending 
liblzf plan 	prepare revision walk 
algorithm believed 	die revision 
patent 	commit patch clear 
free api 	commit marks 
version compress 	clear commit marks 
len bytes 	strbuf addf 
stored memory 	time git committer 
block starting 	info strbuf 
data 	detach strlen putchar 
write result 	putchar read 
data maximum 	branch desc strbuf 
length len 	addch strbuf 
bytes output 	addbuf strbuf 
buffer large 	addch strbuf release 
enough 	dwim strlen 
error occurs 	skip prefix oidcmp 
otherwise number 	xstrdup free 
bytes used 	die git committer 
might considerably 	info reopen 
len less 	stdout log write 
original 	email headers 
size makes 	commit buffer non 
sense always 	ascii unuse 
use len 	commit buffer find 
len ensure 	branch name 
compression store 	user info title 
data 	line remainder 
uncompressed otherwise 	branch description strbuf 
flag course 	release shortlog 
lzf compress 	init shortlog commit 
might use 	shortlog output 
different algorithms 	memcpy diff 
different 	setup done diff 
systems even 	sha diffcore 
different runs 	std diff flush 
thus might 	print signature 
result different 	isspace isspace die 
compressed depending 	xmemdupz absolute 
phase 	path strlen xstrdup 
moon similar 	prefix filename 
factors however 	numbered callback die 
architecture independent 	strcmp strcmp 
result original 	list clear list 
data decompressed 	clear list 
lzf 	clear header list 
decompress buffers 	clear list 
must overlapping 	append list clear 
option lzf 	list append 
state arg 	free xstrdup xstrdup 
enabled extra 	git committer 
argument 	info init 
must supplied 	grep defaults git 
reflected header 	config init 
file refer 	revisions diff opt 
lzf lzf 	memset parse 
decompress data 	options strbuf addf 
compressed 	strbuf detach 
version lzf 	strbuf addstr strbuf 
compress function 	addch strbuf 
stored location 	addstr strbuf addstr 
data length 	strbuf addstr 
len result 	strbuf addch strbuf 
stored 	addch strbuf 
data maximum 	addstr strbuf addstr 
len characters 	strbuf addstr 
output buffer 	strbuf addch strbuf 
large enough 	addch strbuf 
hold decompressed 	detach split 
data 	ident line strlen 
returned errno 	die die 
big otherwise 	die setup revisions 
number decompressed 	die die 
bytes original 	die die diff 
length data 	opt tst 
returned 	diff opt init 
error compressed 	display notes 
data detected 	outdir setup pager 
zero returned 	die mkdir 
errno einval 	die errno head 
function fast 	pending strcmp 
fast 	resolve skip prefix 
copying loop 	xstrdup xstrdup 
lzfP.h std 	oidcmp patch ids 
copyright marc 	xfdopen xdup 
alexander lehmann 	prepare revision walk 
schmorp schmorp 	die revision 
redistribution 	commit patch 
use source 	realloc strbuf read 
binary forms 	file die 
without modifica 	errno strbuf detach 
tion permitted 	xcalloc clean 
provided following 	message list append 
conditions 	gen message 
met redistributions 	make cover letter 
source code 	free list 
must retain 	append gen message 
copyright notice 	oid hex 
list conditions 	reopen stdout die 
following 	log commit 
disclaimer redistributions 	free commit buffer 
binary form 	print signature 
must reproduce 	fclose free free 
copyright notice 	list clear 
list conditions 	list clear list 
following 	clear free 
disclaimer documentation 	patch ids 
materials provided 	sha lookup commit 
distribution software 	reference pending 
provided author 	find unique abbrev 
express implied 	commit easy 
warranties 	find unique abbrev 
including limited 	strbuf release 
implied warranties 	parse options branch 
mer chantability 	branch upstream 
fitness particular 	usage options init 
purpose disclaimed 	revisions pending 
shall 	commit die pending 
author liable 	commit die 
direct indirect 	oidcmp patch ids 
incidental spe 	pending commit 
cial exemplary 	die prepare revision 
consequential damages 	walk die 
including 	revision commit list 
limited procurement 	insert commit 
substitute goods 	patch print 
services loss 	commit free patch 
use data 	ids builtin 
profits business 	git log related 
interruption 	commands show 
however caused 	whatchanged copyright linus 
theory liability 	torvalds junio 
whether contract 	hamano date time 
strict liability 	format git 
tort including 	log log date 
negligence 	config variable 
oth erwise 	use full terminal 
arising way 	width respect 
use software 	stat graph width 
even advised 	config arguments 
possibility damage 	point recognized log 
alternatively 	pretty raw 
contents file 	special ignore oriented 
may used 	configuration variables 
terms gnu 	decoration gives 
general license 	rough estimate many 
gpl version 	commits print 
later 	list already enough 
version provisions 	commits early 
gpl applicable 	output repeat twice 
instead wish 	second note 
allow use 	use interval reader 
version file 	isn listening 
terms 	want output throttled 
gpl allow 	writing timer 
others use 	trigger every second 
version file 	even blocked 
bsd license 	reader signal handler 
indicate decision 	minimally intrusively 
deleting 	single integer word 
provisions replace 	sigatomic trying 
notice provisions 	avoid unnecessary 
required gpl 	system dependencies headers 
provisions recipient 	restart whole 
may use 	output less tenth 
version 	second even 
file either 	bother early output 
bsd gpl 	thing one 
moment size 	time trigger check 
hashtable hlog 	exit code 
decompression independent 	exit code check 
hash 	failed changes 
table size 	accumulated rev diffopt 
difference small 	careful retain 
small blocks 	state information replacing 
usually bit 	rev diffopt 
faster low 	loop decremented max 
memory 	count revision 
faster configuration 	didn actually show 
use hlog 	commit allow 
best compression 	cycles reflog 
use sacrifice 	ancestry maybe warn 
little compression 	nothing command 
quality 	line first parent 
favour compression 	scale real 
speed gives 	terminal size equivalent 
almost compression 	git log 
code roughly 	abbrev commit pretty 
faster preferred 	oneline turn 
mode 	given turn given 
operation sacrifice 	format patch 
compression quality 	given range patch 
favour compression 	ids reset 
speed roughly 	next revision walk 
worse compression 	diffstat unique 
large 	reference point user 
blocks small 	explicitly ask 
redundant blocks 	parse arguments setup 
better speed 	revisions something 
cases need 	like git 
speed enable 	format patch head 
binary 	may fail 
data possibly 	possibly valid sha 
disable text 	numbered solely 
data unconditionally 	due format numbered 
aligning cost 	config would 
much unsure 	conflict keep subject 
may 	command line 
choose pre 	reset numbered always 
hash table 	generate patch 
might faster 	traditional behaviour git 
modern cpus 	format patch 
large blocks 	origin prepares origin 
also 	side still 
makes compression 	otherwise format patch 
deterministic repeatable 	head format 
configuration otherwise 	patch root head 
avoid assigning 	user wants 
values errno 	revision usual 
variable 	traversal branch cannot 
embedding purposes 	move anywhere 
linux kernel 	earlier want know 
example necessary 	root given 
note breaks 	explicitly command line 
documentation lzf 	say anything 
avoiding 	head upstream nothing 
errno speed 	signature inhibits 
impact whether 	signatures non signature 
pass lzf 	already make 
state variable 	second subsequent mails 
argument allocate 	replies first 
stack 	already message deep 
small stack 	threading make 
environments define 	every mail reply 
note breaks 	previous one 
prototype lzf 	matter options 
whether extra 	shallow threading without 
checks 	cover letter 
input validity 	reply make every 
lzf decompress 	mail reply 
einval input 	one reply cover 
stream corrupted 	letter make 
shields overflowing 	every mail reply 
input 	reply cover 
buffer detect 	letter make every 
corrupted streams 	mail cover 
check normally 	letter reply cover 
noticeable modern 	letter cover 
hardware slowdown 	letter reply reply 
might 	specified put 
slow older 	one extra blank 
cpus considerably 	line formatted 
whether store 	patches flag used 
pointers offsets 	log code 
inside hash 	see needs 
table 	emit showing log 
bit architetcures 	one file 
pointers take 	per patch want 
twice much 	extra blank 
space might 	line fallthrough fallthrough 
also slower 	say anything 
autodetect 	head upstream reverse 
define lzf 	list commits 
user offsets 	ls-files.c abbrev show 
autodetect nothing 	deleted show 
changed accesses 	cached show others 
need bit 	show stage 
datatype 	show unmerged show 
lzf data 	resolve undo 
len data 	show modified show 
len htab 	killed show 
htab end 	valid bit line 
end hval 	terminator debug 
lit 	mode show 
hslot len 	eol prefix max 
maxlen memset 	prefix len 
frst next 	prefix len pathspec 
idx expect 	error unmatch 
expect 	matched exc given 
expect frst 	exclude args 
next idx 	tag cached tag 
next idx 	unmerged tag 
next idx 	removed tag tag 
expect expect 	killed tag 
expect 	modified tag skip 
copyright marc 	worktree tag 
alexander lehmann 	resolve undo path 
schmorp schmorp 	txt txt 
redistribution use 	txt name tag 
source binary 	ent len 
forms 	dir ent dir 
without modifica 	ent pos 
tion permitted 	len killed 
provided following 	tag len alttag 
conditions met 	item path 
redistributions source 	len dir dtype 
code 	dir err 
must retain 	prefix pos first 
copyright notice 	last next 
list conditions 	name prefix sha 
following disclaimer 	pathspec last 
redistributions binary 	stage files usage 
form 	opt arg 
must reproduce 	unset exclude list 
copyright notice 	opt arg 
list conditions 	unset dir opt 
following disclaimer 	arg unset 
documentation materials 	dir argc argv 
provided 	cmd prefix 
distribution software 	max prefix 
provided author 	dir exclude list 
express implied 	builtin files 
warranties including 	options bad convert 
limited implied 	attr ascii 
warranties 	isreg cached convert 
mer chantability 	stats ascii 
fitness particular 	lstat isreg convert 
purpose disclaimed 	stats ascii 
shall author 	write name quoted 
liable direct 	relative die 
indirect 	dir path match 
incidental spe 	fputs write 
cial exemplary 	eolinfo write name 
consequential damages 	cache name 
including limited 	show dir entry 
procurement substitute 	strchr cache 
goods 	name pos die 
services loss 	stage namelen 
use data 	strncmp cache 
profits business 	name pos show 
interruption however 	dir entry 
caused theory 	namelen die match 
liability 	pathspec namelen 
whether contract 	isdir isgitlink memcpy 
strict liability 	isalpha tolower 
tort including 	fputs find unique 
negligence oth 	abbrev stage 
erwise arising 	write eolinfo write 
way 	name strlen 
use software 	match pathspec find 
even advised 	unique abbrev 
possibility damage 	write name dtype 
alternatively contents 	excluded fill 
file may 	directory show files 
used 	show killed 
terms gnu 	files excluded stage 
general license 	show entry 
gpl version 	stage skip 
later version 	worktree excluded skip 
provisions gpl 	worktree lstat 
applicable 	show entry modified 
instead wish 	show entry 
allow use 	cache name pos 
version file 	memmove strncmp 
terms gpl 	sha die parse 
allow others 	indirect die 
use 	stage parse pathspec 
version file 	memset read 
bsd license 	die stage strcmp 
indicate decision 	list append 
deleting provisions 	excludes file setup 
replace notice 	standard excludes 
provisions 	strcmp usage options 
required gpl 	memset strlen 
provisions recipient 	git config read 
may use 	cache die 
version file 	parse options 
either bsd 	exclude list exclude 
gpl 	inside work 
play unless 	setup work parse 
benchmark data 	pathspec common 
format dependent 	prefix strlen xcalloc 
hash function 	die prune 
hash function 	cache die overlay 
might 	cache show 
seem strange 	files show info 
believe works 	report path 
idx works 	error merges file 
similar multiplicative 	listing directory 
hash hlog 	cache index actual 
hsize 	working directory 
latter also 	list shows different 
quite fast 	combinations two 
newer compresses 	copyright linus torvalds 
similarly next 	full name 
one also 	prefix len 
quite 	caller needs pass 
good albeit 	empty good 
slow cos 	ent name prefix 
xffffff original 	entry cache 
lzv like 	killed skip unmerged 
hash function 	pos points 
much 	name immediately ent 
worse thus 	name cache 
slower compressed 	expect ent name 
format lllll 	directory leading 
octets looooo 	directories ent name 
oooooooo backref 	registered cache 
octets 	ent name killed 
offset ooooo 	outside prefix 
llllllll oooooooo 	uninterested cached deleted 
backref octets 	files need 
offset requires 	even readdir 
type wide 	prune index contain 
enough 	stuff starting 
hold general 	prefix read specified 
pointer difference 	option typically 
iso doesn 	head stage squash 
size might 	stage used 
enough ptrdiff 	error unmatch list 
works 	check path 
differences within 	patterns given command 
single also 	line going 
bit pattern 	write index hoist 
traps since 	unmerged entries 
platform non 	stage make room 
posix 	fallthru stage 
fails support 	entry need show 
assumptions windows 	use update 
bit make 	bit mark entry 
special workaround 	think twice 
workaround missing 	adding nul 
posix 	synonym point showing 
compliance start 	unmerged unless 
run next 	also show stage 
test actually 	information find 
take care 	common prefix pathspec 
faster match 	treat unmatching 
found 	pathspec elements errors 
first faster 	flags showing 
conservative test 	cached files basic 
second exact 	sanity check 
rare test 	show stages show 
stop run 	unmerged would 
undo 	make sense option 
run length 	ls-remote.c remote 
zero len 	usage pattern path 
octets start 	pathbuf argc 
run one 	argv prefix dest 
must copy 	flags url 
stop 	quiet status 
run start 	show symref target 
run bytes 	uploadpack pattern 
missing stop 	remote transport options 
run start 	snprintf error 
run end 	wildmatch parse options 
run 	xcalloc xstrfmt 
undo run 	remote die die 
length zero 	die transport 
lzf data 	transport option transport 
len data 	remote refs 
len end 	transport disconnect check 
end 	type tail 
ctrl len 	match oid hex 
errno errno 	one among 
lzf movsb 	list patterns match 
errno errno 	tail part 
errno errno 	path restriction found 
lzf 	something ls-tree.c 
movsb memcpy 	line termination 
copyright marc 	abbrev options pathspec 
alexander lehmann 	chomp prefix 
schmorp schmorp 	prefix usage baselen 
redistribution use 	pathname spec 
source 	len speclen sha 
binary forms 	pathname mode 
without modifica 	stage context retval 
tion permitted 	baselen type 
provided following 	size text size 
conditions met 	argc argv 
redistributions 	prefix sha full 
source code 	options strncmp 
must retain 	strlen strlen memcmp 
copyright notice 	isgitlink isdir 
list conditions 	show recursive strcmp 
following disclaimer 	sha info 
redistributions 	xsnprintf xsnprintf 
binary form 	xsnprintf find unique 
must reproduce 	abbrev find 
copyright notice 	unique abbrev strbuf 
list conditions 	addstr write 
following disclaimer 	name quoted relative 
documentation 	strbuf setlen 
materials provided 	git config strlen 
distribution software 	parse options 
provided author 	usage options sha 
express implied 	die parse 
warranties including 	pathspec parse indirect 
limited 	die read 
implied warranties 	recursive git information 
mer chantability 	manager hell 
fitness particular 	copyright linus torvalds 
purpose disclaimed 	maybe want 
shall author 	recursive version something 
liable 	similar incomplete 
direct indirect 	example show 
incidental spe 	subprojects baselen pathname 
cial exemplary 	retval read 
consequential damages 	recursive imply show 
including limited 	recursive rolls 
procurement 	matching code generally 
substitute goods 	ignorant pathspec 
services loss 	magic mask cannot 
use data 	lifted converted 
profits business 	use match pathspec 
interruption however 	entry interesting 
caused 	mailinfo.c pos cnt 
theory liability 	name email 
whether contract 	src line bra 
strict liability 	ket line 
tort including 	line name attr 
negligence oth 	ends line 
erwise 	boundary line line 
arising way 	line content 
use software 	top subject 
even advised 	pos header line 
possibility damage 	hdr len 
alternatively contents 	line len sample 
file 	seg rfc 
may used 	seg acc line 
terms gnu 	charset dec 
general license 	piecebuf found error 
gpl version 	encoding scan 
later version 	line hdr data 
provisions 	overwrite len 
gpl applicable 	len line ret 
instead wish 	line line 
allow use 	len gap first 
version file 	nonblank visible 
terms gpl 	perforation buf line 
allow 	line line 
others use 	line line continuation 
version file 	peek line 
bsd license 	line newline 
indicate decision 	line prev lines 
deleting provisions 	fout hdr 
replace 	data len hdr 
notice provisions 	msg patch 
required gpl 	cmitmsg peek line 
provisions recipient 	isspace isspace 
may use 	strbuf strchr strchr 
version file 	strchr strbuf 
either 	reset strbuf addbuf 
bsd gpl 	strchr strchr 
small win 	strbuf reset strbuf 
amd big 	strbuf reset 
loss intel 	strbuf strbuf trim 
run back 	sane name 
reference 	strbuf init strbuf 
disjunct areas 	addbuf strchr 
overlapping use 	parse bogus 
octte octte 	strchr strbuf release 
copying two 	isspace strcspn 
octets lzio.c 	strbuf reset strbuf 
size 	strbuf cleanup 
buff reader 	space strbuf trim 
data buff 	strbuf strbuf 
lua unlock 	setlen sane name 
reader lua 	strbuf release 
lua fill 	xmalloc strbuf init 
lua 	strbuf reset 
lookahead memcpy 	strbuf addbuf strcasestr 
lua resizebuffer 	strbuf setlen 
lzio roberto 	strlen strcspn strbuf 
exp input 	xmalloc strbuf 
stream see 	init slurp attr 
copyright 	strbuf insert 
notice lua 	error slurp attr 
lua fill 	strbuf release 
removed first 	free strdup 
put back 	strcasestr strcasestr memcmp 
read number 	strbuf strbuf 
missing 	strchr memmem strbuf 
bytes min 	isspace strbuf 
lzio.h buff 	trim strlen strncasecmp 
reader data 	isspace strlen 
reader data 	skip prefix strspn 
lzio roberto 	memcmp strlen 
exp 	xmalloc strbuf init 
buffered streams 	strbuf addch 
see copyright 	hexval hexval strbuf 
notice lua 	addch xmalloc 
end stream 	strbuf init strbuf 
read next 	addch strbuf 
bytes 	addch strbuf addch 
part bytes 	encoding reencode 
still unread 	error strbuf attach 
current position 	strlen strlen 
buffer additional 	strstr strbuf 
data lua 	reset strbuf reset 
state 	isspace strbuf 
reader mallctl.c 	strchr strbuf strstr 
epoch mib 	strbuf tolower 
miblen epoch 	decode segment decode 
mib miblen 	segment convert 
old epoch 	utf strbuf addbuf 
epoch 	strbuf release 
mib miblen 	free strbuf addstr 
config always 	strbuf reset 
nbins mib 	strbuf addbuf strbuf 
len miblen 	release strbuf 
bin size 	release strbuf release 
tis 	strlen cmp 
psz qsz 	header strbuf decode 
arena old 	header handle 
arena narenas 	header cmp header 
dirty mult 	strlen strbuf 
orig dirty 	decode header 
mult 	strbuf insert handle 
prev dirty 	content type 
mult old 	cmp header strlen 
dirty mult 	strbuf decode 
narenas mib 	header handle content 
miblen dss 	transfer encoding 
prec 	cmp header strlen 
old dss 	strbuf decode 
prec mib 	header handle message 
miblen narenas 	starts isspace 
dirty mult 	format patch separator 
orig dirty 	starts isspace 
mult 	strcmp handle header 
prev dirty 	strbuf release 
mult old 	decode segment decode 
dirty mult 	segment strbuf 
narenas arena 	reset strbuf addbuf 
narenas mallctl 	strbuf release 
mallctl 	free starts 
strlen mallctl 	starts starts isspace 
mallctl mallctl 	isspace isspace 
mallctl mallctlnametomib 	memcmp memcmp memcmp 
mallctlnametomib mallctlbymib 	memcmp check 
strlen mallctlnametomib 	header convert utf 
mallctlbymib 	scissors line 
mallctlbymib mallctlbymib 	strbuf setlen strbuf 
mallctlbymib mallctl 	release patchbreak 
mallctl mallctl 	strbuf addf strbuf 
mallctl mallctlnametomib 	addbuf fwrite 
test mallctl 	handle commit msg 
config 	handle patch 
test mallctl 	starts starts strbuf 
config test 	getline strbuf 
mallctl config 	rtrim rfc header 
test mallctl 	strbuf addch 
config test 	fgetc ungetc 
mallctl 	strbuf getline strbuf 
config test 	rtrim strbuf 
mallctl config 	addbuf strbuf release 
test mallctl 	strbuf getline 
config test 	multipart boundary strbuf 
mallctl config 	addch memcmp 
test 	strbuf release free 
mallctl config 	error handle 
test mallctl 	filter strbuf release 
config test 	find boundary 
mallctl config 	strbuf reset read 
test mallctl 	one header 
config 	line check header 
test mallctl 	strbuf release 
config test 	strbuf getline strbuf 
mallctl config 	addch find 
test mallctl 	boundary strbuf getwholeline 
opt test 	multipart boundary 
mallctl 	handle filter 
opt test 	strbuf reset handle 
mallctl opt 	boundary decode 
test mallctl 	transfer encoding strbuf 
opt test 	insert strbuf 
mallctl opt 	reset strbuf split 
test 	strbuf addbuf 
mallctl opt 	handle filter strbuf 
test mallctl 	list free 
opt test 	handle filter strbuf 
mallctl opt 	release strchr 
test mallctl 	strlen strcmp cleanup 
opt 	subject cleanup 
test mallctl 	space output header 
opt test 	lines strcmp 
mallctl opt 	cleanup space handle 
test mallctl 	cleanup space 
opt test 	fopen perror fopen 
mallctl 	perror fclose 
opt test 	xcalloc xcalloc 
mallctl opt 	isspace fgetc ungetc 
test mallctl 	read one 
opt test 	header line check 
mallctl opt 	header handle 
test 	body fwrite fclose 
mallctl opt 	fclose handle 
test mallctl 	info strbuf release 
opt test 	starts git 
mallctl opt 	config strcmp git 
test mallctl 	config memset 
opt 	strbuf init strbuf 
test mallctl 	init strbuf 
opt test 	init strbuf init 
mallctl opt 	git config 
test mallctl 	strbuf release strbuf 
opt mallctl 	release strbuf 
mallctlnametomib 	release free strbuf 
mallctlbymib test 	release free 
skip mallocx 	strbuf release 
ptr mallocx 	free free strbuf 
ptr dallocx 	release john 
dallocx mallocx 	doe johndoe fallback 
ptr 	bother already 
ptr dallocx 	mail address already 
test skip 	one email 
nallocx mallctl 	take confusing lines 
mallctl mallctl 	pick around 
mallctl 	possibly delimited pair 
mallocx mallocx 	email part 
tcache ptr 	remainder name could 
dallocx mallocx 	john doe 
tcache mallocx 	john doe john 
mallocx tcache 	doe john 
ptr 	doe john zzz 
dallocx mallocx 	doe john 
tcache mallocx 	doe comment 
mallocx tcache 	removed email part 
ptr ptr 	extra spaces 
rallocx mallocx 	could stay email 
tcache 	trim ends 
ptr ptr 	possibly removing pair 
dallocx mallocx 	end cases 
tcache mallctl 	note note note 
mallctl mallctl 	claim full 
mallctl mallctl 	mime attempt enough 
mallctl 	heuristics grok 
mallctl mallctl 	mime encoded patches 
ssize mallctl 	often found 
mallctl mallctl 	mailing lists example 
mallctlnametomib mallctlbymib 	even treat 
mallctlnametomib mallctlbymib 	header lines insensitively 
str 	input space 
mallctlbymib mallctlbymib 	keep bother finding 
str narenas 	end space 
total mallctlbymib 	since later 
str mallctlbymib 	normalize anyway drop 
mallctlbymib str 	trailing newline 
mallctl 	rfc decode possibly 
variable mallctl 	place garbage 
mallctl mallctl 	pessimism process encoded 
mallctl ssize 	word begins 
mallctl test 	something encoded word 
arenas constant 	lose something 
test 	unless processed encoded 
arenas constant 	word lws 
test arenas 	one process iso 
constant test 	foo iso 
arenas constant 	foo cbar baz 
test arenas 	search interesting 
constant 	parts unwrap encoding 
test arenas 	optionally normalize 
bin constant 	meta information utf 
test arenas 	content stuff 
bin constant 	inbody stuff 
test arenas 	beginning diff header 
bin 	cvs index 
constant test 	line filename starts 
arenas lrun 	patches without 
constant test 	headers manual separator 
arenas hchunk 	space followed 
constant mallctl 	filename whitespace mark 
mallctl 	must least 
mallctl test 	bytes even though 
stats arenas 	arbitrary cruft 
test stats 	line cut order 
arenas test 	avoid misidentification 
stats arenas 	perforation must occupy 
test 	third visible 
stats arenas 	width line dashes 
test blind 	scissors must 
read write 	occupy half perforation 
read write 	trim first 
something bin 	blank line 
size 	commit message ignoring 
allocate deallocate 	body headers 
bypass tcache 	normalize log message 
make sure 	utf input 
tcache allocation 	error already may 
returns clean 	already read 
create 	secondary headers purge 
tcaches exercise 	give clean 
tcache recycling 	restart section defines 
flush empty 	loosest possible 
tcaches cache 	field name optional 
allocations verify 	fields optional 
tcaches 	field field name 
allocate cached 	unstructured crlf 
regions verify 	field name ftext 
reallocation uses 	ftext count 
cached regions 	mbox headers headers 
avoid undefined 	first part 
behavior 	line empty 
test failure 	line valid rfc 
flush non 	header stop 
empty tcaches 	header newline need 
destroy tcaches 	eat continuation 
mallocx.c cmd 	lines yuck header 
ret 	folding hit 
cmd ind 	end boundary pop 
ret mib 	current boundary 
miblen ind 	stack technically won 
hugemax size 	happen multipart 
alignment nsz 	boundary fail first 
rsz 	skip next 
nsz rsz 	boundary defaults slurp 
alignment total 	section info 
mallctl nsizes 	replenish line skip 
impl mallctlnametomib 	first boundary 
mallctlbymib size 	process boundary 
impl 	lines flush leftover 
huge size 	unwrap transfer 
nhuge mallocx 	encoding prepend previous 
ptr mallocx 	lines decoded 
dallocx ptr 	line may contain 
mallocx mallocx 	multiple lines 
align 	pass one chunk 
nallocx nallocx 	time handle 
mallocx ptr 	filter last line 
sallocx dallocx 	line save 
mallocx ptr 	later chunk saved 
dallocx nallocx 	prev appended 
mallocx 	next iteration read 
ptr sallocx 	line nul 
dallocx nallocx 	print inbody headers 
mallocx align 	output patch 
mallocx mallocx 	file process email 
align ptr 	header perhaps 
sallocx 	others another 
ptr dallocx 	stupid program one 
test impossible 	parsing headers 
allocate two 	email figure authorship 
objects consume 	subject needswork 
half address 	might want optional 
space 	git directory 
MALLOCX arenac 	discovery mailinfo usage 
dss arg 	argc argv 
ind arena 	prefix def charset 
ind mib 	status setup 
miblen dss 	mailinfo commit output 
precs 	encoding strcmp 
prec ind 	strcmp strcmp strcmp 
dss expected 	strcmp strcmp 
err thds 	starts strcmp strcmp 
mallctl mallctlnametomib 	strcmp usage 
mallctlbymib mallocx 	usage mailinfo clear 
mallocx 	mailinfo john 
arena ptr 	doe johndoe 
dallocx thd 	fallback bother already 
create thd 	mail address 
test math.c 	already one email 
exp gamma 	take confusing 
integer 	lines pick around 
expected gamma 	possibly delimited 
increment expected 	pair email part 
norm increment 	remainder name 
expected chi 	could john doe 
increment expected 	john doe 
gamma 	john doe john 
increment shape 	doe john 
increment max 	zzz doe john 
rel err 	doe comment 
max abs 	removed email part 
err rel 	extra spaces 
err 	could stay email 
ret gamma 	trim ends 
misc expected 	possibly removing 
norm expected 	pair end cases 
chi chi 	note note 
expected gamma 	note claim full 
gamma 	mime attempt 
shape gamma 	enough heuristics grok 
expected shape 	mime encoded 
gamma shape 	patches often found 
shape gamma 	mailing lists 
shape fabs 	example even treat 
fabs 	header lines 
fabs fabs 	insensitively input space 
fabs rel 	keep bother 
exp gamma 	finding end space 
factorial rel 	since later 
gamma rel 	normalize anyway drop 
norm 	trailing newline 
gamma rel 	rfc decode 
chi gamma 	possibly place garbage 
rel gamma 	pessimism process 
gamma rel 	encoded word begins 
gamma gamma 	something encoded 
test 	word lose something 
exp gamma 	unless processed 
integer expected 	encoded word lws 
gamma increment 	one process 
expected norm 	iso foo iso 
increment expected 	foo cbar 
chi 	baz search interesting 
increment expected 	parts unwrap 
gamma increment 	encoding optionally normalize 
shape increment 	meta information 
math.c exp 	utf content stuff 
gamma integer 	inbody stuff 
expected 	beginning diff header 
gamma increment 	cvs index 
expected norm 	line filename 
increment expected 	starts patches without 
chi increment 	headers manual 
expected gamma 	separator space followed 
increment 	filename whitespace 
shape increment 	mark must least 
max rel 	bytes even 
err max 	though arbitrary cruft 
abs err 	line cut 
rel err 	order avoid misidentification 
ret 	perforation must 
gamma misc 	occupy third visible 
expected norm 	width line 
expected chi 	dashes scissors must 
chi expected 	occupy half 
gamma gamma 	perforation trim first 
shape 	blank line 
gamma expected 	commit message ignoring 
shape gamma 	body headers 
shape shape 	normalize log 
gamma shape 	message utf input 
fabs fabs 	error already 
fabs 	may already read 
fabs fabs 	secondary headers 
rel exp 	purge give clean 
gamma factorial 	restart section 
rel gamma 	defines loosest possible 
rel norm 	field name 
gamma 	optional fields optional 
rel chi 	field field 
gamma rel 	name unstructured crlf 
gamma gamma 	field name 
rel gamma 	ftext ftext count 
gamma test 	mbox headers 
exp 	headers first part 
gamma integer 	line empty 
expected gamma 	line valid rfc 
increment expected 	header stop 
norm increment 	header newline 
expected chi 	need eat continuation 
increment 	lines yuck 
expected gamma 	header folding hit 
increment shape 	end boundary 
increment math.h 	pop current boundary 
gamma gamma 	stack technically 
shape scale 	won happen multipart 
gamma 	boundary fail 
shape gamma 	first skip next 
acu factor 	boundary defaults 
oflo gin 	slurp section info 
term dif 	replenish line 
ret gamma 	skip first boundary 
shape 	process boundary 
scale gamma 	lines flush leftover 
shape log 	unwrap transfer 
log exp 	encoding prepend 
log fabs 	previous lines decoded 
fabs fabs 	line may 
sqrt 	contain multiple lines 
log log 	pass one 
pow exp 	chunk time handle 
norm pow 	filter last 
sqrt log 	line line save 
log log 	later chunk 
exp 	saved prev appended 
fabs gamma 	next iteration 
exp log 	read line nul 
fabs chi 	print inbody 
compute natural 	headers output patch 
log gamma 	file process 
accurate 	email header perhaps 
places implementation 	others another 
pike hill 	stupid program one 
algorithm logarithm 	parsing headers 
gamma function 	email figure 
communications acm 	authorship subject needswork 
compute 	might want 
incomplete gamma 	optional git directory 
ratio shape 	discovery mailinfo.c 
parameter gamma 	pos cnt name 
gamma implementation 	email src 
bhattacharjee algorithm 	line bra ket 
incomplete 	line line 
gamma integral 	name attr ends 
applied statistics 	line boundary 
calculation series 	line line line 
expansion calculation 	content top 
continued fraction 	subject pos header 
given 	line hdr 
lower tail 	len line len 
area normal 	sample seg 
distribution compute 	rfc seg acc 
limit definite 	line charset 
integral inf 	dec piecebuf 
satisfies 	found error encoding 
accurate places 	scan line 
implementation wichura 	hdr data overwrite 
algorithm percentage 	len len 
points normal 	line ret line 
distribution applied 	line len 
statistics 	gap first nonblank 
close neither 	visible perforation 
close near 	buf line line 
given lower 	line line 
tail area 	line continuation peek 
chi distribution 	line line 
degrees 	newline line prev 
freedom gamma 	lines fout 
gamma compute 	hdr data len 
upper limit 	hdr msg 
definite integral 	patch cmitmsg peek 
satisfies accurate 	line isspace 
places 	isspace strbuf 
implementation best 	strchr strchr strchr 
roberts algorithm 	strbuf reset 
percentage points 	strbuf addbuf strchr 
chi distribution 	strchr strbuf 
applied statistics 	reset strbuf strbuf 
shea 	reset strbuf 
algorithm remark 	strbuf trim sane 
percentage points 	name strbuf 
chi distribution 	init strbuf addbuf 
applied statistics 	strchr parse 
starting approximation 	bogus strchr strbuf 
small 	release isspace 
chi starting 	strcspn strbuf reset 
approximation wilson 	strbuf strbuf 
hilferty estimate 	cleanup space strbuf 
starting approximation 	trim strbuf 
tending calculation 	strbuf setlen sane 
seven 	name strbuf 
term taylor 	release xmalloc 
series given 	strbuf init strbuf 
gamma distribution 	reset strbuf 
shape scale 	addbuf strcasestr strbuf 
parameters compute 	setlen strlen 
upper 	strcspn strbuf xmalloc 
limit definite 	strbuf init 
integral satisfies 	slurp attr strbuf 
mb.c mb.h 	insert error 
mtx sync 	slurp attr strbuf 
synchronize malloc 	release free 
mutex 	strdup strcasestr strcasestr 
init malloc 	memcmp strbuf 
mutex malloc 	strbuf strchr memmem 
mutex unlock 	strbuf isspace 
jemalloc types 	strbuf trim strlen 
jemalloc structs 	strncasecmp isspace 
jemalloc 	strlen skip 
externs according 	prefix strspn memcmp 
intel architecture 	strlen xmalloc 
software developer 	strbuf init strbuf 
manual current 	addch hexval 
processors execute 	hexval strbuf addch 
instructions 	xmalloc strbuf 
order perspective 	init strbuf addch 
processors multiprocessor 	strbuf addch 
system intel 	strbuf addch encoding 
reserves right 	reencode error 
change compiler 	strbuf attach strlen 
optimizer 	strlen strstr 
could order 	strbuf reset strbuf 
instructions weren 	reset isspace 
form barrier 	strbuf strchr strbuf 
therefore even 	strstr strbuf 
running architecture 	tolower decode segment 
need 	decode segment 
memory barriers 	convert utf 
everything least 	strbuf addbuf strbuf 
optimizer barrier 	release free 
necessary memory 	strbuf addstr strbuf 
barrier outputs 	reset strbuf 
inputs 	addbuf strbuf release 
clobbers hopefully 	strbuf release 
enough keep 	strbuf release strlen 
compiler reordering 	cmp header 
instructions around 	strbuf decode header 
one outputs 	handle header 
inputs 	cmp header strlen 
clobbers outputs 	strbuf decode 
inputs clobbers 	header strbuf insert 
outputs inputs 	handle content 
clobbers outputs 	type cmp header 
inputs clobbers 	strlen strbuf 
much 	decode header handle 
slower simple 	content transfer 
memory barrier 	encoding cmp 
semantics mutex 	header strlen strbuf 
unlock make 	decode header 
work jemalloc 	handle message starts 
inlines 	isspace format 
memtest.c progress 	patch separator starts 
printed progress 	isspace strcmp 
full title 	handle header strbuf 
pass curr 	release decode 
size bytes 	segment decode segment 
interactive 	strbuf reset 
words bytes 	strbuf addbuf strbuf 
interactive step 	release free 
words iwords 	starts starts starts 
rseed rout 	isspace isspace 
bytes sym 	isspace memcmp memcmp 
interactive 	memcmp memcmp 
step words 	check header convert 
iwords bytes 	utf scissors 
interactive words 	line strbuf 
bytes pass 	setlen strbuf release 
times interactive 	patchbreak strbuf 
errors 	addf strbuf addbuf 
bytes passes 	fwrite handle 
interactive pass 	commit msg handle 
errors bytes 	patch starts 
passes backup 	starts strbuf getline 
end left 	strbuf rtrim 
errors 	rfc header strbuf 
pass len 	addch fgetc 
megabytes passes 	ungetc strbuf getline 
bytes megabytes 	strbuf rtrim 
passes fflush 	strbuf addbuf strbuf 
fflush memtest 	release strbuf 
progress 	getline multipart boundary 
step exit 	strbuf addch 
memtest progress 	memcmp strbuf 
step xorshift 	release free error 
star next 	handle filter 
memtest progress 	strbuf release find 
step 	boundary strbuf 
memtest progress 	reset read one 
step exit 	header line 
memtest progress 	check header strbuf 
step memtest 	release strbuf 
progress start 	getline strbuf addch 
memtest 	find boundary 
compare memtest 	strbuf getwholeline multipart 
progress end 	boundary handle 
memtest progress 	filter strbuf reset 
start memtest 	handle boundary 
addressing memtest 	decode transfer encoding 
progress 	strbuf insert 
end memtest 	strbuf reset strbuf 
progress start 	split strbuf 
memtest fill 	addbuf handle 
random memtest 	filter strbuf list 
progress 	free handle 
end memtest 	filter strbuf release 
compare times 	strchr strlen 
memtest progress 	strcmp cleanup subject 
start memtest 	cleanup space 
fill memtest 	output header lines 
progress 	strcmp cleanup 
end memtest 	space handle cleanup 
compare times 	space fopen 
memtest progress 	perror fopen perror 
start memtest 	fclose xcalloc 
fill memtest 	xcalloc isspace fgetc 
progress 	ungetc read 
end memtest 	one header line 
compare times 	check header 
memcpy memtest 	handle body fwrite 
addressing memtest 	fclose fclose 
fill random 	handle info 
memtest 	strbuf release starts 
compare times 	git config 
memtest compare 	strcmp git config 
times memtest 	memset strbuf 
compare times 	init strbuf init 
memtest fill 	strbuf init 
memtest 	strbuf init git 
compare times 	config strbuf 
memtest compare 	release strbuf release 
times memtest 	strbuf release 
compare times 	free strbuf release 
memtest fill 	free strbuf 
memtest 	release free free 
compare times 	strbuf release 
memtest compare 	john doe johndoe 
times memtest 	fallback bother 
compare times 	already mail address 
memcpy malloc 	already one 
strerror 	email take 
exit memtest 	confusing lines pick 
test free 	around possibly 
ioctl memtest 	delimited pair email 
alloc test 	part remainder 
exit copyright 	name could john 
salvatore 	doe john 
sanfilippo antirez 	doe john doe 
gmail dot 	john doe 
rights reserved 	john zzz doe 
redistribution use 	john doe 
source binary 	comment removed email 
forms 	part extra 
without modification 	spaces could stay 
permitted provided 	email trim 
following conditions 	ends possibly removing 
met redistributions 	pair end 
source code 	cases note 
must 	note note claim 
retain copyright 	full mime 
notice list 	attempt enough heuristics 
conditions following 	grok mime 
disclaimer redistributions 	encoded patches often 
binary form 	found mailing 
must 	lists example even 
reproduce copyright 	treat header 
notice list 	lines insensitively input 
conditions following 	space keep 
disclaimer documentation 	bother finding end 
materials provided 	space since 
distribution 	later normalize anyway 
neither name 	drop trailing 
redis names 	newline rfc decode 
contributors may 	possibly place 
used endorse 	garbage pessimism process 
promote products 	encoded word 
derived 	begins something 
software without 	encoded word lose 
specific prior 	something unless 
written permission 	processed encoded word 
software provided 	lws one 
copyright holders 	process iso foo 
contributors 	iso foo 
express implied 	cbar baz search 
warranties including 	interesting parts 
limited implied 	unwrap encoding optionally 
warranties merchantability 	normalize meta 
fitness particular 	information utf content 
purpose 	stuff inbody 
disclaimed shall 	stuff beginning diff 
copyright owner 	header cvs 
contributors liable 	index line filename 
direct indirect 	starts patches 
incidental special 	without headers manual 
exemplary 	separator space 
consequential damages 	followed filename 
including limited 	whitespace mark must 
procurement substitute 	least bytes 
goods services 	even though arbitrary 
loss use 	cruft line 
data 	cut order avoid 
profits business 	misidentification perforation 
interruption however 	must occupy third 
caused theory 	visible width 
liability whether 	line dashes scissors 
contract strict 	must occupy 
liability 	half perforation trim 
tort including 	first blank 
negligence otherwise 	line commit message 
arising way 	ignoring body 
use software 	headers normalize log 
even advised 	message utf 
possibility 	input error already 
damage printed 	may already 
chars screen 	read secondary 
wide progress 	headers purge give 
bar many 	clean restart 
chars write 	section defines loosest 
fill 	possible field 
progress bar 	name optional fields 
cursor home 	optional field 
clear screen 	field name unstructured 
fill dots 	crlf field 
cursor home 	name ftext ftext 
clear 	count mbox 
current line 	headers headers first 
print title 	part line 
cursor home 	empty line valid 
clear screen 	rfc header 
test addressing 	stop header newline 
fine 	need eat 
every location 	continuation lines yuck 
populated address 	header folding 
verified test 	hit end 
fast may 	boundary pop current 
detect asap 	boundary stack 
big 	technically won happen 
issues memory 	multipart boundary 
subsystem fill 	fail first skip 
test fill 	next boundary 
words stepping 	defaults slurp section 
single page 	info replenish 
every 	line skip first 
write touch 	boundary process 
pages smallest 	boundary lines flush 
amount time 	leftover unwrap 
reducing effectiveness 	transfer encoding prepend 
caches making 	previous lines 
hard 	decoded line may 
transfer pages 	contain multiple 
swap test 	lines pass 
call rand 	one chunk time 
since system 	handle filter 
may completely 	last line line 
unable 	save later 
handle library 	chunk saved prev 
calls resort 	appended next 
prng uses 	iteration read line 
local state 	nul print 
use xorshift 	inbody headers output 
prng 	patch file 
words per 	process email header 
iteration random 	perhaps others 
seed like 	another stupid program 
memtest fill 	one parsing 
random uses 	headers email figure 
two 	authorship subject 
specified values 	needswork might want 
fill memory 	optional git 
alternated way 	directory discovery 
words per 	mailinfo usage argc 
iteration test 	argv prefix 
specified 	def charset status 
memory number 	setup mailinfo 
bytes must 	commit output encoding 
multiple interactive 	strcmp strcmp 
program exists 	strcmp strcmp strcmp 
error prints 	strcmp starts 
ascii 	strcmp strcmp strcmp 
arts show 	usage usage 
progresses instead 	mailinfo clear mailinfo 
interactive used 	john doe 
api call 	johndoe fallback bother 
returns memory 	already mail 
errors 	address already one 
found errors 	email take 
detected version 	confusing lines pick 
memtest test 	around possibly 
tests memory 	delimited pair 
small pieces 	email part remainder 
order 	name could 
restore memory 	john doe john 
content exit 	doe john 
one problem 	doe john doe 
approach cache 	john zzz 
avoid real 	doe john doe 
memory 	comment removed 
accesses test 	email part extra 
big chunks 	spaces could 
memory time 	stay email trim 
need backup 	ends possibly 
stack allocator 	removing pair end 
may 	cases note 
usable may 	note note claim 
already memory 	full mime 
condition trash 	attempt enough heuristics 
cache useless 	grok mime 
memory accesses 	encoded patches 
fill 	often found mailing 
compare cycles 	lists example 
random accesses 	even treat header 
memtest decache 	lines insensitively 
size performed 	input space keep 
start end 	bother finding 
region 	end space since 
fill compare 	later normalize 
cycles order 	anyway drop trailing 
trash cache 	newline rfc 
test across 	decode possibly place 
page boundaries 	garbage pessimism 
test 	process encoded word 
single page 	begins something 
test single 	encoded word lose 
page back 	something unless 
single page 	processed encoded 
test two 	word lws one 
pages 	process iso 
since code 	foo iso foo 
test single 	cbar baz 
page least 	search interesting parts 
two always 	unwrap encoding 
test even 	optionally normalize meta 
number 	information utf 
pages backup 	content stuff inbody 
restore perform 	stuff beginning 
interactive test 	diff header cvs 
allocating specified 	index line 
number megabytes 	filename starts patches 
microbench.c 	without headers 
timer nwarmup 	manual separator space 
niter func 	followed filename 
compare funcs 	whitespace mark must 
func timer 	least bytes 
start func 	even though 
timer 	arbitrary cruft line 
stop malloc 	cut order 
test fail 	avoid misidentification perforation 
free mallocx 	must occupy 
test fail 	third visible width 
free compare 	line dashes 
funcs 	scissors must occupy 
malloc test 	half perforation 
fail dallocx 	trim first blank 
malloc test 	line commit 
fail sdallocx 	message ignoring body 
compare funcs 	headers normalize 
compare 	log message utf 
funcs malloc 	input error 
test fail 	already may already 
malloc usable 	read secondary 
size free 	headers purge give 
malloc test 	clean restart 
fail 	section defines 
sallocx test 	loosest possible field 
fail free 	name optional 
compare funcs 	fields optional field 
malloc test 	field name 
fail nallocx 	unstructured crlf field 
test 	name ftext 
fail free 	ftext count mbox 
compare funcs 	headers headers 
test compiler 	first part line 
optimize away 	empty line 
free malloc 	valid rfc header 
min.c 	stop header 
lua gettop 	newline need eat 
lua isstring 	continuation lines 
lua tostring 	yuck header folding 
lua isnil 	hit end 
lua isboolean 	boundary pop current 
lua 	boundary stack 
toboolean lua 	technically won 
lua topointer 	happen multipart boundary 
lua open 	fail first 
lua lua 	skip next boundary 
dofile lua 	defaults slurp 
tostring 	section info replenish 
lua close 	line skip 
min minimal 	first boundary process 
lua interpreter 	boundary lines 
loads stdin 	flush leftover unwrap 
minimal error 	transfer encoding 
handling 	prepend previous lines 
interaction standard 	decoded line 
library print 	may contain multiple 
function mq.c 	lines pass 
timeout sleep 	one chunk time 
nanosleep sleep 	handle filter 
approximately 	last line 
nanoseconds lower 	line save later 
upper bound 	chunk saved 
sleep time 	prev appended next 
guaranteed msg 	iteration read 
arg msg 	line nul print 
arg 	inbody headers 
msg receiver 	output patch file 
senders init 	process email 
count ptr 	header perhaps others 
tryget put 	another stupid 
count ptr 	program one parsing 
tryget 	headers email 
put ptr 	figure authorship subject 
fini ptr 	needswork might 
dallocx mallocx 	want optional git 
ptr put 	directory discovery 
init thd 	mailinfo.h input output 
create 	patchfile name 
thd create 	email keep 
thd thd 	subject keep non 
fini test 	patch brackets 
sleep approximately 	subject message use 
nanoseconds lower 	scissors use 
upper 	inbody headers metainfo 
bound sleep 	charset content 
time guaranteed 	content top charset 
mq.c timeout 	message patch 
sleep nanosleep 	lines filter stage 
sleep approximately 	header stage 
nanoseconds 	hdr data hdr 
lower upper 	data log 
bound sleep 	message input error 
time guaranteed 	mailinfo mailinfo 
msg arg 	msg patch mailinfo 
msg arg 	still reading 
msg 	log copying patch 
receiver senders 	still checking 
init count 	body headers 
ptr tryget 	mailinfo mailmap.c format 
put count 	git mailmap 
ptr tryget 	file git mailmap 
put 	blob name 
ptr fini 	email name email 
ptr dallocx 	namemap map 
mallocx ptr 	name email old 
put init 	name old 
thd create 	email item buffer 
thd 	name email 
create thd 	allow empty email 
thd fini 	left right 
test sleep 	nstart nend map 
approximately nanoseconds 	buffer repo 
lower upper 	abbrev email abbrev 
bound 	abblen len 
sleep time 	map filename repo 
guaranteed mq.h 	abbrev buffer 
simple templated 	map buf 
message queue 	repo abbrev end 
implementation relies 	map name 
mutexes 	repo abbrev sha 
synchronization reduces 	buf size 
portability issues 	map repo abbrev 
given following 	err map 
setup msg 	map len cmp 
msg msg 	map email 
msg 	emaillen name namelen 
msg link 	item subitem 
message data 	debug debug str 
gen msg 	debug str 
link api 	free free debug 
follows init 	debug debug 
fini 	str debug str 
count msg 	free free 
tryget msg 	list clear func 
put msg 	strcasecmp list 
msg message 	insert xcalloc 
queue linkage 	debug free xstrdup 
embedded 	free xstrdup 
message treated 	xcalloc debug xstrdup 
externally opaque 	xstrdup list 
need initialize 	insert debug debug 
clean externally 	str debug 
fini perform 	str debug str 
cleanup 	strchr strchr 
messages since 	isspace isspace strlen 
knows nothing 	strncmp free 
payloads sleep 	isspace xstrdup parse 
time max 	name email 
second mtx.c 	parse name email 
mtx 	mapping fopen 
attr mtx 	error strerror fgets 
mtx mtx 	read mailmap 
initialize critical 	line fclose 
section spin 	strchrnul read mailmap 
count pthread 	line sha 
mutexattr 	read sha file 
init pthread 	error error 
mutexattr settype 	read mailmap free 
pthread mutex 	bare repository 
init pthread 	read mailmap file 
mutexattr destroy 	read mailmap 
pthread 	blob read mailmap 
mutexattr destroy 	file debug 
pthread mutex 	list clear func 
destroy enter 	debug list 
critical section 	find insert index 
spin pthread 	strncasecmp debug 
mutex 	debug str debug 
critical section 	str lookup 
spin unlock 	prefix lookup prefix 
pthread mutex 	debug strlen 
unlock mtx 	strlen debug 
varg arg 	debug str debug 
arg 	str debug 
thds mtx 	name email simple 
init mtx 	mail name 
mtx unlock 	email complex mail 
mtx fini 	name matching 
mtx mtx 	systems min definition 
unlock 	strcasecmp non 
mtx init 	implementation supplied anywhere 
thd create 	unusual cannot 
thd test 	take address function 
mtx.c mtx 	store namemap 
attr mtx 	cmp workaround assign 
mtx 	strcasecmp directly 
mtx initialize 	namemap cmp know 
critical section 	systems matter 
spin count 	unusual replace current 
pthread mutexattr 	name email 
init pthread 	simple entry 
mutexattr 	whitespace beginning end 
settype pthread 	name nothing 
mutex init 	look entry map 
pthread mutexattr 	match len 
destroy pthread 	len nul could 
mutexattr 	exact match 
destroy pthread 	map entry matches 
mutex destroy 	exactly including 
enter critical 	cruft end beyond 
section spin 	len match 
pthread mutex 	len looking asked 
critical 	whole got 
section spin 	nothing matching entry 
unlock pthread 	exist map 
mutex unlock 	exact match overlong 
mtx varg 	key location 
arg arg 	overlong key would 
thds 	inserted must 
mtx init 	come real 
mtx mtx 	location key one 
unlock mtx 	exists points 
fini mtx 	key definitely prefix 
mtx unlock 	map len 
mtx 	found otherwise may 
init thd 	len followed 
create thd 	sorts later len 
test mtx.h 	keep trying 
mtx mtx 	item multiple items 
mtx mtx 	look name 
mtx 	name found choose 
slightly simplified 	simple entry 
version malloc 	mailmap.h map repo 
mutex code 	abbrev map 
duplication unfortunate 	map email emaillen 
allocator bootstrapping 	name namelen 
considerations 	mailsplit.c git 
would leak 	mailsplit usage line 
test infrastructure 	len colon 
malloc mutex 	buf keep mbox 
used directly 	name allow 
tests multi.c 	bare output status 
multistring 	bare list 
orig argv 	path dir dent 
orig argc 	name subs 
orig cmd 	sub ret maildir 
must propagate 	dir prec 
key clients 	skip file ret 
clients 	list name 
key clients 	file dir allow 
dbid decr 	bare prec 
count zfree 	skip ret peek 
zfree zrealloc 	file done 
zmalloc memcpy 	name argc argv 
incr 	prefix num 
count free 	allow bare 
client multi 	dir argp stdin 
state init 	arg arg 
client multi 	argstat ret memcmp 
state unwatch 	isdigit isdigit 
keys 	isdigit isdigit isdigit 
reply error 	strtol line 
reply reply 	exit open die 
error discard 	errno xfdopen 
transaction reply 	strbuf setlen strbuf 
create propagate 	addch fwrite 
decr 	die errno strbuf 
count reply 	getwholeline feof 
error reply 	die errno line 
discard transaction 	fclose free 
unwatch keys 	xstrfmt opendir error 
reply multi 	strerror readdir 
bulk 	free xstrfmt list 
len exec 	insert closedir 
command propagate 	free isdigit 
multi call 	isdigit strtol strtol 
discard transaction 	populate maildir 
list length 	list free xstrfmt 
replication 	fopen error 
feed monitors 	strerror strbuf getwholeline 
list rewind 	error strerror 
list next 	xstrfmt split one 
list node 	free fclose 
equal objects 	fclose free list 
dict 	clear strcmp 
fetch list 	fopen error isspace 
create dict 	fgetc ungetc 
incr count 	strbuf getwholeline error 
list node 	xstrfmt split 
tail zmalloc 	one free fclose 
incr 	strtol usage 
count list 	strtol usage strcmp 
node tail 	die usage 
list length 	split mbox 
list rewind 	error stat error 
list next 	strerror isdir 
list 	split maildir split 
node dict 	mbox error 
fetch server 	totally braindamaged mbox 
info list 	splitter program 
del node 	splits mbox list 
list search 	files process 
key 	year close enough 
list length 	called first 
dict list 	line potentially already 
del node 	buf normally 
decr count 	begin unix line 
zfree dict 	write specified 
size 	file copy searching 
dict fetch 	line begins 
list rewind 	something looks 
list next 	like date format 
list node 	done one 
list rewind 	message strtol advanced 
list 	pointers empty 
next list 	stdin flags marks 
node list 	end options 
rewind list 	backwards compatibility specified 
next list 	accept mbox 
node dict 	dir dir usage 
find 	argument parse 
reply error 	stdin malloc.c.h arena 
watch key 	ordblks smblks 
reply unwatch 	hblks hblkhd usmblks 
keys reply 	fsmblks uordblks 
copyright salvatore 	fordblks keepcost capacity 
sanfilippo 	locked msp 
antirez gmail 	capacity locked msp 
dot rights 	enable msp 
reserved redistribution 	bytes msp 
use source 	mem msp mem 
binary forms 	newsize msp 
without 	elements elem size 
modification permitted 	msp alignment 
provided following 	bytes msp elements 
conditions met 	elem size 
redistributions source 	chunks msp elements 
code must 	sizes chunks 
retain 	msp msp msp 
copyright notice 	mem msp 
list conditions 	msp pad dest 
following disclaimer 	exchange comp 
redistributions binary 	target getpagesize dev 
form must 	zero size 
reproduce 	ptr size ptr 
copyright notice 	ptr size 
list conditions 	minfo cptr threadid 
following disclaimer 	malloc mutex 
documentation materials 	spins cmp 
provided distribution 	val ret prev 
neither 	ret cmp 
name redis 	val ret threadid 
names contributors 	malloc mutex 
may used 	threadstruct threadid spins 
endorse promote 	malloc mutex 
products derived 	attr malloc mutex 
software 	malloc mutex 
without specific 	status stat prev 
prior written 	foot head 
permission software 	prev foot head 
provided copyright 	child parent 
holders contributors 	index size next 
express 	sflags smallmap 
implied warranties 	treemap dvsize topsize 
including limited 	least addr 
implied warranties 	top trim check 
merchantability fitness 	release checks 
particular purpose 	magic smallbins 
disclaimed 	treebins footprint max 
shall copyright 	footprint mflags 
owner contributors 	mutex seg extp 
liable direct 	exts magic 
indirect incidental 	page size granularity 
special exemplary 	mmap threshold 
consequential 	trim threshold mflags 
damages including 	mparams addr 
limited procurement 	malloc corruption error 
substitute goods 	count mem 
services loss 	magic psize gsize 
use data 	system info 
profits 	buf param number 
business interruption 	val len 
however caused 	next mem head 
theory liability 	tindex tsize 
whether contract 	idx empty empty 
strict liability 	size size 
tort 	sidx tidx 
including negligence 	sizebits sum lastq 
otherwise arising 	total nfree 
way use 	mfree sum maxfp 
software even 	used mmsize 
advised possibility 	offset psize oldp 
damage 	oldsize offset 
multi exec 	oldmmsize newmmsize newp 
client state 	psize psize 
initialization multi 	offset bin newbase 
exec release 	oldbase oldfirst 
resources associated 	psize qsize tsize 
multi 	dsize nsize 
exec state 	tbase tsize mmapped 
command multi 	old top 
commands queue 	oldsp old end 
flag transacation 	ssize rawsp 
dirty exec 	offset asp 
exec 	csp tnext nfences 
fail called 	nextp psize 
every time 	tbase tsize mmap 
error queueing 	flag mem 
command send 	asize esize end 
multi command 	rsize asize 
slaves 	end ssize oldbase 
aof file 	rsize released 
check exec 	nsegs pred size 
command implementation 	next psize 
information need 	pad released unit 
propagate multi 	extra newsize 
exec 	old rel rsize 
aof slaves 	idx sizebits 
check need 	rst trem leftbits 
abort exec 	leastbit trem 
watc hed 	rsize leastbit trem 
key touched 	oldmem bytes 
previous 	oldp oldsize 
error queueing 	next newp extra 
commands failed 	rsize remainder 
exec first 	newsize newtopsize newtop 
returns multi 	newmem alignment 
bulk nil 	bytes req mem 
technically 	leader trailer 
error special 	pos newp leadsize 
behavior second 	newsize size 
execabort error 	remainder size remainder 
returned exec 	elements sizes 
queued commands 	opts chunks element 
unwatch 	size contents 
asap otherwise 	size size mem 
waste cpu 	remainder size 
cycles propagate 	marray chunk enabled 
multi request 	size chunk 
encounter first 	size bytes mem 
write 	idx smallbits 
way deliver 	rsize leftbits 
multi exec 	leastbit rsize dvs 
block whole 	rsize mem 
aof replication 	psize next prevsize 
link consistency 	prev tsize 
atomicity 	dsize nsize elements 
guarantees commands 	elem size 
may alter 	mem req oldmem 
argc argv 	bytes alignment 
restore mstate 	bytes elements elem 
make sure 	size chunks 
exec 	elements sizes chunks 
command propagated 	bytes pagesz 
well multi 	bytes pagesz pad 
already propagated 	result param 
send exec 	number mem tbase 
clients waiting 	tsize msize 
data 	msp capacity locked 
monitor since 	msize tsize 
natural order 	tbase capacity 
commands execution 	locked msize msp 
actually mutli 	enable ret 
exec commands 	msp freed size 
inside 	flag msp 
transaction instead 	bytes mem idx 
exec flagged 	smallbits rsize 
cmd skip 	leftbits leastbit rsize 
monitor command 	dvs rsize 
table correct 	msp mem psize 
ordering 	next prevsize 
watch cas 	prev tsize dsize 
alike multi 	nsize msp 
exec implementation 	elements elem size 
uses per 	mem req 
hash table 	msp oldmem bytes 
mapping 	msp alignment 
keys list 	bytes msp 
clients watc 	elements elem size 
hing keys 	chunks msp 
given key 	elements sizes chunks 
going modified 	msp pad 
mark 	result msp msp 
associated clients 	result msp 
dirty also 	result msp mem 
every client 	param number 
contains list 	alloc alloc query 
watc hed 	free thr 
keys 	sched readfsdword current 
possible watch 	current current 
keys client 	interlockedexchange sleep interlockedexchange 
freed unwatch 	interlockedexchange pthread 
called client 	mutexattr init pthread 
watched keys 	mutexattr settype 
list 	pthread mutex init 
need use 	pthread mutexattr 
watched key 	destroy interlockedcompareexchange 
structures order 	initialize critical section 
identify key 	interlockedexchange sleep 
redis need 	init malloc mutex 
key 	acquire malloc 
name watch 	system info initial 
specified key 	open read 
check already 	close size tick 
watching key 	count size 
key already 	time release malloc 
watched 	ensure initialization 
key already 	aligned chunk mem 
watched key 	address segment 
list keys 	holding aligned chunk 
watched client 	mem address 
unwatch keys 	pinuse pinuse chunk 
watched 	plus offset 
client clean 	chunksize mmapped use 
exec dirty 	mmap aligned 
flag caller 	chunk mem 
lookup watched 	address small chunk 
key clients 	plus offset 
list 	chunk plus offset 
client list 	check chunk 
kill entry 	cinuse next pinuse 
client watched 	mmapped pinuse 
key client 	next chunk prev 
watched list 	chunk mmapped 
touch 	check mmapped chunk 
key key 	chunksize chunk 
watc hed 	plus offset check 
client next 	chunk cinuse 
exec fail 	next pinuse mmapped 
mark clients 	aligned chunk 
watching 	mem pinuse cinuse 
key client 	mem chunk 
dirty cas 	check inuse chunk 
check already 	mmapped chunksize 
watching key 	compute index 
flushdb flushall 	minsize index minsize 
watched 	index check 
keys present 	chunk chunksize cinuse 
flush deleted 	next pinuse 
effect flushing 	check check chunksize 
operation touched 	chunksize treebin 
dbid getting 	check smallbin chunksize 
flush 	check free 
flushall operation 	chunk small index 
flushed every 	chunksize chunksize 
client check 	next chunk check 
waited keys 	inuse chunk 
every watched 	chunksize small small 
key 	index smallbin 
matching specified 	smallmap marked compute 
key exists 	index treemap 
mark client 	marked treebin 
dirty key 	leftshift index chunksize 
removed mutex.c 	initialized align 
isthreaded 	chunk pinuse segment 
postpone init 	holds chunksize 
postponed mutexes 	cinuse bin find 
restrict pthread 	check inuse 
attr restrict 	chunk bin find 
attr start 	cinuse check 
routine 	free chunk next 
arg control 	chunk check 
mutex calloc 	smallbin check treebin 
mutex attr 	check chunk 
mutex mutex 	chunksize bin find 
mutex dlsym 	check top 
malloc 	chunk bin find 
write abort 	traverse check 
pthread pthread 	ensure initialization preaction 
create fptr 	check malloc 
initialize srw 	state initialized 
initialize critical 	align chunk segment 
section 	holds chunksize 
spin count 	cinuse next chunk 
pthread mutex 	postaction ensure 
init calloc 	initialization preaction check 
pthread mutexattr 	malloc state 
init pthread 	initialized align chunk 
mutexattr 	segment holds 
settype pthread 	cinuse chunksize next 
mutex init 	chunk postaction 
pthread mutexattr 	mmap align call 
destroy pthread 	direct mmap 
mutexattr destroy 	align offset chunk 
malloc 	mem mchunkptr 
mutex malloc 	mark inuse foot 
mutex unlock 	chunk plus 
malloc mutex 	offset chunk plus 
unlock malloc 	offset aligned 
mutex init 	chunk mem 
malloc 	check mmapped chunk 
abort pthread 	chunk mem 
mutex init 	chunksize small mmap 
calloc data 	align call 
intercept pthread 	mremap mchunkptr mark 
create calls 	inuse foot 
order 	chunk plus offset 
toggle isthreaded 	chunk plus 
process goes 	offset check mmapped 
multi threaded 	chunk align 
mutex.h postponed 	offset chunk mem 
next isthreaded 	mchunkptr chunk 
mutex 	plus offset smallbin 
mutex mutex 	treebin init 
mutex mutex 	bins align chunk 
mutex mutex 	align chunk 
mutex acquire 	chunk plus offset 
srw exclusive 	size pinuse 
enter 	inuse chunk 
critical section 	pinuse check top 
spin pthread 	chunk size 
mutex release 	pinuse free chunk 
srw exclusive 	cinuse chunksize 
critical section 	unlink chunk chunk 
spin 	plus offset 
unlock pthread 	free pinuse insert 
mutex unlock 	chunk check 
jemalloc types 	free chunk check 
jemalloc structs 	malloced chunk 
undo definition 	chunk mem chunk 
jemalloc 	mem segment 
externs jemalloc 	holding pad request 
inlines net.c 	align offset 
type str 	chunk mem msegmentptr 
type prefix 	chunk mem 
buf len 	chunk plus offset 
type 	init top 
blocking flags 	aligned size 
interval val 	pinuse inuse chunk 
yes timeout 	chunk plus 
wfd msec 	offset chunk plus 
res err 	offset free 
errlen 	pinuse insert chunk 
addr port 	check top 
timeout source 	chunk ensure initialization 
addr port 	use mmap 
hints servinfo 	mmap alloc use 
bservinfo blocking 	noncontiguous segment 
bound 	holding acquire malloc 
buf buf 	call morecore 
buf addr 	granularity align page 
port timeout 	aligned page 
addr port 	align call morecore 
timeout 	granularity align 
source addr 	call morecore 
path timeout 	granularity align call 
blocking close 	morecore call 
snprintf strerror 	morecore disable contiguous 
redis error 	release malloc 
setsockopt 	granularity align call 
redis error 	mmap granularity 
errno redis 	align acquire malloc 
context close 	call morecore 
socket redis 	call morecore release 
error errno 	malloc initialized 
redis 	init bins init 
reuse addr 	top next 
fcntl redis 	chunk mem chunk 
error errno 	init top 
redis context 	size segment segment 
close fcntl 	holds init 
redis 	top segment prepend 
error errno 	alloc segment 
redis context 	chunk plus 
close setsockopt 	offset size pinuse 
redis error 	inuse chunk 
strerror setsockopt 	check top chunk 
redis 	check malloced 
error strerror 	chunk chunk mem 
setsockopt redis 	chunk mem 
error strerror 	mmapped segment segment 
setsockopt redis 	align chunk 
error strerror 	chunksize cinuse segment 
setsockopt 	holds unlink 
redis error 	large chunk call 
strerror setsockopt 	munmap insert 
redis error 	large chunk ensure 
errno redis 	initialization initialized 
context close 	segment holding segment 
redis 	mmapped segment 
error errno 	segment link call 
redis context 	mremap call 
close poll 	munmap acquire 
redis error 	malloc call morecore 
errno redis 	call morecore 
context 	call morecore release 
close redis 	malloc init 
error errno 	top check top 
redis context 	chunk release 
close redis 	unused segments compute 
check socket 	index treebin 
error 	leftshift index chunksize 
redis error 	left bits 
errno redis 	idx bit least 
context close 	bit compute 
getsockopt redis 	bit idx treebin 
error errno 	chunksize leftmost 
redis 	child size rtcheck 
error errno 	address chunk 
setsockopt redis 	plus offset chunksize 
error errno 	rtcheck next 
setsockopt redis 	unlink large 
error errno 	chunk inuse pinuse 
snprintf 	size pinuse 
memset getaddrinfo 	inuse chunk size 
getaddrinfo redis 	pinuse free 
error gai 	chunk insert chunk 
strerror socket 	chunk mem 
redis blocking 	corruption error action 
getaddrinfo 	least bit 
snprintf gai 	compute bit idx 
strerror redis 	treebin chunksize 
error bind 	leftmost child chunksize 
freeaddrinfo snprintf 	rtcheck address 
strerror redis 	chunk plus offset 
error 	chunksize rtcheck 
connect redis 	next unlink large 
context close 	chunk inuse 
redis context 	pinuse size 
wait ready 	pinuse inuse chunk 
redis blocking 	size pinuse 
redis 	free chunk replace 
tcp delay 	chunk mem 
snprintf strerror 	corruption error action 
redis error 	preaction mem 
freeaddrinfo redis 	chunk chunksize chunk 
context connect 	plus offset 
tcp 	rtcheck address cinuse 
redis context 	next pinuse 
connect tcp 	request size mmapped 
redis create 	mmap resize 
socket redis 	chunk plus offset 
blocking strncpy 	inuse inuse 
connect 	chunk mem chunk 
redis context 	plus offset 
wait ready 	inuse usage error 
redis blocking 	action postaction 
extracted anet 	postaction free 
work properly 	check inuse chunk 
hiredis 	chunk mem 
error reporting 	malloc overhead memcpy 
copyright salvatore 	free malloc 
sanfilippo antirez 	request size malloc 
gmail dot 	mem chunk 
copyright pieter 	preaction size mem 
noordhuis 	chunk size 
pcnoordhuis gmail 	size size chunksize 
dot rights 	mmapped inuse 
reserved redistribution 	inuse chunk mem 
use source 	mmapped chunksize 
binary forms 	chunk plus offset 
without 	inuse inuse 
modification permitted 	chunk mem chunksize 
provided following 	size chunk 
conditions met 	mem check inuse 
redistributions source 	chunk postaction 
code must 	free free 
retain 	chunk mem ensure 
copyright notice 	initialization malloc 
list conditions 	request size request 
following disclaimer 	size request 
redistributions binary 	size use mmap 
form must 	disable mmap 
reproduce 	malloc enable mmap 
copyright notice 	preaction mem 
list conditions 	chunk chunksize mmapped 
following disclaimer 	memset chunk 
documentation materials 	plus offset chunk 
provided distribution 	mem size 
neither 	pinuse inuse chunk 
name redis 	chunk mem 
names contributors 	request size size 
may used 	pinuse inuse 
endorse promote 	chunk chunk plus 
products derived 	offset size 
software 	pinuse inuse 
without specific 	chunk request size 
prior written 	check inuse 
permission software 	chunk mem chunk 
provided copyright 	check inuse 
holders contributors 	chunk mem chunk 
express 	postaction ensure 
implied warranties 	initialization preaction pad 
including limited 	request small 
implied warranties 	index smallbin chunksize 
merchantability fitness 	small index 
particular purpose 	size unlink first 
disclaimed 	small chunk 
shall copyright 	inuse pinuse small 
owner contributors 	index size 
liable direct 	chunk mem check 
indirect incidental 	malloced chunk 
special exemplary 	left bits 
consequential 	idx bit least 
damages including 	bit compute 
limited procurement 	bit idx smallbin 
substitute goods 	chunksize small 
services loss 	index size unlink 
use data 	first small 
profits 	chunk small index 
business interruption 	size inuse 
however caused 	pinuse small index 
theory liability 	size size 
whether contract 	pinuse inuse chunk 
strict liability 	chunk plus 
tort 	offset size pinuse 
including negligence 	free chunk 
otherwise arising 	replace chunk mem 
way use 	check malloced 
software even 	chunk tmalloc small 
advised possibility 	check malloced 
damage 	chunk pad 
defined hiredis 	request tmalloc large 
socket nonblocking 	check malloced 
note fcntl 	chunk chunk plus 
getfl setfl 	offset size 
interrupted signal 	pinuse free chunk 
use 	size pinuse 
timeout strlen 	inuse chunk inuse 
address found 	pinuse chunk 
order since 	mem check malloced 
redis client 	chunk chunk 
afford test 	plus offset size 
connectivity 	pinuse inuse 
would latency 	chunk chunk mem 
every connect 	check top 
otherwise sensible 	chunk check malloced 
route could 	chunk sys 
use addresses 	alloc postaction mem 
available 	chunk mstate 
connectivity getaddrinfo 	magic usage 
saves self 	error action preaction 
determining need 	check inuse 
redis alright 	chunk rtcheck address 
reset socket 	cinuse chunksize 
blocking 	chunk plus offset 
connect net.h 	pinuse call 
addr port 	munmap chunk minus 
timeout addr 	offset rtcheck 
port timeout 	address unlink chunk 
source addr 	free pinuse 
path 	rtcheck next pinuse 
timeout interval 	cinuse trim 
extracted anet 	sys trim size 
work properly 	pinuse free 
hiredis error 	chunk chunksize unlink 
reporting copyright 	chunk size 
salvatore 	pinuse free chunk 
sanfilippo antirez 	free pinuse 
gmail dot 	small insert 
copyright pieter 	small chunk check 
noordhuis pcnoordhuis 	free chunk 
gmail dot 	insert large chunk 
rights 	check free 
reserved redistribution 	chunk release unused 
use source 	segments usage 
binary forms 	error action postaction 
without modification 	dlmalloc calloc 
permitted provided 	must clear mem 
following 	chunk memset 
conditions met 	dlmalloc dlfree mstate 
redistributions source 	mem chunk 
code must 	magic usage error 
retain copyright 	action realloc 
notice list 	memalign ialloc ialloc 
conditions 	ensure initialization 
following disclaimer 	dlmemalign ensure initialization 
redistributions binary 	dlmemalign ensure 
form must 	initialization preaction 
reproduce copyright 	sys trim postaction 
notice list 	mallinfo malloc 
conditions 	stats change mparam 
following disclaimer 	mem chunk 
documentation materials 	cinuse chunksize overhead 
provided distribution 	pad request 
neither name 	align chunk mstate 
redis names 	chunk mem 
contributors 	memset initial disable 
may used 	contiguous init 
endorse promote 	bins next chunk 
products derived 	mem chunk 
software without 	init top size 
specific prior 	check top 
written 	chunk ensure initialization 
permission software 	pad request 
provided copyright 	granularity align 
holders contributors 	call mmap init 
express implied 	user mstate 
warranties including 	ensure initialization pad 
limited 	request init 
implied warranties 	user mstate preaction 
merchantability fitness 	use mmap 
particular purpose 	enable mmap disable 
disclaimed shall 	mmap postaction 
copyright owner 	magic call munmap 
contributors 	usage error 
liable direct 	action magic usage 
indirect incidental 	error action 
special exemplary 	preaction pad request 
consequential damages 	small index 
including limited 	smallbin chunksize small 
procurement 	index size 
substitute goods 	unlink first small 
services loss 	chunk inuse 
use data 	pinuse small 
profits business 	index size chunk 
interruption however 	mem check 
caused 	malloced chunk left 
theory liability 	bits idx 
whether contract 	bit least bit 
strict liability 	compute bit 
tort including 	idx smallbin chunksize 
negligence otherwise 	small index 
arising 	size unlink first 
way use 	small chunk 
software even 	small index size 
advised possibility 	inuse pinuse 
damage networking.c 	small index size 
pos reply 	size pinuse 
cur 	inuse chunk chunk 
len available 	plus offset 
tail tail 	size pinuse free 
len tail 	chunk replace 
obj buf 	chunk mem 
len len 	check malloced chunk 
len 	tmalloc small 
err fmt 	check malloced chunk 
len status 	pad request 
fmt node 	tmalloc large check 
length len 	malloced chunk 
next dbuf 	chunk plus offset 
sbuf 	size pinuse 
dlen slen 	free chunk size 
prefix buf 	pinuse inuse 
len length 	chunk inuse pinuse 
obj len 	chunk mem 
obj len 	check malloced chunk 
buf 	chunk plus 
len dst 	offset size pinuse 
src flags 	inuse chunk 
err err 	chunk mem check 
privdata mask 	top chunk 
cport cfd 	check malloced 
max 	chunk sys alloc 
cip privdata 	postaction mem 
mask cfd 	chunk mstate magic 
max handler 	usage error 
installed totwritten 	action preaction check 
objlen objmem 	inuse chunk 
privdata 	rtcheck address cinuse 
mask processed 	chunksize chunk 
prevcmd newline 	plus offset pinuse 
argc argv 	call munmap 
aux querylen 	chunk minus offset 
pos client 	rtcheck address 
newline 	unlink chunk free 
qblen privdata 	pinuse rtcheck 
mask nread 	next pinuse cinuse 
readlen qblen 	trim sys 
remaining bytes 	trim size 
longest output 	pinuse free chunk 
list 	chunksize unlink 
biggest input 	chunk size pinuse 
buffer bib 	free chunk 
client peerid 	free pinuse small 
peerid len 	insert small 
peerid client 	chunk check free 
flags 	chunk insert 
events emask 	large chunk check 
client client 	free chunk 
addr type 	release unused segments 
skipme close 	usage error 
client moreargs 	action postaction magic 
tmp 	usage error 
len duration 	action malloc calloc 
argc argv 	must clear 
argc argv 	mem chunk memset 
newval oldval 	mspace malloc 
list item 	mspace free 
size 	mem chunk mstate 
name used 	magic usage 
mem elapsed 	error action realloc 
client slave 	magic usage 
events end 	error action memalign 
iterations count 	magic usage 
events 	error action ialloc 
sds alloc 	magic usage 
ptr zmalloc 	error action ialloc 
size server 	magic preaction 
info sds 	sys trim postaction 
zmalloc size 	usage error 
zmalloc 	action magic malloc 
size incr 	stats usage 
count equal 	error action magic 
objects zmalloc 	usage error 
anet non 	action magic usage 
block anet 	error action 
enable 	magic usage 
tcp delay 	error action mallinfo 
anet keep 	mem chunk 
alive create 	cinuse chunksize overhead 
file close 	change mparam 
zfree sdsempty 	version aka dlmalloc 
list 	malloc free 
create list 	realloc written doug 
free method 	lea released 
list dup 	domain explained http 
method dict 	creativecommons licenses 
create list 	publicdomain send questions 
create 	comments complaints 
dict create 	performance data etc 
list create 	oswego edu 
list free 	version pre mon 
method list 	nov gee 
match method 	note may updated 
list 	version malloc 
node tail 	obtainable ftp 
init client 	gee oswego edu 
multi state 	pub misc 
client pending 	malloc check installing 
replies list 	quickstart library 
node 	one file simplify 
head server 	common usage 
list length 	ftp compile link 
list last 	another program 
list node 	compile time options 
dup decr 	reasonable values 
count 	use platforms might 
list node 	later want 
list node 	step various compile 
list length 	time tuning 
memcpy list 	options convenience include 
length incr 	file code 
count 	malloc ftp 
list node 	gee oswego edu 
tail sds 	pub misc 
used memory 	malloc really need 
list node 	file unless 
list last 	call functions defined 
sdslen 	system include 
sdslen sds 	files file contains 
zmalloc size 	excerpts file 
dup last 	needed malloc ansi 
needed sdscatlen 	systems haven 
sdslen sds 	changed compile time 
zmalloc 	options naming 
size incr 	tuning parameters create 
count list 	malloc include 
node tail 	settings cutting point 
sds used 	indicated note 
memory close 	may already library 
client 	containing malloc 
output buffer 	version malloc 
limit reached 	example linux might 
sdsfree list 	still want 
length list 	use one file 
node tail 	customize settings 
create 	avoid overheads associated 
sds zmalloc 	library versions 
size list 	vital statistics supported 
node list 	pointer size 
last sdslen 	representation bytes size 
sdslen sds 	must type 
zmalloc 	width pointers ancient 
size dup 	system declares 
last needed 	size type need 
sdscatlen sdslen 	different width 
sds zmalloc 	pointers use previous 
size sdsfree 	release malloc 
list 	supporting alignment bytes 
node tail 	suffices nearly 
create sds 	current machines 
zmalloc size 	compilers however define 
close client 	malloc alignment 
output buffer 	wider necessary bytes 
limit 	expense space 
reached list 	minimum overhead per 
length create 	allocated chunk 
list node 	bytes sizes bytes 
tail sds 	sizes malloced 
used 	chunk hidden word 
memory list 	overhead holding 
node list 	size status information 
last sdslen 	additional cross 
sds zmalloc 	check word footers 
size dup 	defined minimum 
last 	allocated size ptrs 
needed sdscatlen 	bytes including 
sds zmalloc 	overhead ptrs bytes 
size create 	including overhead 
list node 	even request 
tail sds 	zero bytes malloc 
used 	returns pointer 
memory close 	something minimum allocatable 
client output 	size maximum 
buffer limit 	overhead wastage number 
reached prepare 	extra bytes 
client write 	allocated requested malloc 
sds 	less equal 
encoded reply 	minimum size requests 
buffer sdslen 	mmap threshold 
reply list 	serviced via mmap 
list length 	worst wastage 
reply buffer 	bytes plus remainder 
decoded 	system page 
reply buffer 	minimal mmap unit 
sdslen reply 	typically bytes 
list decr 	security safe optionally 
count server 	less security 
panic prepare 	malloc refers 
client 	ability malicious code 
write sdsfree 	accentuate effects 
reply buffer 	errors example freeing 
sdslen sdsfree 	space currently 
reply sds 	malloc overwriting past 
list prepare 	ends chunks 
client 	code calls malloc 
write reply 	malloc guarantees 
buffer reply 	modify memory locations 
list reply 	heap variables 
reply reply 	even presence usage 
reply error 	errors routines 
length 	additionally detect improper 
strlen start 	frees reallocs 
sdscatvprintf sdsempty 	holds bookkeeping malloc 
end sdslen 	corrupted means 
reply error 	one aspect 
length sdslen 	security checks cannot 
sdsfree 	detect possible 
reply reply 	programming errors footers 
reply reply 	defined nonzero 
status length 	allocated chunk carries 
strlen start 	additional check 
sdscatvprintf sdsempty 	word verify malloced 
end 	space check 
reply status 	words within execution 
length sdslen 	program malloc 
sdsfree prepare 	differ across executions 
client write 	externally crafted 
list node 	fake chunks cannot 
tail 	freed improves 
create list 	security rejecting frees 
last list 	reallocs could 
node sdscatprintf 	corrupt heap memory 
sdsempty sds 	addition checks 
zmalloc size 	preventing writes 
list 	statics always may 
node sds 	improve security 
zmalloc size 	expense time space 
sds used 	overhead note 
memory sdscatlen 	footers may also 
sdslen sds 	worth mspaces 
zmalloc 	detected errors cause 
size list 	program abort 
del node 	calling abort instead 
close client 	proceed past 
output buffer 	errors defining proceed 
limit reached 	error bad 
isinf 	free effect malloc 
reply bulk 	encounters bad 
snprintf snprintf 	address caused user 
reply create 	overwrites ignore 
reply bulk 	bad address dropping 
decr count 	pointers indices 
reply 	known memory 
reply reply 	may appropriate programs 
reply reply 	possible face 
reply prefix 	programming errors although 
reply reply 	may run 
prefix sds 	memory dropped memory 
encoded 	never reclaimed 
sdslen reply 	like either options 
reply prefix 	define corruption 
reply bulk 	error action usage 
len reply 	error action 
reply reply 	anything sure program 
prefix 	malloc errors 
reply reply 	vulnerabilities define insecure 
reply sds 	might might 
sdscatfmt sdsempty 	provide small performance 
sdslen reply 	improvement safety 
sds reply 	safe unless use 
reply 	locks defined 
reply bulk 	use locks 
buffer strlen 	defined call malloc 
reply bulk 	free etc 
buffer list 	surrounded either pthread 
release list 	mutex win 
dup 	spinlock depending win 
memcpy list 	especially fast 
length create 	major bottleneck designed 
client server 	provide minimal 
log strerror 	protection concurrent environments 
close list 	provide basis 
length 	extensions malloc concurrent 
write strlen 	program consider 
free client 	instead nedmalloc http 
strcmp strcmp 	www nedprod 
write strlen 	programs portable nedmalloc 
free client 	ptmalloc see 
unused 	http www 
unused unused 	malloc derived versions 
anet tcp 	malloc system 
accept server 	requirements combination morecore 
log server 	mmap munmap 
log accept 	malloc use unix 
common 	sbrk emulation 
handler unused 	invoked call morecore 
unused unused 	macro mmap 
anet unix 	munmap emulation invoked 
accept server 	call mmap 
log server 	call munmap release 
log 	system memory 
accept common 	unix systems tends 
handler decr 	work best 
count list 	morecore mmap enabled 
length list 	win uses 
first free 	emulations alloc also 
client 	uses common 
list search 	library functions 
key server 	like memset compliance 
list del 	believe compliant 
node file 	single unix specification 
file close 	see http 
list 	www unix also 
search key 	svid xpg 
server list 	ansi probably others 
del node 	well overview 
list search 	algorithms fastest space 
key server 	conserving portable 
list 	tunable malloc ever 
del node 	written however 
server log 	among fastest also 
replication cache 	among space 
master server 	conserving portable tunable 
log replication 	consistent balance 
slave 	across factors results 
name sdsfree 	good general 
unblock client 	purpose allocator 
dict release 	malloc intensive programs 
unwatch keys 	ways malloc 
list release 	best fit allocator 
pubsub 	generally chooses 
unsubscribe channels 	best fitting existing 
pubsub unsubscribe 	chunk request 
patterns dict 	ties broken approximately 
release list 	least recently 
release list 	used order strategy 
release 	normally maintains 
free client 	low fragmentation however 
argv unlink 	requests less 
client close 	bytes deviates best 
sdsfree list 	fit exactly 
search key 	fitting available chunk 
server 	preferring use 
list del 	space adjacent used 
node list 	previous small 
length refresh 	request well 
good slaves 	breaking ties approximately 
count replication 	recently used 
handle 	order enhance locality 
master disconnection 	series small 
list search 	allocations large requests 
key server 	relies system 
list del 	memory mapping facilities 
node decr 	supported helps 
count 	avoid carrying around 
zfree free 	possibly fragmenting 
client multi 	memory used large 
state sdsfree 	chunks operations 
zfree list 	malloc stats mallinfo 
node tail 	execution times 
list 	bounded constant factor 
length list 	number bits 
first list 	size counting 
node free 	clearing calloc copying 
client list 	realloc actions 
del node 	surrounding morecore mmap 
client 	times proportional 
pending replies 	number non contiguous 
write list 	regions returned 
node list 	system allocation routines 
first sdslen 	often real 
sds used 	time applications optionally 
memory 	suppress segment 
list del 	traversals segment traversal 
node list 	assures bounded 
first write 	execution even system 
list del 	allocators non 
node list 	contiguous spaces typical 
first 	expense carrying 
zmalloc used 	around memory increased 
memory server 	fragmentation implementation 
log strerror 	modular seriously 
free client 	overuses macros perhaps 
client pending 	someday compilers 
replies 	good job inlining 
file free 	modular code 
client unused 	done brute force 
unused write 	expansion enough 
client list 	seem compilers issue 
length list 	lot warnings 
rewind 	code dead unreachable 
list next 	platforms also 
list node 	intentional uses negation 
list del 	types known 
node write 	cases ignored longer 
client client 	date high 
pending 	level description see 
replies create 	http gee 
file free 	oswego edu html 
client free 	malloc html 
client argv 	mspaces mspaces 
strchr sdslen 	defined addition malloc 
reply 	free etc 
error protocol 	file also defines 
error sdsnewlen 	mspace malloc 
sdssplitargs sdsfree 	mspace free etc 
reply error 	versions malloc 
protocol error 	routines take mspace 
sdsrange 	argument obtained 
zfree zmalloc 	create mspace control 
sdslen create 	bookkeeping mspaces 
sdsfree zfree 	defined versions compiled 
cat client 	would like 
info sdsempty 	use allocator allocations 
server 	system malloc 
log sdsfree 	others compile mspaces 
sdsrange server 	something like 
info strchr 	mspace mymspace create 
sdslen reply 	mspace example 
error protocol 	define mymalloc 
error 	bytes mspace malloc 
sdslen server 	mymspace bytes 
info reply 	note need one 
error protocol 	instance mspace 
error sdsrange 	instead use use 
zfree zmalloc 	prefix relabel 
server 	malloc similarly create 
info strchr 	local allocators 
sdslen reply 	storing mspaces locals 
error protocol 	example mspace 
error sdslen 	tlms tlmalloc size 
reply error 	bytes tlms 
format 	tlms create mspace 
protocol error 	mspace malloc 
reply error 	tlms bytes tlfree 
protocol error 	mem mspace 
sdsrange sdslen 	free tlms mem 
sds make 	unless footers 
room 	defined mspace 
sdslen sdslen 	completely independent cannot 
create sds 	allocate one 
incr len 	free another although 
sdsempty sds 	conformance weakly 
make room 	usage errors always 
create 	caught footers 
sdsrange sdslen 	defined chunk carries 
clients paused 	around tag 
process buffer 	indicating originating mspace 
process multibulk 	frees directed 
buffer server 	originating spaces compile 
panic 	time options 
reset client 	careful setting define 
process command 	values numerical 
reset client 	constants type size 
unused unused 	systems values 
sdslen sdslen 	automatically extended 
sds 	size precision unless 
make room 	explicitly casted 
read server 	also use symbolic 
log strerror 	values max 
free client 	size size one 
server log 	etc win 
free 	defined win defined 
client sds 	defining win 
incr len 	sets defaults environment 
sdslen cat 	compilers otherwise 
client info 	defaults unix beware 
sdsempty sdscatrepr 	seem cases 
server 	malloc might pure 
log sdsfree 	drop replacement 
sdsfree free 	win malloc random 
client process 	looking failures 
input buffer 	win gdi api 
list rewind 	bits may 
list 	due bugs 
next list 	video driver implementations 
node list 	pixel buffers 
length list 	malloc region spans 
length sdslen 	one alloc 
sdslen snprintf 	region dlmalloc uses 
anet 	small granularity 
format peer 	pixel buffers may 
gen client 	straddle allocation 
peer sdsnew 	regions often microsoft 
file events 	allocator avoid 
sdscatfmt client 	alloc free pixel 
peer 	buffers rather 
dict size 	malloc possible recompile 
list length 	malloc larger 
sdslen sdsavail 	granularity malloc alignment 
list length 	size controls 
client output 	minimum alignment malloc 
buffer 	chunks must 
memory usage 	power two 
sdsempty sds 	least even machines 
make room 	smaller alignments 
list length 	would suffice may 
list rewind 	defined larger 
list 	though note however 
next list 	code data 
node cat 	structures optimized alignment 
client info 	mspaces compile 
sdscatlen strcasecmp 	support independent allocation 
clients info 	spaces supported 
reply 	mmap mspaces compile 
bulk buffer 	mspace versions 
sdslen sdsfree 	regular versions use 
strcasecmp strcasecmp 	locks causes 
reply strcasecmp 	call routine surrounded 
strcasecmp reply 	pthread win 
strcasecmp 	mutex unlock overridden 
strcasecmp reply 	per mspace 
strcasecmp client 	basis mspace 
type name 	versions non zero 
reply error 	locks used 
format strcasecmp 	implementation left functions 
strcasecmp 	must supplied 
strcasecmp strcasecmp 	manually use spin 
reply reply 	locks iff 
reply list 	use locks gcc 
rewind list 	msc uses 
next list 	custom spin locks 
node 	locking currently 
strcmp client 	supported platforms gcc 
peer client 	recent compilers 
type free 	otherwise posix locks 
client reply 	win critical 
error reply 	sections used footers 
reply 	provide extra 
strcasecmp sdslen 	checking dispatching 
decr count 	placing information footers 
reply reply 	allocated chunks 
error decr 	adds space time 
count incr 	overhead insecure 
count 	omit checks usage 
reply strcasecmp 	errors heap 
reply bulk 	space overwrites use 
reply strcasecmp 	prefix defined 
timeout reply 	causes compiler prefix 
pause clients 	routines useful 
reply 	want use malloc 
reply error 	one part 
zmalloc start 	program regular system 
arg incr 	malloc elsewhere 
count decr 	abort defined abort 
count zfree 	defines abort 
lookup 	failed checks systems 
command original 	failed check 
server info 	cannot die 
end free 	even print informative 
client argv 	message underlying 
zfree lookup 	print routines turn 
command 	call malloc 
original server 	fail generally best 
info zrealloc 	policy simply 
incr count 	call abort useful 
decr count 	many errors 
lookup command 	due overwriting show 
original 	address faults 
server info 	odd addresses etc 
list length 	rather malloc 
strcasecmp strcasecmp 	triggered checks also 
strcasecmp strcasecmp 	abort also 
client output 	compilers know abort 
buffer 	better optimize 
memory usage 	code conditionally calling 
client type 	proceed error 
server check 	defined controls 
client output 	whether detected bad 
buffer limits 	addresses cause 
cat 	bypassed rather aborting 
client info 	detected bad 
sdsempty free 	arguments free realloc 
client server 	ignored bookkeeping 
log sdsfree 	information zeroed upon 
list rewind 	detected overwrite 
list 	freed heap space 
next list 	thus losing 
node file 	ability ever malloc 
events client 	enabling application 
pending replies 	proceed proceed error 
write client 	defined variable 
list 	malloc corruption error 
rewind list 	count compiled 
next list 	examined see errors 
node list 	occurred option 
node tail 	generates slower 
process events 	code abort policy 
handle 	debug defined 
clients pending 	debug setting mainly 
writes copyright 	intended people 
salvatore sanfilippo 	trying modify code 
antirez gmail 	diagnose problems 
dot rights 	porting platforms however 
reserved 	may also 
redistribution use 	able better isolate 
source binary 	user errors 
forms without 	runtime checks assertions 
modification permitted 	check routines 
provided 	spell detail assumptions 
following conditions 	invariants underlying 
met redistributions 	algorithms checking fairly 
source code 	extensive slow 
must retain 	execution noticeably 
copyright notice 	calling malloc stats 
list 	mallinfo debug 
conditions following 	attempt check every 
disclaimer redistributions 	non mmapped 
binary form 	allocated free chunk 
must reproduce 	course computing 
copyright notice 	summaries abort failure 
list 	defined debugging 
conditions following 	assertion failures nearly 
disclaimer documentation 	impossible version 
materials provided 	macro causes malloc 
distribution neither 	called lead 
name redis 	cascade failures blowing 
names 	runtime stack 
contributors may 	abort failure cause 
used endorse 	assertions failures 
promote products 	call abort usually 
derived software 	make debugging 
without specific 	easier malloc 
prior 	failure action sets 
written permission 	errno enomem 
software provided 	win action take 
copyright holders 	malloc fails 
contributors express 	able memory none 
implied warranties 	available morecore 
including 	unless win mspaces 
limited implied 	system supports 
warranties merchantability 	sbrk emulation morecore 
fitness particular 	sbrk name 
purpose disclaimed 	sbrk style system 
shall copyright 	routine call 
owner 	obtain memory see 
contributors liable 	guidance writing 
direct indirect 	custom morecore functions 
incidental special 	type argument 
exemplary consequential 	sbrk morecore varies 
damages including 	across systems 
limited 	cannot size 
procurement substitute 	supports negative arguments 
goods services 	normally type 
loss use 	width size sometimes 
data profits 	declared intptr 
business interruption 	doesn much matter 
however 	though internally 
caused theory 	call arguments less 
liability whether 	half max 
contract strict 	size work across 
liability tort 	reasonable possibilities 
including negligence 	although sometimes generating 
otherwise 	compiler warnings 
arising way 	morecore contiguous morecore 
use software 	take advantage 
even advised 	fact consecutive calls 
possibility damage 	morecore positive 
size consumed 	arguments always contiguous 
allocator 	increasing addresses 
specified sds 	unix sbrk 
including fragmentation 	hurt much anyway 
function used 	since malloc 
order compute 	copes non contiguities 
client output 	setting definitely 
buffer 	non contiguous saves 
size amount 	time possibly 
memory used 	wasted space would 
sds ptr 	take discover 
integer encoding 	though morecore cannot 
passing possible 	trim defined 
create 	morecore cannot release 
non connected 	space back 
client useful 	system given negative 
since commands 	arguments generally 
needs executed 	necessary hand crafted 
context client 	morecore function 
commands 	cannot handle negative 
executed contexts 	arguments segment 
instance lua 	traversal non 
script need 	zero suppresses traversals 
non connected 	memory segments 
client function 	returned either morecore 
called 	call mmap 
every time 	disables merging segments 
going transmit 	contiguous selectively 
data client 	releasing unused bounds 
behavior following 	execution times 
client receive 	mmap system supports 
data 	mmap emulation 
normal clients 	morecore mmap used 
function returns 	system allocation 
make sure 	morecore well mmap 
install write 	primarily used 
handler loop 	directly allocate large 
socket 	blocks also 
writable data 	used backup 
gets written 	strategy cases morecore 
client receive 	fails provide 
data fake 	space system note 
client used 	single call 
load 	munmap assumed able 
aof memory 	unmap memory 
master setup 	may allocated multiple 
write handler 	calls mmap 
failed function 	adjacent mremap linux 
returns err 	realloc uses 
function 	mremap allocate large 
may without 	blocks extend 
actually installing 	shrink allocation spaces 
write handler 	mmap clears 
following cases 	wince mmap clears 
handler already 	memory calloc 
installed 	doesn need standard 
since output 	unix mmap 
buffer already 	dev zero 
contained something 	win wince use 
client slave 	builtin ffs 
yet online 	used causes malloc 
want 	use builtin 
accumulate writes 	ffs function compute 
buffer actually 	indices compilers 
sending yet 	may recognize intrinsify 
typically gets 	ffs faster 
called every 	supplied version also 
time 	gcc special 
reply built 	cased asm instruction 
adding data 	already fast 
clients output 	setting effect similarly 
buffers function 	win recent 
returns err 	compilers asm version 
data 	slightly faster 
appended output 	version malloc getpagesize 
buffers lua 	derive system 
client always 	includes system 
without installing 	page size extent 
handler since 	possible malloc 
socket 	manages memory system 
client reply 	page size 
skip handling 	units may usually 
send replies 	function rather 
masters receive 	constant ignored win 
replies unless 	page size 
client 	determined system info 
master force 	initialization use 
reply flag 	dev random used 
fake client 	causes malloc 
aof loading 	use dev random 
schedule client 	initialize secure 
write 	magic seed stamping 
output buffers 	footers otherwise 
socket already 	current time used 
done pending 	mallinfo defined 
writes already 	compile mallinfo 
client yet 	simple way dealing 
flagged 	mismatches system 
slaves slave 	declarations file mallinfo 
actually receive 	field type 
writes stage 	size type fields 
instead installing 	mallinfo originally 
write handler 	defined svid etc 
flag 	usefully defined 
client put 	size used usr 
list clients 	include malloc 
something write 	realloc zero bytes 
socket way 	frees defined 
entering loop 	call realloc zero 
directly 	bytes call 
write client 	free people think 
sockets avoiding 	otherwise since 
system call 	malloc returns 
really install 	unique pointer malloc 
write handler 	realloc lacks 
able 	unistd lacks fcntl 
write whole 	lacks sys 
reply authorize 	param lacks sys 
caller queue 	mman lacks 
output buffer 	lacks lacks sys 
client create 	types lacks 
duplicate 	errno lacks stdlib 
last reply 	defined unless 
list exclusively 	win define system 
owned reply 	header files 
list low 	might need manually 
level functions 	insert declarations 
data 	provide granularity page 
output buffers 	size morecore 
already entries 	contiguous system info 
reply list 	allocation granularity 
cannot anything 	win otherwise 
buffer check 	also settable mallopt 
buffer 	granularity unit 
enough space 	allocating deallocating memory 
available append 	system systems 
possible method 	contiguous morecore reason 
takes responsibility 	make page 
sds longer 	however systems mmap 
needed 	tend either 
free otherwise 	require encourage larger 
ends robj 	granularities increase 
append possible 	prevent system allocation 
append possible 	functions called 
higher level 	often especially slow 
functions 	must least 
queue data 	one page must 
client output 	power two 
buffer following 	setting causes initialization 
functions ones 	either page 
commands implementations 	size win 
call 	region size note 
important place 	previous versions 
avoid copy 	malloc equivalent option 
write saving 	called top 
child running 	pad trim threshold 
avoiding touching 	also settable 
refcount 	mallopt trim threshold 
field needed 	maximum amount 
encoding raw 	unused top memory 
room buffer 	keep releasing 
able send 	via malloc trim 
client without 	free automatic 
messing 	trimming mainly useful 
page optimization 	lived programs 
room buffer 	contiguous morecore trimming 
bytes max 	via sbrk 
chars bit 	slow systems sometimes 
integer take 	wasteful cases 
avoid 	programs immediately 
decoding lower 	afterward allocate large 
level approach 	chunks high 
normal code 	enough overall system 
path never 	performance would 
happen actually 	improve releasing much 
since 	memory rough 
verified room 	guide might close 
caller expects 	average size 
sds free 	process program running 
method free 	system releasing 
sds longer 	much memory would 
needed 	allow process 
make sure 	run memory generally 
newlines otherwise 	worth tuning 
invalid protocol 	trim thresholds program 
emitted adds 	undergoes phases 
empty reply 	several large 
list 	chunks allocated released 
contain multi 	ways reuse 
bulk length 	storage perhaps mixed 
known function 	phases chunks 
called note 	trim must greater 
install write 	page size 
even 	useful effect disable 
ready sent 	trimming completely 
since sure 	max size note 
returning loop 	trick people 
deferred multi 	use mallocing huge 
bulk length 	space freeing 
called 	program startup attempt 
populate length 	reserve system 
gluing next 	memory doesn intended 
chunk abort 	effect automatic 
node see 	trimming since memory 
deferred multi 	immediately returned 
bulk 	system mmap 
length embstr 	threshold also settable 
glue next 	mallopt mmap 
node non 	threshold request size 
sds bulk 	threshold mmap 
reply libc 	directly service request 
odd 	requests least 
systems solaris 	size cannot allocated 
format infinite 	already existing 
different way 	space serviced via 
better handle 	mmap enough 
way bulk 	normal freed space 
reply 	already exists 
uses human 	used instead mmap 
readable formatting 	segregates relatively 
instead exposing 	large chunks memory 
crude behavior 	individually obtained 
doubles dear 	released host system 
user 	request serviced 
integer reply 	mmap never 
bulk len 	reused request least 
multi bulk 	directly system 
count basically 	may happen remap 
used output 	successive requests 
prefix 	locations segregating space 
crlf things 	way benefits 
like emitted 	mmapped space always 
often protocol 	individually released 
shared objects 	back system helps 
use integer 	keep system 
small 	level memory demands 
like times 	lived program 
create length 	low also mapped 
prefix bulk 	memory doesn 
reply example 	become locked chunks 
compute many 	happen normally 
bytes 	allocated chunks means 
take integer 	even trimming 
radix redis 	via malloc 
bulk reply 	trim would release 
buffer bulk 	however disadvantage 
reply sds 	space cannot reclaimed 
reply 	consolidated used 
takes ownership 	service later requests 
sds frees 	happens normal 
nul term 	chunks advantages mmap 
bulk reply 	nearly always 
bulk reply 	outweigh disadvantages large 
copy 	chunks large 
src client 	may vary across 
output buffers 	systems empirically 
dst client 	derived works well 
output buffers 	systems disable 
function takes 	mmap setting max 
care 	size max 
freeing old 	release check rate 
output buffers 	unless mmap 
destination client 	number consolidated 
specified client 	frees checks release 
pending reply 	unused segments 
buffers 	freeing non contiguous 
write socket 	segments especially 
may already 	multiple mspaces checking 
closed ignore 	topmost space 
errors maxclient 	doesn always suffice 
directive one 	trigger trimming 
client 	compensate free period 
close connection 	max release 
note create 	check rate current 
client instead 	number segments 
check condition 	greater release unused 
since socket 	segments freeing 
already 	chunks result consolidation 
non blocking 	best parameter 
mode send 	compromise slowing 
error free 	frees relatively costly 
kernel best 	checks rarely 
effort error 	trigger versus holding 
message 	unused memory 
check write 	effectively disable max 
errors nothing 	size may 
avoid warning 	lead slight speed 
server running 	improvement expense 
mode password 	carrying around memory 
specific 	version allow 
bound accept 	people support multiple 
requests non 	versions dlmalloc 
loopback interfaces 	version win win 
instead explain 	wce win 
user fix 	malloc failure action 
needed 	wince reportedly 
nothing avoid 	clear win wce 
warning close 	win mac 
slaves connections 	osx docs 
useful chained 	advise use sbrk 
replication resync 	seems better 
master 	use mmap osx 
want force 	allocators provide 
slaves resync 	alignment morecore darwin 
well specified 	size lacks 
client lists 	sys types maximum 
client could 	possible size 
referenced 	bits define mspaces 
including pub 	mspaces mspaces 
sub channels 	mspaces malloc alignment 
used free 	footers abort 
client replication 	abort failure proceed 
cache master 	error use 
marked 	locks use locks 
current client 	use spin 
unset certain 	locks insecure mmap 
operations must 	mmap clears 
done client 	linux linux 
active socket 	mremap malloc failure 
client 	action mspaces 
already unlinked 	mspaces morecore morecore 
fake client 	morecore contiguous 
already list 	morecore means compute 
active clients 	init mparams 
unregister handlers 	morecore contiguous morecore 
close 	contiguous granularity 
socket list 	morecore cannot trim 
pending writes 	morecore cannot 
needed client 	trim trim threshold 
unblocked blocking 	mmap mmap 
operation list 	mmap threshold mmap 
unblocked 	max release 
clients master 	check rate use 
beging disconnected 	builtin ffs 
make sure 	use dev random 
cache state 	mallinfo mallinfo 
resynchronization later 	field type 
note 	segment traversal mallopt 
make sure 	tuning options 
client unexpected 	svid xpg defines 
state checking 	four standard 
flags log 	parameter numbers mallopt 
link disconnection 	normally defined 
slave 	malloc none used 
free query 	malloc setting 
buffer deallocate 	effect malloc support 
structures used 	following options 
block blocking 	mallinfo declarations version 
ops unwatch 	malloc supports 
keys 	standard svid xpg 
unsubscribe pubsub 	mallinfo routine 
channels free 	returns containing usage 
data structures 	properties statistics 
unlink client 	work system 
close socket 	usr include malloc 
handlers 	defining mallinfo 
references client 	main declaration needed 
different places 	mallinfo returned 
active clients 	copy mallinfo malloinfo 
may referenced 	contains bunch 
master slave 	fields even meaningful 
cleanup 	version malloc 
lost connection 	fields instead filled 
slave need 	mallinfo numbers 
remember time 	might interest usr 
started zero 	include malloc 
attached slaves 	usr include malloc 
time 	file includes 
free replication 	declaration mallinfo included 
backlog master 	compliant version 
slave cleanup 	declared must precisely 
lost connection 	mallinfo work 
master client 	original svid 
scheduled 	version defined systems 
freeing need 	mallinfo declares 
queue release 	fields ints others 
dynamically allocated 	define system 
client structure 	defines fields type 
fields 	different width 
release client 	listed must include 
structure schedule 	system version 
client free 	define usr include 
safe time 	malloc define 
server cron 	usr include malloc 
function 	usr include 
function useful 	malloc non mmapped 
need terminate 	space allocated 
client context 	system number free 
calling free 	chunks always 
client possible 	always space mmapped 
client 	regions maximum 
valid continuation 	total allocated 
flow program 	space always total 
write data 	allocated space 
output buffers 	total free space 
client client 	releasable via 
still 	malloc trim space 
valid call 	mallinfo declared 
err freed 	usr include malloc 
buffer sent 	mallinfo persuade 
bufpos zero 	compilers critical functions 
remainder reply 	inlining defined 
fully 	macros aren used 
sent head 	cplusplus declarations 
next one 	routines use prefix 
note avoid 	malloc size 
send net 	returns pointer newly 
max writes 	allocated chunk 
per 	least bytes space 
bytes single 	available errno 
threaded server 	enomem ansi 
good idea 	systems zero malloc 
serve clients 	returns minimum 
well even 	sized chunk minimum 
large 	size bytes 
request comes 	bit systems bytes 
fast link 	bit systems 
always able 	note size type 
accept data 	calls arguments 
real world 	would negative interpreted 
scenario 	requests huge 
think keys 	amounts space often 
loopback however 	fail maximum 
maxmemory limit 	supported differs across 
ignore deliver 	systems cases 
much data 	less maximum representable 
possible 	size free 
deliver clients 	releases chunk 
representing masters 	memory pointed previously 
count sending 	allocated malloc 
data interaction 	related routine realloc 
since always 	effect malloced 
send 	already freed free 
replconf ack 	cause current 
commands take 	program abort calloc 
time fill 	size elements 
socket output 	size element size 
buffer rely 	returns pointer 
data 	elements element size 
pings received 	bytes locations 
timeout detection 	zero realloc size 
close connection 	returns pointer 
entire reply 	chunk size contains 
sent write 	data chunk 
handler 	minimum size bytes 
send data 	space available 
client function 	returned pointer 
called entering 	may may algorithm 
loop hope 	prefers extending 
write replies 	cases possible otherwise 
client 	employs equivalent 
output buffer 	malloc copy free 
without need 	sequence realloc 
use syscall 	equivalent malloc space 
order install 	available realloc 
writable handler 	returns errno ansi 
called 	freed fewer 
forth write 	bytes already held 
buffers client 	newly unused 
socket nothing 	space lopped freed 
left nothing 	possible realloc 
otherwise install 	size argument zero 
write 	allocates minimum 
handler reset 	sized chunk old 
client prepare 	unix realloc 
client process 	convention allowing 
next command 	last free chunk 
clear asking 	used argument 
flag 	realloc supported memalign 
well inside 	size alignment 
multi executed 	size returns pointer 
asking command 	newly allocated 
client reply 	chunk bytes aligned 
skip flag 	accord alignment 
reply 	argument alignment argument 
next command 	power two 
sent flag 	argument power two 
command processed 	nearest greater 
client reply 	power used alignment 
skip search 	guaranteed normal 
end 	malloc calls bother 
line nothing 	calling memalign 
without handle 	argument less overreliance 
split input 	memalign sure 
buffer newline 	way fragment 
slaves used 	space valloc size 
refresh 	equivalent memalign 
last ack 	pagesize pagesize page 
time useful 	size system 
slave ping 	pagesize unknown used 
back loading 	mallopt parameter 
big rdb 	number parameter sets 
file 	tunable parameters 
data first 	format provide parameter 
line query 	number parameter 
buffer setup 	pair mallopt sets 
argv client 	corresponding parameter 
structure create 	argument meaningful returns 
redis 	successful workaround 
objects arguments 	fact mallopt specified 
helper function 	use size 
trims query 	parameters specially treated 
buffer make 	maximum size 
function processes 	svid xpg 
multi 	ansi defines four 
bulk requests 	standard param 
idempotent client 	numbers mallopt normally 
reset multi 	defined malloc 
bulk length 	none use malloc 
cannot read 	setting effect 
without 	malloc also supports 
buffer also 	options mallopt 
contain know 	see details briefly 
sure whole 	supported parameters 
line since 	follows listed defaults 
newline ahead 	typical configurations 
find 	symbol param allowed 
multi bulk 	param values 
length setup 	trim threshold disables 
argv client 	granularity page 
structure read 	size power 
bulk length 	page size mmap 
unknown 	threshold mmap 
buffer also 	support malloc footprint 
contain going 	returns number 
read large 	bytes obtained system 
network make 	total number 
likely start 	bytes allocated malloc 
querybuf 	realloc etc 
boundary optimize 	less unlike mallinfo 
creation avoiding 	function returns 
large copy 	precomputed result called 
data hint 	frequently monitor 
sds library 	memory consumption even 
amount 	locks otherwise 
bytes going 	defined function use 
contain read 	results might 
bulk argument 	date malloc max 
enough data 	footprint returns 
trailing optimization 	maximum number 
buffer 	bytes obtained system 
contains bulk 	greater current 
element instead 	footprint deallocated space 
creating copying 	reclaimed system 
sds use 	peak number bytes 
current sds 	allocated malloc 
crlf 	realloc etc less 
saw fat 	unlike mallinfo 
argument see 	function returns precomputed 
another one 	result called 
likely trim 	frequently monitor memory 
pos done 	consumption even 
multibulk 	locks otherwise defined 
still read 	function use 
process command 	results might date 
keep processing 	mallinfo returns 
something input 	copy containing various 
buffer clients 	summary statistics 
paused 	arena current 
immediately abort 	total non mmapped 
client middle 	bytes allocated 
something client 	system ordblks number 
close reply 	free chunks 
closes connection 	smblks always zero 
reply 	hblks current 
written client 	number mmapped regions 
make sure 	hblkhd total 
reply grow 	bytes held mmapped 
flag process 	regions usmblks 
commands determine 	maximum total allocated 
request 	space greater 
type unknown 	current total trimming 
multibulk processing 	occurred fsmblks 
could see 	always zero uordblks 
length reset 	current total 
client command 	allocated space normal 
executed 	mmapped fordblks 
multi bulk 	total free 
request processing 	space keepcost maximum 
bulk reply 	number bytes 
large enough 	could ideally released 
maximize probability 	back system 
query 	via malloc trim 
buffer contains 	ideally means 
exactly sds 	ignores page restrictions 
representing even 	etc fields 
risk requiring 	ints bookkeeping may 
read calls 	kept longs 
way 	reported values may 
function process 	wrap around 
multi bulk 	zero thus inaccurate 
buffer avoid 	mallinfo independent 
copying buffers 	calloc size elements 
create redis 	size element 
representing 	size chunks 
argument redis 	independent calloc similar 
peer colon 	calloc instead 
separated port 	returning single cleared 
pair form 	space returns 
port example 	pointers elements independent 
addresses 	elements hold 
use around 	contents size elem 
part like 	size starts 
unix sockets 	cleared independently freed 
use path 	realloc etc 
like tmp 	elements guaranteed adjacently 
redis 	allocated guaranteed 
peer always 	occur multiple callocs 
fits inside 	mallocs may 
buffer net 	also improve cache 
peer len 	locality applications 
bytes including 	chunks argument optional 
term 	may probably 
failure function 	typical usage 
still populates 	returned dynamically allocated 
peerid want 	also freed 
relax error 	longer needed otherwise 
checking need 	chunks must 
display 	least elements length 
something anyway 	filled pointers 
see anet 	chunks either independent 
peer implementation 	calloc returns 
info unix 	pointer allocation failed 
socket client 	elements zero 
tcp 	chunks returns chunk 
client function 	representing zero 
returns client 	elements freed wanted 
peer creating 	element must 
caching client 	individually freed longer 
peerid otherwise 	needed like 
returning 	instead able free 
cached peer 	instead use 
never changes 	regular calloc 
life client 	assign pointers space 
however expensive 	represent elements 
compute concatenate 	though cannot independently 
representing 	free elements 
state client 	independent calloc simplifies 
human readable 	speeds implementations 
format sds 	many kinds pools 
client list 	may also 
client reply 	useful constructing large 
skip 	data structures 
client kill 	initially number sized 
port client 	nodes number 
kill option 	known compile time 
option old 	nodes may 
style syntax 	later need freed 
client 	example node 
kill addr 	item node next 
old form 	node build 
kill next 	list node 
option index 	pool read number 
style syntax 	nodes needed 
parse 	pool node independent 
options iterate 	calloc node 
clients killing 	pool die organize 
matching clients 	linked list 
kill reply 	node first pool 
according old 	pool next 
format 	pool free pool 
client closed 	free needed 
flag close 	later first independent 
reply queued 	comalloc size 
reply output 	elements size sizes 
buffers setting 	chunks independent 
client 	comalloc allocates elements 
name empty 	chunks sizes 
actually removes 	indicated sizes 
current name 	returns pointers elements 
otherwise check 	independently freed 
charset need 	realloc etc elements 
otherwise 	guaranteed adjacently 
client list 	allocated guaranteed occur 
format always 	multiple callocs 
able split 	mallocs may also 
space different 	improve cache 
fields ascii 	locality applications chunks 
assumed 	argument optional 
rewrite command 	may returned dynamically 
vector client 	allocated also 
objects count 	freed longer needed 
incremented old 	otherwise chunks 
command vector 	must least elements 
freed 	length filled 
old objects 	pointers chunks either 
count decremented 	independent comalloc 
argument vector 	returns pointer 
free objects 	allocation failed elements 
original vector 	zero chunks 
end 	returns chunk representing 
sure objects 	zero elements 
reused vector 	freed wanted element 
refcount gets 	must individually 
incremented gets 	freed longer needed 
decremented replace 	like instead 
argv 	able free instead 
argc versions 	use single 
completely replace 	regular malloc assign 
client command 	pointers particular 
vector provided 	offsets aggregate space 
one rewrite 	though cannot 
single 	independently free elements 
item command 	independent comallac 
vector val 	differs independent calloc 
count incremented 	element may 
old decremented 	different size 
possible specify 	also automatically clear 
argument 	elements independent 
current size 	comalloc used speed 
argument vector 	allocation cases 
objects gets 	several structs objects 
reallocated argc 	must always 
max however 	allocated time example 
caller 	head foot 
make sure 	send message msg 
holes arguments 	msglen strlen 
original argument 	msg size sizes 
vector longer 	head msglen 
one want 	foot chunks independent 
end 	comalloc sizes 
caller argc 	chunks die head 
free longer 	head head 
used objects 	chunks body chunks 
argv command 	foot foot 
name make 	foot chunks 
sure 	general though independent 
fix cmd 	comalloc worth 
function returns 	larger values elements 
number bytes 	small values 
redis virtually 	probably won detect 
store reply 	enough difference 
still 	series malloc calls 
read client 	bother overuse 
since reply 	independent comalloc increase 
output list 	overall memory 
may contain 	usage since cannot 
objects shared 	reuse existing 
really 	noncontiguous small chunks 
additional memory 	might available 
function returns 	elements pvalloc size 
total sum 	equivalent valloc 
length objects 	minimum page holds 
stored output 	round nearest 
list 	pagesize malloc 
plus memory 	trim size pad 
used allocate 	possible gives 
every list 	memory back system 
node reply 	via negative 
buffer taken 	arguments sbrk unused 
account 	memory high 
since allocated 	end malloc pool 
anyway note 	unused mmap 
function fast 	segments call freeing 
called many 	large blocks 
time caller 	memory potentially reduce 
wishes 	system level 
main usage 	memory requirements program 
function currently 	however cannot 
enforcing client 	guarantee reduce memory 
output length 	allocation patterns 
limits client 	large free 
used 	blocks memory locked 
order enforce 	two used 
limits different 	chunks cannot given 
classes clients 	back system 
function one 	pad argument malloc 
following client 	trim represents 
type 	amount free trailing 
normal normal 	space untrimmed 
client client 	argument zero minimum 
type slave 	amount memory 
slave client 	maintain data structures 
executing monitor 	left non 
command 	zero arguments supplied 
client type 	maintain enough 
pubsub client 	trailing space service 
subscribed pub 	future expected 
sub channels 	allocations without obtain 
client type 	memory system 
master 	malloc trim 
client representing 	returns actually released 
replication master 	memory malloc 
function checks 	stats prints stderr 
client reached 	amount space 
output buffer 	obtained system via 
soft 	sbrk mmap 
hard limit 	maximum amount may 
also update 	current malloc 
state needed 	trim munmap got 
check soft 	called current 
limit side 	number bytes allocated 
effect 	via malloc 
non zero 	realloc etc yet 
client reached 	freed note 
soft hard 	number bytes allocated 
limit otherwise 	number requested 
zero returned 	larger number requested 
purpose 	alignment bookkeeping 
output buffer 	overhead includes 
limiting masters 	alignment wastage use 
handled like 	figure may 
normal clients 	greater zero even 
need check 	user level 
soft 	chunks allocated reported 
limit reached 	current maximum 
continuously specified 	system memory inaccurate 
amount seconds 	program makes 
first time 	calls system memory 
see soft 	allocation functions 
limit 	normally sbrk outside 
reached client 	malloc malloc 
still reached 	stats prints commonly 
max number 	interesting statistics 
seconds soft 	information obtained calling 
limit 	mallinfo mspaces 
considered reached 	malloc usable size 
asynchronously close 	returns number 
client soft 	bytes actually 
hard limit 	use allocated chunk 
reached output 	may requested 
buffer 	although often due 
size caller 	alignment minimum 
check client 	size constraints use 
closed checking 	many bytes 
client client 	without worrying overwriting 
close asap 	allocated objects 
flag 	particularly great programming 
note need 	practice malloc 
close client 	usable size useful 
asynchronously function 	debugging assertions 
called contexts 	example malloc malloc 
client freed 	usable size 
safely 	mspace opaque type 
lower level 	representing independent 
functions pushing 	region space 
data inside 	supports mspace malloc 
client output 	etc create 
buffers helper 	mspace creates returns 
function 	independent space 
used free 	given initial capacity 
memory needed 	granularity size 
order flush 	returns system memory 
slaves output 	available create 
buffers without 	space argument locked 
returning 	non zero 
control loop 	space uses separate 
also called 	control access 
shutdown best 	capacity space grow 
effort attempt 	dynamically needed 
send slaves 	service mspace malloc 
latest 	requests control 
writes note 	sizes incremental increases 
following flush 	space compiling 
output buffers 	different granularity 
slaves state 	dynamically setting mallopt 
online put 	granularity destroy 
online 	mspace destroys given 
ack writable 	space attempts 
never installed 	memory back system 
since purpose 	returning total 
put online 	number bytes freed 
ack postpone 	destruction results 
moment 	access memory used 
installed want 	space become 
since slaves 	undefined create mspace 
state receive 	uses memory 
writes first 	supplied initial mspace 
ack pause 	part less 
clients 	size bytes space 
specified unixtime 	used bookkeeping 
clients paused 	capacity must least 
command processed 	large otherwise 
clients data 	returned initial 
change time 	space exhausted additional 
however 	memory obtained 
function pauses 	system destroying space 
normal pub 	deallocate additionally 
sub clients 	allocated space possible 
slaves still 	initial mspace 
served function 	mmap large chunks 
used 	controls whether 
server upgrades 	requests large chunks 
required slaves 	allocated mmapped 
process latest 	regions separate others 
bytes replication 	mspace enabled 
stream turned 	reduces fragmentation however 
masters 	chunks necessarily 
function also 	released system upon 
internally used 	destroy mspace 
redis cluster 	disabling setting may 
manual failover 	increase fragmentation 
procedure implemented 	avoids leakage 
cluster 	relying destroy mspace 
failover function 	release memory 
always succeed 	allocated space mspace 
even already 	malloc behaves 
pause progress 	malloc operates within 
pause extended 	given space 
duration 	mspace free behaves 
time left 	free operates 
previous duration 	within given space 
however duration 	compiled footers 
smaller time 	mspace free actually 
left previous 	needed free 
pause 	may called instead 
change made 	mspace free 
left duration 	freed chunks space 
non zero 	handled originating 
clients currently 	spaces mspace 
paused side 	realloc behaves realloc 
effect 	operates within 
function checks 	given space compiled 
pause time 	footers mspace 
reached clear 	realloc actually needed 
put clients 	realloc may 
unblocked clients 	called instead mspace 
queue 	realloc realloced 
order force 	chunks space handled 
processing input 	originating spaces 
buffer touch 	mspace calloc behaves 
slaves blocked 	calloc operates 
clients latter 	within given space 
pending 	mspace memalign 
requests processed 	behaves memalign operates 
unblocked function 	within given 
called redis 	space mspace independent 
order process 	calloc behaves 
events time 	independent calloc 
time 	operates within given 
blocked interruptible 	space mspace 
operation allows 	independent comalloc behaves 
reply clients 	independent comalloc 
loading error 	operates within given 
loading data 	space mspace 
startup 	footprint returns number 
full resynchronization 	bytes obtained 
master forth 	system space mspace 
calls loop 	max footprint 
order process 	returns peak number 
events specifically 	bytes obtained 
call 	system space mspace 
loop times 	mallinfo behaves 
receive acknowledge 	mallinfo reports properties 
processed order 	given space 
forward accept 	mallinfo malloc usable 
read write 	size behaves 
close 	malloc usable 
sequence needed 	size mspace malloc 
serve client 	stats behaves 
function returns 	malloc stats reports 
total number 	properties given 
events processed 	space mspace trim 
see 	behaves malloc 
function top 	trim operates within 
comment noparser.c 	given space 
buff name 	mallopt mspaces end 
data strip 	cplusplus make 
unused unused 	fully customizable malloc 
unused 	header file 
unused lua 	cut everything line 
pushliteral lua 	put file 
error unused 	malloc edit suit 
unused unused 	include next 
unused unused 	line well programs 
lua 	use malloc 
pushliteral lua 	include malloc 
error code 	includes warnings win 
used make 	printing malloc 
lua core 	stats malloc failure 
contain parsing 	action lacks 
modules 	errno magic initialization 
lcode llex 	footers abort 
lparser represent 	lacks stdlib abort 
total core 	failure abort 
able load 	failure debug debug 
binary files 	memset etc 
precompiled 	lacks ffs lacks 
luac course 	use builtin 
build luac 	ffs mmap lacks 
original parsing 	sys mman 
modules use 	lacks fcntl mmap 
module simply 	sbrk sysconf 
compile 	lacks unistd free 
make noparser 	bsd etc 
list file 	lacks unistd 
lua libraries 	declarations locking solaris 
linker load 	solaris already 
parsing modules 	defined amd builds 
make 	cplusplus cplusplus 
luab also 	amd start gcc 
want avoid 	compatibility compatibility 
dump module 	intrin header gcc 
ldump define 	gcc equivalents 
nodump define 	intrinsic microsoft visual 
nodump 	functions originally 
notify.c classes 	developed react http 
flags flags 	www reactos 
res type 	tiny krnl http 
key dbid 	www tinykrnl 
chan chanobj 	projects copyright kjk 
eventobj 	hyperion hackbunny 
len buf 	reactos permission 
sdsempty sdscatlen 	hereby granted free 
sdscatlen sdscatlen 	charge person 
sdscatlen sdscatlen 	obtaining copy software 
sdscatlen sdscatlen 	associated documentation 
sdscatlen 	files software deal 
sdscatlen sdscatlen 	software without 
sdscatlen create 	restriction including without 
strlen sdsnewlen 	limitation rights 
sdscatlen sdscatlen 	use copy modify 
sdscatsds create 	merge publish 
pubsub 	distribute sublicense sell 
publish message 	copies software 
decr count 	permit persons software 
sdsnewlen sdscatlen 	furnished subject 
sdscatlen sdscatsds 	following conditions copyright 
create pubsub 	notice permission 
publish 	notice shall included 
message decr 	copies substantial 
count decr 	portions software 
count copyright 	software provided without 
salvatore sanfilippo 	warranty kind 
antirez gmail 	express implied including 
dot 	limited warranties 
rights reserved 	merchantability fitness particular 
redistribution use 	purpose noninfringement 
source binary 	shall authors copyright 
forms without 	holders liable 
modification permitted 	claim damages liability 
provided 	whether action 
following conditions 	contract tort otherwise 
met redistributions 	arising connection 
source code 	software use dealings 
must retain 	software atomic 
copyright notice 	operations bugbug gcc 
list 	supports full 
conditions following 	barriers note sync 
disclaimer redistributions 	test would 
binary form 	acquire barrier 
must reproduce 	force full barrier 
copyright notice 	end gcc 
list 	compatibility win use 
conditions following 	locks declarations 
disclaimer documentation 	bit scanning win 
materials provided 	avoid pulling 
distribution neither 	win cplusplus cplusplus 
name redis 	bit scan 
names 	forward defined msc 
contributors may 	ver msc 
used endorse 	ver svr systems 
promote products 	omit underscore 
derived software 	use supplied emulation 
without specific 	getpagesize guess 
prior 	size alignment properties 
written permission 	bit size 
software provided 	size constants coerced 
copyright holders 	size annoying 
contributors express 	necessary avoid 
implied warranties 	errors platforms bit 
including 	mask corresponding 
limited implied 	malloc alignment address 
warranties merchantability 	acceptable alignment 
fitness particular 	number bytes offset 
purpose disclaimed 	address align 
shall copyright 	mmap preliminaries morecore 
owner 	mmap define 
contributors liable 	calls checks fail 
direct indirect 	compiler optimizer 
incidental special 	code rather many 
exemplary consequential 	morecore mmap 
damages including 	must mfail failure 
limited 	defined convenience 
procurement substitute 	map anon map 
goods services 	anonymous nearly 
loss use 	versions mmap 
data profits 	support map anonymous 
business interruption 	following unlikely 
however 	needed supplied cached 
caused theory 	file descriptor 
liability whether 	dev zero map 
contract strict 	anonymous win 
liability tort 	win mmap via 
including negligence 	alloc direct 
otherwise 	mmap use mem 
arising way 	top minimize 
use software 	interference function supports 
even advised 	releasing coalesed 
possibility damage 	segments win mmap 
file keyspace 	win mremap 
events 	define call morecore 
notification via 	morecore morecore 
pub sub 	morecore morecore define 
described http 	call mmap 
redis topics 	call munmap 
keyspace events 	call direct mmap 
turn 	mmap mmap 
representing notification 	munmap munmap direct 
classes integer 	mmap direct 
representing notification 	mmap mmap mmap 
classes flags 	define call 
xored function 	mremap mremap mremap 
returns 	mmap mremap 
input contains 	mmap mremap mstate 
characters mapping 	bit continguous 
function exactly 	morecore disabled failed 
revese function 	segment bit 
gets input 	create mspace preliminaries 
integer 	locks defined 
xored flags 	one plus one 
returns representing 	per mspace 
selected classes 	ensures mparams magic 
returned sds 	unique mparams 
needs released 	values initialized 
sdsfree 	also protects sequences 
api provided 	calls morecore 
rest redis 	many cases sys 
core simple 	alloc requires 
function notify 	two calls interleaved 
keyspace robj 	calls threads 
key 	protect direct calls 
dbid representing 	morecore threads 
name key 	still code cope 
redis representing 	best interference 
key name 	per mspace locks 
dbid database 	surround calls 
key 	malloc free etc 
lives notifications 	enable use 
events asap 	layered extensions per 
keyspace key 	mspace locks 
notifications keyevente 	reentrant regions generally 
key notifications 	bounded times 
object.c 	use supplied 
type ptr 	simple spinlocks custom 
ptr len 	versions use 
ptr len 	locks definitions routines 
ptr len 	bypassed need 
humanfriendly buf 	define least initial 
len 	acquire release 
obj type 	possibly used malloc 
llval len 	commonly needed 
emb dec 	extensions custom pthread 
buf flags 	style spin 
bufa bufb 	locks gcc place 
astr 	args cmpxchgl 
bstr alen 	locals evade oddities 
blen minlen 	gccs solaris 
cmp target 	unknown systems linux 
eptr target 	free bsd 
msg target 	apple solaris 
eptr 	win custom win 
target msg 	style spin 
target eptr 	locks msc todo 
target msg 	win use 
target msg 	spin locks pthreads 
encoding lruclock 	locks cope 
key 	old style linux 
key reply 	recursive initialization 
zmalloc lru 	adding skipped declaration 
clock create 	pthread win 
sdsnewlen zmalloc 	win critical sections 
lru clock 	use spin 
memcpy 	loop initialize transition 
memset create 	initializing win 
embedded create 	use spin locks 
raw incr 	use locks 
count create 	user defined locks 
create sdsfromlonglong 	define implementation 
isinf 	define initial 
memcpy memcpy 	define acquire define 
snprintf strchr 	release define 
snprintf create 	mlock malloc mutex 
server create 	use locks 
raw sdslen 	state use locks 
create 	use locks 
embedded sdslen 	use locks use 
create server 	locks chunk 
panic quicklist 	representations following includes 
create create 	lightly edited 
ziplist create 	explanations colin plumb 
dict 	malloc chunk 
create create 	declaration misleading accurate 
intset create 	necessary declares 
ziplist create 	view memory allowing 
zmalloc dict 	access necessary 
create zsl 	fields known offsets 
create 	given chunks 
create ziplist 	memory maintained 
create sdsfree 	boundary tag method 
quicklist release 	originally described 
server panic 	knuth see paper 
dict release 	paul wilson 
zfree 	ftp ftp utexas 
server panic 	edu pub 
dict release 	garbage allocsrv survey 
zsl free 	techniques sizes 
zfree zfree 	free chunks stored 
server panic 	front chunk 
dict 	end makes consolidating 
release zfree 	fragmented chunks 
server panic 	bigger chunks fast 
server panic 	head fields 
free free 	also hold bits 
list free 	representing whether 
free 	chunks free use 
zset free 	pictures make 
hash server 	clearer exploded 
panic zfree 	show state chunk 
decr count 	thought extending 
reply server 	high bits head 
info 	field header 
sdslen server 	prev foot pinuse 
info sds 	bit bit 
encoded sdslen 	following chunk header 
decr count 	chunk use 
incr count 	looks like chunk 
sdsfree 	size previous 
create embedded 	chunk size chunk 
sdslen decr 	mem size 
count sdsavail 	size available payload 
sds free 	bytes chunk 
space sds 	size next chunk 
encoded 	may may 
incr count 	use mem free 
create strlen 	looks like 
server panic 	chunk user 
server info 	payload must use 
sds encoded 	would merged 
sdslen 	size chunk mem 
sds encoded 	next pointer 
sdslen strcoll 	prev pointer size 
memcmp compare 	chunk unused 
objects flags 	bytes chunk size 
compare objects 	chunk size 
flags 	next chunk must 
compare objects 	use would 
server info 	merged mem user 
sds encoded 	payload note 
sdslen sdigits 	since always merge 
server info 	adjacent free 
sds 	chunks chunks adjacent 
encoded strtod 	free chunk 
isspace isnan 	must use 
server panic 	given pointer chunk 
reply error 	derived trivially 
reply 	payload pointer time 
error server 	find whether 
info sds 	adjacent chunks free 
encoded strtold 	unlink lists 
isspace isnan 	merge current chunk 
server panic 	chunks always 
reply 	begin even word 
error reply 	boundaries mem 
error server 	portion returned user 
info sds 	also even 
encoded strtoll 	word boundary thus 
isspace server 	least word 
panic 	aligned pinuse bit 
reply error 	bit stored 
reply error 	unused low order 
reply reply 	bit chunk 
error reply 	size always 
error lru 	multiple two words 
clock 	use bit 
dict find 	previous chunk bit 
dict val 	clear word 
command lookup 	current chunk size 
reply strcasecmp 	contains previous 
command lookup 	chunk size used 
reply 	find front 
reply strcasecmp 	previous chunk first 
command lookup 	chunk allocated 
reply reply 	always bit preventing 
bulk str 	access non 
encoding strcasecmp 	existent non owned 
command 	memory pinuse 
lookup reply 	given chunk cannot 
reply estimate 	determine size 
idle time 	previous chunk might 
reply error 	even memory 
redis implementation 	addressing fault 
copyright 	trying cinuse bit 
salvatore sanfilippo 	bit stored 
antirez gmail 	unused second lowest 
dot rights 	bit chunk 
reserved redistribution 	size redundantly records 
use source 	whether current 
binary 	chunk inuse redundancy 
forms without 	enables usage 
modification permitted 	checks within free 
provided following 	realloc reduces 
conditions met 	indirection freeing consolidating 
redistributions source 	chunks freshly 
code 	allocated chunk must 
must retain 	cinuse pinuse 
copyright notice 	allocated chunk borders 
list conditions 	either previously 
following disclaimer 	allocated still use 
redistributions binary 	chunk memory 
form 	arena ensured 
must reproduce 	making allocations lowest 
copyright notice 	part found 
list conditions 	chunk free chunk 
following disclaimer 	physically borders 
documentation materials 	another one free 
provided 	chunk known 
distribution neither 	preceded followed either 
name redis 	inuse chunks 
names contributors 	ends memory note 
may used 	foot current 
endorse promote 	chunk actually represented 
products 	prev foot 
derived software 	next chunk makes 
without specific 	easier deal 
prior written 	alignments etc confusing 
permission software 	trying extend 
provided copyright 	adapt code 
holders 	exceptions special chunk 
contributors express 	top top 
implied warranties 	available chunk one 
including limited 	bordering end 
implied warranties 	available memory treated 
merchantability fitness 	specially top 
particular 	never included bin 
purpose disclaimed 	used chunk 
shall copyright 	available released back 
owner contributors 	system large 
liable direct 	see trim threshold 
indirect incidental 	effect top 
special 	chunk treated larger 
exemplary consequential 	thus less 
damages including 	well fitting available 
limited procurement 	chunk top 
substitute goods 	chunk doesn update 
services loss 	trailing size 
use 	field since 
data profits 	next contiguous chunk 
business interruption 	would index 
however caused 	however space still 
theory liability 	allocated top 
whether contract 	foot size enable 
strict 	separation merging 
liability tort 	space extended chunks 
including negligence 	allocated via 
otherwise arising 	mmap lowest order 
way use 	bit mmapped 
software even 	bit prev foot 
advised 	fields pinuse 
possibility damage 	bit head fields 
lru current 	allocated one 
lruclock minutes 	one must carry 
resolution create 	prev foot 
encoding obj 	field also used 
encoding 	hold offset 
raw plain 	chunk within 
ptr points 	mmapped region needed 
proper sds 	preserve alignment 
create encoding 	mmapped chunk trailed 
obj encoding 	first two 
embstr 	fields fake next 
sds actually 	chunk sake 
unmodifiable allocated 	usage checks size 
chunk create 	previous chunk 
embstr encoding 	free size inuse 
smaller reids 	bits links 
encoding 	used free type 
embstr size 	bins chunks 
limit otherwise 	described described type 
raw encoding 	various bit 
used current 	flag sets chunks 
limit chosen 	sizes alignments 
biggest 	footers footers mapped 
allocate embstr 	chunks need 
still fit 	second word 
arena jemalloc 	overhead additional padding 
create humanfriendly 	fake next 
non zero 	chunk foot smallest 
use 	size malloc 
exponential format 	aligned minimal chunk 
trims trailing 	conversion malloc 
zeroes end 	headers user pointers 
however results 	back chunk 
loss precision 	associated aligned address 
otherwise 	bounds request 
exp format 	chunk sizes pad 
used output 	request bytes 
snprintf modified 	usable size pad 
humanfriendly option 	request checking 
used incrbyfloat 	minimum maximum operations 
hincrbyfloat 	head foot 
libc odd 	fields head 
systems solaris 	field chunk pinuse 
format infinite 	bit previous 
different way 	adjacent chunk use 
better handle 	cinuse bit 
way 	chunk use chunk 
use digits 	obtained mmap 
precision since 	prev foot field 
bit floats 	mmapped bit 
precision rounding 	otherwise holding offset 
able represent 	mmapped region 
small 	chunk flag bit 
numbers way 	used malloc 
non surprising 	might useful extensions 
user small 	head fenceposts 
numbers represented 	extraction fields head 
way converted 	words treat 
back 	space ptr offset 
exactly user 	chunk ptr 
typed trailing 	next previous 
zeroes duplicate 	physical malloc chunk 
guarantee returned 	extract next 
encoding original 	chunk pinuse bit 
one 	size footer 
function also 	size pinuse bit 
guarantees duplicating 	foot size 
small integere 	pinuse bit foot 
contains representation 	clear next 
small integer 	pinuse overhead associated 
always 	chunk malloced 
result fresh 	space necessarily cleared 
unshared refcount 	mmap clears 
resulting always 	mmap clears overlaid 
refcount variant 	data structures 
decr count 	chunks use treated 
gets 	nodes either 
argument useful 	lists trees small 
free method 	chunks stored 
data structures 	circular doubly 
expect free 	linked lists look 
prototype free 	like chunk 
method 	size previous chunk 
function count 	head size 
zero without 	chunk bytes mem 
freeing useful 	forward pointer 
order pass 	next chunk list 
functions incrementing 	back pointer 
count 	previous chunk list 
received example 	unused space 
function increment 	may bytes nextchunk 
count reset 	foot size 
count create 	chunk bytes larger 
otherwise need 	chunks kept 
resort 	form bitwise digital 
less elegant 	trees aka 
pattern obj 	tries keyed chunksizes 
create function 	malloc chunks 
increment count 	free chunks 
obj decr 	greater bytes size 
count 	doesn impose 
obj encode 	constraints user chunk 
order save 	sizes node 
space make 	looks like chunk 
sure type 	size previous 
encode function 	chunk head size 
types 	chunk bytes 
use encoded 	mem forward pointer 
memory efficient 	next chunk 
representations handled 	size back pointer 
commands implementing 	previous chunk 
type specialized 	size pointer left 
encoding 	child child 
objects raw 	pointer right child 
embstr encoded 	child pointer 
words objects 	parent bin index 
still represented 	chunk unused 
actually chars 	space nextchunk 
safe 	foot size chunk 
encode shared 	bytes holding 
objects shared 	treenodes unique chunk 
objects shared 	sizes chunks 
everywhere space 	size arranged circularly 
redis may 	linked list 
end 	oldest chunk next 
places handled 	used fifo 
handle values 	ordering actually members 
keyspace check 	distinguished non 
represent integer 	parent pointer chunk 
note sure 	size existing 
larger 	node inserted linked 
chars representable 	existing node 
bit integer 	pointers work way 
encodable use 	pointers small 
shared note 	chunks contains 
avoid shared 	power sized range 
integers 	chunk sizes 
maxmemory used 	smallest divided half 
every needs 	level chunks 
lru field 	smaller half range 
lru algorithm 	top nose 
work well 	left subtree larger 
small 	half right 
still raw 	subtree course done 
encoded embstr 	inspecting individual 
encoding efficient 	bits rules node 
representation sds 	left subtree 
allocated chunk 	contains smaller sizes 
memory 	right subtree 
save space 	however node root 
cache misses 	subtree particular 
encode last 	ordering relationship either 
least optimize 	dividing line 
sds inside 	subtree sizes 
require 	trie relation last 
little space 	chunk given 
free space 	size interior need 
end sds 	replace leaf 
relatively large 	node ordering rules 
branch entered 	permit node 
length 	replaced leaf smallest 
greater obj 	chunk common 
encoding embstr 	operation best fit 
size limit 	allocator found 
original decoded 	walking path leftmost 
version encoded 	leaf unlike 
returned 	usual binary follow 
already raw 	left child 
encoded increment 	pointers reach follow 
count compare 	right child 
two objects 	pointer time left 
via strcmp 	one reach 
strcoll 	leaf child 
depending flags 	pointers smallest chunk 
note objects 	somewhere along 
may integer 	path worst number 
encoded use 	steps find 
representation numbers 	node bounded number 
stack 	bits differentiating 
compare much 	chunks within bins 
faster calling 	current bin 
decoded important 	calculations ranges bit 
note redis 	sizes bit 
compare binary 	sizes typical course 
used 	much better 
binary safe 	first four fields 
comparison used 	must compatible 
wrapper compare 	malloc chunk type 
objects flags 	bins trees 
binary comparison 	little helper macro 
wrapper 	trees segments 
compare objects 	malloc space 
flags collation 	may include non 
equal objects 	contiguous segments 
two objects 	held list headed 
point view 	embedded malloc 
comparison 	segment record representing 
otherwise returned 	top space 
note function 	segments also include 
faster checking 	flags holding 
compare perform 	properties space large 
optimization integer 	chunks directly 
encoded 	allocated mmap included 
check stored 	list instead 
given returns 	independently created destroyed 
min number 	without otherwise 
milliseconds never 	keeping track segment 
requested approximated 	management mainly 
lru 	comes play 
algorithm helper 	spaces allocated mmap 
function command 	call mmap 
need lookup 	might might memory 
keys without 	adjacent existing 
modification lru 	segment morecore normally 
parameters 	contiguously current 
command allows 	space space almost 
inspect internals 	always adjacent 
redis usage 	simpler faster deal 
refcount encoding 	morecore used 
idletime key 	preferentially mmap available 
overflow.c 	see sys 
nhchunks mib 	alloc allocating mmap 
miblen max 	use hinting 
size mallctl 	mechanisms inconsistently supported 
mallctlnametomib mallctlbymib 	various implementations 
ptr malloc 	unix mmap distinguish 
ptr 	reserving committing 
malloc ptr 	memory instead 
calloc ptr 	ask space exploit 
calloc malloc 	contiguity probably 
ptr ptr 	possible better systems 
realloc ptr 	general scheme 
realloc 	seems significantly better 
free test 	management entails 
pages.c addr 	simpler variant consolidation 
size ret 	scheme used 
addr size 	chunks reduce fragmentation 
buf addr 	adjacent memory 
alloc 	normally prepended appended 
size leadsize 	existing segment 
size ret 	however limitations compared 
addr trailsize 	chunk consolidation 
addr size 	mostly reflect fact 
commit prot 	segment processing 
result 	relatively infrequent occurring 
addr size 	getting memory 
addr size 	system expect 
addr size 	huge numbers segments 
unzeroed err 	segments indexed 
alloc mmap 	traversal requires linear 
pages 	scans would 
unmap free 	possible index worth 
munmap buferror 	extra overhead 
errno malloc 	complexity programs platforms 
abort pages 	segments appended 
unmap pages 	old ones holding 
map 	top memory 
pages unmap 	cannot prepended others 
pages unmap 	held different 
pages unmap 	segments top segment 
mmap pages 	mstate segment 
unmap pages 	record kept tail 
commit 	segment segments 
impl pages 	added pushing segment 
commit impl 	records onto 
alloc madvise 	list headed 
alloc allocate 	mstate seg containing 
given address 	mstate segment 
one 	flags control allocation 
given fails 	merge deallocation 
returns use 	policies bit allocate 
map cause 	segment deallocate 
replacement existing 	merge others currently 
mappings want 	holds initial 
create 	segment passed create 
mappings succeeded 	mspace mmapped 
mapping memory 	bit segment may 
right place 	merged surrounding 
following decommit 	mmapped segments trimmed 
commit implementation 	allocated munmap 
functional 	neither bit segment 
always disabled 	obtained morecore 
doesn beyong 	merged surrounding 
improved debugging 	morecore segments deallocated 
cost extra 	trimmed morecore 
system calls 	negative arguments address 
systems 	allocated size 
overcommit succeeded 	ptr next segment 
mapping memory 	mmap flag 
right place 	malloc state malloc 
last resort 	state holds 
pages.h addr 	bookkeeping space main 
size 	fields top 
addr size 	topmost chunk currently 
addr alloc 	active segment 
size leadsize 	size cached topsize 
size addr 	actual size 
size addr 	topmost space topsize 
size 	top foot 
addr size 	size includes space 
jemalloc types 	reserved adding 
jemalloc structs 	fenceposts segment 
jemalloc externs 	records necessary getting 
jemalloc inlines 	space system 
posix 	size autotrim top 
memalignc alignment 	cached mparams 
alignment size 	trim check disabled 
alignment size 	autotrim fails 
total err 	designated victim preferred 
buf posix 	chunk servicing 
memalign 	small requests exact 
posix memalign 	fits normally 
posix memalign 	chunk split recently 
posix memalign 	service another 
posix memalign 	small request size 
posix memalign 	cached dvsize 
buferror 	link fields chunk 
errno test 	maintained since 
fail malloc 	kept bin small 
usable size 	bins bin 
free test 	headers free 
define maxalign 	chunks bins hold 
size 	chunks sizes 
pqsort.c swaptype 	less min large 
cmp cmp 	size bytes 
lrange rrange 	bin contains chunks 
swaptype cmp 	size spaced 
result cmp 	bytes apart simplify 
lrange 	use linked 
rrange cmp 	lists bin header 
cmp cmp 	acts malloc 
cmp cmp 	chunk pointing real 
swapinit cmp 	first node 
swap 	exists pointing avoids 
med med 	special casing 
med med 	headers avoid waste 
swap cmp 	allocate pointers 
swap cmp 	bins use repositioning 
swap swap 	tricks treat 
min 	fields chunk 
vecswap min 	bins treebins pointers 
size vecswap 	roots trees 
pqsort pqsort 	holding range sizes 
following net 	equally spaced 
bsd libc 	treebins power two 
qsort 	shift shift 
implementation modified 	last bin holds 
order support 	anything larger 
sorting ranges 	bin maps one 
redis copyright 	bit map 
salvatore sanfilippo 	small bins smallmap 
rights 	one treebins 
reserved original 	treemap bin sets 
copyright notice 	bit non 
follows net 	empty clears bit 
bsd qsort 	empty bit 
lukem exp 	operations used avoid 
copyright 	bin bin 
regents university 	searching nearly 
california rights 	search done without 
reserved redistribution 	ever looking 
use source 	bins won selected 
binary forms 	bit maps 
without 	conservatively use bits 
modification permitted 	per map 
provided following 	word even bit 
conditions met 	system good 
redistributions source 	description bit techniques 
code must 	used see 
retain 	henry warren book 
copyright notice 	hacker delight 
list conditions 	supplement http hackersdelight 
following disclaimer 	many intended 
redistributions binary 	reduce branchiness paths 
form must 	malloc etc 
reproduce 	well reduce 
copyright notice 	number memory locations 
list conditions 	read written 
following disclaimer 	segments list segments 
documentation materials 	headed embedded 
provided distribution 	malloc segment record 
neither 	representing initial 
name university 	space address check 
names contributors 	support least 
may used 	addr field least 
endorse promote 	address ever 
products derived 	obtained morecore mmap 
software 	attempted frees 
without specific 	reallocs address less 
prior written 	trapped unless 
permission software 	insecure defined magic 
provided regents 	tag cross 
contributors express 	check field always 
implied 	hold mparams 
warranties including 	magic flags 
limited implied 	bits recording whether 
warranties merchantability 	use mmap 
fitness particular 	locks contiguous morecore 
purpose disclaimed 	statistics space 
shall 	keeps track current 
regents contributors 	maximum system 
liable direct 	memory obtained via 
indirect incidental 	morecore mmap 
special exemplary 	trim support fields 
consequential damages 	holding amount 
including 	unused topmost memory 
limited procurement 	trigger timming 
substitute goods 	counter force periodic 
services loss 	scanning release 
use data 	unused non topmost 
profits business 	segments locking 
interruption 	use locks defined 
however caused 	mutex acquired 
theory liability 	released around 
whether contract 	every call mspace 
strict liability 	extension support 
tort including 	pointer size field 
negligence 	used help 
otherwise arising 	implement extensions malloc 
way use 	bin types 
software even 	widths sizes locate 
advised possibility 	among fields 
damage qsort 	rarely change use 
routine 	locks unused 
bentley ilroy 	available extensions malloc 
engineering sort 	state malloc 
function iterate 	malloc holds properties 
rather recurse 	including dynamically 
save stack 	mallopt single instance 
space 	mparams initialized 
qsort cmp 	init mparams note 
pqsort.h cmp 	non zeroness 
lrange rrange 	magic also 
following net 	serves initialization flag 
bsd libc 	ensure mparams 
qsort 	initialized malloc state 
implementation modified 	used non 
order support 	mspace calls mspaces 
sorting ranges 	system alloc 
redis copyright 	setup operations mflags 
salvatore sanfilippo 	page align 
antirez 	size granularity align 
gmail dot 	size mmap 
rights reserved 	use granularity alignment 
redistribution use 	windows page 
source binary 	align sys alloc 
forms without 	enough padding 
modification 	ensure malloc request 
permitted provided 	success segment 
following conditions 	holds address 
met redistributions 	segment holding given 
source code 	address segment 
must retain 	contains segment link 
copyright 	morecore cannot 
notice list 	trim morecore cannot 
conditions following 	trim top 
disclaimer redistributions 	foot size padding 
binary form 	end segment 
must reproduce 	including space may 
copyright 	needed place 
notice list 	segment records fenceposts 
conditions following 	noncontiguous segments 
disclaimer documentation 	added hooks preaction 
materials provided 	defined success 
distribution neither 	nonzero failure locking 
name 	redefine anything 
redis names 	like use locks 
contributors may 	preaction postaction 
used endorse 	use locks 
promote products 	corruption error action 
derived software 	triggered upon 
without 	detected bad addresses 
specific prior 	usage error 
written permission 	action triggered detected 
software provided 	bad frees 
copyright holders 	reallocs argument address 
contributors express 	might triggered 
implied 	fault ignored two 
warranties including 	predefined actions 
limited implied 	might useful custom 
warranties merchantability 	actions help 
fitness particular 	diagnose errors count 
purpose disclaimed 	number corruption 
shall 	errors causing resets 
copyright owner 	corruption action 
contributors liable 	proceed error corruption 
direct indirect 	error action 
incidental special 	usage error 
exemplary consequential 	action proceed error 
damages 	debugging setup 
including limited 	debug debug indexing 
procurement substitute 	bins addressing 
goods services 	index see smallbin 
loss use 	repositioning assign 
data profits 	index size variable 
business 	use asm 
interruption however 	possible gnuc gnuc 
caused theory 	bit representing 
liability whether 	maximum resolved size 
contract strict 	treebin shift 
liability tort 	placing maximum resolved 
including 	bit treebin 
negligence otherwise 	sign bit size 
arising way 	smallest chunk 
use software 	held bin index 
even advised 	operations bin 
possibility damage 	maps bit 
see 	corresponding given index 
pqsort file 	mark clear 
original copyright 	bits given index 
notice print.c 	isolate least 
code sbx 	bit bitmap mask 
line full 	bits left 
getstr 	least bit mask 
putchar isprint 	bits left 
putchar putchar 	equal least bit 
ttype bvalue 	index corresponding 
nvalue print 	given bit use 
rawtsvalue ttype 	asm possible 
opcode 	gnuc runtime check 
getarg getarg 	support security 
getarg getarg 	main invariant malloc 
getarg getline 	free etc 
mode mode 	never writes 
isk indexk 	address malloc state 
mode 	unless malloc 
isk indexk 	state corrupted cannot 
mode print 	occur via 
constant getstr 	malloc checks essence 
svalue isk 	means believe 
print constant 	pointers sizes maps 
indexk 	etc held 
isk isk 	malloc state check 
isk print 	linked offsetted 
constant indexk 	embedded data structures 
isk print 	checks interspersed 
constant indexk 	main code way 
getstr 	tends minimize 
print constant 	run time cost 
getstr getstr 	footers defined 
print header 	addition range checking 
print code 	also verify 
print constants 	footer fields 
print 	inuse chunks used 
locals print 	guarantee mstate 
upvalues print 	controlling malloc free 
function print 	intact streamlined 
lhf exp 	version approach described 
print bytecodes 	william robertson 
see 	run time detection 
copyright notice 	heap overflows 
lua cannot 	lisa http www 
happen prng.h 	usenix events 
simple linear 	lisa tech robertson 
congruential pseudo 	html footer 
random 	inuse chunk holds 
number generator 	xor mstate 
prng following 	random seed upon 
constants ensure 	calls free 
maximal period 	realloc probablistically unguessable 
odd number 	outside program 
relatively 	computed code 
prime multiple 	successfully malloc ing 
odd number 	chunk provide 
relatively prime 	protection code already 
see knuth 	broken security 
taocp vol 	means unlike robertson 
details 	always dynamically 
constraints choice 	check addresses offset 
disadvantage quality 	chunks previous 
bits proportional 	next etc turns 
bit position 	cheaper relying 
example lowest 	hashes check address 
bit 	least high 
cycle next 	morecore mmap check 
cycle etc 	address next 
reason prefer 	chunk higher chunk 
use upper 	check cinuse 
bits macro 	bit check pinuse 
parameters 	bit insecure 
result range 	insecure check 
number least 	alleged mstate expected 
significant bits 	magic field 
state seed 	footers insecure footers 
see discussion 	insecure gcc 
prng 	use builtin expect 
bits pseudo 	minimize impact 
randomness jemalloc 	checks gnuc gnuc 
types jemalloc 	insecure insecure 
structs jemalloc 	macros inuse chunks 
externs jemalloc 	without footers 
inlines 	cinuse bit pinuse 
prof.c opt 	bit next 
prof opt 	chunk cinuse pinuse 
prof active 	chunk pinuse 
opt prof 	next chunk size 
active init 	cinuse pinuse 
opt 	bit chunk footers 
prof sample 	foot inuse 
opt prof 	chunk xor 
interval opt 	mstate seed footers 
prof gdump 	setting mparams 
opt prof 	initialize mparams win 
opt 	win sanity 
prof leak 	check configuration size 
opt prof 	must wide 
accum opt 	pointer type ints 
prof prefix 	must least 
prof active 	bytes alignment must 
prof 	least alignment 
active mtx 	min chunk size 
prof active 	page size 
init prof 	must powers morecore 
active init 	contiguous morecore 
mtx prof 	contiguous main malloc 
gdump 	area use 
val prof 	dev urandom 
gdump mtx 	fall back time 
prof interval 	use dev 
prof sample 	random ensure nonzero 
gctx locks 	improve chances 
cum 	fault bad values 
gctxs tdata 	footers insecure 
locks gctx 	footers insecure support 
gctx mtx 	mallopt debugging 
tdatas tdatas 	support check properties 
mtx next 	chunk whether 
thr 	free inuse mmapped 
uid next 	etc check 
thr uid 	properties top chunk 
mtx prof 	third lowest 
dump seq 	bit check properties 
mtx prof 	inuse mmapped 
dump 	chunks check properties 
seq prof 	inuse chunks 
dump iseq 	pinuse mmapped 
prof dump 	previous chunk offset 
mseq prof 	check properties 
dump useq 	free chunks markers 
prof 	always size 
dump mtx 	size size check 
prof dump 	properties malloced 
buf prof 	chunks point malloced 
dump buf 	unless mmapped 
end prof 	size less min 
dump 	chunk size 
prof booted 	request check subtrees 
tctx tsd 	traverse chain 
tctx tdata 	sized nodes one 
even attached 	node chain 
tsd tdata 	parent check chunks 
even 	treebin check 
attached tsd 	chunks smallbin chunk 
name thr 	claims free 
uid thr 	chunk belongs 
uid ret 	bin chunk followed 
thr discrim 	inuse chunk 
thr 	find bin used 
discrim tctx 	check functions 
uid tctx 	traverse chunk check 
uid len 	total consecutive 
len comp 	free check properties 
len ret 	malloc state 
ret 	check bins check 
uid uid 	chunk check 
discrim discrim 	top chunk topsize 
tsd tctx 	chunksize top 
updated tdata 	redundant debug statistics 
ptr usize 	top always 
tctx 	free mallinfo operations 
tsd usize 	smallbins various 
tctx vec 	forms linking unlinking 
tsd tdata 	defined macros 
tsd tdata 	even ones 
idump gdump 	trees typical paths 
nframes 	ugly reduces 
context arg 	reliance inlining support 
context arg 	compilers link 
data data 	free chunk smallbin 
ngctxs thr 	unlink chunk 
uid tsd 	smallbin unlink first 
gctx 	chunk smallbin 
tsd tdata 	replace node binning 
self gctx 	old one 
tdata tctx 	used dvsize known 
gctx tsd 	small operations 
tctx tdata 	trees insert chunk 
gctx 	unlink steps 
destroy tdata 	chained node unlink 
destroy tctx 	sized links 
destroy gctx 	choose node 
tsd tdata 	replacement last node 
btkey gctx 	size leaf 
gctx 	node must replaced 
gctx tsd 	leaf node 
tdata found 	merely one open 
tcache btkey 	left right 
gctx gctx 	make sure lefts 
error tdata 	rights descendants 
tdatas 	correspond properly bit 
tdata arg 	masks use 
tdata count 	rightmost descendant could 
tdata count 	use leaf 
count tsd 	easy locate tends 
tdata propagate 	counteract removal 
err 	leftmosts elsewhere keeps 
filename prof 	paths shorter 
dump open 	minimally guaranteed doesn 
propagate err 	loop much 
ret err 	average node 
propagate err 	near bottom chain 
ret 	parent links 
propagate err 	relink parent children 
slen propagate 	replacement none 
err format 	relays large small 
ret buf 	bin operations 
tctx tdata 	relays calls malloc 
tctx 	free realloc 
gctx tctxs 	memalign etc mspaces 
tctx arg 	mspaces mspaces 
tctxs tctx 	mspaces direct mmapping 
arg propagate 	chunks directly 
err tctxs 	mmapped chunks offset 
tctx 	start mmapped 
arg ret 	region stored prev 
gctx gctxs 	foot field 
gctxs gctx 	chunk allows reconstruction 
arg leak 	required argument 
ngctx tsd 	munmap freed 
gctxs 	also allows adjustment 
tdata gctx 	returned chunk 
next destroy 	meet alignment requirements 
tdatas tdata 	especially memalign 
arg cnt 	also enough space 
tabind tdatas 	allocated hold 
tdata 	fake next chunk 
arg propagate 	size size 
err propagate 	size maintain pinuse 
err cnt 	bit frees 
ret prof 	malloc mmap check 
dump header 	wrap around 
propagate 	realloc mmap shrink 
err gctx 	mmap regions 
gctxs ret 	small size keep 
format mfd 	old chunk 
filename propagate 	big enough big 
err ret 	mspace management 
mfd 	initialize top 
pid nread 	chunk size ensure 
cnt leak 	alignment size 
ngctx filename 	fake trailing chunk 
gctxs gctx 	holding overhead 
arg ret 	space reset update 
propagate 	initialize bins 
err tsd 	mstate otherwise zeroed 
propagate err 	establish circular 
filename leakcheck 	links smallbins corruption 
tdata cnt 	action reinitialize 
tabind leak 	fields forget memory 
ngctx 	proceed error 
gctxs filename 	allocate chunk prepend 
vseq tsd 	remainder chunk 
filename tsd 	successor consolidate remainder 
tdata filename 	first chunk 
filename tsd 	old segment hold 
filename 	noncontiguous region 
buf tsd 	determine locations 
tdata filename 	sizes segment fenceposts 
key hash 	old top 
thr uid 	reset top space 
tsd 	segment record 
thr uid 	push current record 
thr discrim 	insert trailing 
name active 	fenceposts insert rest 
tdata tcache 	old top 
tsd tdata 	bin ordinary free 
even 	chunk system 
attached tsd 	allocation memory system 
tdata even 	morecore mmap 
attached tcache 	directly map large 
tsd tdata 	chunks getting 
even attached 	memory three ways 
tsd 	preferred least 
tdata destroy 	preferred order 
tdata tsd 	call morecore normally 
tdata thr 	contiguously extend 
uid thr 	memory disabled morecore 
discrim name 	contiguous morecore 
active 	main space mmapped 
tdata destroy 	previous contiguous 
tdata tdatas 	call failed call 
tdata arg 	mmap space 
tsd sample 	disabled mmap note 
next destroy 	settings morecore 
tsd 	unable fulfill request 
tdata prof 	mmap mmap 
active current 	used noncontiguous system 
active prof 	allocator useful 
active old 	backup strategy systems 
tsd tdata 	holes address 
tsd 	spaces sbrk cannot 
name ret 	contiguously expand 
size tsd 	heap mmap 
name tdata 	may able find 
tsd tdata 	space call 
active tsd 	morecore cannot usually 
tdata 	contiguously extend 
active init 	memory disabled morecore 
active init 	cases need 
active init 	request enough bytes 
old prof 	system ensure 
gdump current 	malloc bytes upon 
gdump 	success pad 
prof gdump 	enough space top 
old tsd 	foot plus 
memcmp cassert 	alignment pad make 
prof tdata 	sure lose 
prof sample 	bytes boundary round 
threshold 	granularity unit 
update malloc 	first time recovery 
mutex prof 	adjust end 
tctx destroy 	page boundary 
prof tctx 	call morecore size 
destroy malloc 	negative treated 
mutex 	subtract existing available 
unlock prof 	top space 
tctx malloc 	morecore request use 
mutex malloc 	mem continuously 
mutex unlock 	extend old space 
malloc mutex 	cope failure 
prof 	use extend space 
tctx destroy 	use release 
prof tctx 	use space contiguous 
destroy malloc 	path future 
mutex unlock 	mmap fail wraps 
cassert cassert 	around zero 
prof 	noncontiguous morecore first 
tdata malloc 	time initialization 
mutex cassert 	offset top embedded 
prof tdata 	malloc state 
malloc mutex 	merge existing 
unlock prof 	segment consider recent 
idump 	segment traversal 
prof gdump 	suppressed append allocate 
cassert unw 	extended top 
backtrace cassert 	space system deallocation 
cassert unwind 	unmap unlink 
cassert unwind 	mmapped segments contain 
backtrace 	used chunks 
cassert cassert 	unmap first chunk 
reached atomic 	holds entire 
iallocztm offsetof 	segment pinned unlink 
tcache prof 	obsoleted record 
gctx mutex 	back cannot unmap 
choose 	scan first 
tctx memcpy 	segment reset check 
cassert prof 	counter ensure 
enter malloc 	enough room 
mutex tctx 	segment overhead shrink 
empty ckh 	top space 
reached 	granularity size units 
prof malloc 	keeping least 
mutex unlock 	one shrink pinned 
idalloctm tcache 	prefer mremap 
malloc mutex 	fall back munmap 
unlock prof 	avoid wrapping 
tctx 	negative make sure 
empty ckh 	end memory 
prof tdata 	last unmap unused 
destroy malloc 	mmapped segments 
mutex unlock 	failure disable autotrim 
malloc mutex 	avoid repeated 
tctx 	failed future calls 
prof gctx 	malloc support 
destroy reached 	allocate large request 
malloc mutex 	best fitting 
unlock prof 	chunk treebin 
gctx destroy 	negation traverse bin 
prof 	looking node 
tdata prof 	size deepest untaken 
tdata destroy 	right subtree 
idalloctm tcache 	least subtree holding 
prof enter 	sizes root 
ckh search 	next non empty 
prof 	treebin find 
gctx create 	smallest subtree better 
prof ckh 	fit malloc 
insert prof 	use split allocate 
idalloctm tcache 	small request 
malloc mutex 	best fitting chunk 
malloc 	treebin realloc 
mutex unlock 	support either shrink 
prof cassert 	extend top 
prof tdata 	malloc copy free 
malloc mutex 	already big 
ckh search 	enough expand 
malloc 	top memalign support 
mutex unlock 	use malloc 
prof lookup 	must least minimum 
tcache iallocztm 	chunk size 
prof gctx 	ensure power test 
destroy memset 	isn needed 
malloc 	avoids compiler warning 
mutex ckh 	misaligned find 
insert malloc 	aligned spot inside 
mutex unlock 	chunk since 
prof gctx 	need give back 
destroy idalloctm 	leading space 
malloc 	chunk least min 
mutex tctx 	chunk size 
insert malloc 	first calculation places 
mutex unlock 	spot less 
prng log 	min chunk size 
log malloc 	leader move 
mutex 	next aligned 
tdata iter 	spot allocated enough 
malloc mutex 	total room 
unlock tsd 	always possible mmapped 
fetch prof 	chunks adjust 
tdata malloc 	offset otherwise give 
mutex 	back leader 
ckh count 	use rest give 
malloc mutex 	back spare 
unlock creat 	room end comalloc 
malloc abort 	coalloc support 
jemalloc cassert 	provides common support 
write 	independent routines 
malloc write 	handling combinations result 
abort prof 	opts arg 
dump flush 	bit elements size 
close cassert 	sizes bit 
strlen prof 	elements zeroed 
dump 	chunksize element total 
flush memcpy 	size elements 
start malloc 	request size pointer 
vsnprintf end 	malloced aggregate 
prof dump 	space corresponding chunk 
write malloc 	remaining bytes 
mutex 	splitting either chunks 
malloc mutex 	malloced ptr 
unlock malloc 	chunk malloced ptr 
mutex unlock 	disable mmap 
memcpy reached 	compute length needed 
prof tctx 	nothing empty 
merge 	req must still 
gctx reached 	chunk representing 
prof dump 	empty compute total 
reached reached 	element size 
cassert malloc 	size sizes allocate 
mutex gctx 	aggregate chunk 
insert 	first disable 
memset malloc 	direct mmapping malloc 
mutex unlock 	won use 
malloc mutex 	since would able 
tctx iter 	later free 
malloc mutex 	realloc space segregated 
unlock 	mmap region 
prof tdata 	optionally clear elements 
gctx first 	provided allocate 
gctx malloc 	pointer part chunk 
mutex tctx 	split elements 
iter tctx 	element absorbs overallocation 
next 	slop element 
tctx idalloctm 	must exactly exhausted 
tcache prof 	chunk debug 
gctx destroy 	routines basic algorithm 
malloc mutex 	small request 
unlock prof 	bytes minus per 
gctx 	chunk overhead 
destroy malloc 	one exists 
mutex unlock 	use remainderless chunk 
malloc mutex 	associated smallbin 
memset ckh 	remainderless means excess 
iter prof 	bytes represent 
tctx 	chunk big enough 
merge tdata 	use chunk 
malloc mutex 	normally chunk adjacent 
unlock prof 	one used 
dump prof 	recent small request 
dump malloc 	one exists 
mutex 	split smallest available 
tdata iter 	chunk bin 
malloc mutex 	saving remainder big 
unlock jemalloc 	enough use 
cassert prof 	top chunk available 
dump prof 	memory system 
dump 	use otherwise large 
prof dump 	request find 
tctx iter 	smallest available 
start malloc 	binned chunk fits 
vsnprintf end 	use better 
open cassert 	fitting chunk splitting 
prof 	necessary better 
open maps 	fitting binned chunk 
getpid prof 	use chunk 
open maps 	big enough use 
prof open 	top chunk 
maps prof 	request size mmap 
dump 	threshold directly 
write prof 	mmap chunk available 
dump flush 	memory system 
read close 	use ugly ensure 
malloc malloc 	postaction occurs 
malloc mutex 	along paths initialize 
prof 	sys alloc 
dump gctx 	locks remainderless fit 
malloc mutex 	smallbin uses 
unlock cassert 	next bin 
prof tdata 	idx empty use 
malloc mutex 	chunk next 
prof 	nonempty smallbin fit 
enter gctx 	cannot remainderless 
ckh iter 	sizes big allocate 
prof dump 	force failure 
gctx prep 	sys alloc split 
memset malloc 	exhaust split 
mutex 	top consolidate freed 
tdata iter 	chunks preceding 
malloc mutex 	succeeding bordering free 
unlock gctx 	chunks exist 
iter prof 	place bin intermixed 
prof dump 	special cases 
open 	top mmapped chunks 
prof dump 	usage errors 
header gctx 	footers footers 
iter prof 	consolidate backward consolidate 
dump maps 	forward footers 
prof dump 	force downstream failure 
close 	overflow realloc 
prof gctx 	zero bytes frees 
finish malloc 	footers footers 
mutex unlock 	serves element mallinfo 
prof leakcheck 	mspaces user 
prof dump 	mspaces mspace versions 
close 	routines near 
prof gctx 	clones versions nice 
finish malloc 	better alternatives 
mutex unlock 	remainderless fit smallbin 
cassert malloc 	uses next 
snprintf getpid 	bin idx empty 
malloc 	use chunk 
snprintf getpid 	next nonempty smallbin 
cassert tsd 	fit cannot 
fetch malloc 	remainderless sizes 
mutex prof 	big allocate force 
dump filename 	failure sys 
malloc 	alloc split exhaust 
mutex unlock 	split top 
prof dump 	footers footers consolidate 
cassert tsd 	backward consolidate 
fetch prof 	forward force downstream 
tdata malloc 	failure overflow 
mutex 	realloc zero bytes 
prof dump 	frees footers 
filename malloc 	footers serves element 
mutex unlock 	mallinfo mspaces 
prof dump 	alternative morecore functions 
cassert tsd 	guidelines creating 
fetch 	custom version morecore 
malloc mutex 	best performance 
prof dump 	morecore allocate multiples 
filename malloc 	pagesize morecore 
mutex unlock 	may allocate 
prof dump 	memory requested even 
cassert 	less usually 
tsd fetch 	result malloc failure 
prof tdata 	morecore must 
malloc mutex 	allocate memory given 
prof dump 	argument zero 
filename malloc 	instead one past 
mutex 	end address 
unlock prof 	memory previous nonzero 
dump cassert 	call best 
hash cassert 	performance consecutive calls 
memcmp malloc 	morecore positive 
mutex malloc 	arguments increasing addresses 
mutex 	indicating space 
unlock cassert 	contiguously extended even 
tcache iallocztm 	though consecutive 
prof tdata 	calls morecore need 
mutex choose 	contiguous addresses 
ckh idalloctm 	must malloc 
prof 	chunks span multiple 
sample threshold 	regions cases 
update malloc 	happen contiguous morecore 
mutex tdata 	need handle 
insert malloc 	negative arguments may 
mutex unlock 	instead mfail 
prof 	given negative arguments 
tdata init 	negative arguments 
impl prof 	always multiples pagesize 
thr uid 	morecore must 
alloc prof 	misinterpret negative args 
active init 	large positive 
ckh 	args suppress calls 
count prof 	even occurring 
tdata destroy 	defining morecore cannot 
tsd prof 	trim example 
tdata tdata 	alternative morecore 
tcache idalloctm 	custom allocator kindly 
ckh 	contributed pre 
idalloctm malloc 	osx mac uses 
mutex prof 	virtually necessarily 
tdata destroy 	physically contiguous non 
locked malloc 	paged memory 
mutex unlock 	locked present won 
malloc 	swapped use 
mutex prof 	uncommenting section adding 
tdata destroy 	includes setting 
tsd prof 	appropriate defines define 
tdata malloc 	morecore core 
mutex unlock 	also shutdown routine 
prof 	somehow called 
tdata destroy 	cleanup upon program 
prof name 	exit define 
alloc prof 	max pool entries 
tdata detach 	define minimum 
prof tdata 	morecore size 
init 	next pool pools 
impl malloc 	max pool 
mutex prof 	entries core size 
tdata destroy 	ptr sbrk 
malloc mutex 	top size size 
unlock prof 	minimum morecore 
tdata 	size size minimum 
expire malloc 	morecore size 
mutex malloc 	current execution level 
mutex tdata 	task level 
iter tdata 	ptr pool allocate 
next prof 	resident size 
tdata 	page size ptr 
destroy locked 	mfail save 
malloc mutex 	ptrs freed cleanup 
unlock malloc 	pools next 
mutex unlock 	pool ptr next 
tsd prof 	pool ptr 
tdata 	size ptr 
prof tdata 	page mask page 
detach malloc 	mask sbrk 
mutex malloc 	top ptr size 
mutex unlock 	ptr size 
malloc mutex 	currently support shrink 
malloc 	behavior mfail 
mutex unlock 	sbrk top cleanup 
tsd fetch 	allocated memory 
prof tdata 	pools called last 
strlen iallocztm 	thing shutting 
tcache memcpy 	driver cleanup mem 
prof 	ptr ptr 
tdata isgraph 	pools ptr pools 
isblank prof 	max pool 
name alloc 	entries ptr ptr 
idalloctm tcache 	pool deallocate 
strlen tsd 	ptr ptr history 
fetch 	yet released 
prof tdata 	mspace mmap 
tsd fetch 	large chunks thanks 
prof tdata 	jean brouwers 
malloc mutex 	fix insufficient sys 
malloc mutex 	alloc padding 
unlock 	alignment fix bad 
malloc mutex 	error check 
malloc mutex 	mspace footprint adaptations 
unlock malloc 	ptmalloc courtesy 
mutex malloc 	wolfram gloger reentrant 
mutex unlock 	spin locks 
malloc 	courtesy earl chew 
mutex malloc 	others win 
mutex unlock 	improvements courtesy niall 
cassert memcpy 	douglas earl 
cassert cassert 	chew segment traversal 
malloc mutex 	max release 
init 	check rate 
malloc mutex 	options extension hook 
init malloc 	malloc state 
mutex init 	various small adjustments 
tsd fetch 	reduce warnings 
ckh malloc 	compilers various configuration 
mutex 	extensions changes 
init tdata 	platforms thanks contributed 
malloc mutex 	thu sep 
init malloc 	doug lea gee 
mutex init 	max footprint 
malloc mutex 	functions ensure appropriate 
init 	literals size 
malloc mutex 	fix conditional compilation 
init atexit 	problem define 
malloc write 	settings avoid concatenating 
abort alloc 	segments one 
malloc mutex 	provided create mspace 
init 	rename variables 
alloc malloc 	avoid compiler 
mutex init 	shadowing warnings use 
unwind backtrace 	initialization better 
malloc mutex 	handling sbrk interference 
prefork malloc 	simplify fix 
mutex 	segment insertion trimming 
prefork malloc 	mspace destroy 
mutex prefork 	reinstate realloc zero 
malloc mutex 	bytes frees 
prefork malloc 	option thanks especially 
mutex 	dennis flanagan 
prefork malloc 	help sun jun 
mutex prefork 	doug lea 
malloc mutex 	gee fix memalign 
postfork parent 	brace error 
malloc mutex 	wed jun doug 
postfork 	lea gee 
parent malloc 	fix improper endif 
mutex postfork 	nesting casts 
parent malloc 	needed mon 
mutex postfork 	may doug lea 
parent malloc 	gee use 
mutex 	trees large bins 
postfork parent 	support mspaces 
malloc mutex 	use segments unify 
postfork parent 	sbrk mmap 
malloc mutex 	system allocation removing 
postfork child 	need emulation 
malloc 	platforms without sbrk 
mutex postfork 	safety checks 
child malloc 	optional footer checks 
mutex postfork 	thanks william 
child malloc 	robertson idea code 
mutex postfork 	refactoring incorporate 
child 	suggestions platform specific 
malloc mutex 	changes thanks 
postfork child 	dennis flanagan colin 
malloc mutex 	plumb niall 
postfork child 	douglas aaron 
data minimize 	bachmann emery berger 
memory 	others speed 
bloat non 	non fastbin processing 
prof builds 	enough fastbins 
initialized opt 	useless cfree avoid 
prof active 	conflicts apps 
accessed via 	memcpy memset compilers 
prof 	handle builtins 
active unlocked 	better options one 
initialized opt 	ever used 
prof active 	rename others sat 
init accessed 	aug doug 
via prof 	lea gee fix 
active 	malloc state 
init initialized 	bitmap misdeclaration thu 
opt prof 	jul doug 
gdump accessed 	lea gee allow 
via prof 	tuning first 
gdump unlocked 	sorted bin 
table 	size use ptr 
mutexes shared 	type ptr 
among gctx 	casts thanks john 
leaf locks 	belmonte better 
problem one 	detection support non 
gctx time 	contiguousness morecore 
primary 	thanks andreas mueller 
motivation sharing 	conal walsh 
though gctx 	wolfram gloger bypass 
ephemeral destroying 	malloc frees 
mutexes causes 	thanks emery berger 
complications systems 	fix freeing 
allocate 	old top non 
creating destroying 	contiguous chunk 
mutexes atomic 	sysmalloc raised trim 
counter table 	map thresholds 
mutexes shared 	fix mmap 
among tdata 	related defines thanks 
operations 	lubos lunak 
require holding 	fix copy macros 
multiple tdata 	added lacks 
locks problem 	fcntl thanks neal 
one tdata 	walfield branch 
time even 	free bin calculation 
though 	trim mmap 
gctx may 	thresholds sun mar 
acquired holding 	doug lea 
tdata hash 	gee introduce independent 
prof prof 	comalloc independent 
gctx master 	calloc thanks michael 
data 	pachos motivation 
structure knows 	help make optional 
backtraces currently 	file available 
captured extant 	allow requests bit 
prof tdata 	systems win 
structures regardless 	sbrk mmap 
state 	munmap code walter 
attached detached 	sys thanks 
expired buffer 	also andreas mueller 
rather large 	mueller paradatec 
stack allocation 	anonymous allow malloc 
use single 	alignment thanks 
buffer 	ruud waij helping 
profile dumps 	test memalign 
minimize memory 	check alignment arg 
bloat non 	realloc shift 
prof builds 	chunks backwards since 
dump profiles 	leads fragmentation 
bootstrapping 	programs doesn seem 
complete function 	help others 
prototypes functions 	collect cases malloc 
referenced prior 	requiring system 
definition red 	memory sysmalloc use 
black trees 	mmap backup 
compute 	sbrk place 
sample threshold 	state malloc state 
isn important 	introduce fastbins 
practice function 	although similar many 
rarely executed 	minor tunings 
potential sample 	cosmetic improvements introduce 
bias 	use malloc 
minimal contrived 	wrappers use malloc 
programs create 	introduce malloc 
single allocation 	failure action morecore 
space vec 	contiguous thanks 
length len 	tony bennett tbennett 
nlimbo 	nvidia others 
order avoid 	include errno support 
race condition 	failure action 
prof tctx 	sun dec doug 
destroy prof 	lea gee 
gctx destroy 	negative arguments added 
duplicate 	several win 
check gctx 	cleanups martin 
still unused 	fong mcfong yahoo 
cache destroying 	lacks sys 
prof lookup 	param systems without 
increments gctx 	sys param 
nlimbo 	win platforms cleanup 
order avoid 	header file 
race condition 	inclusion win platforms 
function prof 	cleanup code 
tctx destroy 	avoid microsoft visual 
order avoid 	compiler complaints 
race 	use prefix quickly 
main body 	allow existence 
prof tctx 	existing memory allocation 
destroy entry 	routines malloc 
function gctx 	getpagesize win platforms 
gctx destroy 	needs work 
gctx 	use rather 
compensate increment 	win code conform 
prof tctx 	usage non 
destroy prof 	win code improve 
lookup tctx 	win sbrk 
tdata must 	emulation find region 
held 	routine avoid 
tctx tdata 	infinite loop always 
held upon 	call rather 
entry released 	free wed jun 
increment gctx 	doug lea 
nlimbo order 	gee ordering problem 
keep 	boundary stamping 
another winning 	sun may doug 
race destroy 	lea gee 
gctx one 	added pvalloc recommended 
gctx dropped 	liu added 
without would 	bit pointer support 
possible 	mainly wolfram 
another sample 	gloger added 
allocation associated 	anonymously donated win 
gctx deallocate 	sbrk emulation 
sampled successfully 	malloc calloc getpagesize 
prof gctx 	optimizations raymond 
destroy 	nijssen malloc extend 
gctx result 	top fix 
would gctx 	mask error caused 
longer exists 	wastage foreign 
time accesses 	sbrks linux mremap 
prof gctx 	support code 
destroy 	liu tue dec 
dumping needs 	doug lea 
tctx remain 	gee integrated documentation 
valid dumping 	code support 
finished change 	mmap help wolfram 
state dumping 	gloger gloger 
complete 	lrz uni muenchen 
destruction late 	use last 
dump iteration 	remainder cases 
phase never 	pack bins idea 
seen insert 	colin nyx 
oom increment 	edu use ordered 
nlimbo 	bins instead 
order avoid 	best fit threshold 
race condition 	eliminate block 
prof tctx 	local decls simplify 
destroy prof 	tracing debugging 
gctx destroy 	support another realloc 
note 	via move 
negative cache 	top fix error 
lacks look 	occurring initial 
cache link 	sbrk word aligned 
prof tctx 	rely page 
gctx body 	size units instead 
function 	sbrk unit 
compiled unless 	avoid surprises sbrk 
heap profiling 	alignment conventions 
enabled possible 	mallinfo mallopt 
compile jemalloc 	thanks raymond nijssen 
floating point 	raymond ele 
support 	tue suggestion pad 
completely disabled 	argument malloc 
avoiding floating 	trim top pad 
point code 	mallopt parameter 
important memory 	precautions cases routines 
constrained systems 	call sbrk 
also 	courtesy wolfram gloger 
enables workaround 	gloger lrz 
versions glibc 	uni muenchen added 
properly save 	macros etc 
restore floating 	allowing use linux 
point registers 	libc hjl 
lazy 	gnu mit edu 
symbol loading 	inverted history 
internally calls 	list sat 
whatever malloc 	dec doug lea 
implementation happens 	gee tuned 
integrated application 	behave nicely changes 
note 	removed preallocation 
compilers gcc 	code since current 
may use 	scheme work 
floating point 	required undo bad 
registers fast 	preallocations exceeds 
memory moves 	work saved good 
jemalloc 	cases test 
must compiled 	programs longer use 
optimizations disabled 	list unconsolidated 
mno sse 	bins since scheme 
order workaround 	consistently outperforms 
complete compute 	given changes use 
sample 	best fit 
interval geometrically 	large chunks prevent 
distributed random 	worst cases 
variable mean 	added support 
prof sample 	debugging sat nov 
log tdata 	doug lea 
bytes 	gee removed footers 
sample log 	chunks use 
prof sample 	thanks paul wilson 
information math 	wilson texas 
see non 	edu suggestion wed 
uniform random 	nov doug 
variate 	lea gee added 
generation luc 	malloc trim 
devroye springer 	help wolfram gloger 
verlag york 	wmglo dent 
http luc 	med uni muenchen 
devroye rnbookindex 	tue apr 
html 	doug lea tue 
flush buffer 	apr doug 
full finish 	lea realloc expand 
writing write 	directions malloc 
much fit 	swap order 
tctx tdata 	clean bin strategy 
held 	realloc conditionally 
gctx held 	expand backwards scavenge 
tctx gctx 	used bins 
held since 	use bin counts 
dumping started 	guide preallocation 
ignore gctx 	occasionally bin list 
held 	chunks first 
captured dump 	scan optimizations colin 
tctx gctx 	nyx edu 
held since 	sat aug doug 
dumping started 	lea faster 
ignore increment 	bin computation slightly 
nlimbo 	different binning 
gctx won 	merged consolidations one 
away dump 	part malloc 
additionally link 	proper eliminating old 
gctx dump 	malloc find 
list included 	space malloc 
prof 	clean bin scan 
dump second 	returns chunks 
pass standard 	propagate failure realloc 
iteration won 	malloc returns 
work soon 	stuff allow compilation 
decrement gctx 	non ansi 
nlimbo 	compilers kpv research 
unlock gctx 	att sat 
another concurrently 	aug doug lea 
destroy corrupt 	oswego edu 
therefore tear 	removed potential odd 
one node 	address access 
time 	prev chunk removed 
iteration gctx 	dependency getpagesize 
held avoid 	misc cosmetics bit 
dumping gctx 	documentation anticosmetics 
useful data 	mangled names macros 
make space 	evade debugger 
prof 	strangeness tested 
dump buf 	sparc dec mips 
read put 	gcc dec 
gctx limbo 	allowing detlefs zorn 
clear counters 	comparison study 
preparation summing 	sigplan notices trial 
iterate 	version fri 
tdatas non 	aug doug lea 
expired ones 	oswego edu 
snapshot tctx 	loosely libg malloc 
stats merge 	retains overall 
associated gctx 	structure old version 
merge 	details differ 
tctx stats 	match-trees.c mode path 
gctx create 	score mode 
dump file 	mode path score 
dump profile 	mode mode 
header dump 	path score 
per 	desc hash buffer 
gctx profile 	size hash 
stats dump 	hash one two 
proc pid 	one buf 
maps possible 	two buf score 
prefix pid 	got entry 
seq 	one got entry 
vseq heap 	two cmp 
prefix pid 	hash hash best 
seq heap 	score best 
filename specified 	match recurse limit 
automatically generate 	one one 
one 	buf path elem 
initialize empty 	mode score 
cache tdata 	newbase hash prefix 
must held 	hash result 
tdatas mtx 	subpath toplen buf 
must held 	desc rewrite 
detach 	rewrite subtree 
destroy tdata 	status name mode 
detaching would 	sha hash 
allow another 	hash shifted depth 
win race 	limit prefix 
destroy tdata 	del prefix score 
validate 	del score 
input opt 	mode hash hash 
prof must 	shifted shift 
state arenas 	prefix sub sub 
initialized function 	mode mode 
must executed 	candidate best score 
early 	score isdir 
enable opt 	islnk isdir isdir 
prof way 	islnk islnk 
profiles never 	isdir isdir islnk 
automatically dumped 	islnk isdir 
cause backtracing 	islnk read sha 
machinery 	file die 
allocate state 	sha hex 
enabling profiling 	die sha hex 
prof.h vec 	init desc 
len curobjs 	name compare entry 
curbytes accumobjs 	len entry 
accumbytes 	len fill desc 
tdata thr 	strict fill 
uid thr 	desc strict entry 
discrim cnts 	entry name 
gctx tctx 	entries compare score 
uid prepared 	missing score 
state 	missing hashcmp score 
dump cnts 	differs score 
nlimbo tctxs 	matches free free 
cnt summed 	fill desc 
vec thr 	strict entry extract 
uid thr 	isdir score 
discrim 	trees free xstrfmt 
name attached 	xstrfmt match 
expired tctx 	trees free 
uid next 	update entry free 
tctx prng 	strchrnul read 
state bytes 	sha file die 
sample 	sha hex 
enq enq 	init desc entry 
idump enq 	extract strlen 
gdump dumping 	memcmp isdir die 
active cnt 	sha hex 
summed vec 	update entry die 
opt 	sha hex 
prof opt 	splice hashcpy write 
prof active 	sha file 
opt prof 	free score trees 
active init 	xcalloc xcalloc 
opt prof 	match trees match 
sample 	trees hashcpy 
opt prof 	entry die 
interval opt 	sha hex splice 
prof gdump 	entry isdir 
opt prof 	entry isdir score 
opt prof 	trees score 
leak 	trees score trees 
opt prof 	hashcpy splice 
accum opt 	hashcpy heh found 
prof prefix 	sha collisions 
prof active 	different kind objects 
prof gdump 	inspect two 
val 	trees give score 
prof interval 	tells similar 
prof sample 	two lacks entry 
tsd tctx 	two entries 
updated ptr 	path appear two 
usize tctx 	path appear 
tsd 	one different subtree 
usize tctx 	blob match 
vec tsd 	one subtrees 
prof dump 	two pick best 
open prof 	match hash 
dump header 	subdirectory prefix come 
filename 	replacing another 
tsd tsd 	hash trying come 
tdata tsd 	merge one 
sample tsd 	two results shape 
active tsd 	similar one 
name active 	two might correspond 
active 	subtree one 
init active 	needs shifted prefixing 
tdata tsd 	otherwise empty 
create tsd 	directories hand could 
usize commit 	cover one 
tdata tsd 	might need pick 
usize 	subtree needswork 
prof active 	limits recursion depth 
update ptr 	hardcoded avoid 
ptr usize 	excessive overhead 
tctx ptr 	see one subtree 
usize old 	resembles two 
ptr 	need prefix two 
tctx ptr 	fake trees 
usize tctx 	match prefix see 
ptr usize 	two subtree 
tctx tsd 	resembles one need 
ptr usize 	pick subtree 
tctx 	two shifting need 
prof active 	pick subtree 
updated old 	two user says 
ptr old 	trees shifted 
usize old 	much unfortunately cannot 
tctx tsd 	fundamentally tell 
ptr 	one prefixed recursive 
usize tsd 	merge work 
create tdata 	either direction hash 
ptr ptr 	shift prefix 
usize tctx 	hash hash 
ptr 	shift prefix hash 
usize old 	plausible need 
ptr old 	evaluate score neither 
tctx tsd 	plausible shift 
usize update 	shift adding shift 
tdata tdata 	prefix match 
tsd 	shift removing shift 
usize prof 	prefix match 
active update 	memmem.c haystack haystack 
ret tdata 	len needle 
ptr usize 	needle len begin 
tctx tsd 	last possible 
ptr 	tail point memcmp 
usize tctx 	first occurrence 
prof active 	empty deemed occur 
updated old 	beginning sanity 
ptr old 	check otherwise 
usize old 	loop might search 
tctx 	whole memory 
sampled old 	merge-base.c rev rev 
sampled tsd 	show result 
ptr usize 	merge usage arg 
tctx cassert 	revkey count 
tsd prof 	args revs result 
tdata 	count args 
unlikely tsd 	show revs result 
nominal prof 	argc argv 
tdata init 	one two commit 
tsd prof 	alloc sha 
tdata unlikely 	revs commit osha 
prof 	nsha ident 
tdata reinit 	timestamp message cbdata 
tsd prof 	revs argc 
tdata cassert 	argv sha refname 
arena prof 	commitname revs 
tctx cassert 	derived bases 
arena 	ret argc argv 
prof tctx 	prefix rev 
cassert arena 	rev show cmdmode 
prof tctx 	options merge 
reset cassert 	bases many dirty 
prof tdata 	oid hex 
prof 	sha die lookup 
sample threshold 	commit reference 
update likely 	die commit list 
prof sample 	insert commit 
accum update 	reference reduce heads 
init prof 	oid hex 
backtrace 	commit list insert 
prof lookup 	commit reference 
cassert isalloc 	reduce heads octopus 
unlikely prof 	merge bases 
malloc sample 	oid hex die 
prof tctx 	commit reference 
cassert 	commit reference 
isalloc prof 	merge bases sha 
sample accum 	lookup commit 
update unlikely 	parse commit alloc 
prof malloc 	grow one 
sample prof 	commit one commit 
tctx 	dwim strlen 
reset unlikely 	die die sha 
prof free 	die lookup 
sampled prof 	commit reference memset 
tctx cassert 	reflog ent 
isalloc unlikely 	merge bases many 
prof 	dirty oid 
free sampled 	hex free commit 
option defaults 	list git 
hard limit 	config parse options 
stack backtrace 	usage options 
depth version 	die handle ancestor 
prof 	die handle 
backtrace builtin 	octopus handle 
address necessarily 	independent usage options 
hard coded 	handle fork 
number backtrace 	point usage options 
frame handlers 	alloc commit 
kept 	reference show merge 
sync setting 	good one 
initial hash 	one merge found 
table size 	common ancestor 
size memory 	among reflog entries 
buffer use 	found one 
writing 	must one reflog 
dump files 	entries found 
size stack 	found merge-blobs.c obj 
allocated buffer 	buf size 
used prof 	path size merge 
number mutexes 	status res 
shared 	path size res 
among gctx 	common read 
space allocated 	sha file 
unless profiling 	free free merge 
enabled okay 	read sha 
provision number 	file fill mmfile 
mutexes 	blob fill 
shared among 	mmfile blob fill 
tdata space 	mmfile blob 
allocated unless 	xstrdup three way 
profiling enabled 	filemerge free 
okay provision 	mmfile free mmfile 
prof 	free mmfile 
tdata pointers 	function used cmd 
close used 	merge respect 
encode state 	merge conflictstyle option 
information used 	need worry 
cleaning shutdown 	label common ancestor 
jemalloc 	removed either 
types backtrace 	branch note 
stored len 	depends caller done 
program counters 	proper warning 
data structure 	removing file got 
passed libgcc 	modified branch 
unwind 	merge-blobs.h blob blob 
backtrace callback 	blob merge 
functions profiling 	blobs merge-file.c merge 
counters dumper 	file usage 
must finish 	opt arg unset 
destroying data 	label count 
performed 	names argc argv 
allocation copy 	prefix names 
tdata thr 	mmfs result xmp 
uid discrim 	stdout quiet 
necessary tdata 	prefixlen options fname 
may defunct 	filename fpath 
teardown 	error git config 
profiling counters 	parse options 
tdata associated 	usage options 
context uid 	freopen error strerror 
distinguishes multiple 	strlen prefix 
tctx created 	filename read mmfile 
coexisting 	buffer binary 
gctx tctxs 	error xdl merge 
two ways 	free prefix 
coexistence occur 	filename fopen error 
dumper cause 	fwrite error 
tctx retained 	fclose error free 
purgatory 	read configuration 
state although 	file merge-index.c pgm 
single producer 	one shot 
must create 	quiet err pos 
tctx share 	path found 
thr uid 	arguments hexbuf ownbuf 
multiple 	stage path 
consumers concurrently 	pos argc argv 
execute portions 	prefix force 
prof tctx 	file arg 
destroy prof 	die stage strcmp 
tctx destroy 	sha hex 
gets 	xsnprintf die run 
called time 	command opt 
cnts cur 	die exit cache 
objs bytes 	name pos 
drop threshold 	strlen merge entry 
hit first 	stage merge 
consumer 	entry signal usage 
finishes executing 	read cache 
prof tctx 	strcmp strcmp strcmp 
destroy linkage 	strcmp merge 
gctx tctxs 	die merge one 
prof alloc 	path die 
prep 	already exists cache 
prof malloc 	stage already 
sample prevents 	merged nothing without 
sample destroy 	cannot rely 
race current 	waitpid tell 
dump related 	happened children merge-ours.c 
state 	builtin merge 
gctx copy 	usage diff index 
cnts snapshotted 	args argc 
early dump 	argv prefix strcmp 
phase dump 	usage cmd 
mtx protects 	diff index exit 
nlimbo 	exit implementation 
cnt summed 	git merge builtin 
tctxs number 	copyright thomas 
threads currently 	harning original original 
cause gctx 	copyright junio 
state limbo 	hamano pretend resolved 
due 	heads declare 
one initializing 	trumps everybody need 
gctx initializing 	exit index 
per counters 	match head 
associated gctx 	current index committing 
preparing destroy 	merge result 
gctx 	merge-recursive.c one two 
dumping heap 	subtree shift 
profile includes 	shifted comment commit 
gctx nlimbo 	desc pair 
must single 	pair branch branch 
destroyer order 	dst entry 
safely 	dst entry ren 
destroy gctx 	ren mode 
profile counters 	sha rename conflict 
one allocated 	info setup 
context linkage 	rename conflict info 
contexts dumped 	fmt commit 
temporary 	title msg len 
storage summation 	mode sha 
dump associated 	path stage refresh 
backtrace backtrace 	options desc 
vector variable 	index common 
size referred 	head merge opts 
monotonically 	result sha 
increasing unique 	path mode stage 
monotonically increasing 	context baselen 
discriminator among 	match path entries 
tdata structures 	item unmerged 
associated thr 	item one two 
uid 	onelen twolen 
included heap 	cmp entries sorted 
profile dumps 	entries last 
non counter 	file last len 
used initialize 	next path 
prof tctx 	len pair src 
tctx 	entry dst 
uid locking 	entry entries renames 
necessary incrementing 	opts item 
field one 	pair path clear 
ever hash 	options entry 
prof prof 	clean path 
tctx 	update cache update 
tracks backtraces 	working directory 
non zero 	path branch newpath 
allocation deallocation 	suffix len 
counters associated 	path check working 
specific prof 	copy pos 
tctx 	dirpath path pos 
objects threads 	path path 
may write 	status msg path 
prof tctx 	pathlen pathlen 
contents freeing 	sha mode path 
associated objects 	update cache 
sampling 	update buf size 
state state 	strbuf lnk 
used avoid 	clean sha mode 
dumping operating 	path sha 
prof internals 	mode result buf 
early dump 	one branch 
phase 	branch orig 
tdata currently 	src src opts 
dumped threads 	name name 
tdata initialized 	name merge status 
aren accidentally 	one branch 
included later 	branch result result 
dump 	buf merge 
phases profiling 	status one branch 
active tdata 	filename branch 
prof active 	filename side side 
mallctl temporary 	mfi path 
storage summation 	sha mode sha 
dump 	mode sha 
backtrace vector 	mode branch branch 
used calls 	one path 
prof backtrace 	sha mode sha 
jemalloc structs 	mode sha 
mean bytes 	mode change 
samples 	change past renamed 
prof interval 	pair rename 
high water 	branch branch orig 
memory dumping 	dest sha 
profile dumping 	sha mode mode 
dump leak 	target entry 
summary 	stage sha mode 
exit report 	rename stage 
cumulative bytes 	dst name dst 
minimize memory 	entry cur 
bloat non 	branch branch name 
prof builds 	one mfi 
accessed 	path mfi mfi 
via prof 	path path 
active unlocked 	renames renames dst 
accessed via 	dst sre 
prof gdump 	renames renames dst 
unlocked profile 	ren branch 
dump 	branch ren 
interval measured 	src ren dst 
bytes allocated 	lookup compare 
arena triggers 	tmp ren src 
profile dump 	ren dst 
reaches threshold 	ren dst src 
effect 	dst merge 
interval profile 	renamed stage stage 
dumps averages 	mfi path 
prof interval 	one sha mode 
though actual 	sha dst 
interval dumps 	buf size sha 
tend 	mode sha 
sporadic interval 	mode renormalize path 
maximum approximately 	ret path 
prof interval 	sha mode sha 
narenas initialized 	mode sha 
opt prof 	mode path sha 
sample 	mode sha 
potentially modified 	mode sha 
profiling resets 	mode rename conflict 
jemalloc externs 	info reason 
even opt 	path mfi one 
prof sampling 	conflict remains 
temporarily 	pair path renamed 
disabled setting 	outside head 
prof active 	path file stage 
locking used 	merged path 
reading prof 	entry clean merge 
active fast 	normalize mode 
path 	mode mode sha 
guarantees regarding 	sha sha 
take threads 	conflict info branch 
notice state 	branch mode 
changes locking 	sha conf path 
used reading 	head merge 
prof 	common result code 
gdump val 	clean entries 
fast path 	head merge 
guarantees regarding 	path list current 
take threads 	backup result 
notice state 	iter merged common 
changes 	ancestors mrtree 
compute sample 	clean cnt saved 
threshold sample 	saved sha 
usize passed 	name head merge 
prof alloc 	num list 
prep larger 	list result clean 
actually 	head commit 
got allocated 	next commit arg 
backtrace captured 	shift shift 
allocation even 	oidcmp lookup alloc 
though actual 	commit node 
usize insufficient 	xmalloc hashcmp fputs 
cross 	strbuf reset 
sample threshold 	show strbuf addchars 
jemalloc inlines 	start strbuf 
prof accumc 	vaddf end 
malloc conf 	strbuf addch flush 
propagate err 	output flush 
filename 	output fputs merge 
thd ind 	remote find 
iteration varg 	unique abbrev parse 
thd ind 	commit commit 
count prev 	buffer find commit 
count prev 	subject unuse 
active 	commit buffer make 
thds thd 	cache entry 
args open 	error cache entry 
btalloc alloc 	parse init 
permuted backtrace 	desc memset setup 
dallocx mallctl 	unpack trees 
prof 	porcelain init desc 
count test 	init desc 
skip mallctl 	init desc 
thd create 	unpack trees cache 
thd test 	free unmerged 
prof activec 	cache stage stage 
malloc 	namelen die 
conf name 	cache cache fully 
expected func 	valid cache 
line old 	update die lookup 
name old 	strbuf addstr 
expected val 	isdir list insert 
func 	list insert 
line old 	strbuf setlen isdir 
prof active 	memset read 
old expected 	recursive xcalloc entry 
func line 	entry entry 
prof active 	list insert xcalloc 
old 	stage list 
expected prof 	lookup list insert 
active func 	xcalloc stage 
line prof 	hashcpy stage 
active old 	strlen strlen name 
expected func 	compare memset 
line 	list append qsort 
prof active 	list clear 
old expected 	strlen memcmp list 
prof active 	insert isreg 
func line 	islnk list clear 
expect sample 	xcalloc diff 
func 	setup diff opt 
line expected 	diff opt 
backtraces mallctl 	clr diff setup 
mallctl mallctl 	done diff 
mallctl mallctl 	sha diffcore std 
mallctl prof 	diff free 
count 	filepair xmalloc list 
mallocx ptr 	lookup insert 
prof count 	stage data list 
dallocx test 	lookup insert 
skip mallctl 	stage data 
prof active 	list insert diff 
mallctl 	flush file 
prof active 	cache cacheinfo cacheinfo 
mallctl prof 	cacheinfo hashcpy 
active mallctl 	hashcpy hashcpy file 
prof active 	cache cache 
prof sampling 	file exists strlen 
probe 	stage path 
mallctl prof 	strbuf addstr strbuf 
active mallctl 	addf flattened 
prof active 	path list list 
prof sampling 	file exists 
probe mallctl 	strbuf setlen strbuf 
prof 	addf list 
active mallctl 	insert strbuf detach 
prof active 	strbuf addstr 
prof sampling 	strbuf addch cache 
probe mallctl 	name pos 
prof active 	strncmp strbuf 
mallctl 	release strbuf release 
prof active 	lstat isdir 
prof sampling 	cache name pos 
probe mallctl 	strlen strcmp 
prof active 	stage tracked file 
mallctl prof 	exists strlen 
active 	strlen strncmp output 
test prof 	unlink unsorted 
active prof 	list item safe 
active prof 	create leading 
active prof 	directories error die 
active prof 	would lose 
active 	untracked error unlink 
prof active 	error isgitlink 
prof active 	read sha file 
prof active 	die sha 
restore settings 	hex die 
prof gdumpc 	sha hex isreg 
malloc 	convert working 
conf prof 	free strbuf detach 
dump open 	make room 
propagate err 	path free isreg 
filename active 	islnk open 
gdump 	die errno write 
gdump old 	full close 
open test 	islnk xmemdupz safe 
skip mallctl 	create leading 
mallocx ptr 	directories unlink symlink 
mallocx ptr 	die errno 
mallctl 	free die sha 
mallocx ptr 	hex free 
mallctl mallocx 	cacheinfo update file 
ptr dallocx 	flags strcmp 
dallocx dallocx 	strcmp mkpathdup mkpathdup 
dallocx test 	mkpathdup mkpathdup 
prof 	mkpathdup mkpathdup 
idumpc malloc 	read mmblob read 
conf prof 	mmblob read 
dump open 	mmblob merge free 
propagate err 	free free 
filename active 	free free free 
open 	isreg hashcpy 
test skip 	hashcpy sha sha 
mallctl mallocx 	sha sha 
ptr dallocx 	hashcpy sha hashcpy 
test prof 	isreg merge 
resetc malloc 	way die write 
conf 	sha file 
propagate err 	die free isgitlink 
filename active 	merge submodule 
prof sample 	islnk hashcpy sha 
prof sample 	die xstrfmt 
prof sample 	xstrfmt merge file 
orig 	free free 
prof sample 	hashcpy hashcpy 
prof sample 	hashcpy merge file 
next prof 	dir way 
dump header 	unique path file 
intercepted cnt 	cache update 
copy 	file output update 
propagate err 	file output 
cnt prof 	update file output 
dump header 	output update 
orig varg 	file free handle 
thd ind 	change file 
objs 	cache update stages 
prof sample 	sha hashcpy 
orig thds 	filespec entry unique 
thd args 	path update 
count tdata 	file file unique 
count prof 	path dir 
sample 	way unique path 
orig ptrs 	output update 
nsz open 	file update 
mallctl mallctl 	stages update stages 
mallctl prof 	free output 
sample test 	merge file one 
skip 	update file 
mallctl prof 	filespec entry update 
sample mallctl 	file file 
prof sample 	cache filespec entry 
prof reset 	update file 
prof sample 	file cache handle 
prof 	file handle 
sample memcpy 	file output file 
test skip 	would lose 
prof active 	untracked file would 
prof count 	lose untracked 
mallocx ptr 	merge file special 
prof 	markers merge 
count mallctl 	file special 
mallctl mallctl 	markers file update 
prof count 	file update 
dallocx prof 	file unique path 
count prof 	unique path 
active 	output file update 
memset mallctl 	file update 
mallctl dallocx 	file free free 
btalloc ptr 	list insert 
dallocx test 	list insert strcmp 
skip prof 	strcmp die 
count 	strcmp file update 
prof tdata 	entry setup 
count prof 	rename conflict info 
sample prof 	list lookup 
reset prof 	strcmp die setup 
active thd 	rename conflict 
create 	info file tracked 
thd prof 	hashcpy hashcpy 
count prof 	sha setup 
tdata count 	rename conflict info 
prof active 	sha update 
prof reset 	file flags sha 
test 	output merge 
skip prof 	file one output 
sample prof 	update file 
active prof 	unique path output 
reset prof 	update file 
reset mallocx 	free update entry 
ptr 	setup rename 
prof reset 	conflict info list 
sallocx xallocx 	clear list 
nallocx xallocx 	clear sha read 
dallocx prof 	sha file 
active prof 	error sha hex 
reset 	free error 
test test 	sha hex strbuf 
simple resets 	attach sha 
test resets 	read sha 
prof sample 	strbuf read sha 
changes make 	strbuf renormalize 
sure 	buffer renormalize buffer 
test code 	memcmp strbuf 
restored prof 	release strbuf release 
sample clean 	handle change 
remaining objects 	hashcpy hashcpy hashcpy 
test sampling 	dir way 
allocation 	merge file special 
site across 	markers sha 
resets reset 	output strcmp cacheinfo 
profiling reset 	output isgitlink 
profiling allocate 	output update stages 
small promoted 	file cache 
reset 	update stages tracked 
profiling perform 	hashcpy update 
successful xallocx 	stages unique path 
perform unsuccessful 	output update 
xallocx dallocx 	file free 
intercept dumping 	update file stage 
prior 	sha stage 
running tests 	sha stage sha 
prof namec 	merge content 
malloc conf 	conflict rename conflict 
name expected 	rename rename 
func line 	conflict rename rename 
name 	blob unchanged 
old name 	blob unchanged output 
func line 	file handle 
name name 	modify dir way 
old varg 	unique path 
thd ind 	output file cache 
name 	update file 
thds thd 	file cache free 
args mallctl 	output update 
str mallctl 	file flags merge 
mallctl name 	content file 
impl test 	die shift 
skip 	shift sha output 
mallctl name 	git merge 
mallctl name 	trees show die 
mallctl mallctl 	oid hex 
mallctl mallctl 	oid hex exit 
name malloc 	unmerged cache 
snprintf 	list clear list 
mallctl name 	clear files 
mallctl name 	dirs files dirs 
mallctl mallctl 	unmerged record 
name mallctl 	conflict files renames 
name mallctl 	renames process 
name 	renames process entry 
test skip 	die list 
thd create 	clear list clear 
thd test 	list clear 
input shouldn 	free free 
allowed shouldn 	free write memory 
allowed 	show output 
simultaneous read 	output commit title 
write shouldn 	output commit 
allowed pubsub.c 	title merge bases 
pat channel 	reverse commit 
clients retval 	list show commit 
channel 	list count 
notify clients 	output output commit 
retval pattern 	title pop 
retval pat 	commit lookup make 
pattern notify 	commit discard 
pat retval 	cache merge recursive 
notify 	die discard 
count channel 	cache read cache 
notify count 	merge trees 
pattern channel 	make commit commit 
message receivers 	list insert 
list pat 	commit list 
receivers 	insert flush output 
pat mblen 	show diff 
replylen cobj 	warn rename limit 
channel decr 	deref tag 
count zfree 	parse strlen make 
equal objects 	commit parse 
dict 	commit xcalloc sha 
size list 	hex error 
length dict 	sha hex commit 
incr count 	list insert 
dict find 	hold locked index 
list create 	merge recursive 
dict 	write locked index 
incr count 	error git 
dict val 	config git config 
list node 	git config 
tail reply 	git config memset 
reply reply 	merge recursive 
bulk 	config getenv 
reply client 	strtol getenv strbuf 
subscriptions count 	init list 
incr count 	init list init 
dict dict 	list init 
find server 	strcmp strcmp strcmp 
info 	skip prefix 
dict val 	strcmp diff alg 
list search 	strcmp diff 
key server 	alg skip prefix 
info list 	parse algorithm 
del node 	diff xdl clr 
list 	strcmp strcmp 
length dict 	strcmp strcmp strcmp 
reply reply 	strcmp strcmp 
reply bulk 	skip prefix skip 
reply dict 	prefix parse 
size list 	rename score recursive 
length 	merge algorithm 
decr count 	stolen git 
list search 	merge recursive fredrik 
key list 	kuivinen thieves 
node tail 	alex riesen johannes 
incr count 	schindelin june 
zmalloc 	july since use 
decoded list 	entry put 
node tail 	read pool cannot 
reply reply 	rely since 
reply bulk 	want write index 
reply client 	eventually cannot 
subscriptions 	reuse index temporary 
count incr 	data rename 
count list 	could modifications side 
search key 	history file 
list del 	renamed returns index 
node list 	entry instance 
search 	doesn correspond 
key list 	real cache entry 
del node 	git index 
reply reply 	create dictionary mapping 
reply bulk 	file names 
reply dict 	stage data objects 
size 	dictionary contains 
list length 	one entry every 
decr count 	path non 
dict safe 	zero stage entry 
iterator dict 	care entries 
next dict 	conflicts adjacent particular 
key 	file conflict 
pubsub unsubscribe 	appearing files corresponding 
channel reply 	directory order 
reply reply 	rest list irrelevant 
reply dict 	achieve sort 
size list 	name compare provide 
length 	mode ifdir 
dict release 	conflicts sort 
iterator list 	correctly use mode 
rewind list 	ifdir everything 
next pubsub 	simplicity since cases 
unsubscribe pattern 	changes order 
reply 	due sorting cause 
reply reply 	problems foo 
reply dict 	foo bar compare 
size list 	equal make 
length dict 	sure foo comes 
find dict 	foo bar 
val 	conflict file conflict 
list rewind 	currently exist 
list next 	working want allow 
reply reply 	removed make 
reply bulk 	room corresponding directory 
reply bulk 	needed files 
list 	underneath directories conflicts 
length list 	processed corresponding 
rewind decoded 	file involved 
list next 	conflict directory ends 
stringmatchlen sdslen 	removed merge 
sdslen reply 	won touch file 
reply 	directory needs 
reply bulk 	written working copy 
reply bulk 	file simply 
reply bulk 	removed make room 
decr count 	path make 
pubsub subscribe 	room necessary paths 
channel 	note directory 
pubsub unsubscribe 	file need present 
channels pubsub 	file reinstated 
unsubscribe channel 	unique name time 
client subscriptions 	processed merging 
count pubsub 	merge bases want 
subscribe 	bother working 
pattern pubsub 	directory changes ensure 
unsubscribe patterns 	conflicts adjacent 
pubsub unsubscribe 	entries list 
pattern client 	check last file 
subscriptions count 	path correspond 
pubsub 	conflict whether path 
publish message 	last file 
cluster propagate 	something record okay 
publish force 	last file 
command propagation 	make room path 
reply strcasecmp 	friends needed 
dict 	determine whether path 
iterator deferred 	could exist 
multi bulk 	file working directory 
length dict 	possible conflict 
next dict 	occur exists stage 
key stringmatchlen 	file information 
sdslen 	renames occurred need 
sdslen reply 	three trees 
bulk dict 	merge able 
release iterator 	associate correct cache 
deferred multi 	entries rename 
bulk length 	information always equal 
strcasecmp 	either note 
reply multi 	usually bad idea 
bulk len 	call update 
dict fetch 	stages path calling 
reply bulk 	update file 
reply list 	path since sometimes 
length 	lead spurious 
strcasecmp reply 	refusing lose untracked 
list length 	file messages 
reply error 	update file via 
format copyright 	make room 
salvatore sanfilippo 	path via would 
antirez 	lose untracked 
gmail dot 	instead reverse order 
rights reserved 	calls executing 
redistribution use 	update file 
source binary 	first update stages 
forms without 	strbuf converting 
modification 	stage definitely tracked 
permitted provided 	stage tracked 
following conditions 	merge started cases 
met redistributions 	path tracked 
source code 	unlink conflict files 
must retain 	way make 
copyright 	sure leading directories 
notice list 	created something 
conditions following 	exists unlink file 
disclaimer redistributions 	work tracking 
binary form 	successful unlink good 
must reproduce 	existing file 
copyright 	error really cares 
notice list 	may later 
conditions following 	decide recursively descend 
disclaimer documentation 	submodule directory 
materials provided 	update index 
distribution neither 	work low level 
name 	file merging 
redis names 	update removal merge 
contributors may 	modes cannot 
used endorse 	arbitrarily accept either 
promote products 	sha sha 
derived software 	correct since middle 
without 	point simply 
specific prior 	reuse version merge 
written permission 	need call 
software provided 	update file path 
copyright holders 	renamed since 
contributors express 	would needlessly touch 
implied 	path could 
warranties including 	call update file 
limited implied 	flags update 
warranties merchantability 	cache update one 
fitness particular 	file renamed 
purpose disclaimed 	branches different 
shall 	names fixme rename 
copyright owner 	source conflicts 
contributors liable 	could detect wrong 
direct indirect 	instead find 
incidental special 	unique pathname either 
exemplary consequential 	rename source 
damages 	file unique path 
including limited 	use unique 
procurement substitute 	path instead src 
goods services 	put merged 
loss use 	content merge path 
data profits 	usually need 
business 	path path however 
interruption however 	rename side 
caused theory 	merge could also 
liability whether 	involved rename 
contract strict 	conflict cases keep 
liability tort 	added file 
including 	around resolving 
negligence otherwise 	conflict path favor 
arising way 	two files 
use software 	renamed thing path 
even advised 	mfi clean 
possibility damage 	mfi clean might 
pubsub 	make sense 
low level 	two way merge 
api number 	results think 
channels patterns 	cases makes sense 
client subscribed 	merge undo 
subscribe client 	renames detected later 
channel 	non recursive 
returns operation 	merge todo refactor 
succeeded client 	needed bug 
already subscribed 	mark src entry 
channel channel 	processed dealing 
client channels 	rename source 
hash 	one file renamed 
table client 	sides bug 
channel list 	ren src stage 
clients hash 	think rename 
table notify 	source cases two 
client unsubscribe 	different files 
client 	renamed thing bug 
channel returns 	mark src 
operation succeeded 	entry processed dealing 
client subscribed 	rename source 
specified channel 	renamed maybe changed 
channel client 	use sha 
channels 	mode unpack trees 
hash table 	loads entries 
channel may 	common commit stage 
pointer hash 	head commit 
tables protect 	stage merge commit 
client channel 	stage keep 
clients 	track side 
list hash 	corresponds rename bug 
table free 	ren src 
list associated 	stage stage think 
hash entry 	rename source 
latest client 	added file side 
possible 	identical file 
abuse redis 	renamed clean merge 
pubsub creating 	also need 
millions channels 	overwrite file already 
notify client 	working copy 
safe release 	call update file 
subscribe 	flags instead 
client pattern 	update file update 
returns operation 	cache update 
succeeded client 	changed safety note 
already subscribed 	binary used 
pattern 	renormalizations performed comparison 
notify client 	skipped files 
unsubscribe client 	unchanged since 
channel returns 	sha already compared 
operation succeeded 	rename conflict 
client subscribed 	info pair rename 
specified 	one file 
channel protect 	one otherwise normal 
may notify 	rename content 
client unsubscribe 	merge resulted file 
channels number 	contents already 
channels client 	early file contents 
subscribed 	recorded correct 
subscribed nothing 	path may merge 
still reply 	involves rename 
client unsubscribe 	per entry merge 
patterns number 	function deleted 
patterns client 	one deleted deleted 
subscribed 	one unchanged 
subscribed nothing 	touch working file 
still reply 	exist modify 
client publish 	deleted side 
message send 	may put directory 
clients listening 	way added 
channel 	one nothing directory 
send clients 	nothing directory 
listening matching 	file overwrite file 
channels pubsub 	already present 
commands implementation 	added check permissions 
pubsub command 	modified differently 
pub 	entry deleted altogether 
sub introspection 	mode means 
pubsub channels 	path want actively 
pattern pubsub 	merge commits 
numsub channel 	resulting commit flag 
channel pubsub 	indicating cleanness 
numpat 	merge common ancestor 
ql.c head 	use empty 
head entries 	merge fails 
nentries head 	result contains files 
entries nentries 	conflict markers 
head entries 	cleanness flag ignored 
head 	never actually 
entries head 	used result merge 
entries head 	trees always 
entries head 	overwritten committed conflicts 
entries ptr 	already resolved 
first ptr 	clear previous settings 
last 	head remote 
test empty 	die error code 
list elm 	builtin merge 
first last 	recursive usage branch 
next ptr 	githead env 
next ptr 	name argc argv 
prev 	prefix bases 
prev init 	bases count failed 
entries tail 	result arg 
insert test 	sha strlen 
entries list 	xsnprintf getenv init 
init entries 	merge options 
tail 	ends usagef starts 
insert test 	parse merge 
entries list 	opt die size 
tail test 	xmalloc sha 
empty list 	die warning size 
init entries 	die sha 
head 	die sha die 
insert test 	better branch 
entries list 	name better branch 
init entries 	name merge 
head insert 	recursive recursive merge 
test entries 	algorithm stolen 
list 	git merge recursive 
head test 	fredrik kuivinen 
empty list 	thieves alex riesen 
init entries 	johannes schindelin 
tail insert 	june july 
insert insert 	since use entry 
insert 	put read 
insert insert 	pool cannot rely 
insert insert 	since want 
test entries 	write index eventually 
list test 	cannot reuse 
number ring 	index temporary data 
entries 	rename could 
insert insert 	modifications side history 
used internally 	file renamed 
macros already 	returns index entry 
tested need 	instance doesn 
test completely 	correspond real cache 
however 	entry git 
insertion deletion 	index create dictionary 
middle lists 	mapping file 
otherwise tested 	names stage data 
ql.h list 	objects dictionary 
definitions list 	contains one 
functions 	entry every path 
qr.c entries 	non zero 
entries entries 	stage entry care 
entries entries 	entries conflicts 
entries entries 	adjacent particular file 
entries entries 	conflict appearing 
next 	files corresponding directory 
ptr prev 	order rest 
ptr init 	list irrelevant achieve 
entries test 	sort name 
independent entries 	compare provide mode 
next prev 	ifdir conflicts 
init 	sort correctly use 
entries insert 	mode ifdir 
test entries 	everything simplicity since 
ring init 	cases changes 
entries insert 	order due 
test independent 	sorting cause problems 
entries 	foo foo 
init entries 	bar compare equal 
insert next 	make sure 
prev init 	foo comes foo 
entries insert 	bar conflict 
split test 	file conflict currently 
split 	exist working 
entries meld 	want allow removed 
test entries 	make room 
ring meld 	corresponding directory needed 
test split 	files underneath 
entries split 	directories conflicts processed 
test 	corresponding file 
entries ring 	involved conflict directory 
split test 	ends removed 
entries ring 	merge won touch 
meld test 	file directory 
entries ring 	needs written 
test 	working copy file 
number ring 	simply removed 
entries split 	make room path 
index nentries 	make room 
qr.h ring 	necessary paths note 
definitions ring 	directory file 
functions 	need present file 
meld split 	reinstated unique 
functionally equivalent 	name time processed 
need two 	merging merge 
copies code 	bases want bother 
quarantine.c tsd 	working directory 
quarantine 	changes ensure conflicts 
tsd quarantine 	adjacent entries 
tsd quarantine 	list check last 
upper bound 	file path 
tsd maxobjs 	correspond conflict whether 
quarantine tsd 	path last 
quarantine 	file something 
tsd quarantine 	record okay last 
ret ncopy 	file make 
ncopy tsd 	room path friends 
quarantine obj 	needed determine 
tsd quarantine 	whether path could 
upper 	exist file 
bound tsd 	working directory possible 
ptr quarantine 	conflict occur 
usize upper 	exists stage file 
bound offset 	information renames 
obj tsd 	occurred need three 
quarantine 	trees merge 
tsd nominal 	able associate correct 
iallocztm offsetof 	cache entries 
tcache tsd 	rename information always 
nominal quarantine 	equal either 
init tsd 	note usually bad 
quarantine 	idea call 
tsd quarantine 	update stages 
idalloctm tcache 	path calling update 
quarantine init 	file path 
quarantine drain 	since sometimes lead 
one memcpy 	spurious refusing 
memcpy 	lose untracked file 
memcpy idalloctm 	messages update 
tcache tsd 	file via make 
quarantine isalloc 	room path 
idalloctm quarantine 	via would lose 
drain one 	untracked instead 
isalloc 	reverse order calls 
cassert tsd 	executing update 
quarantine idalloctm 	file first update 
quarantine drain 	stages strbuf 
quarantine grow 	converting stage definitely 
unlikely likely 	tracked stage 
arena 	tracked merge started 
quarantine junk 	cases path 
small memset 	tracked unlink 
idalloctm tsd 	conflict files way 
quarantine quarantine 	make sure 
drain idalloctm 	leading directories created 
tcache 	something exists 
tsd quarantine 	unlink file work 
quarantine pointers 	tracking successful 
close used 	unlink good existing 
encode state 	file error 
information used 	really cares may 
cleaning 	later decide 
shutdown function 	recursively descend submodule 
prototypes non 	directory update 
functions check 	index work low 
whether quarantine 	level file 
initialized quarantine 	merging update removal 
init 	merge modes 
may triggered 	cannot arbitrarily 
recursive initialization 	accept either sha 
objs ring 	sha correct 
buffer data 	since middle point 
contiguous objs 	simply reuse 
ring 	version merge need 
buffer data 	call update 
wrap around 	file path renamed 
drain one 	since would 
objects quarantine 	needlessly touch path 
size limit 	could call 
would 	update file flags 
exceeded appending 	update cache 
ptr grow 	update one file 
quarantine ring 	renamed branches 
buffer full 	different names fixme 
quarantine grow 	rename source 
must 	conflicts could detect 
free slot 	wrong instead 
fails grow 	find unique 
append ptr 	pathname either rename 
size doesn 	source file 
exceed quarantine 	unique path use 
size 	unique path 
redzone validation 	instead src put 
valgrind isn 	merged content 
operation allocate 	merge path usually 
enough regions 	need path 
completely fill 	path however rename 
quarantine 	side merge 
plus one 	could also involved 
last iteration 	rename conflict 
occurs completely 	cases keep added 
full quarantine 	file around 
regions drained 	resolving conflict path 
quarantine 	favor two 
last deallocation 	files renamed thing 
occurs therefore 	path mfi 
region recycling 	clean mfi 
occur loop 	clean might make 
completes test 	sense two 
underflow 	way merge results 
test overflow 	think cases 
malloc conf 	makes sense merge 
quarantined detected 	undo renames 
redzone corruption 	detected later non 
ptr usize 	recursive merge 
offset 	todo refactor needed 
arena redzone 	bug mark 
corruption orig 	src entry processed 
stringify mallocx 	dealing rename 
ptr dallocx 	source one file 
test skip 	renamed sides 
nallocx 	bug ren src 
quarantine clear 	stage think 
mallocx ptr 	rename source cases 
dallocx ptr 	two different 
test skip 	files renamed 
mallocx ptr 	thing bug mark 
dallocx 	src entry 
mallocx ptr 	processed dealing rename 
sallocx dallocx 	source renamed 
test quarantine 	maybe changed use 
pointers close 	sha mode 
used encode 	unpack trees loads 
state 	entries common 
information used 	commit stage head 
cleaning shutdown 	commit stage 
function prototypes 	merge commit stage 
non functions 	keep track 
check whether 	side corresponds rename 
quarantine 	bug ren 
initialized quarantine 	src stage stage 
init may 	think rename 
triggered recursive 	source added 
initialization objs 	file side identical 
ring buffer 	file renamed 
data 	clean merge also 
contiguous objs 	need overwrite 
ring buffer 	file already working 
data wrap 	copy call 
around drain 	update file flags 
one objects 	instead update 
quarantine 	file update cache 
size limit 	update changed 
would exceeded 	safety note binary 
appending ptr 	used renormalizations 
grow quarantine 	performed comparison skipped 
ring buffer 	files unchanged 
full 	since sha already 
quarantine grow 	compared rename 
must free 	conflict info pair 
slot fails 	rename one 
grow append 	file one 
ptr size 	otherwise normal rename 
doesn 	content merge 
exceed quarantine 	resulted file contents 
size redzone 	already early 
validation valgrind 	file contents recorded 
isn operation 	correct path 
allocate enough 	may merge involves 
regions 	rename per 
completely fill 	entry merge function 
quarantine plus 	deleted one 
one last 	deleted deleted one 
iteration occurs 	unchanged touch 
completely full 	working file exist 
quarantine 	modify deleted 
regions drained 	side may put 
quarantine last 	directory way 
deallocation occurs 	added one nothing 
therefore region 	directory nothing 
recycling occur 	directory file 
loop 	overwrite file already 
completes test 	present added 
underflow test 	check permissions modified 
overflow quarantine.c 	differently entry 
tsd quarantine 	deleted altogether mode 
tsd quarantine 	means path 
tsd 	want actively merge 
quarantine upper 	commits resulting 
bound tsd 	commit flag indicating 
maxobjs quarantine 	cleanness merge 
tsd quarantine 	common ancestor use 
tsd quarantine 	empty merge 
ret 	fails result contains 
ncopy ncopy 	files conflict 
tsd quarantine 	markers cleanness flag 
obj tsd 	ignored never 
quarantine upper 	actually used result 
bound tsd 	merge trees 
ptr 	always overwritten 
quarantine usize 	committed conflicts already 
upper bound 	resolved clear 
offset obj 	previous settings head 
tsd quarantine 	remote die 
tsd nominal 	error code merge-recursive.c 
iallocztm 	one two 
offsetof tcache 	subtree shift shifted 
tsd nominal 	comment commit 
quarantine init 	desc pair pair 
tsd quarantine 	branch branch 
tsd quarantine 	dst entry dst 
idalloctm 	entry ren 
tcache quarantine 	ren mode sha 
init quarantine 	rename conflict 
drain one 	info setup rename 
memcpy memcpy 	conflict info 
memcpy idalloctm 	fmt commit 
tcache 	title msg len 
tsd quarantine 	mode sha 
isalloc idalloctm 	path stage refresh 
quarantine drain 	options desc 
one isalloc 	index common head 
cassert tsd 	merge opts 
quarantine 	result sha path 
idalloctm quarantine 	mode stage 
drain quarantine 	context baselen match 
grow unlikely 	path entries 
likely arena 	item unmerged item 
quarantine junk 	one two 
small 	onelen twolen cmp 
memset idalloctm 	entries sorted 
tsd quarantine 	entries last file 
quarantine drain 	last len 
idalloctm tcache 	next path len 
tsd quarantine 	pair src 
quarantine 	entry dst 
pointers close 	entry entries renames 
used encode 	opts item 
state information 	pair path clear 
used cleaning 	options entry 
shutdown function 	clean path update 
prototypes 	cache update 
non functions 	working directory path 
check whether 	branch newpath 
quarantine initialized 	suffix len path 
quarantine init 	check working 
may triggered 	copy pos dirpath 
recursive 	path pos 
initialization objs 	path path status 
ring buffer 	msg path 
data contiguous 	pathlen pathlen sha 
objs ring 	mode path 
buffer data 	update cache update 
wrap 	buf size 
around drain 	strbuf lnk 
one objects 	clean sha mode 
quarantine size 	path sha 
limit would 	mode result buf 
exceeded appending 	one branch 
ptr 	branch orig src 
grow quarantine 	src opts 
ring buffer 	name name name 
full quarantine 	merge status 
grow must 	one branch branch 
free slot 	result result 
fails 	buf merge status 
grow append 	one branch 
ptr size 	filename branch filename 
doesn exceed 	side side 
quarantine size 	mfi path sha 
redzone validation 	mode sha 
valgrind 	mode sha mode 
isn operation 	branch branch 
allocate enough 	one path 
regions completely 	sha mode sha 
fill quarantine 	mode sha 
plus one 	mode change change 
last 	past renamed 
iteration occurs 	pair rename branch 
completely full 	branch orig 
quarantine regions 	dest sha sha 
drained quarantine 	mode mode 
last deallocation 	target entry stage 
occurs 	sha mode 
therefore region 	rename stage dst 
recycling occur 	name dst 
loop completes 	entry cur branch 
test underflow 	branch name 
test overflow 	one mfi path 
malloc 	mfi mfi 
conf quarantined 	path path renames 
detected redzone 	renames dst 
corruption ptr 	dst sre 
usize offset 	renames renames dst 
arena redzone 	ren branch 
corruption 	branch ren src 
orig stringify 	ren dst 
mallocx ptr 	lookup compare tmp 
dallocx test 	ren src 
skip nallocx 	ren dst ren 
quarantine 	dst src 
clear mallocx 	dst merge renamed 
ptr dallocx 	stage stage 
ptr test 	mfi path one 
skip mallocx 	sha mode 
ptr dallocx 	sha dst buf 
mallocx 	size sha 
ptr sallocx 	mode sha mode 
dallocx test 	renormalize path 
quarantine pointers 	ret path 
close used 	sha mode sha 
encode state 	mode sha 
information 	mode path sha 
used cleaning 	mode sha 
shutdown function 	mode sha mode 
prototypes non 	rename conflict 
functions check 	info reason path 
whether quarantine 	mfi one 
initialized 	conflict remains pair 
quarantine init 	path renamed 
may triggered 	outside head path 
recursive initialization 	file stage 
objs ring 	merged path entry 
buffer data 	clean merge 
contiguous 	normalize mode mode 
objs ring 	mode sha 
buffer data 	sha sha conflict 
wrap around 	info branch 
drain one 	branch mode 
objects quarantine 	sha conf path 
size 	head merge 
limit would 	common result code 
exceeded appending 	clean entries 
ptr grow 	head merge path 
quarantine ring 	list current 
buffer full 	backup result iter 
quarantine 	merged common 
grow must 	ancestors mrtree clean 
free slot 	cnt saved 
fails grow 	saved sha name 
append ptr 	head merge 
size doesn 	num list list 
exceed 	result clean 
quarantine size 	head commit next 
redzone validation 	commit arg 
valgrind isn 	shift shift oidcmp 
operation allocate 	lookup alloc 
enough regions 	commit node 
completely 	xmalloc hashcmp fputs 
fill quarantine 	strbuf reset 
plus one 	show strbuf addchars 
last iteration 	start strbuf 
occurs completely 	vaddf end strbuf 
full quarantine 	addch flush 
regions 	output flush output 
drained quarantine 	fputs merge 
last deallocation 	remote find unique 
occurs therefore 	abbrev parse 
region recycling 	commit commit buffer 
occur loop 	find commit 
completes 	subject unuse commit 
test underflow 	buffer make 
test overflow 	cache entry error 
quarantine.h ptr 	cache entry 
usize curbytes 	parse init desc 
curobjs first 	memset setup 
maxobjs 	unpack trees 
objs tsd 	porcelain init desc 
tsd ptr 	init desc 
tsd tsd 	init desc unpack 
tsd fetch 	trees cache 
tsd quarantine 	free unmerged cache 
quarantine 	stage stage 
alloc hook 	namelen die cache 
work per 	cache fully 
quarantine size 	valid cache update 
valgrind enabled 	die lookup 
jemalloc types 	strbuf addstr isdir 
dynamically 	list insert 
sized ring 	list insert strbuf 
buffer jemalloc 	setlen isdir 
structs jemalloc 	memset read recursive 
externs jemalloc 	xcalloc entry 
inlines quicklist.c 	entry entry 
optimization 	list insert xcalloc 
level quicklist 	stage list 
quicklist compress 	lookup list insert 
quicklist fill 	xcalloc stage 
quicklist fill 	hashcpy stage strlen 
depth fill 	strlen name 
compress 	compare memset list 
quicklist node 	append qsort 
quicklist len 	list clear strlen 
current next 	memcmp list 
node lzf 	insert isreg islnk 
node decompressed 	list clear 
lzf 	xcalloc diff setup 
node data 	diff opt 
lzf quicklist 	diff opt clr 
node forward 	diff setup 
reverse depth 	done diff sha 
depth quicklist 	diffcore std 
old 	diff free 
node node 	filepair xmalloc list 
quicklist old 	lookup insert 
node node 	stage data list 
quicklist old 	lookup insert 
node node 	stage data list 
fill 	insert diff 
offset node 	flush file cache 
fill ziplist 	cacheinfo cacheinfo 
overhead fill 	cacheinfo hashcpy hashcpy 
merge quicklist 	hashcpy file 
orig head 	cache cache file 
node 	exists strlen 
quicklist orig 	stage path strbuf 
tail node 	addstr strbuf 
quicklist node 	addf flattened path 
quicklist longval 	list list 
longstr fill 	file exists strbuf 
compress 	setlen strbuf 
quicklist node 	addf list 
quicklist node 	insert strbuf detach 
gone iter 	strbuf addstr 
entry prev 	strbuf addch cache 
next deleted 	name pos 
node 	strncmp strbuf release 
quicklist index 	strbuf release 
data entry 	lstat isdir cache 
quicklist nokeep 	name pos 
quicklist center 	strlen strcmp stage 
fill prev 	tracked file 
prev 	exists strlen strlen 
prev next 	strncmp output 
next next 	unlink unsorted list 
target node 	item safe 
offset node 	create leading directories 
orig start 	error die 
orig 	would lose untracked 
extent start 	error unlink 
extent quicklist 	error isgitlink 
entry full 	read sha file 
prev fill 	die sha 
node node 	hex die sha 
next 	hex isreg 
quicklist entry 	convert working free 
quicklist entry 	strbuf detach 
quicklist start 	make room path 
count extent 	free isreg 
entry node 	islnk open die 
next 	errno write 
del entire 	full close islnk 
node len 	xmemdupz safe 
quicklist direction 	create leading directories 
iter quicklist 	unlink symlink 
direction idx 	die errno free 
entry 	die sha 
iter iter 	hex free 
entry offset 	cacheinfo update file 
update orig 	flags strcmp 
copy current 	strcmp mkpathdup mkpathdup 
node lzf 	mkpathdup mkpathdup 
lzf 	mkpathdup mkpathdup read 
quicklist idx 	mmblob read 
entry accum 	mmblob read mmblob 
index forward 	merge free 
quicklist longval 	free free free 
longstr quicklist 	free free 
data 	isreg hashcpy hashcpy 
sval saver 	sha sha 
vstr vlen 	sha sha hashcpy 
vlong pos 	sha hashcpy 
node data 	isreg merge way 
vstr quicklist 	die write 
data 	sha file die 
slong vstr 	free isgitlink 
vlen vlong 	merge submodule 
ret quicklist 	islnk hashcpy sha 
ust print 	die xstrfmt 
forward iter 	xstrfmt merge file 
entry 	free free 
prev print 	hashcpy hashcpy hashcpy 
print len 	merge file 
count head 	dir way unique 
count tail 	path file 
count errors 	cache update file 
loopr 	output update 
rloopr node 	file output update 
low raw 	file output 
high raw 	output update file 
prefix result 	free handle 
argc argv 	change file cache 
err 	update stages 
optimize start 	sha hashcpy filespec 
options option 	entry unique 
count runtime 	path update 
start populate 	file file unique 
data data 	path dir 
data 	way unique path 
ret data 	output update 
ret iter 	file update stages 
entry count 	update stages 
iter entry 	free output merge 
entry entry 	file one 
entry 	update file filespec 
entry iter 	entry update 
entry entry 	file file cache 
entry copy 	filespec entry 
copy copy 	update file file 
entry entry 	cache handle 
entry 	file handle file 
entry entry 	output file 
num nums 	would lose untracked 
entry words 	file would 
result result 	lose untracked 
iter entry 	merge file special 
del 	markers merge 
res entry 	file special markers 
iter vals 	file update 
num nums 	file update file 
entry iter 	unique path 
num nums 	unique path output 
entry 	file update 
num nums 	file update file 
entry num 	free free 
nums entry 	list insert list 
num nums 	insert strcmp 
nums num 	strcmp die strcmp 
stop 	file update 
list sizes 	entry setup rename 
start list 	conflict info 
depth node 	list lookup strcmp 
low raw 	die setup 
high raw 	rename conflict 
stop 	info file tracked 
zmalloc quicklist 	hashcpy hashcpy 
fill quicklist 	sha setup rename 
compress depth 	conflict info 
quicklist create 	sha update file 
quicklist options 	flags sha 
zmalloc 	output merge file 
zfree zfree 	one output 
zfree zmalloc 	update file unique 
lzf compress 	path output 
zfree zrealloc 	update file free 
zfree zmalloc 	update entry 
lzf 	setup rename conflict 
decompress zfree 	info list 
zfree quicklist 	clear list clear 
allows compression 	sha read 
quicklist decompress 	sha file 
node quicklist 	error sha hex 
decompress 	free error 
node quicklist 	sha hex strbuf 
compress node 	attach sha 
quicklist compress 	read sha strbuf 
node quicklist 	read sha 
compress node 	strbuf renormalize buffer 
quicklist 	renormalize buffer 
compress quicklist 	memcmp strbuf release 
insert node 	strbuf release 
quicklist insert 	handle change hashcpy 
node unlikely 	hashcpy hashcpy 
likely likely 	dir way merge 
quicklist 	file special 
node size 	markers sha output 
meets optimization 	strcmp cacheinfo 
requirement size 	output isgitlink output 
meets safety 	update stages 
limit likely 	file cache 
quicklist 	update stages tracked 
node size 	hashcpy update 
meets optimization 	stages unique path 
requirement size 	output update 
meets safety 	file free update 
limit likely 	file stage 
quicklist 	sha stage sha 
node allow 	stage sha 
insert ziplist 	merge content conflict 
push quicklist 	rename conflict 
node update 	rename rename conflict 
quicklist create 	rename rename 
node 	blob unchanged blob 
ziplist push 	unchanged output 
ziplist quicklist 	file handle modify 
node update 	dir way 
quicklist insert 	unique path output 
node likely 	file cache 
quicklist 	update file 
node allow 	file cache free 
insert ziplist 	output update 
push quicklist 	file flags merge 
node update 	content file 
quicklist create 	die shift shift 
node 	sha output 
ziplist push 	git merge trees 
ziplist quicklist 	show die 
node update 	oid hex oid 
quicklist insert 	hex exit 
node quicklist 	unmerged cache list 
create 	clear list 
node ziplist 	clear files dirs 
len ziplist 	files dirs 
blob len 	unmerged record conflict 
quicklist insert 	files renames 
node ziplist 	renames process renames 
index 	process entry 
ziplist quicklist 	die list 
push tail 	clear list clear 
ziplist next 	list clear 
zfree quicklist 	free free free 
append values 	write memory 
ziplist 	show output output 
quicklist quicklist 	commit title 
compress zfree 	output commit title 
zfree ziplist 	merge bases 
quicklist del 	reverse commit list 
node quicklist 	show commit 
node 	list count output 
update quicklist 	output commit 
del index 	title pop commit 
likely quicklist 	lookup make 
index ziplist 	commit discard cache 
ziplist insert 	merge recursive 
quicklist 	die discard 
compress quicklist 	cache read cache 
decompress node 	merge trees 
quicklist decompress 	make commit commit 
node ziplist 	list insert 
merge ziplist 	commit list insert 
len 	flush output 
quicklist node 	show diff warn 
update quicklist 	rename limit 
del node 	deref tag parse 
quicklist compress 	strlen make 
quicklist node 	commit parse commit 
allow 	xcalloc sha 
merge quicklist 	hex error sha 
ziplist merge 	hex commit 
quicklist node 	list insert hold 
allow merge 	locked index 
quicklist ziplist 	merge recursive write 
merge 	locked index 
quicklist node 	error git 
allow merge 	config git config 
quicklist ziplist 	git config 
merge quicklist 	git config memset 
node allow 	merge recursive 
merge 	config getenv strtol 
quicklist ziplist 	getenv strbuf 
merge quicklist 	init list init 
create node 	list init 
zmalloc memcpy 	list init strcmp 
ziplist range 	strcmp strcmp 
ziplist 	skip prefix strcmp 
len quicklist 	diff alg 
node update 	strcmp diff alg 
ziplist range 	skip prefix 
ziplist len 	parse algorithm diff 
quicklist node 	xdl clr 
update 	strcmp strcmp strcmp 
quicklist create 	strcmp strcmp 
node ziplist 	strcmp strcmp 
push ziplist 	skip prefix skip 
quicklist insert 	prefix parse 
node quicklist 	rename score recursive 
node 	merge algorithm 
allow insert 	stolen git merge 
quicklist node 	recursive fredrik 
allow insert 	kuivinen thieves alex 
quicklist node 	riesen johannes 
allow insert 	schindelin june july 
quicklist 	since use 
decompress node 	entry put read 
use ziplist 	pool cannot 
next ziplist 	rely since want 
push ziplist 	write index 
insert quicklist 	eventually cannot reuse 
node 	index temporary 
update quicklist 	data rename could 
recompress quicklist 	modifications side 
decompress node 	history file 
use ziplist 	renamed returns index 
insert quicklist 	entry instance 
node 	doesn correspond real 
update quicklist 	cache entry 
recompress quicklist 	git index create 
decompress node 	dictionary mapping 
use ziplist 	file names stage 
push quicklist 	data objects 
node 	dictionary contains one 
update quicklist 	entry every 
recompress quicklist 	path non zero 
decompress node 	stage entry 
use ziplist 	care entries conflicts 
push quicklist 	adjacent particular 
node 	file conflict appearing 
update quicklist 	files corresponding 
recompress quicklist 	directory order 
create node 	rest list irrelevant 
ziplist push 	achieve sort 
ziplist quicklist 	name compare provide 
node 	mode ifdir 
update quicklist 	conflicts sort correctly 
insert node 	use mode 
quicklist decompress 	ifdir everything simplicity 
node use 	since cases 
quicklist split 	changes order due 
node 	sorting cause 
ziplist push 	problems foo foo 
quicklist node 	bar compare 
update quicklist 	equal make sure 
insert node 	foo comes 
quicklist merge 	foo bar conflict 
nodes 	file conflict 
quicklist insert 	currently exist working 
quicklist insert 	want allow 
quicklist index 	removed make 
quicklist del 	room corresponding directory 
node quicklist 	needed files 
decompress 	underneath directories conflicts 
node use 	processed corresponding 
ziplist range 	file involved conflict 
quicklist node 	directory ends 
update quicklist 	removed merge won 
empty quicklist 	touch file 
recompress 	directory needs written 
ziplist compare 	working copy 
zmalloc quicklist 	file simply removed 
index quicklist 	make room 
iterator quicklist 	path make room 
compress 	necessary paths 
zfree init 	note directory file 
entry quicklist 	need present 
decompress node 	file reinstated unique 
use ziplist 	name time 
index next 	processed merging 
ziplist 	merge bases want 
quicklist compress 	bother working 
quicklist next 	directory changes ensure 
quicklist quicklist 	conflicts adjacent 
create node 	entries list check 
zmalloc memcpy 	last file 
zmalloc 	path correspond conflict 
memcpy quicklist 	whether path 
insert node 	last file something 
init entry 	record okay 
likely quicklist 	last file make 
decompress node 	room path 
use 	friends needed determine 
ziplist index 	whether path 
ziplist ziplist 	could exist file 
index ziplist 	working directory 
quicklist push 	possible conflict occur 
head ziplist 	exists stage 
index 	file information 
quicklist del 	renames occurred need 
index ziplist 	three trees 
index ziplist 	merge able associate 
saver quicklist 	correct cache 
del index 	entries rename information 
zmalloc 	always equal 
memcpy quicklist 	either note usually 
pop custom 	bad idea 
quicklist push 	call update stages 
head quicklist 	path calling 
push tail 	update file path 
ziplist 	since sometimes 
len ziplist 	lead spurious refusing 
len unused 	lose untracked 
gettimeofday ustime 	file messages update 
quicklist iterator 	file via 
quicklist next 	make room path 
quicklist 	via would 
release iterator 	lose untracked 
itrprintr itrprintr 	instead reverse order 
info yell 	calls executing 
yell itrprintr 	update file first 
yell itrprintr 	update stages 
rev 	strbuf converting stage 
yell ziplist 	definitely tracked 
len yell 	stage tracked merge 
ziplist len 	started cases 
ziplist len 	path tracked unlink 
yell ziplist 	conflict files 
len 	way make sure 
quicklist allows 	leading directories 
compression yell 	created something exists 
yell snprintf 	unlink file 
unused unused 	work tracking successful 
mstime quicklist 	unlink good 
verify 	existing file 
quicklist release 	error really cares 
quicklist quicklist 	may later 
push tail 	decide recursively descend 
verify quicklist 	submodule directory 
release quicklist 	update index work 
quicklist 	low level 
push head 	file merging update 
verify quicklist 	removal merge 
release quicklist 	modes cannot arbitrarily 
quicklist push 	accept either 
tail genstr 	sha sha correct 
verify 	since middle 
quicklist release 	point simply reuse 
quicklist quicklist 	version merge 
push head 	need call update 
genstr verify 	file path 
quicklist release 	renamed since would 
quicklist 	needlessly touch 
quicklist push 	path could 
tail genstr 	call update file 
verify quicklist 	flags update 
release quicklist 	cache update one 
quicklist push 	file renamed 
head 	branches different names 
genstr verify 	fixme rename 
quicklist release 	source conflicts could 
quicklist quicklist 	detect wrong 
rotate verify 	instead find unique 
quicklist release 	pathname either 
quicklist 	rename source file 
quicklist push 	unique path 
head quicklist 	use unique path 
rotate verify 	instead src 
quicklist release 	put merged content 
quicklist quicklist 	merge path 
push 	usually need path 
head quicklist 	path however 
push head 	rename side 
quicklist push 	merge could also 
head quicklist 	involved rename 
push head 	conflict cases keep 
quicklist 	added file 
push head 	around resolving conflict 
genstr info 	path favor 
info quicklist 	two files renamed 
rotate verify 	thing path 
verify verify 	mfi clean mfi 
quicklist 	clean might 
release quicklist 	make sense two 
quicklist pop 	way merge 
verify quicklist 	results think cases 
release quicklist 	makes sense 
genstr quicklist 	merge undo renames 
push 	detected later 
head info 	non recursive merge 
quicklist pop 	todo refactor 
strcmp err 	needed bug 
zfree verify 	mark src entry 
quicklist release 	processed dealing 
quicklist 	rename source one 
quicklist push 	file renamed 
head info 	sides bug ren 
quicklist pop 	src stage 
verify quicklist 	think rename source 
release quicklist 	cases two 
quicklist 	different files renamed 
push head 	thing bug 
genstr info 	mark src entry 
quicklist pop 	processed dealing 
strcmp genstr 	rename source renamed 
err genstr 	maybe changed 
zfree 	use sha mode 
verify quicklist 	unpack trees 
release quicklist 	loads entries 
quicklist push 	common commit stage 
head genstr 	head commit 
quicklist pop 	stage merge commit 
strcmp 	stage keep 
genstr err 	track side corresponds 
genstr zfree 	rename bug 
verify quicklist 	ren src stage 
release quicklist 	stage think 
quicklist fill 	rename source added 
quicklist 	file side 
push head 	identical file renamed 
genstr quicklist 	clean merge 
iterator quicklist 	also need overwrite 
next genstr 	file already 
strcmp err 	working copy call 
err 	update file 
verify quicklist 	flags instead update 
release iterator 	file update 
quicklist release 	cache update 
quicklist quicklist 	changed safety note 
fill quicklist 	binary used 
push 	renormalizations performed comparison 
head genstr 	skipped files 
quicklist iterator 	unchanged since sha 
quicklist next 	already compared 
genstr strcmp 	rename conflict info 
err err 	pair rename 
verify 	one file one 
quicklist release 	otherwise normal 
iterator quicklist 	rename content merge 
release quicklist 	resulted file 
quicklist index 	contents already early 
quicklist insert 	file contents 
verify 	recorded correct path 
quicklist release 	may merge 
quicklist quicklist 	involves rename per 
index quicklist 	entry merge 
insert verify 	function deleted 
quicklist release 	one deleted deleted 
quicklist 	one unchanged 
quicklist push 	touch working file 
head quicklist 	exist modify 
index quicklist 	deleted side may 
insert verify 	put directory 
quicklist release 	way added one 
quicklist 	nothing directory 
quicklist push 	nothing directory file 
head quicklist 	overwrite file 
index quicklist 	already present added 
insert verify 	check permissions 
quicklist release 	modified differently entry 
quicklist 	deleted altogether 
quicklist push 	mode means path 
tail quicklist 	want actively 
fill quicklist 	merge commits resulting 
push tail 	commit flag 
quicklist fill 	indicating cleanness 
quicklist 	merge common ancestor 
push tail 	use empty 
quicklist push 	merge fails result 
tail quicklist 	contains files 
push tail 	conflict markers cleanness 
itrprintr quicklist 	flag ignored 
iterator 	never actually used 
quicklist next 	result merge 
strncmp quicklist 	trees always overwritten 
insert itrprintr 	committed conflicts 
quicklist index 	already resolved clear 
strncmp err 	previous settings 
quicklist 	head remote die 
index strncmp 	error code 
err quicklist 	builtin merge recursive 
index strncmp 	usage branch 
err quicklist 	githead env 
index strncmp 	name argc argv 
err 	prefix bases 
quicklist index 	bases count failed 
strncmp err 	result arg 
quicklist index 	sha strlen xsnprintf 
strncmp err 	getenv init 
quicklist release 	merge options ends 
iterator 	usagef starts 
quicklist release 	parse merge opt 
quicklist quicklist 	die size 
push tail 	xmalloc sha die 
genstr quicklist 	warning size 
index quicklist 	die sha die 
insert 	sha die 
genstr verify 	better branch name 
quicklist release 	better branch 
quicklist quicklist 	name merge recursive 
push head 	recursive merge 
genstr quicklist 	algorithm stolen 
index 	git merge recursive 
quicklist insert 	fredrik kuivinen 
genstr err 	thieves alex riesen 
verify quicklist 	johannes schindelin 
release quicklist 	june july since 
verify quicklist 	use entry 
dup 	put read pool 
verify quicklist 	cannot rely 
release quicklist 	since want write 
release quicklist 	index eventually 
quicklist push 	cannot reuse index 
head genstr 	temporary data 
verify 	rename could modifications 
quicklist dup 	side history 
verify quicklist 	file renamed returns 
release quicklist 	index entry 
release quicklist 	instance doesn correspond 
quicklist fill 	real cache 
quicklist 	entry git 
push head 	index create dictionary 
genstr verify 	mapping file 
quicklist dup 	names stage data 
verify quicklist 	objects dictionary 
release quicklist 	contains one entry 
release 	every path 
quicklist quicklist 	non zero stage 
push tail 	entry care 
genstr quicklist 	entries conflicts adjacent 
index strcmp 	particular file 
err quicklist 	conflict appearing files 
index 	corresponding directory 
strcmp err 	order rest list 
quicklist release 	irrelevant achieve 
quicklist quicklist 	sort name compare 
push tail 	provide mode 
genstr quicklist 	ifdir conflicts sort 
index 	correctly use 
strcmp err 	mode ifdir 
quicklist index 	everything simplicity since 
strcmp err 	cases changes 
quicklist release 	order due sorting 
quicklist quicklist 	cause problems 
push 	foo foo bar 
tail genstr 	compare equal 
quicklist index 	make sure foo 
strcmp err 	comes foo 
quicklist release 	bar conflict file 
quicklist quicklist 	conflict currently 
push 	exist working want 
tail genstr 	allow removed 
quicklist index 	make room corresponding 
err quicklist 	directory needed 
release quicklist 	files underneath directories 
quicklist del 	conflicts processed 
range 	corresponding file involved 
verify quicklist 	conflict directory 
release quicklist 	ends removed 
quicklist push 	merge won touch 
head genstr 	file directory 
verify quicklist 	needs written working 
del 	copy file 
range verify 	simply removed make 
quicklist release 	room path 
quicklist quicklist 	make room necessary 
push head 	paths note 
genstr verify 	directory file need 
quicklist 	present file 
del range 	reinstated unique name 
verify quicklist 	time processed 
release quicklist 	merging merge bases 
quicklist fill 	want bother 
quicklist push 	working directory changes 
tail 	ensure conflicts 
genstr verify 	adjacent entries 
quicklist del 	list check last 
range verify 	file path 
quicklist release 	correspond conflict whether 
quicklist quicklist 	path last 
fill 	file something record 
quicklist push 	okay last 
tail genstr 	file make room 
verify quicklist 	path friends 
del range 	needed determine whether 
verify quicklist 	path could 
release 	exist file working 
quicklist quicklist 	directory possible 
fill quicklist 	conflict occur exists 
push tail 	stage file 
genstr verify 	information renames occurred 
quicklist del 	need three 
range 	trees merge able 
verify quicklist 	associate correct 
release quicklist 	cache entries 
quicklist fill 	rename information always 
quicklist push 	equal either 
tail genstr 	note usually bad 
quicklist 	idea call 
del range 	update stages path 
verify quicklist 	calling update 
release quicklist 	file path since 
quicklist fill 	sometimes lead 
quicklist push 	spurious refusing lose 
tail 	untracked file 
genstr verify 	messages update file 
quicklist del 	via make 
range verify 	room path via 
quicklist release 	would lose 
quicklist quicklist 	untracked instead reverse 
push 	order calls 
tail quicklist 	executing update file 
push tail 	first update 
quicklist push 	stages strbuf 
tail quicklist 	converting stage definitely 
push tail 	tracked stage 
verify 	tracked merge started 
quicklist index 	cases path 
err quicklist 	tracked unlink conflict 
index err 	files way 
quicklist index 	make sure leading 
err quicklist 	directories created 
index 	something exists unlink 
err quicklist 	file work 
index err 	tracking successful unlink 
quicklist index 	good existing 
err quicklist 	file error really 
index err 	cares may 
quicklist 	later decide recursively 
index err 	descend submodule 
quicklist index 	directory update index 
err quicklist 	work low 
index err 	level file 
quicklist release 	merging update removal 
quicklist 	merge modes 
quicklist fill 	cannot arbitrarily accept 
quicklist push 	either sha 
tail quicklist 	sha correct since 
push tail 	middle point 
quicklist index 	simply reuse version 
err 	merge need 
quicklist index 	call update file 
strncmp err 	path renamed 
verify quicklist 	since would needlessly 
release quicklist 	touch path 
quicklist push 	could call update 
tail 	file flags 
quicklist push 	update cache update 
tail quicklist 	one file 
push tail 	renamed branches 
quicklist push 	different names fixme 
tail quicklist 	rename source 
push 	conflicts could detect 
tail quicklist 	wrong instead 
replace index 	find unique pathname 
quicklist replace 	either rename 
index quicklist 	source file unique 
release quicklist 	path use 
quicklist 	unique path instead 
push tail 	src put 
strlen quicklist 	merged content merge 
iterator quicklist 	path usually 
next quicklist 	need path path 
compare quicklist 	however rename 
del 	side merge could 
entry quicklist 	also involved 
release iterator 	rename conflict cases 
quicklist iterator 	keep added 
quicklist next 	file around 
strncmp err 	resolving conflict path 
quicklist 	favor two 
release iterator 	files renamed thing 
quicklist push 	path mfi 
tail quicklist 	clean mfi clean 
iterator quicklist 	might make 
next quicklist 	sense two way 
compare 	merge results 
quicklist del 	think cases makes 
entry quicklist 	sense merge 
release iterator 	undo renames detected 
quicklist iterator 	later non 
quicklist next 	recursive merge todo 
strncmp 	refactor needed 
err quicklist 	bug mark src 
release iterator 	entry processed 
quicklist release 	dealing rename source 
quicklist quicklist 	one file 
push tail 	renamed sides 
quicklist 	bug ren src 
push tail 	stage think 
quicklist push 	rename source cases 
tail quicklist 	two different 
push tail 	files renamed thing 
quicklist push 	bug mark 
tail 	src entry processed 
quicklist iterator 	dealing rename 
quicklist next 	source renamed maybe 
quicklist compare 	changed use 
quicklist del 	sha mode unpack 
entry quicklist 	trees loads 
release 	entries common commit 
iterator err 	stage head 
quicklist iterator 	commit stage merge 
quicklist next 	commit stage 
quicklist compare 	keep track side 
err quicklist 	corresponds rename 
release 	bug ren 
iterator quicklist 	src stage stage 
release quicklist 	think rename 
quicklist push 	source added file 
tail quicklist 	side identical 
iterator 	file renamed clean 
idx quicklist 	merge also 
next err 	need overwrite file 
quicklist release 	already working 
iterator quicklist 	copy call update 
release quicklist 	file flags 
quicklist 	instead update file 
push tail 	update cache 
verify quicklist 	update changed safety 
del range 	note binary 
quicklist del 	used renormalizations performed 
range quicklist 	comparison skipped 
index 	files unchanged 
err verify 	since sha already 
quicklist release 	compared rename 
quicklist quicklist 	conflict info pair 
push tail 	rename one 
verify quicklist 	file one otherwise 
del 	normal rename 
range quicklist 	content merge resulted 
del range 	file contents 
verify quicklist 	already early file 
index err 	contents recorded 
quicklist index 	correct path may 
err 	merge involves 
quicklist push 	rename per entry 
tail quicklist 	merge function 
index strncmp 	deleted one deleted 
err quicklist 	deleted one 
index err 	unchanged touch working 
quicklist 	file exist 
release quicklist 	modify deleted 
quicklist push 	side may put 
tail verify 	directory way 
quicklist del 	added one nothing 
range quicklist 	directory nothing 
del 	directory file overwrite 
range verify 	file already 
quicklist index 	present added check 
quicklist release 	permissions modified 
quicklist quicklist 	differently entry deleted 
push tail 	altogether mode 
verify 	means path want 
quicklist del 	actively merge 
range err 	commits resulting commit 
quicklist release 	flag indicating 
ziplist ziplist 	cleanness merge common 
push ziplist 	ancestor use 
push 	empty merge fails 
genstr quicklist 	result contains 
create ziplist 	files conflict 
verify verify 	markers cleanness flag 
verify quicklist 	ignored never 
release mstime 	actually used result 
mstime 	merge trees 
quicklist quicklist 	always overwritten committed 
push tail 	conflicts already 
genstr quicklist 	resolved clear previous 
push head 	settings head 
genstr err 	remote die error 
err 	code merge-recursive.h 
quicklist release 	ancestor branch branch 
mstime err 	subtree shift 
quicklist doubly 	xdl opts verbosity 
linked list 	detect rename 
ziplists copyright 	diff rename limit 
matt 	merge rename 
stancliff matt 	limit rename score 
genges rights 	needed rename 
reserved redistribution 	limit show 
use source 	rename progress call 
binary forms 	depth obuf 
without 	current file current 
modification permitted 	directory conflict 
provided following 	file ancestors result 
conditions met 	head merge 
redistributions source 	common result head 
code must 	merge num 
start 	result merge trees 
copyright notice 	recursive ancestor 
quicklist conditions 	consolidation rename detecting 
following disclaimer 	three way 
redistributions binary 	merge recursion git 
form must 	merge recursive 
reproduce 	fed trees wrap 
copyright notice 	commits call 
quicklist conditions 	merge recursive proper 
following disclaimer 	merge-tree.c merge 
documentation materials 	usage next 
provided distribution 	link mode path 
neither 	blob merge 
name redis 	result merge result 
names contributors 	end entry 
may used 	entry entry size 
endorse promote 	path entry 
products derived 	size priv nbuf 
software 	entry size 
without specific 	src dst xpp 
prior written 	xecfg ecb 
permission software 	entry link desc 
provided copyright 	walk stage 
holders contributors 	mode sha path 
express 	res info 
implied warranties 	path info result 
including limited 	orig path 
implied warranties 	info newbase 
merchantability fitness 	buf buf buf 
particular purpose 	stage info 
disclaimed 	entry path link 
shall copyright 	info entry 
owner contributors 	mask mask dirmask 
liable direct 	entry info 
indirect incidental 	info desc rev 
special exemplary 	sha buf 
consequential 	argc argv prefix 
damages including 	buf buf 
limited procurement 	buf read sha 
substitute goods 	file merge 
services loss 	blobs read sha 
use data 	file memset 
profits 	origin result xdi 
business interruption 	diff die 
however caused 	free free explanation 
theory liability 	oid hex 
whether contract 	show result 
strict liability 	list show diff 
tort 	hashcmp xcalloc 
including negligence 	lookup blob xmallocz 
otherwise arising 	traverse path 
way use 	len make traverse 
software even 	path traverse 
advised possibility 	path create entry 
damage 	create entry 
memcpy debug 	merge entry isdir 
printing snprintf 	traverse path 
genstr optimization 	fill descriptor entry 
levels size 	sha fill 
filling maximum 	descriptor entry sha 
size 	fill descriptor 
bytes multi 	entry sha merge 
element ziplist 	trees free 
larger values 	free free free 
live isolated 	traverse path 
ziplists minimum 	create entry 
ziplist 	isdir unresolved directory 
size bytes 	isdir link 
attempting compression 	entry isdir link 
minimum size 	entry isdir 
reduction bytes 	link entry merge 
store compressed 	entry entry 
quicklist 	empty resolve entry 
node data 	isdir resolve 
also prevents 	entry empty resolve 
storing compression 	unresolved setup 
compression resulted 	traverse info traverse 
larger size 	trees sha 
original 	die fill descriptor 
data verbose 	die usage 
testing debug 	descriptor descriptor descriptor 
printing simple 	merge trees 
way give 	free free free 
quicklist entry 	show result 
structs 	stages existed 
values one 	empty entry never 
call create 	compares even 
quicklist free 	another empty entry 
quicklist release 	already bother 
create quicklist 	showing treat missing 
parameters 	entries directories 
cached quicklist 	unresolved directory handled 
count free 	merge two 
entire quicklist 	trees together common 
compress ziplist 	origin walks 
node update 	sorted trees step 
encoding 	checking every 
details returns 	possible name note 
ziplist compressed 	directories automatically 
successfully returns 	sort differently files 
compression failed 	see name 
ziplist small 	compare never 
compress 	see file directory 
bother compressing 	conflicts won 
small values 	ever compare iow 
cancel compression 	directory changes 
fails doesn 	filename automatically seen 
compress small 	directory going 
enough 	away filename created 
lzf compress 	think three 
aborts rejects 	way diff output 
compression compressable 	either successful 
compress uncompressed 	merge mode sha 
nodes uncompress 	filename note 
ziplist 	note note fixme 
node update 	really really 
encoding details 	need walk index 
returns successful 	parallel conflict 
decode failure 	mode sha filename 
decode someone 	mode sha 
requested 	filename mode 
decompress decompress 	sha filename lines 
good decompress 	may exist 
compressed nodes 	course successful merge 
force node 	rules three 
immediately compresable 	way merge git 
extract 	read modified 
raw lzf 	added removed identically 
data quicklist 	touch modified 
node pointer 	take touch directory 
lzf data 	made file 
assigned data 	fall unresolved recurses 
length 	likewise opposite 
compressed lzf 	added modified removed 
data force 	touch take 
quicklist meet 	merge.c commit strategy 
compression guidelines 	xopts xopts 
compress depth 	common head arg 
way 	remotes args 
guarantee interior 	ret head 
nodes compressed 	remote overwrite ignore 
iterate interior 	trees opts 
compress depth 	trees dir file 
compress next 	oid hex 
node 	argv pushf argv 
find compress 	pushf argv 
depth larger 	push merge argument 
entire list 	argv push 
immediately length 	argv push argv 
less compress 	push merge 
depth 	argument run command 
sides compress 	opt argv 
anything optimized 	clear discard cache 
cases small 	read cache 
depth counts 	die resolve undo 
iterate reach 	clear xcalloc 
compress 	refresh cache hold 
depth sides 	locked index 
list note 	memset memset 
length checks 	memset memset setup 
top function 	standard excludes 
skip checks 	setup unpack trees 
everything 	porcelain parse 
exists point 	indirect parse indirect 
forward reverse 	parse init 
one node 	desc unpack trees 
beyond depth 	write locked 
previously used 	index die builtin 
quicklist 	git merge 
decompress node 	copyright miklos vajna 
use recompress 	vmiklos frugalware 
insert node 	git merge junio 
old node 	hamano cleans 
insert node 	metadata uninteresting succeeded 
old 	merge changes 
node note 	ignore error 
node always 	example nothing restore 
uncompressed assign 	called merge 
head tail 	necessary ignore errors 
need uncompress 	since user 
insert 	see use full 
creates element 	terminal width 
far initialize 	respect stat graph 
head tail 	width config 
wrappers node 	run post merge 
inserting around 	hook name 
existing 	merge commit message 
node size 	see remote 
previous offset 	matches name name 
size forward 	number count 
offset overestimates 	number name name 
encodes integer 	barf values 
type 	future versions git 
approximate merged 	check many 
ziplist size 	files differ 
one ziplist 	check many unmerged 
header trailer 	entries pretend 
entry head 	user told merge 
node 	remote tracking 
quicklist returns 	branch upstream current 
used existing 	branch msg 
head returns 	without edit use 
head created 	editor stdin 
entry tail 	stdout tty current 
node 	head reachable 
quicklist returns 	another commit merged 
used existing 	want record 
tail returns 	parent resulting merge 
tail created 	unless given 
create node 	flip variable find 
consisting 	head among 
pre formed 	independent tips merged 
ziplist used 	find parents 
loading entire 	record checking 
ziplists stored 	independent ones bad 
retrieved later 	merge check 
append 	detached head current 
values ziplist 	branch invoke 
individually quicklist 	git reset merge 
allows restore 	unmerged entry 
old rdb 	advise git file 
ziplists quicklists 	git commit 
smaller 	merged head valid 
ziplist sizes 	one reason 
saved rdb 	forbid git merge 
ziplist returns 	branch yet 
quicklist argument 	born git pull 
frees passed 	could traditional 
ziplist 	merge msg head 
write longval 	commit way 
create potentially 	tell see second 
multi node 	token head 
quicklist single 	people might 
existing ziplist 	misused used commit 
returns 	ish head 
quicklist frees 	instead traditional format 
passed ziplist 	never would 
deleted node 	additional safety measure 
within compress 	check invoked 
depth compressed 	directly first rest 
nodes 	commits merged 
needing decompressed 	prepare standard merge 
one entry 	summary message 
list given 	appended given message 
node entry 	already date 
pointer entry 	already date common 
node 	ancestors found 
note quicklist 	need real merge 
del index 	head reach 
requires uncompressed 	merge date first 
nodes already 	common merging 
uncompressed node 	one remote 
somewhere 	common merging one 
returns entire 	remote octopus 
node deleted 	fast forward need 
node still 	real merge 
exists also 	octopus fast forward 
updates param 	one common 
next 	see really trivial 
offset ziplist 	octopus reach 
deleted node 	remote date calculate 
original node 	individual merge 
longer valid 	bases otherwise git 
one element 	merge head 
represented 	head would missed 
entry entry 	going make 
stores enough 	commit point need 
metadata proper 	real merge 
position correct 	matter strategy 
ziplist correct 	use would operate 
quicklist 	index possibly 
node invalid 	affecting working resolved 
future usage 	cleanly desired 
current node 	index means index 
deleted must 	must sync 
update iterator 	head commit strategies 
node 	responsible ensure 
offset deleted 	stash away local 
node changes 	changes one 
needed already 	remember strategy left 
reset iter 	state working 
existing iter 	necessary avoid writing 
offset 	later exit 
doesn move 	status code merge 
offset next 	backend exits 
element still 	conflicts left resolved 
offset offset 	handle given 
next element 	merge automerge 
still 	succeeded resulting means 
offset deleted 	strategy module 
last element 	resolved merge cleanly 
offet length 	pick result 
ziplist next 	best strategy user 
call quicklist 	fix already 
next 	result working name 
jump next 	attr builtin 
node replace 	merge usage squash 
quicklist entry 	option commit 
offset index 	option edit message 
data length 	verify signatures 
returns 	overwrite ignore merge 
replace happened 	msg use 
returns replace 	strategies use strategies 
failed changes 	use strategies 
happened quicklist 	alloc xopts xopts 
index provides 	xopts alloc 
uncompressed 	branch branch 
node given 	mergeoptions option renormalize 
two nodes 	verbosity allow 
merge ziplists 	rerere abort current 
helps quicklist 	merge show 
element ziplists 	progress upstream sign 
fill 	commit strategy 
factor handle 	pull twohead pull 
much higher 	octopus opt 
levels note 	arg unset buf 
must left 	name ret 
calling function 	main cmds cmds 
considered 	loaded strategies 
unusable function 	found ent opt 
must used 	name unset 
instead quicklist 	opt arg unset 
node input 	opt arg 
arguments returns 	unset builtin merge 
input 	options stash 
node picked 	len buffer 
merge merging 	argv sha verbose 
possible merged 	args sha 
ziplists unused 	verbose args head 
quicklist node 	stash args 
merge 	msg commit remoteheads 
returned nothing 	rev filename 
changed attempt 	ctx head commit 
merge ziplists 	remoteheads head 
within two 	msg reflog message 
nodes either 	head argv 
side 	opts remote msg 
center attempt 	remote head 
merge center 	branch head buf 
prev prev 	bname ptr 
center prev 	found len early 
center next 	seen nonzero 
center 	truname desc 
next next 	bmo argv argc 
center prev 	status boolval 
center center 	common head one 
center next 	trees trees 
merge prev 	opts sha strategy 
prev 	common remoteheads 
prev could 	head head arg 
moved invalidate 	clean result 
merge next 	reversed opt data 
next next 	count ret 
could moved 	list alloc buf 
invalidate 	attr list 
merge center 	msg filename msg 
node previous 	filename commit 
node center 	list remoteheads err 
could deleted 	msg merge 
invalidate 	editor comment remoteheads 
didn merge 	msg head 
target needs 	remoteheads result 
valid use 	result commit parents 
result center 	pptr head 
merge original 	head subsumed common 
merge 	remoteheads result 
next node 	strategy parents buf 
split node 	result commit 
two parts 	filename msgbuf argc 
parameterized offset 	argv head 
argument controls 	second token second 
quicklist 	sha cnt 
node gets 	rev argv branch 
returned returned 	args remoteheads 
node elements 	filename buf oid 
offset input 	name stdin 
node keeps 	stdout head commit 
elements 	head subsumed 
offset including 	remoteheads parents remotes 
offset returned 	commit merge 
node elements 	names merge 
offset including 	msg opts remotes 
offset input 	merge names 
node 	filename pos npos 
keeps elements 	fetch head 
offset returned 	file sha ptr 
node elements 	commit saved 
offset returned 	head commit head 
node elements 	subsumed argc 
offset 	argv merge msg 
end input 	remoteheads remotes 
node keeps 	autogen commit argc 
elements offset 	argv prefix 
returned node 	result stash head 
keep elements 	sha head 
including 	commit buf head 
offset returned 	arg flag 
node elements 	head subsumed automerge 
offset input 	common strategy 
node keeps 	remoteheads branch 
elements offset 	free nargc nargv 
end 	remote head 
input node 	commit hex signature 
keeps elements 	check commit 
taken returned 	list msg commit 
node returns 	date common 
newly created 	one ret cnt 
node 	strbuf setlen 
split possible 	strbuf addf error 
copy original 	size strcmp 
ziplist split 	memset load command 
means deleting 	list size 
list ends 	strncmp cmdname exclude 
insert 	cmds cmdlist 
entry existing 	cmdlist exit xcalloc 
entry entry 	xstrdup alloc 
inserted entry 	grow append 
otherwise inserted 	strategy strategy alloc 
entry reference 	grow xstrdup 
node 	unlink git path 
create node 	merge head 
list populate 	unlink git path 
accounting flags 	merge msg 
easier checks 	unlink git path 
later determine 	merge mode 
insert 	start command die 
element tail 	strbuf read 
next free 	close finish command 
space inserting 	die strbuf 
insert entry 	setlen sha die 
head next 	sha hex 
node 	run command opt 
head previous 	die sha 
free space 	hex run command 
inserting insert 	opt die 
entry tail 	sha reset 
previous node 	hard sha hex 
full 	run command 
prev next 	opt strbuf release 
full create 	refresh cache 
node attach 	drop save git 
quicklist node 	path squash 
full need 	msg open die 
split 	errno init 
covers cases 	revisions pending pending 
range elements 	setup revisions 
quicklist elements 	prepare revision walk 
may span 	die strbuf 
across multiple 	addstr revision strbuf 
quicklist 	addch strbuf 
nodes careful 	addf oid hex 
tracking start 	pretty print 
end returns 	commit write full 
entries deleted 	die errno 
nothing deleted 	close die 
range 	errno strbuf release 
inclusive start 	strbuf addstr 
position requesting 	getenv strbuf addf 
elements exist 	getenv squash 
limit list 	message update close 
size negative 	packs run 
offset 	command opt diff 
limit max 	setup diff 
size rest 	setup done diff 
list lrem 	sha diffcore 
end iterate 	std diff flush 
next nodes 	run hook 
everything 	strbuf release strbuf 
deleted deleting 	branchname memset 
count node 	merge parent die 
entire node 	dwim strlen 
without ziplist 	starts strbuf addf 
math deleting 	sha hex 
nodes 	starts strbuf 
one calculate 	addf sha hex 
size current 	starts strbuf 
node offset 	addf sha hex 
negative first 	strrchr isdigit 
run loop 	strbuf addf strbuf 
deleting 	setlen exists 
entire range 	strbuf addf sha 
start offset 	hex strbuf 
end list 	release strbuf release 
since negative 	merge remote 
offset number 	strbuf addf sha 
elements 	hex strbuf 
tail list 	addf sha hex 
use directly 	strbuf release 
deletion count 	strbuf release split 
positive offset 	cmdline die 
greater remaining 	split cmdline strerror 
extent 	realloc memmove 
remaining extent 	parse options 
entire offset 	free starts starts 
deleting less 	strcmp strlen 
extent node 	free xstrdup strcmp 
use extent 	strcmp git 
directly 	config strcmp git 
passthrough ziplist 	config strcmp 
compare returns 	git config strcmp 
quicklist iterator 	git config 
iter initialization 	strcmp git config 
every call 	maybe strcmp 
quicklist 	strcmp git config 
next next 	strcmp git 
element quicklist 	config fmt merge 
initialize iterator 	msg config 
specific offset 	git gpg config 
idx make 	git diff 
iterator 	config memset 
nodes direction 	parse indirect parse 
direction release 	indirect parse 
iterator still 	indirect cache free 
valid current 	parse init 
node encode 	desc unpack trees 
current 	write cache 
node next 	die hold locked 
element iterator 	index refresh 
note must 	cache write locked 
insert list 	index error 
iterating may 	rollback file strcmp 
list 	strcmp error 
iterating quicklist 	init merge options 
del entry 	strcmp isatty 
function insert 	parse merge opt 
quicklist iterating 	die merge 
create iterator 	remote commit list 
addition 	insert hold 
iter quicklist 	locked index 
iterator quicklist 	merge recursive write 
direction quicklist 	locked index 
entry entry 	die index file 
quicklist next 	rollback file 
iter 	merge command stage 
entry entry 	xstrdup strchr 
use entry 	alloc grow xstrdup 
entry use 	free alloc 
entry longval 	grow xstrdup memset 
populates entry 	split merge 
values 	strategies append strategy 
iteration returns 	strategy size 
iteration complete 	append strategy git 
iteration possible 	path merge 
contents entry 	msg open die 
valid use 	errno write 
current 	full die errno 
index use 	close git 
existing iterator 	path merge 
offset prev 	msg strbuf reset 
next necessary 	strbuf read 
populate existing 	file die errno 
ziplist 	error write 
position ran 	merge state exit 
ziplist entries 	strbuf addbuf 
pick next 	strbuf addch strbuf 
node update 	commented addf 
offset run 	write merge msg 
retrieval 	run commit 
forward traversal 	hook index file 
reverse traversal 	git path 
duplicate quicklist 	merge msg abort 
success copy 	commit launch 
original quicklist 	editor git path 
returned 	merge msg 
original quicklist 	abort commit read 
success error 	merge msg 
never modified 	strbuf stripspace 
returns newly 	abort commit strbuf 
allocated quicklist 	release strbuf 
copy 	addbuf strbuf release 
count must 	write trivial 
equal orig 	commit list append 
count populate 	commit list 
entry element 	append prepare commit 
specified zero 	commit die 
index 	finish drop save 
head element 	free commit 
next head 	list commit list 
negative integers 	insert strbuf 
used order 	addch prepare commit 
count tail 	commit die 
last 	strbuf addf finish 
element penultimate 	strbuf release 
index range 	drop save 
returned returns 	git path merge 
element found 	msg fopen 
returns element 	die errno append 
found 	conflicts hint 
reverse forward 	fputs strbuf release 
forward normal 	fclose rerere 
head tail 	sha lookup commit 
offset reverse 	reference gently 
need negative 	die hashcmp init 
offset 	revisions setup 
tail head 	revisions run diff 
undo result 	files count 
original index 	unmerged entries branch 
caller use 	die die 
result compress 	die xcalloc die 
caller 	merge remote 
recompress node 	merge remote strbuf 
needed rotate 	addf oid 
quicklist moving 	hex git 
tail element 	path merge head 
head first 	open die 
tail 	errno write full 
entry found 	die errno 
ziplist populated 	close strbuf addch 
longval instead 	write merge 
write longval 	msg git path 
tail entry 	merge mode 
head 	open die errno 
must happen 	strbuf reset 
tail deleted 	strbuf addf write 
quicklist one 	full die 
node head 	errno close getenv 
ziplist also 	git config 
tail 	maybe die fstat 
ziplist push 	fstat isatty 
head could 	isatty reduce heads 
reallocated single 	pop commit 
ziplist would 	commit list 
make pre 	insert memset fmt 
existing 	merge msg 
unusable tail 	strbuf setlen git 
entry pop 	path fetch 
quicklist result 	head open die 
data ptr 	errno strbuf 
data saver 	read die errno 
function 	close die 
pointer data 	errno strchr sha 
number quicklist 	hex memcmp 
element returned 	merge parent die 
sval means 	commit list 
elements available 	insert strbuf release 
means 	commit list 
check data 	insert strcmp handle 
sval values 	fetch head 
data use 	reduce parents merge 
data otherwise 	parent help 
use sval 	unknown commit 
malloc 	list insert reduce 
copy data 	parents merge 
passed pop 	name merge remote 
function returns 	prepare merge 
malloc quicklist 	message strbuf release 
wrapper allow 	strcmp usage 
argument 	options resolve refdup 
switching head 	starts sha 
tail pop 	lookup commit die 
rest file 	git config 
test cases 	parse branch merge 
test helpers 	options parse 
unix 	options file exists 
time microseconds 	git path 
unix time 	merge head die 
milliseconds iterate 	cmd reset 
entire quicklist 	read cache 
print list 	unmerged die resolve 
print 	conflict file 
returns physical 	exists git path 
count elements 	merge head 
found iterating 	die die file 
list count 	exists git 
number list 	path cherry pick 
nodes 	head die 
verify list 	die resolve undo 
metadata matches 	clear die 
physical list 	setup upstream die 
contents generate 	strcmp usage 
concatenating integer 	options die die 
prefix 	collect parents 
main test 	die die read 
callable files 	empty update 
head tail 	old style invocation 
beacuse node 	warning strbuf 
head tail 	addstr collect 
head 	parents collect parents 
tail beacuse 	usage options 
node head 	memset check commit 
tail ignore 	signature find 
compression verify 	unique abbrev die 
ziplist small 	die die 
compress 	signature check clear 
force unique 	strbuf addstr 
node force 	strbuf addf merge 
reset insert 	remote setenv 
bar bob 	strbuf reset strbuf 
iterating list 	addf sha 
insert 	hex setenv merge 
fill spills 	remote strbuf 
node didn 	reset merge remote 
fix insert 	merge remote 
iterating verify 	merge remote edit 
results lrem 	option strategies 
bar 	strategies merge 
check result 	bases commit list 
lrem bar 	insert octopus 
result must 	merge bases free 
abc foo 	update finish 
foobar foobared 	date hashcmp find 
zap 	unique abbrev 
test foo 	find unique abbrev 
lrem foo 	strbuf addstr 
check result 	strbuf addstr checkout 
lrem foo 	fast forward 
ignoring part 	finish drop save 
still 	refresh cache 
deleting foo 	git committer info 
two foo 	read trivial 
result must 	merge trivial merge 
abc foo 	bases hashcmp 
foobar foobared 	finish date die 
zap 	git committer 
test foo 	info save 
result tests 	state hashcpy restore 
check results 	state merge 
deletion hij 	strategy evaluate result 
ltrim keep 	write trivial 
inclusive 	finish automerge restore 
remaining force 	state restore 
disable compression 	state merge strategy 
sequential integers 	finish write 
compress check 	merge state suggest 
always fails 	conflicts free 
ltrim 	builtin git merge 
keep inclusive 	copyright miklos 
remaining ltrim 	vajna vmiklos frugalware 
keep inclusive 	git merge 
remaining make 	junio hamano cleans 
sure loop 	metadata uninteresting 
forever 	succeeded merge changes 
run longer 	ignore error 
test compression 	example nothing 
depth outside 	restore called merge 
primary test 	necessary ignore 
loop skip 	errors since user 
many 	see use 
redundant test 	full terminal width 
cases quicklist.h 	respect stat 
fill compress 	graph width config 
quicklist depth 	run post 
quicklist fill 	merge hook name 
quicklist 	merge commit 
fill depth 	message see remote 
quicklist quicklist 	matches name 
quicklist quicklist 	name number count 
quicklist quicklist 	number name 
fill compress 	name barf values 
quicklist 	future versions 
node quicklist 	git check 
node iter 	many files differ 
entry quicklist 	check many 
index data 	unmerged entries pretend 
quicklist start 	user told 
stop 	merge remote tracking 
quicklist direction 	branch upstream 
quicklist direction 	current branch msg 
idx iter 	without edit 
node iter 	use editor stdin 
orig quicklist 	stdout tty 
index 	current head reachable 
entry quicklist 	another commit 
quicklist quicklist 	merged want record 
quicklist data 	parent resulting 
sval saver 	merge unless given 
quicklist data 	flip variable 
slong 	find head among 
len node 	independent tips 
data argc 	merged find 
argv quicklist 	parents record checking 
doubly linked 	independent ones 
quicklist implementation 	bad merge check 
copyright 	detached head 
matt stancliff 	current branch invoke 
matt genges 	git reset 
rights reserved 	merge unmerged entry 
redistribution use 	advise git 
source binary 	file git commit 
forms 	merged head 
without modification 	valid one reason 
permitted provided 	forbid git 
following conditions 	merge branch yet 
met redistributions 	born git 
source code 	pull could traditional 
must 	merge msg 
retain copyright 	head commit way 
notice quicklist 	tell see 
conditions following 	second token 
disclaimer redistributions 	head people might 
binary 	misused used 
form must 	commit ish head 
reproduce copyright 	instead traditional 
notice quicklist 	format never would 
conditions following 	additional safety 
disclaimer documentation 	measure check invoked 
materials 	directly first 
provided distribution 	rest commits merged 
neither name 	prepare standard 
redis names 	merge summary message 
contributors may 	appended given 
used endorse 	message already date 
promote 	already date 
products derived 	common ancestors found 
software without 	need real 
specific prior 	merge head reach 
written permission 	merge date 
software provided 	first common 
copyright 	merging one remote 
holders contributors 	common merging 
express implied 	one remote octopus 
warranties including 	fast forward 
limited implied 	need real merge 
warranties merchantability 	octopus fast 
fitness 	forward one common 
particular purpose 	see really 
disclaimed shall 	trivial octopus reach 
copyright owner 	remote date 
contributors liable 	calculate individual merge 
direct indirect 	bases otherwise 
incidental 	git merge head 
special exemplary 	head would 
consequential damages 	missed going make 
including limited 	commit point 
procurement substitute 	need real 
goods services 	merge matter strategy 
loss 	use would 
use data 	operate index possibly 
profits business 	affecting working 
interruption however 	resolved cleanly desired 
caused theory 	index means 
liability whether 	index must sync 
contract 	head commit 
strict liability 	strategies responsible ensure 
tort including 	stash away 
negligence otherwise 	local changes one 
arising way 	remember strategy 
use software 	left state working 
even 	necessary avoid 
advised possibility 	writing later exit 
damage node 	status code 
quicklist iterator 	merge backend exits 
data structures 	conflicts left 
used currently 	resolved handle 
quicklist 	given merge automerge 
node describing 	succeeded resulting 
ziplist quicklist 	means strategy module 
use bit 	resolved merge 
fields keep 	cleanly pick result 
quicklist node 	best strategy 
bytes 	user fix already 
count bits 	result working 
max max 	merge.c commit strategy 
bytes max 	xopts xopts 
count actually 	common head arg 
encoding bits 	remotes args 
raw 	ret head remote 
lzf container 	overwrite ignore 
bits none 	trees opts trees 
ziplist recompress 	dir file 
bit node 	oid hex argv 
temporarry decompressed 	pushf argv 
usage 	pushf argv 
attempted compress 	push merge argument 
bit used 	argv push 
verifying testing 	argv push argv 
extra bits 	push merge 
free future 	argument run command 
use 	opt argv 
pads remainder 	clear discard cache 
bits ziplist 	read cache 
size bytes 	die resolve undo 
count items 	clear xcalloc 
ziplist raw 	refresh cache hold 
lzf 	locked index 
none ziplist 	memset memset memset 
node previous 	memset setup 
compressed node 	standard excludes setup 
compress small 	unpack trees 
bits steal 	porcelain parse indirect 
future 	parse indirect 
usage quicklist 	parse init 
lzf holding 	desc unpack trees 
followed compressed 	write locked 
length compressed 	index die builtin 
field compressed 	git merge 
lzf 	copyright miklos vajna 
data total 	vmiklos frugalware 
compressed length 	git merge junio 
note uncompressed 	hamano cleans 
length stored 	metadata uninteresting succeeded 
quicklist node 	merge changes 
quicklist 	ignore error example 
node compressed 	nothing restore 
node points 	called merge necessary 
quicklist lzf 	ignore errors 
lzf size 	since user see 
bytes quicklist 	use full 
bit 	terminal width 
systems describing 	respect stat graph 
quicklist count 	width config 
number total 	run post merge 
entries len 	hook name 
number quicklist 	merge commit message 
nodes 	see remote 
compress compression 	matches name name 
disabled otherwise 	number count 
number quicklist 	number name name 
nodes uncompressed 	barf values 
ends quicklist 	future versions git 
fill 	check many 
user requested 	files differ check 
fill factor 	many unmerged 
total count 	entries pretend user 
entries ziplists 	told merge 
number quicklist 	remote tracking branch 
nodes 	upstream current 
fill factor 	branch msg 
individual nodes 	without edit use 
depth end 	editor stdin 
nodes compress 	stdout tty current 
offset current 	head reachable 
ziplist 	another commit merged 
quicklist node 	want record 
encodings quicklist 	parent resulting merge 
compression disable 	unless given 
quicklist container 	flip variable find 
formats prototypes 	head among 
directions 	independent tips merged 
iterators quicklist 	find parents 
rallocx.c tsz 	record checking independent 
szs offset 	ones bad 
len ret 	merge check detached 
buf psz 	head current 
qsz 	branch invoke git 
start sizes 	reset merge 
start size 	unmerged entry 
align align 	advise git file 
mallocx ptr 	git commit 
sallocx rallocx 	merged head valid 
ptr 	one reason 
sallocx rallocx 	forbid git merge 
ptr sallocx 	branch yet 
dallocx test 	born git pull 
fail mallocx 	could traditional 
ptr sallocx 	merge msg head 
validate 	commit way 
fill memset 	tell see second 
validate fill 	token head 
rallocx ptr 	people might misused 
sallocx validate 	used commit 
fill validate 	ish head instead 
fill 	traditional format 
memset validate 	never would additional 
fill dallocx 	safety measure 
mallocx mallocx 	check invoked 
align ptr 	directly first rest 
rallocx mallocx 	commits merged 
align 	prepare standard merge 
ptr ptr 	summary message 
dallocx mallocx 	appended given message 
mallocx align 	already date 
ptr rallocx 	already date common 
mallocx align 	ancestors found 
ptr 	need real merge 
ptr sallocx 	head reach 
validate fill 	merge date first 
validate fill 	common merging 
validate fill 	one remote common 
dallocx test 	merging one 
rand.c 	remote octopus fast 
seedval carry 	forward need 
carry next 	real merge octopus 
seed low 	fast forward 
high mul 	one common 
addequ addequ 	see really trivial 
mul 	octopus reach 
addequ mul 	remote date calculate 
low carry 	individual merge 
low low 	bases otherwise git 
pseudo random 	merge head 
number generation 	head would missed 
functions 	going make 
derived drand 	commit point need 
function obtained 	real merge 
pysam source 	matter strategy use 
code functions 	would operate 
used order 	index possibly affecting 
replace 	working resolved 
math random 	cleanly desired index 
lua implementation 	means index 
something exactly 	must sync 
behavior across 	head commit strategies 
different systems 	responsible ensure 
lua 	stash away local 
uses libc 	changes one 
rand required 	remember strategy left 
implement specific 	state working 
prng generating 	necessary avoid writing 
sequence different 	later exit 
systems 	status code merge 
seeded integer 	backend exits 
original code 	conflicts left resolved 
appears domain 	handle given 
modified removing 	merge automerge succeeded 
non needed 	resulting means 
functions 	strategy module resolved 
style coding 	merge cleanly 
stuff copyright 	pick result best 
salvatore sanfilippo 	strategy user 
antirez gmail 	fix already 
dot rights 	result working name 
reserved 	attr builtin 
redistribution use 	merge usage squash 
source binary 	option commit 
forms without 	option edit message 
modification permitted 	verify signatures 
provided following 	overwrite ignore merge 
conditions 	msg use 
met redistributions 	strategies use strategies 
source code 	use strategies 
must retain 	alloc xopts xopts 
copyright notice 	xopts alloc 
list conditions 	branch branch mergeoptions 
following 	option renormalize 
disclaimer redistributions 	verbosity allow rerere 
binary form 	abort current 
must reproduce 	merge show progress 
copyright notice 	upstream sign 
list conditions 	commit strategy 
following 	pull twohead pull 
disclaimer documentation 	octopus opt 
materials provided 	arg unset buf 
distribution neither 	name ret 
name redis 	main cmds cmds 
names contributors 	loaded strategies 
may 	found ent opt 
used endorse 	name unset 
promote products 	opt arg unset 
derived software 	opt arg 
without specific 	unset builtin merge 
prior written 	options stash 
permission 	len buffer argv 
software provided 	sha verbose 
copyright holders 	args sha verbose 
contributors express 	args head 
implied warranties 	stash args msg 
including limited 	commit remoteheads 
implied 	rev filename 
warranties merchantability 	ctx head commit 
fitness particular 	remoteheads head 
purpose disclaimed 	msg reflog message 
shall copyright 	head argv 
owner contributors 	opts remote msg 
liable 	remote head 
direct indirect 	branch head buf 
incidental special 	bname ptr 
exemplary consequential 	found len early 
damages including 	seen nonzero 
limited procurement 	truname desc bmo 
substitute 	argv argc 
goods services 	status boolval common 
loss use 	head one 
data profits 	trees trees opts 
business interruption 	sha strategy 
however caused 	common remoteheads 
theory 	head head arg 
liability whether 	clean result 
contract strict 	reversed opt data 
liability tort 	count ret 
including negligence 	list alloc buf 
otherwise arising 	attr list 
way 	msg filename msg 
use software 	filename commit 
even advised 	list remoteheads err 
possibility damage 	msg merge 
rand.h seedval 	editor comment remoteheads 
copyright salvatore 	msg head 
sanfilippo 	remoteheads result result 
antirez gmail 	commit parents 
dot rights 	pptr head head 
reserved redistribution 	subsumed common 
use source 	remoteheads result strategy 
binary forms 	parents buf 
without 	result commit 
modification permitted 	filename msgbuf argc 
provided following 	argv head 
conditions met 	second token second 
redistributions source 	sha cnt 
code must 	rev argv branch 
retain 	args remoteheads 
copyright notice 	filename buf oid 
list conditions 	name stdin 
following disclaimer 	stdout head commit 
redistributions binary 	head subsumed 
form must 	remoteheads parents remotes 
reproduce 	commit merge 
copyright notice 	names merge msg 
list conditions 	opts remotes 
following disclaimer 	merge names filename 
documentation materials 	pos npos 
provided distribution 	fetch head file 
neither 	sha ptr 
name redis 	commit saved 
names contributors 	head commit head 
may used 	subsumed argc 
endorse promote 	argv merge msg 
products derived 	remoteheads remotes 
software 	autogen commit argc 
without specific 	argv prefix 
prior written 	result stash head 
permission software 	sha head 
provided copyright 	commit buf head 
holders contributors 	arg flag 
express 	head subsumed automerge 
implied warranties 	common strategy 
including limited 	remoteheads branch free 
implied warranties 	nargc nargv 
merchantability fitness 	remote head commit 
particular purpose 	hex signature 
disclaimed 	check commit list 
shall copyright 	msg commit 
owner contributors 	date common 
liable direct 	one ret cnt 
indirect incidental 	strbuf setlen 
special exemplary 	strbuf addf error 
consequential 	size strcmp 
damages including 	memset load command 
limited procurement 	list size 
substitute goods 	strncmp cmdname exclude 
services loss 	cmds cmdlist 
use data 	cmdlist exit xcalloc 
profits 	xstrdup alloc 
business interruption 	grow append strategy 
however caused 	strategy alloc 
theory liability 	grow xstrdup unlink 
whether contract 	git path 
strict liability 	merge head unlink 
tort 	git path 
including negligence 	merge msg 
otherwise arising 	unlink git path 
way use 	merge mode 
software even 	start command die 
advised possibility 	strbuf read 
damage 	close finish command 
rb.c magic 	die strbuf 
key ret 	setlen sha die 
key node 	sha hex 
black height 	run command opt 
black depth 	die sha 
nil 	hex run command 
ret left 	opt die 
node right 	sha reset hard 
node node 	sha hex 
data search 	run command opt 
node node 	strbuf release 
nnodes 	refresh cache drop 
search node 	save git 
black height 	path squash 
imbalances node 	msg open die 
data nnodes 	errno init 
ret node 	revisions pending pending 
data 	setup revisions 
nnodes ret 	prepare revision walk 
sfmt bag 	die strbuf 
nodes black 	addstr revision strbuf 
height imbalances 	addch strbuf 
start nnodes 	addf oid hex 
start 	pretty print 
nnodes gen 	commit write full 
empty ptr 	die errno 
first ptr 	close die errno 
last ptr 	strbuf release 
search ptr 	strbuf addstr getenv 
nsearch 	strbuf addf 
ptr psearch 	getenv squash message 
rbtn left 	update close 
rbtn right 	packs run 
rbtn red 	command opt diff 
rbtn red 	setup diff 
rbtn 	setup done diff 
red rbtn 	sha diffcore 
red recurse 	std diff flush 
recurse search 	run hook 
ptr nsearch 	strbuf release strbuf 
ptr psearch 	branchname memset 
ptr 	merge parent die 
iter reverse 	dwim strlen 
iter nsearch 	starts strbuf addf 
psearch rbtn 	sha hex 
black height 	starts strbuf addf 
recurse iterate 	sha hex 
iterate 	starts strbuf addf 
reverse next 	sha hex 
node prev 	strrchr isdigit strbuf 
node init 	addf strbuf 
gen rand 	setlen exists 
gen rand 	strbuf addf sha 
range 	hex strbuf 
insert rbtn 	release strbuf release 
black height 	merge remote 
recurse iterate 	strbuf addf sha 
iterate reverse 	hex strbuf 
empty ptr 	addf sha hex 
first 	strbuf release 
ptr last 	strbuf release split 
next prev 	cmdline die 
node node 	split cmdline strerror 
iter reverse 	realloc memmove 
iter reached 	parse options free 
fini 	starts starts 
gen rand 	strcmp strlen free 
test duplicates 	xstrdup strcmp 
allowed force 	strcmp git config 
arbitrary ordering 	strcmp git 
non identical 	config strcmp 
items 	git config strcmp 
equal keys 	git config 
red nodes 	strcmp git config 
must interleaved 	maybe strcmp 
black nodes 	strcmp git config 
self left 	strcmp git 
subtree 	config fmt merge 
right subtree 	msg config 
test search 	git gpg config 
test nsearch 	git diff 
test psearch 	config memset parse 
test 	indirect parse 
nsearch test 	indirect parse indirect 
psearch insert 	cache free 
order insert 	parse init desc 
reverse order 	unpack trees 
initialize nodes 	write cache 
insert 	die hold locked 
nodes nodes 	index refresh 
rb.h cpp 	cache write locked 
macro implementation 	index error 
left leaning 	rollback file strcmp 
red black 	strcmp error 
trees 	init merge options 
parent pointers 	strcmp isatty 
used color 	parse merge opt 
bits stored 	die merge 
least significant 	remote commit list 
bit right 	insert hold 
child 	locked index merge 
pointers compact 	recursive write 
defined thus 	locked index die 
making node 	index file 
linkage compact 	rollback file merge 
possible red 	command stage 
black 	xstrdup strchr 
trees usage 	alloc grow xstrdup 
include stdint 	free alloc 
include stdbool 	grow xstrdup memset 
define ndebug 	split merge 
optional see 	strategies append strategy 
include 	strategy size 
define compact 	append strategy git 
optional embed 	path merge 
color bits 	msg open die 
right child 	errno write 
pointers include 	full die errno 
node 	close git 
structure root 	path merge msg 
structure left 	strbuf reset 
accessors right 	strbuf read file 
accessors color 	die errno 
accessors right 	error write merge 
accessors 	state exit 
color accessors 	strbuf addbuf 
node initializer 	strbuf addch strbuf 
initializer utility 	commented addf 
macros proto 	write merge msg 
macro generates 	run commit 
function 	hook index file 
prototypes correspond 	git path 
functions generated 	merge msg abort 
equivalently parameterized 	commit launch 
call gen 	editor git path 
gen macro 	merge msg 
generates 	abort commit read 
type specific 	merge msg 
red black 	strbuf stripspace abort 
implementation cpp 	commit strbuf 
macros arguments 	release strbuf addbuf 
attr function 	strbuf release 
attribute 	write trivial commit 
generated functions 	list append 
prefix prefix 	commit list 
generated functions 	append prepare commit 
type type 	commit die 
red black 	finish drop save 
data 	free commit 
structure type 	list commit list 
type red 	insert strbuf 
black node 	addch prepare commit 
data structure 	commit die 
node field 	strbuf addf finish 
name 	strbuf release 
red black 	drop save git 
node linkage 	path merge 
link cmp 	msg fopen die 
node comparison 	errno append 
function name 	conflicts hint fputs 
following 	strbuf release 
prototype cmp 	fclose rerere 
type node 	sha lookup commit 
type key 	reference gently 
interpretation comparison 	die hashcmp init 
function values 	revisions setup 
node 	revisions run diff 
node node 	files count 
cases node 	unmerged entries branch 
key macro 	die die 
argument first 	die xcalloc die 
argument comparison 	merge remote 
function 	merge remote strbuf 
makes possible 	addf oid 
write comparison 	hex git path 
functions treat 	merge head 
first argument 	open die errno 
specially assuming 	write full 
following 	die errno close 
setup node 	strbuf addch 
node node 	write merge 
node node 	msg git path 
link node 	merge mode 
gen node 	open die errno 
link 	strbuf reset 
cmp following 	strbuf addf write 
api generated 	full die 
description initialize 	errno close getenv 
red black 	git config 
structure args 	maybe die fstat 
pointer 	fstat isatty 
uninitialized red 	isatty reduce heads 
black empty 	pop commit 
description determine 	commit list insert 
whether empty 	memset fmt 
args pointer 	merge msg strbuf 
initialized 	setlen git 
red black 	path fetch head 
ret empty 	open die 
otherwise node 	errno strbuf 
first node 	read die errno 
last description 	close die 
first 	errno strchr sha 
last node 	hex memcmp 
args pointer 	merge parent die 
initialized red 	commit list 
black ret 	insert strbuf release 
first last 	commit list 
node 	insert strcmp handle 
empty node 	fetch head 
next node 	reduce parents merge 
node node 	parent help 
prev node 	unknown commit list 
node description 	insert reduce 
node 	parents merge name 
successor predecessor 	merge remote 
args pointer 	prepare merge message 
initialized red 	strbuf release 
black node 	strcmp usage 
node ret 	options resolve refdup 
node 	starts sha 
successor predecessor 	lookup commit die 
node last 	git config 
first node 	parse branch merge 
search node 	options parse 
key description 	options file exists 
search 	git path 
node matches 	merge head die 
key args 	cmd reset 
pointer initialized 	read cache unmerged 
red black 	die resolve 
key search 	conflict file exists 
key 	git path 
ret node 	merge head die 
matches key 	die file 
match node 	exists git path 
nsearch node 	cherry pick 
key node 	head die 
psearch 	die resolve undo 
node key 	clear die 
description search 	setup upstream die 
node matches 	strcmp usage 
key match 	options die die 
found would 	collect parents 
key 	die die read 
successor predecessor 	empty update 
key args 	old style invocation 
pointer initialized 	warning strbuf 
red black 	addstr collect parents 
key search 	collect parents 
key 	usage options memset 
ret node 	check commit 
matches key 	signature find unique 
match hypothetical 	abbrev die 
node successor 	die die 
predecessor successor 	signature check clear 
predecessor 	strbuf addstr 
insert node 	strbuf addf merge 
node description 	remote setenv 
insert node 	strbuf reset strbuf 
args pointer 	addf sha 
initialized red 	hex setenv merge 
black 	remote strbuf 
node node 	reset merge remote 
inserted node 	merge remote 
node description 	merge remote edit 
node args 	option strategies 
pointer initialized 	strategies merge bases 
red 	commit list 
black node 	insert octopus merge 
node removed 	bases free 
node iter 	update finish date 
node start 	hashcmp find 
node node 	unique abbrev 
arg 	find unique abbrev 
node reverse 	strbuf addstr 
iter node 	strbuf addstr checkout 
start node 	fast forward 
node arg 	finish drop save 
description iterate 	refresh cache 
forward 	git committer info 
backward starting 	read trivial 
node modified 	merge trivial merge 
iteration must 	bases hashcmp 
immediately terminated 	finish date die 
callback function 	git committer 
causes 	info save state 
modification args 	hashcpy restore 
pointer initialized 	state merge strategy 
red black 	evaluate result 
start node 	write trivial finish 
start iteration 	automerge restore 
start 	state restore 
first last 	state merge strategy 
node callback 	finish write 
function called 	merge state suggest 
node iteration 	conflicts free 
normal circumstances 	builtin git merge 
callback 	copyright miklos 
function causes 	vajna vmiklos frugalware 
iteration callback 	git merge 
function returns 	junio hamano cleans 
non iteration 	metadata uninteresting 
immediately terminated 	succeeded merge changes 
non 	ignore error 
returned iterator 	example nothing restore 
useful starting 	called merge 
iteration modifying 	necessary ignore errors 
arg opaque 	since user 
pointer passed 	see use full 
ret 	terminal width 
iteration completed 	respect stat 
non callback 	graph width config 
caused termination 	run post 
iteration wind 	merge hook name 
unwind fix 	merge commit 
node 	message see remote 
split node 	matches name 
lean left 	name number count 
root make 	number name 
black wind 	name barf values 
silence compiler 	future versions 
warning 	git check many 
find node 	files differ 
successor preparation 	check many unmerged 
swap swap 	entries pretend 
node successor 	user told merge 
node successor 	remote tracking 
right 	branch upstream 
child following 	current branch msg 
code wrong 	without edit 
thing right 	use editor stdin 
child pointer 	stdout tty 
however doesn 	current head reachable 
matter 	another commit 
pointer properly 	merged want record 
successor pruned 	parent resulting 
pruned leaf 	merge unless given 
node child 	flip variable 
pointers never 	find head among 
accessed 	independent tips 
bother setting 	merged find parents 
nil node 	record checking 
successor left 	independent ones bad 
child splice 	merge check 
node without 	detached head current 
losing 	branch invoke 
left child 	git reset 
contained one 	merge unmerged entry 
node prune 	advise git 
red node 	file git commit 
requires fixup 	merged head 
node 	valid one reason 
pruned black 	forbid git 
unwind balance 	merge branch yet 
restored following 	born git 
diagrams indicate 	pull could traditional 
path removed 	merge msg 
node 	head commit way 
pathp pathp 	tell see 
balance restored 	second token head 
rotation modified 	people might 
subtree root 	misused used commit 
pathp balance 	ish head 
restored 	instead traditional format 
rotation modified 	never would 
subtree root 	additional safety 
may actually 	measure check invoked 
root root 	directly first 
pathp pathp 	rest commits merged 
pathp 	prepare standard 
balance restored 	merge summary message 
rotation modified 	appended given 
subtree root 	message already date 
may actually 	already date 
root root 	common ancestors found 
pathp 	need real 
balance restored 	merge head reach 
rotation modified 	merge date 
subtree root 	first common merging 
pathp balance 	one remote 
restored pathp 	common merging one 
balance 	remote octopus 
restored rotation 	fast forward need 
modified subtree 	real merge 
root may 	octopus fast 
actually root 	forward one common 
root pathp 	see really 
root 	trivial octopus reach 
rdb.c reason 	remote date 
rdb len 	calculate individual merge 
rdb type 	bases otherwise 
rdb type 	git merge head 
rdb rdb 	head would 
rdb 	missed going make 
rdb len 	commit point 
buf nwritten 	need real merge 
rdb isencoded 	matter strategy 
buf len 	use would operate 
type enc 	index possibly 
rdb 	affecting working resolved 
enctype flags 	cleanly desired 
plain encode 	index means 
enc val 	index must sync 
buf len 	head commit 
len enc 	strategies responsible ensure 
endptr 	stash away 
buf rdb 	local changes one 
data compress 	remember strategy 
len original 	left state working 
len nwritten 	necessary avoid 
rdb len 	writing later exit 
comprlen 	status code 
outlen nwritten 	merge backend exits 
rdb flags 	conflicts left 
plain len 	resolved handle given 
clen val 	merge automerge 
rdb len 	succeeded resulting means 
enclen 	strategy module 
nwritten buf 	resolved merge cleanly 
rdb buf 	pick result 
nwritten enclen 	best strategy 
rdb obj 	user fix already 
rdb flags 	result working 
encode 	mergesort.c ptr len 
plain isencoded 	list next 
len buf 	next list next 
rdb rdb 	next compare 
rdb val 	curr prev next 
buf len 	next nth 
min 	next compare pop 
max rdb 	item pop 
val buf 	item pop item 
len rdb 	pop item 
rdb type 	compare pop item 
rdb nwritten 	pop item 
node 	next nth next 
data compress 	next mergesort.h 
len eleobj 	list next next 
eleobj score 	compare sort 
key val 	linked list 
len rdb 	place next returns 
key 	next element 
val expiretime 	given element linked 
rdb key 	list next 
keylen val 	takes two elements 
vallen rdb 	makes next 
key val 	element list compare 
rdb 	takes two 
key val 	elements returns negative 
buf vlen 	positive sign 
rdb redis 	subtracting mingw.c delay 
bits rdb 	winerr error 
error magic 	errcode answer answer 
cksum 	len format 
size expires 	question retry hook 
size keystr 	args answer 
key expire 	pathname ret tries 
rdb error 	wpathname wpath 
eofmark filename 	findbuf handle 
tmpfile 	wbuf err pathname 
cwd rdb 	ret tries 
error cwdp 	wpathname path mode 
cwdp filename 	ret wpath 
childpid start 	filename oflags args 
retval dirty 	mode wfilename 
childpid 	attrs type stream 
tmpfile rdbtype 	filename otype 
rdb ele 	file wfilename wotype 
dec len 	filename otype 
len llval 	stream file wfilename 
zsetlen maxelelen 	wotype stream 
ele 	ret buf len 
score znode 	result filename 
len ret 	mode wfilename dirname 
field field 	wdirname filename 
encoded fstr 	mode wfilename win 
vstr flen 	time wfilename 
vlen 	attributes follow 
maxlen pos 	file name buf 
buf len 	fdata wfilename 
filename dbid 	findbuf handle buffer 
type rdbver 	follow file 
buf expiretime 	name buf namelen 
rdb 	alt name 
key val 	file name buf 
size expires 	file name 
size auxkey 	buf buf fdata 
auxval cksum 	win time 
expected exitcode 	file name times 
bysignal 	mft aft 
latency exitcode 	attrs wfilename seconds 
bysignal slaves 	wtemplate filename 
readlen slave 	hnsec filedes timep 
errorcode exitcode 	result timep 
bysignal fds 	result pointer 
clientids 	len wpointer arg 
numfds childpid 	force quotes 
start pipefds 	count count cmd 
slave retval 	buf opt 
slave sockets 	path envpath dir 
dirty msg 	path dir 
len 	cmd isexe exe 
ids msglen 	path cmd 
slave server 	path exe prog 
log redis 	len isexe 
check rdb 	env name size 
exit rio 	free old 
write 	environ size environ 
rdb write 	alloc deltaenv 
raw rio 	wenvblk tmpenv wenvpos 
read rio 	next pid 
read rdb 	proc pinfo pinfo 
write 	cmd argv 
raw rio 	deltaenv dir 
read rdb 	prepend cmd fhin 
write raw 	fhout fherr 
rdb write 	args wcmd wdir 
raw rdb 	wargs wenvblk 
write 	flags ret cons 
raw htonl 	quoted quoted 
rdb write 	info cmd argv 
raw rio 	prepend cmd 
read rio 	cmd argv deltaenv 
read rio 	dir fhin 
read 	fhout fherr pid 
ntohl rio 	path prog 
read rio 	interpr argv iprog 
read rio 	cmd argv 
read rdb 	interpr path prog 
exit report 	pid argc 
corrupt 	argv status cmd 
rdb zmalloc 	argv pid 
memcpy create 	status cmd 
create sdsfromlonglong 	argv path prog 
strtoll strlen 	pid sig 
memcmp rdb 	env name size 
encode 	high mid 
integer rdb 	cmp env name 
write raw 	size free 
rdb save 	old name pos 
len rdb 	namevalue node 
save len 	service hints res 
rdb 	sin res 
write raw 	salen host hostlen 
zmalloc lzf 	serv servlen 
compress zfree 	flags sin ent 
rdb save 	ent ipv 
lzf blob 	dll res node 
zfree 	service hints 
rdb load 	res salen host 
len rdb 	hostlen serv 
load len 	servlen flags 
zmalloc zmalloc 	wsa initialized libraries 
sdsnewlen rio 	name name 
read 	namelen host res 
lzf decompress 	node service 
zfree create 	hints res salen 
zfree zfree 	host hostlen 
sdsfree rdb 	serv servlen flags 
integer encoding 	domain type 
rdb 	protocol sockfd sockfd 
write raw 	sockfd sockfd 
rdb save 	lvl optname optval 
lzf rdb 	optlen sockfd 
save len 	sockfd backlog sockfd 
rdb write 	sockfd err 
raw 	pold pnew attrs 
rdb encode 	gle tries 
integer rdb 	wpold wpnew 
write raw 	attrsold uid user 
server rdb 	name len 
save len 	timer timer timer 
rdb 	interval one 
write raw 	shot sigint dummy 
rdb save 	type zero 
server info 	atexit done sig 
sds encoded 	sig handler 
rdb save 	old sig path 
raw 	buf unixpath 
sdslen rdb 	htmlpath shell execute 
load len 	shell oldpath 
rdb load 	newpath create hard 
integer rdb 	link woldpath 
load lzf 	wnewpath pid status 
rdb 	options ppinfo 
exit report 	info path ret 
corrupt rdb 	path pos 
create create 	wcs utfs 
raw rio 	wcslen utflen wpos 
read decr 	utf hex 
count 	utf wcs utflen 
zmalloc rio 	tmp crt 
read zfree 	glob argc argv 
rdb load 	env glob 
rdb load 	size result buffer 
isnan isfinite 	wcs len 
snprintf 	maxlen argc buffer 
strlen rdb 	wenv wargv 
write raw 	buf fgets strlen 
rio read 	getchar tolower 
rio read 	strncasecmp tolower strncasecmp 
sscanf rdb 	start vsnprintf 
save 	end mingw getenv 
type rdb 	run command 
save type 	opt isatty fileno 
server panic 	isatty fileno 
rdb save 	read yes 
type rdb 	answer xutftowcs path 
save 	wchmod wunlink 
type server 	size file use 
panic rdb 	error last 
save type 	error sleep file 
rdb save 	use error 
type server 	last error ask 
panic 	yes possible 
rdb save 	wunlink wcscpy wcscat 
type rdb 	find first 
save type 	file last error 
server panic 	wcscmp wcscmp 
server panic 	find next file 
rdb 	last error 
load type 	find close find 
rdb type 	close xutftowcs 
rdb save 	path wrmdir size 
rdb save 	file use 
len quicklist 	error last 
node 	error err win 
compressed quicklist 	posix last 
lzf rdb 	error dir empty 
save lzf 	sleep file 
blob rdb 	use error last 
save raw 	error ask 
server 	yes possible wrmdir 
panic dict 	xutftowcs path 
iterator rdb 	wmkdir start arg 
save len 	end strcmp 
dict size 	xutftowcs path wopen 
dict next 	file attributes 
dict 	isatty fileno fgetc 
key rdb 	console ctrl 
save dict 	handler fgetc last 
release iterator 	error mingw 
intset blob 	console ctrl 
len rdb 	handler strcmp xutftowcs 
save 	path xutftowcs 
raw server 	size wfopen strcmp 
panic ziplist 	xutftowcs path 
blob len 	xutftowcs size wfreopen 
rdb save 	fflush write 
raw dict 	osfhandle file type 
iterator 	xutftowcs path 
rdb save 	waccess xutftowcs path 
len dict 	wchdir xutftowcs 
size dict 	path wchmod time 
next dict 	filetime hnsec 
key dict 	wcslen dir sep 
val 	file attributes 
rdb save 	last error xutftowcs 
rdb save 	path file 
dict release 	attributes file attr 
iterator server 	mode filetime 
panic ziplist 	time filetime 
blob 	time filetime time 
len rdb 	find first 
save raw 	file readlink find 
dict iterator 	close last 
rdb save 	error valid directory 
len dict 	prefix lstat 
size 	strlen memcpy lstat 
dict next 	stat stat 
dict key 	osfhandle file type 
dict val 	fstati file 
rdb save 	information handle file 
rdb save 	attr mode 
dict 	filetime time filetime 
release iterator 	time filetime 
server panic 	time xutftowcs path 
server panic 	file attributes 
rdb save 	file attributes wopen 
server info 	time filetime 
rdb 	time filetime 
save type 	system time file 
rdb save 	time file 
millisecond time 	time osfhandle close 
rdb save 	file attributes 
type rdb 	sleep xutftowcs path 
save 	wmktemp xwcstoutf 
rdb save 	strlen mktemp open 
rdb save 	system time 
type rdb 	file time filetime 
save raw 	hnsec create 
rdb save 	pipe err win 
raw 	posix last 
rdb save 	error open osfhandle 
aux field 	hcast close 
strlen strlen 	handle close handle 
rdb save 	open osfhandle 
aux field 	hcast close close 
strlen 	handle memcpy 
rdb save 	gmtime memcpy 
aux field 	localtime wgetcwd size 
str str 	xwcstoutf isspace 
rdb save 	xmalloc strlen strcasecmp 
aux field 	open read 
str 	close strcspn strrchr 
rdb save 	strrchr strchr 
aux field 	mingw getenv xstrdup 
str time 	strchr alloc 
rdb save 	xstrdup strlen free 
aux field 	free free 
str 	snprintf access xstrdup 
zmalloc used 	strlen access 
memory mstime 	file attributes xstrdup 
snprintf rdb 	strlen strcasecmp 
write raw 	strchr strchr xstrdup 
rdb save 	lookup prog 
info 	alloc memcpy putenv 
aux fields 	strlen alloc 
dict size 	grow xutftowcs 
dict safe 	free create file 
iterator rdb 	close handle 
save type 	memset winansi osfhandle 
rdb 	winansi osfhandle 
save len 	winansi osfhandle xutftowcs 
dict size 	path xutftowcs 
dict size 	path strbuf init 
dict size 	quote arg 
dict size 	strbuf addstr free 
rdb 	quote arg 
save type 	strbuf addch strbuf 
rdb save 	addstr free 
len rdb 	alloc mult xutftowcs 
save len 	strbuf release 
dict next 	make environment block 
dict 	memset create 
key dict 	process free 
val init 	free close handle 
expire rdb 	enter critical 
save key 	section xmalloc critical 
pair dict 	section mingw 
release 	spawnve path split 
iterator rdb 	path lookup 
save type 	parse interpreter path 
memrev ifbe 	lookup mingw 
rio write 	spawnve free mingw 
dict release 	spawnve free 
iterator 	free path split 
random hex 	parse interpreter 
chars rio 	path split path 
write rio 	lookup alloc 
write rio 	memcpy mingw spawnv 
write rdb 	waitpid exit 
save 	free free free 
rio rio 	path split 
write snprintf 	shell exec 
getpid fopen 	mingw spawnv waitpid 
getcwd server 	exit path 
log strerror 	split path lookup 
rio 	mingw execv 
init file 	free free path 
rdb save 	split open 
rio fflush 	process terminate process 
fsync fileno 	close handle 
fclose rename 	err win posix 
getcwd 	last error 
server log 	close handle open 
strerror unlink 	process close 
server log 	handle tolower tolower 
time server 	compareenv bsearchenv 
log strerror 	free strchr memmove 
fclose 	memmove bsearchenv 
unlink time 	strchr alloc grow 
ustime fork 	putenv gethostbyname 
close listening 	wsa last 
sockets redis 	error xmalloc xstrdup 
proc title 	xcalloc htons 
rdb 	atoi free free 
save zmalloc 	free gethostbyaddr 
dirty server 	snprintf snprintf inet 
log exit 	ntoa getservbyport 
child ustime 	snprintf snprintf ntohs 
zmalloc used 	wsa cleanup 
memory 	free library wsa 
latency sample 	startup makeword 
needed server 	die wsa last 
log strerror 	error load 
server log 	library proc address 
time update 	proc address 
dict 	proc address free 
resize policy 	library atexit 
snprintf unlink 	ensure socket initialization 
rdb load 	gethostname ensure 
encoded encoding 	socket initialization 
rdb load 	gethostbyname ipv freeaddrinfo 
len 	ensure socket 
create quicklist 	initialization ipv getaddrinfo 
quicklist options 	ensure socket 
rdb load 	initialization ipv getnameinfo 
encoded decoded 	ensure socket 
sdslen quicklist 	initialization wsa socket 
push 	wsa last 
tail decr 	error open osfhandle 
count decr 	closesocket error 
count rdb 	strerror osfhandle connect 
load len 	osfhandle bind 
create dict 	osfhandle setsockopt osfhandle 
expand 	shutdown osfhandle 
create intset 	listen osfhandle accept 
rdb load 	open osfhandle 
encoded encoding 	closesocket error 
representable intset 	strerror xutftowcs path 
type convert 	xutftowcs path 
dict 	wrename move file 
expand dict 	last error 
decr count 	file attributes file 
rdb load 	attributes wrmdir 
len create 	file attributes move 
zset rdb 	file last 
load 	error file attributes 
encoded encoding 	size sleep 
rdb load 	ask yes possible 
sds encoded 	system info 
sdslen sdslen 	user name wait 
zsl insert 	single mingw 
dict 	create beginthreadex wait 
incr count 	single error 
zset length 	error last error 
zset convert 	close handle 
rdb load 	close handle 
len create 	timeval timeval stop 
hash 	timer timeval 
hash type 	timeval timeval atexit 
convert rdb 	start timer 
load server 	signal isatty fputs 
sds encoded 	exit timer 
rdb load 	exit sigint strlcpy 
server 	die make 
sds encoded 	backslash path load 
ziplist push 	library die 
sdslen ziplist 	proc address die 
push sdslen 	hcast shell 
sdslen sdslen 	execute free library 
decr 	die xutftowcs 
count decr 	path xutftowcs path 
count hash 	proc address 
type convert 	module handle create 
decr count 	hard link 
decr count 	err win 
rdb 	posix last error 
load encoded 	open process 
rdb load 	wait single close 
encoded encoding 	handle wait 
encoding dict 	single close handle 
rdb exit 	exit code 
report 	process enter critical 
corrupt rdb 	section close 
server rdb 	handle free critical 
load len 	section close 
create quicklist 	handle close handle 
quicklist options 	dos drive 
rdb 	prefix skip dos 
load quicklist 	drive prefix 
append ziplist 	dir sep dir 
rdb load 	sep strpbrk 
create ziplist 	dir sep dir 
zipmap rewind 	sep wide 
zipmap 	multi getenv 
next ziplist 	getenv getenv setenv 
push ziplist 	getenv getenv 
push zfree 	setenv fputs exit 
hash type 	malloc die 
length hash 	startup xwcstoutf memcpy 
type 	malloc startup 
convert list 	wgetmainargs die startup 
type convert 	wcslen max 
intset len 	wcslen max wcslen 
type convert 	alloc malloc 
zset length 	startup malloc startup 
zset 	wcstoutfdup startup 
convert hash 	wcstoutfdup startup wcstoutfdup 
type length 	startup free 
hash type 	qsort setup windows 
convert rdb 	environment initialize 
exit report 	critical section 
corrupt 	setmode fileno setmode 
rdb rdb 	fileno setmode 
exit report 	fileno winansi init 
corrupt rdb 	version memset 
time fstat 	xsnprintf xsnprintf xsnprintf 
fileno zmalloc 	newline flush 
used 	buffer full line 
memory zmalloc 	could read 
used memory 	answer find answer 
rio update 	understand read 
checksum update 	files cannot removed 
cached time 	process source 
replication 	destination file open 
send newline 	wrong moment 
master loading 	retry order give 
progress process 	process higher 
events blocked 	chance complete operation 
mstime fopen 	give time 
rio 	slice retry 
init file 	sleep bit process 
rio read 	source destination 
memcmp fclose 	file open wrong 
server log 	moment retry 
atoi fclose 	order give process 
server 	higher chance 
log start 	complete operation give 
loading rdb 	time slice 
load type 	retry sleep bit 
rdb load 	ctrl pressed 
time rdb 	simulate sigint retry 
load 	write used 
type rdb 	behind scenes stdio 
load millisecond 	output functions 
time rdb 	since git code 
load type 	check errors 
rdb load 	stdio write operation 
len 	happen write 
server log 	called later 
exit rdb 	stdio function even 
load len 	earlier write 
rdb load 	call failed pipe 
len dict 	whose readable 
expand 	end closed first 
dict expand 	call write 
rdb load 	reports epipe windows 
rdb load 	subsequent write 
server log 	calls report einval 
server log 	impossible notice 
decr 	whether fflush invocation 
count decr 	triggered therefore 
count rdb 	einval errors whole 
load rdb 	sale check 
load decr 	pipe supported msvcrt 
count decr 	version unit 
count 	filetime nanoseconds since 
expire decr 	january utc 
count rio 	returns nanoseconds 
read memrev 	hekto nanoseconds since 
ifbe server 	epoch windows 
log server 	unix epoch conversion 
log 	verifies safe 
rdb exit 	create leading directories 
report corrupt 	would succeed 
rdb fclose 	implies parent directory 
stop loading 	exists keep 
server 	lstat code separate 
log rdb 	function avoid 
exit report 	recursion path ends 
corrupt rdb 	slash stat 
server log 	fail enoent strip 
time server 	trailing slashes 
log 	stat follow act 
server log 	like stat 
latency start 	report link target 
monitor rdb 	otherwise report 
temp file 	link used 
latency end 	git fallthru provide 
monitor 	lstat fstat 
latency sample 	functions since provided 
needed time 	lstat fstat 
update slaves 	functions slow stat 
waiting bgsave 	functions tailored 
server log 	git usage read 
server 	fast meant 
log server 	complete note git 
log zmalloc 	stat redirected 
read zrealloc 	mingw lstat since 
read close 	windows doesn 
close list 	really handle symlinks 
rewind 	well file 
list next 	name ended windows 
server log 	returned enoent 
replication slave 	without trailing 
name strerror 	slashes direct non 
free client 	file handles 
server 	fstat used git 
log replication 	must write 
slave name 	permission ignore errors 
anet non 	open report 
block anet 	ignore errors creates 
send timeout 	non inheritable 
zfree 	handles gmtime msvcrt 
update slaves 	dll safe 
waiting bgsave 	reentrant localtime msvcrt 
background save 	dll safe 
done handler 	reentrant see http 
disk background 	msdn microsoft 
save 	library ykft aspx 
done handler 	parsing command 
socket server 	line arguments count 
panic pipe 	chars quote 
zmalloc list 	insert necessary 
length zmalloc 	even exe least 
list 	error strip 
length list 	options splits path 
rewind list 	parts earlier 
next replication 	catches series exe 
setup slave 	means want 
full resync 	detect exe files 
psync 	scripts extension 
initial offset 	determines absolute path 
anet block 	cmd split 
anet send 	path path cmd 
timeout ustime 	contains slash 
fork rio 	backslash lookup performed 
init 	used number 
fdset zfree 	elements environ including 
close listening 	terminating allocated 
sockets redis 	size environ bytes 
proc title 	create environment 
rdb save 	block suitable 
rio 	create process merges 
eof mark 	current process 
rio flush 	environment supplied environment 
zmalloc dirty 	changes copy 
server log 	environment leaving space 
zmalloc write 	changes merge 
zfree 	supplied environment changes 
zfree exit 	temporary environment 
child ustime 	create environment block 
zmalloc used 	temporary environment 
memory latency 	terminator determine whether 
sample needed 	associated console 
server 	console associated process 
log strerror 	since child 
list rewind 	console process windows 
list next 	would normally 
close close 	create console window 
server log 	since redirecting 
time 	std streams 
update dict 	need console necessary 
resize policy 	use detached 
zfree zfree 	process instead create 
reply error 	window make 
rdb save 	ssh recognize console 
reply 	already console 
reply reply 	specified detached process 
error reply 	windows would 
error rdb 	disassociate child console 
save background 	create window 
reply status 	figure concatenate argv 
reply 	quoting args 
copyright salvatore 	process human readable 
sanfilippo antirez 	process want 
gmail dot 	present log error 
rights reserved 	messages handle 
redistribution use 	useful purpose 
source 	cannot close either 
binary forms 	possible turn 
without modification 	process process handle 
permitted provided 	process terminated 
following conditions 	keep handle list 
met redistributions 	waitpid full 
source 	path script file 
code must 	indicate tried 
retain copyright 	failed check git 
notice list 	command shell 
conditions following 	script compare environment 
disclaimer redistributions 	entries key 
binary 	stopping found complement 
form must 	insert position 
reproduce copyright 	name contains sets 
notice list 	variable otherwise 
conditions following 	unsets size includes 
disclaimer documentation 	terminating env 
materials 	must room 
provided distribution 	size entries insert 
neither name 	returns size 
redis names 	optionally frees removed 
contributors may 	entries optionally 
used endorse 	free removed replaced 
promote 	entry key 
products derived 	specified insert replace 
software without 	entry otherwise 
specific prior 	key existing entry 
written permission 	note isn 
software provided 	complete replacement getaddrinfo 
copyright 	assumes service 
holders contributors 	contains numerical port 
express implied 	simple search 
warranties including 	gethostbyname returns one 
limited implied 	host one 
warranties merchantability 	found note getaddrinfo 
fitness 	supposed allow 
particular purpose 	service looked 
disclaimed shall 	getservbyname currently implemented 
copyright owner 	gai strerror 
contributors liable 	function tcpip header 
direct indirect 	need load 
incidental 	one dynamically wsa 
special exemplary 	last error 
consequential damages 	values regular bsd 
including limited 	error codes 
procurement substitute 	biased wsabaseerr however 
goods services 	strerror know 
loss 	networking specific errors 
use data 	values beginning 
profits business 	therefore choose biased 
interruption however 	error code 
caused theory 	errno someone looks 
liability whether 	code somewhere 
contract 	least number usually 
strict liability 	listed convert 
tort including 	file descriptor 
negligence otherwise 	convert file descriptor 
arising way 	rename first 
use software 	errno right move 
even 	file cannot 
advised possibility 	overwrite existing files 
damage lzf 	todo translate 
compression library 	errors revert file 
load type 	attributes failure 
rdb format 	process source destination 
one 	file open 
integer function 	wrong moment retry 
used load 	order give 
types also 	process higher chance 
special types 	complete operation 
like end 	give time slice 
file 	retry sleep 
type expire 	bit note 
type forth 	doesn actual pagesize 
saves encoded 	allocation granularity 
length first 	future windows specific 
two bits 	git code 
first 	needs real getpagesize 
used hold 	function need 
encoding type 	find another solution 
see rdb 	timer works 
definitions information 	like ticktack trivial 
types encoding 	routine time 
save 	waits receive signal 
bit len 	terminate main 
save bit 	tells terminate setting 
len save 	timer signalled 
bit len 	state ticktack interrupts 
load encoded 	wait state 
length 	timer interval length 
isencoded argument 	call signal 
length actually 	handler tell 
length encoding 	terminate see msdn 
type see 	documentation referring 
rdb enc 	result codes unc 
definitions 	paths skip 
rdb information 	server name error 
read bit 	malformed unc 
encoding type 	path reserve space 
read bit 	ascii utf 
len read 	encoding utf encoding 
bit 	ffff utf 
len read 	convert udcxx surrogate 
bit len 	pair invalid 
encodes argument 	utf printable unicode 
integer fits 	convert invalid 
supported ranges 	utf non printable 
encoded 	unicode convert 
types function 	hex windows tmp 
successfully encodes 	temp convert 
integer representation 	dir separators 
stored buffer 	forward slashes help 
pointer enc 	shell commands 
length 	called git executable 
returned otherwise 	mistaking dir 
returned loads 	separators escape characters 
integer encoded 	simulate term 
specified encoding 	enable color see 
type enctype 	color disable 
returned 	msvcrt command line 
changes according 	wildcard expansion 
flags see 	getmainargs called mingw 
rdb generinc 	startup code 
load info 	see init mingw 
anti warning 	runtime wide 
objects 	arguments environment determine 
form without 	size argv 
space range 	environ conversion buffer 
values fit 	nedmalloc free 
bit encoded 	crt memory 
integers save 	allocate resizable environment 
space 	list note 
check possible 	xmalloc xmemdupz etc 
encode number 	call getenv 
number converted 	cannot use initializing 
back identical 	environment allocate 
possible encode 	buffer wchar encodes 
integer 	max utf 
data compressed 	bytes convert command 
save disk 	line arguments 
require least 	environment utf sort 
four bytes 	environment log 
compression worth 	getenv putenv fix 
load 	windows specific 
lzf compressed 	environment settings initialize 
rdb format 	critical section 
returned changes 	waitpid pinfo list 
according flags 	file mode 
info check 	file modes 
rdb 	stdin err initialize 
load function 	unicode console 
allocate target 	assuming variants mingw.h 
according uncompressed 	name gecos 
size load 	dir handler flags 
compressed representation 	interval sysname 
uncompress 	nodename release version 
target save 	machine path 
len data 	buf bufsiz oldpath 
disk representation 	newpath fildes 
integer save 	mode seconds name 
special form 	cmd signum 
integer 	oldset pid path 
encoding lzf 	mode pid 
compression bytes 	status options pid 
unable compress 	sig ssl 
even aaaaaaaaaaaaaaaaaa 	ssl ssl 
skip means 	filedes seconds timep 
data 	result timep 
compressed save 	result uid type 
old way 	sig oldpath 
store verbatim 	newpath buf pathname 
save either 	path filename 
encoded encode 	oflags stream filename 
like 	otype filename 
rdb save 	otype stream stream 
raw handle 	buf len 
encoded objects 	filename mode dirname 
avoid decode 	filename mode 
encode already 	pointer len name 
integer 	namevalue host 
encoded load 	namelen host res 
rdb file 	node service 
according flags 	hints res salen 
rdb load 	host hostlen 
none flags 	serv servlen 
load 	flags domain type 
rdb unencoded 	protocol sockfd 
rdb load 	sockfd sockfd lvl 
enc returned 	optname optval 
type redis 	optlen sockfd sockfd 
encode special 	backlog sockfd 
way 	rlim cur resource 
memory efficient 	rlp file 
flag passed 	name buf file 
function longer 	name buf 
guarantees obj 	buf file name 
ptr sds 	times cmd 
rdb 	argv env dir 
load plain 	fhin fhout 
plain allocated 	fherr cmd argv 
zmalloc instead 	cmd argv 
redis save 	sig handler sig 
doubles saved 	path path 
prefixed 	ret path 
bit integer 	path dir wcs 
specifying length 	utf wcslen 
representation bit 	utflen wcs utf 
integer special 	wcslen wcs 
values order 	utf result utf 
specify 	wcs utflen 
following conditions 	pinfo winerr commit 
number inf 	getpid getpid 
inf check 	ssl osfhandle ssl 
safe range 	rfd osfhandle 
casted assuming 	ssl wfd osfhandle 
bit 	ntohl dir 
also assuming 	sep xutftowcsn xutftowcsn 
implementations around 	min reports 
precision bit 	flockfile actually things 
assumptions test 	available header 
inside interval 	files symbolic link 
casting 	sanitize preprocessor 
safe two 	polluted windows 
castings make 	headers defining macros 
sure part 	collide git 
zero use 	local versions winuser 
integer printing 	trivial stubs 
function 	bash cannot reliably 
much faster 	detect negative 
information serialization 	codes failure simple 
check rdb 	adaptors implementations 
save save 	missing functions defined 
type avoid 	min libgcc 
warning 	replacements existing functions 
use rdb 	use mingw 
load type 	specific stat lstat 
load type 	fstat implementations 
rdb format 	windows use stat 
returns type 	bit size 
specifically 	ansi emulation 
valid type 	wrappers git specific 
save redis 	compatibility converts 
returns error 	utf encoded utf 
number bytes 	support repositories 
written success 	legacy encoded file 
save 	names invalid 
save list 	utf bytes xff 
save save 	converted corresponding 
sorted save 	printable unicode chars 
hash length 	invalid utf 
disk saved 	bytes would make 
rdb 	non printable 
save function 	unicode converted hex 
currently use 	code lead 
trick length 	bytes followed appropriate 
little changes 	number trail 
code future 	bytes encodings encodings 
could 	ffff detected 
faster solution 	invalid utf 
save key 	maximum space requirement 
pair expire 	target buffer 
time type 	two wide chars 
key error 	per utf 
returned 	strlen utf wchar 
success key 	maximum space 
actually saved 	needed entire input 
returned otherwise 	consists invalid 
returned key 	utf bytes range 
already expired 	per following 
save 	table utf utf 
expire time 	code point 
key already 	utf sequence bytes 
expired skip 	words ratio 
save type 	ffff ffff invalid 
key save 	invalid encoded 
aux 	utf surrogate pair 
field wrapper 	encoded two 
rdb save 	hex digits 
aux field 	note utf encoding 
used key 	scheme extended 
val length 	even indefinite sequences 
obtained 	largest valid 
strlen wrapper 	code point ffff 
strlen key 	encodes utf 
integer type 	bytes parameters wcs 
range save 	wide target 
aux fields 	buffer utf convert 
information 	wcslen size 
rdb generated 	target buffer wchar 
fields state 	utflen size 
rdb created 	convert terminated returns 
produces dump 	length converted 
database rdb 	wcslen wcs failure 
format 	errors einval 
sending specified 	one input parameters 
redis channel 	invalid erange 
success returned 	output buffer 
otherwise err 	small simplified variant 
returned part 	xutftowcsn assumes 
output 	input terminated simplified 
output missing 	file system 
errors function 	specific variant xutftowcsn 
returns err 	assumes output 
error integer 	buffer size max 
pointed error 	path wide 
errno 	chars input terminated 
error write 	fails enametoolong 
opcode write 	input converts utf 
resize opcode 	encoded utf 
trim size 	maximum space requirement 
max currently 	target buffer 
largest 	three utf chars 
type able 	per wide 
represent rdb 	wcslen wcs 
sizes however 	maximum space needed 
limit actual 	entire input 
size load 	consists utf words 
since 	range xffff 
sizes hints 	uffff modulo surrogate 
resize hash 	pairs per 
tables iterate 	following table utf 
writing every 	utf code 
entry release 	point utf sequence 
error 	words bytes 
eof opcode 	ratio ffff ffff 
crc checksum 	ffff dbff 
zero checksum 	dfff note invalid 
computation disabled 	code points 
loading code 	ffff cannot represented 
skips 	utf parameters 
check wrapper 	utf target buffer 
rdb save 	wcs wide 
rio additionally 	convert utflen 
adds prefix 	size target buffer 
suffix 	returns length 
generated rdb 	converted failure errors 
dump prefix 	einval one 
eof bytes 	input parameters invalid 
unguessable hex 	erange output 
suffix bytes 	buffer small critical 
hex 	section used 
announced prefix 	implementation spawn functions 
way processes 	mingw spawnv 
receiving payload 	waitpid intialised replacement 
understand ends 	main macro 
without processing 	replacement main adds 
content 	win specific 
write error 	initialization used pthread 
error already 	api implementation 
rdb save 	windows mkdir.c dir 
rio call 	mode retval 
save disk 	tmp dir 
err 	len strlen strdup 
error success 	mkdir free 
current working 	platforms deal trailing 
dir path 	mkdtemp.c mktemp 
error messages 	mkdir mktag.c sha 
make sure 	expected type 
data 	ret size buffer 
remain output 	repl buffer 
buffers use 	size typelen type 
rename make 	sha type 
sure file 	line tag line 
changed atomically 	tagger line 
generate 	len argc argv 
file child 	prefix buf 
parent per 	result sha read 
second unreached 	sha file 
load redis 	lookup replace type 
specified type 	check sha 
specified 	signature free 
file success 	error memcmp error 
newly allocated 	sha hex 
returned otherwise 	error memcmp error 
read read 	strchr error 
list load 	uintmax memcmp error 
every 	uintmax strlen 
single element 	error uintmax memcpy 
list read 	verify error 
list use 	sha hex error 
regular many 	uintmax memcmp 
entries faster 	error uintmax strstr 
expand 	strstr strpbrk 
dict right 	strpbrk error uintmax 
size asap 	error uintmax 
order avoid 	strspn error uintmax 
rehashing load 	error uintmax 
every single 	strspn atoi error 
element 	uintmax error 
list fetch 	uintmax usage 
integer element 	strbuf read die 
also called 	errno verify 
converted regular 	tag die write 
hash table 	sha file 
encoded 	die strbuf release 
read list 	sha hex 
load every 	signature file simple 
single element 	format four 
list care 	lines sha type 
integer encoded 	tag tagname 
added 	tagger committer followed 
skiplist convert 	blank line 
loading since 	free form tag 
sorted sets 	message signature 
stored ordered 	block git doesn 
many entries 	care verified 
use 	gpg similar 
hash table 	first four lines 
load every 	guaranteed least 
field ziplist 	bytes sha bytes 
load raw 	type tag 
pair ziplist 	bytes shortest possible 
convert 	type line 
hash table 	tag bytes shortest 
size threshold 	single character 
exceeded load 	tag line tagger 
remaining fields 	bytes shortest 
values hash 	possible tagger line 
table 	refuse tag 
load encoded 	something verify verify 
pair hash 	line verify 
table pairs 	type line verify 
read obj 	tag line 
type fix 	actual type verify 
encoding 	matches verify 
make sure 	tag name 
convert encoded 	allow control characters 
data type 	spaces verify 
type accordingly 	tagger line check 
current configuration 	correct form 
many 	name email followed 
elements encoded 	line angle 
data type 	brackets within name 
note check 	email address 
length max 	fields spaces within 
element size 	email address 
scan 	field check author 
eventually everything 	name least 
converted convert 	one character space 
ziplist encoded 	acceptable timestamp 
hash must 	digits followed space 
deprecated loading 	timezone digits 
dumps 	hhmm max verify 
created redis 	blank line 
gets deprecated 	separating header 
mark loading 	body actual stuff 
state setup 	afterwards care 
fields needed 	verify basic sanity 
provide 	needs start 
loading stats 	sha ntype ntagger 
load refresh 	mktree.c mode 
loading progress 	sha len name 
info loading 	alloc used 
finished track 	mode sha path 
loading 	ent len 
progress order 	sha buf size 
serve client 	ent mktree 
time time 	usage buf len 
needed calculate 	nul term 
rdb checksum 	line allow missing 
take 	ptr ntr 
non trivial 	mode path sha 
amount time 	prefix sha 
load update 	nul term 
cached time 	line allow missing 
since used 	batch mode 
create 	got eof getline 
update last 	option strlen 
interaction time 	strchr die flex 
clients important 	alloc mem 
things read 	hashcpy alloc grow 
type handle 	name compare 
special 	qsort strbuf init 
types expiretime 	strbuf addf 
load expire 	strbuf write sha 
associated next 	file strbuf 
key load 	release strtoul die 
note loading 	strchr sha 
expire 	hex die isgitlink 
need load 	unquote style 
actual type 	die strbuf 
read time 	detach type type 
need read 	die sha 
type expiretime 	info die sha 
opcode 	hex die 
specifies time 	sha hex append 
seconds convert 	parse options 
milliseconds expiretime 	getline die mktree 
milliseconds precision 	line write 
expire times 	puts sha hex 
introduced 	fflush strbuf 
rdb like 	release exit git 
expiretime precision 	stupid content 
read time 	tracker copyright junio 
need read 	hamano type 
type eof 	derived mode type 
end 	derived sha 
file exit 	read non recursive 
main loop 	output format 
selectdb specified 	mode type 
database read 	sha tab name 
type resizedb 	type perfectly 
hint 	normal commit submodule 
size keys 	beginning sha 
currently selected 	beginning name type 
data order 	redundantly derivable 
avoid useless 	three ways agree 
rehashing read 	check type 
type 	identified sha problem 
aux fields 	missing objects 
use state 	presumed right type 
rdb backward 	exists wrong 
compatible implementations 	type problem regardless 
rdb loading 	allow missing 
requierd 	entry never correct 
skip aux 	empty lines 
fields understand 	denote boundaries batch 
aux field 	mode execution 
composed two 	gets last 
key fields 	entry terminated line 
name 	line made 
staring considered 	optional consistent original 
information fields 	non batch 
logged startup 	behaviour mktree skip 
log level 	creating empty 
notice ignore 	reset entry buffer 
fields 	use batch 
understand aux 	mode mmap.c start 
field contract 	length prot 
read type 	flags offset count 
read key 	start length 
read check 	die xmalloc xpread 
key 	memset free 
already expired 	free msvc.c msvc.h 
function used 	size sisz 
loading rdb 	strlen strlen strnicmp 
file disk 	porting function 
either startup 	mv.c builtin 
rdb 	usage prefix pathspec 
received master 	count flags 
latter master 	result length copy 
responsible key 	path len 
expiry would 	slash file src 
expire keys 	first submodule 
snapshot 	gitfile submodule dotgit 
taken master 	src length 
may reflected 	first last src 
slave hash 	slash first 
table expire 	last len slash 
time needed 	path argc 
verify 	argv prefix gitmodules 
checksum rdb 	modified ignore 
version unexpected 	errors builtin options 
end file 	source destination 
handled fatal 	dest path 
exit avoid 	submodule gitfile src 
warning 	dst dst 
background saving 	pos alloc memcpy 
child bgsave 	strlen dir 
terminated work 	sep xmemdupz xstrdup 
handle function 	basename free 
covers actual 	pathspec strlen xmalloc 
bgsav 	memcpy isgitlink 
sigusr whitelisted 	die staging gitmodules 
way kill 	die strbuf 
child without 	addf read gitfile 
tirggering error 	xstrdup strbuf 
conditon possibly 	release slash cache 
slaves 	name pos 
waiting bgsave 	die strncmp free 
order served 	gitmodules config 
first stage 	git config parse 
sync bulk 	options usage 
transfer dump 	options hold 
rdb 	locked index read 
background saving 	cache die 
child bgsave 	copy pathspec xcalloc 
terminated work 	copy pathspec 
handle function 	xcalloc copy pathspec 
covers rdb 	lstat isdir 
salves 	lstat strncmp die 
socket transfers 	memmove memmove 
diskless replication 	memmove memmove rename 
child returns 	die errno 
exit code 	connect work git 
read slave 	dir update 
client 	path gitmodules cache 
associated status 	name pos 
code terminate 	strlen rename cache 
slaves error 	entry stage 
state process 	updated gitmodules write 
returned error 	locked index 
consider 	die git 
list slaves 	builtin command copyright 
emtpy special 	johannes schindelin 
normal code 	keep trailing slash 
path make 	needed git 
space count 	file dir error 
make 	special normalized 
space enough 	checking last first 
elements specified 	files overwrite 
first element 	check source destination 
replication process 	name-hash.c ent 
slaves correctly 	parent namelen name 
received 	name istate 
full payload 	name namelen key 
others terminated 	istate namelen 
search slave 	dir istate dir 
reply order 	istate dir 
slave replication 	parent istate istate 
process 	istate istate 
need find 	name len 
list must 	name len name 
error code 	namelen icase 
means success 	len istate name 
found slaves 	namelen dir 
list 	istate name start 
restore socket 	ptr ptr 
non blocking 	dir istate name 
background rdb 	namelen icase 
saving transfer 	istate strncasecmp hashmap 
terminates call 	entry init 
right 	memihash hashmap dir 
handler spawn 	sep find 
rdb child 	dir entry flex 
writes rdb 	alloc mem 
sockets slaves 	hashmap entry init 
currently slave 	memihash hashmap 
state 	hash dir entry 
wait bgsave 	hash dir 
start state 	entry namelen 
fork create 	hash dir entry 
pipe used 	namelen hashmap 
order send 	free hashmap entry 
back 	init memihash 
parent slaves 	namelen hashmap dir 
successfully received 	entry hashmap 
writes collect 	init hashmap init 
file descriptors 	hash index 
slaves want 	entry hash index 
transfer 	entry hashmap 
rdb wait 	dir entry toupper 
bgsave start 	toupper namelen 
state also 	memcmp slow name 
allocate corresponding 	lazy init 
client useful 	name hash find 
child 	dir entry 
process order 	lazy init 
build report 	name hash find 
sent via 	dir entry 
unix pipe 	memcpy lazy init 
sent parent 	name hash 
put 	hashmap hash memihash 
socket non 	name hashmap 
blocking mode 	next hashmap free 
simplify rdb 	hashmap free 
transfer restore 	name hash hashing 
children returns 	names index 
since 	state copyright linus 
duped socket 	torvalds directory 
share nonblock 	component hash quick 
attribute parent 	lookup git 
create child 	status directory components 
process child 	stored without 
returning 	closing slash despite 
least one 	submodules directory 
slave served 	never reach 
rdb file 	point stored index 
expected need 	state name 
send report 	hash ordinary cache 
parent 	entries length 
via pipe 	parent directory lookup 
format message 	existing entry 
len slave 	directory found create 
slave error 	hash table 
len slave 	recursively missing parent 
slave 	directories reference 
errors integers 	directory entry parents 
basically reply 	release reference 
composed bits 	directory entry parent 
len field 	directory name 
plus additional 	hash find exact 
bit 	entry pointer 
integers entry 	equality index file 
total len 	exists find 
entries represents 	entries matching 
slave client 	hash code decide 
master match 	whether entry 
report 	matches name always 
specific slave 	exact compare 
error replication 	even want ignoring 
process terminated 	comparison quick 
success error 	exact one first 
code error 	common name-rev.c 
occurred 	cutoff commit tip 
write message 	name generation 
parent good 	distance deref name 
slaves unable 	parents parent 
transfer message 	number len name 
parent exit 	path filter 
error 	subpath refname shorten 
parent abort 	unambiguous tags 
replication process 	name filter sha 
childre waiting 	refname alloc 
parent per 	sorted sha 
second undo 	refname shorten unambiguous 
state 	path oid 
change caller 	flags data data 
perform cleanup 	abbreviate output 
slaves bgsave 	deref commit table 
start state 	table found 
early call 	buffer len obj 
replication 	caller name 
setup slave 	always allow undefined 
full resync 	name name 
turned bgsave 	oid name rev 
end unreached 	usage data 
rdb.h rdb 	forty start sha 
type 	name len 
rdb rdb 	argc argv prefix 
rdb rdb 	revs peel 
len rdb 	tag data 
isencoded rdb 	opts sha commit 
rdb filename 	peeled buffer 
filename 	max obj parse 
childpid filename 	commit xstrfmt 
rdb type 	die xmalloc strip 
rdb exitcode 	suffix xstrfmt 
bysignal rdb 	xstrfmt name rev 
key val 	name rev 
expiretime 	wildmatch strchr shorten 
rdb copyright 	unambiguous starts 
salvatore sanfilippo 	starts name abbrev 
antirez gmail 	alloc grow 
dot rights 	hashcpy xstrdup hashcmp 
reserved redistribution 	parse starts 
use 	subpath matches tip 
source binary 	table parse 
forms without 	name abbrev name 
modification permitted 	rev xstrdup 
provided following 	qsort sha 
conditions met 	pos exact match 
redistributions 	strlen strcmp 
source code 	snprintf oid hex 
must retain 	rev name 
copyright notice 	find unique abbrev 
list conditions 	die oid 
following disclaimer 	hex ishex ishex 
redistributions 	sha lookup 
binary form 	rev name fwrite 
must reproduce 	git config 
copyright notice 	parse options error 
list conditions 	usage options 
following disclaimer 	sha parse deref 
documentation 	tag feof 
materials provided 	fgets name rev 
distribution neither 	line max 
name redis 	index indexed show 
names contributors 	name show 
may used 	name one 
endorse 	day many generations 
promote products 	maximally preferred 
derived software 	one merge traversal 
without specific 	match matched 
prior written 	fully matched subpath 
permission 	broken repository 
software provided 	returns buffer flush 
copyright holders 	hidden opt 
contributors express 	nedmalloc.c idx ret 
implied warranties 	nedalloc tls 
including limited 	last error alternative 
implied 	malloc implementation 
warranties merchantability 	multiple threads without 
fitness particular 	contention dlmalloc 
purpose disclaimed 	niall douglas boost 
shall copyright 	software license 
owner contributors 	version august permission 
liable 	hereby granted 
direct indirect 	free charge 
incidental special 	person organization obtaining 
exemplary consequential 	copy software 
damages including 	accompanying documentation covered 
limited procurement 	license software 
substitute 	use reproduce display 
goods services 	distribute execute 
loss use 	transmit software prepare 
data profits 	derivative works 
business interruption 	software permit third 
however caused 	parties software 
theory 	furnished subject following 
liability whether 	copyright notices 
contract strict 	software entire statement 
liability tort 	including license 
including negligence 	grant restriction following 
otherwise arising 	disclaimer must 
way 	included copies 
use software 	software whole part 
even advised 	derivative works 
possibility damage 	software unless copies 
tbd include 	derivative works 
necessary headers 	solely form machine 
current 	executable code 
rdb version 	generated source language 
format changes 	processor software 
way longer 	provided without warranty 
backward compatible 	kind express 
number gets 	implied including limited 
incremented 	warranties merchantability 
defines related 	fitness particular purpose 
dump file 	title non 
format store 	infringement shall copyright 
bits lengths 	holders anyone 
keys requires 	distributing software liable 
lot 	damages liability 
space check 	whether contract 
significant bits 	tort otherwise arising 
first interpreter 	connection software 
length two 	use dealings software 
msb len 	enable full 
bits 	aliasing msvc pragma 
len byes 	optimize define 
bits bits 	fullsanitychecks need enable 
next bit 	footers frees 
integer full 	right mspace dlmalloc 
bit len 	wants debug 
follow 	either disable checking 
means specially 	release builds 
encoded follow 	means spend much 
six bits 	time kernel 
number specify 	side define use 
kind follows 	spin locks 
see 	define disable checking 
rdb enc 	release builds 
defines lengths 	maximum concurrent 
stored single 	threads pool possible 
keys may 	maximum number 
values fit 	threadcaches allocated maximum 
inside 	size allocated 
length stored 	cache number cache 
disk first 	entries finer 
two bits 	grained bins topbitpos 
remaining two 	threadcachemax number 
bits specify 	cache entries topbitpos 
special 	threadcachemax point 
encoding accordingly 	free space cache 
following defines 	garbage collected 
bit integer 	enable testing valgrind 
bit integer 	causes misoperation 
bit integer 	enable testing valgrind 
compressed 	causes misoperation 
fastlz dup 	fails someone tried 
types rdb 	free block 
types reason 	twice keep 
readability dealing 	less bytes bit 
rdb types 	systems bytes 
memory 	bit systems last 
types note 	mspace entry 
adding rdb 	used much free 
type update 	space stored 
rdb type 	cache max entries 
types encoded 	use cache 
objects 	unset negative use 
note adding 	mspace directly 
rdb type 	otherwise cache mspace 
update rdb 	entries pool 
type test 	come oldest end 
type type 	list tcsanitycheck 
special 	tcbptr nedblksize tcsanitycheck 
rdb opcodes 	tcbptr list 
saved loaded 	exhausted disable calculate 
rdb save 	best fit 
type rdb 	bin size 
load type 	finer grained bin 
redis-benchmark.c 	fit match 
hostip hostport 	close move bin 
hostsocket numclients 	necessary bump 
liveclients requests 	bin nedblksize blk 
requests issued 	malloc blk 
requests finished 	size acquire mymspace 
keysize 	mutex removing 
datasize randomkeys 	cache entries older 
randomkeys keyspacelen 	age free 
keepalive pipeline 	cache release mymspace 
start totlatency 	mutex make 
latency title 	sure valid memory 
clients 	block calculate 
quiet csv 	best fit bin 
loop idlemode 	size finer 
dbnum dbnumstr 	grained bin 
tests auth 	fit dlmalloc round 
privdata mask 	round preserve 
ust 	indexing free mem 
mst next 	size threads 
privdata mask 	system pool allocate 
reply privdata 	system pool 
mask ptr 	screwed gets called 
nwritten cmd 	last used 
len 	mspace use strategy 
buf len 	run list 
curlat perc 	available mspaces looking 
reqpersec title 	unlocked one 
cmd len 	fail create one 
argc argv 	exceed threads 
lastarg 	ready modify lists 
exit status 	drat must 
loop client 	destroy really want 
data rps 	make sure 
name buf 	goes memory 
argc argv 	careful breaking aliasing 
data 	rules write 
cmd len 	twice created mspace 
title argv 	idx end 
gettimeofday gettimeofday 	last one used 
file file 	mspace last 
redis free 	used mspace returns 
sdsfree 	locked ready 
zfree zfree 	use mspace locked 
list search 	mymspace mutex 
key list 	disable use cache 
del node 	use mspace 
free client 	use cache use 
file 	mspace use 
file create 	cache reallocs always 
file random 	happen mspace 
free client 	happened skip locking 
stop reset 	preferred mspace 
client create 	frees always 
missing 	happen mspace happened 
clients free 	skip locking 
client unused 	preferred mspace use 
unused unused 	mspace implementation 
ustime redis 	purely libc version 
buffer read 	avoid crash 
exit 	due allocation free 
redis reply 	different heaps 
exit exit 	nedmalloc.h mem size 
free reply 	size mem 
sdsrange client 	size mem alignment 
done unused 	bytes parno 
unused 	pad elemsno elemsize 
unused free 	chunks elems 
client randomize 	sizes chunks capacity 
client key 	threads mem 
ustime sdslen 	size size mem 
write sdslen 	size mem 
strerror 	alignment bytes 
free client 	parno pad elemsno 
sdslen file 	elemsize chunks 
create file 	elems sizes chunks 
zmalloc redis 	nedalloc alternative 
connect non 	malloc implementation multiple 
block 	threads without 
redis connect 	contention dlmalloc niall 
unix non 	douglas boost 
block exit 	software license version 
sdsempty redis 	august permission 
format command 	hereby granted free 
sdscatlen 	charge person 
free sdscatprintf 	organization obtaining copy 
sdslen sdslen 	software accompanying 
sdscatlen sdslen 	documentation covered license 
sdscatlen zmalloc 	software use 
zmalloc strstr 	reproduce display 
zrealloc 	distribute execute transmit 
create file 	software prepare 
list node 	derivative works software 
tail create 	permit third 
client usleep 	parties software furnished 
qsort create 	subject following 
client 	copyright notices software 
create missing 	entire statement 
clients mstime 	including license grant 
main mstime 	restriction following 
show latency 	disclaimer must included 
report free 	copies software 
clients 	whole part derivative 
strcmp atoi 	works software 
strcmp atoi 	unless copies derivative 
strcmp atoi 	works solely 
strcmp strdup 	form machine executable 
strcmp atoi 	code generated 
strcmp 	source language 
strdup strcmp 	processor software provided 
strdup strcmp 	without warranty 
atoi strcmp 	kind express implied 
atoi strcmp 	including limited 
atoi strcmp 	warranties merchantability fitness 
strcmp 	particular purpose 
strcmp strcmp 	title non infringement 
strcmp sdsnew 	shall copyright 
sdscat sdscat 	holders anyone distributing 
sdstolower strcmp 	software liable 
atoi sdsfromlonglong 	damages liability whether 
strcmp 	contract tort 
exit unused 	otherwise arising connection 
unused unused 	software use 
exit fflush 	dealings software see 
mstime fflush 	malloc function 
strlen memcpy 	replace system allocator 
strstr 	causes nedalloc 
srandom time 	functions called 
signal signal 	malloc free etc 
create loop 	instead nedmalloc 
create time 	nedfree etc may 
list create 	may want 
parse 	ned prevents functions 
options zmalloc 	defined nedalloc 
create client 	uses instead extspec 
create missing 	defined dllexport 
clients main 	attribute visibility whatever 
sdsnew sdscatlen 	like defaults 
sdscatlen 	use locks want 
strlen redis 	define mlock 
format command 	initial acquire release 
argv benchmark 	locked initializer 
free zmalloc 	size functions gets 
memset test 	usable size 
selected 	allocated block note 
test selected 	always bigger 
benchmark test 	asked due 
selected test 	rounding etc pool 
selected redis 	functions creates 
format command 	memory pool use 
benchmark 	nedp functions 
free test 	capacity much allocate 
selected redis 	immediately know 
format command 	allocating lot memory 
benchmark free 	soon zero 
test selected 	threads specifies many 
redis 	threads normally 
format command 	accessing pool concurrently 
benchmark free 	setting zero 
test selected 	means demand careful 
redis format 	rapidly consume 
command benchmark 	system resources bursts 
free 	concurrent threads 
test selected 	use pool 
redis format 	destroys memory pool 
command benchmark 	previously created 
free test 	nedcreatepool sets associated 
selected redis 	pool retrieve 
format 	passing memory block 
command benchmark 	allocated pool 
free test 	gets previously nedpsetvalue 
selected redis 	zero memory 
format command 	unknown optionally also 
benchmark free 	retrieve pool 
test 	disables cache calling 
selected redis 	returning existing 
format command 	cache data central 
benchmark free 	pool notes-cache.c 
test selected 	validity sha commit 
redis format 	pretty ctx 
command 	msg ret name 
benchmark free 	validity flags 
test selected 	sha commit 
redis format 	sha key sha 
command benchmark 	outsize sha 
free test 	size key sha 
selected 	data size 
test selected 	sha read lookup 
test selected 	commit reference 
test selected 	gently memset format 
test selected 	commit message 
redis format 	strbuf trim strcmp 
command 	strbuf release 
benchmark free 	memset xstrdup strbuf 
test selected 	addf notes 
test selected 	cache match validity 
redis format 	init notes 
command benchmark 	strbuf release write 
free 	notes commit 
test selected 	strlen update note 
test selected 	read sha 
redis format 	file write 
command benchmark 	sha file note 
free test 	notes-cache.h validity 
selected 	name validity sha 
test selected 	outsize sha 
redis format 	data size notes 
command benchmark 	cache notes-merge.c 
free test 	obj local remote 
selected test 	path sha 
selected 	hex sha sha 
redis format 	list len 
command benchmark 	obj insert occupied 
free test 	last index 
selected redis 	cmp uninitialized remote 
format command 	num changes 
argv 	opt changes len 
benchmark free 	occupied obj 
redis benchmark 	changes len local 
utility copyright 	opt match 
salvatore sanfilippo 	obj obj 
antirez gmail 	buf size path 
dot 	ret obj 
rights reserved 	note size buf 
redistribution use 	result buf 
source binary 	local remote status 
forms without 	lref rref 
modification permitted 	reason changes num 
provided 	changes conflicts 
following conditions 	local remote changes 
met redistributions 	num changes 
source code 	conflicts local result 
must retain 	sha local 
copyright notice 	sha remote sha 
list 	local remote 
conditions following 	bases sha sha 
disclaimer redistributions 	result parents 
binary form 	commit result sha 
must reproduce 	dir path 
copyright notice 	buffer msg 
list 	baselen obj sha 
conditions following 	blob sha 
disclaimer documentation 	buf ret memset 
materials provided 	strbuf init 
distribution neither 	sha hex sha 
name redis 	sha sha 
names 	sha strcmp path 
contributors may 	sha hashcmp 
used endorse 	memmove memset trace 
promote products 	sha hex 
derived software 	sha hex diff 
without specific 	setup diff 
prior 	opt diff setup 
written permission 	done diff 
software provided 	sha diffcore std 
copyright holders 	xcalloc verify 
contributors express 	notes filepair 
implied warranties 	trace sha hex 
including 	sha hex 
limited implied 	find notes merge 
warranties merchantability 	pair pos 
fitness particular 	hashcmp sha sha 
purpose disclaimed 	hashcpy sha 
shall copyright 	sha hashcpy hashcpy 
owner 	hashcpy hashcpy 
contributors liable 	hashcpy trace sha 
direct indirect 	hex sha 
incidental special 	hex sha hex 
exemplary consequential 	diff flush 
damages including 	free pathspec trace 
limited 	sha hex 
procurement substitute 	sha hex diff 
goods services 	setup diff 
loss use 	opt diff setup 
data profits 	done diff 
business interruption 	sha diffcore 
however 	std verify notes 
caused theory 	filepair trace 
liability whether 	sha hex sha 
contract strict 	hex find 
liability tort 	notes merge pair 
including negligence 	pos trace 
otherwise 	sha hex sha 
arising way 	hex sha 
use software 	hex hashcmp sha 
even advised 	hashcmp hashclr 
possibility damage 	sha sha hashcmp 
use hiredis 	hashcpy hashcmp 
sds 	hashcmp hashcpy trace 
pointers rand 	sha hex 
inside command 	sha hex sha 
buf number 	hex diff 
pointers client 	flush free pathspec 
randptr number 	file exists 
unused 	git path 
pointers client 	empty dir git 
randptr bytes 	path die 
obuf already 	git path die 
written start 	git path 
time request 	safe create leading 
request 	directories git 
latency number 	path die errno 
pending requests 	git path 
replies consume 	file exists git 
non zero 	path die 
number pending 	git path git 
prefix 	pathdup sha 
commands commands 	hex safe create 
auth prefixed 	leading directories 
pipeline benchmark 	die errno file 
commands discarded 	exists die 
first send 	open die errno 
size 	write full 
bytes pending 	die errno 
prefix commands 	die close free 
prototypes implementation 	read sha 
calculate latency 	file die sha 
first read 	hex sha 
means 	hex die sha 
server already 	hex sha 
sent reply 	hex write buf 
need parse 	worktree free 
parsing overhead 	read mmblob read 
part latency 	mmblob read 
calculate 	mmblob merge sha 
prefix commands 	hex free 
auth discard 	free free die 
prefix commands 	write buf 
first response 	worktree free trace 
also 	sha hex 
need fix 	sha hex 
pointers need 	sha hex sha 
randomize initialize 	hex strbuf 
request nothing 	addstr strbuf addf 
written enforce 	sha hex 
upper 	sha hex check 
bound number 	notes merge 
requests really 	worktree sha sha 
initialize randomize 	sha hex 
keys start 	write note worktree 
time create 	sha sha 
benchmark 	sha hex write 
client configured 	note worktree 
send command 	sha sha sha 
passed cmd 	sha hex 
len bytes 	merge worktree trace 
command copied 	note merge 
times 	one change manual 
client output 	sha hex 
buffer reused 	sha hex 
send request 	note die sha 
server accordingly 	hex note 
configured pipeline 	die sha hex 
size 	note die 
also initial 	die trace trace 
command prepended 	sha hex 
order make 	sha hex sha 
sure right 	hex sha 
database selected 	hex hashcmp trace 
needed 	hashcmp trace 
initial discarded 	hashcmp hashcmp trace 
soon first 	note die 
reply received 	trace merge one 
create client 	change trace 
scratch pointer 	sha hex sha 
instead 	hex sha 
want create 	hex diff remote 
client another 	diff local 
client reference 	merge changes 
pointer points 	free strcmp hashclr 
client use 	trace read 
reference 	full die check 
following information 	refname format 
take client 	sha lookup commit 
command line 	reference die 
use offsets 	sha hex trace 
rand elements 	sha hex 
inside 	sha check refname 
command line 	format hashclr 
used arguments 	die lookup commit 
randomization even 	reference die 
cloning another 	sha hex trace 
client prefix 	sha hex 
commands 	die hashcpy hashcpy 
applied needed 	merge bases 
suppress hiredis 	sha hex sha 
cleanup unused 	hex oid 
buffers max 	hex oid 
speed build 	hex sha hex 
request 	hashcmp hashcpy 
buffer queue 	hashcmp hashcpy merge 
requests accordingly 	diffs commit 
pipeline size 	list insert commit 
simply clone 	list insert 
example client 	create notes commit 
buffer 	free commit 
prefix request 	list strbuf release 
buffer auth 	trace sha 
commands applicable 	hex commit buffer 
commands discarded 	strstr strbuf 
first response 	addstr git path 
client 	die opendir 
reused commands 	die errno strbuf 
used number 	addch readdir 
different zero 	dot dotdot 
selected prefix 	strlen sha hex 
request buffer 	strbuf addstr 
command 	stat die errno 
discarded first 	index path 
time replies 	die note die 
received client 	sha hex 
reused command 	sha hex strbuf 
used append 	setlen create 
request 	notes commit strlen 
find substrings 	unuse commit 
output buffer 	buffer sha hex 
need randomized 	strbuf release 
copy offsets 	closedir strbuf addstr 
adjust different 	git path 
prefix 	dir recursively strbuf 
length strlen 	release diff 
rand listen 	remote diff local 
backlog quite 	tend process 
limited systems 	merge pairs 
returns number 	order therefore cache 
consumed 	last returned 
options list 	index search sequentially 
tests run 	appropriate position 
form lrange 	found since inserts 
test comma 	happen diff 
order make 	remote mainly appends 
sure 	care inserting 
searching testname 	middle list expensive 
always match 	memmove obj 
test enabled 	belongs obj belongs 
user meant 	obj belongs 
provide option 	obj belongs cmp 
arg 	obj belongs 
starts dash 	obj belongs immediately 
done otherwise 	preceding index 
use remainder 	len found addition 
command arguments 	deletion pair 
running benchmark 	addition deletion 
every 	deletion either deletion 
named test 	part pair 
selected command 	pair local uninitialized 
line tests 	sha local 
selected passed 	uninitialized touch local 
user never 	uninitialized sha 
receive 	overwritten following addition 
reply wait 	addition either 
every run 	addition part pair 
benchmark command 	pair local 
remainder arguments 	uninitialized two sha 
run benchmark 	local uninitialized 
suite 	two sha local 
redis-check-aof.c error 	sha two 
epos buf 	sha modification modification 
prefix target 	one sha 
buf eptr 	shall match local 
target length 	shall uninitialized 
real 	local two 
target len 	sha must establish 
target argc 	notes merge 
pos multi 	worktree abort notes 
str argc 	merge worktree 
argv filename 	already exists notes 
fix 	merge worktree 
size pos 	already established ignore 
diff buf 	epipe conflicts 
strncmp error 	section commit message 
ftello fgets 	first time 
error strtol 	conflict checkout remote 
consume 	conflict checkout 
newline ftello 	local regular conflict 
fread error 	checkout result 
read malloc 	merge change successfully 
read bytes 	resolved stored 
consume newline 	notes change results 
read 	conflict stored 
ftello read 	notes instead 
argc read 	written notes merge 
strcasecmp error 	worktree conflict 
strcasecmp error 	markers nothing remote 
free free 	change nothing 
feof 	change local remote 
strlen error 	nothing local 
strlen exit 	change adopt remote 
strcmp exit 	change need 
exit fopen 	file level merge 
exit redis 	local remote 
fstat 	dereference local local 
fileno exit 	sha local 
exit process 	sha sha indicates 
fgets strncasecmp 	unborn dereference 
exit ftruncate 	remote remote sha 
fileno exit 	failed remote 
exit 	sha remote 
fclose copyright 	looks like unborn 
pieter noordhuis 	perform merge 
pcnoordhuis gmail 	empty notes result 
dot copyright 	remote commit 
salvatore sanfilippo 	result local commit 
antirez 	find merge 
gmail dot 	bases todo handle 
rights reserved 	multiple merge 
redistribution use 	bases already merged 
source binary 	result local 
forms without 	commit fast forward 
modification 	result remote 
permitted provided 	commit non trivial 
following conditions 	merge without 
met redistributions 	conflicts commit result 
source code 	lifo order 
must retain 	iterate files git 
copyright 	notes merge 
notice list 	worktree found 
conditions following 	notes write updated 
disclaimer redistributions 	notes commit 
binary form 	resulting reusing commit 
must reproduce 	message parents 
copyright 	commit store commit 
notice list 	sha result 
conditions following 	sha write file 
disclaimer documentation 	blob files 
materials provided 	within git notes 
distribution neither 	merge worktree 
name 	git notes merge 
redis names 	worktree directory 
contributors may 	since might current 
used endorse 	working directory 
promote products 	user notes-merge.h local 
derived software 	remote commit 
without 	msg verbosity local 
specific prior 	result sha 
written permission 	commit result 
software provided 	sha merge notes 
copyright holders 	remote local 
contributors express 	given notes local 
implied 	must notes 
warranties including 	referenced local notes 
limited implied 	level merge 
warranties merchantability 	performed commits given 
fitness particular 	two refs 
purpose disclaimed 	merged producing one 
shall 	following outcomes 
copyright owner 	merge trivially results 
contributors liable 	existing commit 
direct indirect 	fast forward already 
incidental special 	date local 
exemplary consequential 	untouched sha result 
damages 	written result 
including limited 	sha returned merge 
procurement substitute 	successfully completes 
goods services 	producing merge 
loss use 	commit local contains 
data profits 	updated notes 
business 	sha resulting commit 
interruption however 	written result 
caused theory 	sha returned merge 
liability whether 	results conflicts 
contract strict 	similar merge result 
liability tort 	merge result 
including 	minus unmerged entries 
negligence otherwise 	stored local 
arising way 	sha resulting commit 
use software 	amended conflicts 
even advised 	resolved written result 
possibility damage 	sha unmerged 
increase 	entries written git 
length also 	notes merge 
consume stop 	worktree directory 
loop finish 	conflict markers returned 
redis-check-rdb.c level 	local remote 
positions errors 	must given non 
types 	either although 
target num 	may refer non 
peek buf 	existing notes 
dump version 	notes interpreted empty 
offset type 	notes merge 
offset timelen 	trivially results points 
isencoded 	finalize conflict 
buf len 	resolution earlier notes 
type enctype 	merge given 
offset enc 	notes must notes 
val buf 	corresponding given 
slen clen 	commit result commit 
offset 	created previous 
isencoded len 	call notes merge 
buf store 	function resolved 
offset key 	notes git 
buf len 	notes merge worktree 
val store 	create notes 
offset 	merge commit sha 
val offset 	stored result 
key length 	sha abort conflict 
length offset 	resolution earlier 
indent width 	notes merge removes 
body head 	notes merge 
tail 	worktree git notes 
ops bytes 	merge worktree 
body bytes 	notes-utils.c parents msg 
offset body 	msg len 
body tmp 	result sha sha 
num valid 	parent sha 
bytes 	parent msg buf 
entry dump 	commit sha 
version offset 	parse notes merge 
crc crc 	strategy cmd 
rdbfilename size 	rewrite mode 
stat data 	env rewrite refs 
argv 	env obj 
argc memcpy 	obj ret msg 
read bytes 	write notes 
error memcmp 	die read lookup 
error strtol 	commit parse 
error read 	commit die commit 
bytes 	list insert 
rdb check 	commit die die 
type shift 	strbuf addstr 
error shift 	strbuf complete line 
error read 	create notes 
bytes rdb 	commit strbuf insert 
check 	update strbuf 
type read 	release strcasecmp strcasecmp 
bytes shift 	strcasecmp strcasecmp 
error read 	starts strcmp git 
bytes read 	config strcmp 
bytes read 	config error 
bytes 	nonbool parse combine 
ntohl read 	notes error 
bytes read 	strcmp starts list 
bytes read 	refs glob 
bytes shift 	warning xmalloc getenv 
error zmalloc 	getenv xcalloc 
sprintf 	parse combine notes 
load length 	error list 
load length 	refs colon sep 
zmalloc read 	git config 
bytes zfree 	list clear free 
zmalloc lzf 	free load 
decompress 	notes trees list 
zfree zfree 	clear free 
zfree load 	copy note commit 
length load 	notes free 
integer load 	notes free 
lzf shift 	free deduce parent 
error 	commit points 
zmalloc read 	nothing root orphan 
bytes zfree 	commit commit 
load shift 	unchanged prepare commit 
error zfree 	message reflog 
zfree read 	message commit message 
bytes 	starts index 
zmalloc read 	note refs prefix 
bytes zfree 	implied underlying 
sscanf load 	glob translators first 
shift error 	name environment 
zfree zfree 	variable second notes-utils.h 
process 	parents msg 
shift error 	msg len result 
load length 	sha msg 
shift error 	trees cmd enabled 
process shift 	combine refs 
error process 	refs env 
shift 	mode env parse 
error process 	notes merge 
shift error 	strategy cmd obj 
process shift 	obj msg 
error process 	create notes commit 
shift error 	given notes 
process 	properties created commit 
shift error 	result converting 
shift error 	write notes parents 
load type 	given parents 
load length 	commit referenced author 
shift error 	committer determined 
shift 	commit commit message 
error shift 	msg resulting 
error process 	commit sha stored 
time load 	result sha 
type load 	notes.c key sha 
pair shift 	val sha 
error 	next path 
peek type 	mode sha notes 
shift error 	display notes 
shift error 	refs display notes 
memset memset 	trees subtree 
memset memset 	node key sha 
strlen 	key sha 
server log 	parent index entry 
sprintf print 	parent stack 
centered sprintf 	entry type combine 
print centered 	notes node 
sprintf sprintf 	ret hex hex 
sprintf 	len sha 
strncpy strlen 	sha len len 
memset strlen 	val path 
sprintf print 	mode sha subtree 
centered server 	node sha 
log process 	prefix len buf 
header 	desc entry 
server log 	len path 
exit load 	len type non 
entry print 	note path 
valid print 	fanout sha fanout 
error stack 	path hex 
load 	sha fanout flags 
entry print 	data ret 
skipped zfree 	path path len 
print valid 	next buf 
shift error 	path tws full 
print error 	path buf 
stack 	mode path path 
crc shift 	len sha 
error server 	tws path tws 
log server 	ret tws 
log open 	path mode sha 
error fstat 	path len 
error 	ret root next 
error mmap 	non note 
error sprintf 	note path 
sprintf sprintf 	ret sha note 
sprintf sprintf 	sha note 
sprintf sprintf 	path data note 
sprintf 	path len 
process munmap 	mode next sha 
close exit 	sha note 
server log 	sha note path 
exit redis 	data cur 
check rdb 	sha sha buf 
copyright 	cur len 
pieter noordhuis 	len buf len 
pcnoordhuis gmail 	ret cur 
dot copyright 	sha sha cur 
salvatore sanfilippo 	sha sha 
antirez gmail 	list sha data 
dot 	len item 
rights reserved 	data buf 
redistribution use 	cur sha sha 
source binary 	sort uniq 
forms without 	list buf ret 
modification permitted 	refname oid 
provided 	flag refs list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code 	globs copy 
must retain 	load refs notes 
copyright notice 	notes combine 
list 	notes flags sha 
conditions following 	sha mode 
disclaimer redistributions 	root refs flags 
binary form 	item counter 
must reproduce 	trees opt display 
copyright notice 	env load 
list 	config refs item 
conditions following 	sha note 
disclaimer documentation 	sha combine 
materials provided 	notes sha sha 
distribution neither 	found flags 
name redis 	data result root 
names 	data ret 
contributors may 	flags sha output 
used endorse 	encoding raw 
promote products 	utf sha msg 
derived software 	msg linelen 
without 	msglen reencoded sha 
specific prior 	output encoding 
written permission 	raw obj obj 
software provided 	force combine 
copyright holders 	notes note existing 
contributors express 	note ptr 
implied 	type clr ptr 
warranties including 	type subtree 
limited implied 	sha prefixcmp load 
warranties merchantability 	subtree free 
fitness particular 	note search 
purpose disclaimed 	nibble ptr type 
shall 	clr ptr 
copyright owner 	type note search 
contributors liable 	clr ptr 
direct indirect 	type subtree sha 
incidental special 	prefixcmp load 
exemplary consequential 	subtree free note 
damages 	search note 
including limited 	search ptr type 
procurement substitute 	clr ptr 
goods services 	type hashcmp clr 
loss use 	ptr type 
data profits 	ptr type free 
business 	note search 
interruption however 	ptr type ptr 
caused theory 	type clr 
liability whether 	ptr type hashcmp 
contract strict 	hashcpy free 
liability tort 	ptr type 
including 	nibble clr ptr 
negligence otherwise 	type note 
arising way 	consolidate nibble note 
use software 	search ptr 
even advised 	type clr ptr 
possibility damage 	type ptr 
data 	type sha free 
type hold 	ptr type 
offset file 	hashcmp hashcmp combine 
size hold 	notes sha 
stack errors 	note free subtree 
data type 	sha prefixcmp 
hold 	load subtree free 
opcode optional 	subtree sha 
key name 	prefixcmp load subtree 
success status 	free note 
store types 	insert ptr 
output valid 	type ptr type 
type 	sha free 
type added 	xcalloc note insert 
update following 	ptr type 
condition necessary 	ptr type note 
number bytes 	insert ptr 
read negative 	type note free 
peek 	clr ptr 
expect first 	type free clr 
bytes equal 	ptr type 
redis needs 	hexval hexval strcmp 
qualify type 	xmalloc hashcpy 
failure discard 	non note cmp 
time 	non note 
consume bytes 	cmp non note 
failure read 	cmp non 
bit len 	note cmp strcmp 
read bit 	hashcpy free 
len encoding 	fill descriptor 
type 	die sha hex 
read bit 	memcpy entry 
len read 	strlen sha hex 
bit len 	segment xcalloc 
convert val 	hashcpy hashcpy isdir 
returns processable 	note insert 
valid 	die sha hex 
unknown encoding 	sha hex 
read key 	strbuf addch strbuf 
first done 	addch strbuf 
success reset 	addch strbuf addstr 
error container 	non note 
optionally 	strbuf detach free 
consume expire 	ptr type 
entries followed 	sha hex xsnprintf 
valid type 	determine fanout 
entry selectdb 	ptr type note 
expire eof 	helper clr 
display 	ptr type 
truncation last 	clr ptr type 
chars display 	construct path 
unprintable characters 	fanout load subtree 
display error 	free clr 
stack exclude 	ptr type construct 
checksum 	path fanout 
rdb end 	strbuf addf strbuf 
search next 	xmalloc strbuf 
valid entry 	init write stack 
find consecutive 	finish subtree 
valid entries 	write sha file 
check 	strbuf release 
found consecutive 	free write entry 
valid entries 	strlen matches 
print many 	write stack write 
bytes skipped 	stack finish 
find valid 	subtree write stack 
opcode 	init subtree 
advance position 	memchr write 
another potential 	entry strcmp write 
error print 	note helper 
many valid 	strlen write non 
ops processed 	note write 
expect 	note helper sha 
eof last 	file xmalloc 
eof error 	sha read sha 
eof error 	file free 
reset type 	sha read sha 
verify checksum 	file free 
print 	free hashcpy xmalloc 
summary errors 	memcpy memcpy 
initialize vars 	free free write 
types types 	sha file 
used dumping 	free hashcpy sha 
disk rdb 	read sha 
check 	file free 
main called 	list split free 
form redis 	strbuf addstr 
redis executed 	strbuf addch list 
redis check 	note lines 
rdb redis-cli.c 	list note lines 
spectrum 	list empty 
palette color 	items list sort 
size spectrum 	list duplicates 
palette color 	list write sha 
spectrum palette 	file strbuf 
mono size 	release list clear 
spectrum 	unsorted list 
palette mono 	list append glob 
spectrum palette 	specials glob 
spectrum palette 	sha warning unsorted 
size context 	list list 
hostip hostport 	append xstrdup list 
hostsocket 	split place 
repeat interval 	list empty 
dbnum interactive 	items list refs 
shutdown monitor 	glob list 
mode pubsub 	clear free strcmp 
mode latency 	config error 
mode 	nonbool list refs 
latency dist 	glob getenv 
mode latency 	notes xcalloc xstrdup 
history lru 	sha treeish 
test mode 	read die entry 
lru test 	die sha 
sample 	hex hashclr hashcpy 
size cluster 	load subtree 
mode cluster 	alloc xcalloc init 
reissue command 	notes list 
slave mode 	append notes getenv 
pipe mode 	list refs 
pipe 	colon sep git 
timeout getrdb 	config list 
mode stat 	refs glob 
mode scan 	load notes trees 
mode intrinsic 	list clear 
latency mode 	xmalloc hashcpy hashcpy 
intrinsic 	note insert 
latency duration 	hashcpy hashclr note 
pattern rdb 	sha note 
filename bigkeys 	find note helper 
stdinarg auth 	strbuf init 
output delim 	note write non 
prompt 	note write 
eval eval 	stack finish subtree 
ldb eval 	write sha 
ldb sync 	file strbuf release 
eval ldb 	note sha 
end enable 	hex note note 
ldb 	free free 
eval last 	free free free 
cmd type 	memset init 
force cancel 	notes note 
loop ust 	read sha file 
len path 	free encoding 
history 	utf reencode free 
path home 	strlen strcmp 
help entries 	strbuf addstr starts 
help entries 	starts strbuf 
len version 	addf strchrnul strbuf 
commandslen groupslen 	addstr strbuf 
len 	strbuf addch free 
pos tmp 	format note 
help version 	note note note 
argc argv 	note starts 
len entry 	starts strbuf insert 
help buf 	strbuf insert 
startpos 	sha expand notes 
mask matchlen 	use non 
tmp reply 	balancing simple structure 
reply result 	node nodes 
force prefix 	leaf node 
idxlen prefixlen 	leaf nodes node 
prefixfmt 	pointers children 
prefix tmp 	bottom bits pointer 
len color 	used identify 
bold ccode 	pointer type ptr 
len color 	pointer ptr 
tmp tmp 	ptr pointer next 
output 	node cast 
raw reply 	node ptr pointer 
reply output 	note entry 
slot argc 	cast leaf node 
argv repeat 	ptr pointer 
command argvlen 	subtree entry cast 
output 	leaf node 
raw fmt 	root node statically 
reply tries 	allocated node 
argc argv 	leaf nodes 
lastarg seconds 	come two variants 
version buf 	note entries 
arg 	subtree entries distinguished 
nread version 	leaf node 
count args 	pointer see note 
sds argc 	entry key 
argv repeat 	sha referenced sha 
argc argv 	note subtree 
line 	entry key prefix 
argc argv 	sha trailing 
len elen 	referenced last key 
historyfile history 	store length 
line argc 	prefix sha containing 
argv elapsed 	notes subtree 
repeat 	notes may contain 
skipargs argc 	entries notes 
argv retval 	follow naming conventions 
argc argv 	notes typically 
script buf 	none still 
nread argv 	need keep track 
got 	keep simple 
comma keys 	linked list sorted 
retval reply 	alpha betically 
eval ldb 	non note path 
reply start 	list populated 
latency count 	parsing objects load 
history 	subtree non 
interval avg 	notes correctly written 
history start 	back objects 
max count 	produced write notes 
character samples 	grounded last 
tot coloridx 	next search appropriate 
color 	location given 
reply start 	key found start 
latency count 	root node 
history interval 	current level matching 
history start 	subtree entry 
outputs samples 	unpack subtree 
buf 	entry restart search 
nread payload 	current level 
buf original 	use nth nibble 
output nread 	key index 
payload buf 	node recurse node 
nread nwritten 	increment matching 
obuf 	subtree entry unpack 
pos ibuf 	subtree entry 
obuf aneterr 	restart search current 
reader reply 	level otherwise 
eof done 	found one following 
magic last 	subtree entry 
read 	match key note 
time mask 	entry may 
nread loop 	may match key 
nwritten nwritten 	unused leaf 
nread echo 	node pointer location 
reply reply 	unpack resume 
size 	search unpack 
key type 	resume search fall 
keys types 	find leaf 
reply keys 	node search location 
types sizes 	appropriate given 
reply sizecmds 	key note entry 
totalsize 	matching key 
total keys 	note entry consolidate 
maxkeys typeunit 	node non 
reply keys 	entries give non 
type types 	zero otherwise 
pct info 	replace node given 
field 	index given 
result info 	parent node entry 
field reply 	entry entries 
aux requests 	given one entry 
buf reply 	replace parent 
cur min 	index leaf 
max 	node search location 
alpha buf 	appropriate given 
buflen reply 	leaf node key 
key start 	location hold 
cycle misses 	matching entry abort 
output test 	nothing copy 
end 	matching entry given 
run time 	entry replace 
runs start 	matching leaf node 
end latency 	entry free 
avg avg 	leaf node consolidate 
argc argv 	nodes repeatedly 
firstarg 	walking towards root 
gettimeofday ustime 	type bits 
snprintf anet 	type mismatch nothing 
format addr 	key mismatch 
snprintf snprintf 	nothing found matching 
getenv strcmp 	entry consolidate 
sdscatprintf 	level parent 
sdsempty getenv 	levels possible cannot 
sdscatprintf sdsempty 	consolidate top 
sdscatprintf sdsempty 	level first build 
strtoll redis 	stack ancestors 
git sha 	root current node 
sdscatprintf 	next unwind 
redis git 	stack note consolidate 
sha strtoll 	done insert 
redis git 	leaf node search 
dirty sdscatprintf 	location appropriate 
sdscat malloc 	given leaf node 
malloc 	key location 
sdscatprintf sdsempty 	unused store tweaked 
sdssplitargs sdsnew 	pointer directly 
cli version 	location holds note 
sdsfree cli 	entry matches 
output help 	note inserted combine 
strcasecmp 	two notes 
strcasecmp cli 	calling given 
output command 	combine notes function 
help cli 	location holds 
output command 	note entry matches 
help strncasecmp 	subtree inserted 
isspace 	unpack subtree inserted 
strlen strncasecmp 	location location 
sdsnewlen sdscat 	holds matching subtree 
linenoise completion 	entry unpack 
sdsfree redis 	subtree location restart 
command free 	insert operation 
reply 	level create node 
redis command 	holding node 
free reply 	location node inserted 
redis free 	store node 
redis connect 	location type bits 
redis connect 	skip concatenation 
unix 	entry unpack entry 
redis free 	unpack restart 
anet keep 	insert non 
alive cli 	matching leaf node 
auth cli 	skip insertion 
sdsempty sdscatprintf 	empty note free 
sdscat 	entire notes 
sdscat sdscatprintf 	data contained given 
sdscatrepr sdscat 	fall convert 
sdscat sdscat 	sha hex corresponding 
memset sdscat 	sha hex 
sdsnew snprintf 	sha segment ascii 
sdscatprintf 	hex format 
cli format 	hex len length 
reply tty 	segment must 
sdscatlen sdslen 	multiple sha sha 
sdsfree sdsfree 	written sha 
exit getenv 	len max bytes 
strstr 	store sha 
color term 	must hex 
sdscatlen strstr 	len returns error 
strstr strstr 	invalid arguments 
strstr strstr 	invalid sha hex 
strstr strstr 	format otherwise 
strstr 	returns number bytes 
strstr sdscatfmt 	written sha 
sdscatlen sdscat 	hex len pads 
strstr strstr 	sha sha 
strstr strstr 	len included returned 
strstr strstr 	length note 
strstr 	takes ownership path 
isdigit sdscatcolor 	nothing sorts 
sdsempty sdscatlen 	first non note 
sdscatlen strstr 	sorts equal 
cli refresh 	overwrite sorts next 
prompt sds 	entry path 
cat 	sha sha complete 
colorized ldb 	len note 
reply sdscatlen 	sha incomplete 
sdscatprintf sdscat 	len current component 
cli format 	consists hex 
reply raw 	chars note subtree 
sdscatlen 	subtree determine 
sdslen sdsfree 	full path non 
exit sdsempty 	note entry 
sdscat sdscatrepr 	filename already found 
strlen sdscatrepr 	entry path 
sdscatprintf sdscatrepr 	directory part path 
sdscat 	must deduced 
cli format 	subtree containing entry 
reply csv 	overall notes 
sdscatlen sdslen 	follows strict progressive 
sdscat sdsfree 	fanout structure 
exit redis 	etc fanouts fanout 
reply 	means non 
redis free 	note found path 
cli print 	dead beef 
context error 	following code 
exit strncmp 	found beef hand 
strcmp strchr 	use non 
strchr 	obvious non note 
atoi strchr 	paths middle 
sdsfree sdsnew 	notes deserve coming 
atoi cli 	note non 
refresh prompt 	notes sha like 
cli format 	top level 
reply 	problems conclude strongly 
raw cli 	advised make 
format reply 	sure non notes 
raw sdscat 	least one 
cli format 	non hex character 
reply tty 	top level 
cli 	path component determine 
format reply 	optimal disk 
csv sdscat 	fanout part notes 
fwrite sdslen 	given sub 
sdsfree free 	level structure 
reply strcasecmp 	determine whether given 
strcasecmp 	existing fanout 
cli output 	expanded sub values 
help strcasecmp 	fanout variable 
strcasecmp strcasecmp 	fanout notes stored 
strcasecmp strcasecmp 	directly root 
strcasecmp strcasecmp 	notes fanout fanout 
strcasecmp 	fanout etc 
strcasecmp strcasecmp 	following simple heuristic 
strcasecmp strcasecmp 	works well 
strcasecmp strcasecmp 	practice even numbered 
strcasecmp strcasecmp 	level remember 
strcasecmp 	disk fanout level 
strcasecmp strcasecmp 	corresponds two 
strcasecmp strcasecmp 	levels peek entries 
strcasecmp strcasecmp 	level either 
strcasecmp malloc 	nodes subtree entries 
sdslen redis 	likely plenty 
append 	notes level 
command argv 	incremented fanout hex 
cli read 	sha nul 
reply exit 	recurse node subtree 
fflush cli 	entries note 
read reply 	represent parts note 
exit 	yet explored 
slave mode 	direct relationship subtree 
free cli 	entries level 
read reply 	fanout variable subtree 
free strcasecmp 	entries level 
atoi cli 	fanout preserved since 
refresh 	correspond exactly 
prompt strcasecmp 	fanout directory disk 
cli usleep 	structure however 
fflush free 	subtree entries level 
fflush redis 	fanout preserved 
free redis 	rather consolidated 
connect 	notes level achieve 
usleep start 	unconditionally unpacking 
redisv command 	subtree entries exist 
end exit 	threshold level 
strcmp sdsfree 	fanout invoke callback 
sdsnew strcmp 	subtree create 
usage 	trailing slash needed 
strcmp usage 	unpack subtree 
strcmp strcmp 	resume traversal path 
atoi strcmp 	subtree next 
strcmp strtoll 	entries per determine 
strcmp atof 	common part 
strcmp 	write stack tws 
atoi strcmp 	point last 
strcmp strcmp 	matching write stack 
strcmp strcmp 	entry start 
strcmp strcmp 	subtrees needed satisfy 
strcmp strcmp 	path directory 
strtoll 	components given 
strcmp strcmp 	path given entry 
strcmp strcmp 	current nothing 
strcmp atoi 	prefer note non 
strcmp strcmp 	note subtree 
strcmp atoi 	entry weave non 
strcmp 	note entries 
strcmp strcmp 	note entries nothing 
strcmp strcmp 	note failed 
strcmp sdsfree 	find prune note 
sdsnew strcmp 	read note 
strcmp cli 	blob objects separate 
version 	notes two 
sdsfree exit 	newlines anyway concatenate 
exit exit 	cur msg 
sdsempty read 	msg buf create 
fileno perror 	blob buf 
exit sdscatlen 	lines named list 
cli 	trailing newlines 
version sdsfree 	removed read 
exit zmalloc 	sha file nul 
sdsnew cli 	terminates last 
send command 	line file eol 
cli connect 	terminated empty 
cli 	list removed later 
send command 	along empty 
cli print 	came empty lines 
context error 	within file 
cli connect 	read note blob 
issue command 	objects unique 
repeat 	lines create blob 
strstr strstr 	sort uniq 
sds malloc 	list list argument 
strlen sdsnewlen 	must strdup 
sdsnewlen sdssplitargs 	core notes config 
linenoise multi 	note removed 
line 	prepare traversal current 
linenoise completion 	notes last 
callback isatty 	forward entry 
fileno history 	list grounded entries 
path linenoise 	write objects 
history load 	representing current notes 
cli 	fill given 
refresh prompt 	strbuf notes associated 
linenoise cli 	given given 
split args 	notes structure initialized 
linenoise history 	initialized see 
linenoise history 	documentation init notes 
save 	given notes 
free strcasecmp 	notes used instead 
strcasecmp exit 	raw gives 
strcasecmp strcasecmp 	userformat otherwise note 
sdsfree sdsnew 	message given 
atoi cli 	human consumption end 
refresh 	annotation newline 
prompt cli 	anyway happy 
connect strcasecmp 	fallback expand notes 
linenoise clear 	builtin git 
screen mstime 	notes copyright johan 
atoi issue 	herland johan 
command 	herland net git 
repeat cli 	notes johannes 
read reply 	schindelin builtin tag 
mstime sdsfreesplitres 	kristian gsberg 
free exit 	carlos rica invoke 
zrealloc read 	git show 
arg 	stat notes write 
stdin issue 	message editing 
command issue 	redirect edit subcommand 
command sdsfree 	end none 
sdsempty fopen 	given original args 
strerror exit 	therefore still 
fread 	argv append buf 
sdscatlen fclose 	previous note 
redis command 	contents git 
free reply 	notes merge git 
zmalloc sdsnew 	notes merge 
sdsnew sdscatprintf 	call notes merge 
sdsempty 	abort git 
issue command 	notes merge worktree 
cli read 	read merge 
reply strncpy 	result git notes 
repl cli 	merge target 
connect mstime 	notes git notes 
exit 	merge reuse 
mstime reconnecting 	existing commit message 
redis command 	reflog message 
exit mstime 	skip notes merge 
free reply 	resulted trivially 
fflush mstime 	result sha update 
mstime 	notes commit 
mstime usleep 	merge unresolved conflicts 
ceil tot 	update git 
fflush ustime 	notes merge 
exit ustime 	merge result store 
reconnecting redis 	updated git 
command 	notes merge non 
exit ustime 	zero conflicts 
free reply 	git notes usage 
ustime show 	git notes 
latency dist 	list usage git 
legend show 	notes usage 
latency 	git notes copy 
dist samples 	usage git 
ustime usleep 	notes append usage 
write exit 	git notes 
read exit 	edit usage git 
exit strtoull 	notes show 
send 	usage git notes 
sync read 	merge usage 
exit cli 	git notes usage 
read reply 	git notes 
send sync 	prune usage 
strcmp open 	git notes usage 
strerror 	note given 
exit read 	use editor edit 
exit write 	path buf 
strerror exit 	sha note sha 
close fsync 	note path 
exit redis 	data sha size 
reader 	buf show 
create time 	args show buf 
srand time 	cbuf old 
anet non 	note buf sha 
block exit 	opt arg 
wait read 	unset opt arg 
strerror 	unset opt 
exit redis 	arg unset buf 
reader feed 	len opt 
time redis 	arg unset 
reader reply 	force rewrite cmd 
exit memcmp 	buf ret 
free 	msg obj obj 
reply write 	split err 
strerror exit 	subcommand flags argc 
read rand 	argv prefix 
memcpy memcpy 	note retval options 
strerror exit 	argc argv 
time 	prefix argc argv 
redis reader 	prefix allow 
free exit 	empty note note 
exit redis 	options argc 
command exit 	argv prefix stdin 
exit exit 	note note 
exit 	obj rewrite cmd 
strtoull redis 	options argc 
command exit 	argv prefix allow 
free reply 	empty note 
strcmp strcmp 	note logmsg 
strcmp strcmp 	usage options edit 
strcmp 	size prev 
strcmp exit 	buf argc argv 
redis append 	prefix note 
command redis 	retval options show 
reply exit 	args ret 
exit type 	msg sha parent 
free 	sha pretty 
reply redis 	ctx local free 
append command 	ret git 
redis reply 	config notes strategy 
exit free 	argc argv 
reply size 	prefix msg result 
sdsempty 	sha abort 
exit send 	result strategy options 
scan zrealloc 	merge key 
zrealloc exit 	existing name flag 
key types 	status sha 
key sizes 	argc argv 
sdscpy 	prefix flag stdin 
exit usleep 	options retval 
free reply 	argc argv prefix 
zfree zfree 	verbose options 
sdslen sdsfree 	argc argv prefix 
exit strstr 	options argc 
strlen 	argv prefix result 
strchr strchr 	notes options 
malloc memcpy 	unlink warn free 
info field 	strbuf release 
strtol free 	sha hex sha 
sprintf sprintf 	hex read 
sprintf 	sha file write 
sprintf reconnecting 	die free 
redis command 	start command die 
exit sprintf 	sha hex 
info field 	strbuf read die 
sprintf info 	errno strbuf 
field 	commented lines 
bytes human 	write die strbuf 
info field 	release strbuf 
sprintf info 	release finish command 
field sprintf 	die sha 
info field 	hex git pathdup 
sprintf 	open die 
info field 	errno write die 
sprintf info 	copy obj 
field info 	strbuf addch strbuf 
field info 	commented lines 
field free 	strlen strbuf addch 
reply 	write die 
usleep redis 	write commented close 
command redis 	strbuf release 
command exit 	strbuf reset launch 
exit strtoull 	editor die 
free reply 	strbuf stripspace write 
exit 	sha file 
rand pow 	error error 
pow pow 	exit strbuf grow 
pow snprintf 	strlen strbuf 
power law 	addch strbuf addstr 
rand srand 	strbuf stripspace 
time 	strbuf addch strcmp 
getpid mstime 	strbuf read 
mstime lru 	die errno strbuf 
test gen 	read file 
key redis 	die errno strbuf 
append command 	stripspace strbuf 
redis 	addch sha die 
reply lru 	read sha 
test gen 	file free die 
key redis 	free die 
append command 	strbuf free parse 
redis reply 	reuse arg 
exit 	init copy 
exit unused 	notes rewrite init 
ustime signal 	notes strbuf 
ustime compute 	getline strbuf split 
something fast 	die strbuf 
ustime exit 	rtrim strbuf rtrim 
sdsnew 	sha die 
isatty fileno 	sha die copy 
getenv sdsnew 	note rewrite 
cli init 	copy note error 
help parse 	strbuf list 
options cli 	free commit notes 
connect 	free notes 
exit latency 	finish copy notes 
mode cli 	rewrite init 
connect exit 	notes starts die 
latency dist 	parse options 
mode cli 	error usage options 
connect 	init notes 
exit slave 	check sha 
mode cli 	die note puts 
connect exit 	sha hex 
rdb cli 	error sha hex 
connect exit 	note free 
pipe 	notes parse options 
mode cli 	error usage 
connect exit 	options sha die 
find big 	init notes 
keys cli 	check note free 
connect exit 	notes free 
stat 	note data error 
mode cli 	sha hex 
connect exit 	append edit sha 
scan mode 	hex prepare 
cli connect 	note data write 
exit lru 	note data 
test 	note die commit 
mode intrinsic 	notes sha 
latency mode 	hex note 
signal cli 	commit notes free 
connect repl 	note data 
cli connect 	free notes parse 
exit 	options error 
eval mode 	usage options notes 
noninteractive convert 	copy stdin 
sds redis 	error usage options 
cli command 	error usage 
line copyright 	options sha die 
salvatore 	sha die 
sanfilippo antirez 	init notes check 
gmail dot 	note error 
rights reserved 	sha hex sha 
redistribution use 	hex note 
source binary 	error sha hex 
forms 	note die 
without modification 	commit notes free 
permitted provided 	notes strcmp 
following conditions 	parse options 
met redistributions 	error usage options 
source code 	sha die 
must 	init notes check 
retain copyright 	note prepare 
notice list 	note data read 
conditions following 	sha file 
disclaimer redistributions 	strbuf grow strbuf 
binary form 	insert strbuf 
must 	insert free write 
reproduce copyright 	note data 
notice list 	note die snprintf 
conditions following 	sha hex 
disclaimer documentation 	note snprintf commit 
materials provided 	notes free 
distribution 	note data free 
neither name 	notes parse 
redis names 	options error 
contributors may 	usage options sha 
used endorse 	die init 
promote products 	notes check note 
derived 	error sha 
software without 	hex execv git 
specific prior 	cmd free 
written permission 	notes error error 
software provided 	notes merge 
copyright holders 	abort error sha 
contributors 	die lookup 
express implied 	commit reference die 
warranties including 	parse commit 
limited implied 	die hashcpy hashclr 
warranties merchantability 	xcalloc init 
fitness particular 	notes resolve refdup 
purpose 	die notes 
disclaimed shall 	merge commit die 
copyright owner 	memset format 
contributors liable 	commit message 
direct indirect 	strbuf trim strbuf 
incidental special 	insert update 
exemplary 	sha free notes 
consequential damages 	strbuf release 
including limited 	merge abort free 
procurement substitute 	parse options 
goods services 	error usage options 
loss use 	error usage 
data 	options error usage 
profits business 	options init 
interruption however 	notes merge options 
caused theory 	merge abort 
liability whether 	merge commit notes 
contract strict 	strbuf addstr 
liability 	expand loose notes 
tort including 	init notes 
negligence otherwise 	check parse notes 
arising way 	merge strategy 
use software 	error usage 
even advised 	options skip prefix 
possibility 	die strbuf 
damage use 	addf git config 
sds hiredis 	notes strategy 
one sds 	git config notes 
functions present 	strategy strbuf 
binary seconds 	release strbuf addf 
seconds 	notes strbuf 
latency dist 	notes merge update 
palettes actual 	notes update 
palette use 	find shared symref 
last arg 	notes die 
stdin option 	notes create symref 
output 	notes die 
mode see 	notes git path 
output defines 	free notes 
ask synchronous 	strbuf release strbuf 
mode lua 	release sha 
debugger lua 	error note 
debugging 	parse options init 
session ended 	notes check 
handle manual 	one note one 
script debug 	note strbuf 
eval commands 	getwholeline strbuf rtrim 
utility functions 	one note 
dbnum 	strbuf release commit 
needed check 	notes free 
env histfile 	notes parse options 
env otherwise 	error usage 
help functions 	options init notes 
used help 	check prune 
commands 	notes commit notes 
git commit 	free notes 
working status 	parse options error 
available output 	usage options 
command help 	puts notes 
stdout print 	git config parse 
help 	options strbuf 
output command 	addstr expand notes 
help filtering 	setenv strbuf 
command name 	release strcmp list 
compare arguments 	strcmp strcmp 
networking parsing 	copy strcmp strcmp 
send 	append edit 
auth command 	strcmp show strcmp 
server send 	merge strcmp 
dbnum server 	cmd strcmp prune 
connect server 	strcmp error 
force zero 	usage options use 
connection 	non balancing 
performed even 	simple structure node 
already connected 	nodes leaf 
socket aggressive 	node leaf nodes 
keep alive 	node pointers 
socket option 	children bottom 
redis 	bits pointer used 
context socket 	identify pointer 
order prevent 	type ptr pointer 
timeouts caused 	ptr ptr 
execution commands 	pointer next node 
time 	cast node 
improves detection 	ptr pointer note 
real errors 	entry cast 
auth right 	leaf node ptr 
producing output 	pointer subtree 
standard output 	entry cast leaf 
want 	node root 
interesting output 	node statically allocated 
quoted characters 	node leaf 
forth calculate 	nodes come two 
chars needed 	variants note 
represent largest 	entries subtree entries 
index 	distinguished leaf 
prefix nested 	node pointer 
multi bulks 	see note entry 
grow idxlen 	key sha 
spaces setup 	referenced sha note 
prefix format 	subtree entry 
every 	key prefix sha 
entry use 	trailing referenced 
prefix first 	last key store 
element parent 	length prefix 
caller already 	sha containing notes 
prepended index 	subtree notes 
number 	may contain entries 
format multi 	notes follow 
bulk entry 	naming conventions notes 
helpe function 	typically none 
sds cat 	still need keep 
colorized ldb 	track keep 
reply 	simple linked list 
appending colorize 	sorted alpha 
sds defaults 	betically non 
white colorize 	note path list 
lua debugger 	populated parsing 
status replies 	objects load subtree 
according 	non notes 
prefix current 	correctly written back 
line point 	objects produced 
nothing lua 	write notes grounded 
debugger replies 	last next 
arrays simple 	search appropriate location 
status 	given key 
colorize output 	found start root 
fun debugging 	node current 
session detect 	level matching subtree 
end debugging 	entry unpack 
session signal 	subtree entry restart 
caller 	search current 
session ended 	level use nth 
filter cases 	nibble key 
reconnect avoid 	index node 
compiler warning 	recurse node increment 
check need 	matching subtree 
connect 	entry unpack subtree 
different node 	entry restart 
reissue request 	search current level 
comments show 	otherwise found 
position pointer 	one following subtree 
pointer pointer 	entry match 
moved 	key note entry 
moved moved 	may may 
debugging mode 	match key unused 
pass help 	leaf node 
redis user 	pointer location unpack 
manually calls 	resume search 
script 	unpack resume search 
debug setup 	fall find 
activation debugging 	leaf node 
mode next 	search location appropriate 
eval needed 	given key 
actually activate 	note entry matching 
ldb 	key note 
eval needed 	entry consolidate node 
setup argument 	non entries 
length error 	give non zero 
slave mode 	otherwise replace 
lost connection 	node given index 
master 	given parent 
store database 	node entry entry 
number successfully 	entries given 
executed make 	one entry replace 
grep friendly 	parent index 
send command 	leaf node search 
reconnecting 	location appropriate 
link needed 	given leaf node 
cursor left 	key location 
edge clear 	hold matching 
line cursor 	entry abort nothing 
left edge 	copy matching 
clear 	entry given entry 
line user 	replace matching 
likely command 	leaf node entry 
name stop 	free leaf 
ldb requires 	node consolidate nodes 
eval turn 	repeatedly walking 
plain 	towards root type 
sds still 	bits type 
cannot send 	mismatch nothing key 
command print 	mismatch nothing 
error reconnect 	found matching entry 
next time 	consolidate level 
issue 	parent levels possible 
command got 	cannot consolidate 
redirected cluster 	top level first 
mode split 	build stack 
user provided 	ancestors root 
command multiple 	current node next 
sds 	unwind stack 
arguments function 	note consolidate done 
normally uses 	insert leaf 
sdssplitargs sds 	node search location 
able understand 	appropriate given 
quoted escapes 	leaf node key 
forth 	location unused 
however lua 	store tweaked pointer 
debugging mode 	directly location 
eval command 	holds note entry 
used want 	matches note 
remaining lua 	inserted combine two 
script 	notes calling 
eval passed 	given combine notes 
verbatim single 	function location 
big argument 	holds note entry 
eval use 	matches subtree 
history stdin 	inserted unpack 
tty 	subtree inserted location 
eval mode 	location holds 
restart session 	matching subtree entry 
debugging session 	unpack subtree 
ended show 	location restart insert 
eval reply 	operation level 
free 	create node holding 
argument vector 	node location 
linenoise returns 	node inserted store 
malloc lines 	node location 
like readline 	type bits skip 
eval mode 	concatenation entry 
load 	unpack entry unpack 
script file 	restart insert 
sds debugging 	non matching leaf 
script enable 	node skip 
lua debugger 	insertion empty 
create argument 	note free entire 
vector 	notes data 
call save 	contained given fall 
may reverteed 	convert sha 
debugging session 	hex corresponding sha 
ended immediately 	hex sha 
error compiling 	segment ascii hex 
script 	format hex 
show enter 	len length segment 
repl caller 	must multiple 
restart session 	sha sha written 
repl returned 	sha len 
caller latency 	max bytes store 
latency 	sha must 
history modes 	hex len returns 
milliseconds milliseconds 	error invalid 
latency distribution 	arguments invalid sha 
mode requires 	hex format 
colors xterm 	otherwise returns 
milliseconds 	number bytes written 
structure store 	sha hex 
samples distribution 	len pads sha 
max latency 	sha len 
fit interval 	included returned length 
usec number 	note takes 
samples 	ownership path nothing 
interval associated 	sorts first 
character visualization 	non note sorts 
helper function 	equal overwrite 
latency dist 	sorts next entry 
mode performs 	path sha 
spectrum 	sha complete len 
visualization collected 	note sha 
samples targeting 	incomplete len current 
xterm terminal 	component consists 
takes distsamples 	hex chars note 
structures ordered 	subtree subtree 
smaller 	determine full 
bigger max 	path non note 
last sample 	entry filename 
max must 	already found entry 
mean olds 	path directory 
samples greater 	part path must 
previous 	deduced subtree 
one also 	containing entry overall 
stop sentinel 	notes follows 
tot total 	strict progressive fanout 
number samples 	structure etc 
different buckets 	fanouts fanout means 
sum 	non note 
samples conut 	found path dead 
max sample 	beef following 
side effect 	code found beef 
function sets 	hand use 
buckets count 	non obvious non 
convert 	note paths 
samples index 	middle notes 
inside palette 	deserve coming note 
proportional percentage 	non notes 
given bucket 	sha like top 
represents way 	level problems 
intensity 	conclude strongly advised 
different parts 	make sure 
spectrum change 	non notes least 
relative number 	one non 
requests avoids 	hex character top 
pollute visualization 	level path 
non 	component determine optimal 
latency related 	disk fanout 
info foreground 	part notes given 
color black 	sub level 
last sample 	structure determine whether 
show legend 	given existing 
different 	fanout expanded 
buckets values 	sub values fanout 
colors meaning 	variable fanout 
spectrum easily 	notes stored directly 
readable use 	root notes 
mostly logarithmic 	fanout fanout fanout 
scale 	etc following 
certain linear 	simple heuristic works 
intervals interesting 	well practice 
others like 	even numbered level 
milliseconds range 	remember disk 
minute minute 	fanout level corresponds 
populate 	two levels 
relevant bucket 	peek entries level 
time time 	either nodes 
show spectrum 	subtree entries likely 
slave mode 	plenty notes 
sends sync 	level incremented fanout 
reads 	hex sha 
number bytes 	nul recurse 
payload used 	node subtree entries 
slave mode 	note represent 
rdb start 	parts note yet 
need send 	explored direct 
sync 	relationship subtree entries 
command payload 	level fanout 
hiredis client 	variable subtree entries 
lib understand 	level fanout 
part protocol 	preserved since correspond 
want mess 	exactly fanout 
buffers 	directory disk structure 
everything performed 	however subtree 
direct low 	entries level fanout 
level send 	preserved rather 
sync command 	consolidated notes level 
read payload 	achieve unconditionally 
making 	unpacking subtree entries 
sure read 	exist threshold 
discard payload 	level fanout 
use hiredis 	invoke callback subtree 
read incoming 	create trailing 
protocol rdb 	slash needed unpack 
transfer 	subtree resume 
mode function 	traversal path subtree 
rdb uses 	next entries 
replication protocol 	per determine common 
order fetch 	part write 
rdb file 	stack tws point 
remote 	last matching 
server write 	write stack entry 
file close 	start subtrees 
file descriptor 	needed satisfy path 
asap fsync 	directory components 
may take 	given path given 
time 	entry current 
bulk pipe 	nothing prefer note 
mode input 	non note 
output buffers 	subtree entry 
consumed standard 	weave non note 
input special 	entries note 
reply 	entries nothing note 
recognize use 	failed find 
non blocking 	prune note read 
transfer raw 	note blob 
protocol read 	objects separate notes 
replies server 	two newlines 
time 	anyway concatenate cur 
handle readable 	msg msg 
state read 	buf create blob 
replies server 	buf lines 
read socket 	named list trailing 
feed hiredis 	newlines removed 
reader 	read sha file 
consume replies 	nul terminates 
check reply 	last line file 
echo command 	eol terminated 
everything received 	empty list 
server handle 	removed later along 
writable 	empty came 
state send 	empty lines within 
protocol server 	file read 
transfer current 	note blob objects 
buffer server 	unique lines 
accept data 	create blob sort 
buffer 	uniq list 
empty load 	list argument must 
stdin echo 	strdup core 
sequence starts 	notes config note 
garbage protocol 	removed prepare 
read stdin 	traversal current notes 
echo 	last forward 
likely still 	entry list grounded 
properly formatted 	entries write 
crlf ignored 	objects representing 
redis effects 	current notes fill 
everything transferred 	given strbuf 
queue 	notes associated given 
special echo 	given notes 
command match 	structure initialized initialized 
replies make 	see documentation 
sure everything 	init notes given 
read server 	notes notes 
handle 	used instead raw 
timeout reached 	gives userformat 
eof getting 	otherwise note message 
replies server 	given human 
seconds echo 	consumption end annotation 
received find 	newline anyway 
big 	happy fallback expand 
keys handle 	notes builtin 
error conditions 	git notes copyright 
validate types 	johan herland 
correct update 	johan herland 
iterator grab 	net git notes 
number 	johannes schindelin 
keys free 	builtin tag kristian 
reply pipeline 	gsberg carlos 
type commands 	rica invoke git 
retrieve types 	show stat 
pipeline size 	notes write message 
commands 	editing redirect 
skip keys 	edit subcommand end 
deleted retreive 	none given 
sizes skip 	original args therefore 
keys dissapeared 	still argv 
scan type 	append buf previous 
retreive 	note contents 
size theoretically 	git notes merge 
key could 	git notes 
removed added 	merge call notes 
different type 	merge abort 
type size 	git notes 
total 	merge worktree read 
keys pre 	merge result 
scanning status 	git notes merge 
message sds 	target notes 
keep track 	git notes merge 
overall biggest 	reuse existing 
per 	commit message reflog 
type scan 	message skip 
loop calculate 	notes merge resulted 
approximate percentage 	trivially result 
completion grab 	sha update notes 
keys point 	commit merge 
keys 	unresolved conflicts update 
reallocate type 	git notes 
size need 	merge merge result 
retreive types 	store updated 
sizes update 	git notes merge 
stats keep 	non zero 
track 	conflicts notes.c 
biggest key 	key sha val 
name type 	sha next 
keep track 	path mode sha 
biggest size 	notes display 
type update 	notes refs display 
overall 	notes trees 
progress sleep 	subtree node key 
directed done 	sha key 
output biggest 	sha parent index 
keys found 	entry parent 
types find 	stack entry type 
free 	combine notes 
sds containing 	node ret hex 
max keys 	hex len 
success stats 	sha sha len 
mode specified 	len val 
info field 	path mode 
info 	sha subtree node 
command output 	sha prefix 
info buffer 	len buf desc 
allocated result 	entry len 
needs free 	path len type 
field found 	non note 
returned 	path fanout sha 
like function 	fanout path 
automatically convert 	hex sha fanout 
result error 	flags data 
missing field 	ret path path 
min returned 	len next 
convert 	buf path tws 
number bytes 	full path 
human readable 	buf mode path 
form forth 	path len 
bytes keys 	sha tws path 
used memory 	tws ret 
clients 	tws path 
blocked blpopping 	mode sha path 
clients requets 	len ret 
connections children 	root next non 
scan mode 	note note 
lru test 	path ret sha 
mode 	note sha 
integer min 	note path data 
max inclusive 	note path 
power law 	len mode next 
distribution depending 	sha sha 
alpha greater 	note sha note 
alpha 	path data 
bias towards 	cur sha sha 
lower values 	buf cur 
alpha output 	len len buf 
follows rule 	len ret 
returned numbers 	cur sha sha 
account 	cur sha 
frequency generates 	sha list 
key name 	sha data len 
among lru 	item data 
test sample 	buf cur sha 
size keys 	sha sort 
distribution 	uniq list buf 
milliseconds perform 	ret refname 
cycles second 	oid flag refs 
writes reads 	list glob 
use pipelining 	sha list globs 
batching 	split globs 
writes reads 	copy load refs 
times per 	notes notes 
cycle order 	combine notes flags 
fill target 	sha sha 
instance easily 	mode root refs 
write 	flags item 
cycle read 	counter trees opt 
cycle print 	display env 
stats intrisic 	load config 
latency mode 	refs item sha 
measure max 	note sha 
latency 	combine notes sha 
running process 	sha found 
result syscalls 	flags data result 
basically software 	root data 
provide hint 	ret flags sha 
much time 	output encoding 
kernel 	raw utf sha 
leaves process 	msg msg 
without chance 	linelen msglen reencoded 
run computation 	sha output 
compiler optimize 	encoding raw obj 
run less 	obj force 
microseconds 	combine notes note 
even slow 	existing note 
hardware runs 	ptr type 
less microseconds 	clr ptr type 
modern reporting 	subtree sha 
program main 	prefixcmp load subtree 
latency 	free note 
mode latency 	search nibble ptr 
distribution mode 	type clr 
slave mode 	ptr type note 
rdb mode 	search clr 
pipe mode 	ptr type subtree 
find 	sha prefixcmp 
big keys 	load subtree free 
stat mode 	note search 
scan mode 	note search ptr 
lru test 	type clr 
mode intrinsic 	ptr type hashcmp 
latency 	clr ptr 
mode start 	type ptr type 
interactive mode 	free note 
command provided 	search ptr 
ignore sigpipe 	type ptr type 
interactive mode 	clr ptr 
force 	type hashcmp hashcpy 
reconnect note 	free ptr 
repl mode 	type nibble clr 
abort connection 	ptr type 
error attempt 	note consolidate nibble 
performed every 	note search 
command 	ptr type clr 
send otherwise 	ptr type 
arguments execute 	ptr type sha 
redisassert.h estr 	free ptr 
file line 	type hashcmp hashcmp 
redisassert drop 	combine notes 
replacemnet 	sha note free 
prints stack 	subtree sha 
trace redis 	prefixcmp load subtree 
logs file 	free subtree 
included instead 	sha prefixcmp 
inside libraries 	load subtree free 
used 	note insert 
redis assertions 	ptr type ptr 
instead redis 	type sha 
disappearing sigabort 	free xcalloc note 
details stack 	insert ptr 
trace inside 	type ptr type 
log 	note insert 
file copyright 	ptr type note 
salvatore sanfilippo 	free clr 
antirez gmail 	ptr type free 
dot rights 	clr ptr 
reserved redistribution 	type hexval hexval 
use 	strcmp xmalloc 
source binary 	hashcpy non note 
forms without 	cmp non 
modification permitted 	note cmp non 
provided following 	note cmp 
conditions met 	non note 
redistributions 	cmp strcmp hashcpy 
source code 	free fill 
must retain 	descriptor die sha 
copyright notice 	hex memcpy 
list conditions 	entry strlen sha 
following disclaimer 	hex segment 
redistributions 	xcalloc hashcpy hashcpy 
binary form 	isdir note 
must reproduce 	insert die sha 
copyright notice 	hex sha 
list conditions 	hex strbuf addch 
following disclaimer 	strbuf addch 
documentation 	strbuf addch strbuf 
materials provided 	addstr non 
distribution neither 	note strbuf detach 
name redis 	free ptr 
names contributors 	type sha hex 
may used 	xsnprintf determine 
endorse 	fanout ptr 
promote products 	type note helper 
derived software 	clr ptr 
without specific 	type clr ptr 
prior written 	type construct 
permission software 	path fanout load 
provided 	subtree free 
copyright holders 	clr ptr type 
contributors express 	construct path 
implied warranties 	fanout strbuf addf 
including limited 	strbuf xmalloc 
implied warranties 	strbuf init write 
merchantability 	stack finish 
fitness particular 	subtree write sha 
purpose disclaimed 	file strbuf 
shall copyright 	release free write 
owner contributors 	entry strlen 
liable direct 	matches write 
indirect 	stack write stack 
incidental special 	finish subtree 
exemplary consequential 	write stack init 
damages including 	subtree memchr 
limited procurement 	write entry strcmp 
substitute goods 	write note 
services 	helper strlen write 
loss use 	non note 
data profits 	write note helper 
business interruption 	sha file 
however caused 	xmalloc sha read 
theory liability 	sha file 
whether 	free sha read 
contract strict 	sha file 
liability tort 	free free hashcpy 
including negligence 	xmalloc memcpy 
otherwise arising 	memcpy free free 
way use 	write sha 
software 	file free 
even advised 	hashcpy sha read 
possibility damage 	sha file 
exit rehashing.c 	free list split 
keyp key 	free strbuf 
privdata key 	addstr strbuf addch 
key 	list note 
dict type 	lines list note 
test times 	lines list 
perfect run 	empty items list 
approx run 	sort list 
des requested 	duplicates list write 
returned 	sha file 
dup approx 	strbuf release list 
run exit 	clear unsorted 
dict gen 	list list append 
hash function 	glob specials 
show buckets 	glob sha warning 
show 	unsorted list 
buckets zmalloc 	list append 
dict size 	xstrdup list split 
rand dict 	place list 
size dict 	empty items list 
keys qsort 	refs glob 
zfree 	list clear free 
dict create 	strcmp config 
srand time 	error nonbool list 
dict show 	refs glob 
dict size 	getenv notes xcalloc 
dict dict 	xstrdup sha 
resize 	treeish read die 
show dict 	entry die 
release dict 	sha hex hashclr 
create dict 	hashcpy load 
stress keys 	subtree alloc xcalloc 
dict dict 	init notes 
resize 	list append notes 
stress keys 	getenv list 
dict release 	refs colon 
hash function 	sep git config 
key dup 	list refs 
val dup 	glob load notes 
key 	trees list 
compare key 	clear xmalloc hashcpy 
destructor val 	hashcpy note 
destructor release.c 	insert hashcpy hashclr 
buildid crc 	note sha 
strlen copyright 	note find note 
salvatore 	helper strbuf 
sanfilippo antirez 	init note write 
gmail dot 	non note 
rights reserved 	write stack finish 
redistribution use 	subtree write 
source binary 	sha file strbuf 
forms 	release note 
without modification 	sha hex 
permitted provided 	note note free 
following conditions 	free free 
met redistributions 	free free memset 
source code 	init notes 
must 	note read sha 
retain copyright 	file free 
notice list 	encoding utf reencode 
conditions following 	free strlen 
disclaimer redistributions 	strcmp strbuf addstr 
binary form 	starts starts 
must 	strbuf addf strchrnul 
reproduce copyright 	strbuf addstr 
notice list 	strbuf strbuf addch 
conditions following 	free format 
disclaimer documentation 	note note note 
materials provided 	note note 
distribution 	starts starts strbuf 
neither name 	insert strbuf 
redis names 	insert sha 
contributors may 	expand notes use 
used endorse 	non balancing 
promote products 	simple structure node 
derived 	nodes leaf 
software without 	node leaf nodes 
specific prior 	node pointers 
written permission 	children bottom bits 
software provided 	pointer used 
copyright holders 	identify pointer type 
contributors 	ptr pointer 
express implied 	ptr ptr pointer 
warranties including 	next node 
limited implied 	cast node ptr 
warranties merchantability 	pointer note 
fitness particular 	entry cast leaf 
purpose 	node ptr 
disclaimed shall 	pointer subtree entry 
copyright owner 	cast leaf 
contributors liable 	node root 
direct indirect 	node statically allocated 
incidental special 	node leaf 
exemplary 	nodes come two 
consequential damages 	variants note 
including limited 	entries subtree entries 
procurement substitute 	distinguished leaf 
goods services 	node pointer see 
loss use 	note entry 
data 	key sha referenced 
profits business 	sha note 
interruption however 	subtree entry key 
caused theory 	prefix sha 
liability whether 	trailing referenced last 
contract strict 	key store 
liability 	length prefix sha 
tort including 	containing notes 
negligence otherwise 	subtree notes may 
arising way 	contain entries 
use software 	notes follow 
even advised 	naming conventions notes 
possibility 	typically none 
damage every 	still need keep 
time redis 	track keep 
git sha 	simple linked list 
dirty status 	sorted alpha 
changes small 	betically non note 
file 	path list 
recompiled access 	populated parsing objects 
information files 	load subtree 
functions replication.c 	non notes correctly 
newfd slave 	written back 
buf newsize 	objects produced write 
ptr 	notes grounded 
len thislen 	last next search 
llstr len 	appropriate location 
slaves dictid 	given key 
argv argc 	found start root 
len llstr 	node current 
selectcmd 	level matching subtree 
dictid len 	entry unpack 
slave aux 	subtree entry restart 
objlen slave 	search current 
monitors dictid 	level use nth 
argv argc 	nibble key 
cmdrepr 	index node recurse 
cmdobj monitor 	node increment 
offset skip 	matching subtree entry 
len thislen 	unpack subtree 
psync offset 	entry restart search 
slave offset 	current level 
buf 	otherwise found one 
buflen psync 	following subtree 
offset psync 	entry match key 
len master 	note entry 
runid buf 	may may 
buflen mincapa 	match key unused 
retval 	leaf node 
socket target 	pointer location unpack 
slave slave 	resume search 
master runid 	unpack resume search 
slave port 	fall find 
offset slave 	leaf node search 
privdata 	location appropriate 
mask slave 	given key note 
buf nwritten 	entry matching 
buflen bgsaveerr 	key note entry 
type startbgsave 	consolidate node 
mincapa slave 	non entries give 
buf 	non zero 
newline sent 	otherwise replace node 
privdata privdata 	given index 
mask buf 	given parent node 
nread readlen 	entry entry 
left eofmark 	entries given 
lastbytes 	one entry replace 
usemark eof 	parent index 
reached rem 	leaf node search 
sync size 	location appropriate 
retry flags 	given leaf node 
arg cmd 	key location 
buf 	hold matching entry 
read reply 	abort nothing 
psync runid 	copy matching entry 
psync offset 	given entry 
reply offset 	replace matching leaf 
privdata mask 	node entry 
tmpfile 	free leaf node 
err dfd 	consolidate nodes 
maxtries psync 	repeatedly walking towards 
result errlen 	root type 
port port 	bits type mismatch 
client port 	nothing key 
client 	mismatch nothing 
mbcount slaves 	found matching entry 
slave slavestate 	consolidate level 
newfd good 	parent levels possible 
slave lag 	cannot consolidate 
sha retval 	top level first 
key 	build stack 
oldest sha 	ancestors root current 
offset count 	node next 
slave timeout 	unwind stack note 
numreplicas ackreplicas 	consolidate done 
offset last 	insert leaf node 
offset 	search location 
last numreplicas 	appropriate given leaf 
numreplicas offset 	node key 
replication cron 	location unused store 
loops ping 	tweaked pointer 
argv slave 	directly location holds 
slave 	note entry 
idle idle 	matches note 
max idle 	inserted combine two 
slaves waiting 	notes calling 
mincapa slave 	given combine notes 
anet peer 	function location 
anet 	holds note entry 
format addr 	matches subtree 
snprintf snprintf 	inserted unpack subtree 
server zmalloc 	inserted location 
zfree zmalloc 	location holds matching 
server list 	subtree entry 
length 	unpack subtree location 
zfree memcpy 	restart insert 
sdslen feed 	operation level create 
replication backlog 	node holding 
list length 	node location node 
server list 	inserted store 
length 	node location 
create sdscatprintf 	type bits skip 
sdsempty feed 	concatenation entry 
replication backlog 	unpack entry unpack 
list rewind 	restart insert 
list next 	non matching leaf 
reply 	node skip 
decr count 	insertion empty note 
feed replication 	free entire 
backlog len 	notes data contained 
feed replication 	given fall 
backlog feed 	convert sha hex 
replication 	corresponding sha 
backlog feed 	hex sha segment 
replication backlog 	ascii hex 
list rewind 	format hex len 
list next 	length segment 
reply multi 	must multiple sha 
bulk 	sha written 
len reply 	sha len 
bulk sdsnew 	max bytes store 
gettimeofday sdscatprintf 	sha must 
sdscatprintf sdscatprintf 	hex len returns 
sdscatprintf client 	error invalid 
peer 	arguments invalid sha 
sdscatprintf sdscatrepr 	hex format 
sdslen sdscatlen 	otherwise returns number 
sdscatlen create 	bytes written 
list rewind 	sha hex len 
list next 	pads sha 
reply 	sha len included 
decr count 	returned length 
server log 	note takes ownership 
server log 	path nothing 
server log 	sorts first non 
server log 	note sorts 
server 	equal overwrite sorts 
log server 	next entry 
log server 	path sha 
log server 	sha complete len 
log server 	note sha 
log server 	incomplete len current 
log 	component consists 
reply sds 	hex chars note 
sdsnewlen snprintf 	subtree subtree 
write free 	determine full path 
client strcasecmp 	non note 
server log 	entry filename already 
server 	found entry 
log replication 	path directory part 
slave name 	path must 
reply server 	deduced subtree containing 
log replication 	entry overall 
slave name 	notes follows strict 
server 	progressive fanout 
log replication 	structure etc fanouts 
slave name 	fanout means 
list node 	non note 
tail snprintf 	found path dead 
write free 	beef following 
client 	code found beef 
reply replication 	hand use 
backlog server 	non obvious non 
log replication 	note paths 
slave name 	middle notes deserve 
refresh good 	coming note 
slaves 	non notes sha 
count server 	like top 
log rdb 	level problems conclude 
save slaves 	strongly advised 
sockets rdb 	make sure non 
save background 	notes least 
server 	one non hex 
log list 	character top 
rewind list 	level path 
next list 	component determine optimal 
del node 	disk fanout 
reply 	part notes given 
error list 	sub level 
rewind list 	structure determine whether 
next replication 	given existing 
setup slave 	fanout expanded sub 
full resync 	values fanout 
psync 	variable fanout notes 
initial offset 	stored directly 
replication script 	root notes fanout 
cache flush 	fanout fanout 
reply error 	etc following simple 
client pending 	heuristic works 
replies 	well practice even 
reply error 	numbered level 
server log 	remember disk fanout 
replication slave 	level corresponds 
name strcasecmp 	two levels 
master resynchronization 	peek entries level 
anet 	either nodes 
disable tcp 	subtree entries likely 
delay list 	plenty notes 
node tail 	level incremented fanout 
list rewind 	hex sha 
list next 	nul recurse node 
copy 	subtree entries 
client output 	note represent parts 
buffer replication 	note yet 
setup slave 	explored direct relationship 
full resync 	subtree entries 
server log 	level fanout variable 
server 	subtree entries 
log server 	level fanout preserved 
log server 	since correspond 
log start 	exactly fanout directory 
bgsave replication 	disk structure 
list length 	however subtree 
create 	entries level fanout 
replication backlog 	preserved rather 
reply strcasecmp 	consolidated notes level 
reply strcasecmp 	achieve unconditionally 
strcasecmp strcasecmp 	unpacking subtree entries 
put slave 	exist threshold 
online 	level fanout invoke 
strcasecmp replication 	callback subtree 
send ack 	create trailing slash 
reply error 	needed unpack 
format reply 	subtree resume traversal 
create file 	path subtree 
server 	next entries per 
log strerror 	determine common 
free client 	part write stack 
refresh good 	tws point 
slaves count 	last matching write 
server log 	stack entry 
replication 	start subtrees 
slave name 	needed satisfy path 
unused unused 	directory components 
write sdslen 	given path given 
server log 	entry current 
strerror free 	nothing prefer note 
client 	non note 
sdsrange sdslen 	subtree entry weave 
sdsfree lseek 	non note 
read server 	entries note entries 
log strerror 	nothing note 
free client 	failed find prune 
write 	note read 
server log 	note blob objects 
strerror free 	separate notes 
client close 	two newlines anyway 
file put 	concatenate cur 
slave online 	msg msg buf 
list 	create blob 
rewind list 	buf lines 
next server 	named list trailing 
log replication 	newlines removed 
slave name 	read sha file 
free client 	nul terminates 
server 	last line file 
log open 	eol terminated 
redis fstat 	empty list removed 
free client 	later along 
server log 	empty came empty 
strerror sdscatprintf 	lines within 
sdsempty 	file read note 
file create 	blob objects 
file free 	unique lines create 
client start 	blob sort 
bgsave replication 	uniq list list 
time time 	argument must 
write 	strdup core 
unused replication 	notes config note 
send newline 	removed prepare 
master create 	traversal current notes 
client memcpy 	last forward 
unused unused 	entry list grounded 
unused 	entries write 
sync read 	objects representing current 
line server 	notes fill 
log strerror 	given strbuf notes 
server log 	associated given 
server log 	given notes structure 
strncmp 	initialized initialized 
strlen memcpy 	see documentation init 
memset server 	notes given 
log strtol 	notes notes used 
server log 	instead raw 
read server 	gives userformat otherwise 
log 	note message 
strerror cancel 	given human 
replication handshake 	consumption end annotation 
memcpy memmove 	newline anyway 
memcpy memcmp 	happy fallback expand 
write server 	notes builtin 
log 	git notes copyright 
strerror ftruncate 	johan herland 
server log 	johan herland net 
strerror rdb 	git notes 
fsync range 	johannes schindelin builtin 
rename server 	tag kristian 
log 	gsberg carlos rica 
strerror cancel 	invoke git 
replication handshake 	show stat notes 
server log 	write message 
signal flushed 	editing redirect edit 
empty file 	subcommand end 
server 	none given original 
log rdb 	args therefore 
load server 	still argv 
log cancel 	append buf previous 
replication handshake 	note contents 
zfree close 	git notes merge 
replication 	git notes 
create master 	merge call notes 
client server 	merge abort 
log stop 	git notes merge 
append start 	worktree read 
append server 	merge result git 
log 	notes merge 
sleep server 	target notes git 
log exit 	notes merge 
cancel replication 	reuse existing commit 
handshake sdsempty 	message reflog 
start arg 	message skip notes 
sdslen 	merge resulted 
sdscatlen sdscat 	trivially result sha 
sdscatlen sync 	update notes 
write sdslen 	commit merge 
sdsfree sdscatprintf 	unresolved conflicts update 
sdsempty strerror 	git notes 
sdsfree 	merge merge result 
end sync 	store updated 
read line 	git notes merge 
sdscatprintf sdsempty 	non zero 
strerror sdsnew 	conflicts git notes 
snprintf server 	usage git 
log 	notes list usage 
server log 	git notes 
memcpy send 	usage git notes 
synchronous command 	copy usage 
server log 	git notes append 
sdsfree file 	usage git 
send 	notes edit usage 
synchronous command 	git notes 
sdslen sdsfree 	show usage 
file strncmp 	git notes merge 
strchr strchr 	usage git 
server log 	notes usage git 
memset 	notes prune 
memcpy strtoll 	usage git notes 
server log 	usage note 
replication discard 	given use editor 
cached master 	edit path 
sdsfree strncmp 	buf sha note 
server 	sha note 
log sdsfree 	path data sha 
replication resurrect 	size buf 
cached master 	show args show 
strncmp server 	buf cbuf 
log server 	old note buf 
log 	sha opt 
sdsfree replication 	arg unset opt 
discard cached 	arg unset 
master unused 	opt arg 
unused unused 	unset buf len 
close getsockopt 	opt arg 
server 	unset force rewrite 
log strerror 	cmd buf 
server log 	ret msg obj 
file send 	obj split 
synchronous command 	err subcommand flags 
send synchronous 	argc argv 
command 	prefix note retval 
strncmp strncmp 	options argc 
server log 	argv prefix argc 
sdsfree server 	argv prefix 
log sdsfree 	allow empty note 
send synchronous 	note options 
command 	argc argv prefix 
send synchronous 	stdin note 
command server 	note obj rewrite 
log sdsfree 	cmd options 
sdsfree sdsfromlonglong 	argc argv 
send synchronous 	prefix allow empty 
command 	note note 
sdsfree sdsfree 	logmsg usage options 
send synchronous 	edit size 
command server 	prev buf argc 
log sdsfree 	argv prefix 
send synchronous 	note retval options 
command 	show args 
sdsfree send 	ret msg sha 
synchronous command 	parent sha 
server log 	pretty ctx local 
sdsfree slave 	free ret 
resynchronization sdsnew 	git config notes 
server 	strategy argc 
log slave 	argv prefix msg 
resynchronization server 	result sha 
log disconnect 	abort result strategy 
slaves free 	options merge 
replication backlog 	key existing 
server 	name flag status 
log sync 	sha argc 
write server 	argv prefix flag 
log strerror 	stdin options 
snprintf getpid 	retval argc argv 
open sleep 	prefix verbose 
server 	options argc argv 
log strerror 	prefix options 
create file 	argc argv prefix 
server log 	result notes 
strerror zstrdup 	options unlink warn 
file close 	free strbuf 
server 	release sha hex 
log sdsfree 	sha hex 
anet tcp 	read sha file 
non block 	write die 
best effort 	free start 
bind connect 	command die sha 
server 	hex strbuf 
log strerror 	read die errno 
create file 	strbuf commented 
close server 	lines write die 
log file 	strbuf release 
close server 	strbuf release finish 
undo 	command die 
connect master 	sha hex git 
close unlink 	pathdup open 
zfree replication 	die errno write 
abort sync 	die copy 
transfer slave 	obj strbuf addch 
handshake 	strbuf commented 
state undo 	lines strlen strbuf 
connect master 	addch write 
sdsfree sdsnew 	die write commented 
free client 	close strbuf 
disconnect blocked 	release strbuf 
clients 	reset launch editor 
disconnect slaves 	die strbuf 
replication discard 	stripspace write sha 
cached master 	file error 
free replication 	error exit strbuf 
backlog cancel 	grow strlen 
replication 	strbuf addch strbuf 
handshake sdsfree 	addstr strbuf 
list length 	stripspace strbuf addch 
free replication 	strcmp strbuf 
backlog free 	read die errno 
client replication 	strbuf read 
discard 	file die errno 
cached master 	strbuf stripspace 
cancel replication 	strbuf addch sha 
handshake reply 	die read 
error strcasecmp 	sha file free 
strcasecmp replication 	die free 
unset 	die strbuf 
master cat 	free parse reuse 
client info 	arg init 
sdsempty server 	copy notes rewrite 
log sdsfree 	init notes 
reply strcasecmp 	strbuf getline strbuf 
server 	split die 
log reply 	strbuf rtrim strbuf 
sds sdsnew 	rtrim sha 
replication master 	die sha die 
cat client 	copy note 
info sdsempty 	rewrite copy note 
server 	error strbuf 
log sdsfree 	list free commit 
reply reply 	notes free 
multi bulk 	notes finish copy 
len reply 	notes rewrite 
bulk buffer 	init notes starts 
reply 	die parse 
deferred multi 	options error 
bulk length 	usage options init 
list rewind 	notes check 
list next 	sha die note 
anet peer 	puts sha 
reply 	hex error sha 
multi bulk 	hex note 
len reply 	free notes parse 
bulk reply 	options error 
bulk reply 	usage options sha 
bulk deferred 	die init 
multi 	notes check note 
bulk length 	free notes 
reply multi 	free note data 
bulk len 	error sha 
reply bulk 	hex append edit 
buffer reply 	sha hex 
bulk 	prepare note data 
reply slave 	write note 
handshake state 	data note 
reply bulk 	die commit notes 
reply reply 	sha hex 
multi bulk 	note commit notes 
len 	free note 
reply bulk 	data free notes 
reply bulk 	parse options 
reply bulk 	error usage options 
server server 	notes copy 
log unlink 	stdin error usage 
client 	options error 
sdsfree replication 	usage options sha 
handle master 	die sha 
disconnection server 	die init notes 
log free 	check note 
client list 	error sha hex 
node 	sha hex 
tail create 	note error 
file server 	sha hex note 
log strerror 	die commit 
free client 	notes free notes 
client pending 	strcmp parse 
replies 	options error usage 
create file 	options sha 
server log 	die init notes 
strerror free 	check note 
client list 	prepare note data 
rewind list 	read sha 
next 	file strbuf grow 
dict create 	strbuf insert 
list create 	strbuf insert free 
dict empty 	write note 
list release 	data note die 
list create 	snprintf sha 
sdsdup 	hex note snprintf 
list length 	commit notes 
list last 	free note 
list node 	data free notes 
dict server 	parse options 
list del 	error usage options 
node 	sha die 
dict list 	init notes check 
node head 	note error 
server dict 	sha hex execv 
find list 	git cmd 
rewind list 	free notes error 
next 	error notes 
reply timeout 	merge abort error 
reply replication 	sha die 
count acks 	lookup commit reference 
offset reply 	die parse 
list node 	commit die hashcpy 
tail 	hashclr xcalloc 
block client 	init notes resolve 
replication request 	refdup die 
ack slaves 	notes merge 
list search 	commit die memset 
key server 	format commit 
list 	message strbuf trim 
del node 	strbuf insert 
list rewind 	update sha free 
list next 	notes strbuf 
unblock client 	release merge abort 
reply replication 	free parse 
count 	options error usage 
acks offset 	options error 
unblock client 	usage options error 
reply slave 	usage options 
handshake state 	init notes merge 
time server 	options merge 
log 	abort merge commit 
cancel replication 	notes strbuf 
handshake time 	addstr expand loose 
server log 	notes init 
cancel replication 	notes check 
handshake time 	parse notes merge 
server 	strategy error 
log free 	usage options skip 
client server 	prefix die 
log connect 	strbuf addf git 
master server 	config notes 
log replication 	strategy git config 
send 	notes strategy 
ack create 	strbuf release strbuf 
replication feed 	addf notes 
slaves decr 	strbuf notes merge 
count list 	update notes 
rewind list 	update find shared 
next 	symref notes 
write list 	die notes create 
length list 	symref notes 
rewind list 	die notes 
next server 	git path free 
log replication 	notes strbuf 
slave 	release strbuf release 
name free 	sha error 
client list 	note parse options 
length free 	init notes 
replication backlog 	check one note 
server log 	one note 
list 	strbuf getwholeline strbuf 
length list 	rtrim one 
length replication 	note strbuf release 
script cache 	commit notes 
flush list 	free notes parse 
rewind list 	options error 
next 	usage options init 
start bgsave 	notes check 
replication refresh 	prune notes commit 
good slaves 	notes free 
count asynchronous 	notes parse 
replication implementation 	options error usage 
copyright 	options puts 
salvatore sanfilippo 	notes git config 
antirez gmail 	parse options 
dot rights 	strbuf addstr expand 
reserved redistribution 	notes setenv 
use source 	strbuf release strcmp 
binary 	list strcmp 
forms without 	strcmp copy strcmp 
modification permitted 	strcmp append 
provided following 	edit strcmp show 
conditions met 	strcmp merge 
redistributions 	strcmp cmd strcmp 
source code 	prune strcmp 
must retain 	error usage options 
copyright notice 	use non 
list conditions 	balancing simple structure 
following disclaimer 	node nodes 
redistributions 	leaf node 
binary form 	leaf nodes node 
must reproduce 	pointers children 
copyright notice 	bottom bits pointer 
list conditions 	used identify 
following disclaimer 	pointer type ptr 
documentation 	pointer ptr 
materials provided 	ptr pointer next 
distribution neither 	node cast 
name redis 	node ptr pointer 
names contributors 	note entry 
may used 	cast leaf node 
endorse 	ptr pointer 
promote products 	subtree entry cast 
derived software 	leaf node 
without specific 	root node statically 
prior written 	allocated node 
permission software 	leaf nodes come 
provided 	two variants 
copyright holders 	note entries 
contributors express 	subtree entries distinguished 
implied warranties 	leaf node 
including limited 	pointer see note 
implied warranties 	entry key 
merchantability 	sha referenced sha 
fitness particular 	note subtree 
purpose disclaimed 	entry key prefix 
shall copyright 	sha trailing 
owner contributors 	referenced last key 
liable direct 	store length 
indirect 	prefix sha containing 
incidental special 	notes subtree 
exemplary consequential 	notes may contain 
damages including 	entries notes 
limited procurement 	follow naming conventions 
substitute goods 	notes typically 
services 	none still 
loss use 	need keep track 
data profits 	keep simple 
business interruption 	linked list sorted 
however caused 	alpha betically 
theory liability 	non note path 
whether 	list populated 
contract strict 	parsing objects load 
liability tort 	subtree non 
including negligence 	notes correctly written 
otherwise arising 	back objects 
way use 	produced write notes 
software 	grounded last 
even advised 	next search appropriate 
possibility damage 	location given 
utility functions 	key found start 
pointer representing 	root node 
slave listening 	current level matching 
port 	subtree entry 
pair mostly 	unpack subtree 
useful logging 	entry restart search 
since want 	current level 
log slave 	use nth nibble 
address listening 	key index 
port 	node recurse node 
clear user 	increment matching 
example closing 	subtree entry unpack 
connection slave 	subtree entry 
master backlog 	restart search current 
buffer created 	level otherwise 
increment 	found one following 
replication offset 	subtree entry 
one make 	match key note 
sure able 	entry may 
psync previous 	may match key 
slave needed 	unused leaf 
avoid 	node pointer location 
incrementing master 	unpack resume 
repl offset 	search unpack 
backlog exists 	resume search fall 
slaves attached 	find leaf 
data inside 	node search location 
buffer 	appropriate given 
virtually first 	key note entry 
next generated 	matching key 
replication stream 	note entry consolidate 
function called 	node non 
user modifies 	entries give non 
replication 	zero otherwise 
backlog size 	replace node given 
runtime function 	index given 
update server 	parent node entry 
repl backlog 	entry entries 
size resize 	given one entry 
buffer 	replace parent 
setup contains 	index leaf node 
data previous 	search location 
one possibly 	appropriate given 
less data 	leaf node key 
recent bytes 	location hold 
data 	matching entry abort 
free space 	nothing copy 
buffer enlarged 	matching entry given 
actually flush 	entry replace 
old buffer 	matching leaf node 
realloc empty 	entry free 
one 	leaf node consolidate 
refill data 	nodes repeatedly 
incrementally reason 	walking towards root 
copying gigabytes 	type bits 
adds latency 	type mismatch nothing 
even worse 	key mismatch 
often 	nothing found matching 
need alloc 	entry consolidate 
additional space 	level parent levels 
freeing old 	possible cannot 
buffer next 	consolidate top 
next since 	level first build 
buffer 	stack ancestors 
empty data 	root current node 
replication backlog 	next unwind 
function also 	stack note consolidate 
increments replication 	done insert 
offset stored 	leaf node search 
server 	location appropriate 
master repl 	given leaf node 
offset want 	key location 
feed backlog 	unused store tweaked 
without incrementing 	pointer directly 
buffer circular 	location holds note 
buffer 	entry matches 
write much 	note inserted combine 
data every 	two notes 
iteration rewind 	calling given 
idx index 	combine notes function 
reach limit 	location holds 
offset 	note entry matches 
first backlog 	subtree inserted 
wrapper feed 	unpack subtree inserted 
replication backlog 	location location 
takes redis 	holds matching subtree 
objects input 	entry unpack 
aren 	subtree location restart 
slaves backlog 	insert operation 
buffer populate 	level create node 
asap slaves 	holding node 
attached backlog 	location node inserted 
send command 	store node 
every 	location type bits 
slave needed 	skip concatenation 
pre computed 	entry unpack entry 
command command 	unpack restart 
backlog send 	insert non 
slaves write 	matching leaf node 
command 	skip insertion 
replication backlog 	empty note free 
multi bulk 	entire notes 
reply length 	data contained given 
need feed 	fall convert 
buffer bulk 	sha hex corresponding 
reply 	sha hex 
plain create 	sha segment ascii 
crlf payload 	hex format 
len crlf 	hex len length 
write command 	segment must 
every slave 	multiple sha sha 
feed 	written sha 
slaves still 	len max bytes 
waiting bgsave 	store sha 
start feed 	must hex len 
slaves waiting 	returns error 
initial sync 	invalid arguments 
commands 	invalid sha hex 
queued output 	format otherwise 
buffer initial 	returns number bytes 
sync completes 	written sha 
already sync 	hex len pads 
master multi 	sha sha 
bulk 	len included returned 
length additional 	length note 
argument stored 	takes ownership path 
inside buffer 	nothing sorts 
argc feed 	first non note 
slave replication 	sorts equal 
backlog 	overwrite sorts next 
starting specified 	entry path 
offset end 	sha sha complete 
backlog compute 	len note 
amount bytes 	sha incomplete len 
need discard 	current component 
point 	consists hex 
oldest actaully 	chars note subtree 
server repl 	subtree determine 
backlog discard 	full path non 
amount data 	note entry 
seek specified 	filename already found 
offset 	entry path 
feed slave 	directory part path 
data since 	must deduced 
circular buffer 	subtree containing entry 
split reply 	overall notes 
two parts 	follows strict progressive 
cross 	fanout structure 
boundary offset 	etc fanouts fanout 
provide reply 	means non 
psync command 	note found path 
received slave 	dead beef 
returned valid 	following code 
immediately 	found beef hand 
bgsave process 	use non 
started executing 	obvious non note 
command clients 	paths middle 
psync offset 	notes deserve coming 
replication backlog 	note non 
exists 	notes sha like 
created later 	top level 
increment offset 	problems conclude strongly 
one send 	advised make 
fullresync reply 	sure non notes 
specific full 	least one 
resynchronization 	non hex character 
side effect 	top level 
setup slave 	path component determine 
full sync 	optimal disk 
different ways 	fanout part notes 
remember slave 	given sub 
client 	level structure 
structure offset 	determine whether given 
sent slaves 	existing fanout 
later attach 	expanded sub values 
background rdb 	fanout variable 
saving process 	fanout notes stored 
duplicating 	directly root 
client output 	notes fanout fanout 
buffer right 	fanout etc 
offset slave 	following simple heuristic 
replication state 	works well 
slave wait 	practice even numbered 
bgsave 	level remember 
end start 	disk fanout level 
accumulating differences 	corresponds two 
point force 	levels peek entries 
replication stream 	level either 
emit statement 	nodes subtree entries 
slave 	likely plenty 
incremental differences 	notes level 
start selecting 	incremented fanout hex 
right database 	sha nul 
number normally 	recurse node subtree 
function called 	entries note 
immediately 	represent parts note 
successful bgsave 	yet explored 
replication started 	direct relationship subtree 
one already 	entries level 
progress attached 	fanout variable subtree 
slave going 	entries level 
accumulate 	fanout preserved since 
incremental changes 	correspond exactly 
slave well 	fanout directory disk 
slaveseldb order 	structure however 
force emit 	subtree entries level 
sleect statement 	fanout preserved 
replication 	rather consolidated notes 
stream send 	level achieve 
reply slaves 	unconditionally unpacking 
approached old 	subtree entries exist 
sync command 	threshold level 
function handles 	fanout invoke callback 
psync 	subtree create 
command point 	trailing slash needed 
view master 	unpack subtree 
receiving request 	resume traversal path 
resynchronization success 	subtree next 
otherwise err 	entries per determine 
returned 	common part 
proceed usual 	write stack tws 
full resync 	point last 
runid master 	matching write stack 
advertised wannabe 	entry start 
slave via 	subtrees needed satisfy 
psync 	path directory 
runid changed 	components given 
master different 	path given entry 
instance way 	current nothing 
run used 	prefer note non 
slaves want 	note subtree 
force 	entry weave non 
full resync 	note entries 
still data 	note entries nothing 
slave asking 	note failed 
reached point 	find prune note 
able perform 	read note 
resync 	blob objects separate 
client state 	notes two 
make slave 	newlines anyway concatenate 
inform client 	cur msg 
send backlog 	msg buf create 
data offset 	blob buf 
end 	lines named list 
slave use 	trailing newlines 
connection buffers 	removed read 
since used 	sha file nul 
accumulate commands 	terminates last 
stage sure 	line file eol 
socket 	terminated empty 
send buffer 	list removed later 
empty write 	along empty 
never fail 	came empty lines 
actually note 	within file 
need selected 	read note blob 
server 	objects unique 
slaveseldb force 	lines create blob 
master emit 	sort uniq 
since slave 	list list argument 
already state 	must strdup 
previous connection 	core notes config 
master 	note removed 
caller full 	prepare traversal current 
resync needed 	notes last 
need full 	forward entry 
resync reason 	list grounded entries 
note reply 	write objects 
psync 	representing current notes 
right full 	fill given 
sync needed 	strbuf notes associated 
reply must 	given given 
include master 	notes structure initialized 
offset time 	initialized see 
rdb 	documentation init notes 
file transfer 	given notes 
generated need 	notes used instead 
delay reply 	raw gives 
moment start 	userformat otherwise note 
bgsave replication 	message given 
goals 	human consumption end 
selecting disk 	annotation newline 
socket target 	anyway happy fallback 
depending configuration 	expand notes 
making sure 	builtin git 
script cache 	notes copyright johan 
flushed 	herland johan 
start mincapa 	herland net git 
argument bitwise 	notes johannes 
among slaves 	schindelin builtin tag 
capabilities slaves 	kristian gsberg 
waiting bgsave 	carlos rica invoke 
represents 	git show 
slave capabilities 	stat notes write 
slaves support 	message editing 
tested via 	redirect edit subcommand 
slave capa 	end none 
macros side 	given original args 
effects 	therefore still 
starting bgsave 	argv append buf 
handle slaves 	previous note 
wait start 	contents git notes 
state preparing 	merge git 
full sync 	notes merge 
bgsave 	call notes merge 
succesfully started 	abort git 
sending error 	notes merge worktree 
dropping list 	read merge 
slaves flush 	result git notes 
lua scripting 	merge target 
script 	notes git notes 
cache bgsave 	merge reuse 
actually started 	existing commit message 
returns success 	reflog message 
err otherwise 	skip notes merge 
failed bgsave 	resulted trivially 
slaves 	result sha update 
waiting full 	notes commit 
resynchorinization list 	merge unresolved conflicts 
salves inform 	update git 
error happened 	notes merge 
close connection 	merge result store 
asap 	updated git 
target socket 	notes merge non 
rdb save 	zero conflicts 
slaves sockets 	notes.h cur sha 
already setup 	sha cur 
salves full 	sha sha cur 
resync 	sha sha 
otherwise disk 	cur sha sha 
target flush 	root first 
script cache 	non note prev 
since need 	non note 
slave differences 	update combine notes 
accumulated 	initialized dirty 
without requiring 	notes combine notes 
slaves match 	flags sha 
cached scripts 	note sha combine 
sync psync 	notes sha 
command implemenation 	sha obj 
ignore 	obj force combine 
sync already 	notes flags 
slave monitor 	data result flags 
mode refuse 	use notes 
sync requests 	extra notes refs 
slave link 	opt sha 
master 	output encoding raw 
sync issued 	refs flags 
server pending 	list glob list 
data send 	globs function 
client already 	type combining two 
issued commands 	notes annotating 
need 	adding note annotating 
fresh reply 	existing note 
buffer registering 	caller decide combine 
differences bgsave 	two notes 
current dataset 	decision made passing 
copy slaves 	function following 
needed 	form function 
resynchronization psync 	accepts two sha 
command fails 	existing note 
usual full 	note respectively function 
resynchronization however 	combines notes 
happens master 	whatever way sees 
resynchronization 	fit writes 
already replied 	resulting sha first 
fullresync runid 	sha argument 
offset slave 	cur sha non 
knows runid 	zero indicates 
offset psync 	failure two given 
later 	sha shall 
connection master 	non different either 
lost full 	may sha 
resync needed 	indicates empty non 
increment stats 	existent note 
failed 	resulting sha cur 
psyn runid 	sha sha 
used slaves 	note removed 
force full 	notes combine notes 
resync purpose 	function passing 
albe partially 	combine notes concatenate 
resync 	appends contents 
slave uses 	note contents existing 
sync dealing 	note common 
old implementation 	notes combinators notes 
replication protocol 	encapsulates notes 
like redis 	structure associated notes 
cli 	whenever notes 
slave flag 	pointer required may 
client expect 	pass order 
receive replconf 	use notes need 
ack feedbacks 	pass non 
full resynchronization 	need refer several 
setup 	different notes 
slave one 	trees simultaneously 
waiting bgsave 	notes notes notes 
start following 	used notes 
code paths 	passed init notes 
change state 	first following 
handle 	defined option git 
slave differently 	notes given 
non critical 	git notes environment 
fails bgsave 	variable core 
progress disk 	notes config variable 
target background 	git notes 
save 	refs notes commits 
progress check 	flags controlling 
good one 	behaviour notes initialization 
replication another 	behaviour initialize 
slave registering 	notes specified given 
differences since 	notes notes 
server 	readable notes treeish 
forked save 	notes however 
attach slave 	made writable 
check least 	flag strict names 
capabilities slave 	used initialize 
triggered current 	given notes notes 
bgsave 	structure given 
perfect server 	given git notes 
already registering 	environment variable 
differences another 	used missing notes 
slave right 	used refs 
state copy 	notes commits need 
buffer 	initialize notes 
way need 	structure switching one 
wait next 	notes another 
bgsave order 	must first initialize 
differences bgsave 	notes structure 
progress socket 	calling free notes 
target 	notes pass 
rdb child 	notes initialized combine 
process writing 	notes function 
directly children 	passed becomes 
sockets need 	combine notes function 
wait next 	given notes 
bgsave 	passed combine notes 
order synchronize 	function combine 
bgsave progress 	notes concatenate precondition 
diskless replication 	notes structure 
rdb child 	zeroed achieved memset 
created inside 	notes given 
replication 	note given notes 
cron since 	structure already 
want delay 	exists note given 
start seconds 	sha given 
wait slaves 	combine notes function 
arrive target 	invoked tie 
disk 	given combine notes 
slave capable 	combine notes 
supporting diskless 	function given notes 
replication bgsave 	used passing 
progress start 	note sha 
one replconf 	sha indicates addition 
option 	empty non 
option command 	existent note potentially 
used slave 	expensive unless 
order configure 	already exists note 
replication process 	given sha 
starting sync 	combining note empty 
command 	note given 
currently use 	combine notes function 
command communicate 	results changed 
master listening 	note returns zero 
port slave 	success non 
redis instance 	zero means combine 
master 	notes failed 
accurately list 	important changes made 
slaves listening 	note given 
ports info 	notes structure 
output future 	persistent subsequent call 
command used 	write notes 
order 	returns zero given 
configure replication 	note given 
initiate incremental 	notes structure important 
replication instead 	changes made 
full resync 	note given notes 
number arguments 	structure persistent 
must 	subsequent call write 
odd make 	notes returns 
sure every 	zero note removed 
option corresponding 	note note 
process every 	sha containing note 
option pair 	data given 
ignore 	given notes copy 
capabilities understood 	note one 
master replconf 	another given notes 
ack used 	returns obj 
slave inform 	already note 
master amount 	force otherwise returns 
replication 	non zero 
stream processed 	force given combine 
far command 	notes function 
normal clients 	failed combine obj 
never use 	note obj 
diskless replication 	existing note returns 
need 	zero success 
really put 	important changes made 
slave online 	copy note 
first ack 	given notes structure 
received confirms 	persistent subsequent 
slave online 	call write notes 
ready 	returns zero 
data note 	flags controlling behaviour 
command reply 	note behaviour 
anything replconf 	note traverse every 
getack used 	single note 
order request 	given notes 
ack 	unpacking subtree entries 
asap slave 	along way 
note command 	following flags used 
reply anything 	alter behaviour 
function puts 	dont unpack subtrees 
slave online 	causes note 
state 	unpack recurse subtree 
called slave 	entries traversing 
received rdb 	notes causes notes 
file initial 	within subtrees 
synchronization ready 	passed callback use 
send incremental 	flag want 
stream 	traverse notes want 
commands things 	traverse parts 
put slave 	notes already unpacked 
online state 	includes least 
useless function 	notes added changed 
called state 	subtrees causes 
already 	subtree entries 
online repl 	encountered passed callback 
put online 	recursing subtree 
ack make 	entries note objects 
sure writable 	represent intermediate 
installed since 	directories notes passed 
calling 	callback subtree 
sync command 	entries trailing slash 
disables accumulate 	path callback 
output buffer 	may use differentiate 
without sending 	note entries 
slave update 	subtree entries note 
count 	already unpacked 
good slaves 	subtree entries part 
prevent timeout 	notes therefore 
sending rdb 	yielded flag used 
file send 	together dont 
preamble configured 	unpack subtrees note 
replication 	subtree entry 
process currently 	recurse invoke 
preamble bulk 	specified callback function 
count file 	note given 
form length 	notes callback returns 
fall sending 	nonzero note 
data 	walk aborted callback 
preamble already 	returned note 
transfered send 	hence zero note 
rdb bulk 	indicates notes 
data function 	walked successfully important 
called end 	callback function 
every 	allowed change notes 
background saving 	words following 
replication rdb 	functions invoked current 
transfer strategy 	notes within 
modified disk 	callback note note 
socket way 	copy note 
around 	free notes 
goal function 	write given notes 
handle slaves 	structure database 
waiting successful 	creates encapsulating current 
background saving 	state given 
order perform 	notes stores sha 
non 	result argument 
blocking synchronization 	returns zero success 
schedule bgsave 	non zero 
slaves attached 	failure important changes 
bgsave progress 	made given 
good one 	notes persistent function 
replication 	returned zero 
slave accumulating 	please also remember 
differences argument 	create corresponding 
bgsaveerr background 	commit update appropriate 
saving succeeded 	notes flags 
otherwise err 	controlling operation prune 
passed 	notes annotating 
function type 	non existing 
argument type 	objects given notes 
child terminated 	notes given 
disk socket 	notes associated objects 
target rdb 	longer exist 
disk 	database removed notes 
save prepare 	important changes 
send rdb 	made prune notes 
disk slave 	given notes 
socket otherwise 	structure persistent subsequent 
already rdb 	call write 
slaves 	notes returns zero 
socket transfer 	free initialize 
used diskless 	given notes structure 
replication work 	important changes 
trivial put 	made given notes 
slave online 	since last 
note 	successful call write 
wait replconf 	notes lost 
ack message 	load notes 
slave order 	machinery displaying several 
really put 	notes trees 
online install 	opt specifies additional 
write 	settings displaying 
handler accumulated 	suppress notes indicates 
data transfered 	notes core 
however change 	notes notes display 
replication state 	loaded extra 
asap since 	notes refs may 
slave 	contain list 
technically online 	globs style notes 
timeout otherwise 	display notes 
slave returns 	loaded append notes 
given replication 	given sha 
state handshake 	trees init display 
state 	notes flags 
otherwise avoid 	bitwise combination notes 
master detect 	show header 
slave timing 	notes refname 
loading rdb 	header notes indent 
file initial 	indent notes 
synchronization 	places must call 
send single 	init display 
newline character 	notes function load 
valid protocol 	notes listed 
guaranteed either 	refs output notes 
sent entierly 	terminated refs 
since 	match glob list 
indivisible function 	refs colon 
called two 	separated glob list 
contexts flush 	globs end 
current data 	list empty components 
empty load 	ignored helper 
data 	used parse git 
received rdb 	notes display 
file master 	style environment 
pinging back 	variables expand inplace 
stage best 	note like 
effort callback 	foo notes foo 
used 	refs notes 
empty flushing 	foo similar expand 
away old 	notes check 
data load 	whether located via 
dataset received 	sha first 
master link 	falls back expand 
master 	notes sha 
synchroniziation performed 	fails object.c obj 
function materializes 	hash objs 
master client 	obj hash size 
store server 	idx type 
master starting 	type str len 
specified 	gentle sha 
file descriptor 	obj hash size 
master offset 	sha first 
master old 	obj tmp 
psync capable 	hash size hash 
flag accordingly 	obj sha 
asynchronously 	obj type sha 
read sync 	obj parse 
payload receive 	buffer sha name 
master vars 	sha size 
used hold 	eaten repl buffer 
eof mark 	obj item 
last 	list list list 
bytes received 	obj slopbuf 
form server 	obj name mode 
match reached 	path alloc 
end transfer 	objects entry obj 
repl transfer 	name ent 
size 	want data src 
still read 	dst objects 
bulk length 	name src objects 
master reply 	flags obj 
stage newline 	size strlen 
works ping 	size strncmp die 
order 	sha hash 
take connection 	hash obj hash 
live refresh 	obj hashcmp 
last interaction 	xcalloc insert obj 
timestamp two 	hash free 
possible forms 	hashcpy grow hash 
bulk 	insert obj 
payload one 	hash lookup create 
usual count 	alloc node 
bulk format 	parse die sha 
used diskless 	hex lookup 
transfers master 	replace lookup sha 
know 	file sha 
beforehand size 	info check sha 
file transfer 	signature error 
latter following 	sha hex parse 
format used 	blob buffer 
eof bytes 	lookup blob 
delimiter 	lookup read sha 
end file 	file check 
announced delimiter 	sha signature free 
transmitted delimiter 	error sha 
random enough 	hex parse buffer 
probability collision 	free xmalloc 
actual 	realloc xstrdup xstrdup 
file content 	path free 
ignored repl 	free want release 
transfer size 	entry release 
avoid entering 	entry free strcmp 
code path 	contains name 
next 	release entry obj 
call read 	none obj 
bulk data 	commit obj obj 
mark used 	blob obj 
want detect 	tag numerical 
eof asap 	hash specified sha 
order 	must power 
avoid writing 	please note consistent 
eof mark 	across computer 
file update 	architectures insert obj 
last bytes 	hash table 
check matches 	hash length size 
delimiter 	must power 
last bytes 	collisions simply overflow 
file reached 	next empty 
eof sync 	bucket look record 
data disk 	given sha 
time time 	hash map stored 
otherwise 	obj hash 
end transfer 	found move started 
may suffer 	look need 
big delay 	walk hash table 
memory buffers 	next time 
copied actual 	look increase 
disk 	size hash map 
check transfer 	stored obj 
complete loading 	hash next power 
memory need 	least copy 
readable handler 	existing values hash 
otherwise called 	map note 
recursively 	size must always 
since rdb 	power match 
load call 	hash obj zero 
loop process 	length entry 
events time 	name initialized without 
time non 	requiring malloc 
blocking 	free use empty 
loading setup 	instead allocating 
connected slave 	one free memory 
master link 	associated entry 
restart aof 	result unspecified state 
subsystem finished 	examined iff 
sync 	already contains 
trigger aof 	entry name obstack.c 
rewrite done 	obstack compat 
start appending 	size alignment chunkfun 
file send 	freefun chunk 
synchronous command 	extra size alignment 
master 	chunkfun freefun 
used send 	arg chunk extra 
auth replconf 	length old 
commands starting 	chunk chunk size 
replication sync 	obj size 
command returns 	already obj obj 
sds 	plp obj 
representing result 	plp nbytes compat 
operation error 	symbol call 
first create 	chunkfun obstack alloc 
command send 	failed handler 
master use 	ptr align call 
simple 	chunkfun obstack 
protocol simplicity 	alloc failed 
currently send 	handler ptr align 
simple transfer 	call chunkfun 
command server 	obstack alloc failed 
read reply 	handler ptr 
server 	align ptr align 
resynchronization master 	call freefun 
reconnect cached 	call freefun abort 
master structure 	fxprintf exit 
least issue 	obstack subroutines used 
psync command 	implicitly stack 
order 	macros copyright free 
trigger full 	software foundation 
resync psync 	inc file part 
command order 	gnu library 
obtain master 	gnu library free 
run master 	software redistribute 
replication 	modify terms gnu 
offset function 	lesser general 
designed called 	license published 
sync master 	free software foundation 
following assumptions 	either version 
made pass 	license option later 
function 	version gnu 
already connected 	library distributed hope 
socket function 	useful without 
close file 	warranty without even 
descriptor however 	implied warranty 
successful resynchronization 	merchantability fitness particular 
function 	purpose see 
reuse file 	gnu lesser general 
descriptor server 	license details 
master client 	received copy gnu 
structure function 	lesser general 
split two 	license along gnu 
halves 	library write 
read reply 	free software 
function writes 	foundation inc franklin 
psync command 	street fifth 
socket function 	floor boston usa 
call needed 	note modifying 
read 	file version number 
reply order 	must incremented 
read reply 	whenever callers compiled 
command useful 	old obstack 
order support 	longer properly call 
non 	functions obstack 
blocking operations 	comment code gnu 
write loop 	library actually 
read data 	compiling library installed 
read reply 	library supports 
function returns 	library code part 
psync 	gnu library 
write err 	also included many 
write error 	gnu distributions 
psync wait 	compiling linking 
reply signal 	code waste gnu 
need another 	library especially 
call 	shared library rather 
read reply 	every gnu 
however even 	program understand configure 
read reply 	gnu libc 
function may 	omit files simpler 
psync wait 	source file 
reply 	random thing gnu 
signal insufficient 	library determine 
data read 	alignment malloc really 
complete work 	smart would 
enter loop 	round addresses alignment 
wait function 	fact might 
returns 	less smart round 
psync psync 	addresses much 
command succeded 	rounding prepare copy 
psync fullresync 	block data 
psync supported 	unit machines 
full resync 	copying successive ints 
needed 	work redefine 
master run 	copying unit works 
replication offset 	last resort 
saved psync 	functions allocating room 
supported server 	calling obstack 
understand psync 	chunk alloc jump 
caller 	handler pointed 
fall back 	obstack alloc failed 
sync psync 	handler user 
write err 	defined function either 
error writing 	abort gracefully 
command socket 	use longjump shouldn 
psync 	variable points 
wait reply 	function print abort 
call function 	looong time 
read reply 	ago anyway sure 
notable side 	variable used 
effects side 	non gnu 
effect 	macros avoid multiple 
function call 	evaluation gnu 
function removes 	library still exports 
readable handler 	somebody might 
unless psync 	use define macro 
wait reply 	either calls 
server 	functions traditional malloc 
repl master 	free calling 
initial offset 	calls functions mmalloc 
right according 	mfree adds 
master reply 	extra first argument 
used populate 	state use 
server 	extra arg free 
master structure 	use since 
replication offset 	compilers like mips 
writing half 	compilers allow 
initially repl 	expr initialize 
master initial 	obstack use specify 
offset 	chunk size 
mark current 	size means objects 
master run 	start multiples 
offset valid 	alignment means use 
later able 	chunkfun function 
full resync 	use allocate chunks 
psync 	freefun function 
command offset 	free nonzero successful 
right information 	calls obstack 
propagated client 	alloc failed handler 
structure representing 	allocation fails 
master server 	points chunk size 
master 	gnu malloc 
issue psync 	fit block mhead 
command reading 	extra gnu 
half master 	malloc use values 
may send 	range checking 
empty newlines 	range checking 
receives 	extra bytes won 
psync reply 	missed terribly 
keep connection 	range checking used 
alive full 	larger request 
resync parse 	whole extra bytes 
reply order 	would allocated 
extract 	number irrelevant gnu 
run replication 	malloc suspect 
offset unexpected 	less sensitive size 
condition actually 	request initial 
fullresync reply 	chunk contains empty 
means master 	points chunk 
supports 	size gnu malloc 
psync reply 	fit block 
format seems 	mhead extra gnu 
wrong stay 	malloc use 
safe blank 	values range checking 
master runid 	range checking 
make 	extra bytes 
sure next 	won missed terribly 
psyn fail 	range checking 
going full 	used larger request 
resync discard 	whole extra 
cached master 	bytes would allocated 
structure 	number irrelevant 
resync accepted 	gnu malloc suspect 
replication state 	less sensitive 
accordingly reach 	size request initial 
point received 	chunk contains 
either error 	empty allocate current 
since 	chunk obstack 
master understand 	assumption length bytes 
psync unexpected 	need added 
reply master 	current length length 
psync supported 	allocated copies 
caller cases 	end old chunk 
error 	beginning one 
log unexpected 	compute size 
fired user 	chunk allocate initialize 
turned instance 	chunk compute 
master slaveof 	aligned chunk move 
one must 	existing chunk 
asap 	word time fast 
check errors 	safe sufficiently 
socket send 	aligned used copy 
ping check 	odd remaining 
master able 	bytes one extra 
reply without 	copying unit 
errors 	cross page boundary 
writable readable 	machine strict 
remains registered 	alignment copying units 
wait pong 	copy remaining 
reply send 	bytes one one 
ping check 	copied data 
errors 	old chunk 
timeout take 	free chunk chain 
care receive 	chunk might 
pong command 	contain empty chunk 
accept two 	certainly contains 
replies valid 	empty yet nonzero 
positive 	obj allocated 
pong reply 	obstack debugging use 
check authentication 	program probably 
error note 	losing suppress wmissing 
older versions 	prototypes warning 
redis replied 	want declare obstack 
operation 	debugging addr 
permitted instead 	objects chunk point 
proper error 	previous chunk 
code test 	use rather since 
auth master 	cannot exactly 
required receive 	beginning chunk might 
auth 	empty exactly 
reply slave 	end adjacent 
port master 	chunk free objects 
info command 	obstack including 
list slave 	obj everything allocate 
listening port 	recently obj 
correctly 	obj zero free 
receive replconf 	everything addr 
listening port 	objects chunk point 
reply ignore 	previous chunk 
error redis 	use cannot beginning 
versions support 	chunk empty 
replconf 	address end another 
listening port 	chunk chunks 
inform master 	tell whether current 
capabilities currently 	chunk contains 
send one 	empty may obj 
capability possible 	chunks older 
chain 	versions libc used 
capabilities form 	function obstack 
replconf capa 	free intended 
capa capa 	called non gcc 
master ignore 	compilers feature 
capabilities understand 	available gcc versions 
receive 	later empty 
capa reply 	change yes would 
ignore error 	possible newline 
redis versions 	use fputs must 
support replconf 	happen memory 
capa resynchonization 	exhausted message appears 
cached 	places like 
master slave 	translation reused instead 
resynchronization least 	creating similar 
use psync 	requires separate translation 
start full 	elide code 
resynchronization master 	obstack.h limit prev 
run 	contents chunk 
offset resync 	size chunk next 
next reconnection 	free chunk 
attempt reached 	limit tempint 
point repl 	tempptr alignment mask 
state receive 	obstack chunk 
psync 	extra arg obstack 
later note 	obstack obstack 
psync wait 	obstack obstack obstack 
reply take 	stack macros 
care uninstalling 	copyright free software 
read handler 	foundation inc 
file 	file part gnu 
descriptor psync 	library gnu 
failed supported 	library free software 
want slaves 	redistribute modify 
resync well 	terms gnu lesser 
chained replication 	general license 
mater 	published free software 
may transfer 	foundation either 
entirely different 	version license option 
data way 	later version 
incrementally feed 	gnu library 
slaves force 	distributed hope useful 
slaves 	without warranty 
resync well 	without even implied 
allow chained 	warranty merchantability 
slaves psync 	fitness particular purpose 
fall back 	see gnu 
sync needed 	lesser general license 
otherwise 	details received 
psync result 	copy gnu lesser 
psync fullresync 	general license 
server repl 	along gnu library 
master runid 	write free 
repl master 	software foundation inc 
initial 	franklin street 
offset already 	fifth floor boston 
populated prepare 	usa summary 
suitable temp 	apparent functions 
file bulk 	defined macros idea 
transfer setup 	would use 
non 	pre tested macros 
blocking download 	solve specific 
bulk file 	problems would run 
handle send 	fast caution 
synchronous command 	side effects arguments 
sync cmd 	please may 
write 	evaluated many times 
errors function 	macros operate 
called non 	stack objects starts 
blocking connection 	life small 
currently progress 	may grow maturity 
undo never 	consider building 
call 	word syllable syllable 
function directly 	move growing 
use cancel 	finished never changes 
replication handshake 	address top 
instead abort 	stack typically 
download bulk 	immature growing rest 
dataset 	stack mature 
sync ing 	size address objects 
master never 	routines grab 
call function 	large chunks memory 
directly use 	function supply 
cancel replication 	called obstack chunk 
handshake 	alloc occasion 
instead function 	free chunks calling 
aborts non 	obstack chunk 
blocking replication 	free must define 
attempt one 	declare obstack 
progress canceling 	macros independent stack 
non 	represented obstack 
blocking connect 	obstack macros expects 
attempt initial 	pointer structure 
bulk transfer 	first argument one 
replication handshake 	motivation problem 
progress returned 	growing symbol 
replication 	tables unless fascist 
state server 	pig read 
repl state 	mind gosper immortal 
repl state 	quote hakmem 
connect otherwise 	item context would 
zero returned 	like put 
operation 	arbitrary upper limit 
perforemd replication 	length symbols 
specified master 	practice often means 
address port 	build many 
clients blocked 	symbols symbols time 
master slave 	reading symbol 
force 	know one traditional 
slaves resync 	method read 
well psync 	symbol buffer realloc 
allow chained 	ating buffer 
slaves psync 	every time read 
cancel replication 	symbol longer 
setting 	buffer beaut 
instance master 	still want copy 
nothing instance 	symbol buffer 
turned master 	permanent symbol table 
slaves inherits 	entry say 
replication offset 	half time obstacks 
master 	work differently 
certain conditions 	use one obstack 
makes replicas 	symbol names 
comparable replication 	read symbol grow 
offset understand 	name obstack 
updated function 	gradually name complete 
called 	finalize symbol 
slave lose 	exists already free 
connection master 	newly read 
unexpected way 	name way take 
lost connection 	large chunk 
master disconnect 	allocating memory 
slaves 	low addresses want 
yet maybe 	build symbol 
able psync 	chunk chars current 
master later 	high water 
disconnect slaves 	mark chunk finished 
full resync 	adding chars 
master 	got end symbol 
slaveof allowed 	know chars 
cluster mode 	create mostly chars 
replication automatically 	burst highest 
configured current 	address chunk would 
address master 	typically expect 
node 	chunk say times 
special host 	average isn 
port combination 	clear enough chars 
one turns 	make already 
instance master 	contiguous chunk guaranteed 
otherwise master 	point lies 
address 	moving chars 
check already 	needed second win 
attached specified 	potentially need 
slave previous 	never explicitly shuffled 
master user 	formed change 
specified different 	address lifetime chars 
one 	burst chunk 
role command 	boundary allocate larger 
provide information 	chunk copy 
role instance 	partly formed end 
master slave 	old chunk 
additional information 	beginning larger chunk 
related 	carry accreting 
replication easy 	characters end normally 
process format 	would special 
send replconf 	macro provided single 
ack command 	time growing 
master inform 	allows use variables 
current 	ordinary growth 
processed offset 	macro summary 
connected master 	allocate large chunks 
command effects 	carve one 
master caching 	time current chunk 
psync order 	carved never 
implement 	moves free append 
synchronization need 	data size 
able cache 	currently growing exactly 
master client 	one growing 
structure disconnection 	obstack one time 
cached server 	run one 
cached 	obstack per control 
master flushed 	block may 
away following 	many control blocks 
functions function 	dare way 
called free 	unwind obstack back 
client order 	previous state 
cache 	may objects much 
master client 	would stack 
structure instead 	contents file 
destryoing free 	need type pointer 
client asap 	subtraction ptrdiff 
function returns 	type defined gnu 
every 	use way 
action needed 	pollute stddef symbols 
avoid problems 	otherwise include 
client really 	stddef use ptrdiff 
suspended done 	addressed result 
function functions 	aligning next multiple 
deal 	must type 
cached master 	must power similar 
replication discard 	bptr align 
cached master 	optimize common pointers 
make sure 	converted integers 
kill client 	aligned integers converted 
reason 	back ptr 
want use 	type narrower 
future replication 	pointer play safe 
resurrect cached 	compute alignment 
master used 	relative otherwise use 
successful psync 	faster strategy 
handshake 	computing alignment relative 
order reactivate 	lives front 
cached master 	chunk past end 
unlink client 	chunk address 
server structures 	prior chunk objects 
save master 	begin control 
server 	current current chunk 
master later 	preferred size 
replication handle 	allocate chunks address 
master disconnection 	current obstack 
invalidate peer 	chunk address building 
cache caching 	next current 
master 	address current chunk 
happens instead 	temporary macros 
actual free 	mask alignment 
client call 	prototypes vary use 
make sure 	extra arg 
adjust replication 	use casts prototypeless 
state 	function type 
function also 	assignments prototypes quiets 
server master 	wstrict prototypes 
free cached 	first arg chunk 
master called 	alloc dealloc 
longer conditions 	funcs chunk alloc 
resync 	dealloc funcs 
reconnection turn 	take extra arg 
cached master 	possibility current 
current master 	chunk contains zero 
file descriptor 	length prevents 
passed argument 	freeing chunk allocate 
socket 	bigger chunk 
master function 	replace longer used 
called successfully 	call failed 
setup resynchronization 	handler error 
stream data 	retained binary compatibility 
receive start 	declare external 
master 	functions use obstack 
left list 	error handler 
clients close 	called obstack chunk 
asap may 	alloc failed 
also need 	allocate memory user 
install write 	defined function 
handler 	either abort gracefully 
well pending 	use longjump 
data write 	shouldn action print 
buffers close 	message abort 
asap min 	pointer beginning allocated 
slaves write 	allocated next 
function 	note might address 
counts number 	chunk might 
slaves lag 	needed hold size 
min slaves 	size allocating 
max lag 	ordinary chunks 
option 	pointer next yet 
active server 	allocated current 
prevent writes 	chunk mask specifying 
enough connected 	low bits 
slaves specified 	clear address prevent 
lag less 	prototype warnings 
replication 	provide complete argument 
script cache 	list next 
goal code 	step really gcc 
keep track 	defines gnuc 
scripts already 	implement extension compiler 
sent every 	doesn define 
connected 	gnuc minor gnu 
slave order 	traditional define 
able replicate 	macros compute args 
evalsha without 	without variable 
translating eval 	also avoid temp 
every time 	slot make 
possible 	faster code 
use capped 	obstack alignment good 
collection implemented 	enough pointers 
hash table 	ints data added 
fast lookup 	far current 
scripts send 	shares much alignment 
evalsha 	local variable 
plus linked 	named avoid name 
list used 	conflict obstack 
eviction oldest 	blank called gnuc 
entry max 	stdc note 
number items 	call obstack newchunk 
reached 	enclosed avoid 
care taking 	expressions arms conditional 
different cache 	expression casting 
every different 	third operand tried 
slave since 	compilers won 
fill cache 	accept gnuc 
costly 	stdc obstack pack-bitmap-write.c 
goal code 	commit bitmap 
avoid big 	write flags xor 
script trasmitted 	offset commit 
big number 	pos commits trees 
times per 	blobs tags 
second 	bitmaps reused pack 
wasting bandwidth 	selected selected 
processor speed 	selected alloc progress 
problem need 	show progress 
rebuild cache 	pack checksum writer 
scratch time 	show index 
time 	index entry seen 
every used 	objects seen 
script need 	objects seen objects 
transmitted single 	alloc commit 
time reappear 	reused sha entry 
cache system 	name data 
works 	commit data 
every time 	commit hash pos 
slave connects 	bitmap pos 
flush whole 	commit data parent 
script cache 	max xor 
send evalsha 	offset search next 
sent 	stored best 
master evalsha 	offset best bitmap 
without trying 	test xor 
convert eval 	curr pack reuse 
evalsha specifically 	bitmap threshold 
slaves every 	reuse need reset 
time 	revs stored 
trasmit script 	hash pos hash 
eval slaves 	ret idx 
also corresponding 	min commits max 
sha script 	commits must 
cache sure 	region min region 
every 	offset next 
slave knows 	pack sha 
script starting 	hash pos indexed 
script flush 	commits indexed 
command replicate 	commits max bitmaps 
command slaves 	next reused 
time 	bitmap chosen buf 
flush script 	len bitmap 
cache last 	pos table index 
slave disconnects 	index index 
flush cache 	stored commit pos 
handle script 	index index 
load 	entry hash sha 
well since 	index index 
scripts loaded 	filename options tmp 
master sometimes 	file version 
initialize script 	flags header ewah 
cache called 	ewah ewah 
startup 	ewah sha info 
empty script 	ewah ewah 
cache called 	ewah ewah 
every time 	die sha hex 
longer sure 	realloc alloc 
every slave 	grow packlist find 
knows 	die sha 
scripts current 	hex bitmap find 
aof context 	pos mark 
longer aware 	seen mark seen 
script general 	find pos 
flush cache 	bitmap sha end 
every 	bitmap ewah 
time slave 	bitmap include mark 
reconnects master 	seen mark 
performs full 	seen ewah pool 
sync psync 	ewah xor 
require flushing 	ewah pool free 
every 	ewah pool 
time aof 	free bitmap 
rewrite performed 	init sha start 
every time 	progress init 
left without 	revisions reset revision 
slaves aof 	walk merge 
order 	bases bitmap reset 
reclaim otherwise 	reset seen 
unused memory 	pending prepare revision 
entry script 	walk die 
cache reach 	traverse commit list 
max number 	bitmap ewah 
entries 	put sha die 
oldest removed 	oid hex 
list evict 	display progress bitmap 
oldest current 	free stop 
returns non 	progress compute xor 
zero specified 	offsets prepare 
entry 	bitmap git init 
exists inside 	sha rebuild 
cache slaves 	existing bitmaps 
aware script 	sha end qsort 
sha synchronous 	start progress 
replication redis 	push bitmapped commit 
synchronous 	next commit 
replication design 	index find reused 
summarized points 	bitmap find 
redis masters 	reused bitmap push 
replication offset 	bitmapped commit 
used psync 	display progress stop 
master 	progress sha 
increment offset 	write ewah serialize 
every time 	die sha 
commands sent 	pos die sha 
slaves slaves 	write sha 
ping back 	write sha write 
masters 	dump bitmap 
offset processed 	htonl sha write 
far synchronous 	hashcpy odb 
replication adds 	mkstemp die 
wait command 	errno sha memcpy 
form wait 	htons htons 
num 	htonl hashcpy sha 
replicas milliseconds 	write dump 
timeout returns 	bitmap dump bitmap 
number replicas 	dump bitmap 
processed query 	dump bitmap write 
least num 	selected commits 
replicas 	write hash cache 
timeout reached 	sha close 
command implemented 	adjust shared perm 
way every 	die errno 
time client 	rename die errno 
processes command 	build initial 
remember 	type index packfile 
replication offset 	compute actual 
sending command 	bitmaps commits bitmapped 
slaves wait 	sha write 
called ask 	die error 
slaves send 	write bitmap index 
acknowledgement 	disk pack-bitmap.c 
asap client 	sha root xor 
blocked time 	flags pack 
see blocked 	reuse objects map 
receive enough 	map size 
given offset 	map pos commits 
timeout 	trees blobs 
reached wait 	tags bitmaps entry 
command unblocked 	count hashes 
reply sent 	objects hashes count 
client flag 	alloc positions 
broadcast replconf 	result version parent 
getack 	composed index 
command slaves 	bitmap size index 
sleep function 	header flags 
note way 	end index 
clients want 	root sha xor 
wait synchronouns 	flags stored 
replication 	hash pos ret 
given loop 	buffer pos 
iteration send 	result buffer pos 
single getack 	index recent 
number slaves 	bitmaps xor offset 
already acknowledged 	flags bitmap 
specified 	xor bitmap commit 
replication offset 	idx pos 
wait replicas 	sha len packfile 
acknowledge processing 	idx name 
latest write 	ret seen sha 
command previous 	positions pos 
commands 	bitmap pos sha 
argument parsing 	offset sha 
first without 	pos name eindex 
blocking otherwise 	hash pos 
block client 	hash ret 
put list 	bitmap pos name 
clients 	data bitmap 
waiting ack 	pos commit data 
slaves make 	data sha 
sure server 	bitmap pos hash 
send ack 	pos commit 
request slaves 	data data bitmap 
returning 	pos parent 
loop called 	revs roots seen 
unblock client 	needs walk 
perform blocking 	mapped pos pos 
type specific 	incdata objects 
cleanup client 	show reach eindex 
list 	obj show 
clients waiting 	objects type roots 
replica acks 	revs pending 
never call 	pending wants haves 
directly call 	wants bitmap 
unblock client 	haves bitmap 
instead 	tag packfile entries 
check clients 	reuse percent 
blocked wait 	result reuse threshold 
unblocked since 	reuse objects 
received enough 	sha entry show 
slaves every 	reachable count 
time 	type commits trees 
find client 	blobs tags 
satisfied given 	prg seen name 
offset number 	data tdata 
replicas remember 	bitmap pos commit 
next client 	data tdata 
may 	bitmap pos revs 
unblocked without 	root result 
calling replication 	pos result popcnt 
count acks 	tdata reposition 
offset requested 	source dest pos 
offset replicas 	word offset 
equal 	bit pos 
less slave 	mapping reused bitmaps 
replication offset 	show progress 
instance offset 	num objects reposition 
already processed 	rebuild stored 
master replication 	progress hash pos 
stream 	hash ret 
offset may 	sha entry ewah 
master support 	pool lookup 
however function 	stored bitmap ewah 
designed offset 	xor ewah 
express amount 	pool free ewah 
data 	pool ewah 
processed master 	read mmap error 
positive integer 	ewah pool 
replication cron 	free error memcmp 
replication cron 	error ntohs 
function called 	error ntohs error 
time 	ntohl xmalloc 
per second 	hashcpy put 
non blocking 	sha error sha 
connection timeout 	hex read 
bulk transfer 	read read nth 
timeout timed 	packed sha 
master 	read bitmap error 
already connected 	error store 
slave check 	bitmap strip suffix 
connect master 	die xstrfmt 
send ack 	open pack index 
master time 	pack bitmap 
time 	filename git open 
note send 	noatime free 
periodic acks 	fstat close warning 
masters support 	close xsize 
psync replication 	xmmap close load 
offsets attached 	bitmap header 
slaves 	munmap init 
ping time 	sha init sha 
time slaves 	pos load 
implement timeout 	pack revindex read 
masters able 	bitmap read 
detect link 	bitmap read bitmap 
disconnection 	read bitmap 
even tcp 	load bitmap entries 
connection actually 	munmap prepare 
first send 	packed git open 
ping according 	pack bitmap 
ping slave 	open pack bitmap 
period 	load pack 
second send 	bitmap sha pos 
newline slaves 	end find 
pre synchronization 	pack entry one 
stage slaves 	find revindex 
waiting master 	position bitmap position 
create 	packfile bitmap 
rdb file 	position extended 
newline ignored 	put sha pos 
slave refresh 	realloc realloc 
last timer 	pack name hash 
preventing timeout 	bitmap position 
ignore 	ext index bitmap 
ping period 	bitmap bitmap 
refresh connection 	sha end bitmap 
per second 	ewah lookup 
since certain 	stored bitmap bitmap 
timeouts seconds 	bitmap position 
example 	ext index include 
psync response 	sha end 
worry ping 	lookup stored bitmap 
disconnect timedout 	ewah bitmap 
slaves attached 	bitmap ewah list 
slaves replication 	insert bitmap 
backlog 	position bitmap pending 
memory free 	bitmap prepare 
configured time 	revision walk 
aof disabled 	die traverse commit 
longer attached 	list bitmap 
slaves free 	show reach find 
replication 	pack entry 
script cache 	one open pack 
need propagate 	bitmap parse 
evalsha diskless 	die list insert 
replication slaves 	list insert 
waiting wait 	die parse die 
bgsave 	list insert 
start state 	list insert bitmapped 
check enough 	pack load 
seconds elapsed 	pack bitmap find 
start bgsave 	objects reset 
code also 	revision walk die 
useful 	find objects 
trigger bgsave 	die bitmap bitmap 
diskless replication 	free ewah 
turned config 	bit ctz 
already slaves 	nth packed sha 
wait bgsave 	sha hex 
start 	bitmap popcount show 
state start 	objects type 
bgsave usually 	show objects type 
socket target 	show objects 
disk target 	type show objects 
recent socket 	type show 
disk 	extended objects bitmap 
config change 	free count 
refresh number 	type count type 
slaves lag 	count type 
min slaves 	count type bitmap 
max lag 	position die 
incremented 	oid hex bitmap 
frequency rio.c 	display progress 
buf len 	bitmap position 
buf len 	die oid hex 
rio buffer 	bitmap display 
buf len 	progress prepare bitmap 
retval 	git die 
buf len 	die sha end 
rio file 	lookup stored 
buf len 	bitmap oid hex 
retval doflush 	ewah checksum 
count broken 	ewah bitmap die 
nwritten 	oid hex 
buf len 	bitmap popcount prepare 
rio fdset 	revision walk 
fds numfds 	die bitmap start 
buf len 	progress traverse 
bytes prefix 	commit list stop 
count 	progress bitmap 
cbuf clen 	bitmap free ewah 
buf len 	iterator init 
nwritten lbuf 	ewah iterator 
llen dbuf 	next ewah bit 
dlen sdscatlen 	ctz bitmap 
sdslen 	prepare bitmap git 
memcpy unused 	xcalloc nth 
fwrite fflush 	packed sha packlist 
aof fsync 	find bitmap 
fileno fread 	start progress stop 
ftello fflush 	progress free 
sdscatlen 	bitmap free entry 
sdslen sdslen 	bitmap index 
write sdsclear 	representing bitmap given 
unused unused 	commit currently 
unused rio 	active bitmap index 
fdset write 	design repositories 
zmalloc 	single bitmap index 
zmalloc memcpy 	available index 
sdsempty zfree 	biggest packfile repository 
zfree sdsfree 	since bitmap 
crc server 	indexes need 
rio write 	full closure one 
rio 	bitmap index 
write bulk 	available alternates active 
count rio 	bitmap index 
write rio 	largest one packfile 
write rio 	bitmap index 
write bulk 	belongs mark first 
snprintf 	reuse objects 
rio write 	packfile reused sent 
bulk rio 	without repacking 
simple stream 	calculations mmapped buffer 
oriented abstraction 	whole bitmap 
provides write 	index size mmaped 
code 	buffer current 
consume produce 	position loading index 
data different 	type indexes 
concrete input 	bitmap marks objects 
output devices 	packfile given 
instance rdb 	type provides 
code 	type information yielding 
rio abstraction 	objects packfile 
used read 	walk allows better 
write rdb 	delta bases 
format memory 	map sha stored 
buffers files 	bitmap bitmapped 
rio 	commits number bitmapped 
provides following 	commits name 
methods read 	hash cache present 
read stream 	extended index 
write write 	trying perform bitmap 
stream tell 	operations objects 
current 	packed pack objects 
offset also 	added fake 
possible checksum 	index assumed appear 
method used 	end packfile 
rio order 	operations bitmap 
compute checksum 	result last performed 
data 	walk version 
written read 	bitmap index read 
query rio 	bitmap current 
current checksum 	read position mmaped 
copyright pieter 	index increase 
noordhuis 	read position accordingly 
pcnoordhuis gmail 	parse known 
dot copyright 	bitmap format options 
salvatore sanfilippo 	code means 
antirez gmail 	insertion succeeded changes 
dot rights 	sha already 
reserved 	existed map bad 
redistribution use 	shouldn duplicated 
source binary 	commits index roots 
forms without 	walk ones 
modification permitted 	bitmaps bitmap index 
provided following 	together form 
conditions 	initial reachability 
met redistributions 	analysis ones without 
source code 	bitmaps index 
must retain 	stored mapped list 
copyright notice 	processing best 
list conditions 	scenario found bitmaps 
following 	roots resulting 
disclaimer redistributions 	bitmap full reachability 
binary form 	analysis iterate 
must reproduce 	roots bitmaps check 
copyright notice 	determine reachable 
list conditions 	existing bitmap cannot 
following 	find existing 
disclaimer documentation 	bitmap need push 
materials provided 	actual walk 
distribution neither 	run confirm reachable 
name redis 	open bitmapped 
names contributors 	pack parse yet 
may 	may need 
used endorse 	use haves 
promote products 	list none haves 
derived software 	contained packfile 
without specific 	bitmap anything optimize 
prior written 	want anything 
permission 	done going use 
software provided 	bitmaps load 
copyright holders 	actual bitmap entries 
contributors express 	disk point 
implied warranties 	rev list becomes 
including limited 	invalidated must 
implied 	perform revwalk bitmaps 
warranties merchantability 	reuse packfile 
fitness particular 	content need objects 
purpose disclaimed 	reuse full 
shall copyright 	pack reuse pack-bitmap.h 
owner contributors 	magic version 
liable 	options entry count 
direct indirect 	checksum bitmap 
incidental special 	idx signature 
exemplary consequential 	commits trees blobs 
damages including 	tags show 
limited procurement 	reachable revs revs 
substitute 	packfile entries 
goods services 	mapping reused bitmaps 
loss use 	show progress 
data profits 	show sha index 
business interruption 	index pack 
however caused 	indexed commits indexed 
theory 	commits max 
liability whether 	bitmaps pack index 
contract strict 	index filename 
liability tort 	options pack-check.c offset 
including negligence 	sha entry 
otherwise arising 	entry curs offset 
way 	len index 
use software 	crc data crc 
even advised 	avail data 
possibility damage 	curs progress 
buffer implementation 	count index size 
returns success 	index ctx 
failure 	sha pack sig 
returns success 	pack sig 
failure enough 	ofs objects err 
buffer len 	entries remaining 
bytes returns 	data size offset 
read write 	len eaten 
position 	index size index 
buffer flushes 	ctx sha 
buffer target 	err progress count 
device applicable 	err curs 
returns success 	crc use pack 
failures nothing 	crc ntohl 
write 	git sha init 
appends buffer 	use pack 
update checksum 	git sha 
current checksum 	update git sha 
bytes read 	use pack 
written read 	hashcmp error hashcmp 
write 	error unuse 
chunk size 	pack alloc nth 
specific vars 	packed sha 
stdio file 	die nth packed 
pointer implementation 	offset qsort 
returns success 	check pack crc 
failure 	error sha 
returns success 	hex unpack entry 
failure returns 	error sha 
read write 	hex check sha 
position file 	signature error 
flushes buffer 	sha hex display 
target 	progress free 
device applicable 	display progress free 
returns success 	open pack 
failures update 	index error 
checksum current 	git sha init 
checksum bytes 	git sha 
read 	update git sha 
written read 	hashcmp error 
write chunk 	verify pack index 
size specific 	verify packfile 
vars file 	unuse pack note 
descriptors implementation 	pack header 
returns 	checks actually performed 
success failure 	use pack 
function returns 	first opens pack 
success able 	file anything 
correctly write 	goes wrong checks 
least one 	call die 
file 	immediately make sure 
descriptor buf 	everything reachable 
adn len 	idx valid since 
function performs 	verified objects 
flush operation 	matches idx 
pending buffer 	pack scan streaming 
function 	check pack 
also used 	file first sort 
order implement 	entries pack 
rio fdset 	offset since unpacking 
flush start 	efficient way 
always append 	verify sha sum 
buffer 	index file 
gets larger 	pack-objects.c pdata sha 
given size 	found mask 
actually write 	pos pdata entry 
sockets prevent 	found pdata 
entering belove 	sha index pos 
flush 	found pdata 
write little 	sha index pos 
chunchs big 	entry sha 
writes parallelize 	hash hashcmp closest 
kernel sending 	pow free 
data background 	xcalloc locate 
tcp 	entry hash die 
socket skip 	locate entry 
alraedy error 	hash realloc memset 
make sure 	hashcpy rehash 
write count 	objects objects going 
bytes socket 	pack collected 
regardless 	pack structure contains 
writes blocking 	dynamically expanded 
sockets sole 	data map resolve 
user rio 	sha position 
target ewouldblock 	stats indexed commits 
returned sndtimeo 	nothing going 
socket 	reuse existing data 
option translate 	make sure 
error one 	corrupt bust pack 
recognizable user 	size limit 
mark broken 	make sure 
error returns 	cached delta data 
success 	remains previous 
failure error 	attempt pack split 
target support 	occurred large 
reading returns 	blob compress well 
read write 	header type 
position file 	followed zero bytes 
flushes 	length deltas 
buffer target 	relative contain additional 
device applicable 	encoding relative 
returns success 	offset delta position 
failures flush 	pack deltas 
implemented write 	reference contain additional 
method 	bytes sha 
recognizes buffer 	bust pack size 
count zero 	limit bust 
flush request 	pack size limit 
update checksum 	apply size 
current checksum 	limit limited 
bytes 	packsize first earlier 
read written 	fit limit 
read write 	avoid mistaking unlimited 
chunk size 	limit delta 
specific vars 	unlimited packfile written 
functions function 	another pack 
installed 	already exists pack 
memory file 	could end 
streams checksum 	another pack reuse 
computation needed 	check decided 
file rio 	pack split may 
fsync every 	pack delta 
bytes 	unusable want pack 
file written 	afresh pack 
zero means 	undeltified need deltify 
automatic file 	already written 
sync performed 	writing bust limit 
feature useful 	written normal 
contexts 	already scheduled 
since rely 	written offset impossible 
write buffers 	mark fact 
sometimes buffers 	involved write first 
way much 	writing deltified 
resulting many 	recursion offset non 
disk 	zero written 
concentrated little 	already deltified write 
time fsync 	first recurse 
way instead 	cannot depend one 
pressure distributed 	make sure 
across time 	sufficiently large wrap 
higher 	node siblings 
level following 	drop level left 
higher level 	subtree nodes 
functions use 	possible sibling might 
lower level 	children next 
rio functions 	back parent node 
help 	right side 
generating redis 	subtree keep 
protocol append 	going right done 
file write 	hit original 
multi bulk 	root node pass 
count format 	sibling level 
count 	nothing fully connect 
write binary 	delta child 
safe format 	delta sibling network 
count payload 	make sure 
write format 	delta sibling sorted 
count payload 	original recency 
write 	order mark first 
format count 	child mark 
payload rio.h 	objects tip tags 
rio buf 	give objects 
len rio 	original recency order 
buf len 	see tagged 
rio 	tip fill 
rio rio 	tagged tips remaining 
buf len 	commits tags 
cksum processed 	trees rest really 
bytes max 	tight order 
processing chunk 	know actual number 
ptr 	objects written 
pos buffered 	many bytes written 
autosync fds 	many bytes 
state numfds 	total many objects 
pos buf 	total fake 
buf len 	pretending objects writing 
bytes 	size gives 
write buf 	smooth progress meter 
len bytes 	end matches 
read fds 	answer write wrong 
numfds prefix 	entries header 
count buf 	rewrite like fast 
len 	packs runtime 
buf len 	accessed mtime 
bytes update 	order since newer 
cksum write 	packs likely 
read update 	contain younger objects 
cksum tell 	creating multiple 
flush 	packs modify mtime 
copyright pieter 	later ones 
noordhuis pcnoordhuis 	preserve mark written 
gmail dot 	objects written 
copyright salvatore 	previous pack adding 
sanfilippo antirez 	check whether 
gmail 	already added packing 
dot rights 	list skip 
reserved redistribution 	however asked excludei 
use source 	previous mention 
binary forms 	include make sure 
without modification 	adjust flags 
permitted 	tweak numbers accordingly 
provided following 	optimization pass 
conditions met 	index position 
redistributions source 	would found item 
code must 	since saves 
retain copyright 	look lines later 
notice 	want entry 
list conditions 	check whether want 
following disclaimer 	pack want 
redistributions binary 	objects found non 
form must 	local stores 
reproduce copyright 	local option used 
notice 	side effect 
list conditions 	check find packed 
following disclaimer 	version therefore 
documentation materials 	pass pack information 
provided distribution 	avoid look 
neither name 	later pack missing 
redis 	closure phony 
names contributors 	cache entry going 
may used 	evict find 
endorse promote 	mechanism toplevel 
products derived 	node would almost 
software without 	always change 
specific 	commit pbase cache 
prior written 	acts limited 
permission software 	hashtable found index 
provided copyright 	within slots 
holders contributors 	slot cached find 
express implied 	one either 
warranties 	got bogus request 
including limited 	need read 
implied warranties 	perhaps cache need 
merchantability fitness 	either cache 
particular purpose 	throwaway copy evict 
disclaimed shall 	reuse want 
copyright 	pack type even 
owner contributors 	reuse delta 
liable direct 	since non delta 
indirect incidental 	representations could 
special exemplary 	still reused 
consequential damages 	determine delta whether 
including 	reuse otherwise 
limited procurement 	find cheaply possible 
substitute goods 	actual type 
services loss 	size delta hence 
use data 	already got 
profits business 	need means wish 
interruption 	reuse delta 
however caused 	data even found 
theory liability 	list objects 
whether contract 	want pack goodie 
strict liability 	depth matter 
tort including 	find deltas never 
negligence 	consider reused 
otherwise arising 	delta deltify objects 
way use 	order avoid 
software even 	circular deltas 
advised possibility 	must delta already 
damage backend 	know type 
functions 	extract actual size 
since functions 	delta header 
tolerate writes 	choice fall back 
reads simplified 	recursive delta 
zero error 	walk sha info 
non zero 	find type 
complete 	point error condition 
success update 	prepare pack 
cksum method 	permit missing preferred 
used compute 	ignored preferred 
checksum data 	result larger pack 
read written 	file transfer 
far 	still take place 
method designed 	avoid filesystem 
called current 	trashing loose objects 
checksum buf 	search deltas 
len fields 	list sorted 
pointing block 	type filename hash 
data 	size see 
checksum computation 	progressively smaller smaller 
current checksum 	files prefer 
number bytes 	deltas bigger file 
read written 	smaller deletes 
maximum single 	potentially cheaper perhaps 
read 	importantly bigger 
write chunk 	file likely recent 
size backend 	one deepest 
specific vars 	deltas therefore oldest 
memory buffer 	objects less 
target stdio 	susceptible accessed often 
file 	newest first 
pointer target 	cache delta objects 
bytes written 	large enough 
since last 	compared delta size 
fsync fsync 	bother diffs 
autosync bytes 	different types 
written 	bother delta discarded 
multiple target 	earlier reusing 
used write 	delta data note 
sockets file 	src entry 
descriptors error 	marked preferred always 
state errno 	considered even 
following 	produce suboptimal delta 
functions stream 	still save 
call actual 	transfer cost already 
implementation read 	know side 
write tell 	won send src 
update checksum 	entry bust 
needed 	allowed depth size 
rtree.c rtree 	filtering heuristics 
bits alloc 	load data already 
dalloc bits 	done objects 
leaf height 	included resulting pack 
rtree node 	resilient ignore 
level 	read pack 
nchildren child 	could created nevertheless 
rtree subtree 	prefer shallower 
rtree level 	sized deltas handle 
elmp node 	memory allocation 
rtree level 	outside cache accounting 
rtree 	compiler optimize 
elm level 	strangeness away pthreads 
hmin rtree 	defined compute 
subtree dalloc 	delta create objects 
rtree subtree 	going pack 
atomic cas 	current pack edge 
atomic 	take depth 
read alloc 	objects depend current 
atomic write 	account otherwise 
rtree node 	would become deep 
init rtree 	decided cache 
node init 	delta data 
significant 	best compress right 
bits keys 	away first 
passed rtree 	anyway threaded save 
used root 	lot time 
level interior 	non threaded write 
levels leaf 	phase well 
level 	allow caching deltas 
compute lookup 	within cache 
table used 	size limit writing 
rtree start 	stdout since 
level another 	network likely throttling 
already process 	writes anyway 
initializing 	therefore best write 
spin wait 	phase asap 
initialization complete 	instead afford spending 
nelms node 	time compressing 
rtree node 	writes moment made 
node rtree 	delta already 
keys 	max depth 
node rtree 	leaving window pointless 
sfmt keys 	evict first 
node rtree 	move best delta 
calloc free 	window currently 
rtree ptr 	deltified keep longer 
rtree 	first attempted 
rtree rtree 	next main waits 
rtree ptr 	condition least 
rtree rtree 	one workers stopped 
ptr rtree 	working indicated 
rtree rtree 	working member work 
rtree 	completed work 
ptr rtree 	sets working signals 
ptr rtree 	main waits 
rtree rtree 	condition data ready 
init gen 	becomes mutex 
rand 	conditional variable statically 
rtree gen 	initialized windows 
rand rtree 	must data 
ptr rtree 	ready wait condition 
ptr rtree 	main may 
rtree ptr 	order sure work 
rtree 	available see 
ptr rtree 	data ready initialized 
rtree fini 	spawned reset 
gen rand 	right away working 
test significant 	doesn work 
bits keys 	assigned partition work 
passed 	amongst work 
rtree used 	threads use small 
root level 	segments deltas 
interior levels 	found split chunks 
leaf level 	path boundaries 
compute lookup 	start work threads 
table 	wait work 
used rtree 	completion time done 
start level 	work steal 
another already 	half remaining 
process initializing 	work largest number 
spin wait 	unprocessed objects 
initialization 	give newly idle 
complete rtree.c 	ensure good 
rtree bits 	load balancing remaining 
alloc dalloc 	list segments 
bits leaf 	simply worth splitting 
height rtree 	anymore possible 
node 	paths many objects 
level nchildren 	hash boundary 
child rtree 	might found steal 
subtree rtree 	exact half 
level elmp 	tag peelable packed 
node rtree 	locally repacking 
level 	need doubly careful 
rtree elm 	order make 
level hmin 	sure stealth 
rtree subtree 	corruption gets propagated 
dalloc rtree 	pack clients 
subtree atomic 	receiving streamed packs 
cas 	validate everything 
atomic read 	anyway need incur 
alloc atomic 	additional cost 
write rtree 	happens decided reuse 
node init 	existing delta 
rtree node 	pack reuse delta 
init 	implied found 
significant bits 	include anyway compare 
keys passed 	objects offset 
rtree used 	order order emulate 
root level 	git rev 
interior levels 	list objects output 
leaf 	produced pack 
level compute 	originally store list 
lookup table 	sha discarded 
used rtree 	either written 
start level 	recently reachable another 
another already 	filled list 
process 	tracks options reader 
initializing spin 	pack might 
wait initialization 	understand would therefore 
complete nelms 	prevent blind 
node rtree 	reuse disk make 
node node 	sure shallows 
rtree 	read threads means 
keys node 	autodetect pack 
rtree sfmt 	usage pack written 
keys node 	list result 
rtree calloc 	written non empty 
free rtree 	reuse keep 
ptr 	unreachable unpack unreachable 
rtree rtree 	include tag 
rtree rtree 	unpack unreachable expiration 
ptr rtree 	local incremental 
rtree ptr 	ignore packed 
rtree rtree 	keep allow ofs 
rtree 	delta pack 
rtree ptr 	idx opts name 
rtree ptr 	progress window 
rtree rtree 	pack size limit 
rtree init 	depth delta 
gen rand 	search threads pack 
rtree 	stdout num 
gen rand 	preferred progress state 
rtree ptr 	pack compression 
rtree ptr 	level pack compression 
rtree rtree 	seen reuse 
ptr rtree 	packfile reuse packfile 
ptr 	objects reuse 
rtree rtree 	packfile offset use 
fini gen 	bitmap index 
rand test 	write bitmap index 
significant bits 	write bitmap 
keys passed 	options delta 
rtree 	cache size max 
used root 	delta cache 
level interior 	size cache max 
levels leaf 	small delta 
level compute 	size window memory 
lookup table 	limit written 
used 	written delta reused 
rtree start 	reused delta 
level another 	indexed commits indexed 
already process 	commits indexed 
initializing spin 	commits alloc commit 
wait initialization 	entry size 
complete 	size delta size 
rtree.h pun 	buf buf 
child val 	delta buf pptr 
subtree pun 	size stream 
subtree bits 	maxsize sha stream 
cumbits alloc 	ibuf obuf 
dalloc 	olen readlen 
height start 	zret curs offset 
level levels 	len expect 
rtree bits 	stream fakebuf curs 
alloc dalloc 	offset len 
rtree rtree 	avail entry limit 
level 	usable delta 
rtree elm 	size datalen header 
level rtree 	dheader hdrlen 
key rtree 	buf ofs pos 
key level 	entry limit 
node elm 	usable delta curs 
rtree 	revidx offset 
elm level 	datalen header dheader 
rtree elm 	hdrlen ofs 
dependent rtree 	pos entry write 
elm val 	offset limit 
rtree level 	len usable 
rtree 	delta reuse path 
level rtree 	oid flag 
key dependent 	data peeled entry 
rtree key 	endp endp 
val rtree 	order endp root 
key start 	end last 
level 	untagged objects buffer 
rtree key 	write total 
level node 	read pack offset 
elm child 	remaining last 
rtree elm 	mtime write order 
level child 	sha pack 
rtree 	tmp name packfile 
elm dependent 	size tmpname 
rtree elm 	utb check attr 
val rtree 	delta path 
level subtree 	check sha exclude 
rtree level 	index pos 
subtree 	entry sha 
rtree key 	exclude found pack 
dependent subkey 	found offset 
start level 	offset create entry 
node child 	closure warning 
rtree key 	entry entry bitmap 
val 	sha temporary 
subkey start 	data size sha 
level node 	next pcache 
child unlikely 	sha ent nent 
floor rtree 	data size 
node valid 	neigh available cache 
atomic 	name name 
read rtree 	cmplen fullname entry 
child tryread 	cmp sub 
unlikely rtree 	downlen done pbase 
node valid 	paths done 
rtree child 	pbase paths num 
read 	done pbase 
hard atomic 	paths alloc 
read atomic 	hash hash pos 
write rtree 	name cmplen 
node valid 	hash sha data 
atomic read 	size sha 
rtree 	entry curs entry 
subtree tryread 	used used 
unlikely rtree 	avail ofs buf 
node valid 	revidx sorted 
rtree subtree 	offset entry entry 
read hard 	data index 
rtree 	depth src size 
start level 	trg size 
unlikely rtree 	delta size read 
node valid 	mutex cache 
rtree subkey 	mutex progress mutex 
rtree val 	trg src 
read 	max depth mem 
rtree child 	usage trg 
tryread reached 	entry src 
rtree start 	entry trg size 
level rtree 	src size 
subtree read 	delta size sizediff 
rtree 	max size 
subkey rtree 	depth delta buf 
val write 	warned warned 
rtree child 	child freed mem 
read reached 	list list 
radix implementation 	size window depth 
tailored 	processed count 
singular purpose 	mem usage entry 
associating metadata 	max depth 
chunks currently 	best tail ret 
owned jemalloc 	idx swap 
rtree bits 	dist dst src 
per 	size old 
level must 	free routine 
power two 	list list size 
larger machine 	remaining window 
address width 	depth working data 
used two 	ready mutex 
stage 	cond processed progress 
free node 	cond arg 
initialization node 	list list size 
allocation callback 	window depth 
function argument 	processed ret active 
number contiguous 	threads sub 
rtree 	size target victim 
node elm 	sub size 
structures allocate 	path oid flag 
resulting memory 	data peeled 
must zeroed 	window depth delta 
jemalloc types 	list deltas 
non 	entry done level 
subtree points 	line sha 
subtree rooted 	commit data 
along hypothetical 	obj name data 
path leaf 	commit offset 
node corresponding 	alloc pack revs 
key 	pack sha 
depending keys 	sha last found 
used store 	recent objects 
arbitrary combination 	sha mtime revs 
subtree pointers 	sha revs 
may remain 	obj name data 
suppose 	commit data 
keys comprise 	revs line flags 
bits rtree 	len sha 
bits per 	opt arg unset 
level results 	val opt 
level leftmost 	arg unset argc 
leaf 	argv prefix 
directly accessed 	use rev list 
via subtrees 	thin shallow 
subtree prefixed 	progress implied 
excluding accessed 	rev list reflog 
via subtrees 	rev list 
remainder 	index pack objects 
accessed via 	options realloc 
subtrees levels 	read sha file 
unused levels 	die sha 
unused levels 	hex read sha 
val val 	file die 
practical 	sha hex diff 
implications currently 	delta die 
uses lower 	free free git 
bits address 	deflate init 
space userland 	git deflate bound 
thus leaving 	xmalloc git 
subtrees 	deflate git deflate 
unused avoiding 	end free 
level traversal 	git deflate init 
number key 	read istream 
bits distinguished 	die sha 
level cumulative 	hex git deflate 
number 	sha write 
key bits 	die die git 
distinguished traversing 	deflate end 
corresponding level 	memset git inflate 
precomputed table 	init use 
used convert 	pack git inflate 
number 	git inflate 
leading key 	end use pack 
bits subtree 	sha write 
level start 	open istream read 
jemalloc structs 	sha file 
jemalloc externs 	die sha hex 
read 	free delta 
first read 	compress encode pack 
may stale 	header close 
reading val 	istream free 
behalf pointer 	sha write sha 
valid allocation 	write close 
guaranteed 	istream free sha 
clean read 	write sha 
even without 	write close istream 
synchronization rtree 	free sha 
update became 	write write large 
visible memory 	blob data 
pointer 	close istream sha 
came existence 	write free 
arbitrary read 	encode pack header 
behalf ivsalloc 	find pack 
may dependent 	revindex check pack 
previous rtree 	crc error 
write 	sha hex unuse 
means stale 	pack write 
read could 	reuse check pack 
result synchronization 	inflate error 
omitted read 	sha hex 
first read 	unuse pack write 
may 	reuse unuse 
stale node 	pack sha write 
leaf contains 	sha write 
values rather 	unuse pack sha 
child pointers 	write sha 
node leaf 	write unuse pack 
contains 	sha write 
values rather 	copy pack data 
child pointers 	unuse pack 
jemalloc inlines 	crc begin write 
scripting.c lua 	reuse write 
reply lua 	reuse crc end 
reply 	write one 
lua reply 	write overflows die 
lua reply 	packlist find 
lua reply 	peel packlist find 
evalsha lua 	write order 
entry reply 	write order 
lua 	descendants write order 
idx active 	tag alloc 
forked logs 	write order write 
traces children 	order write 
bpcount step 	order write order 
luabp src 	family write 
lines 	order die pack 
currentline cbuf 	valid die 
maxlen maxlen 	git open noatime 
hint sent 	die errno 
digest script 	lseek die errno 
len ctx 	xread die 
hash 	errno sha write 
cset lua 	reuse packfile 
reply lua 	objects display progress 
reply lua 	close display 
reply bulklen 	progress start progress 
lua reply 	alloc compute 
lua 	write order 
reply lua 	sha throughput create 
reply mbulklen 	tmp packfile 
lua error 	write pack header 
dbg msg 	write reused 
lua lua 	pack write one 
lua 	display progress 
err replylen 	sha close sha 
mbulklen lua 	close sha 
error argc 	close fixup pack 
cmd reply 	header footer 
argv argv 	close stat warning 
size 	strerror utime 
cached objects 	warning strerror strbuf 
cached objects 	addf bitmap 
len inuse 	writer checksum bitmap 
recursion warning 	writer build 
obj obj 	type index finish 
len 	tmp packfile 
dbuf num 	strbuf addf 
cmdlog call 	sha hex stop 
flags lua 	progress bitmap 
lua lua 	writer show progress 
argc digest 	bitmap writer 
len 	reuse bitmaps bitmap 
lua field 	writer commits 
lua lua 	bitmap writer build 
lua lua 	bitmap writer 
lua argc 	finish strbuf release 
log lua 	free puts 
argc 	sha hex free 
flags lua 	free stop 
argc level 	progress die git 
log len 	attr setup 
lua libname 	delta attr check 
luafunc lua 	git check 
lua 	attr size 
lua code 	attr packlist find 
setup lua 	loose nonlocal 
compare func 	find pack entry 
errh func 	one pack 
lua elev 	valid size size 
elec 	pbase cache 
lua funcname 	hashcmp pbase cache 
body funcdef 	incr read 
retval lua 	sha file free 
elapsed evalsha 	xmalloc free 
lua funcname 	hashcpy free free 
numkeys 	entry isgitlink 
err sha 	entry len memcmp 
count propargv 	entry type 
script funcname 	isdir name cmp 
sha log 	len pbase 
entry entry 	init desc pbase 
trimmed 	pbase put 
proto act 	done pbase 
srcstring srclen 	path pos alloc 
pid pid 	grow memmove 
evalsha line 	pack name hash 
idx line 	check pbase 
line 	path name cmp 
line argcp 	len entry 
argv argc 	init desc pbase 
copy plen 	read reference 
slen lnum 	hashcmp free xcalloc 
line prefix 	hashcpy free 
current 	free size free 
thisline around 	free free 
context lua 	use pack unpack 
idx level 	header buffer 
strl strp 	unuse pack use 
expected index 	pack use 
repr 	pack msb error 
repr lua 	sha hex 
idx lua 	error sha 
prefix reply 	hex find pack 
reply reply 	revindex nth 
reply reply 	packed sha packlist 
reply 	find unuse 
reply bulklen 	pack size delta 
reply reply 	unuse pack 
mbulklen reply 	unuse pack sha 
log lua 	info hashcmp 
varname name 	xcalloc qsort check 
lua 	free max 
vars name 	size read read 
prefix argv 	sha file 
argc arg 	read unlock die 
line lua 	sha hex 
argv argc 	die sha hex 
code 	read read 
expr lua 	sha file read 
argv argc 	unlock warning 
saved lua 	sha hex 
level argv 	die sha hex 
argc newval 	die sha 
lua 	hex create delta 
argv argc 	index warning 
buf nread 	delta index create 
ctx num 	delta free 
lua timeout 	free cache delta 
elapsed 	cacheable cache 
timelimit reason 	unlock xrealloc cache 
sha init 	unlock free 
sha update 	check delta limit 
sha redis 	delta index 
protocol lua 	free delta index 
type 	free xcalloc 
redis protocol 	progress progress unlock 
lua type 	display progress 
bulk redis 	progress unlock 
protocol lua 	free unpacked free 
type status 	unpacked check 
redis 	delta limit delta 
protocol lua 	compress cache 
type error 	cache unlock free 
redis protocol 	delta index 
lua type 	free free read 
multi bulk 	release pack 
strchr 	memory read unlock 
lua pushnumber 	init recursive 
strchr lua 	mutex pthread mutex 
pushboolean lua 	init pthread 
pushlstring strchr 	mutex init pthread 
lua newtable 	cond init 
lua 	free routine free 
pushstring lua 	routine pthread 
pushlstring lua 	cond destroy pthread 
settable strchr 	mutex destroy 
lua newtable 	pthread mutex 
lua pushstring 	destroy pthread mutex 
lua 	destroy find 
pushlstring lua 	deltas progress pthread 
settable strchr 	cond signal 
lua pushboolean 	progress unlock pthread 
lua newtable 	mutex pthread 
lua pushnumber 	cond wait pthread 
redis 	mutex unlock 
protocol lua 	init threaded search 
type lua 	find deltas 
settable ldb 	cleanup threaded search 
log sdscatprintf 	xcalloc pthread 
sdsempty lua 	mutex init pthread 
newtable 	cond init 
lua pushstring 	pthread create die 
lua getstack 	strerror progress 
lua getinfo 	pthread cond wait 
sdscatprintf sdsempty 	progress unlock 
lua pushstring 	pthread mutex 
sdsfree 	pthread cond signal 
lua pushstring 	pthread mutex 
lua settable 	unlock pthread pthread 
lua pushstring 	cond destroy 
lua gettable 	pthread mutex destroy 
lua error 	cleanup threaded 
lua 	search free starts 
getglobal lua 	peel packlist 
pushstring lua 	find entry details 
gettable lua 	alloc die 
pushvalue lua 	sha hex start 
pcall lua 	progress qsort 
pop 	find deltas stop 
lua pushstring 	progress die 
lua gettable 	free strcmp git 
lua pushvalue 	config strcmp 
lua getglobal 	git config strcmp 
lua call 	git config 
lua 	strcmp git 
pop lua 	config die strcmp 
type reply 	git config 
bulk buffer 	strcmp git config 
lua tostring 	strcmp git 
lua strlen 	config strcmp git 
reply 	config strcmp 
lua toboolean 	git config die 
reply lua 	warning strcmp 
tonumber lua 	git config die 
pushstring lua 	git config 
gettable lua 	fgets feof ferror 
type 	die die 
sdsnew lua 	errno clearerr sha 
tostring sdsmapchars 	hex die 
reply sds 	preferred sha hex 
sdscatprintf sdsempty 	die preferred 
sdsfree lua 	entry entry 
pop 	index commit bitmap 
lua pop 	preferred entry 
lua pushstring 	preferred find pack 
lua gettable 	entry one 
lua type 	oidcmp memset open 
sdsnew lua 	pack index 
tostring 	die alloc grow 
sdsmapchars reply 	nth packed 
sds sdscatprintf 	sha lookup unknown 
sdsempty sdsfree 	mark pack 
lua pop 	qsort entry free 
deferred multi 	find pack 
bulk 	entry one sha 
length lua 	lookup open 
pop lua 	pack index die 
pushnumber lua 	nth packed 
gettable lua 	sha packlist find 
type lua 	sha pack 
pop 	kept nonlocal 
lua reply 	loosened discarded force 
redis reply 	loose die 
deferred multi 	prepare bitmap walk 
bulk length 	pack options 
reply lua 	allow reuse reuse 
pop 	packfile bitmap 
lua gettop 	display progress traverse 
server log 	bitmap commit 
lua push 	list sha append 
error lua 	sha append 
push error 	init revisions setup 
lua 	revisions repository 
error zrealloc 	shallow fgets strlen 
lua type 	strcmp starts 
lua tonumber 	sha hex die 
snprintf lua 	shallow die 
tolstring memcpy 	handle revision arg 
sdssetlen 	die list 
create decr 	bitmap prepare 
count lua 	revision walk die 
push error 	mark edges 
lua error 	uninteresting traverse commit 
sdsnew sdscatprintf 	list unseen 
sdscatlen 	recent objects traversal 
sdscatsds ldb 	die prepare 
log lookup 	revision walk die 
command lua 	traverse commit 
push error 	list objects unpacked 
lua push 	packs loosen 
error 	unused packed objects 
lua push 	sha clear 
error lua 	strtoul die strtoul 
push error 	die approxidate 
lua push 	reset pack idx 
error lua 	option git 
push 	config isatty parse 
error free 	options usage 
memory needed 	options argv 
lua push 	push argv push 
error node 	argv push 
query lua 	argv push argv 
push 	push argv 
error exec 	push argv push 
command propagate 	die online 
multi call 	cpus warning die 
list length 	warning die 
sdsnewlen list 	die repository shallow 
length 	prepare packed 
list node 	git start progress 
list first 	read list 
sdscatlen sdslen 	stdin list argv 
list del 	clear cleanup 
node list 	preferred stop progress 
first 	prepare pack 
redis protocol 	write pack file 
lua type 	objects going 
ldb log 	pack collected 
redis reply 	pack structure contains 
lua sort 	dynamically expanded 
sdsfree 	data map resolve 
sdslen decr 	sha position 
count sdsalloc 	stats indexed commits 
decr count 	nothing going 
zfree lua 	reuse existing data 
error lua 	make sure 
redis 	corrupt bust pack 
command lua 	size limit 
redis command 	make sure cached 
lua gettop 	delta data 
lua pushstring 	remains previous attempt 
lua error 	pack split 
lua 	occurred large blob 
tolstring sha 	compress well 
hex lua 	header type 
pushstring lua 	followed zero bytes 
gettop lua 	length deltas 
type lua 	relative contain additional 
push 	encoding relative 
error lua 	offset delta position 
newtable lua 	pack deltas 
pushstring lua 	reference contain additional 
pushvalue lua 	bytes sha 
settable lua 	bust pack size 
redis 	limit bust 
single field 	pack size limit 
table lua 	apply size 
redis single 	limit limited packsize 
field table 	first earlier 
lua pushboolean 	fit limit avoid 
redis 	mistaking unlimited 
srand rand 	limit delta unlimited 
lua pushboolean 	packfile written 
lua pushboolean 	another pack 
lua pushboolean 	already exists pack 
lua gettop 	could end 
sdscatprintf 	another pack reuse 
sdsempty ldb 	check decided 
cat stack 	pack split may 
sdscatlen ldb 	pack delta 
log lua 	unusable want pack 
gettop lua 	afresh pack 
pushstring 	undeltified need deltify 
lua error 	already written 
lua pushstring 	writing bust limit 
lua error 	written normal 
lua tonumber 	already scheduled written 
lua pushstring 	offset impossible 
lua 	mark fact involved 
error lua 	write first 
gettop lua 	writing deltified recursion 
pushstring lua 	offset non 
error lua 	zero written 
isnumber lua 	already deltified write 
pushstring 	first recurse 
lua error 	cannot depend one 
lua tonumber 	make sure 
lua pushstring 	sufficiently large wrap 
lua error 	node siblings 
sdsempty lua 	drop level left 
tolstring 	subtree nodes 
sdscatlen sdscatlen 	possible sibling might 
server log 	children next 
raw sdsfree 	back parent node 
lua pushcfunction 	right side 
lua pushstring 	subtree keep going 
lua 	right done 
call lua 	hit original root 
load lib 	node pass 
lua load 	sibling level nothing 
lib lua 	fully connect 
load lib 	delta child 
lua 	delta sibling network 
load lib 	make sure 
lua load 	delta sibling sorted 
lib lua 	original recency 
load lib 	order mark first 
lua load 	child mark 
lib 	objects tip tags 
lua load 	give objects 
lib lua 	original recency order 
load lib 	see tagged 
lua pushnil 	tip fill tagged 
lua setglobal 	tips remaining 
sdsempty 	commits tags trees 
sdscatlen strlen 	rest really 
lua loadbuffer 	tight order know 
sdslen lua 	actual number 
pcall sdsfree 	objects written 
lua open 	many bytes written 
ldb 	many bytes 
init lua 	total many objects 
load libraries 	total fake 
lua unsupported 	pretending objects writing 
functions dict 	size gives 
create lua 	smooth progress meter 
newtable 	end matches 
lua pushstring 	answer write wrong 
lua pushcfunction 	entries header 
lua settable 	rewrite like fast 
lua pushstring 	packs runtime 
lua pushcfunction 	accessed mtime order 
lua 	since newer 
settable lua 	packs likely contain 
pushstring lua 	younger objects 
pushcfunction lua 	creating multiple packs 
settable lua 	modify mtime 
pushstring lua 	later ones 
pushnumber 	preserve mark written 
lua settable 	objects written 
lua pushstring 	previous pack adding 
lua pushnumber 	check whether 
lua settable 	already added packing 
lua pushstring 	list skip 
lua 	however asked excludei 
pushnumber lua 	previous mention 
settable lua 	include make sure 
pushstring lua 	adjust flags 
pushnumber lua 	tweak numbers accordingly 
settable lua 	optimization pass 
pushstring 	index position would 
lua pushcfunction 	found item 
lua settable 	since saves look 
lua pushstring 	lines later 
lua pushcfunction 	want entry check 
lua settable 	whether want 
lua 	pack want 
pushstring lua 	objects found non 
pushcfunction lua 	local stores 
settable lua 	local option used 
pushstring lua 	side effect 
pushcfunction lua 	check find packed 
settable 	version therefore 
lua pushstring 	pass pack information 
lua pushcfunction 	avoid look 
lua settable 	later pack missing 
lua pushstring 	closure phony 
lua pushnumber 	cache entry going 
lua 	evict find 
settable lua 	mechanism toplevel node 
pushstring lua 	would almost 
pushnumber lua 	always change commit 
settable lua 	pbase cache 
pushstring lua 	acts limited hashtable 
pushnumber 	found index 
lua settable 	within slots 
lua pushstring 	slot cached find 
lua pushnumber 	one either 
lua settable 	got bogus request 
lua pushstring 	need read 
lua 	perhaps cache need 
pushcfunction lua 	either cache 
settable lua 	throwaway copy evict 
pushstring lua 	reuse want 
pushcfunction lua 	pack type even 
settable lua 	reuse delta 
setglobal 	since non delta 
lua getglobal 	representations could 
lua pushstring 	still reused determine 
lua pushcfunction 	delta whether 
lua settable 	reuse otherwise find 
lua pushstring 	cheaply possible 
lua 	actual type 
pushcfunction lua 	size delta hence 
settable lua 	already got 
setglobal lua 	need means wish 
loadbuffer strlen 	reuse delta 
lua pcall 	data even found 
lua 	list objects 
loadbuffer strlen 	want pack goodie 
lua pcall 	depth matter 
create client 	find deltas never 
scripting enable 	consider reused 
globals protection 	delta deltify objects 
dict 	order avoid 
release lua 	circular deltas must 
close scripting 	delta already 
release scripting 	know type extract 
init lua 	actual size 
newtable lua 	delta header choice 
pushlstring 	fall back 
sdslen lua 	recursive delta 
rawseti lua 	walk sha info 
setglobal lua 	find type 
number redis 	point error condition 
lrand lua 	prepare pack 
gettop 	permit missing preferred 
lua pushnumber 	ignored preferred 
lua checkint 	result larger pack 
lua argcheck 	file transfer 
lua pushnumber 	still take place 
floor lua 	avoid filesystem 
checkint 	trashing loose objects 
lua checkint 	search deltas 
lua argcheck 	list sorted type 
lua pushnumber 	filename hash 
floor lua 	size see progressively 
error redis 	smaller smaller 
srand 	files prefer deltas 
lua checkint 	bigger file 
sdsempty sdscat 	smaller deletes 
sdscatlen sdscatlen 	potentially cheaper perhaps 
sdscatlen sdslen 	importantly bigger 
sdscatlen lua 	file likely recent 
loadbuffer 	one deepest 
sdslen reply 	deltas therefore oldest 
error format 	objects less 
lua tostring 	susceptible accessed often 
lua pop 	newest first 
sdsfree sdsfree 	cache delta objects 
lua 	large enough 
pcall reply 	compared delta size 
error format 	bother diffs 
lua tostring 	different types bother 
lua pop 	delta discarded 
dict sdsnewlen 	earlier reusing delta 
server 	data note 
info incr 	src entry marked 
count unused 	preferred always 
unused mstime 	considered even 
server log 	produce suboptimal delta 
file process 	still save 
events 	transfer cost already 
blocked server 	know side 
log lua 	won send src 
pushstring lua 	entry bust 
error redis 	allowed depth size 
srand reply 	filtering heuristics 
reply 	load data already 
error reply 	done objects 
error sha 	included resulting pack 
hex sdslen 	resilient ignore 
lua getglobal 	read pack could 
lua getglobal 	created nevertheless 
lua 	prefer shallower sized 
isnil lua 	deltas handle 
pop lua 	memory allocation outside 
pop reply 	cache accounting 
lua create 	compiler optimize 
function lua 	strangeness away pthreads 
pop 	defined compute 
lua getglobal 	delta create objects 
server lua 	going pack 
isnil lua 	current pack edge 
lua mstime 	take depth 
lua sethook 	objects depend current 
lua 	account otherwise 
sethook lua 	would become deep 
pcall lua 	decided cache 
sethook create 	delta data best 
file lua 	compress right 
reply error 	away first anyway 
format 	threaded save 
lua tostring 	lot time non 
lua pop 	threaded write 
lua reply 	phase well 
redis reply 	allow caching deltas 
lua pop 	within cache 
prevent 	size limit writing 
command propagation 	stdout since 
create also 	network likely throttling 
propagate decr 	writes anyway 
count replication 	therefore best write 
script cache 	phase asap 
exists 	instead afford spending 
dict fetch 	time compressing 
replication script 	writes moment made 
cache server 	delta already 
info rewrite 	max depth leaving 
client 	window pointless 
command argument 	evict first move 
reset count 	best delta 
create rewrite 	window currently deltified 
client command 	keep longer 
argument force 	first attempted 
command 	next main waits 
propagation eval 	condition least 
command eval 	one workers stopped 
command debugging 	working indicated 
sdslen reply 	working member work 
eval command 	completed work 
reply 	sets working signals 
error strcasecmp 	main waits 
scripting reset 	condition data ready 
reply replication 	becomes mutex 
script cache 	conditional variable statically 
flush strcasecmp 	initialized windows 
reply 	must data ready 
multi bulk 	wait condition 
len dict 	main may order 
find reply 	sure work 
reply strcasecmp 	available see data 
sha hex 	ready initialized 
sdslen 	spawned reset 
sdsnewlen dict 	right away working 
find lua 	doesn work 
create function 	assigned partition work 
sdsfree reply 	amongst work 
bulk buffer 	threads use small 
sdsfree 	segments deltas 
force command 	found split chunks 
propagation strcasecmp 	path boundaries 
reply sds 	start work threads 
sdsnew reply 	wait work 
sds sdsnew 	completion time done 
reply 	work steal 
strcasecmp client 	half remaining work 
pending replies 	largest number 
reply error 	unprocessed objects give 
strcasecmp ldb 	newly idle 
disable reply 	ensure good load 
strcasecmp 	balancing remaining 
ldb enable 	list segments 
reply strcasecmp 	simply worth splitting 
ldb enable 	anymore possible 
reply reply 	paths many objects 
error reply 	hash boundary 
error 	might found steal 
list create 	exact half 
list free 	tag peelable packed 
method list 	locally repacking 
create sdsempty 	need doubly careful 
list first 	order make 
list 	sure stealth corruption 
del node 	gets propagated 
ldb flush 	pack clients receiving 
log sdsfree 	streamed packs 
sdsempty list 	validate everything anyway 
node tail 	need incur 
sdslen 	additional cost 
sdsrange sdscatlen 	happens decided reuse 
ldb log 	existing delta 
ldb log 	pack reuse delta 
sdsnew sdsempty 	implied found 
sdscatfmt list 	include anyway compare 
length 	objects offset 
list length 	order order emulate 
list first 	git rev 
sdscatlen sdsmapchars 	list objects output 
sdscatsds sdscatlen 	produced pack 
list del 	originally store list 
node 	sha discarded 
write sdslen 	either written recently 
sdsfree fork 	reachable another 
reply error 	filled list tracks 
sigemptyset sigaction 	options reader 
sigaction server 	pack might understand 
log 	would therefore 
close listening 	prevent blind 
sockets list 	reuse disk make 
node tail 	sure shallows 
free client 	read threads means 
server log 	autodetect pack-objects.c 
anet 	pdata sha found 
block anet 	mask pos 
send timeout 	pdata entry found 
sdsdup sdslen 	pdata sha 
sdssetlen sdssplitlen 	index pos found 
sdslen sdsfree 	pdata sha 
ldb 	index pos entry 
log sdsnew 	sha hash 
ldb send 	hashcmp closest pow 
logs write 	free xcalloc 
client server 	locate entry hash 
log exit 	die locate 
child 	entry hash realloc 
server log 	memset hashcpy 
anet non 	rehash objects 
block anet 	objects going pack 
send timeout 	collected pack 
sdsfreesplitres list 	structure contains dynamically 
search 	expanded data 
key list 	map resolve sha 
del node 	position stats 
list length 	indexed commits nothing 
list rewind 	going reuse 
list next 	existing data make 
server 	sure corrupt 
log kill 	bust pack size 
list release 	limit make 
list create 	sure cached delta 
ldb start 	data remains 
session eval 	previous attempt pack 
command 	split occurred 
ldb end 	large blob compress 
session ldb 	well header 
disable ldb 	type followed 
breakpoint memmove 	zero bytes length 
sdslen sdsdup 	deltas relative 
strchr 	contain additional encoding 
strstr atoi 	relative offset 
zmalloc strstr 	delta position pack 
atoi sdsnewlen 	deltas reference 
sdsfree sdsfreesplitres 	contain additional bytes 
sdsfree ldb 	sha bust 
source 	pack size limit 
line ldb 	bust pack 
breakpoint sdscatprintf 	size limit apply 
sdsempty ldb 	size limit 
log abs 	limited packsize first 
ldb log 	earlier fit 
source 	limit avoid mistaking 
line lua 	unlimited limit 
type sdscat 	delta unlimited 
lua tolstring 	packfile written another 
sdscatrepr sdscat 	pack already 
lua toboolean 	exists pack could 
sdscatprintf 	end another 
lua tonumber 	pack reuse check 
sdscatlen sdsempty 	decided pack 
sdsempty lua 	split may pack 
pushnil lua 	delta unusable 
next lua 	want pack afresh 
type 	pack undeltified 
lua tonumber 	need deltify already 
ldb cat 	written writing 
stack rec 	bust limit written 
sdscatlen sdscatlen 	normal already 
ldb cat 	scheduled written offset 
stack 	impossible mark 
rec sdscatlen 	fact involved write 
ldb cat 	first writing 
stack rec 	deltified recursion 
sdscatlen lua 	offset non zero 
pop sdslen 	written already 
sdsrange 	deltified write first 
sdslen sdsrange 	recurse cannot 
sdscatlen sdscatsds 	depend one make 
sdscatlen sdsfree 	sure sufficiently 
sdsfree lua 	large wrap node 
topointer sdscatprintf 	siblings drop 
sdscat 	level left subtree 
ldb cat 	nodes possible 
stack rec 	sibling might children 
sdsnew ldb 	next back 
cat stack 	parent node right 
ldb log 	side subtree 
max 	keep going right 
len ldb 	done hit 
redis protocol 	original root node 
human ldb 	pass sibling 
redis protocol 	level nothing 
human bulk 	fully connect delta 
ldb 	child delta 
redis protocol 	sibling network make 
human status 	sure delta 
ldb redis 	sibling sorted original 
protocol human 	recency order 
status ldb 	mark first child 
redis 	mark objects 
protocol human 	tip tags give 
multi bulk 	objects original 
strchr sdscatlen 	recency order see 
strchr sdscatlen 	tagged tip 
sdscatrepr strchr 	fill tagged tips 
sdscatrepr 	remaining commits 
strchr sdscatlen 	tags trees rest 
sdscatlen ldb 	really tight 
redis protocol 	order know actual 
human sdscatlen 	number objects 
sdscatlen sdsnew 	written many 
ldb 	bytes written many 
redis protocol 	bytes total 
human ldb 	many objects total 
log max 	fake pretending 
len lua 	objects writing size 
getstack lua 	gives smooth 
getlocal 	progress meter end 
strcmp ldb 	matches answer 
log stack 	write wrong entries 
lua pop 	header rewrite 
lua pop 	like fast packs 
strcmp strcmp 	runtime accessed 
lua 	mtime order since 
getglobal ldb 	newer packs 
log stack 	likely contain younger 
lua pop 	objects creating 
ldb log 	multiple packs modify 
sdsnew lua 	mtime later 
getstack 	ones preserve 
lua getlocal 	mark written objects 
strstr sdscatprintf 	written previous 
sdsempty ldb 	pack adding check 
log stack 	whether already 
sdsfree lua 	added packing list 
pop 	skip however 
ldb log 	asked excludei previous 
sdsnew ldb 	mention include 
log sdsnew 	make sure adjust 
ldb log 	flags tweak 
sdscatfmt sdsempty 	numbers accordingly optimization 
ldb 	pass index 
log source 	position would found 
line sdslen 	item since 
ldb log 	saves look lines 
sdscatfmt sdsempty 	later want 
ldb log 	entry check 
sdsnew 	whether want pack 
ldb log 	want objects 
sdsnew ldb 	found non local 
breakpoint ldb 	stores local 
list ldb 	option used side 
log sdsnew 	effect check 
ldb 	find packed version 
del breakpoint 	therefore pass 
ldb log 	pack information avoid 
sdsnew ldb 	look later 
log sdsnew 	pack missing closure 
sdsjoinsds sdscatsds 	phony cache 
sdsnew 	entry going evict 
lua loadbuffer 	find mechanism 
sdslen lua 	toplevel node would 
pop lua 	almost always 
loadbuffer sdslen 	change commit pbase 
ldb log 	cache acts 
sdscatfmt 	limited hashtable 
sdsempty lua 	found index within 
tostring lua 	slots slot 
pop sdsfree 	cached find one 
sdsfree sdsfree 	either got 
lua pcall 	bogus request need 
ldb 	read perhaps 
log sdscatfmt 	cache need either 
sdsempty lua 	cache throwaway 
tostring lua 	copy evict reuse 
pop ldb 	want pack 
log stack 	type even reuse 
lua 	delta since 
pop lua 	non delta representations 
getglobal lua 	could still 
pushstring lua 	reused determine delta 
gettable lua 	whether reuse 
pushlstring sdslen 	otherwise find cheaply 
lua 	possible actual 
pcall lua 	type size 
pop lua 	delta hence already 
getstack lua 	got need 
getinfo strstr 	means wish reuse 
ldb log 	delta data 
sdscatprintf 	even found list 
sdsempty ldb 	objects want 
log source 	pack goodie depth 
line ldb 	matter find 
log sdsnew 	deltas never consider 
atoi ldb 	reused delta 
log 	deltify objects order 
sdscatprintf sdsempty 	avoid circular 
ldb log 	deltas must delta 
sdscatprintf sdsempty 	already know 
ldb repl 	type extract actual 
parse command 	size delta 
read 	header choice fall 
sdscatlen sdsfree 	back recursive 
sdsempty strcasecmp 	delta walk 
strcasecmp ldb 	sha info find 
log sdsnew 	type point 
ldb log 	error condition prepare 
sdsnew 	pack permit 
ldb log 	missing preferred ignored 
sdsnew ldb 	preferred result 
log sdsnew 	larger pack file 
ldb log 	transfer still 
sdsnew ldb 	take place avoid 
log 	filesystem trashing 
sdsnew ldb 	loose objects search 
log sdsnew 	deltas list 
ldb log 	sorted type filename 
sdsnew ldb 	hash size 
log sdsnew 	see progressively smaller 
ldb 	smaller files 
log sdsnew 	prefer deltas 
ldb log 	bigger file smaller 
sdsnew ldb 	deletes potentially 
log sdsnew 	cheaper perhaps importantly 
ldb log 	bigger file 
sdsnew 	likely recent one 
ldb log 	deepest deltas 
sdsnew ldb 	therefore oldest objects 
log sdsnew 	less susceptible 
ldb log 	accessed often newest 
sdsnew ldb 	first cache 
log 	delta objects large 
sdsnew ldb 	enough compared 
log sdsnew 	delta size bother 
ldb log 	diffs different 
sdsnew ldb 	types bother delta 
log sdsnew 	discarded earlier 
ldb 	reusing delta data 
log sdsnew 	note src 
ldb log 	entry marked 
sdsnew ldb 	preferred always considered 
log sdsnew 	even produce 
ldb log 	suboptimal delta still 
sdsnew 	save transfer 
ldb log 	cost already know 
sdsnew ldb 	side won 
log sdsnew 	send src entry 
ldb log 	bust allowed 
sdsnew ldb 	depth size filtering 
log 	heuristics load 
sdsnew ldb 	data already done 
log sdsnew 	objects included 
ldb log 	resulting pack resilient 
sdsnew ldb 	ignore read 
send logs 	pack could created 
strcasecmp 	nevertheless prefer 
strcasecmp strcasecmp 	shallower sized deltas 
strcasecmp strcasecmp 	handle memory 
strcasecmp strcasecmp 	allocation outside 
strcasecmp ldb 	cache accounting compiler 
trace ldb 	optimize strangeness 
send 	away pthreads defined 
logs strcasecmp 	compute delta 
strcasecmp ldb 	create objects going 
maxlen ldb 	pack current 
send logs 	pack edge take 
strcasecmp strcasecmp 	depth objects 
ldb 	depend current account 
ldb send 	otherwise would 
logs strcasecmp 	become deep decided 
strcasecmp ldb 	cache delta 
eval ldb 	data best compress 
send logs 	right away 
strcasecmp 	first anyway threaded 
strcasecmp lua 	save lot 
pushstring lua 	time non threaded 
error strcasecmp 	write phase 
strcasecmp ldb 	well allow 
redis ldb 	caching deltas within 
send 	cache size 
logs strcasecmp 	limit writing stdout 
strcasecmp ldb 	since network 
print ldb 	likely throttling writes 
print ldb 	anyway therefore 
send logs 	best write phase 
strcasecmp 	asap instead 
strcasecmp atoi 	afford spending time 
atoi ldb 	compressing writes 
list ldb 	moment made delta 
send logs 	already max 
strcasecmp strcasecmp 	depth leaving window 
ldb 	pointless evict 
list ldb 	first move best 
send logs 	delta window 
ldb log 	currently deltified 
sdsnew ldb 	keep longer first 
send logs 	attempted next 
sdsfreesplitres 	main waits condition 
sdsfreesplitres lua 	least one 
getstack lua 	workers stopped working 
getinfo ldb 	indicated working 
breakpoint strstr 	member work completed 
mstime ldb 	work sets 
log 	working signals main 
sdscatprintf sdsempty 	waits condition 
ldb log 	data ready becomes 
source line 	mutex conditional 
ldb send 	variable statically initialized 
logs ldb 	windows must 
repl 	data ready wait 
lua pushstring 	condition main 
lua error 	may order sure 
mstime copyright 	work available 
salvatore sanfilippo 	see data 
antirez gmail 	ready initialized spawned 
dot 	reset right 
rights reserved 	away working doesn 
redistribution use 	work assigned 
source binary 	partition work amongst 
forms without 	work threads 
modification permitted 	use small segments 
provided 	deltas found 
following conditions 	split chunks path 
met redistributions 	boundaries start 
source code 	work threads wait 
must retain 	work completion 
copyright notice 	time done work 
list 	steal half 
conditions following 	remaining work largest 
disclaimer redistributions 	number unprocessed 
binary form 	objects give newly 
must reproduce 	idle ensure 
copyright notice 	good load 
list 	balancing remaining list 
conditions following 	segments simply 
disclaimer documentation 	worth splitting anymore 
materials provided 	possible paths 
distribution neither 	many objects hash 
name redis 	boundary might 
names 	found steal exact 
contributors may 	half tag 
used endorse 	peelable packed locally 
promote products 	repacking need 
derived software 	doubly careful order 
without specific 	make sure 
prior 	stealth corruption gets 
written permission 	propagated pack 
software provided 	clients receiving streamed 
copyright holders 	packs validate 
contributors express 	everything anyway need 
implied warranties 	incur additional 
including 	cost happens 
limited implied 	decided reuse existing 
warranties merchantability 	delta pack 
fitness particular 	reuse delta implied 
purpose disclaimed 	found include 
shall 	anyway compare objects 
copyright owner 	offset order 
contributors liable 	order emulate git 
direct indirect 	rev list 
incidental special 	objects output produced 
exemplary consequential 	pack originally 
damages 	store list sha 
including limited 	discarded either 
procurement substitute 	written recently reachable 
goods services 	another filled 
loss use 	list tracks options 
data profits 	reader pack 
business 	might understand would 
interruption however 	therefore prevent 
caused theory 	blind reuse 
liability whether 	disk make sure 
contract strict 	shallows read 
liability tort 	threads means autodetect 
including 	pack usage 
negligence otherwise 	pack written list 
arising way 	result written 
use software 	non empty reuse 
even advised 	keep unreachable 
possibility damage 	unpack unreachable include 
debugger 	tag unpack 
shared state 	unreachable expiration local 
stored inside 	incremental ignore 
structure max 	packed keep allow 
number breakpoints 	ofs delta 
len limit 	pack idx opts 
replies 	name progress 
dumps socket 	window pack 
debugging client 	size limit depth 
debugging eval 	delta search 
right fork 	threads pack stdout 
debugging session 	num preferred 
list 	progress state pack 
messages send 	compression level 
client messages 	pack compression seen 
redis commands 	reuse packfile 
executed since 	reuse packfile objects 
last stop 	reuse packfile 
forked 	offset use bitmap 
debugging sessions 	index write 
pids breakpoints 	bitmap index write 
line numbers 	bitmap options 
number valid 	delta cache size 
entries inside 	max delta 
stop 	cache size cache 
next line 	max small 
ragardless breakpoints 	delta size 
stop next 	window memory limit 
line redis 	written written 
breakpoint called 	delta reused reused 
lua 	delta indexed 
script source 	commits indexed commits 
code split 	indexed commits 
line number 	alloc commit entry 
lines src 	size size 
current line 	delta size buf 
number 	buf delta 
debugger client 	buf pptr size 
command buffer 	stream maxsize 
max dump 	sha stream ibuf 
reply length 	obuf olen 
already hint 	readlen zret curs 
maxlen 	offset len 
utility functions 	expect stream fakebuf 
perform sha 	curs offset 
input use 	len avail 
hashing script 	entry limit usable 
bodies order 	delta size 
obtain 	datalen header dheader 
lua function 	hdrlen buf 
name implementation 	ofs pos entry 
redis sha 	limit usable 
digest point 	delta curs revidx 
bytes buffer 	offset datalen 
sha 	header dheader hdrlen 
converted hexadecimal 	ofs pos 
number plus 	entry write offset 
term redis 	limit len 
reply lua 	usable delta reuse 
type conversion 	path oid 
functions 	flag data peeled 
take redis 	entry endp 
reply redis 	endp order endp 
protocol format 	root end 
convert lua 	last untagged 
type thanks 	objects buffer write 
function 	total read 
introduction connected 	pack offset remaining 
clients trivial 	last mtime 
implement redis 	write order sha 
lua function 	pack tmp 
basically take 	name packfile size 
arguments 	tmpname utb 
execute redis 	check attr delta 
command context 	path check 
non connected 	sha exclude index 
client take 	pos entry 
generated reply 	sha exclude found 
convert 	pack found 
suitable lua 	offset offset create 
type trick 	entry closure 
scripting feature 	warning entry 
need introduction 	entry bitmap sha 
full redis 	temporary data 
internals 	size sha next 
api script 	pcache sha 
like normal 	ent nent data 
client bypasses 	size neigh 
slow paths 	available cache name 
note function 	name cmplen 
sanity 	fullname entry cmp 
check reply 	sub downlen 
generated redis 	done pbase paths 
directly allows 	done pbase 
faster errors 	paths num done 
returned table 	pbase paths 
single 	alloc hash hash 
err field 	pos name 
error function 	cmplen hash sha 
used order 	data size 
push error 	sha entry 
lua stack 	curs entry used 
format 	used avail 
used redis 	ofs buf revidx 
pcall errors 	sorted offset 
lua table 	entry entry data 
single err 	index depth 
field error 	src size trg 
note 	size delta 
table never 	size read mutex 
valid reply 	cache mutex 
proper commands 	progress mutex trg 
since returned 	src max 
tables otherwise 	depth mem usage 
always 	trg entry 
indexed integers 	src entry trg 
never debugging 	size src 
active step 	size delta size 
mode log 	sizediff max 
errors resulting 	size depth 
redis 	delta buf warned 
commands attempt 	warned child 
figure function 	freed mem list 
called possible 	list size 
error lua 	window depth processed 
stack lua 	count mem 
push 	usage entry max 
error generated 	depth best 
non error 	tail ret idx 
trapping version 	swap dist 
redis pcall 	dst src size 
redis call 	old free 
function 	routine list list 
lua error 	size remaining 
execution script 	window depth working 
halted sort 	data ready 
currently stack 	mutex cond processed 
make output 	progress cond 
commands 	arg list 
like keys 	list size window 
smembers something 	depth processed 
deterministic called 	ret active threads 
lua play 	sub size 
well replication 	target victim sub 
sorted 	size path 
table sort 	oid flag data 
assuming list 	peeled window 
elements initial 	depth delta list 
stack stack 	deltas entry 
table table 	done level line 
sort 	sha commit 
stack table 	data obj name 
table sort 	data commit 
stack table 	offset alloc pack 
error interested 	revs pack 
error problem 	sha sha 
elements 	last found recent 
inside slower 	objects sha 
function able 	mtime revs sha 
handle table 	revs obj 
sort table 	name data commit 
redis compare 	data revs 
helper 	line flags len 
stack table 	sha opt 
stack table 	arg unset val 
sort stack 	opt arg 
table table 	unset argc argv 
sort stack 	prefix use 
table 	rev list thin 
table sort 	shallow progress 
stack table 	implied rev list 
table sort 	reflog rev 
redis compare 	list index pack 
helper stack 	objects options 
sorted 	realloc read 
table stack 	sha file die 
sorted lua 	sha hex 
reply redis 	read sha file 
reply conversion 	die sha 
functions need 	hex diff delta 
check 	die free 
error status 	free git deflate 
reply error 	init git 
returned single 	deflate bound xmalloc 
element table 	git deflate 
err field 	git deflate end 
status 	free git 
replies returned 	deflate init read 
single element 	istream die 
table field 	sha hex git 
discard field 	deflate sha 
popped lua 	write die die 
redis 	git deflate 
functions implementations 	end memset 
cached across 	git inflate init 
calls recursive 	use pack 
calls detection 	git inflate git 
lua debug 	inflate end 
hooks 	use pack sha 
possible trigger 	write open 
recursive call 	istream read sha 
lua redis 	file die 
command normally 	sha hex free 
never happen 	delta compress 
make 	encode pack header 
function reentrant 	close istream 
futile makes 	free sha write 
slower least 	sha write 
detect misuse 	close istream free 
abort require 	sha write 
least 	sha write close 
one argument 	istream free 
build arguments 	sha write 
vector use 	write large blob 
lua tolstring 	data close 
number conversion 	istream sha write 
since 	free encode 
lua uses 	pack header find 
format specifier 	pack revindex 
loses precision 	check pack crc 
use cached 	error sha 
check one 	hex unuse pack 
arguments 	write reuse 
passed lua 	check pack inflate 
script integer 	error sha 
lua isstring 	hex unuse pack 
integers well 	write reuse 
setup fake 	unuse pack sha 
client 	write sha 
command execution 	write unuse pack 
log command 	sha write 
debugging active 	sha write 
command lookup 	unuse pack sha 
commands allowed 	write copy 
inside 	pack data unuse 
scripts write 	pack crc 
commands forbidden 	begin write reuse 
read slaves 	write reuse 
command marked 	crc end write 
non deterministic 	one write 
already 	overflows die packlist 
called context 	find peel 
script reached 	packlist find write 
memory limit 	order write 
configured via 	order descendants write 
maxmemory commands 	order tag 
could 	alloc write order 
enlarge memory 	write order 
usage allowed 	write order 
first write 	write order family 
context script 	write order 
otherwise stop 	die pack valid 
middle 	die git 
redis cluster 	open noatime die 
node need 	errno lseek 
make sure 	die errno xread 
lua trying 	die errno 
access non 	sha write reuse 
local 	packfile objects 
keys commands 	display progress close 
received master 	display progress 
duplicate relevant 	start progress alloc 
flags lua 	compute write 
client single 	order sha throughput 
commands 	create tmp 
replication need 	packfile write pack 
wrap propagate 	header write 
multi exec 	reused pack 
block atomic 	write one display 
like lua 	progress sha 
script 	close sha close 
context aof 	sha close 
slaves run 	fixup pack header 
command flags 	footer close 
according redis 	stat warning strerror 
repl settings 	utime warning 
convert 	strerror strbuf addf 
result redis 	bitmap writer 
command suitable 	checksum bitmap writer 
lua type 	build type 
first thing 	index finish tmp 
need create 	packfile strbuf 
single 	addf sha hex 
client output 	stop progress 
buffers fast 	bitmap writer show 
path common 	progress bitmap 
reply inside 	writer reuse 
client buffer 	bitmaps bitmap writer 
create 	commits bitmap 
sds use 	writer build bitmap 
client buffer 	writer finish 
directly debugger 	strbuf release free 
active log 	puts sha 
reply redis 	hex free free 
sort 	stop progress 
output needed 	die git attr 
assuming non 	setup delta 
multi bulk 	attr check git 
reply expected 	check attr 
clean command 	size attr packlist 
code 	find loose 
may changed 	nonlocal find pack 
argv argc 	entry one 
use argv 	pack valid size 
argc client 	size pbase 
instead local 	cache hashcmp 
variables 	pbase cache incr 
cache cached 	read sha 
objects must 	file free xmalloc 
small sds 	free hashcpy 
encoded refcount 	free free entry 
must owner 	isgitlink entry 
cache 	len memcmp entry 
error stack 	type isdir 
form table 	name cmp len 
err field 	pbase init 
extract plain 	desc pbase pbase 
error redis 	put done 
call 	pbase path pos 
redis pcall 	alloc grow 
adds redis 	memmove pack name 
sha hex 	hash check 
lua scripts 	pbase path 
hashing function 	name cmp len 
used 	entry init 
sha ing 	desc pbase read 
lua scripts 	reference hashcmp 
returns table 	free xcalloc hashcpy 
single field 	free free 
field passed 	size free free 
argument 	free use 
helper function 	pack unpack header 
handy returning 	buffer unuse 
redis protocol 	pack use pack 
error status 	use pack 
reply lua 	msb error sha 
redis 	hex error 
error reply 	sha hex find 
err error 	pack revindex 
redis status 	nth packed sha 
reply err 	packlist find 
error redis 	unuse pack 
error 	size delta unuse 
reply redis 	pack unuse 
status reply 	pack sha info 
redis replicate 	hashcmp xcalloc 
commands turn 	qsort check free 
single commands 	max size 
replication 	read read sha 
script never 	file read 
called write 	unlock die sha 
command far 	hex die 
returns otherwise 	sha hex read 
script already 	read sha 
started 	file read unlock 
write returns 	warning sha 
stick whole 	hex die sha 
scripts replication 	hex die 
single commands 	sha hex create 
replication provide 	delta index 
different 	warning delta 
math random 	index create delta 
sequences every 	free free 
call user 	cache delta cacheable 
normally expects 	cache unlock 
redis breakpoint 	xrealloc cache unlock 
allows 	free check 
stop execution 	delta limit delta 
debuggign session 	index free 
within lua 	delta index free 
code implementation 	xcalloc progress 
like breakpoint 	progress unlock display 
code 	progress progress 
immediately function 	unlock free unpacked 
redis debug 	free unpacked 
log message 	check delta limit 
output console 	delta compress 
take multiple 	cache cache unlock 
arguments 	free delta 
separated commas 	index free 
nothing returned 	free read release 
caller redis 	pack memory 
repl propagation 	read unlock init 
write commands 	recursive mutex 
executed 	pthread mutex init 
context script 	pthread mutex 
aof slaves 	init pthread cond 
redis log 	init free 
glue together 	routine free routine 
arguments lua 	pthread cond 
engine 	destroy pthread mutex 
initialization reset 	destroy pthread 
stuff load 	mutex destroy pthread 
currently sandboxing 	mutex destroy 
concerns functions 	find deltas progress 
want expose 	pthread cond 
redis 	signal progress 
scripting environment 	unlock pthread mutex 
function installs 	pthread cond 
metamethods table 	wait pthread mutex 
prevent creation 	unlock init 
globals accidentally 	threaded search find 
last 	deltas cleanup 
called scripting 	threaded search xcalloc 
engine initialization 	pthread mutex 
sequence may 	init pthread cond 
interact creation 	init pthread 
globals 	create die strerror 
strict lua 	progress pthread 
http metalua 	cond wait progress 
luaforge net 	unlock pthread 
src lib 	mutex pthread cond 
strict lua 	signal pthread 
html 	mutex unlock pthread 
modified adapted 	pthread cond 
redis initialize 	destroy pthread 
scripting environment 	mutex destroy cleanup 
function called 	threaded search 
first time 	free starts peel 
server 	packlist find 
startup setup 	entry details alloc 
argument called 	die sha 
multiple times 	hex start progress 
lifetime redis 	qsort find 
process setup 	deltas stop progress 
following 	die free 
scripting release 	strcmp git config 
call order 	strcmp git 
reset lua 	config strcmp git 
scripting environment 	config strcmp 
however simpler 	git config die 
call 	strcmp git 
scripting reset 	config strcmp git 
debug change 	config strcmp 
initialize dictionary 	git config 
use map 	strcmp git config 
scripts useful 	strcmp git 
replication 	config die warning 
need replicate 	strcmp git 
evalsha eval 	config die git 
need remember 	config fgets 
associated script 	feof ferror die 
redis commands 	die errno 
table 	clearerr sha hex 
fields redis 	die preferred 
call redis 	sha hex die 
pcall redis 	preferred entry 
log log 	entry index commit 
levels redis 	bitmap preferred 
sha 	entry preferred find 
hex redis 	pack entry 
error reply 	one oidcmp memset 
redis status 	open pack 
reply redis 	index die 
replicate commands 	alloc grow nth 
redis 	packed sha 
repl associated 	lookup unknown mark 
flags redis 	pack qsort 
breakpoint redis 	entry free find 
debug table 	pack entry 
redis replace 	one sha lookup 
math 	open pack 
random math 	index die nth 
randomseed implementations 	packed sha 
helper function 	packlist find sha 
use sort 	pack kept 
multi bulk 	nonlocal loosened discarded 
output 	force loose 
non deterministic 	die prepare bitmap 
commands containing 	walk pack 
elements helper 	options allow reuse 
function use 	reuse packfile 
pcall error 	bitmap display 
reporting 	progress traverse bitmap 
note error 	commit list 
function want 	sha append sha 
report information 	append init 
caller makes 	revisions setup revisions 
sense point 	repository shallow 
view 	fgets strlen strcmp 
user debugging 	starts sha 
script create 	hex die shallow 
non connected 	die handle 
client use 	revision arg die 
execute redis 	list bitmap 
commands 	prepare revision walk 
inside lua 	die mark 
interpreter note 	edges uninteresting traverse 
need create 	commit list 
function called 	unseen recent 
scripting reset 	objects traversal die 
lua 	prepare revision 
beginners often 	walk die traverse 
use local 	commit list 
likely introduce 	objects unpacked packs 
subtle bugs 	loosen unused 
code prevent 	packed objects sha 
problems 	clear strtoul 
protect accesses 	die strtoul die 
variables release 	approxidate reset 
resources related 	pack idx option 
lua scripting 	git config 
function used 	isatty parse options 
order 	usage options 
reset scripting 	argv push argv 
environment redis 	push argv 
objects lua 	push argv push 
table stored 	argv push 
variable redis 	argv push 
provided 	argv push die 
math random 	online cpus 
replace math 	warning die warning 
random implementation 	die die 
affected specific 	repository shallow prepare 
libc random 	packed git 
implementations 	start progress read 
output sequence 	list stdin 
seed every 	list argv clear 
arch following 	cleanup preferred 
implementation one 	stop progress prepare 
shipped lua 	pack write 
rand 	pack file objects 
replaced redis 	going pack 
lrand avoids 	collected pack structure 
rare needed 	contains dynamically 
also systems 	expanded data map 
sun rand 	resolve sha 
may 	position stats 
larger rand 	indexed commits nothing 
max check 	going reuse 
number arguments 	existing data make 
arguments number 	sure corrupt 
upper limit 	bust pack size 
lower 	limit make 
upper limits 	sure cached delta 
eval script 	data remains 
commands implementation 	previous attempt pack 
define lua 	split occurred 
function specified 	large blob compress 
function 	well header 
name body 	type followed zero 
function name 	bytes length 
musts characters 	deltas relative contain 
since functions 	additional encoding 
defined lua 	relative offset delta 
context 	position pack 
form hex 	deltas reference 
sha sum 	contain additional bytes 
success returned 	sha bust 
nothing left 	pack size limit 
lua stack 	bust pack 
error 	size limit apply 
err returned 	size limit 
appropriate error 	limited packsize first 
client context 	earlier fit 
also save 	limit avoid mistaking 
sha original 	unlimited limit 
script 	delta unlimited packfile 
map dictionary 	written another 
replicate write 	pack already exists 
aof evalsha 	pack could 
commands eval 	end another pack 
original script 	reuse check 
lua 	decided pack 
script count 	split may pack 
hook use 	delta unusable 
detect scripts 	want pack afresh 
timeout script 	pack undeltified 
timeouts reenter 	need deltify already 
loop 	written writing 
permit others 	bust limit written 
call script 	normal already 
kill shutdown 	scheduled written offset 
nosave needed 	impossible mark 
reason need 	fact involved write 
mask 	first writing 
client executing 	deltified recursion offset 
script loop 	non zero 
client may 	written already deltified 
disconnect could 	write first 
longer eval 	recurse cannot depend 
command 	one make 
replicate whole 	sure sufficiently 
scripts want 	large wrap node 
prng sequence 	siblings drop 
every call 	level left subtree 
prng affected 	nodes possible 
external 	sibling might children 
state flag 	next back 
zero remember 	parent node right 
far random 	side subtree 
command called 	keep going right 
way allow 	done hit 
user 	original root node 
call commands 	pass sibling 
like srandmember 	level nothing fully 
randomkey lua 	connect delta 
scripts far 	child delta sibling 
write command 	network make 
called 	sure delta sibling 
otherwise replication 	sorted original 
aof would 	recency order 
end non 	mark first child 
deterministic sequences 	mark objects 
thanks flag 	tip tags give 
error 	objects original 
every time 	recency order see 
write command 	tagged tip 
called random 	fill tagged tips 
command used 	remaining commits 
number arguments 	tags trees rest 
keys 	really tight 
obtain script 	order know actual 
sha check 	number objects 
function already 	written many bytes 
defined lua 	written many 
state hash 	bytes total many 
code 	objects total 
eval call 	fake pretending objects 
already sha 	writing size 
evalsha convert 	gives smooth 
lowercase use 	progress meter end 
tolower since 	matches answer 
function 	write wrong entries 
managed always 	header rewrite 
show profiler 	like fast packs 
output consuming 	runtime accessed 
non trivial 	mtime order since 
amount time 	newer packs 
push 	likely contain younger 
pcall error 	objects creating 
handler function 	multiple packs modify 
stack lookup 	mtime later 
lua function 	ones preserve mark 
nil stack 	written objects 
function 	written previous pack 
defined define 	adding check 
body function 	whether already added 
evalsha call 	packing list 
error error 	skip however 
handler stack 	asked excludei previous 
error 	mention include 
handler stack 	make sure adjust 
error sent 	flags tweak 
client lua 	numbers accordingly optimization 
create function 	pass index 
returns err 	position would found 
following 	item since 
guaranteed non 	saves look lines 
nil populate 	later want 
argv keys 	entry check whether 
table accordingly 	want pack 
arguments eval 	want objects found 
received 	non local 
right context 	stores local option 
lua client 	used side 
hook order 	effect check 
able stop 	find packed version 
script execution 	therefore pass 
running 	pack information avoid 
much time 	look later 
hook time 	pack missing closure 
limit enabled 	phony cache 
hook make 	entry going evict 
lua script 	find mechanism 
execution 	toplevel node would 
slower debugging 	almost always 
instead line 	change commit pbase 
hook debugger 	cache acts 
call back 	limited hashtable found 
every line 	index within 
executed 	slots slot cached 
script point 	find one 
whether script 	either got bogus 
never seen 	request need 
already defined 	read perhaps 
call zero 	cache need either 
arguments 	cache throwaway 
expect single 	copy evict reuse 
perform cleanup 	want pack 
need error 	type even reuse 
success disable 	delta since 
hook restore 	non delta representations 
readable 	could still 
handler unregistered 	reused determine delta 
script timeout 	whether reuse 
detected call 	otherwise find cheaply 
lua garbage 	possible actual 
collector time 	type size delta 
time 	hence already 
avoid full 	got need means 
cycle performed 	wish reuse 
lua adds 	delta data even 
latency call 	found list 
performed every 	objects want 
lua 	pack goodie depth 
cycle period 	matter find 
executed commands 	deltas never consider 
lua cycle 	reused delta 
period collection 	deltify objects order 
steps calling 	avoid circular 
every 	deltas must delta 
command uses 	already know 
much cpu 	type extract actual 
consume lua 	size delta 
reply error 	header choice fall 
handler success 	back recursive 
convert 	delta walk sha 
lua redis 	info find 
protocol send 	type point error 
client convert 	condition prepare 
consume reply 	pack permit missing 
error handler 	preferred ignored 
single 	preferred result 
commands replication 	larger pack file 
emit exec 	transfer still 
least write 	take place avoid 
evalsha propagated 	filesystem trashing 
slave aof 	loose objects search 
file 	deltas list 
full eval 	sorted type filename 
unless sure 	hash size 
script already 	see progressively smaller 
context attached 	smaller files 
slaves current 	prefer deltas bigger 
aof 	file smaller 
file enabled 	deletes potentially cheaper 
use cache 	perhaps importantly 
sha scripts 	bigger file likely 
already propagated 	recent one 
full eval 	deepest deltas 
called 	therefore oldest objects 
replication script 	less susceptible 
cache repliation 	accessed often newest 
everytime slave 	first cache 
attaches master 	delta objects large 
need flush 	enough compared 
cache 	delta size bother 
scripts replicated 	diffs different 
evalsha aof 	types bother delta 
need every 	discarded earlier 
time rewrite 	reusing delta data 
aof file 	note src 
script 	entry marked preferred 
script cache 	always considered 
replicate eval 	even produce suboptimal 
script cache 	delta still 
slaves aof 	save transfer cost 
know know 	already know 
match 	side won 
possible provided 	send src entry 
sha right 	bust allowed 
length error 	depth size filtering 
asap way 	heuristics load 
eval command 	data already done 
implemented 	objects included 
without length 	resulting pack resilient 
sanity check 	ignore read 
propagating command 	pack could created 
good idea 	nevertheless prefer 
ldb redis 	shallower sized deltas 
lua 	handle memory 
debugging facilities 	allocation outside cache 
initialize lua 	accounting compiler 
debugger data 	optimize strangeness away 
structures pending 	pthreads defined 
messages specified 	compute delta create 
list 	objects going 
enable debug 	pack current 
mode lua 	pack edge take 
scripts client 	depth objects 
exit debugging 	depend current account 
mode pov 	otherwise would 
client 	become deep decided 
function enough 	cache delta 
properly shut 	data best compress 
client debugging 	right away 
session see 	first anyway threaded 
ldb end 	save lot 
session 	time non threaded 
information append 	write phase 
log entry 	well allow caching 
specified ldb 	deltas within 
log version 	cache size limit 
ldb log 	writing stdout 
prevents 	since network likely 
producing logs 	throttling writes 
greater ldb 	anyway therefore 
maxlen first 	best write phase 
time limit 	asap instead 
reached hint 	afford spending time 
generated 	compressing writes 
inform user 	moment made delta 
reply trimming 	already max 
disabled debugger 	depth leaving window 
maxlen command 	pointless evict 
send ldb 	first move best 
logs 	delta window 
debugging client 	currently deltified keep 
multi bulk 	longer first 
reply consisting 	attempted next main 
simple log 	waits condition 
entries include 	least one workers 
newlines 	stopped working 
replaced spaces 	indicated working 
entries sent 	member work completed 
also consumed 	work sets 
avoid warning 	working signals main 
check write 	waits condition 
since 	data ready becomes 
next read 	mutex conditional 
error close 	variable statically initialized 
debugging session 	windows must 
start debugging 	data ready wait 
session calling 	condition main 
eval 	may order sure 
implementation techique 	work available 
use capture 	see data ready 
client socket 	initialized spawned 
file descriptor 	reset right away 
order perform 	working doesn 
direct 	work assigned partition 
within lua 	work amongst 
hooks way 	work threads 
enter redis 	use small segments 
order handle 	deltas found 
function returns 	split chunks path 
caller 	boundaries start 
proceed call 	work threads wait 
eval instead 	work completion 
caller abort 	time done work 
operation happens 	steal half 
parent forked 	remaining work largest 
session 	number unprocessed 
since children 	objects give newly 
fork returned 	idle ensure 
error caller 	good load balancing 
call ldb 	remaining list 
end session 	segments simply worth 
ldb 	splitting anymore 
start session 	possible paths many 
returned child 	objects hash 
ignore important 	boundary might 
signals handled 	found steal exact 
parent 	half tag 
log creation 	peelable packed locally 
child close 	repacking need 
listening socket 	doubly careful order 
make sure 	make sure 
parent crashes 	stealth corruption gets 
reset 	propagated pack 
sent clients 	clients receiving streamed 
parent close 	packs validate 
client parent 	everything anyway need 
side setup 	incur additional 
debugging session 	cost happens decided 
first 	reuse existing 
argument eval 	delta pack reuse 
script split 	delta implied 
different lines 	found include anyway 
since way 	compare objects 
debugger accesses 	offset order 
source 	order emulate git 
code end 	rev list 
debugging session 	objects output produced 
eval call 	pack originally 
debugging enabled 	store list sha 
returned emit 	discarded either 
remaining 	written recently reachable 
logs endsession 	another filled 
mark fork 	list tracks options 
session exit 	reader pack 
otherwise restore 	might understand would 
client state 	therefore prevent 
close 	blind reuse disk 
client connectin 	make sure 
sending eval 	shallows read threads 
reply order 	means autodetect 
signal end 	pack-objects.h idx size 
debugging session 	pack pack 
cleanup 	offset delta 
specified pid 	delta child delta 
among list 	sibling delta 
children spawned 	data delta size 
forked debugging 	delta size 
sessions removed 	hash pack pos 
children 	pack header 
list pid 	size objects objects 
found non 	alloc index 
zero returned 	index size pdata 
number children 	sha index 
still received 	pos pdata sha 
termination 	index pos 
acknowledge via 	name hash isspace 
wait parent 	uncompressed size 
process kill 	already pack delta 
forked sessions 	deltified objects 
wrapper eval 	bases deltified 
evalsha 	objects uses cached 
enables debugging 	delta uncompressed 
makes sure 	delta data size 
eval returns 	uncompressed delta 
whatever happened 	data size compressed 
session ended 	could delta 
pointer 	name hint hash 
ldb src 	pack available 
source code 	used delta objects 
line considering 	near tip 
line one 	refs assigned write 
returning special 	order effectively 
range 	creates sortable number 
lines breakpoint 	last sixteen 
specified line 	non whitespace characters 
specified breakpoint 	last characters 
ignore already 	count things end 
reached max 	sort together 
returns 	pack-redundant.c pack 
breakpoint added 	redundant usage load 
already space 	packs verbose 
breakpoint line 	alt odb next 
invalid specified 	sha front 
breakpoint returning 	back size next 
operation 	pack unique 
performed breakpoint 	objects objects next 
expect valid 	free nodes 
multi bulk 	item list list 
command debugging 	list ret 
client query 	old prev list 
buffer 	sha list 
success command 	sha list sha 
parsed returned 	hint cmp 
sds otherwise 	list sha hint 
returned read 	prev cmp 
buffer working 	hint entry ret 
copy 	ret step 
simpler modify 	step hint 
freely sake 	cmp old opl 
simpler parsing 	list subset 
redis protocol 	pll list diff 
parser joke 	ret step 
simplest 	step cmp subset 
thing works 	ret ret 
context also 	min min perm 
forgiving regarding 	perm perm 
broken protocol 	perm missing perm 
seek parse 	size hint 
count 	subset local alt 
multi bulk 	step filename 
len pointer 	argc argv prefix 
parse argument 	min red 
bulk len 	ignore sha buf 
pointer length 	arg alloc 
arg 	llist item put 
skip already 	llist item 
parsed argument 	put free 
skip log 	xmalloc llist init 
specified line 	llist item 
lua debugger 	llist item llist 
output 	item llist 
implement list 	insert hashcmp llist 
command lua 	insert llist 
debugger around 	insert back hashcmp 
whole file 	llist item 
listed otherwise 	put llist sorted 
small 	xmalloc memcpy 
portion file 	pack list difference 
around specified 	xmalloc memcpy 
line shown 	pack list difference 
line number 	hashcmp llist 
specified amonut 	sorted llist sorted 
context 	free free 
lines specified 	pack list 
via context 	size xmalloc pack 
argument append 	list insert 
human readable 	permutations xmalloc pack 
representation lua 	list insert 
position 	llist copy llist 
idx stack 	sorted difference 
lua state 	inplace llist free 
sds passed 	llist free 
argument sds 	hashcmp pack list 
represented attached 	insert pack 
returned 	list insert llist 
used order 	copy llist 
implement ldb 	sorted difference inplace 
log stack 	pack list 
element automatically 	size permutations superset 
removed stack 	xmalloc memcpy 
converted 	pll free die 
different type 	pack bytecount 
first index 	pack list 
expect check 	insert llist init 
fails note 	llist insert 
create two 	sorted unique llist 
representations 	sorted difference 
time one 	inplace cmp two 
assuming table 	packs llist 
one assuming 	sorted difference inplace 
end know 	llist sorted 
right one 	difference inplace llist 
first 	init open 
key start 	pack index llist 
iteration nil 	insert back 
test far 	llist copy pack 
table looks 	list insert 
like stack 	pack list insert 
table 	strlen die 
key repr 	strstr pack die 
full repr 	pack strcmp 
stack table 	usage strcmp 
key ready 	strcmp strcmp strcmp 
next iteration 	usage prepare 
strip 	packed git load 
last representations 	pack file 
right one 	die load objects 
discard higher 	cmp local 
level wrapper 	packs scan alt 
ldb cat 	odb packs 
stack 	llist init isatty 
rec uses 	fgets xmalloc 
initial recursion 	sha hex die 
level produce 	llist insert 
debugger log 	sorted unique llist 
entry representing 	sorted difference 
lua 	inplace llist sorted 
currently top 	difference inplace 
stack element 	minimize pack list 
popped modified 	size pack 
check ldb 	redundancy pack 
cat stack 	bytecount pack list 
actual 	difference sha 
implementation redis 	pack index name 
protocol reply 	pack bytecount 
appends human 	copyright lukas sandstrom 
readable form 	lukass etek 
passed sds 	chalmers file licensed 
note 	gpl objects 
sds passed 	must present local 
reference pointer 	packfiles insert 
pointer modified 	front insert entry 
pointer sds 	already exists 
semantics following 	insert end returns 
functions 	pointer item 
helpers ldb 	front sha list 
redis protocol 	since sorted 
human take 	found know 
care given 	previous element computes 
redis type 	cmp doesn 
log 	doesn permutations free 
redis reply 	time since 
debugger output 	refer done cmp 
human readable 	doesn doesn 
format resulting 	another function find 
longer len 	objects missing 
plus 	unique packs objects 
chars used 	missing unique 
prefix gets 	find permutations contain 
truncated print 	missing objects 
command lua 	find permutation smallest 
debugger scans 	size unique 
lua 	packs list objects 
varname starting 	present remote 
current stack 	packs scales like 
frame top 	list pruned 
stack frame 	cmp two 
first matching 	packs later sha 
variable 	ignore objects 
printed stack 	given stdin pack-refs.c 
level variable 	pack refs 
index discard 	usage argc argv 
name stack 	prefix flags 
vars two 	opts parse options 
selected 	usage options 
cases print 	pack refs pack-revindex.c 
command without 	entries max 
arguments lua 	tmp bits pos 
debugger prints 	swap num 
variables current 	ent index ofs 
stack 	revindex ofs 
frame variable 	pos alloc alloc 
index command 	memset bucket 
list breakpoints 	bucket memcpy free 
lua debugger 	free alloc 
eval command 	ntohl ntohl 
compiles 	ntohl ntohl sort 
user passed 	revindex create 
fragment code 	pack revindex error 
executes showing 	load pack 
result left 	revindex find revindex 
stack glue 	position pack 
script 	index existing packs 
together composed 	give easy 
multiple arguments 	access offsets corresponding 
compile expression 	pack file 
prepending failed 	data starts entries 
statement call 	store size 
implement 	compressed representation uncompressed 
debugger redis 	size easily 
command use 	available examining pack 
trick order 	entry header 
make implementation 	also rather expensive 
simple call 	find sha 
lua 	given offset 
redis call 	pack index file 
command implementation 	sorted name 
ldb step 	mapping offset revindex 
enabled side 	list offset 
effect redis 	index pairs ordered 
command 	offset know 
reply logged 	offset next offset 
stack redis 	packed representation 
redis call 	ends index used 
force redis 	sha main 
call log 	index least significant 
stack 	digit radix 
redis result 	sort sorts items 
disable logging 	entries offset 
discard result 	field max parameter 
clean stack 	must least 
trace command 	large largest offset 
lua 	lets quit 
debugger prints 	sort early 
backtrace querying 	use digit size 
lua starting 	bits keeps 
current callframe 	memory usage reasonable 
back outer 	generally smaller 
one 	packfile quit two 
impleemnts debugger 	rounds radix 
maxlen command 	sorting want know 
queries sets 	bucket digit 
ldb maxlen 	bits least significant 
variable user 	end need 
knows 	temporary storage rather 
command read 	extra copy 
debugging commands 	results entries sort 
client debugging 	back forth 
session continuing 	real temporary storage 
otherwise err 	iteration loop 
client 	keep track 
closed connection 	pointers always sorting 
timing processing 	max bits 
commands command 	zero know radix 
lua interpreter 	digit higher 
found make 	zero entries loop 
sure 	everybody lands 
script runs 	zero bucket want 
without user 	pos store 
input since 	index last element 
client longer 	bucket actually 
connected flush 	one past last 
old 	element first 
buffer execute 	count items bucket 
command free 	gives relative 
command vector 	offset last bucket 
free current 	cumulatively index 
command argv 	previous bucket index 
inside 	drop elements 
loop core 	correct buckets 
lua debugger 	temporary iterate pos 
called time 	counter backwards 
lua start 	avoid extra index 
executing line 	count since 
events 	going backwards must 
outside script 	also backwards 
interesting check 	keep sort stable 
timeout occurred 	note use 
timeout ignore 	iterator make sure 
count client 	handle objects 
closed 	even bit system 
connection timeout 	means cannot 
connection kill 	use obvious loop 
script otherwise 	condition counting 
process remain 	backwards must instead 
blocked indefinitely 	check wrap 
sdallocx.c 	around max contains 
ptr nsz 	sorted list 
alignment total 	swap next 
mallocx sdallocx 	iteration ended data 
nallocx mallocx 	original great 
align mallocx 	move back temporary 
mallocx 	storage ordered 
align sdallocx 	list offsets objects 
mallocx align 	pack knows 
test sds.c 	pack format trailer 
type size 	follows immediately 
init initlen 	last data pack-revindex.h 
type 	offset ofs 
hdrlen init 	ofs pack-write.c opts 
initlen reallen 	offset opts 
addlen newsh 	ofsval index name 
avail len 	objects objects 
newlen type 	opts sha sorted 
oldtype 	sha list 
hdrlen newsh 	last last obj 
type oldtype 	offset index 
hdrlen len 	version tmp 
alloc incr 	file hdr next 
flags len 	obj obj 
oldlen 	offset large offset 
len curlen 	obj crc 
len curlen 	val obj offset 
len aux 	obj offset 
aux buf 	split entries hdr 
len fmt 	pack pack 
cpy 	sha pack name 
staticbuf buflen 	count pack 
fmt fmt 	sha pack offset 
initlen next 	aligned buf 
str num 	old sha ctx 
unum buf 	sha ctx 
buf 	hdr buf sha 
cset start 	packname name 
end len 	encode pack 
start end 	header pack tmp 
newlen len 	name tmpname 
minlen cmp 	name buffer pack 
len 	tmp name 
sep seplen 	written list written 
count tokens 	pack idx 
newtokens tokens 	opts sha idx 
count len 	tmp name 
line argc 	basename len memset 
current 	hashcmp bsearch 
vector inq 	qsort sha check 
insq done 	odb mkstemp 
setlen argv 	xstrdup unlink open 
argc sep 	die errno 
argv argc 	sha need large 
sep 	offset htonl 
seplen size 	htonl sha write 
ptr size 	htonl sha 
ptr oldfree 	write htonl 
oldlen type 	sha write sha 
sds req 	write hashcmp 
type 	die sha hex 
sds hdr 	htonl sha 
size malloc 	write need large 
memset sds 	offset htonl 
hdr sds 	sha write need 
hdr sds 	large offset 
hdr 	htonl htonl sha 
sds hdr 	write sha 
memcpy sdsnewlen 	write sha close 
strlen sdsnewlen 	htonl htonl 
sdsnewlen sdslen 	htonl sha write 
free sds 	git sha 
hdr 	init git sha 
size strlen 	init lseek 
sdssetlen sdssetlen 	die errno read 
sdsavail sdslen 	full die 
sds hdr 	errno lseek 
size sds 	die errno git 
req 	sha update 
type sds 	htonl git sha 
hdr size 	update write 
realloc malloc 	die xmalloc xread 
memcpy free 	die errno 
sdssetlen sdssetalloc 	git sha update 
sdslen 	git sha 
sds hdr 	update git sha 
size sds 	hashcmp die 
req type 	git sha init 
sds hdr 	msb free 
size realloc 	git sha git 
malloc 	sha write 
memcpy free 	die fsync die 
sdssetlen sdssetalloc 	read full 
sdsalloc sds 	skip prefix xstrfmt 
hdr size 	directory odb 
sds hdr 	mkstemp xstrdup 
size 	sha adjust shared 
sds type 	perm die 
len sds 	errno write idx 
hdr sds 	file adjust 
hdr sds 	shared perm die 
hdr sds 	errno strbuf 
hdr 	addf sha hex 
sdslen sds 	free pack 
make room 	name rename die 
memset sdssetlen 	errno strbuf 
sdslen sds 	setlen strbuf addf 
make 	sha hex 
room memcpy 	rename die errno 
sdssetlen sdscatlen 	strbuf setlen 
strlen sdscatlen 	free entry sha 
sdslen sdsalloc 	contains pack 
sds make 	content sha 
room 	hash exit sha 
sdslen memcpy 	hash sorted 
sdssetlen sdscpylen 	names objects passed 
strlen sdsll 	sorted sha 
str sdsnewlen 	exit last offset 
strlen malloc 	use index 
copy 	index versions need 
vsnprintf end 	header write 
free malloc 	first level table 
sdscat free 	list sorted 
start sdscatvprintf 	use entry lookup 
end sdslen 	able avoid 
start 	eight extra binary 
sdsavail sds 	search iterations 
make room 	write actual sha 
arg strlen 	entries write 
sdslen sdsavail 	crc table write 
sds make 	bit offset 
room 	table write 
memcpy sdsinclen 	large offset table 
arg sdsll 	update pack 
str sdsavail 	header count compute 
sds make 	sha pack 
room memcpy 	data associated pack 
sdsinclen 	write sha 
sdsull str 	end sha also 
sdsavail sds 	returned pack 
make room 	sha pack sha 
memcpy sdsinclen 	non sha 
sdsinclen sdsinclen 	existing pack without 
end 	header update 
sdslen strchr 	computed validated one 
strchr memmove 	provided pack 
sdssetlen sdslen 	sha validation performed 
memmove sdssetlen 	pack offset 
sdslen tolower 	bytes pack file 
sdslen 	sha remaining 
toupper sdslen 	data pack 
sdslen memcmp 	offset end computed 
malloc realloc 	returned pack 
memcmp sdsnewlen 	sha note pack 
sdsnewlen sdsfree 	sha updated 
free 	last pack sha 
sdsfree free 	pack sha 
sdscatlen sdscatprintf 	refer buffer caller 
sdscatlen sdscatlen 	interested resulting 
sdscatlen sdscatlen 	sha pack data 
sdscatlen isprint 	pack offset 
sdscatprintf 	compute sha remainder 
sdscatprintf sdscatlen 	pack also 
isspace sdsempty 	means making pack 
hex digit 	offset big 
hex digit 	enough matter anymore 
hex digit 	first thing 
hex 	expect index pack 
digit sdscatlen 	output pack 
sdscatlen isspace 	keep bytes 
sdscatlen sdscatlen 	newly created pack 
isspace sdscatlen 	sha name 
sdscatlen realloc 	keep need corresponding 
malloc 	keep file 
sdsfree free 	later tough luck 
sdsfree sdslen 	per header 
sdsempty sdscat 	pretty dense thing 
sdscat sdsempty 	first low 
sdscatsds sdscatlen 	four bits size 
malloc 	three bits 
realloc free 	type high bit 
sdsnew sdsfree 	size continues 
sdsnewlen sdscat 	afterwards low seven 
test cond 	bits size 
sdslen memcmp 	continuation high bit 
sdscpy 	size continues 
sdscpy sdsfree 	pack.h hdr signature 
sdscatprintf sdsempty 	hdr version 
sdsfree sdsnew 	hdr entries 
sdscatfmt sdsfree 	flags version limit 
sdsnew sdscatfmt 	anomaly alloc 
sdsfree 	anomaly anomaly pack 
sdsnew sdstrim 	idx option 
sdsfree sdsnew 	idx signature idx 
sdstrim sdsfree 	version sha 
sdsnew sdstrim 	crc offset index 
sdsdup sdsrange 	name objects 
sdsfree 	objects pack idx 
sdsdup sdsrange 	option sha 
sdsfree sdsdup 	curs offset len 
sdsrange sdsfree 	packed git 
sdsdup sdsrange 	packed git progress 
sdsfree sdsdup 	encode pack 
sdsrange 	header pack header 
sdsfree sdsdup 	pack tmp 
sdsrange sdsfree 	name name 
sdsfree sdsnew 	buffer pack tmp 
sdsnew sdsfree 	name written 
sdsfree sdsnew 	list written pack 
sdsnew 	idx opts 
sdsfree sdsfree 	sha packed header 
sdsnew sdsnew 	pack first 
sdsfree sdsfree 	four bytes index 
sdsnewlen sdscatrepr 	formats later 
sdsempty sdslen 	version start signature 
sdsfree 	older git 
sdsfree sdsnew 	binaries would find 
test cond 	illegal abort 
sdslen sdsavail 	reading file number 
sdslen sds 	objects packfile 
make room 	cannot exceed every 
test 	would need 
cond sdslen 	least bytes data 
test cond 	overall packfile 
sdsavail sdsavail 	cannot exceed 
sds incr 	version index file 
len test 	due offsets 
cond 	limited bits clearly 
memcmp test 	signature exceeds 
cond sdslen 	maximum old git 
sdsfree sds 	binaries also 
test sds 	compare first bytes 
lib library 	next bytes 
copyright 	index abort non 
salvatore sanfilippo 	monotonic index 
antirez gmail 	error second word 
dot copyright 	smaller first 
oran agra 	word would proposed 
copyright redis 	future index 
labs 	format idx signature 
inc rights 	would greater 
reserved redistribution 	idx version flag 
use source 	bits verify 
binary forms 	write idx 
without modification 	file list offsets 
permitted 	would fit 
provided following 	within limit need 
conditions met 	written bit 
redistributions source 	entity verification packed 
code must 	index header 
retain copyright 	common part structure 
notice 	used write 
list conditions 	idx file pager.c 
following disclaimer 	pager process 
redistributions binary 	signal signo stdout 
form must 	tty pager 
reproduce copyright 	pager process pager 
notice 	pager env 
list conditions 	term columns startup 
following disclaimer 	col cols 
documentation materials 	number width cmd 
provided distribution 	want key 
neither name 	fflush fflush 
redis 	close close finish 
names contributors 	command signal 
may used 	finish command wait 
endorse promote 	pager wait 
products derived 	pager sigchain pop 
software without 	getenv git 
specific 	config getenv strcmp 
prior written 	argv push 
permission software 	getenv argv push 
provided copyright 	getenv argv 
holders contributors 	push git pager 
express implied 	isatty term 
warranties 	columns setenv prepare 
including limited 	pager args 
implied warranties 	argv push start 
merchantability fitness 	command dup 
particular purpose 	isatty dup 
disclaimed shall 	close sigchain push 
copyright 	common atexit 
owner contributors 	getenv git config 
liable direct 	getenv atoi 
indirect incidental 	ioctl strbuf addf 
special exemplary 	git config 
consequential damages 	key valid git 
including 	config git 
limited procurement 	config maybe xstrdup 
substitute goods 	strbuf release 
services loss 	split rest git 
use data 	something different 
profits business 	windows signal eof 
interruption 	pager force 
however caused 	computing width terminal 
theory liability 	redirect standard 
whether contract 	output pager spawn 
strict liability 	pager original 
tort including 	process continues 
negligence 	writes pipe makes 
otherwise arising 	sure parent 
way use 	terminates pager cached 
software even 	columns environment 
advised possibility 	variable positive ioctl 
damage create 	tiocgwinsz col 
sds 	positive fails many 
content specified 	columns need 
init pointer 	show number returns 
initlen used 	pager use 
init initialized 	pager specified param.h 
zero bytes 	intentionally empty 
always 	file support building 
termined sds 	git msvc 
always even 	parse-options-cb.c opt arg 
create sds 	unset opt 
mystring sdsnewlen 	arg unset opt 
abc print 	arg unset 
end 	opt arg 
however binary 	unset opt arg 
safe contain 	unset target 
characters middle 	opt arg unset 
length stored 	sha commit 
sds header 	opt arg unset 
empty 	sha opt 
usually created 	arg unset target 
order append 	dst dst 
use type 	size src opt 
since type 	arg unset 
good flags 	opt arg unset 
pointer 	opt arg 
create empty 	unset opt arg 
zero length 	unset opt 
sds even 	opt arg unset 
always term 	opt strtol 
create sds 	opterror approxidate parse 
starting 	expiry date 
terminated duplicate 	git config 
sds free 	colorbool opterror sha 
sds operation 	error lookup 
performed sds 	commit reference error 
length length 	commit list 
obtained 	insert sha clear 
strlen considering 	sha error 
content first 	sha append list 
term character 	clear list 
function useful 	append xstrdup strbuf 
sds hacked 	reset strbuf 
manually 	addstr strbuf addstr 
way like 	strbuf addch 
following example 	strbuf addstr strbuf 
sdsnew foobar 	addch strbuf 
sdsupdatelen sdslen 	addch strbuf addstr 
output comment 	recreate opt 
call 	free strbuf 
sdsupdatelen output 	detach recreate opt 
modified logical 	argv push 
length remains 	often used options 
bytes modify 	quiet verbose 
sds place 	recreates command line 
make 	option strbuf 
empty zero 	option opt recreates 
length however 	command line 
existing buffer 	option opt must 
discarded free 	initialized useful 
space next 	need pass command 
append 	line option 
operations require 	another command since 
allocations number 	previous overwritten 
bytes previously 	callback used options 
available enlarge 	last one 
free space 	wins option opt 
end 	recreate command 
sds caller 	line option 
sure calling 	appending opt must 
function overwrite 	argv useful 
addlen bytes 	need pass command 
end plus 	line option 
one 	specified multiple times 
nul term 	another command 
note change 	parse-options.c opt reason 
length sds 	opt flags 
returned sdslen 	arg prefix file 
free buffer 	opt opts 
space 	flags message name 
asap enough 	opt opts 
space left 	flags arg unset 
use type 	err options 
user appending 	opts numopt len 
type able 	arg arg 
remember 	options opts arg 
empty space 	end ambiguous 
sds make 	option ambiguous 
room must 	flags rest name 
called every 	opt flags 
appending operation 	arg options opts 
since 	arg options 
header size 	opts err opts 
changes need 	ctx argc 
move forward 	argv prefix options 
use realloc 	flags parse 
reallocate sds 	opt ctx option 
free 	ctx options 
space end 	usagestr help err 
contained remains 	arg ctx 
altered next 	argc argv prefix 
concatenation operations 	options usagestr 
require reallocation 	flags ctx opts 
call 	outfile ctx 
passed sds 	usagestr opts full 
longer valid 	err outfile 
references must 	pos pad 
substituted pointer 	usagestr opts msg 
returned call 	usagestr options 
total 	opt reason flags 
size allocation 	error error 
specifed sds 	error opterror absolute 
including sds 	path strcmp 
header pointer 	xstrdup prefix filename 
free buffer 	strlen strbuf 
end 	addf strbuf addf 
term pointer 	strbuf addf 
actual sds 	strbuf release opterror 
allocation normally 	strbuf release 
sds referenced 	opterror opterror opterror 
start buffer 	opterror opt 
increment 	command mode error 
sds length 	arg arg 
decrements left 	fix filename callback 
free space 	callback callback 
end according 	arg callback 
incr also 	arg strtol opterror 
term 	arg git 
end function 	parse opterror die 
used order 	isdigit isdigit 
fix length 	xmemdupz callback free 
user calls 	strchrnul skip 
sds make 	prefix opterror strncmp 
room 	starts starts 
writes something 	starts skip prefix 
end current 	starts error 
needs length 	strlen starts error 
note possible 	exit starts 
use negative 	error exit memset 
increment 	optbug optbug 
order right 	optbug optbug optbug 
trim usage 	strcspn strlen 
example sds 	optbug exit 
incr len 	memset die parse 
sds make 	options check 
room 	parse nodash opt 
possible mount 	strcmp parse 
following schema 	opt check typos 
cat bytes 	check typos 
coming kernel 	parse opt xstrdup 
end sds 	strcmp usage 
without 	options strcmp parse 
copying intermediate 	opt usage 
buffer oldlen 	options memmove parse 
sdslen sds 	options start 
make room 	parse options step 
buffer size 	exit error 
nread 	isascii error error 
read oldlen 	usage options 
buffer size 	precompose argv parse 
check nread 	options end 
handle sds 	utf putchar 
incr len 	fputc fputc utf 
nread 	usage argh 
avoid compilation 	fputc fputc fputs 
warnings grow 	usage options 
sds specified 	exit usage options 
length bytes 	error error 
part original 	error find option 
length 	used variable 
sds zero 	already report compatible 
specified length 	giving mode 
smaller current 	option twice although 
length operation 	unnecessary grave 
performed make 	error pass handle 
sure 	numerical option 
added region 	later one digit 
doesn contain 	options take 
garbage also 	precedence abbreviated abbreviated 
trailing append 	ambiguous exact 
specified binary 	match later 
safe 	need error negation 
pointed len 	allowed negated 
bytes end 	abbreviated much negated 
specified sds 	abbreviated negated 
call passed 	usually accepts argument 
sds longer 	must reset 
valid 	opt unknown option 
references must 	dangling lone 
substituted pointer 	asks help fake 
returned call 	option thing 
append specified 	hide fact may 
termianted sds 	started parse 
call 	aggregated stuff leaky 
passed sds 	bad parse 
longer valid 	opt unknown translators 
references must 	colon align 
substituted pointer 	one usage translation 
returned call 	parse-options.h name 
append 	name argh 
specified sds 	help flags callback 
existing sds 	defval argc 
call modified 	argv prefix options 
sds longer 	usagestr flags 
valid references 	usagestr options msg 
must 	usagestr options 
substituted pointer 	opt reason opt 
returned call 	reason flags 
destructively modify 	argv argc cpidx 
sds hold 	total opt 
specified binary 	flags prefix ctx 
safe 	argc argv 
pointed length 	prefix options flags 
len bytes 	ctx options 
like sdscpylen 	usagestr ctx dst 
must termined 	src option 
length obtained 	option option 
strlen 	option option option 
helper sdscatlonglong 	option option 
actual number 	option option option 
conversion must 	option special 
point room 	types options arguments 
least sds 	options arguments 
llstr 	usually type holds 
size bytes 	type option 
function returns 	must option end 
length terminated 	last name 
representation stored 	character use option 
generate representation 	name none 
method 	name option name 
produces reversed 	without leading 
compute length 	dashes none stores 
term reverse 	pointers values 
identical sdsll 	filled argh token 
str 	explain kind 
type generate 	argument option 
representation method 	wants keep homogeneous 
produces reversed 	across repository 
compute length 	wrapped translation help 
term reverse 	help associated 
create 	option must never 
sds much 	option end 
faster sdscatprintf 	option uses pointer 
sdsempty lld 	store header 
like sdscatprintf 	wrapped translation flags 
gets list 	mask parse 
instead 	opt option flags 
variadic start 	parse opt 
buffer speed 	optarg says argument 
possible revert 	optional boolea 
heap allocation 	parse opt noarg 
buffers two 	says option 
times 	take argument parse 
bigger every 	opt noneg 
time fail 	says option 
fit current 	cannot negated parse 
buffer size 	opt hidden 
concat obtained 	option skipped usage 
sds 	shown full 
append sds 	usage parse opt 
obtained alike 	lastarg says 
format specifier 	option take argument 
call modified 	given option 
sds longer 	last command line 
valid 	option last 
references must 	require argument used 
substituted pointer 	parse opt 
returned call 	optarg parse opt 
example sdsnew 	nodash option 
sum sdscatprintf 	doesn start dash 
often 	parse opt 
need create 	arghelp says argh 
scratch alike 	shouldn enclosed 
format need 	brackets argh 
use sdsempty 	help message useful 
target sdscatprintf 	options multiple 
sdsempty 	parameters callback pointer 
format args 	callback use 
function similar 	option callback option 
sdscatprintf much 	lowlevel callback 
faster rely 	defval fill parse 
sprintf family 	opt optarg 
functions 	option bit store 
implemented libc 	mask integer 
often slow 	put met callbacks 
moreover directly 	use like 
handling sds 	want parse options 
data concatenated 	filter processed 
provides 	options non option 
performance improvement 	arguments argv 
however function 	usagestr marked 
handles incompatible 	translation returns number 
subset alike 	arguments left 
format specifiers 	argv incremental advanced 
sds 	okay caller 
bit integer 	consume argv argc 
bit integer 	usual way 
verbatim character 	fields structure parse 
next format 	options modified 
specifier process 	way often used 
position 	options patch-delta.c 
next write 	src buf src 
dest str 	size delta 
make sure 	buf delta size 
always space 	dst size 
least handle 	data top dst 
generally 	buf cmd 
unknown term 	size size delta 
part left 	hdr size 
right composed 	delta hdr 
contiguous characters 	size xmallocz overflows 
found cset 	memcpy memcpy 
terminted 	error error free 
call modified 	patch delta 
sds longer 	recreate buffer source 
valid references 	delta produced 
must substituted 	diff delta nicolas 
pointer returned 	pitre nico 
call 	fluxnic net code 
example sdsnew 	free software 
hello world 	redistribute modify terms 
sdstrim output 	gnu general 
hello world 	license version published 
turn smaller 	free software 
equal 	foundation make sure 
containing substring 	orig file 
specified start 	size matches expect 
end indexes 	result size 
start end 	cmd reserved 
negative means 	future encoding extensions 
last 	mean time 
character penultimate 	must fail encountering 
character forth 	might data 
interval inclusive 	corruption sanity check 
start end 	patch-id.c patchlen 
characters part 	result name line 
resulting 	src dst 
modified place 	digits result ctx 
example sdsnew 	hash carry 
hello world 	next oid result 
sdsrange ello 	line buf 
world apply 	stable found next 
tolower 	ctx line 
every character 	len stable oid 
sds apply 	result patchlen 
toupper every 	line buf patch 
character sds 	usage stable 
compare two 	argc argv 
sds 	prefix stable memcpy 
memcmp positive 	oid hex 
negative exactly 	oid hex isspace 
binary two 	strspn strspn 
share exactly 	strspn strspn atoi 
prefix one 	atoi git 
two 	sha git sha 
additional characters 	init git 
longer considered 	sha init oidclr 
greater smaller 	strbuf getwholeline 
one split 	memcmp memcmp memcmp 
separator sep 	memcmp strlen 
sds 	oid hex memcmp 
returned count 	memcmp memcmp 
reference number 	isalpha memcmp scan 
tokens returned 	hunk header 
memory zero 	memcmp flush one 
length zero 	hunk space 
length 	git sha 
separator returned 	update oidclr flush 
note sep 	one hunk 
able split 	oidclr feof one 
multi character 	patchid flush 
separator example 	current oidcpy strbuf 
sdssplit 	release strcmp 
foo bar 	git config git 
two elements 	config git 
foo bar 	config strcmp strcmp 
version function 	usage generate 
binary safe 	list sum carry 
requires 	ignore commit 
length arguments 	comments parsing diff 
sdssplit function 	header looking 
zero terminated 	valid hunk header 
make sure 	parse next 
room next 	hunk ignore 
element 	line numbers split 
one search 	end patch 
separator skip 	parsing another header 
separator element 	inside hunk 
sure room 	compute sha without 
tokens free 	whitespace nothing 
result 	unstable patch-ids.c commit 
returned sdssplitlen 	options sha 
nothing tokens 	index table table 
append sds 	table next 
escaped representation 	bucket ids ids 
non printable 	next patches 
characters 	commit ids bucket 
tested isprint 	ent sha 
turned escapes 	pos commit ids 
form hex 	commit ids 
number call 	diff sha diff 
modified sds 	root sha 
longer 	diffcore std 
valid references 	diff flush patch 
must substituted 	sha pos 
pointer returned 	memset diff setup 
call helper 	diff opt 
function sdssplitargs 	diff setup done 
returns 	free free 
non zero 	commit patch patch 
valid hex 	pos xcalloc 
digit helper 	hashcpy alloc grow 
function sdssplitargs 	memmove commit 
converts hex 	commit slop close 
digit 	enough patch-ids.h 
integer split 	patch seen diffopts 
line arguments 	alloc table 
every argument 	patches patch ids 
following programming 	patch ids 
language repl 	commit patch ids 
alike 	commit patch 
form foo 	ids patch 
bar newline 	ids path.c path 
supported xff 	mode bad 
otherstuff number 	path pathname index 
arguments stored 	path path 
argc 	buf fmt args 
sds returned 	len buf 
caller free 	dir len buf 
resulting sds 	dir file 
sdsfreesplitres note 	len buf len 
sdscatrepr able 	newdir newlen 
convert 	need sep dirname 
back quoted 	common list 
format sdssplitargs 	children len contents 
able parse 	key node 
function returns 	root key child 
allocated tokens 	old root 
success 	key baton result 
even input 	child common 
empty input 	trie common 
contains unbalanced 	trie done setup 
quotes closed 	unmatched baton 
quotes followed 	dir buf git 
non 	dir len 
space characters 	common dir len 
foo bar 	path buf 
foo skip 	git dir len 
blanks token 	buf fmt 
quotes single 	args gitdir len 
quotes 	buf fmt 
closing quote 	args fmt args 
must followed 	fmt pathname 
space nothing 	args fmt path 
unterminated quotes 	args fmt 
closing quote 	args fmt args 
must 	pathname buf 
followed space 	path fmt 
nothing unterminated 	args git dir 
quotes token 	git submodule 
vector even 	common dir git 
empty input 	submodule dir 
something 	path fmt args 
modify substituting 	buf buf 
occurrences characters 	path fmt args 
specified corresponding 	path buf 
character instance 	buffer sha len 
sdsmapchars mystring 	username len 
effect 	username path user 
turning hello 	path copy 
ell function 	first slash username 
returns sds 	username len 
pointer always 	home path strict 
input pointer 	validated path 
since 	used path suffix 
resize needed 	gitfile len 
specified separator 	newpath baselen 
also returns 	gitfile mode tweak 
result sds 	path old 
like sdsjoin 	mode mode dir 
joins 	share path 
sds wrappers 	path abs abs 
allocators used 	prefix len 
sds note 	prefix len prefix 
sds actually 	prefix buf 
use macros 	dst src prefix 
defined 	len dst 
sdsalloc order 	dst src path 
avoid pay 	prefixes max 
overhead function 	len ceil len 
calls define 	path len 
wrappers programs 	path suffix suffix 
sds 	len ndot 
linked want 	path len skip 
touch sds 	name len 
internals even 	filename home 
use different 	config home lstat 
allocator run 	strbuf reset 
test 	memcmp cleanup path 
times order 	strbuf start 
hit first 	vsnprintf end strlcpy 
two sds 	cleanup path 
header types 	strlen strncmp dir 
sds lib 	sep strlen 
library 	strncmp dir sep 
copyright salvatore 	dir sep 
sanfilippo antirez 	strcmp strlen dir 
gmail dot 	sep dir 
copyright oran 	sep strbuf splice 
agra copyright 	xcalloc strlen 
redis 	xmalloc memcpy malloc 
labs inc 	memcpy xstrndup 
rights reserved 	memset make trie 
redistribution use 	node trie 
source binary 	make trie 
forms without 	node trie find 
modification 	trie init 
permitted provided 	common trie git 
following conditions 	common dir 
met redistributions 	trie find replace 
source code 	dir strbuf 
must retain 	addf git dir 
copyright 	strbuf setlen 
notice list 	strbuf addstr file 
conditions following 	exists report 
disclaimer redistributions 	garbage strbuf release 
binary form 	dir file 
must reproduce 	strbuf splice graft 
copyright 	file strlen 
notice list 	graft file strcmp 
conditions following 	strbuf splice 
disclaimer documentation 	index file 
materials provided 	strlen index file 
distribution neither 	dir prefix 
name 	replace dir directory 
redis names 	update common 
contributors may 	dir strbuf addstr 
used endorse 	git dir 
promote products 	dir sep strbuf 
derived software 	addch strbuf 
without 	vaddf adjust git 
specific prior 	path strbuf 
written permission 	cleanup path strbuf 
software provided 	reset start 
copyright holders 	git path end 
contributors express 	start git 
implied 	path end pathname 
warranties including 	start git 
limited implied 	path end start 
warranties merchantability 	git path 
fitness particular 	end strbuf 
purpose disclaimed 	detach start strbuf 
shall 	vaddf end 
copyright owner 	strbuf cleanup path 
contributors liable 	strbuf detach 
direct indirect 	pathname start strbuf 
incidental special 	vaddf end 
exemplary consequential 	cleanup path strbuf 
damages 	addstr strbuf 
including limited 	complete strbuf addstr 
procurement substitute 	read gitfile 
goods services 	strbuf reset strbuf 
loss use 	addstr strbuf 
data profits 	addch strbuf addstr 
business 	strbuf vaddf 
interruption however 	common dir noenv 
caused theory 	update common 
liability whether 	dir strbuf cleanup 
contract strict 	path strbuf 
liability tort 	release strbuf 
including 	release start submodule 
negligence otherwise 	path end 
arising way 	strbuf detach start 
use software 	submodule path 
even advised 	end lstat islnk 
possibility damage 	readlink memcmp 
create 	open read full 
sds content 	close memcmp 
specified init 	isspace memcmp sha 
pointer initlen 	hex xmemdupz 
used init 	getpwnam free strchrnul 
initialized zero 	getenv strbuf 
bytes 	addstr getpw str 
always termined 	strbuf addstr 
sds always 	strbuf addstr strbuf 
even create 	detach strbuf 
sds mystring 	release strlen strbuf 
sdsnewlen abc 	reset strbuf 
print 	reset strbuf 
end however 	strbuf expand user 
binary safe 	path strbuf 
contain characters 	attach strlen strlen 
middle length 	strbuf addstr 
stored sds 	stat isreg isdir 
header 	git directory 
empty usually 	strbuf addstr strbuf 
created order 	setlen read 
append use 	gitfile strbuf reset 
type since 	strbuf addstr 
type good 	chdir read gitfile 
flags 	chdir git 
pointer create 	directory git dir 
empty zero 	check repository 
length sds 	format mode bits 
even always 	calc shared 
term create 	perm isdir chmod 
sds 	mkdir perror 
starting terminated 	exit adjust 
duplicate sds 	shared perm die 
free sds 	absolute path 
operation performed 	absolute path tolower 
sds length 	tolower strlen 
length 	strlen root dos 
obtained strlen 	drive prefix 
considering content 	dir sep dir 
first term 	sep dir 
character function 	sep dir sep 
useful sds 	dir sep 
hacked 	dir sep dir 
manually way 	sep strbuf 
like following 	reset strbuf grow 
example sdsnew 	dir sep 
foobar sdsupdatelen 	strbuf addstr dir 
sdslen output 	sep dir 
comment 	sep strbuf 
call sdsupdatelen 	addstr strbuf addstr 
output modified 	dir sep 
logical length 	dir sep dir 
remains bytes 	sep dir 
modify sds 	sep dir sep 
place 	dir sep 
make empty 	dir sep strbuf 
zero length 	reset strbuf 
however existing 	addstr strbuf addstr 
buffer discarded 	dos drive 
free space 	prefix dir sep 
next 	dir sep 
append operations 	dir sep dir 
require allocations 	sep dir 
number bytes 	sep dir sep 
previously available 	dir sep 
enlarge free 	dir sep dir 
space 	sep normalize 
end sds 	path copy 
caller sure 	len strcmp strlen 
calling function 	strncmp dir 
overwrite addlen 	sep strlen dir 
bytes end 	sep dir 
plus 	sep chomp trailing 
one nul 	dir sep 
term note 	chomp trailing dir 
change length 	sep dir 
sds returned 	sep xstrndup chomp 
sdslen free 	trailing dir 
buffer 	sep dir sep 
space asap 	spaces periods 
enough space 	strncasecmp spaces periods 
left use 	strncasecmp getenv 
type user 	mkpathdup getenv mkpathdup 
appending type 	utilities paths 
able 	pathnames clean buf 
remember empty 	dir file 
space sds 	without regex 
make room 	keep one replaced 
must called 	considered garbage 
every appending 	report linked checkout 
operation 	garbage common 
since header 	even though parent 
size changes 	compressed trie 
need move 	trie node consists 
forward use 	zero characters 
realloc 	common elements prefix 
reallocate sds 	optionally followed 
free space 	children trie node 
end contained 	terminal node 
remains altered 	example consider following 
next concatenation 	abc def 
operations 	definite definition trie 
require reallocation 	would look 
call passed 	look like root 
sds longer 	len children 
valid references 	non len 
must substituted 	contents data abc 
pointer 	len contents 
returned call 	children non data 
total size 	def len 
allocation specifed 	contents nit children 
sds including 	non len 
sds header 	children data definite 
pointer 	len contents 
free buffer 	children data definition 
end term 	key pair 
pointer actual 	trie key assumed 
sds allocation 	terminated existing 
normally sds 	key reached end 
referenced 	key split 
start buffer 	node child contain 
increment sds 	node existing 
length decrements 	children newly 
left free 	added child matched 
space end 	entire compressed 
according 	section search trie 
incr also 	key find 
term end 	longest terminated prefix 
function used 	key trie 
order fix 	contains call unmatched 
length user 	portion key 
calls 	found prefix key 
sds make 	partially normalized 
room writes 	consecutive slashes skipped 
something end 	example consider 
current needs 	trie containing refs 
length note 	refs worktree 
possible 	values key unmatched 
use negative 	val node 
increment order 	called refs refs 
right trim 	per refs 
usage example 	refs per 
sds incr 	refs refs per 
len 	refs worktree 
sds make 	refs worktree per 
room possible 	refs worktree 
mount following 	refs worktree per 
schema cat 	refs worktree 
bytes coming 	refs worktree per 
kernel 	reached end 
end sds 	key path normalization 
without copying 	skip consecutive 
intermediate buffer 	slashes matched entire 
oldlen sdslen 	compressed section 
sds make 	end key path 
room 	normalization skip 
buffer size 	consecutive slashes helper 
nread read 	function update 
oldlen buffer 	common dir returns 
size check 	dir prefix 
nread handle 	common make 
sds 	sure refs symlink 
incr len 	anything open 
nread avoid 	see symbolic symbolic 
compilation warnings 	detached head 
grow sds 	user expanded via 
specified length 	getpw buf 
bytes 	newly allocated returns 
part original 	getpw failure 
length sds 	path first one 
zero specified 	directory determined 
length smaller 	following algorithm strict 
current length 	given path 
operation 	used given dwim 
performed make 	done otherwise 
sure added 	path mean path 
region doesn 	running user 
contain garbage 	home directory user 
also trailing 	path mean 
append 	path named 
specified binary 	user home directory 
safe pointed 	relative path 
len bytes 	mean cwd relative 
end specified 	directory absolute 
sds call 	path mean absolute 
passed 	directory unless 
sds longer 	strict given check 
valid references 	git git 
must substituted 	git git order 
pointer returned 	first one 
call append 	valid git repository 
specified 	chdir none 
termianted sds 	match fail chdir 
call passed 	goes well 
sds longer 	directory used chdir 
valid references 	user expanded 
must substituted 	avoiding getcwd 
pointer 	resolving symbolic links 
returned call 	user relative 
append specified 	paths also returned 
sds existing 	given dwim 
sds call 	suffixing handle arbitrary 
modified sds 	sized buffers 
longer 	remains sanity check 
valid references 	untrusted input 
must substituted 	copy read bits 
pointer returned 	execute bits 
call destructively 	copy read bits 
modify sds 	execute bits 
hold 	give path relative 
specified binary 	prefix strbuf 
safe pointed 	may may used 
length len 	contains returned 
bytes like 	path bypass dos 
sdscpylen must 	drive identical 
termined 	prefix seems 
length obtained 	like prefix foo 
strlen helper 	prefix foobar 
sdscatlonglong actual 	prefix end prefix 
number conversion 	prefix bbb 
must point 	prefix prefix end 
room 	prefix simpler 
least sds 	implementation relative path 
llstr size 	relative path 
bytes function 	removing prefix function 
returns length 	first appears 
terminated representation 	bbbc makes git 
stored 	dir shorter 
generate representation 	increase performance traversing 
method produces 	path work 
reversed compute 	foo prefix foo 
length term 	foo prefix 
reverse identical 	foobar okay dst 
sdsll 	src overlap 
str type 	otherwise performs 
generate representation 	following normalizations src 
method produces 	storing result 
reversed compute 	dst ensures components 
length term 	separated windows 
reverse 	squashes sequences removes 
create sds 	components removes 
much faster 	components components precede 
sdscatprintf sdsempty 	returns failure 
lld like 	non zero component 
sdscatprintf gets 	appears first 
list 	path component anytime 
instead variadic 	normalization otherwise 
start buffer 	returns success note 
speed possible 	function purely 
revert heap 	textual follow symlinks 
allocation buffers 	verify existence 
two 	path make system 
times bigger 	calls prefix 
every time 	len specific 
fail fit 	prefix pathspec src 
current buffer 	dst src 
size concat 	prefix len already 
obtained 	normalized time 
sds append 	eats prefix len 
sds obtained 	part prefix 
alike format 	len reduced end 
specifier call 	prefix len 
modified sds 	remaining prefix overridden 
longer 	user pathspec 
valid references 	needswork function doesn 
must substituted 	perform normalization 
pointer returned 	trailing everything root 
call example 	folder normalized 
sdsnew sum 	path end callers 
sdscatprintf 	need accordingly 
often need 	path component begins 
create scratch 	could special 
alike format 	ends ignore 
need use 	terminate ignore eat 
sdsempty target 	slash ends 
sdscatprintf 	strip one terminate 
sdsempty format 	strip one 
args function 	eat slash copy 
similar sdscatprintf 	next eat 
much faster 	dst dst prefix 
rely sprintf 	portion dst 
family 	one level trailing 
functions implemented 	windows dst 
libc often 	cannot backslash anymore 
slow moreover 	path canonical 
directly handling 	absolute path prefixes 
sds data 	list containing 
concatenated 	normalized absolute paths 
provides performance 	without trailing 
improvement however 	slashes root 
function handles 	directory denoted determines 
incompatible subset 	path prefixes 
alike format 	whether prefix ancestor 
specifiers 	directory path 
sds bit 	returns length longest 
integer bit 	ancestor directory 
integer verbatim 	excluding trailing slashes 
character next 	prefix ancestor 
format specifier 	note means returned 
process 	prefixes foo 
position next 	considered ancestor foobar 
write dest 	directories considered 
str make 	ancestors path must 
sure always 	canonical form 
space least 	empty components components 
handle 	allowed root 
generally unknown 	matches anything length 
term part 	match length 
left right 	len match 
composed contiguous 	strip arbitrary amount 
characters found 	directory separators 
cset 	end path path 
terminted call 	ends suffix 
modified sds 	complete path components 
longer valid 	returns part 
references must 	suffix sans trailing 
substituted pointer 	directory separators 
returned 	otherwise returns resurrects 
call example 	belts suspenders 
sdsnew hello 	paranoia check hpa 
world sdstrim 	done zytor 
output hello 	enter repo getcwd 
world turn 	path canonicalization 
smaller 	becomes immediately seeing 
equal containing 	continues dots 
substring specified 	without intervening non 
start end 	dot character 
indexes start 	reject reject 
end negative 	pathspec.c pathspec seen 
means 	pathspec seen 
last character 	bit mnemonic name 
penultimate character 	prefixlen magic 
forth interval 	item magic raw 
inclusive start 	flags prefix 
end characters 	prefixlen elt glob 
part 	noglob icase 
resulting modified 	magic magic end 
place example 	match pathspec 
sdsnew hello 	prefix nextat len 
world sdsrange 	endptr len 
ello world 	pattern magic magic 
apply 	pathspec magic 
tolower every 	mask flags prefix 
character sds 	argv item 
apply toupper 	entry prefixlen exclude 
every character 	raw magic 
sds compare 	prefix pathspec 
two 	dst src pathspec 
sds memcmp 	path match 
positive negative 	xcalloc pathspec matches 
exactly binary 	index strbuf 
two share 	addstr size strbuf 
exactly prefix 	addch strbuf 
one 	addstr strbuf addf 
two additional 	git env 
characters longer 	git env git 
considered greater 	env die 
smaller one 	git env die 
split separator 	strcspn size 
sep 	strlen strncmp starts 
sds returned 	strtol die 
count reference 	size die die 
number tokens 	pathspec magic 
returned memory 	size size 
zero length 	die die die 
zero 	xstrdup xstrdup 
length separator 	prefix path gently 
returned note 	die prefix 
sep able 	magic strbuf strbuf 
split multi 	addf strbuf 
character separator 	addf strbuf addstr 
example 	strbuf detach 
sdssplit foo 	strlen cache name 
bar two 	pos isgitlink 
elements foo 	namelen isgitlink memcmp 
bar version 	die simple 
function binary 	length wildcard strcmp 
safe 	size strbuf 
requires length 	addch strbuf addf 
arguments sdssplit 	strbuf addf 
function zero 	die memset die 
terminated make 	die xcalloc 
sure room 	strlen alloc 
next 	strlen prefix pathspec 
element one 	unsupported magic 
search separator 	symlink leading path 
skip separator 	die die 
element sure 	die qsort parse 
room tokens 	pathspec alloc 
free 	memcpy free finds 
result returned 	given pathspecs 
sdssplitlen nothing 	match items index 
tokens append 	pathspec sets 
sds escaped 	corresponding entry seen 
representation non 	specs items 
printable 	size pathspec nature 
characters tested 	closest specific 
isprint turned 	match found pathspec 
escapes form 	index closer 
hex number 	type match existing 
call modified 	entry optimization 
sds 	matching skipped 
longer valid 	altogether seen already 
references must 	contains non 
substituted pointer 	zero entries seen 
returned call 	already written 
helper function 	may make sense 
sdssplitargs 	use find 
returns non 	pathspecs matching index 
zero valid 	instead since 
hex digit 	walking index walking 
helper function 	directory mark 
sdssplitargs converts 	matched pathspec seen 
hex 	otherwise mistakenly 
digit integer 	think user gave 
split line 	pathspec match 
arguments every 	anything finds given 
argument following 	pathspecs match 
programming language 	items index one 
repl 	shot wrapper 
alike form 	around pathspec 
foo bar 	matches index allocates 
newline supported 	populates returns 
xff otherstuff 	seen indicating nature 
number arguments 	closest specific 
stored 	matches given pathspecs 
argc sds 	achieves items 
returned caller 	index magic pathspec 
free resulting 	possible future 
sds sdsfreesplitres 	magic semantics include 
note sdscatrepr 	stuff like 
able 	pathspec recursive recursive 
convert back 	pathspec regexp 
quoted format 	regexp cannot take 
sdssplitargs able 	element pathspec 
parse function 	check magic signatures 
returns allocated 	append result 
tokens 	prefix magic 
success even 	bitmap parse syntax 
input empty 	anything top 
input contains 	magic needswork needs 
unbalanced quotes 	rewritten start 
closed quotes 	migrating pathspec users 
followed 	use pathspec 
non space 	example pathspec element 
characters foo 	may marked 
bar foo 	insensitive prefix part 
skip blanks 	must always 
token quotes 	match literally single 
single 	stupid cannot 
quotes closing 	express nothing longhand 
quote must 	handle would 
followed space 	wrong matter shorthand 
nothing unterminated 	noglob pathspec 
quotes closing 	adds unless glob 
quote 	specified glob 
must followed 	pathspec overridden 
space nothing 	prefix pathspec keep 
unterminated quotes 	magic assign 
token vector 	original useful passing 
even empty 	another command 
input 	preserve actual prefix 
something modify 	length pattern 
substituting occurrences 	strip trailing slash 
characters specified 	fixme enable 
corresponding character 	onestar glob pattern 
instance sdsmapchars 	sanity checks 
mystring 	pathspec matchers sane 
effect turning 	may want 
hello ell 	substitute command command 
function returns 	name interactive 
sds pointer 	dies running checkout 
always input 	given command 
pointer 	line arguments prefix 
since resize 	convert input 
needed specified 	pathspec die 
separator also 	magic magic mask 
returns result 	used arguments 
sds like 	prefix pathspec arguments 
sdsjoin 	prefix prefix 
joins sds 	pathspec pathspec deprecated 
wrappers allocators 	favor pathspec 
used sds 	see pathspec parse 
note sds 	pathspec arguments 
actually use 	prefix path relative 
macros 	root working 
defined sdsalloc 	pathspec list paths 
order avoid 	underneath prefix 
pay overhead 	path iterates pathspec 
function calls 	prepending path 
define wrappers 	prefix resulting list 
programs 	pathspec empty 
sds linked 	singleton list containing 
want touch 	prefix pathspec 
sds internals 	prefix empty 
even use 	empty list typically 
different allocator 	used built 
run 	commands order normalize 
test times 	argv arguments 
order hit 	provided built list 
first two 	paths process 
sds header 	relative root working 
types type 	pathspec.h raw 
size 	magic max depth 
init initlen 	match original 
type hdrlen 	magic len prefix 
init initlen 	nowildcard len 
reallen addlen 	flags pathspec magic 
newsh avail 	mask flags 
len 	prefix args dst 
newlen type 	src pathspec 
oldtype hdrlen 	item item pathspec 
newsh type 	pathspec seen 
oldtype hdrlen 	path path 
len alloc 	prefix strncasecmp strncmp 
incr 	strcasecmp strcmp 
flags len 	pathspec magic pathspec 
oldlen len 	pattern satisfies 
curlen len 	gfnm onestar pathspec 
curlen len 	result freed 
aux aux 	free pathspec parse 
buf 	pathspec flags 
len fmt 	args means match 
cpy staticbuf 	cwd args 
buflen fmt 	means match everything 
fmt initlen 	max depth 
next str 	field valid strip 
num 	trailing slash 
unum buf 	given path gitlink 
buf cset 	die symlink 
start end 	part given 
len start 	path directory like 
end 	combination leading 
newlen len 	path slash cheap 
minlen cmp 	strips trailing 
len sep 	slash given path 
seplen count 	gitlink also 
tokens newtokens 	checks dies gitlink 
tokens 	part leading 
count len 	path given path 
line argc 	goes beyond 
current vector 	submodule safer slash 
inq insq 	cheap also 
done setlen 	expensive callers need 
argv 	pure paths 
argc sep 	somewhere command line 
argv argc 	pathspecs options 
sep seplen 	ignored magic parsed 
size ptr 	pathspec either 
size ptr 	pathspec allowed 
oldfree 	automatically every pathspec 
oldlen type 	pathspec pkt-line.c 
sds req 	packet buffer packet 
type sds 	trace prefix 
hdr size 	trace packet trace 
malloc memset 	pack prog 
sds 	buf len sideband 
hdr sds 	buf len 
hdr sds 	write pack sideband 
hdr sds 	buf fmt 
hdr memcpy 	args hexchar orig 
sdsnewlen strlen 	len fmt 
sdsnewlen 	buf args buf 
sdsnewlen sdslen 	fmt args 
free sds 	src buf src 
hdr size 	size dst 
strlen sdssetlen 	size options ret 
sdssetlen sdsavail 	linelen len 
sdslen 	src buf 
sds hdr 	src len buffer 
size sds 	size options 
req type 	len ret linelen 
sds hdr 	src src 
size realloc 	len dst len 
malloc 	len len 
memcpy free 	src src len 
sdssetlen sdssetalloc 	dst len 
sdslen sds 	trace key init 
hdr size 	trace key 
sds req 	init xstrdup trace 
type 	verbatim trace 
sds hdr 	verbatim trace want 
size realloc 	trace want 
malloc memcpy 	packet trace pack 
free sdssetlen 	starts starts 
sdssetalloc sdsalloc 	packet trace pack 
sds 	strlen trace 
hdr size 	want strbuf 
sds hdr 	init strbuf addf 
size sds 	trace prefix 
type len 	strbuf addch strbuf 
sds hdr 	addf strbuf 
sds 	addch trace strbuf 
hdr sds 	strbuf release 
hdr sds 	packet trace write 
hdr sdslen 	die packet 
sds make 	trace strbuf strbuf 
room memset 	addstr strbuf 
sdssetlen 	vaddf die hex 
sdslen sds 	hex hex 
make room 	hex packet trace 
memcpy sdssetlen 	strbuf reset 
sdscatlen strlen 	start format packet 
sdscatlen sdslen 	end write 
sdsalloc 	die start 
sds make 	format packet end 
room sdslen 	die memcpy 
memcpy sdssetlen 	read full die 
sdscpylen strlen 	errno die 
sdsll str 	packet data packet 
sdsnewlen 	length die 
strlen malloc 	packet trace die 
copy vsnprintf 	packet data 
end free 	packet trace packet 
malloc sdscat 	read packet 
free start 	read line packet 
sdscatvprintf 	read line 
end sdslen 	another non pack 
start sdsavail 	sideband make 
sds make 	note human readable 
room arg 	trace pack 
strlen sdslen 	data started guess 
sdsavail 	header quoting 
sds make 	xxx really 
room memcpy 	handle printable utf 
sdsinclen arg 	suppress newlines 
sdsll str 	buffered things flush 
sdsavail sds 	read size 
make 	bytes source whatever 
room memcpy 	complain didn 
sdsinclen sdsull 	enough bytes satisfy 
str sdsavail 	read pkt-line.h 
sds make 	attribute buf attribute 
room memcpy 	src buffer 
sdsinclen 	src len buffer 
sdsinclen sdsinclen 	size options 
end sdslen 	size src buf 
strchr strchr 	src len 
memmove sdssetlen 	size packet buffer 
sdslen memmove 	write packetized 
sdssetlen 	stream line preceded 
sdslen tolower 	length including 
sdslen toupper 	header hex 
sdslen sdslen 	number length zero 
memcmp malloc 	means end 
realloc memcmp 	stream length would 
sdsnewlen 	error pretty 
sdsnewlen sdsfree 	stupid use packetized 
free sdsfree 	line format 
free sdscatlen 	make streaming format 
sdscatprintf sdscatlen 	possible without 
sdscatlen sdscatlen 	ever running read 
sdscatlen 	buffers way 
sdscatlen isprint 	never read might 
sdscatprintf sdscatprintf 	pack data 
sdscatlen isspace 	another process entirely 
sdsempty hex 	writing side 
digit hex 	could use stdio 
digit 	since reading 
hex digit 	side stay pure 
hex digit 	read write 
sdscatlen sdscatlen 	interfaces read 
isspace sdscatlen 	packetized line buffer 
sdscatlen isspace 	must least 
sdscatlen 	size bytes specifies 
sdscatlen realloc 	number bytes 
malloc sdsfree 	read buffer src 
free sdsfree 	buffer src 
sdslen sdsempty 	buffer point buffer 
sdscat sdscat 	containing packet 
sdsempty 	data parse least 
sdscatsds sdscatlen 	src len 
malloc realloc 	bytes function returns 
free sdsnew 	src buf 
sdsfree sdsnewlen 	incremented src len 
sdscat test 	decremented number 
cond 	bytes consumed src 
sdslen memcmp 	buffer src 
sdscpy sdscpy 	buffer data 
sdsfree sdscatprintf 	read descriptor options 
sdsempty sdsfree 	contain packet 
sdsnew sdscatfmt 	read gentle eof 
sdsfree 	die following 
sdsnew sdscatfmt 	conditions read error 
sdsfree sdsnew 	descriptor protocol 
sdstrim sdsfree 	error remote bogus 
sdsnew sdstrim 	length characters 
sdsfree sdsnew 	receiving packet larger 
sdstrim 	size bytes 
sdsdup sdsrange 	truncated output remote 
sdsfree sdsdup 	expected packet 
sdsrange sdsfree 	got eof got 
sdsdup sdsrange 	packet followed 
sdsfree sdsdup 	eof options contain 
sdsrange 	packet read 
sdsfree sdsdup 	gentle eof die 
sdsrange sdsfree 	condition truncated 
sdsdup sdsrange 	input instead 
sdsfree sdsfree 	however still die 
sdsnew sdsnew 	conditions options 
sdsfree 	contains packet read 
sdsfree sdsnew 	chomp newline 
sdsnew sdsfree 	trailing newline present 
sdsfree sdsnew 	removed buffer 
sdsnew sdsfree 	returning convenience wrapper 
sdsfree sdsnewlen 	packet read 
sdscatrepr 	gentle sets chomp 
sdsempty sdslen 	newline option 
sdsfree sdsfree 	flush packet otherwise 
sdsnew test 	points buffer 
cond sdslen 	may overwritten subsequent 
sdsavail sdslen 	calls size 
sds 	parameter length packet 
make room 	written packet 
test cond 	read line read 
sdslen test 	buf rather 
cond sdsavail 	descriptor see 
sdsavail sds 	packet read details 
incr 	src used 
len test 	poll.c sought ret 
cond memcmp 	happened irbuffer 
test cond 	avail nbuffer ret 
sdslen sdsfree 	iosb fpli 
sds test 	query information file 
sds 	sought network 
lib library 	events happened error 
copyright salvatore 	data sought 
sanfilippo antirez 	rfds wfds efds 
gmail dot 	happened socket 
copyright oran 	errno data pfd 
agra 	nfd timeout 
copyright redis 	rfds wfds efds 
labs inc 	ptv maxfd 
rights reserved 	open max happened 
redistribution use 	handle ret 
source binary 	wait timeout 
forms 	nhandles elapsed orig 
without modification 	timeout rfds 
permitted provided 	wfds xfds poll 
following conditions 	msg sought 
met redistributions 	requested ret happened 
source code 	sought console 
must 	handle wsa network 
retain copyright 	events file 
notice list 	type proc address 
conditions following 	module handle 
disclaimer redistributions 	peek named pipe 
binary form 	last error 
must 	memset memset query 
reproduce copyright 	information file 
notice list 	wait single console 
conditions following 	handle number 
disclaimer documentation 	console input events 
materials provided 	alloca peek 
distribution 	console input 
neither name 	wait single wsa 
redis names 	last error 
contributors may 	recv wsa last 
used endorse 	error wsa 
promote products 	last error isset 
derived 	recv ioctl 
software without 	recv isset isset 
specific prior 	sysconf zero 
written permission 	zero zero compute 
software provided 	revents tick 
copyright holders 	count create zero 
contributors 	zero zero 
express implied 	osfhandle socket handle 
warranties including 	wsa win 
limited implied 	compute revents msg 
warranties merchantability 	wait multiple 
fitness particular 	objects peek 
purpose 	message translate message 
disclaimed shall 	dispatch message 
copyright owner 	osfhandle wsa network 
contributors liable 	events wsa 
direct indirect 	isset isset isset 
incidental special 	win compute 
exemplary 	revents socket win 
consequential damages 	compute revents 
including limited 	tick count sleep 
procurement substitute 	emulation poll 
goods services 	contributed paolo bonzini 
loss use 	copyright free 
data 	software foundation inc 
profits business 	file part 
interruption however 	gnulib program free 
caused theory 	software redistribute 
liability whether 	modify terms gnu 
contract strict 	general license 
liability 	published free 
tort including 	software foundation either 
negligence otherwise 	version option 
arising way 	later version program 
use software 	distributed hope 
even advised 	useful without warranty 
possibility 	without even 
damage create 	implied warranty merchantability 
sds content 	fitness particular 
specified init 	purpose see gnu 
pointer initlen 	general license 
used init 	details received copy 
initialized 	gnu general 
zero bytes 	license along program 
always termined 	write free 
sds always 	software foundation inc 
even create 	franklin street 
sds mystring 	fifth floor boston 
sdsnewlen 	usa tell 
abc print 	gcc warn 
end however 	nfd tests specification 
binary safe 	msg peek 
contain characters 	wine seems getsockopt 
middle length 	returns pipes 
stored 	wsa network events 
sds header 	instead distinguishes 
empty usually 	two correctly declare 
created order 	data structures 
append use 	ntdll functions compute 
type since 	revents values 
type 	file handle events 
good flags 	cannot happen 
pointer create 	handle eliminate sought 
empty zero 	write end 
length sds 	pipe check writable 
even always 	query information 
term 	file fails optimistically 
create sds 	pipe writable 
starting terminated 	could happen 
duplicate sds 	win query information 
free sds 	file available 
operation performed 	inherit pipe doesn 
sds 	permit file 
length length 	read attributes access 
obtained strlen 	write end 
considering content 	think happen since 
first term 	win wine 
character function 	seems fine otherwise 
useful 	ensure enough 
sds hacked 	space available atomic 
manually way 	writes input 
like following 	buffer screen buffer 
example sdsnew 	convert sets 
foobar sdsupdatelen 	returned revents values 
sdslen 	distinguish hung 
output comment 	sockets errors 
call sdsupdatelen 	min convert returned 
output modified 	sets poll 
logical length 	revents values bug 
remains bytes 	mac causes 
modify 	ignore msg peek 
sds place 	kinds descriptors 
make empty 	detect descriptor connected 
zero length 	socket server 
however existing 	socket something recv 
buffer discarded 	use ioctl 
free 	detect pollhup happened 
space next 	unconnected server 
append operations 	socket fine distinguish 
require allocations 	hung sockets 
number bytes 	errors systems use 
previously available 	recv non 
enlarge 	socket including non 
free space 	stop min 
end sds 	open max 
caller sure 	open max check 
calling function 	needed open 
overwrite addlen 	max efault necessary 
bytes 	implement simplest 
end plus 	convert timeout number 
one nul 	timeval structure 
term note 	wait forever create 
change length 	sets determine 
sds returned 	max see exceptional 
sdslen 	condition detectable 
free buffer 	band data received 
space asap 	socket hence 
enough space 	push pollwrband events 
left use 	onto wfds 
type user 	instead efds examine 
appending 	sets establish 
type able 	results classify socket 
remember empty 	handles create 
space sds 	sets see 
make room 	socket handles mapped 
must called 	onto poll 
every 	poll also screen 
appending operation 	buffer handles 
since header 	waitable block character 
size changes 	available win 
need move 	compute revents eliminates 
forward use 	bits wrong 
realloc 	direction msg wait 
reallocate sds 	multiple objects 
free space 	anyway dispatch messages 
end contained 	need call 
remains altered 	input kind place 
next concatenation 	sentinel end 
operations 	socket lucky wsa 
require reallocation 	network events 
call passed 	already provided way 
sds longer 	distinguish read 
valid references 	accept saves 
must substituted 	recv later socket 
pointer 	poll.h events 
returned call 	revents pfd nfd 
total size 	timeout header 
allocation specifed 	poll emulation contributed 
sds including 	paolo bonzini 
sds header 	copyright free software 
pointer 	foundation inc 
free buffer 	file part gnulib 
end term 	program free 
pointer actual 	software redistribute modify 
sds allocation 	terms gnu 
normally sds 	general license published 
referenced 	free software 
start buffer 	foundation either version 
increment sds 	option later 
length decrements 	version program 
left free 	distributed hope useful 
space end 	without warranty 
according 	without even implied 
incr also 	warranty merchantability 
term end 	fitness particular purpose 
function used 	see gnu 
order fix 	general license details 
length user 	received copy 
calls 	gnu general license 
sds make 	along program 
room writes 	write free software 
something end 	foundation inc 
current needs 	franklin street fifth 
length note 	floor boston 
possible 	usa fake poll 
use negative 	environment readable 
increment order 	data available oob 
right trim 	urgent readable 
usage example 	data file 
sds incr 	descriptor writeable poll 
len 	error occurred 
sds make 	file descriptor hung 
room possible 	requested events 
mount following 	invalid file descriptor 
schema cat 	poll events 
bytes coming 	interested events found 
kernel 	define inftim 
end sds 	conforms posix poll 
without copying 	pread.c buf 
intermediate buffer 	count offset current 
oldlen sdslen 	offset lseek 
sds make 	lseek read full 
room 	lseek precompose 
buffer size 	utf8c repo encoding 
nread read 	path encoding 
oldlen buffer 	maxlen strlen ptr 
size check 	strlen chars 
nread handle 	ret path 
sds 	auml nfc auml 
incr len 	nfd output 
nread avoid 	argc argv oldarg 
compilation warnings 	newarg precompose 
grow sds 	namelen dirname prec 
specified 	dir ret 
length bytes 	errno prec dir 
part original 	res namelenz 
length sds 	maxlen ret errno 
zero specified 	len inleft 
length smaller 	outpos outsz prec 
current 	dir ret 
length operation 	ret errno git 
performed make 	path buf 
sure added 	open close git 
region doesn 	path buf 
contain garbage 	access git config 
also 	git path 
trailing append 	buf unlink 
specified binary 	die errno strbuf 
safe pointed 	release iconv 
len bytes 	open non ascii 
end specified 	reencode iconv 
sds 	iconv close xmalloc 
call passed 	xmalloc opendir 
sds longer 	free free iconv 
valid references 	open readdir 
must substituted 	strlen xrealloc non 
pointer returned 	ascii die 
call 	iconv strlcpy closedir 
append specified 	iconv close 
termianted sds 	free free converts 
call passed 	filenames decomposed 
sds longer 	unicode precomposed unicode 
valid references 	used mac 
must 	found defined config 
substituted pointer 	respect iconv 
returned call 	open fails 
append specified 	die readdir needed 
sds existing 	iconv failed 
sds call 	errno could big 
modified 	eilseq einval 
sds longer 	ebadf mac avoids 
valid references 	illegal sequemces 
must substituted 	occur mounted drive 
pointer returned 	nfs worth 
call destructively 	die rather user 
modify 	see original 
sds hold 	name trigger strlcpy 
specified binary 	precompose utf8h 
safe pointed 	argc argv dirname 
length len 	dirp dirp 
bytes like 	posix see available 
sdscpylen 	systems git 
must termined 	runs see 
length obtained 	http pubs opengroup 
strlen helper 	onlinepubs basedefs 
sdscatlonglong actual 	dirent html name 
number conversion 	max enough 
must 	systems name max 
point room 	strlen name 
least sds 	may solution allocate 
llstr size 	needed see 
bytes function 	precompose utf readdir 
returns length 	precompose unicode 
terminated 	precompose unicode preload-index.c 
representation stored 	index pathspec 
generate representation 	pthread index pathspec 
method produces 	offset data 
reversed compute 	index cep cache 
length term 	index pathspec 
reverse 	threads work offset 
identical sdsll 	data index 
str type 	pathspec retval 
generate representation 	stage isgitlink uptodate 
method produces 	path match 
reversed compute 	threaded symlink leading 
length 	path namelen 
term reverse 	lstat match stat 
create sds 	mark uptodate 
much faster 	cache def clear 
sdscatprintf sdsempty 	div round 
lld like 	memset copy pathspec 
sdscatprintf 	pthread create 
gets list 	die pthread die 
instead variadic 	read index 
start buffer 	preload index copyright 
speed possible 	linus torvalds 
revert heap 	nothing mostly randomly 
allocation 	chosen maximum 
buffers two 	counts cap parallelism 
times bigger 	threads want 
every time 	least lstat 
fail fit 	per worth starting 
current buffer 	pretty.c user 
size 	format name tformat 
concat obtained 	user format 
sds append 	builtin formats len 
sds obtained 	commit formats 
alike format 	len commit formats 
specifier call 	alloc sought 
modified 	commit format empty 
sds longer 	rev tformat 
valid references 	commit format name 
must substituted 	fmt builtin 
pointer returned 	formats sought original 
call example 	num redirections 
sdsnew 	found found match 
sum sdscatprintf 	len match 
often need 	len sought arg 
create scratch 	rev commit 
alike format 	format msg 
need use 	ret len len 
sdsempty 	rfc special 
target sdscatprintf 	needs rfc encoding 
sdsempty format 	rfc ident 
args function 	mode date line 
similar sdscatprintf 	encoding ident 
much faster 	line end mailbuf 
rely 	namebuf namelen 
sprintf family 	maillen max length 
functions implemented 	buf quoted 
libc often 	line len len 
slow moreover 	msg linelen 
directly handling 	commit parent hex 
sds 	msg key 
data concatenated 	len buf encoding 
provides performance 	tmp start 
improvement however 	len commit 
function handles 	commit encoding output 
incompatible subset 	encoding utf 
alike 	use encoding encoding 
format specifiers 	msg email 
sds bit 	email len name 
integer bit 	name len 
integer verbatim 	mail map part 
character next 	msg len 
format 	dmode placeholder len 
specifier process 	name mail 
position next 	maillen namelen len 
write dest 	commit pretty 
str make 	ctx signature check 
sure always 	message commit 
space 	encoding width indent 
least handle 	indent color 
generally unknown 	padding author committer 
term part 	message subject 
left right 	body abbrev 
composed contiguous 	commit hash abbrev 
characters 	hash abbrev 
found cset 	parent hashes wrap 
terminted call 	start chunk 
modified sds 	context msg name 
longer valid 	eol msg 
references must 	trimlen start len 
substituted 	space msg 
pointer returned 	line separator first 
call example 	line linelen 
sdsnew hello 	msg start pos 
world sdstrim 	width indent 
output hello 	indent tmp width 
world 	indent indent 
turn smaller 	part log dmode 
equal containing 	ident placeholder 
substring specified 	rest begin end 
start end 	color placeholder 
indexes start 	column start 
end 	end next width 
negative means 	placeholder context 
last character 	commit msg ret 
penultimate character 	indent next 
forth interval 	start end placeholder 
inclusive start 	local len 
end 	padding start occupied 
characters part 	modifier consumed 
resulting modified 	offset placeholder context 
place example 	consumed orig 
sdsnew hello 	len placeholder context 
world sdsrange 	fmt dummy 
ello 	commit format pretty 
world apply 	ctx context 
tolower every 	output enc utf 
character sds 	outsz encoding 
apply toupper 	commit msg parents 
every character 	shown name 
sds 	line linelen 
compare two 	num msg encoding 
sds memcmp 	need bit 
positive negative 	cte max length 
exactly binary 	title header 
two share 	fmt msg indent 
exactly 	first line 
prefix one 	linelen commit beginning 
two additional 	body indent 
characters longer 	msg reencoded encoding 
considered greater 	need bit 
smaller one 	cte body commit 
split 	easy free 
separator sep 	xstrdup skip prefix 
sds returned 	strcmp strcmp 
count reference 	alloc grow memset 
number tokens 	xstrdup git 
returned memory 	config skip 
zero 	prefix skip prefix 
length zero 	strchr size 
length separator 	alloc grow memcpy 
returned note 	size git 
sep able 	config die starts 
split multi 	strlen find 
character 	commit format recursive 
separator example 	setup commit 
sdssplit foo 	formats find commit 
bar two 	format recursive 
elements foo 	skip prefix save 
bar version 	user format 
function 	skip prefix strchr 
binary safe 	save user 
requires length 	format find commit 
arguments sdssplit 	format die 
function zero 	save user format 
terminated make 	isascii non 
sure 	ascii rfc 
room next 	special strbuf grow 
element one 	strbuf addch 
search separator 	strbuf addch strbuf 
skip separator 	addch strbuf 
element sure 	addch strtoul date 
room 	overflows strtol 
tokens free 	show date strchrnul 
result returned 	split ident 
sdssplitlen nothing 	line map user 
tokens append 	ident cmp 
sds escaped 	strbuf addstr strbuf 
representation 	strbuf addstr 
non printable 	strbuf strbuf addstr 
characters tested 	list append 
isprint turned 	strbuf detach strbuf 
escapes form 	addstr needs 
hex number 	rfc encoding rfc 
call 	needs rfc 
modified sds 	quoting rfc 
longer valid 	quoted strbuf wrapped 
references must 	bytes strbuf 
substituted pointer 	release strbuf wrapped 
returned call 	bytes last 
helper 	line length strlen 
function sdssplitargs 	strlen strbuf 
returns non 	addch strbuf addf 
zero valid 	strbuf addf 
hex digit 	strbuf addf show 
helper function 	ident date 
sdssplitargs 	strbuf addf show 
converts hex 	ident date 
digit integer 	date mode strbuf 
split line 	addf show 
arguments every 	ident date isspace 
argument following 	one line 
programming 	empty line strbuf 
language repl 	addstr find 
alike form 	unique abbrev 
foo bar 	oid hex strbuf 
newline supported 	addf strbuf 
xff otherstuff 	addch find commit 
number 	header xmemdupz 
arguments stored 	starts strchr strchr 
argc sds 	strbuf attach 
returned caller 	strlen strlen encoding 
free resulting 	utf strbuf 
sds sdsfreesplitres 	strbuf splice strlen 
note 	strlen strlen 
sdscatrepr able 	strbuf detach commit 
convert back 	buffer header 
quoted format 	header encoding cached 
sdssplitargs able 	commit buffer 
parse function 	xstrdup reencode unuse 
returns 	commit buffer 
allocated tokens 	replace encoding header 
success even 	free xcalloc 
input empty 	read mailmap 
input contains 	map user split 
unbalanced quotes 	ident line 
closed 	mailmap name strbuf 
quotes followed 	strbuf strbuf 
non space 	strbuf addstr show 
characters foo 	ident date 
bar foo 	strbuf addstr show 
skip blanks 	ident date 
token 	date mode strbuf 
quotes single 	addstr show 
quotes closing 	ident date date 
quote must 	mode strbuf 
followed space 	addstr show ident 
nothing unterminated 	date date 
quotes 	mode strbuf addstr 
closing quote 	show ident 
must followed 	date date 
space nothing 	mode strbuf adddup 
unterminated quotes 	skip prefix 
token vector 	skip prefix istitlechar 
even 	strbuf addch 
empty input 	strbuf addch strbuf 
something modify 	one line 
substituting occurrences 	empty line strbuf 
characters specified 	grow strbuf 
corresponding character 	addstr strbuf skip 
instance 	empty lines 
sdsmapchars mystring 	format subject skip 
effect turning 	empty lines 
hello ell 	strbuf strbuf wrapped 
function returns 	text strbuf 
sds pointer 	swap strbuf release 
always 	strbuf wrap 
input pointer 	reflog ident format 
since resize 	person part 
needed specified 	strlen strchr 
separator also 	skip prefix want 
returns result 	color color 
sds 	parse mem die 
like sdsjoin 	strbuf addstr 
joins sds 	skip prefix strbuf 
wrappers allocators 	addstr skip 
used sds 	prefix strbuf addstr 
note sds 	skip prefix 
actually 	strbuf addstr skip 
use macros 	prefix strbuf 
defined sdsalloc 	addstr strcspn strtoul 
order avoid 	strchr starts 
pay overhead 	starts starts starts 
function calls 	parse color 
define 	strbuf addch strbuf 
wrappers programs 	addch strchr 
sds linked 	strtoul strtoul strtoul 
want touch 	rewrap message 
sds internals 	tail parse 
even use 	padding placeholder parse 
different 	strbuf addstr 
allocator run 	diff color strbuf 
test times 	addstr oid 
order hit 	hex strbuf addstr 
first two 	diff color 
sds header 	strbuf addstr diff 
types 	color strbuf 
sds lib 	addstr diff color 
library copyright 	strbuf addstr 
salvatore sanfilippo 	find unique abbrev 
antirez gmail 	strbuf addstr 
dot copyright 	diff color strbuf 
oran 	addstr oid 
agra copyright 	hex strbuf addstr 
redis labs 	find unique 
inc rights 	abbrev strbuf addch 
reserved redistribution 	strbuf addstr 
use source 	oid hex 
binary 	strbuf addch strbuf 
forms without 	addstr find 
modification permitted 	unique abbrev strbuf 
provided following 	addstr revision 
conditions met 	mark load decorations 
redistributions source 	format decorations 
code 	load decorations format 
must retain 	decorations extended 
copyright notice 	reflog selector reflog 
list conditions 	message format 
following disclaimer 	reflog person strbuf 
redistributions binary 	addstr check 
form 	commit signature strbuf 
must reproduce 	addstr strbuf 
copyright notice 	addch strbuf addstr 
list conditions 	strbuf addstr 
following disclaimer 	parse commit 
documentation materials 	header format person 
provided 	part format 
distribution neither 	person part strbuf 
name redis 	addstr strbuf 
names contributors 	addstr parse commit 
may used 	message format 
endorse promote 	subject format sanitized 
products 	subject strbuf 
derived software 	addstr strrchr utf 
without specific 	strnwidth format 
prior written 	commit one utf 
permission software 	strnwidth display 
provided copyright 	mode esc sequence 
holders 	len strbuf 
contributors express 	insert strbuf setlen 
implied warranties 	strbuf utf 
including limited 	replace strbuf utf 
implied warranties 	replace strbuf 
merchantability fitness 	utf replace 
particular 	strbuf addbuf strbuf 
purpose disclaimed 	addchars memcpy 
shall copyright 	strbuf release format 
owner contributors 	pad commit 
liable direct 	format commit one 
indirect incidental 	strbuf setlen 
special 	strbuf insert strbuf 
exemplary consequential 	insert strbuf 
damages including 	expand strbuf release 
limited procurement 	memset logmsg 
substitute goods 	reencode strbuf expand 
services loss 	rewrap message 
use 	tail encoding encoding 
data profits 	reencode len 
business interruption 	strbuf attach free 
however caused 	unuse commit 
theory liability 	buffer one line 
whether contract 	strbuf starts 
strict 	die commit 
liability tort 	list count strbuf 
including negligence 	grow merge 
otherwise arising 	info skip prefix 
way use 	strbuf grow 
software even 	user info skip 
advised 	prefix strbuf 
possibility damage 	grow user info 
create sds 	strbuf init 
content specified 	format subject strbuf 
init pointer 	grow strbuf 
initlen used 	addstr needs rfc 
init 	encoding rfc 
initialized zero 	strbuf wrapped bytes 
bytes always 	last line 
termined sds 	length strbuf addbuf 
always even 	strbuf addch 
create sds 	non ascii strbuf 
mystring 	addf strbuf 
sdsnewlen abc 	addstr strbuf 
print end 	addch strbuf addstr 
however binary 	free list 
safe contain 	clear strbuf addch 
characters middle 	strbuf release 
length 	one line empty 
stored sds 	line strbuf 
header empty 	grow strbuf addchars 
usually created 	strbuf strbuf 
order append 	addch format commit 
use type 	message log 
since 	output encoding logmsg 
type good 	reencode non 
flags pointer 	ascii header strbuf 
create empty 	addch skip 
zero length 	empty lines title 
sds 	line remainder 
even always 	strbuf rtrim 
term create 	strbuf addch strbuf 
sds starting 	addch unuse 
terminated duplicate 	commit buffer support 
sds free 	pretty printing 
sds 	header high bit 
operation performed 	iso many 
sds length 	bytes already used 
length obtained 	last line 
strlen considering 	guess may also 
content first 	backslash quote 
term 	fall rfc section 
character function 	bit values 
useful sds 	correspond printable ascii 
hacked manually 	characters underscore 
way like 	may represented characters 
following example 	see section 
sdsnew 	restrictions particular space 
foobar sdsupdatelen 	tab must 
sdslen output 	represented within 
comment call 	encoded words rule 
sdsupdatelen output 	non ascii 
modified logical 	characters non printable 
length 	characters non 
remains bytes 	ascii check redundant 
modify sds 	isprint localized 
place make 	knows ascii defensive 
empty zero 	rule special 
length however 	printable characters whitespace 
existing 	character considered 
buffer discarded 	printable defensive use 
free space 	isspace rfc 
next append 	section replacement word 
operations require 	entity within 
allocations number 	phrase example one 
bytes 	precedes address 
previously available 	header abnf definition 
enlarge free 	phrase rfc 
space end 	thus becomes 
sds caller 	phrase encoded word 
sure calling 	word characters 
function 	may used encoded 
overwrite addlen 	encoded word 
bytes end 	restricted upper lower 
plus one 	ascii letters 
nul term 	digits underscore ascii 
note change 	encoded word 
length 	appears within phrase 
sds returned 	must separated 
sdslen free 	adjacent word text 
buffer space 	special linear 
asap enough 	white space special 
space left 	cases per 
use 	rfc rfc section 
type user 	encoded word 
appending type 	must represent integral 
able remember 	number characters 
empty space 	multi octet 
sds make 	character may split 
room 	across adjacent 
must called 	encoded word chrlen 
every appending 	according rfc 
operation since 	could encode special 
header size 	character space 
changes need 	underscore readability many 
move 	programs understand 
forward use 	underscore place thus 
realloc reallocate 	nothing special 
sds free 	causes encoded avoiding 
space end 	problem won 
contained remains 	fit trailing line 
altered 	plus per 
next concatenation 	rfc per rfc 
operations require 	notin guess 
reallocation call 	encoding header happen 
passed sds 	defensive coded 
longer valid 	utf drop 
references 	header replaces xxxx 
must substituted 	encoding xxxx 
pointer returned 	encoding work done 
call total 	encoding header 
size allocation 	nothing message verbatim 
specifed sds 	whether newly 
including 	allocated otherwise still 
sds header 	want munge 
pointer free 	encoding header result 
buffer end 	done modifying 
term pointer 	buffer fresh copy 
actual sds 	reuse cached 
allocation 	copy commit buffer 
normally sds 	need duplicate 
referenced start 	avoid munging cached 
buffer increment 	copy actual 
sds length 	encoding work 
decrements left 	reencoding still leaves 
free 	header replaced 
space end 	next step point 
according incr 	done msg 
also term 	allocated fresh copy 
end function 	free replacement 
used order 	actually consumes buffer 
fix 	hand worry 
length user 	freeing old encoding 
calls sds 	failed might 
make room 	commit message verbatim 
writes something 	currently placeholders 
end current 	length mailmap lookup 
needs 	name email 
length note 	date unix timestamp 
possible use 	date date 
negative increment 	rfc style date 
order right 	relative date 
trim usage 	iso like 
example 	date iso strict 
sds incr 	reading either 
len sds 	bogus commit reflog 
make room 	entry etc 
possible mount 	cannot updated still 
following schema 	need compute 
cat 	valid unknown placeholder 
bytes coming 	offsets relative 
kernel end 	start commit message 
sds without 	following ones 
copying intermediate 	relative result strbuf 
buffer oldlen 	haven seen 
sdslen 	chunk caller surely 
sds make 	going hard 
room buffer 	way remember likely 
size nread 	start added 
read oldlen 	chunk current end 
buffer size 	strbuf nothing 
check 	trim trailing 
nread handle 	characters utf next 
sds incr 	means wide 
len nread 	enough column utf 
avoid compilation 	independent commit 
warnings grow 	consumed bytes otherwise 
sds 	decided treat 
specified length 	unknown previous still 
bytes part 	valid newline 
original length 	nul etc depend 
sds zero 	commit commit 
specified length 	hash abbreviated commit 
smaller 	hash hash 
current length 	abbreviated hash parent 
operation performed 	hashes abbreviated 
make sure 	parent hashes left 
added region 	right bottom 
doesn contain 	reflog info reflog 
garbage 	selector reflog 
also trailing 	message unknown 
append specified 	placeholder rest parse 
binary safe 	commit header 
pointed len 	author committer encoding 
bytes end 	raw body 
specified 	message always left 
sds call 	initial newline 
passed sds 	need parse commit 
longer valid 	message subject 
references must 	sanitized subject body 
substituted pointer 	unknown placeholder 
returned 	utf check trailing 
call append 	ansi sequences 
specified termianted 	got good ansi 
sds call 	sequence put 
passed sds 	back local cutting 
longer valid 	calculate padding 
references 	columns convert 
must substituted 	back chars utf 
pointer returned 	convert commit 
call append 	message utf first 
specified sds 	far format 
existing sds 	commit item assumes 
call 	utf convert 
modified sds 	commit message actual 
longer valid 	output encoding 
references must 	end header enough 
substituted pointer 	slop medium 
returned call 	shows author dates 
destructively 	full shows 
modify sds 	authors dates fuller 
hold specified 	shows authors 
binary safe 	dates per rfc 
pointed length 	need check 
len bytes 	emit content type 
like 	mark bit 
sdscpylen must 	haven done 
termined length 	author could non 
obtained strlen 	bit ascii 
helper sdscatlonglong 	log may skip 
actual number 	header part 
conversion 	first skip excess 
must point 	blank lines 
room least 	beginning body formats 
sds llstr 	treat title 
size bytes 	line specially make 
function returns 	sure eoln 
length 	non oneline caller 
terminated representation 	may append 
stored generate 	additional body text 
representation method 	mail format 
produces reversed 	make sure strip 
compute length 	blank line 
term 	header body prio-queue.c 
reverse identical 	queue cmp 
sdsll str 	queue tmp 
type generate 	queue queue queue 
representation method 	thing parent 
produces reversed 	queue result child 
compute 	compare die 
length term 	swap free alloc 
reverse create 	grow compare 
sds much 	swap compare compare 
faster sdscatprintf 	swap append 
sdsempty lld 	end lifo bubble 
like 	one lifo 
sdscatprintf gets 	push one root 
list instead 	left use 
variadic start 	right child prio-queue.h 
buffer speed 	ctr data 
possible revert 	compare insertion ctr 
heap 	data alloc 
allocation buffers 	prio queue thing 
two times 	prio queue 
bigger every 	prio queue 
time fail 	prio queue priority 
fit current 	queue implementation 
buffer 	primarily keeping track 
size concat 	commits date 
obtained sds 	order process old 
append sds 	discovered used 
obtained alike 	hold pointer caller 
format specifier 	responsible supplying 
call 	function compare two 
modified sds 	things alternatively 
longer valid 	data structure also 
references must 	used lifo 
substituted pointer 	stack specifying comparison 
returned call 	function compare 
example 	two things one 
sdsnew sum 	two third 
sdscatprintf often 	parameter data 
need create 	prio queue structure 
scratch alike 	result returned 
format need 	sign sign result 
use 	subtracting two 
sdsempty target 	one negative one 
sdscatprintf sdsempty 	sorts earlier 
format args 	two thing queue 
function similar 	extract thing 
sdscatprintf much 	compares smallest queue 
faster 	compare function 
rely sprintf 	queue acts lifo 
family functions 	stack reverse 
implemented libc 	lifo elements prio 
often slow 	queue progress.c 
moreover directly 	curr total prev 
handling 	total prev 
sds data 	avg bytes avg 
concatenated provides 	misecs last 
performance improvement 	bytes last 
however function 	misecs idx display 
handles incompatible 	title last 
subset 	total last percent 
alike format 	delay delayed 
specifiers sds 	percent treshold throughput 
bit integer 	progress update 
bit integer 	signum tpgrp progress 
verbatim character 	done eol 
next 	percent percent buf 
format specifier 	total rate 
process position 	progress total misecs 
next write 	count rate 
dest str 	progress title total 
make sure 	percent treshold 
always 	delay progress title 
space least 	total progress 
handle generally 	progress msg progress 
unknown term 	buf bufp 
part left 	len rate 
right composed 	memset sigemptyset sigaction 
contiguous 	setitimer setitimer 
characters found 	signal tcgetpgrp getpgid 
cset terminted 	clear progress 
call modified 	signal foreground fileno 
sds longer 	fflush foreground 
valid references 	fileno fflush strbuf 
must 	reset strbuf 
substituted pointer 	addstr strbuf humanise 
returned call 	bytes strbuf 
example sdsnew 	addstr strbuf humanise 
hello world 	bytes strbuf 
sdstrim output 	addstr getnanotime calloc 
hello 	strbuf init 
world turn 	throughput display display 
smaller equal 	malloc fflush 
containing substring 	progress signal start 
specified start 	progress delay 
end indexes 	stop progress 
start 	msg strlen xmallocz 
end negative 	throughput xsnprintf 
means last 	display free clear 
character penultimate 	progress signal 
character forth 	strbuf release free 
interval inclusive 	free simple 
start 	text progress display 
end characters 	module git 
part resulting 	copyright nicolas pitre 
modified place 	nico fluxnic 
example sdsnew 	net code free 
hello world 	software redistribute 
sdsrange 	modify terms gnu 
ello world 	general license 
apply tolower 	version published free 
every character 	software foundation 
sds apply 	inhibit progress report 
toupper every 	entirely update 
character 	throughput every 
sds compare 	bytes nanosecs want 
two sds 	simplify things 
memcmp positive 	keep track misecs 
negative exactly 	sec obtained 
binary two 	unlikely good fallback 
share 	force last 
exactly prefix 	update progress.h progress 
one two 	total progress 
additional characters 	title total title 
longer considered 	total percent 
greater smaller 	treshold delay progress 
one 	progress msg 
split separator 	prompt.c cmd prompt 
sep sds 	pass args 
returned count 	buffer err prompt 
reference number 	flags askpass 
tokens returned 	err start 
memory 	command strbuf reset 
zero length 	strbuf read 
zero length 	close finish command 
separator returned 	error strbuf 
note sep 	release strbuf setlen 
able split 	strcspn getenv 
multi 	getenv askpass git 
character separator 	env git 
example sdssplit 	terminal prompt strerror 
foo bar 	die prompts 
two elements 	already contain end 
foo bar 	prompt.h prompt 
version 	flags prompt prune-packed.c 
function binary 	prune packed 
safe requires 	usage progress path 
length arguments 	data opts 
sdssplit function 	sha path data 
zero terminated 	opts opts 
make 	argc argv 
sure room 	prefix opts prune 
next element 	packed options 
one search 	display progress rmdir 
separator skip 	sha pack 
separator element 	unlink warn start 
sure 	progress delay 
room tokens 	loose file objdir 
free result 	directory display 
returned sdssplitlen 	progress stop progress 
nothing tokens 	isatty parse 
append sds 	options prune packed 
escaped 	objects ensure 
representation non 	show finishing progress 
printable characters 	prune.c prune 
tested isprint 	usage show verbose 
turned escapes 	expire show 
form hex 	progress fullpath sha 
number 	fullpath data 
call modified 	basename path 
sds longer 	data path data 
valid references 	path dir 
must substituted 	argc argv prefix 
pointer returned 	revs progress 
call 	options sha name 
helper function 	lstat error 
sdssplitargs returns 	unlink warn lookup 
non zero 	lstat error 
valid hex 	sha hex unlink 
digit helper 	warn starts 
function 	prune tmp file 
sdssplitargs converts 	rmdir opendir 
hex digit 	readdir starts prune 
integer split 	tmp file 
line arguments 	mkpath closedir init 
every argument 	revisions parse 
following 	options die sha 
programming language 	parse die 
repl alike 	pending die 
form foo 	isatty start progress 
bar newline 	delay mark 
supported xff 	reachable objects stop 
otherstuff 	progress loose 
number arguments 	file objdir directory 
stored argc 	prune packed 
sds returned 	objects temporary files 
caller free 	directory mkpathdup 
resulting sds 	directory temporary files 
sdsfreesplitres 	free repository 
note sdscatrepr 	shallow prune shallow 
able convert 	know must 
back quoted 	reachable report errors 
format sdssplitargs 	stop pruning 
able parse 	write errors particularly 
function 	space result 
returns allocated 	failed temporary 
tokens success 	packs rarely indexes 
even input 	files beginning 
empty input 	tmp accumulating pack 
contains unbalanced 	directories pthread.c 
quotes 	arg unused start 
closed quotes 	routine arg 
followed non 	ptr result cond 
space characters 	unused cond 
foo bar 	cond mutex last 
foo skip 	waiter cond 
blanks 	waiters cond current 
token quotes 	start routine 
single quotes 	beginthreadex wait single 
closing quote 	err win 
must followed 	posix last error 
space nothing 	current initialize 
unterminated 	critical section create 
quotes closing 	semaphore die 
quote must 	create die 
followed space 	close handle close 
nothing unterminated 	handle critical 
quotes 	section enter critical 
token vector 	section critical 
even empty 	section critical section 
input something 	wait single 
modify substituting 	enter critical section 
occurrences characters 	critical section 
specified 	enter critical section 
corresponding character 	enter critical 
instance sdsmapchars 	section critical section 
mystring effect 	release semaphore 
turning hello 	err win posix 
ell function 	last error 
returns 	enter critical section 
sds pointer 	release semaphore 
always input 	critical section wait 
pointer since 	single critical 
resize needed 	section copyright 
specified separator 	andrzej haczewski ahaczewski 
also 	gmail disclaimer 
returns result 	implementation git specific 
sds like 	subset original 
sdsjoin joins 	pthreads api without 
sds wrappers 	lots features 
allocators used 	git doesn use 
sds 	git also 
note sds 	makes sure passed 
actually use 	arguments valid 
macros defined 	need checking security 
sdsalloc order 	reset signaled 
avoid pay 	name unlock external 
overhead 	mutex wait 
function calls 	signal note held 
define wrappers 	mutex locked 
programs sds 	enough increment waiters 
linked want 	count problem 
touch sds 	leaving mutex 
internals 	unlocked wait semaphore 
even use 	wait ignore 
different allocator 	decrease waiters count 
run test 	last waiter 
times order 	must notify broadcasting 
hit first 	continued due 
two 	cond signal signaling 
sds header 	knows one 
types sds.c 	waiter continued cond 
type size 	broadcast issued 
init initlen 	mutex held means 
type hdrlen 	waiters continued 
init 	contending mutex end 
initlen reallen 	function broadcasting 
addlen newsh 	cond broadcast yet 
avail len 	sure waiter 
newlen type 	consumed exactly 
oldtype hdrlen 	one slice semaphor 
newsh 	last waiter 
type oldtype 	must tell broadcasting 
hdrlen len 	contend waiters 
alloc incr 	mutex auf den 
flags len 	kampf external 
oldlen len 	mutex important implementation 
curlen 	requires pthread 
len curlen 	cond signal called 
len aux 	mutex held 
aux buf 	used corresponding pthread 
len fmt 	cond wait 
cpy staticbuf 	calls signal waiters 
buflen 	doubly important 
fmt fmt 	implementation requires pthread 
initlen next 	cond broadcast 
str num 	called mutex held 
unum buf 	used corresponding 
buf cset 	pthread cond 
start 	wait calls wake 
end len 	waiters point 
start end 	waiters one takes 
newlen len 	slice semaphor 
minlen cmp 	turn wait since 
len sep 	external mutex 
seplen 	held cond wait 
count tokens 	yet reason 
newtokens tokens 	sure gets chance 
count len 	eat one 
line argc 	slice otoh means 
current vector 	last waiter 
inq 	must send wake 
insq done 	since external 
setlen argv 	mutex held enter 
argc sep 	cond wait 
argv argc 	hence safe reset 
sep seplen 	flag without 
size 	cond waiters 
ptr size 	held pthread.h cond 
ptr oldfree 	unused cond 
oldlen type 	cond mutex cond 
sds req 	cond unused 
type sds 	start routine arg 
hdr 	ptr ret 
size malloc 	keyp destructor key 
memset sds 	key key 
hdr sds 	exit tls alloc 
hdr sds 	tls free 
hdr sds 	tls tls header 
hdr 	used adapt 
memcpy sdsnewlen 	pthread posix code 
strlen sdsnewlen 	windows api 
sdsnewlen sdslen 	threads copyright andrzej 
free sds 	haczewski ahaczewski 
hdr size 	gmail defines adapt 
strlen 	windows api 
sdssetlen sdssetlen 	threads pthreads 
sdsavail sdslen 	api implement simple 
sds hdr 	condition variable 
size sds 	windows threads ace 
req type 	implementation see 
sds 	original implementation http 
hdr size 	bit djo 
realloc malloc 	ace homepage http 
memcpy free 	www cse 
sdssetlen sdssetalloc 	wustl edu schmidt 
sdslen sds 	ace html 
hdr 	see also http 
size sds 	www cse 
req type 	wustl edu schmidt 
sds hdr 	win html 
size realloc 	simple creation implementation 
malloc memcpy 	pthread api 
free 	avoid need copying 
sdssetlen sdssetalloc 	use small 
sdsalloc sds 	macro wrapper 
hdr size 	pass pointer win 
sds hdr 	pthread instead 
size sds 	pthread pull.c opt 
type 	arg unset 
len sds 	pull usage opt 
hdr sds 	verbosity opt 
hdr sds 	progress opt diffstat 
hdr sds 	opt log 
hdr sdslen 	opt squash opt 
sds 	commit opt 
make room 	edit opt opt 
memset sdssetlen 	verify signatures 
sdslen sds 	opt strategies opt 
make room 	strategy opts 
memcpy sdssetlen 	opt gpg sign 
sdscatlen 	opt opt 
strlen sdscatlen 	append opt 
sdslen sdsalloc 	upload pack opt 
sds make 	force opt 
room sdslen 	tags opt prune 
memcpy sdssetlen 	opt recurse 
sdscpylen 	submodules max children 
strlen sdsll 	opt dry 
str sdsnewlen 	run opt keep 
strlen malloc 	opt depth 
copy vsnprintf 	opt unshallow opt 
end free 	update shallow 
malloc 	opt refmap pull 
sdscat free 	options arr 
start sdscatvprintf 	verbosity arr force 
end sdslen 	argc argv 
start sdsavail 	msg prefix rev 
sds make 	info result 
room 	prefix rev info 
arg strlen 	result prefix 
sdslen sdsavail 	file die 
sds make 	merge heads filename 
room memcpy 	sha remote 
sdsinclen arg 	data remote name 
sdsll 	repo refspecs 
str sdsavail 	curr branch remote 
sds make 	remote name 
room memcpy 	argc argv repo 
sdsinclen sdsull 	refspecs repo 
str sdsavail 	refspecs args ret 
sds 	merge head 
make room 	curr head ret 
memcpy sdsinclen 	args remote 
sdsinclen sdsinclen 	curr branch curr 
end sdslen 	branch remote 
strchr strchr 	remote refspec spec 
memmove 	spec src 
sdssetlen sdslen 	merge branch fork 
memmove sdssetlen 	point repo 
sdslen tolower 	refspec ret 
sdslen toupper 	curr branch remote 
sdslen sdslen 	branch merge 
memcmp 	curr head merge 
malloc realloc 	head fork 
memcmp sdsnewlen 	point result curr 
sdsnewlen sdsfree 	head merge 
free sdsfree 	head fork point 
free sdscatlen 	ret oct 
sdscatprintf 	merge args argc 
sdscatlen sdscatlen 	argv prefix 
sdscatlen sdscatlen 	repo refspecs merge 
sdscatlen isprint 	heads orig 
sdscatprintf sdscatprintf 	head curr head 
sdscatlen isspace 	rebase fork 
sdsempty 	point autostash die 
hex digit 	error parse 
hex digit 	config rebase argv 
hex digit 	push argv 
hex digit 	push argv 
sdscatlen sdscatlen 	push strbuf addch 
isspace 	strbuf addstr 
sdscatlen sdscatlen 	setenv strbuf release 
isspace sdscatlen 	git config 
sdscatlen realloc 	git config maybe 
malloc sdsfree 	strcmp die 
free sdsfree 	git config parse 
sdslen 	config rebase 
sdsempty sdscat 	init revisions diff 
sdscat sdsempty 	opt diff 
sdscatsds sdscatlen 	opt diff setup 
malloc realloc 	done run 
free sdsnew 	diff files diff 
sdsfree 	result code 
sdsnewlen sdscat 	cache unborn init 
test cond 	revisions diff 
sdslen memcmp 	opt diff 
sdscpy sdscpy 	opt head pending 
sdsfree sdscatprintf 	diff setup 
sdsempty 	done run diff 
sdsfree sdsnew 	index diff 
sdscatfmt sdsfree 	result code xcalloc 
sdsnew sdscatfmt 	hold locked 
sdsfree sdsnew 	index refresh cache 
sdstrim sdsfree 	update index 
sdsnew 	able rollback file 
sdstrim sdsfree 	unstaged changes 
sdsnew sdstrim 	error uncommitted changes 
sdsdup sdsrange 	error error 
sdsfree sdsdup 	exit git path 
sdsrange sdsfree 	fopen die 
sdsdup 	errno strbuf getline 
sdsrange sdsfree 	sha hex 
sdsdup sdsrange 	starts sha append 
sdsfree sdsdup 	fclose strbuf 
sdsrange sdsfree 	release branch 
sdsdup sdsrange 	strcmp remote exit 
sdsfree 	argv pushl 
sdsfree sdsnew 	argv push verbosity 
sdsnew sdsfree 	argv push 
sdsfree sdsnew 	argv push argv 
sdsnew sdsfree 	push argv 
sdsfree sdsnew 	push argv push 
sdsnew 	force argv 
sdsfree sdsfree 	push argv push 
sdsnewlen sdscatrepr 	argv push 
sdsempty sdslen 	argv push argv 
sdsfree sdsfree 	push argv 
sdsnew test 	push argv push 
cond 	argv push 
sdslen sdsavail 	argv push argv 
sdslen sds 	push argv 
make room 	push argv pushv 
test cond 	die run 
sdslen test 	command opt 
cond 	argv clear checkout 
sdsavail sdsavail 	fast forward 
sds incr 	update argv pushl 
len test 	argv push 
cond memcmp 	verbosity argv push 
test cond 	argv push 
sdslen 	argv push argv 
sdsfree sds 	push argv 
test sds 	push argv push 
lib library 	argv push 
copyright salvatore 	argv push argv 
sanfilippo antirez 	pushv argv 
gmail 	pushv argv push 
dot copyright 	argv push 
oran agra 	run command opt 
copyright redis 	argv clear 
labs inc 	remote branch remote 
rights reserved 	branch strcmp 
redistribution 	branch upstream 
use source 	parse fetch refspec 
binary forms 	strcmp skip 
without modification 	prefix skip prefix 
permitted provided 	starts starts 
following conditions 	starts strcmp mkpath 
met 	mkpath free 
redistributions source 	refspec branch tracking 
code must 	branch upstream 
retain copyright 	branch argv pushl 
notice list 	capture command 
conditions following 	sha hex strbuf 
disclaimer 	release commit 
redistributions binary 	list insert lookup 
form must 	commit reference 
reproduce copyright 	commit list insert 
notice list 	lookup commit 
conditions following 	reference sha 
disclaimer 	commit list insert 
documentation materials 	lookup commit 
provided distribution 	reference reduce heads 
neither name 	octopus merge 
redis names 	bases free commit 
contributors may 	list hashcpy 
used 	octopus merge sha 
endorse promote 	hashcmp argv 
products derived 	push argv push 
software without 	verbosity argv 
specific prior 	push argv push 
written permission 	argv push 
software 	argv pushv argv 
provided copyright 	pushv argv 
holders contributors 	push argv push 
express implied 	argv push 
warranties including 	sha hex sha 
limited implied 	argv push 
warranties 	sha hex 
merchantability fitness 	argv push sha 
particular purpose 	hex run 
disclaimed shall 	command opt argv 
copyright owner 	clear getenv 
contributors liable 	reflog message parse 
direct 	options parse 
indirect incidental 	repo refspecs xstrdup 
special exemplary 	config config 
consequential damages 	rebase git config 
including limited 	read cache 
procurement substitute 	unmerged die resolve 
goods 	conflict file 
services loss 	exists git path 
use data 	die conclude 
profits business 	merge sha hashclr 
interruption however 	sha cache 
caused theory 	unborn die git 
liability 	config die 
whether contract 	unclean work 
strict liability 	rebase fork point 
tort including 	hashclr run 
negligence otherwise 	fetch sha hashclr 
arising way 	sha sha 
use 	hashcmp warning sha 
software even 	hex checkout 
advised possibility 	fast forward die 
damage create 	sha hex 
sds content 	merge heads die 
specified init 	merge candidates 
pointer 	sha die pull 
initlen used 	die run 
init initialized 	rebase run merge 
zero bytes 	builtin git 
always termined 	pull git pull 
sds always 	junio hamano 
even 	fetch one remote 
create sds 	refs merge 
mystring sdsnewlen 	current head 
abc print 	parses rebase returns 
end however 	rebase returns 
binary safe 	rebase preserve returns 
contain 	rebase preserve 
characters middle 	invalid dies fatal 
length stored 	error fatal 
sds header 	otherwise returns rebase 
empty usually 	invalid callback 
created order 	rebase parses arg 
append 	parse config 
use type 	rebase shared options 
since type 	options passed 
good flags 	git merge git 
pointer create 	rebase options 
empty zero 	passed git fetch 
length 	shared options 
sds even 	options passed git 
always term 	merge git 
create sds 	rebase options 
starting terminated 	passed git fetch 
duplicate sds 	pushes switches 
free 	arr match opt 
sds operation 	verbosity level 
performed sds 	pushes switches arr 
length length 	match opt 
obtained strlen 	force level sets 
considering content 	git reflog 
first 	action environment variable 
term character 	concatenation argv 
function useful 	pull unset returns 
sds hacked 	pull returns 
manually way 	pull returns pull 
like following 	returns otherwise 
example 	pull invalid die 
sdsnew foobar 	error returns 
sdsupdatelen sdslen 	configured rebase 
output comment 	first looks branch 
call sdsupdatelen 	curr branch 
output modified 	rebase curr branch 
logical 	current branch 
length remains 	head detached configuration 
bytes modify 	key exist 
sds place 	looks pull rebase 
make empty 	configuration keys 
zero length 	exist returns rebase 
however 	returns unstaged 
existing buffer 	changes otherwise returns 
discarded free 	uncommitted changes 
space next 	otherwise work unstaged 
append operations 	uncommitted changes 
require allocations 	dies appropriate message 
number 	appends merge 
bytes previously 	candidates fetch head 
available enlarge 	marked merge 
free space 	merge heads 
end sds 	invalid line start 
caller sure 	sha merge 
calling 	used die merge 
function overwrite 	candidates remote 
addlen bytes 	callback retrieve name 
end plus 	remote repository 
one nul 	one remote dies 
term note 	appropriate reason 
change 	merge candidates fetched 
length sds 	specific remote 
returned sdslen 	refspec given ended 
free buffer 	fetching anything 
space asap 	usually user provided 
enough space 	wildcard refspec 
left 	matches remote end 
use type 	fetched non 
user appending 	remote didn specify 
type able 	branch merge 
remember empty 	use configured 
space sds 	one applies remote 
make 	thus user 
room must 	must specify branches 
called every 	merge fetched 
appending operation 	branch repo remote 
since header 	branch never 
size changes 	configured branch merge 
need 	branch configured 
move forward 	branch merge fetched 
use realloc 	branch repo 
reallocate sds 	remote configured branch 
free space 	merge didn 
end 	fetched either doesn 
contained remains 	exist wasn 
altered next 	part configured fetch 
concatenation operations 	refspec parses 
require reallocation 	argv repo refspecs 
call passed 	returning values 
sds 	repo refspecs 
longer valid 	terminated repo provided 
references must 	argv runs 
substituted pointer 	git fetch returning 
returned call 	exit status 
total size 	repo refspecs repository 
allocation 	refspecs fetch 
specifed sds 	provided shared options 
including sds 	options passed 
header pointer 	git fetch pulls 
free buffer 	branching merge 
end term 	head two way 
pointer 	merge treat 
actual sds 	index empty fast 
allocation normally 	forward head 
sds referenced 	ensures lose index 
start buffer 	worktree changes 
increment sds 	user already 
length 	made unborn branch 
decrements left 	runs git 
free space 	merge returning exit 
end according 	status shared 
incr also 	options options passed 
term end 	git merge 
function 	returns remote upstream 
used order 	branch current 
fix length 	branch remote current 
user calls 	branch configured 
sds make 	remote used returns 
room writes 	remote name 
something 	valid remote head 
end current 	point branch 
needs length 	remote branch configured 
note possible 	remote branch 
use negative 	configured upstream branch 
increment order 	derives remote 
right 	tracking branch 
trim usage 	remote refspec fixme 
example sds 	current implementation 
incr len 	assumes mapping refs 
sds make 	heads branch 
room possible 	name refs remotes 
mount 	remote name 
following schema 	branch name given 
cat bytes 	repo refspecs 
coming kernel 	sets fork point 
end sds 	point current 
without copying 	branch forked remote 
intermediate 	tracking branch 
buffer oldlen 	returns success failure 
sdslen sds 	sets merge 
make room 	octopus merge curr 
buffer size 	head merge 
nread read 	head fork point 
oldlen 	returns merge 
buffer size 	found otherwise 
check nread 	given current head 
handle sds 	sha merge 
incr len 	head returned git 
nread avoid 	fetch fork 
compilation 	point calculated rebase 
warnings grow 	fork point 
sds specified 	runs git rebase 
length bytes 	appropriate arguments 
part original 	returns exit status 
length sds 	shared options 
zero 	options passed git 
specified length 	rebase fetch 
smaller current 	involved updating current 
length operation 	branch working 
performed make 	index file still 
sure added 	orig head 
region 	commit merging curr 
doesn contain 	head update 
garbage also 	working match 
trailing append 	curr head push.c 
specified binary 	push usage 
safe pointed 	thin deleterefs receivepack 
len 	verbosity progress 
bytes end 	recurse submodules cas 
specified sds 	refspec refspec 
call passed 	refspec alloc remote 
sds longer 	local refs 
valid references 	matched query buf 
must 	branch buf 
substituted pointer 	refs repo remote 
returned call 	local refs 
append specified 	tagref delref remote 
termianted sds 	url branch 
call passed 	remote advice maybe 
sds 	upstream message 
longer valid 	detached head 
references must 	die remote branch 
substituted pointer 	triangular simple 
returned call 	refspec remote branch 
append specified 	remote fetch 
sds 	remote remote branch 
existing sds 	triangular message 
call modified 	advice pull push 
sds longer 	message advice 
valid references 	checkout pull push 
must substituted 	message advice 
pointer 	fetch first message 
returned call 	advice already 
destructively modify 	exists message advice 
sds hold 	needs force 
specified binary 	transport flags err 
safe pointed 	reject reasons 
length 	repo flags errs 
len bytes 	remote url 
like sdscpylen 	url transport 
must termined 	transport opt arg 
length obtained 	unset recurse 
strlen helper 	submodules flags flags 
sdscatlonglong 	status argc 
actual number 	argv prefix flags 
conversion must 	tags push 
point room 	cert repo options 
least sds 	alloc grow 
llstr size 	count refspec match 
bytes 	memset query 
function returns 	refspecs strbuf addf 
length terminated 	strbuf detach 
representation stored 	starts branch strbuf 
generate representation 	addf strbuf 
method produces 	detach strcmp die 
reversed 	strbuf addf 
compute length 	strbuf addf strbuf 
term reverse 	detach strchr 
identical sdsll 	die strbuf 
str type 	addf strbuf detach 
generate representation 	strchr remote 
method 	local heads map 
produces reversed 	refspec refspec 
compute length 	skip prefix die 
term reverse 	die die 
create sds 	die die strcmp 
much faster 	die push 
sdscatprintf 	simple strbuf addf 
sdsempty lld 	refspec die 
like sdscatprintf 	refspec remote branch 
gets list 	workflow triangular 
instead variadic 	refspec setup push 
start buffer 	current setup 
speed 	push upstream setup 
possible revert 	push upstream 
heap allocation 	setup push current 
buffers two 	die advise 
times bigger 	advise advise 
every time 	advise advise transport 
fail 	verbosity transport 
fit current 	option transport option 
buffer size 	empty cas 
concat obtained 	die transport push 
sds append 	error transport 
sds obtained 	disconnect advise pull 
alike 	push advise 
format specifier 	checkout pull push 
call modified 	advise already 
sds longer 	exists advise fetch 
valid references 	first advise 
must substituted 	needs force pushremote 
pointer 	die die 
returned call 	strcmp error error 
example sdsnew 	strcmp error 
sum sdscatprintf 	error error setup 
often need 	push refspecs 
create scratch 	push url 
alike 	remote transport push 
format need 	options transport 
use sdsempty 	push options parse 
target sdscatprintf 	push recurse 
sdsempty format 	submodules arg die 
args function 	git gpg 
similar 	config strcmp git 
sdscatprintf much 	config strcmp 
faster rely 	git config git 
sprintf family 	config maybe 
functions implemented 	push cert flags 
libc often 	push cert 
slow 	flags strcasecmp push 
moreover directly 	cert flags 
handling sds 	error strcmp git 
data concatenated 	config parse 
provides performance 	push recurse 
improvement however 	submodules arg git 
function 	config packet 
handles incompatible 	trace identity git 
subset alike 	config parse 
format specifiers 	options push cert 
sds bit 	flags die 
integer bit 	die refspec refspecs 
integer 	push usage 
verbatim character 	options git push 
next format 	uniquely name 
specifier process 	lazily grab remote 
position next 	local refs 
write dest 	point shorten unambiguous 
str 	ambiguity would 
make sure 	remote side locally 
always space 	plus supposed 
least handle 	simple mode user 
generally unknown 	something crazy 
term part 	like setting 
left 	upstream non branch 
right composed 	probably showing 
contiguous characters 	big ugly fully 
found cset 	qualified show 
terminted call 	advice people explicitly 
modified sds 	push additional 
longer 	safety repository qsort.c 
valid references 	cmp tmp 
must substituted 	cmp size buf 
pointer returned 	tmp msort 
call example 	tmp msort tmp 
sdsnew hello 	cmp memcpy 
world 	memcpy memcpy memcpy 
sdstrim output 	mult msort 
hello world 	tmp xmalloc msort 
turn smaller 	tmp free 
equal containing 	merge sort implementation 
substring specified 	simplified qsort 
start 	implementation mike 
end indexes 	haertel part gnu 
start end 	library temporary 
negative means 	fits small stack 
last character 	buffer somewhat 
penultimate character 	large malloc quote.c 
forth 	quote path 
interval inclusive 	fully dst src 
start end 	free len 
characters part 	dst argv maxlen 
resulting modified 	arg next 
place example 	dst src arg 
sdsnew 	arg argv 
hello world 	alloc next dequoted 
sdsrange ello 	arg argv 
world apply 	alloc arg lookup 
tolower every 	maxlen len 
character sds 	name maxlen len 
apply 	count name 
toupper every 	nodq prefix 
character sds 	path nodq name 
compare two 	terminator name 
sds memcmp 	prefix terminator prefix 
positive negative 	rel quoted 
exactly 	endp len src 
binary two 	src src 
share exactly 	strbuf detach strbuf 
prefix one 	addch strcspn 
two additional 	strbuf need quote 
characters longer 	strbuf addstr 
considered 	strbuf addch strbuf 
greater smaller 	addch strbuf 
one split 	addch free strbuf 
separator sep 	grow strbuf 
sds returned 	addch quote buf 
count reference 	die need 
number 	quote isspace 
tokens returned 	isspace dequote step 
memory zero 	dequote step 
length zero 	alloc grow argv 
length separator 	push dequote 
returned note 	argv dequote argv 
sep 	must quote 
able split 	must quote next 
multi character 	quote pos 
separator example 	emit emitbuf emit 
sdssplit foo 	emit emit 
bar two 	emit emit emitbuf 
elements 	emit quote 
foo bar 	style counted quote 
version function 	style quote 
binary safe 	style strbuf addch 
requires length 	quote style 
arguments sdssplit 	quote style strbuf 
function 	addch strbuf 
zero terminated 	addstr strbuf 
make sure 	addstr quote style 
room next 	fputs fputc 
element one 	relative path write 
search separator 	name quoted 
skip 	strbuf release relative 
separator element 	path strbuf 
sure room 	reset quote style 
tokens free 	counted strlen 
result returned 	strbuf release strcspn 
sdssplitlen nothing 	strbuf strbuf 
tokens 	addch strbuf setlen 
append sds 	strbuf addch 
escaped representation 	strbuf addch strbuf 
non printable 	addch strbuf 
characters tested 	addch strbuf addch 
isprint turned 	strbuf addch 
escapes 	strbuf addch strbuf 
form hex 	addch strbuf 
number call 	addch strbuf 
modified sds 	addch strbuf addch 
longer valid 	strbuf addch 
references must 	strbuf addch strbuf 
substituted 	addstr strbuf 
pointer returned 	addstr strbuf addstr 
call helper 	strbuf addstr 
function sdssplitargs 	strbuf addstr strbuf 
returns non 	addch help 
zero valid 	copy thing properly 
hex 	quoted shell 
digit helper 	safety single quote 
function sdssplitargs 	replaced exclamation 
converts hex 	point replaced whole 
digit integer 	thing enclosed 
split line 	single quote pair 
arguments 	original quote 
every argument 	result name name 
following programming 	name copy 
language repl 	destination buffer 
alike form 	stepped fallthrough means 
foo bar 	quote octal 
newline 	means quote octal 
supported xff 	quote path 
otherstuff number 	fully means never 
arguments stored 	quote quote 
argc sds 	returns longest prefix 
returned caller 	needing quote 
free 	maxlen positive stops 
resulting sds 	first marked 
sdsfreesplitres note 	character needing escape 
sdscatrepr able 	style name 
convert back 	quoting inspect input 
quoted format 	name counts 
sdssplitargs 	number bytes needed 
able parse 	hold style 
function returns 	quoted version 
allocated tokens 	name counting quotes 
success even 	around terminating 
input empty 	nul returns however 
input 	name need 
contains unbalanced 	style quoting returns 
quotes closed 	emits style 
quotes followed 	quoted version name 
non space 	enclosed quotes 
characters foo 	asked needed ending 
bar 	quote needed 
foo skip 	quote path relative 
blanks token 	given prefix 
quotes single 	style name unquoting 
quotes closing 	quoted point 
quote must 	opening quote returns 
followed 	able unquote 
space nothing 	properly appends result 
unterminated quotes 	strbuf returns 
closing quote 	error doesn 
must followed 	touch strbuf though 
space nothing 	note function 
unterminated 	allocate memory strbuf 
quotes token 	calling strbuf 
vector even 	release mandatory whichever 
empty input 	result unquote 
something modify 	style returns updates 
substituting occurrences 	endp pointer 
characters 	point one past 
specified corresponding 	ending quote 
character instance 	given verbatim octal 
sdsmapchars mystring 	values first 
effect turning 	digit overflow quoting 
hello ell 	languages quote.h 
function 	strbuf src strbuf 
returns sds 	argv maxlen 
pointer always 	arg argv alloc 
input pointer 	arg argv 
since resize 	strbuf quoted 
needed specified 	endp name strbuf 
separator 	strbuf name 
also returns 	terminator name prefix 
result sds 	terminator prefix 
like sdsjoin 	src src src 
joins sds 	help copy 
wrappers allocators 	thing properly quoted 
used 	shell safety 
sds note 	single quote replaced 
sds actually 	exclamation point 
use macros 	replaced whole thing 
defined sdsalloc 	enclosed single 
order avoid 	quote pair example 
pay 	passing result 
overhead function 	system argument sprintf 
calls define 	cmd foobar 
wrappers programs 	quote arg quote 
sds linked 	arg would 
want touch 	appropriate system 
sds 	going call ssh 
internals even 	run command 
use different 	side sprintf cmd 
allocator run 	git diff 
test times 	quote arg quote 
order hit 	arg sprintf 
first 	rcmd ssh quote 
two sds 	host quote 
header types 	cmd note examples 
sds lib 	leak memory 
library copyright 	remember free result 
salvatore sanfilippo 	quote real 
antirez 	application quote buf 
gmail dot 	writes existing 
copyright oran 	buffer specified size 
agra copyright 	number characters 
redis labs 	would written excluding 
inc rights 	regardless buffer 
reserved 	size unwraps 
redistribution use 	quote produces place 
source binary 	returns input 
forms without 	look like quote 
modification permitted 	would produced 
provided following 	used unwrap many 
conditions 	arguments separated 
met redistributions 	space like quote 
source code 	works place 
must retain 	modifying arg appending 
copyright notice 	pointers argv 
list conditions 	store unquoted argv 
following 	still modify 
disclaimer redistributions 	arg place unlike 
binary form 	dequote argv 
must reproduce 	argv duplicate take 
copyright notice 	ownership quote 
list conditions 	path relative 
following 	given prefix quoting 
disclaimer documentation 	languages reachable.c 
materials provided 	progress count path 
distribution neither 	oid flag 
name redis 	data revs obj 
names 	name data 
contributors may 	data revs timestamp 
used endorse 	sha mtime 
promote products 	data obj sha 
derived software 	path data 
without specific 	obj sha pos 
prior 	data obj 
written permission 	revs timestamp data 
software provided 	revs mark 
copyright holders 	reflog mark recent 
contributors express 	progress display 
implied warranties 	progress warning parse 
including 	die pending 
limited implied 	update progress 
warranties merchantability 	mark sha info 
fitness particular 	die sha 
purpose disclaimed 	hex parse die 
shall copyright 	lookup lookup 
owner 	blob die sha 
contributors liable 	hex die 
direct indirect 	sha hex pending 
incidental special 	lookup stat 
exemplary consequential 	error sha hex 
damages including 	strerror recent 
limited 	lookup recent loose 
procurement substitute 	packed index 
goods services 	objects pending head 
loss use 	reflogs pending 
data profits 	prepare revision walk 
business interruption 	die traverse 
however 	commit list unseen 
caused theory 	recent objects 
liability whether 	traversal die 
contract strict 	prepare revision walk 
liability tort 	die traverse 
including negligence 	commit list display 
otherwise 	progress traversal 
arising way 	already marked seen 
use software 	need handle 
even advised 	progress reporting want 
possibility damage 	call parse 
create sds 	inflating blobs trees 
content 	could expensive 
specified init 	however need know 
pointer initlen 	correct type 
used init 	later processing revision 
initialized zero 	machinery expects 
bytes always 	commits tags parsed 
termined 	went away 
sds always 	iteration could due 
even create 	simultaneous repack 
sds mystring 	anything abort 
sdsnewlen abc 	since might fail 
print end 	mark objects 
however 	pruned revision parsing 
binary safe 	mark interested 
contain characters 	types commits refs 
middle length 	index file 
stored sds 	external refs detached 
header empty 	head included 
usually 	list reflog info 
created order 	revision walk 
append use 	move commits pending 
type since 	list commit 
type good 	walking list reachable.h 
flags pointer 	revs timestamp 
create 	revs mark reflog 
empty zero 	mark recent 
length sds 	progress read-cache.c 
even always 	options index alternate 
term create 	index output 
sds starting 	istate istate old 
terminated 	istate name 
duplicate sds 	namelen changed match 
free sds 	sha expected 
operation performed 	size match buffer 
sds length 	size sha 
length obtained 	changed istate istate 
strlen 	istate istate 
considering content 	options changed ignore 
first term 	valid ignore 
character function 	skip worktree racy 
useful sds 	modified istate 
hacked manually 	options changed changed 
way 	name len 
like following 	mode name len 
example sdsnew 	mode len 
foobar sdsupdatelen 	cmp name 
sdslen output 	len mode name 
comment call 	len mode 
sdsupdatelen 	cmp name len 
output modified 	name len 
logical length 	min len cmp 
remains bytes 	name len 
modify sds 	stage name len 
place make 	stage cmp 
empty 	istate name namelen 
zero length 	stage first 
however existing 	last next cmp 
buffer discarded 	istate name 
free space 	namelen istate pos 
next append 	istate istate 
operations 	path pos path 
require allocations 	namelen istate 
number bytes 	path namelen pos 
previously available 	len istate 
enlarge free 	len sha 
space end 	istate path flags 
sds 	size namelen 
caller sure 	mode option verbose 
calling function 	pretend intent 
overwrite addlen 	option ent pos 
bytes end 	istate path 
plus one 	flags mode sha 
nul 	path stage 
term note 	refresh options size 
change length 	len ret 
sds returned 	len rest path 
sdslen free 	istate pos 
buffer space 	replace retval len 
asap 	stage name 
enough space 	istate pos replace 
left use 	retval stage 
type user 	name slash len 
appending type 	istate pos 
able remember 	replace retval 
empty 	istate option pos 
space sds 	replace skip 
make room 	check istate option 
must called 	pos ret 
every appending 	istate options err 
operation since 	changed ret 
header 	updated changed size 
size changes 	refresh ignore 
need move 	valid ignore skip 
forward use 	worktree ignore 
realloc reallocate 	missing fmt name 
sds free 	porcelain first 
space 	header msg istate 
end contained 	flags pathspec 
remains altered 	seen header msg 
next concatenation 	errors really 
operations require 	allow unmerged quiet 
reallocation call 	ignore submodules 
passed 	first porcelain 
sds longer 	options modified fmt 
valid references 	deleted fmt 
must substituted 	typechange fmt added 
pointer returned 	fmt unmerged 
call total 	fmt cache errno 
size 	changed filtered 
allocation specifed 	fmt options envversion 
sds including 	endp version 
sds header 	ctime mtime dev 
pointer free 	ino mode 
buffer end 	uid gid size 
term 	sha flags 
pointer actual 	name ctime mtime 
sds allocation 	dev ino 
normally sds 	mode uid gid 
referenced start 	size sha 
buffer increment 	flags flags 
sds 	name hdr size 
length decrements 	sha hdr 
left free 	version istate ext 
space end 	data die 
according incr 	error istate ondisk 
also term 	flags name 
end 	len name len 
function used 	ondisk ent 
order fix 	size previous name 
length user 	len name 
calls sds 	flags ondisk extended 
make room 	flags consumed 
writes 	istate next name 
something end 	compare istate 
current needs 	istate istate path 
length note 	must exist 
possible use 	src offset hdr 
negative increment 	mmap mmap 
order 	size previous 
right trim 	name disk consumed 
usage example 	extsize istate 
sds incr 	path split index 
len sds 	ret istate 
make room 	istate istate write 
possible 	buffer write 
mount following 	buffer len context 
schema cat 	buffered context 
bytes coming 	data len buffered 
kernel end 	context ext 
sds without 	context sha left 
copying 	ondisk flags 
intermediate buffer 	ondisk previous name 
oldlen sdslen 	size ondisk 
sds make 	saved namelen name 
room buffer 	result common 
size nread 	prefix size istate 
read 	path sha 
oldlen buffer 	istate istate 
size check 	entries istate lockfile 
nread handle 	istate newfd 
sds incr 	strip extensions hdr 
len nread 	err removed 
avoid 	extended hdr version 
compilation warnings 	cache entries 
grow sds 	previous name msg 
specified length 	allow name 
bytes part 	istate flags ret 
original length 	istate flags 
sds 	ret temporary sharedindex 
zero specified 	istate flags 
length smaller 	ret istate flags 
current length 	ret istate 
operation performed 	unmerged size len 
make sure 	istate name 
added 	namelen pos istate 
region doesn 	path size 
contain garbage 	pos len 
also trailing 	data path name 
append specified 	hash replace 
binary safe 	index entry name 
pointed 	hash free 
len bytes 	index entry strlen 
end specified 	xmalloc cache 
sds call 	entry size copy 
passed sds 	cache entry 
longer valid 	memcpy cache invalidate 
references 	path untracked 
must substituted 	cache index index 
pointer returned 	entry index 
call append 	entry ctime nsec 
specified termianted 	mtime nsec 
sds call 	mtime nsec ctime 
passed 	nsec fill 
sds longer 	stat data 
valid references 	isreg mark uptodate 
must substituted 	open index 
pointer returned 	hashcmp strbuf readlink 
call append 	read sha 
specified 	file memcmp free 
sds existing 	strbuf release 
sds call 	resolve gitlink hashcmp 
modified sds 	compare data 
longer valid 	compare link xsize 
references must 	isgitlink compare 
substituted 	gitlink isreg islnk 
pointer returned 	isreg isdir 
call destructively 	compare gitlink die 
modify sds 	match stat 
hold specified 	data empty blob 
binary safe 	sha isgitlink 
pointed 	racy stat racy 
length len 	stat match 
bytes like 	stat data 
sdscpylen must 	skip worktree intent 
termined length 	match stat 
obtained strlen 	basic racy timestamp 
helper 	modified check 
sdscatlonglong actual 	match stat isgitlink 
number conversion 	modified check 
must point 	memcmp isdir isdir 
room least 	memcmp isdir 
sds llstr 	isdir memcmp name 
size 	compare cache 
bytes function 	name stage compare 
returns length 	namelen stage 
terminated representation 	index name stage 
stored generate 	pos record 
representation method 	resolve undo name 
produces 	hash save 
reversed compute 	free index entry 
length term 	memmove name 
reverse identical 	hash save 
sdsll str 	free index entry 
type generate 	index name 
representation 	pos strlen cache 
method produces 	invalidate path 
reversed compute 	untracked cache index 
length term 	strcmp index 
reverse create 	entry namelen memcmp 
sds much 	index name 
faster 	pos compare name 
sdscatprintf sdsempty 	stage stage 
lld like 	compare name namelen 
sdscatprintf gets 	namelen memcmp 
list instead 	die namelen xcalloc 
variadic start 	cache entry 
buffer 	size memcpy copy 
speed possible 	cache entry 
revert heap 	save free index 
allocation buffers 	entry write 
two times 	sha file 
bigger every 	die hashcpy isreg 
time 	islnk isdir 
fail fit 	error strlen isdir 
current buffer 	cache entry 
size concat 	size xcalloc memcpy 
obtained sds 	fill stat 
append sds 	cache info create 
obtained 	mode index 
alike format 	name pos also 
specifier call 	unmerged mode 
modified sds 	stat adjust dirname 
longer valid 	index file 
references must 	exists namelen stage 
substituted 	match stat 
pointer returned 	isgitlink mark uptodate 
call example 	free index 
sdsnew sum 	path free 
sdscatprintf often 	error name intent 
need create 	entry different 
scratch 	name create stage 
alike format 	hashcmp free 
need use 	index entry free 
sdsempty target 	error lstat 
sdscatprintf sdsempty 	die errno index 
format args 	verify path 
function 	error strlen cache 
similar sdscatprintf 	entry size 
much faster 	xcalloc hashcpy memcpy 
rely sprintf 	create flags 
family functions 	create mode refresh 
implemented libc 	cache entry 
often 	free namelen namelen 
slow moreover 	memcmp dir 
directly handling 	sep dir sep 
sds data 	dos drive 
concatenated provides 	prefix dir 
performance improvement 	sep hfs dotgit 
however 	ntfs dotgit 
function handles 	verify dotfile dir 
incompatible subset 	sep namelen 
alike format 	stage namelen memcmp 
specifiers sds 	stage index 
bit integer 	entry stage namelen 
bit 	index name 
integer verbatim 	stage pos index 
character next 	entry namelen 
format specifier 	memcmp stage file 
process position 	name dir 
next write 	name cache invalidate 
dest 	path index 
str make 	name stage pos 
sure always 	namelen stage 
space least 	replace index entry 
handle generally 	untracked cache 
unknown term 	index stage 
part 	name index entry 
left right 	verify path 
composed contiguous 	error check file 
characters found 	directory conflict 
cset terminted 	error index name 
call modified 	stage pos 
sds 	namelen stage index 
longer valid 	entry check 
references must 	alloc grow memmove 
substituted pointer 	index entry 
returned call 	uptodate skip worktree 
example sdsnew 	mark uptodate 
hello 	mark uptodate symlink 
world sdstrim 	leading path 
output hello 	namelen lstat match 
world turn 	stat isgitlink 
smaller equal 	mark uptodate modified 
containing substring 	size xmalloc 
specified 	memcpy fill 
start end 	stat cache info 
indexes start 	isgitlink path 
end negative 	match stage strcmp 
means last 	show file 
character penultimate 	refresh cache ent 
character 	intent show 
forth interval 	file replace index 
inclusive start 	entry refresh 
end characters 	cache ent getenv 
part resulting 	git config 
modified place 	warning strtoul warning 
example 	htonl error 
sdsnew hello 	ntohl error git 
world sdsrange 	sha init 
ello world 	git sha update 
apply tolower 	git sha 
every character 	hashcmp error cache 
sds 	ext cache 
apply toupper 	read resolve 
every character 	undo read read 
sds compare 	link extension 
two sds 	read untracked extension 
memcmp positive 	error hold 
negative 	file update index 
exactly binary 	file read 
two share 	index index file 
exactly prefix 	xmalloc cache 
one two 	entry size hashcpy 
additional characters 	memcpy decode 
longer 	varint die strbuf 
considered greater 	strbuf die 
smaller one 	strlen cache entry 
split separator 	ondisk ondisk 
sep sds 	size expand name 
returned count 	field cache 
reference 	entry ondisk 
number tokens 	strcmp die stage 
returned memory 	die stage 
zero length 	stage die git 
zero length 	config untracked 
separator returned 	cache untracked cache 
note 	untracked cache 
sep able 	check order tweak 
split multi 	untracked cache 
character separator 	open die errno 
example sdssplit 	fstat die 
foo bar 	errno xsize die 
two 	xmmap die 
elements foo 	errno close verify 
bar version 	hdr hashcpy 
function binary 	ntohl ntohl alloc 
safe requires 	xcalloc create 
length arguments 	disk index entry 
sdssplit 	strbuf release 
function zero 	mtime nsec 
terminated make 	memcpy ntohl read 
sure room 	index extension 
next element 	munmap munmap die 
one search 	read index 
separator 	sha post read 
skip separator 	index discard 
element sure 	index xcalloc read 
room tokens 	index git 
free result 	path sha hex 
returned 	hashcmp die 
sdssplitlen nothing 	sha hex git 
tokens append 	path sha 
sds escaped 	hex sha hex 
representation non 	merge index 
printable characters 	post read index 
tested 	free resolve 
isprint turned 	undo clear index 
escapes form 	free name 
hex number 	hash cache 
call modified 	free free discard 
sds longer 	split index 
valid 	free untracked cache 
references must 	stage git 
substituted pointer 	sha update write 
returned call 	full memcpy 
helper function 	write flush htonl 
sdssplitargs returns 	htonl write 
non 	write git sha 
zero valid 	update write 
hex digit 	full git sha 
helper function 	hashcpy write 
sdssplitargs converts 	full lstat match 
hex digit 	stat basic 
integer 	modified check htonl 
split line 	htonl htonl 
arguments every 	htonl htonl htonl 
argument following 	htonl htonl 
programming language 	htonl htonl 
repl alike 	hashcpy namelen namelen 
form 	htons htons 
foo bar 	namelen ondisk size 
newline supported 	xcalloc copy 
xff otherstuff 	cache entry ondisk 
number arguments 	memcpy namelen 
stored argc 	encode varint offsetof 
sds 	offsetof namelen 
returned caller 	xcalloc copy cache 
free resulting 	entry ondisk 
sds sdsfreesplitres 	memcpy memcpy namelen 
note sdscatrepr 	strbuf splice 
able convert 	namelen write free 
back 	open fstat 
quoted format 	pread full hashcmp 
sdssplitargs able 	close close 
parse function 	verify index 
returns allocated 	index file racy 
tokens success 	timestamp racy 
even 	timestamp verify index 
input empty 	write locked 
input contains 	index rollback file 
unbalanced quotes 	index format 
closed quotes 	getenv init split 
followed non 	index htonl 
space 	htonl htonl git 
characters foo 	sha init 
bar foo 	write uptodate racy 
skip blanks 	timestamp smudge 
token quotes 	racily clean entry 
single quotes 	sha git 
closing 	env warning error 
quote must 	write entry 
followed space 	strbuf release write 
nothing unterminated 	link extension 
quotes closing 	write index 
quote must 	ext header write 
followed 	strbuf release 
space nothing 	cache write write 
unterminated quotes 	index ext 
token vector 	header write strbuf 
even empty 	release resolve 
input something 	undo write write 
modify 	index ext 
substituting occurrences 	header write strbuf 
characters specified 	release write 
corresponding character 	untracked extension write 
instance sdsmapchars 	index ext 
mystring effect 	header write strbuf 
turning 	release flush 
hello ell 	fstat mtime nsec 
function returns 	commit file 
sds pointer 	commit file write 
always input 	index file 
pointer since 	commit locked 
resize 	index close file 
needed specified 	prepare write 
separator also 	split index write 
returns result 	locked index 
sds like 	finish writing split 
sdsjoin joins 	index mks 
sds 	tempfile git path 
wrappers allocators 	hashclr write 
used sds 	locked index move 
note sds 	cache index 
actually use 	write index tempfile 
macros defined 	rename tempfile 
sdsalloc 	git path sha 
order avoid 	hex hashcpy 
pay overhead 	hashclr write locked 
function calls 	index getenv 
define wrappers 	write shared index 
programs sds 	write split 
linked 	index read 
want touch 	index stage namelen 
sds internals 	cache entry 
even use 	size xcalloc memcpy 
different allocator 	create flags 
run test 	index entry error 
times 	index name 
order hit 	pos namelen memcmp 
first two 	strlen index 
sds header 	name pos strcmp 
types type 	stage read 
size init 	sha file free 
initlen 	free stat 
type hdrlen 	isreg match stat 
init initlen 	data fstat 
reallen addlen 	isreg stat validity 
newsh avail 	clear xcalloc 
len newlen 	fill stat 
type 	data git information 
oldtype hdrlen 	manager hell 
newsh type 	copyright linus torvalds 
oldtype hdrlen 	mask name 
len alloc 	length flags disk 
incr flags 	index index 
len 	extensions first letter 
oldlen len 	extensions necessary 
curlen len 	correct operation optimization 
curlen len 	data extensions 
aux aux 	added needs understood 
buf len 	order correctly 
fmt 	interpret index file 
cpy staticbuf 	pick character 
buflen fmt 	outside range cause 
fmt initlen 	reader abort 
next str 	reuc link untr 
num unum 	changes kept 
buf 	git dir 
buf cset 	index basically extensions 
start end 	dev breaks 
len start 	network filesystems different 
end newlen 	clients different 
len minlen 	views device filesystem 
cmp 	updates non 
len sep 	critical parts directory 
seplen count 	cache parts 
tokens newtokens 	aren tracked git 
tokens count 	used validate 
len line 	cache index closed 
argc 	file descriptor 
current vector 	already actually require 
inq insq 	git directory 
done setlen 	gitlink directory valid 
argv argc 	git directory 
sep argv 	might even missing 
argc 	nobody populated 
sep seplen 	sub project 
size ptr 	consider always match 
size ptr 	consider owner 
oldfree oldlen 	bit relevant mode 
type sds 	changes ignore 
req 	xxx fields gitlinks 
type sds 	racily smudged 
hdr size 	entry nanosecond timestamped 
malloc memset 	files also 
sds hdr 	racy marked always 
sds hdr 	valid index 
sds 	valid whatever copy 
hdr sds 	says skip 
hdr memcpy 	worktree effect higher 
sdsnewlen strlen 	precedence intent 
sdsnewlen sdsnewlen 	entries added index 
sdslen free 	entry definition 
sds 	never matches work 
hdr size 	actually gets 
strlen sdssetlen 	added within 
sdssetlen sdsavail 	second sequence echo 
sdslen sds 	xyzzy file 
hdr size 	git update index 
sds 	file running 
req type 	command echo frotz 
sds hdr 	file would 
size realloc 	give falsely clean 
malloc memcpy 	cache entry 
free sdssetlen 	mtime length match 
sdssetalloc 	cache stat 
sdslen sds 	fields change could 
hdr size 	detect update 
sds req 	index time cache 
type sds 	entry registered 
hdr size 	updated records time 
realloc 	delay git 
malloc memcpy 	update index would 
free sdssetlen 	effectively mean 
sdssetalloc sdsalloc 	make one 
sds hdr 	commit per second 
size sds 	acceptable instead 
hdr 	check cache entries 
size sds 	whose mtime 
type len 	index file timestamp 
sds hdr 	carefully others 
sds hdr 	mode type changed 
sds hdr 	point trying 
sds 	refresh entry going 
hdr sdslen 	match immediately 
sds make 	read update index 
room memset 	cacheinfo length 
sdssetlen sdslen 	field zero never 
sds make 	even read 
room 	lstat information cannot 
memcpy sdssetlen 	trust data 
sdscatlen strlen 	changed returned 
sdscatlen sdslen 	match stat turn 
sdsalloc sds 	returned match 
make room 	stat basic signal 
sdslen 	filesize blob 
memcpy sdssetlen 	changed actually filesystem 
sdscpylen strlen 	see contents 
sdsll str 	match answer unchanged 
sdsnewlen strlen 	logic apply 
malloc copy 	gitlinks match stat 
vsnprintf 	basic already 
end free 	actual head filesystem 
malloc sdscat 	subproject match 
free start 	stat already said 
sdscatvprintf end 	different know 
sdslen start 	name compare identical 
sdsavail 	name compare 
sds make 	compares conflicting directory 
room arg 	file entries 
strlen sdslen 	equal note 
sdsavail sds 	directory name compares 
make room 	equal regular 
memcpy 	file individually compare 
sdsinclen arg 	differently filename 
sdsll str 	dot basename used 
sdsavail sds 	routines want 
make room 	traverse git handle 
memcpy sdsinclen 	conflicting entries 
sdsull 	together possible directories 
str sdsavail 	files compare 
sds make 	equal length name 
room memcpy 	entry entries 
sdsinclen sdsinclen 	cache entries marked 
sdsinclen end 	removal flags 
sdslen 	much effective calling 
strchr strchr 	index entry 
memmove sdssetlen 	entry removed maybe 
sdslen memmove 	unmerged order 
sdssetlen sdslen 	preference stage 
tolower sdslen 	filename aliases cache 
toupper 	use name 
sdslen sdslen 	already want update 
memcmp malloc 	twice implies 
realloc memcmp 	actually two different 
sdsnewlen sdsnewlen 	files aliasing 
sdsfree free 	names use added 
sdsfree 	flag verify 
free sdscatlen 	old one accept 
sdscatprintf sdscatlen 	create entry 
sdscatlen sdscatlen 	name existing existing 
sdscatlen sdscatlen 	entry pick 
isprint sdscatprintf 	mode bits type 
sdscatprintf 	otherwise unexecutable 
sdscatlen isspace 	regular file core 
sdsempty hex 	ignorecase determine 
digit hex 	directory name differing 
digit hex 	already exists 
digit hex 	within git 
digit 	repository ensure directory 
sdscatlen sdscatlen 	file added 
isspace sdscatlen 	repository matches folded 
sdscatlen isspace 	existing entry 
sdscatlen sdscatlen 	directory nothing changed 
realloc malloc 	really suspected 
sdsfree 	racily clean turns 
free sdsfree 	fundamentally like 
sdslen sdsempty 	paths want dot 
sdscat sdscat 	dot dot 
sdsempty sdscatsds 	anywhere obvious reasons 
sdscatlen malloc 	want recurse 
realloc 	git either also 
free sdsnew 	want slashes 
sdsfree sdsnewlen 	slashes end make 
sdscat test 	pathnames ambiguous 
cond sdslen 	first character 
memcmp sdscpy 	already discarded test 
sdscpy 	rest allowed 
sdsfree sdscatprintf 	git followed nul 
sdsempty sdsfree 	slash bad 
sdsnew sdscatfmt 	shares path end 
sdsfree sdsnew 	test fallthrough 
sdscatfmt sdsfree 	another file beginning 
sdsnew 	components proper 
sdstrim sdsfree 	superset name trying 
sdsnew sdstrim 	another file 
sdsfree sdsnew 	pathname proper subset 
sdstrim sdsdup 	name trying 
sdsrange sdsfree 	found one fast 
sdsdup 	could marker 
sdsrange sdsfree 	says removed entry 
sdsdup sdsrange 	part resulting 
sdsfree sdsdup 	directory path trivial 
sdsrange sdsfree 	optimization find 
sdsdup sdsrange 	entry already 
sdsfree 	matches sub directory 
sdsdup sdsrange 	know exit 
sdsfree sdsfree 	subdirectory stage entry 
sdsnew sdsnew 	subdirectory looking 
sdsfree sdsfree 	cannot conflicts level 
sdsnew sdsnew 	anything shorter 
sdsfree 	may situation already 
sdsfree sdsnew 	path file 
sdsnew sdsfree 	path added already 
sdsfree sdsnewlen 	path path 
sdscatrepr sdsempty 	file added either 
sdslen sdsfree 	one would 
sdsfree 	result nonsense path 
sdsnew test 	twice git 
cond sdslen 	write tries write 
sdsavail sdslen 	prevent replace 
sds make 	specified conflicting entries 
room test 	cache caller 
cond 	recompute insert 
sdslen test 	position happens non 
cond sdsavail 	zero going 
sdsavail sds 	away entry allow 
incr len 	added check 
test cond 	path sub path 
memcmp 	subsequent pathname 
test cond 	first since removing 
sdslen sdsfree 	change position 
sds test 	check path might 
sds lib 	clashing sub 
library copyright 	directory existing match 
salvatore 	replace inserting 
sanfilippo antirez 	merged entry stage 
gmail dot 	index always 
copyright oran 	replace non merged 
agra copyright 	entries make 
redis labs 	sure big enough 
inc 	refresh calculate 
rights reserved 	sha file 
redistribution use 	bring cache date 
source binary 	mode content 
forms without 	changes match stat 
modification permitted 	information file 
provided 	cache refresh cache 
following conditions 	file hasn 
met redistributions 	changed stat entry 
source code 	date example 
must retain 	want git read 
copyright notice 	link stat 
list 	cache details proper 
conditions following 	files valid 
disclaimer redistributions 	skip worktree means 
binary form 	user promised 
must reproduce 	change work matter 
copyright notice 	told worry 
list 	path unchanged 
conditions following 	told ignore valid 
disclaimer documentation 	bit actual 
materials provided 	stat check found 
distribution neither 	entry unmodified 
name redis 	entry marked valid 
names 	place mark 
contributors may 	valid unchanged mode 
used endorse 	mark one 
promote products 	valid mark index 
derived software 	modified uptodate 
without specific 	flag core going 
prior 	write change 
written permission 	ignore valid valid 
software provided 	bit alone 
copyright holders 	otherwise paths marked 
contributors express 	unchanged things 
implied warranties 	edited reacquire valid 
including 	bit automatically 
limited implied 	really want 
warranties merchantability 	istate cache changed 
fitness particular 	updated caller 
purpose disclaimed 	really refresh means 
shall copyright 	index valid 
owner 	anymore must checks 
contributors liable 	index file 
direct indirect 	dev ino uid 
incidental special 	gid size 
exemplary consequential 	also tracked low 
damages including 	bits strong 
limited 	practice heuristic inode 
procurement substitute 	hasn changed 
goods services 	save fields big 
loss use 	endian order 
data profits 	allow index file 
business interruption 	nfs transparently 
however 	used extended bit 
caused theory 	must match 
liability whether 	ondisk cache 
contract strict 	entry exactly ctime 
liability tort 	till flags 
including negligence 	used lower adjacent 
otherwise 	cache entries 
arising way 	tend share leading 
use software 	paths makes 
even advised 	sense store differences 
possibility damage 	later entries 
create sds 	disk format index 
content 	disk cache 
specified init 	entry stores number 
pointer initlen 	bytes stripped 
used init 	end previous name 
initialized zero 	bytes append 
bytes always 	result come name 
termined 	find end 
sds always 	disk flags bits 
even create 	yet understand 
sds mystring 	bit extended 
sdsnewlen abc 	flags earlier keep 
print end 	nothing unknown 
however 	nothing remember discard 
binary safe 	cache reading 
contain characters 	different cache active 
middle length 	index entries 
stored sds 	arbitrary number extended 
header empty 	sections prefixed 
usually 	extension name section 
created order 	length network 
append use 	order istate initialized 
type since 	covers git 
type good 	index git sharedindex 
flags pointer 	xxx flush 
create 	first enough space 
empty zero 	sha signature 
length sds 	append sha signature 
even always 	end thing 
term create 	care function 
sds 	smudge falsely clean 
starting terminated 	entry due 
duplicate sds 	touch update touch 
free sds 	race everything 
operation performed 	called entries whose 
sds length 	stat data 
length 	mtime match index 
obtained strlen 	file mtime 
considering content 	note actually much 
first term 	gitlinks match 
character function 	stat basic always 
useful sds 	goes actual 
hacked 	contents caller checks 
manually way 	racy timestamp 
like following 	always says gitlinks 
example sdsnew 	called racily 
foobar sdsupdatelen 	clean smudge 
sdslen output 	note tricky code 
comment 	first glance 
call sdsupdatelen 	may appear sequence 
output modified 	echo xyzzy 
logical length 	frotz git update 
remains bytes 	index frotz 
modify sds 	frotz sleep echo 
place 	filfre nitfol 
make empty 	git update index 
zero length 	nitfol second 
however existing 	update index runs 
buffer discarded 	notices entry 
free space 	frotz timestamp index 
next 	smudge resetting 
append operations 	size zero name 
require allocations 	recorded index 
number bytes 	file cached stat 
previously available 	information becomes 
enlarge free 	zero would 
space 	match would obtain 
end sds 	filesystem next 
caller sure 	time stat frotz 
calling function 	however second 
overwrite addlen 	update index calling 
bytes end 	function notices 
plus 	cached size bytes 
one nul 	filesystem empty 
term note 	file never calls 
change length 	cached size 
sds returned 	information frotz stays 
sdslen free 	match filesystem 
buffer 	copy miscellaneous fields 
space asap 	name compiler 
enough space 	workaround still matching 
left use 	function verifies 
type user 	index state correct 
appending type 	sha index 
able 	file die 
remember empty 	failure opportunistically update 
space sds 	index complain 
make room 	reduce extended entries 
must called 	possible demote 
every appending 	version version latter 
operation 	suffices write 
since header 	extension data read 
size changes 	index file 
need move 	potentially unmerged given 
forward use 	index state 
realloc reallocate 	dropping unmerged entries 
sds 	returns index 
free space 	unmerged callers want 
end contained 	refuse work 
remains altered 	unmerged state call 
next concatenation 	check instead 
operations require 	calling read cache 
reallocation 	returns path 
call passed 	path respect 
sds longer 	index path mentioned 
valid references 	index either 
must substituted 	file directory files 
pointer returned 	index unmerged 
call 	entry helpfully trailing 
total size 	directories output 
allocation specifed 	read directory used 
sds including 	exact match 
sds header 	yup one exists 
pointer free 	unmerged might 
buffer 	middle merge would 
end term 	read stage 
pointer actual 	read-tree.c trees read 
sds allocation 	empty trees 
normally sds 	sha read usage 
referenced start 	opt arg 
buffer 	unset opt 
increment sds 	arg unset dir 
length decrements 	opts label 
left free 	stages buf file 
space end 	argc argv 
according incr 	unused prefix stage 
also 	sha opts 
term end 	prefix read options 
function used 	arg die 
order fix 	parse indirect alternate 
length user 	index output 
calls sds 	die xcalloc stage 
make 	sha hex 
room writes 	debug stage xsnprintf 
something end 	debug stage 
current needs 	memset git config 
length note 	parse options 
possible use 	hold locked index 
negative 	die read 
increment order 	cache unmerged 
right trim 	die resolve undo 
usage example 	clear sha 
sds incr 	die list die 
len sds 	warning die 
make 	die die die 
room possible 	setup work 
mount following 	die cache unborn 
schema cat 	cache free 
bytes coming 	parse init desc 
kernel end 	unpack trees 
sds 	prime cache write 
without copying 	locked index 
intermediate buffer 	die git information 
oldlen sdslen 	manager hell 
sds make 	copyright linus torvalds 
room buffer 	need want 
size 	read directory merely 
nread read 	interested reusing 
oldlen buffer 	per directory 
size check 	ignore stack mechanism 
nread handle 	needswork old 
sds incr 	index read anyway 
len 	even going 
nread avoid 	destroy index entries 
compilation warnings 	still need 
grow sds 	preserve certain information 
specified length 	index version 
bytes part 	split index mode 
original 	write index 
length sds 	reading one either 
zero specified 	basic form 
length smaller 	ent reset ent 
current length 	form obtain 
operation performed 	fully valid cache 
make 	index must 
sure added 	match exactly came 
region doesn 	receive-pack.c receive 
contain garbage 	pack usage 
also trailing 	deny deletes deny 
append specified 	non fast 
binary 	forwards receive fsck 
safe pointed 	objects transfer 
len bytes 	fsck objects fsck 
end specified 	msg types 
sds call 	receive unpack limit 
passed sds 	transfer unpack 
longer 	limit advertise atomic 
valid references 	push unpack 
must substituted 	limit report status 
pointer returned 	use sideband 
call append 	use atomic quiet 
specified termianted 	prefer ofs 
sds 	delta update server 
call passed 	info fix 
sds longer 	thin stateless 
valid references 	rpc service dir 
must substituted 	head name 
pointer returned 	head name free 
call 	sent capabilities 
append specified 	shallow update alt 
sds existing 	shallow file 
sds call 	push cert push 
modified sds 	cert sha 
longer valid 	sigcheck push cert 
references 	nonce cert 
must substituted 	nonce seed nonce 
pointer returned 	unsolicited nonce 
call destructively 	bad nonce missing 
modify sds 	nonce nonce 
hold specified 	slop nonce status 
binary 	nonce stamp 
safe pointed 	slop nonce stamp 
length len 	slop limit 
bytes like 	transaction status 
sdscpylen must 	path path sha 
termined length 	cap path 
obtained 	full oid flag 
strlen helper 	unused path 
sdscatlonglong actual 	sha unused data 
number conversion 	next error 
must point 	index old sha 
room least 	sha name 
sds 	err err prefix 
llstr size 	err msg 
bytes function 	err err arg 
returns length 	data key 
terminated representation 	key len text 
stored generate 	text len 
representation 	key ipad opad 
method produces 	ctx path 
reversed compute 	stamp buf sha 
length term 	msg len 
reverse identical 	key key 
sdsll str 	len line eol 
type 	offset buf 
generate representation 	len nonce stamp 
method produces 	ostamp bohmac 
reversed compute 	expect retval proc 
length term 	already done 
reverse create 	gpg output gpg 
sds 	status bogs 
much faster 	hook name feed 
sdscatprintf sdsempty 	feed state 
lld like 	proc muxer argv 
sdscatprintf gets 	code buf 
list instead 	cmd skip broken 
variadic 	buf state 
start buffer 	bufp sizep state 
speed possible 	cmd commands 
revert heap 	hook name skip 
allocation buffers 	broken state 
two times 	status cmd 
bigger 	argv proc code 
every time 	refuse unconfigured 
fail fit 	deny msg refuse 
current buffer 	unconfigured deny 
size concat 	current msg data 
obtained sds 	sha cmd 
append 	shallow extra alt 
sds obtained 	file mask 
alike format 	sha sha env 
specifier call 	work update 
modified sds 	refresh diff files 
longer valid 	diff index 
references 	read child push 
must substituted 	checkout hook 
pointer returned 	sha env work 
call example 	sha retval 
sdsnew sum 	work env cmd 
sdscatprintf often 	name namespaced 
need 	name buf 
create scratch 	namespaced name ret 
alike format 	old sha 
need use 	sha old old 
sdsempty target 	commit commit 
sdscatprintf sdsempty 	err err commands 
format 	cmd argc 
args function 	proc hook cmd 
similar sdscatprintf 	list buf 
much faster 	dst name item 
rely sprintf 	dst cmd 
family functions 	sha cmd oldh 
implemented 	cmd newh 
libc often 	dst oldh dst 
slow moreover 	newh flag 
directly handling 	commands cmd list 
sds data 	item data 
concatenated provides 	sha cmd 
performance 	list cmd commands 
improvement however 	cmd singleton 
function handles 	cmds data sha 
incompatible subset 	data cmd 
alike format 	list cmd commands 
specifiers sds 	refname full 
bit 	prefix len cmd 
integer bit 	cmd commands 
integer verbatim 	cmd connectivity commands 
character next 	cmd err 
format specifier 	commands cmd err 
process position 	reported error 
next 	commands unpacker error 
write dest 	cmd sha 
str make 	data tail line 
sure always 	linelen old 
space least 	sha sha cmd 
handle generally 	refname reflen 
unknown 	tail push 
term part 	cert boc eoc 
left right 	eol shallow 
composed contiguous 	commands line len 
characters found 	linelen sha 
cset terminted 	feature list flush 
call 	certbuf hdr 
modified sds 	pack lockfile err 
longer valid 	hdr hdr 
references must 	err status hdr 
substituted pointer 	arg child 
returned call 	fsck objects hostname 
example 	muxer ret 
sdsnew hello 	commands bitmap size 
world sdstrim 	commands cmd 
output hello 	status commands unpack 
world turn 	status cmd 
smaller equal 	buf commands cmd 
containing 	argc argv 
substring specified 	prefix advertise 
start end 	refs commands shallow 
indexes start 	arg unpack 
end negative 	status argv opt 
means last 	git config 
character 	parse hide refs 
penultimate character 	config strcmp 
forth interval 	git config strcmp 
inclusive start 	git config 
end characters 	strcmp git config 
part resulting 	strcmp git 
modified 	config strcmp git 
place example 	config pathname 
sdsnew hello 	strbuf addf free 
world sdsrange 	skip prefix 
ello world 	valid msg type 
apply tolower 	strbuf addf 
every 	warning strcmp git 
character sds 	config strcmp 
apply toupper 	git config 
every character 	strcmp parse deny 
sds compare 	action strcmp 
two sds 	parse deny action 
memcmp 	strcmp git 
positive negative 	config strcmp git 
exactly binary 	config strcmp 
two share 	git config strcmp 
exactly prefix 	git config 
one two 	strcmp git config 
additional 	strcmp git 
characters longer 	config strcmp git 
considered greater 	config git 
smaller one 	config packet write 
split separator 	sha hex 
sep sds 	strbuf addstr strbuf 
returned 	addstr strbuf 
count reference 	addstr strbuf 
number tokens 	addf strbuf addf 
returned memory 	git user 
zero length 	agent sanitized packet 
zero length 	write sha 
separator 	hex strbuf release 
returned note 	strip hidden 
sep able 	show show sha 
split multi 	append alternate 
character separator 	sha unique sha 
example sdssplit 	clear show 
foo 	advertise shallow grafts 
bar two 	packet flush 
elements foo 	xsnprintf vsnprintf send 
bar version 	sideband xwrite 
function binary 	start report message 
safe requires 	end start 
length 	report message end 
arguments sdssplit 	xread send 
function zero 	sideband close 
terminated make 	memset git sha 
sure room 	init git 
next element 	sha update git 
one 	sha memcpy 
search separator 	git sha init 
skip separator 	git sha 
element sure 	update git sha 
room tokens 	update git 
free result 	sha git sha 
returned 	init git 
sdssplitlen nothing 	sha update git 
tokens append 	sha update 
sds escaped 	git sha strbuf 
representation non 	addf hmac 
printable characters 	sha strlen strbuf 
tested 	release strbuf 
isprint turned 	addf sha hex 
escapes form 	strbuf detach 
hex number 	strlen strchrnul 
call modified 	memcmp xmemdupz find 
sds longer 	header strcmp 
valid 	strtoul prepare push 
references must 	cert nonce 
substituted pointer 	strcmp strtoul labs 
returned call 	free xstrdup 
helper function 	free free write 
sdssplitargs returns 	sha file 
non 	hashclr memset parse 
zero valid 	signature verify 
hex digit 	buffer parse gpg 
helper function 	output strbuf 
sdssplitargs converts 	release strbuf release 
hex digit 	check nonce 
integer 	sha argv pushf 
split line 	sha hex 
arguments every 	argv pushf argv 
argument following 	pushf argv 
programming language 	pushf argv 
repl alike 	pushf argv pushf 
form 	argv pushf 
foo bar 	find hook memset 
newline supported 	start prepare 
xff otherstuff 	push cert sha 
number arguments 	start command 
stored argc 	finish sigchain push 
sds 	feed write 
returned caller 	full close finish 
free resulting 	sigchain pop 
sds sdsfreesplitres 	finish command strbuf 
note sdscatrepr 	reset strbuf 
able convert 	addf sha hex 
back 	sha hex 
quoted format 	strbuf init feed 
sdssplitargs able 	receive hook 
parse function 	run feed 
returns allocated 	hook strbuf release 
tokens success 	find hook 
even 	sha hex sha 
input empty 	hex start 
input contains 	command copy sideband 
unbalanced quotes 	finish command 
closed quotes 	bare repository strcmp 
followed non 	size error 
space 	size error trace 
characters foo 	key delayed 
bar foo 	reachability test sha 
skip blanks 	append setup 
token quotes 	alternate shallow check 
single quotes 	shallow connected 
closing 	rollback file sha 
quote must 	clear commit 
followed space 	file shallow sha 
nothing unterminated 	clear sha 
quotes closing 	run command 
quote must 	child process init 
followed 	run command 
space nothing 	head history child 
unterminated quotes 	process init 
token vector 	run command sha 
even empty 	hex child 
input something 	process init run 
modify 	command argv 
substituting occurrences 	pushf absolute path 
characters specified 	run hook 
corresponding character 	sha hex bare 
instance sdsmapchars 	repository argv 
mystring 	pushf absolute path 
effect turning 	git dir 
hello ell 	find hook push 
function returns 	deploy push 
sds pointer 	checkout argv clear 
always input 	starts check 
pointer 	refname format 
since resize 	error strbuf addf 
needed specified 	git strbuf 
separator also 	detach warning error 
returns result 	refuse unconfigured 
sds like 	deny update worktree 
sdsjoin 	sha sha 
joins sds 	file error sha 
wrappers allocators 	hex sha 
used sds 	sha starts error 
note sds 	strcmp warning 
actually use 	refuse unconfigured deny 
macros 	current error 
defined sdsalloc 	sha sha starts 
order avoid 	parse parse 
pay overhead 	error merge bases 
function calls 	error run 
define wrappers 	update hook error 
programs 	sha parse 
sds linked 	exists warning 
want touch 	warning transaction error 
sds internals 	strbuf release 
even use 	strbuf release update 
different allocator 	shallow transaction 
run 	update error strbuf 
test times 	release strbuf 
order hit 	release find hook 
first two 	argv push 
sds header 	argv push start 
types sds 	command copy 
lib 	sideband finish command 
library copyright 	strbuf addf 
salvatore sanfilippo 	git resolve strbuf 
antirez gmail 	release strip 
dot copyright 	error list lookup 
oran agra 	hashcmp hashcmp 
copyright 	find unique abbrev 
redis labs 	find unique 
inc rights 	abbrev find 
reserved redistribution 	unique abbrev find 
use source 	unique abbrev 
binary forms 	error list append 
without 	list sort 
modification permitted 	check aliased update 
provided following 	list clear 
conditions met 	sha hashcpy check 
redistributions source 	everything connected 
code must 	sha hashcpy strbuf 
retain 	addstr git 
copyright notice 	strbuf setlen strbuf 
list conditions 	addstr hidden 
following disclaimer 	sha strbuf release 
redistributions binary 	process cmd 
form must 	error die process 
reproduce 	cmd transaction 
copyright notice 	begin error 
list conditions 	strbuf reset update 
following disclaimer 	transaction commit 
documentation materials 	error strbuf reset 
provided distribution 	transaction free 
neither 	strbuf release transaction 
name redis 	begin error 
names contributors 	strbuf reset process 
may used 	cmd update 
endorse promote 	transaction commit error 
products derived 	transaction free 
software 	strbuf release check 
without specific 	everything connected 
prior written 	connectivity errors reject 
permission software 	updates hidden 
provided copyright 	run receive hook 
holders contributors 	check aliased 
express 	updates free resolve 
implied warranties 	refdup execute 
including limited 	commands atomic 
implied warranties 	execute commands non 
merchantability fitness 	atomic warn 
particular purpose 	skipped connectivity check 
disclaimed 	sha hex 
shall copyright 	sha hex die 
owner contributors 	xcalloc hashcpy 
liable direct 	hashcpy memcpy die 
indirect incidental 	strstr die 
special exemplary 	parse signature memchr 
consequential 	queue command 
damages including 	packet read line 
limited procurement 	starts sha 
substitute goods 	hex die sha 
services loss 	append strlen 
use data 	parse feature request 
profits 	parse feature 
business interruption 	request parse feature 
however caused 	request parse 
theory liability 	feature request 
whether contract 	strcmp packet read 
strict liability 	strcmp strbuf 
tort 	addstr queue command 
including negligence 	queue commands 
otherwise arising 	cert read pack 
way use 	header parse 
software even 	pack header close 
advised possibility 	snprintf ntohl 
damage 	ntohl setup temporary 
create sds 	shallow argv 
content specified 	push argv push 
init pointer 	ntohl argv 
initlen used 	pushl argv push 
init initialized 	argv pushf 
zero 	run command argv 
bytes always 	pushl gethostname 
termined sds 	xsnprintf argv pushf 
always even 	getpid argv 
create sds 	pushf argv 
mystring sdsnewlen 	push start command 
abc 	index pack 
print end 	lockfile close finish 
however binary 	command reprepare 
safe contain 	packed git unpack 
characters middle 	memset start 
length stored 	unpack finish alloc 
sds 	assign shallow 
header empty 	commits refs xcalloc 
usually created 	xcalloc xcalloc 
order append 	setenv nonexistent shallow 
use type 	sha sha 
since type 	append prepare shallow 
good 	update alloc 
flags pointer 	assign shallow commits 
create empty 	refs sha 
zero length 	free packet 
sds even 	buf write packet 
always term 	buf write 
create 	packet buf write 
sds starting 	packet buf 
terminated duplicate 	flush send sideband 
sds free 	write die 
sds operation 	strbuf release sha 
performed sds 	packet trace 
length 	identity strcmp strcmp 
length obtained 	strcmp strcmp 
strlen considering 	usage usage usage 
content first 	setup path 
term character 	enter repo die 
function useful 	git config 
sds 	prepare push cert 
hacked manually 	nonce time 
way like 	write head info 
following example 	read head 
sdsnew foobar 	info prepare 
sdsupdatelen sdslen 	shallow info unpack 
output 	sideband update 
comment call 	shallow info execute 
sdsupdatelen output 	commands unlink 
modified logical 	warn report run 
length remains 	receive hook 
bytes modify 	run update post 
sds 	hook close 
place make 	packs run command 
empty zero 	opt update 
length however 	server info clear 
existing buffer 	shallow info 
discarded free 	packet flush sha 
space 	clear sha 
next append 	clear free advertise 
operations require 	refs outside 
allocations number 	current refs client 
bytes previously 	use minimize 
available enlarge 	data transfer 
free 	otherwise ignore happens 
space end 	cover thrown 
sds caller 	one alternate mark 
sure calling 	histories complete 
function overwrite 	alternates well eof 
addlen bytes 	rfc rfc 
end 	rfc rfc rfc 
plus one 	hmac sha 
nul term 	needswork reuse find 
note change 	commit header 
length sds 	commit author parsing 
returned sdslen 	dropping commit 
free 	name possibly moving 
buffer space 	commit returned 
asap enough 	nonce must match 
space left 	gave earlier 
use type 	stateless mode may 
user appending 	receiving nonce 
type 	issued another 
able remember 	instance server serving 
empty space 	repository timestamps 
sds make 	may match nonce 
room must 	seed dir 
called every 	match recompute report 
appending 	time slop 
operation since 	addition nonce issued 
header size 	another instance 
changes need 	timestamp within receive 
move forward 	certnonceslop seconds 
use realloc 	pretend issued nonce 
reallocate 	reporting hook 
sds free 	nonce concat seconds 
space end 	since epoch 
contained remains 	hmac would earlier 
altered next 	many seconds 
concatenation operations 	nonce stale 
require 	negative would mean 
reallocation call 	issued another 
passed sds 	server clock skewed 
longer valid 	future pretend 
references must 	received nonce passes 
substituted pointer 	hmac check 
returned 	forged third party 
call total 	issued beginning 
size allocation 	gpg sig error 
specifed sds 	running gpg 
including sds 	eof make sure 
header pointer 	setup alternate 
free 	shallow next lose 
buffer end 	roots needswork 
term pointer 	consolidate various implementions 
actual sds 	unborn branch 
allocation normally 	test one make 
sds referenced 	unified one 
start 	robust sha 
buffer increment 	check used elsewhere 
sds length 	would allow 
decrements left 	tell unborn branch 
free space 	corrupt example 
end according 	purpose fixing deploy 
incr 	update work 
also term 	pushing empty repository 
end function 	issue suffice 
used order 	run command clean 
fix length 	completely reinitialize 
user calls 	diff index either 
sds 	head empty 
make room 	refs allowed good 
writes something 	good end 
end current 	list returns one 
needs length 	update shallow 
note possible 	update shallow end 
use 	list end 
negative increment 	cert associated 
order right 	refs belong list 
trim usage 	aka step 
example sds 	done yet keep 
incr len 	hooks happy 
sds 	forcing temporary shallow 
make room 	file via 
possible mount 	env variable shallow 
following schema 	file every 
cat bytes 	command check everything 
coming kernel 	connected done 
end 	git shallow though 
sds without 	ref-filter.c position 
copying intermediate 	width name type 
buffer oldlen 	color align 
sdslen sds 	nlines used atom 
make room 	cnt need 
buffer 	tagged need symref 
size nread 	need color 
read oldlen 	reset eol 
buffer size 	atom color atom 
check nread 	arg atom 
handle sds 	arg atom arg 
incr 	atom arg 
len nread 	atom arg atom 
avoid compilation 	arg align 
warnings grow 	width position name 
sds specified 	cmp type 
length bytes 	atom arg prev 
part 	output stack 
original length 	end data quote 
sds zero 	style stack 
specified length 	align atomv state 
smaller current 	atom arg 
length operation 	len len str 
performed 	quote style 
make sure 	state stack stack 
added region 	current prev 
doesn contain 	stack align 
garbage also 	atomv state atomv 
trailing append 	state current 
specified 	format color sha 
binary safe 	obj eaten 
pointed len 	buf name sha 
bytes end 	atom val 
specified sds 	deref obj buf 
call passed 	name val 
sds 	deref obj buf 
longer valid 	tag name 
references must 	val deref obj 
substituted pointer 	buf commit 
returned call 	name parents parent 
append specified 	wholen buf 
termianted 	eol buf eol 
sds call 	buf buf 
passed sds 	email eoemail 
longer valid 	buf len buf 
references must 	atomname eoemail 
substituted pointer 	zone timestamp date 
returned 	mode formatp 
call append 	val deref obj 
specified sds 	buf wholen 
existing sds 	wholine name name 
call modified 	buf sub 
sds longer 	sublen body bodylen 
valid 	nonsiglen sig 
references must 	siglen eol buf 
substituted pointer 	size lines 
returned call 	eol len val 
destructively modify 	deref obj 
sds hold 	buf sigpos siglen 
specified 	atom name 
binary safe 	contents end val 
pointed length 	val deref 
len bytes 	obj buf 
like sdscpylen 	dst src refname 
must termined 	arg end 
length 	remaining start atom 
obtained strlen 	refname branch 
helper sdscatlonglong 	num num buf 
actual number 	obj eaten 
conversion must 	size tagged unused 
point room 	atom name 
least 	deref refname formatp 
sds llstr 	branch branch 
size bytes 	name branch name 
function returns 	buf head 
length terminated 	sha arg atom 
representation stored 	alloc commit 
generate 	parents want candidate 
representation method 	contains stack 
produces reversed 	entry commit parents 
compute length 	filter commit 
term reverse 	patterns refname 
identical sdsll 	pattern refname namelen 
str 	plen filter 
type generate 	refname points sha 
representation method 	refname tagged 
produces reversed 	sha obj refname 
compute length 	objectname flag 
term reverse 	filter refname prefix 
create 	kind refname 
sds much 	oid flag data 
faster sdscatprintf 	cbdata filter 
sdsempty lld 	commit kind item 
like sdscatprintf 	cbdata revs 
gets list 	old filter clear 
instead 	item item 
variadic start 	commit merged filter 
buffer speed 	type cbdata 
possible revert 	ret broken cmp 
heap allocation 	cmp type 
buffers two 	sorting cmp 
times 	sorting state info 
bigger every 	format quote 
time fail 	style buf state 
fit current 	atomv resetv 
buffer size 	color cstr name 
concat obtained 	sorting opt 
sds 	arg unset sorting 
append sds 	tail len 
obtained alike 	opt arg unset 
format specifier 	sha die 
call modified 	color parse die 
sds longer 	strcmp strcmp 
valid 	strcmp die die 
references must 	die strcmp 
substituted pointer 	strcmp strcmp skip 
returned call 	prefix strtoul 
example sdsnew 	die die 
sum sdscatprintf 	strcmp die strcmp 
often 	strcmp strcmp 
need create 	die list split 
scratch alike 	skip prefix 
format need 	parse align position 
use sdsempty 	die skip 
target sdscatprintf 	prefix strtoul die 
sdsempty 	strtoul parse 
format args 	align position die 
function similar 	die list 
sdscatprintf much 	clear die strlen 
faster rely 	memcmp size 
sprintf family 	strlen memchr memcmp 
functions 	size die 
implemented libc 	realloc xmemdupz memset 
often slow 	parser strcmp 
moreover directly 	strbuf addstr quote 
handling sds 	buf perl 
data concatenated 	quote buf 
provides 	python quote buf 
performance improvement 	tcl quote 
however function 	buf quote formatting 
handles incompatible 	strbuf addstr 
subset alike 	xcalloc strbuf init 
format specifiers 	strbuf addbuf 
sds 	strbuf release free 
bit integer 	strbuf utf 
bit integer 	align strbuf swap 
verbatim character 	strbuf release 
next format 	push stack element 
specifier process 	die end 
position 	quote formatting strbuf 
next write 	swap strbuf 
dest str 	release pop stack 
make sure 	element find 
always space 	next strchr error 
least handle 	parse filter 
generally 	atom skip 
unknown term 	prefix strcmp read 
part left 	sha file 
right composed 	parse buffer starts 
contiguous characters 	xstrdup find 
found cset 	unique abbrev xstrdup 
terminted 	sha hex 
call modified 	die strcmp strcmp 
sds longer 	xstrfmt grab 
valid references 	objectname strcmp strcmp 
must substituted 	strcmp xstrdup 
pointer returned 	oid hex strcmp 
call 	xstrdup oid 
example sdsnew 	hex strcmp commit 
hello world 	list count 
sdstrim output 	xstrfmt strcmp strbuf 
hello world 	addch strbuf 
turn 	addstr oid hex 
smaller equal 	strbuf detach 
containing substring 	strncmp strchr 
specified start 	strchrnul xmemdupz strncmp 
end indexes 	xmemdupz strchr 
start end 	strchr xmemdupz xmemdupz 
negative 	strstr strchr 
means last 	parse date format 
character penultimate 	strtoul strtol 
character forth 	xstrdup show date 
interval inclusive 	strlen strncmp 
start end 	strcmp strcmp starts 
characters 	find wholine 
part resulting 	copy line strcmp 
modified place 	copy name 
example sdsnew 	strcmp copy email 
hello world 	starts grab 
sdsrange ello 	date strcmp strcmp 
world 	find wholine 
apply tolower 	starts grab 
every character 	date strcmp copy 
sds apply 	line strchrnul 
toupper every 	parse signature strlen 
character sds 	strlen strchrnul 
compare 	strlen strbuf addstr 
two sds 	memchr strbuf 
memcmp positive 	strcmp strcmp starts 
negative exactly 	find subpos 
binary two 	copy subject xmemdupz 
share exactly 	xmemdupz xmemdupz 
prefix 	append lines strbuf 
one two 	detach xstrdup 
additional characters 	grab common values 
longer considered 	grab tag 
greater smaller 	values grab sub 
one split 	body contents 
separator 	grab person grab 
sep sds 	commit values 
returned count 	grab sub 
reference number 	body contents grab 
tokens returned 	person grab 
memory zero 	person die strtol 
length 	die die 
zero length 	shorten unambiguous stat 
separator returned 	tracking info 
note sep 	xstrfmt xstrfmt xstrfmt 
able split 	stat tracking 
multi character 	info xcalloc resolve 
separator 	refdup starts 
example sdssplit 	starts starts skip 
foo bar 	prefix branch 
two elements 	branch upstream fill 
foo bar 	remote details 
version function 	starts skip prefix 
binary 	branch branch 
safe requires 	push fill remote 
length arguments 	details starts 
sdssplit function 	strcmp copy 
zero terminated 	advance copy advance 
make sure 	xstrdup grab 
room 	objectname strcmp resolve 
next element 	strcmp starts 
one search 	strcmp strchr strcmp 
separator skip 	shorten unambiguous 
separator element 	skip prefix strip 
sure room 	components die 
tokens 	xstrfmt obj die 
free result 	sha hex 
returned sdssplitlen 	die sha hex 
nothing tokens 	grab values 
append sds 	free obj die 
escaped representation 	sha hex 
non 	die sha hex 
printable characters 	grab values 
tested isprint 	free populate fill 
turned escapes 	missing values 
form hex 	oidcmp commit 
number call 	list parse commit 
modified 	alloc grow 
sds longer 	contains test push 
valid references 	contains stack 
must substituted 	free contains test 
pointer returned 	contains tag 
call helper 	algo descendant skip 
function 	prefix skip 
sdssplitargs returns 	prefix skip prefix 
non zero 	skip prefix 
valid hex 	wildmatch strlen strlen 
digit helper 	strncmp wildmatch 
function sdssplitargs 	match name path 
converts 	match pattern 
hex digit 	sha lookup parse 
integer split 	die sha 
line arguments 	lookup flex alloc 
every argument 	str hashcpy 
following programming 	strcmp size 
language 	starts warning warning 
repl alike 	filter kind 
form foo 	filter pattern match 
bar newline 	match points 
supported xff 	lookup commit reference 
otherstuff number 	gently commit 
arguments 	contains item realloc 
stored argc 	free free 
sds returned 	free item free 
caller free 	xcalloc init 
resulting sds 	revisions pending pending 
sdsfreesplitres note 	prepare revision 
sdscatrepr 	walk die free 
able convert 	item clear 
back quoted 	commit marks clear 
format sdssplitargs 	commit marks 
able parse 	free die 
function returns 	fullref fullref fullref 
allocated 	fullref head 
tokens success 	merge filter atom 
even input 	atom versioncmp 
empty input 	strcmp strcmp cmp 
contains unbalanced 	sorting qsort 
quotes closed 	hex hex hex 
quotes 	strbuf addch 
followed non 	strbuf addch push 
space characters 	stack element 
foo bar 	find next strchr 
foo skip 	append atom 
blanks token 	parse filter atom 
quotes 	handler strlen 
single quotes 	append color parse 
closing quote 	die append 
must followed 	atom die fwrite 
space nothing 	pop stack 
unterminated quotes 	element putchar 
closing 	xcalloc parse filter 
quote must 	atom strlen 
followed space 	xcalloc skip prefix 
nothing unterminated 	skip prefix 
quotes token 	strlen parse filter 
vector even 	atom starts 
empty 	sha die lookup 
input something 	commit reference 
modify substituting 	gently opterror atom 
occurrences characters 	valid field 
specified corresponding 	atom listed possibly 
character instance 	prefixed denote 
sdsmapchars 	deref tag parse 
mystring effect 	given format 
turning hello 	sort specifiers make 
ell function 	list properties 
returns sds 	need extract objects 
pointer always 	item structure 
input 	hold values 
pointer since 	extracted indexed atom 
resize needed 	number index 
specified separator 	used sorting field 
also returns 	str used 
result sds 	parse format sort 
like 	specifiers deref 
sdsjoin joins 	atom already used 
sds wrappers 	elsewhere atom 
allocators used 	valid one atom 
sds note 	name colon 
sds actually 	strip everything specifies 
use 	format entry 
macros defined 	shouldn used checking 
sdsalloc order 	valid atom 
avoid pay 	table including deref 
overhead function 	prefix quote 
calls define 	formatting done stack 
wrappers 	single element 
programs sds 	otherwise quote 
linked want 	formatting done element 
touch sds 	entire output 
internals even 	strbuf end atom 
use different 	encountered perform 
allocator 	quote formatting stack 
run test 	element supporting 
times order 	atom nested perform 
hit first 	quote formatting 
two sds 	topmost supporting atom 
header types 	format find 
sds.h 	next occurrence atom 
flags buf 	start atom 
len alloc 	quoted per cent 
flags buf 	skip two 
len alloc 	otherwise singleton make 
flags buf 	sure format 
len 	well formed 
alloc flags 	parse used atoms 
buf len 	points points 
alloc flags 	closing given name 
buf flags 	read data 
flags newlen 	size data returning 
flags 	also borrowed 
inc flags 	representation eaten well 
newlen flags 	signal parse 
newlen flags 	buffer free buffer 
init initlen 	see grab 
init len 	values see grab 
len 	values see 
len fmt 	grab values end 
attribute fmt 	header got 
fmt cset 	atomname ends date 
start end 	date something 
len sep 	possible something format 
seplen 	parse filter 
count tokens 	atom wouldn 
count len 	allowed means format 
line argc 	specified use 
setlen argv 	see grab values 
argc sep 	point looking 
argv 	tag commit creator 
argc sep 	creatordate requested 
seplen addlen 	something special author 
incr size 	commit wanted 
ptr size 	skip past header 
ptr argc 	hit empty 
argv 	line skip empty 
sds type 	lines parse 
len sds 	signature first might 
hdr sds 	even subject 
hdr sds 	line subject first 
hdr sds 	non empty 
hdr 	line subject goes 
sds hdr 	first empty 
sds hdr 	line drop 
sds hdr 	trailing newline present 
sds hdr 	skip empty 
sds hdr 	lines lines greater 
sds 	append many 
hdr sds 	lines given buf 
hdr sds 	length size 
hdr sds 	given strbuf see 
type len 	grab values 
sds hdr 	size length message 
sds 	removing signature 
hdr sds 	want empty print 
hdr sds 	field requests 
hdr sds 	apply authordate tag 
type len 	val list 
sds hdr 	atom hold returned 
sds 	values extract 
hdr sds 	values atoms used 
hdr sds 	atom obj 
hdr sds 	buf deref 
hdr sds 	obj buf pointed 
hdr sds 	otherwise tag 
hdr 	refers grab values 
sds hdr 	val deref 
sds lib 	obj buf grab 
library copyright 	blob values 
salvatore sanfilippo 	val deref obj 
antirez gmail 	buf normal 
dot 	parse referred grab 
copyright oran 	needed fill 
agra copyright 	specials first local 
redis labs 	branches may 
inc rights 	upstream atom wants 
reserved redistribution 	know tagged 
use 	done tag see 
source binary 	use derefs 
forms without 	grab refers 
modification permitted 	needswork derefs tag 
provided following 	good deal 
conditions met 	chains trust consistent 
redistributions 	deref tag 
source code 	peels onion core 
must retain 	given atom 
copyright notice 	lazily gets calling 
list conditions 	populate mimicking 
following disclaimer 	real stack stack 
redistributions 	lives heap 
binary form 	avoiding stack overflows 
must reproduce 	recursion step 
copyright notice 	stack items points 
list conditions 	commits whose 
following disclaimer 	ancestors inspected test 
documentation 	whether candidate 
materials provided 	one parents contained 
distribution neither 	list recurse 
name redis 	find though 
names contributors 	inconclusive previously marked 
may used 	containing want 
endorse 	commit marked possibly 
promote products 	containing want 
derived software 	commit popped stack 
without specific 	parents item 
prior written 	marked therefore contains 
permission software 	test meaningful 
provided 	refname matches one 
copyright holders 	patterns otherwise 
contributors express 	pattern prefix refname 
implied warranties 	refs heads 
including limited 	master matches pattern 
implied warranties 	refs heads 
merchantability 	mas wildcard matches 
fitness particular 	refs heads 
purpose disclaimed 	mas format option 
shall copyright 	given need 
owner contributors 	skip prefix 
liable direct 	matching refs tags 
indirect 	branches refname 
incidental special 	matches one patterns 
exemplary consequential 	otherwise pattern 
damages including 	path prefix refname 
limited procurement 	refs heads 
substitute goods 	master matches pattern 
services 	refs heads 
loss use 	refs heads wildcard 
data profits 	matches refs 
business interruption 	heads refname matches 
however caused 	one patterns 
theory liability 	otherwise pattern always 
whether 	matches given 
contract strict 	sha refname check 
liability tort 	belongs sha 
including negligence 	given tag check 
otherwise arising 	given tag 
way use 	points one 
software 	sha given sha 
even advised 	given sha 
possibility damage 	needswork single level 
note sdshdr 	inderection obtained 
never used 	might want change 
access flags 	account multiple 
directly 	levels annotated tags 
however document 	pointing annotated 
layout type 	tags pointing commit 
sds lsb 	refs cached 
type msb 	might know refname 
length used 	peels without 
excluding 	need parse via 
header terminator 	parse peel 
lsb type 	might efficient alternative 
unused bits 	obtain pointee 
used excluding 	allocate space item 
header terminator 	copy objectname 
lsb 	flag call 
type unused 	back given filter 
bits used 	refs keep 
excluding header 	later processing obtain 
terminator lsb 	current kind 
type unused 	filter kind ignore 
bits 	unwanted refs 
used excluding 	merge filter applied 
header terminator 	refs pointing 
lsb type 	commits hence obtain 
unused bits 	commit oid 
sdsalloc sdsavail 	available discard non 
sdslen 	commits early 
nothing type 	actual filtering done 
total allocation 	later perform 
info low 	filtering contains option 
level functions 	open yet 
exposed user 	sort may 
api 	need refname job 
export allocator 	resulting list 
used sds 	may yet pruned 
program sds 	maxcount logic 
sometimes program 	free memory allocated 
sds linked 	item free 
may 	memory allocated api 
use different 	filtering refs 
allocators may 	type refs user 
want allocate 	requested iterate 
free things 	refs apply filters 
sds respectively 	per given 
free 	filter structure store 
allocate sds 	filtered refs 
lib library 	structure simple per 
copyright salvatore 	filtering common 
sanfilippo antirez 	cases need branches 
gmail dot 	remotes tags 
copyright 	iterate refs 
oran agra 	mix refs needed 
copyright redis 	iterate refs 
labs inc 	filter required refs 
rights reserved 	help filter 
redistribution use 	kind filters need 
source 	revision walking 
binary forms 	sorting option given 
without modification 	use refname 
permitted provided 	sort sort list 
following conditions 	ref-filter.h next 
met redistributions 	atom objectname flag 
source 	kind symref 
code must 	commit refname alloc 
retain copyright 	items revs 
notice list 	name patterns points 
conditions following 	commit merge 
disclaimer redistributions 	commit kind lines 
binary 	abbrev verbose 
form must 	filter filter 
reproduce copyright 	type atom format 
notice list 	sort info 
conditions following 	format quote style 
disclaimer documentation 	opt arg 
materials 	unset opt arg 
provided distribution 	unset quoting 
neither name 	styles index used 
redis names 	atom macros 
contributors may 	checking merged merged 
used endorse 	options api 
promote 	filtering refs type 
products derived 	refs user 
software without 	requested iterate refs 
specific prior 	apply filters 
written permission 	per given filter 
software provided 	structure store 
copyright 	filtered refs structure 
holders contributors 	clear memory 
express implied 	allocated parse 
warranties including 	format sort specifiers 
limited implied 	used verify 
warranties merchantability 	given format correct 
fitness 	parse used 
particular purpose 	atoms sort given 
disclaimed shall 	per sorting 
copyright owner 	provided print given 
contributors liable 	format quote 
direct indirect 	style callback function 
incidental 	parsing sort 
special exemplary 	option sort option 
consequential damages 	refname function 
including limited 	parse merged merged 
procurement substitute 	options filter 
goods services 	reflog-walk.c osha nsha 
loss 	email timestamp 
use data 	message alloc 
profits business 	osha nsha email 
interruption however 	timestamp message 
caused theory 	data item reflogs 
liability whether 	sha name 
contract 	name free refname 
strict liability 	timestamp commit 
tort including 	alloc commit lifo 
negligence otherwise 	pop result 
arising way 	commit lifo info 
use 	recno reflogs 
software even 	reflogs complete reflogs 
advised possibility 	last commit 
damage note 	reflog info info 
sdshdr never 	commit name 
used access 	timestamp recno item 
flags 	reflogs branch 
directly however 	commit reflog sha 
document layout 	sha info 
type sds 	commit commit 
lsb type 	info commit reflog 
msb length 	logobj reflog 
used 	reflog info dmode 
excluding header 	force date 
terminator lsb 	shorten commit reflog 
type unused 	info printed 
bits used 	reflog info commit 
excluding header 	reflog info 
terminator 	len reflog info 
lsb type 	commit reflog 
unused bits 	info reflog info 
used excluding 	oneline dmode 
header terminator 	force date commit 
lsb type 	reflog info 
unused 	selector alloc grow 
bits used 	hashcpy hashcpy 
excluding header 	xstrdup xstrdup xcalloc 
terminator lsb 	xstrdup reflog 
type unused 	ent resolve 
bits sdsalloc 	refdup reflog ent 
sdsavail 	free xstrfmt 
sdslen nothing 	reflog ent free 
type total 	xstrfmt reflog 
allocation info 	ent free memmove 
low level 	alloc grow 
functions exposed 	xcalloc strchr die 
user 	xstrdup strtoul 
api export 	approxidate list lookup 
allocator used 	free resolve 
sds program 	refdup die read 
sds sometimes 	complete reflog 
program sds 	dwim log strlen 
linked 	free free 
may use 	free read complete 
different allocators 	reflog list 
may want 	insert xcalloc reflog 
allocate free 	recno time 
things sds 	free free 
respectively 	commit info commit 
free allocate 	info parse 
flags buf 	xcalloc shorten unambiguous 
len alloc 	strbuf addf 
flags buf 	strbuf addstr show 
len alloc 	date strbuf 
flags 	addf strbuf addch 
buf len 	strlen strbuf 
alloc flags 	reflog selector strbuf 
buf len 	release strip 
alloc flags 	away trailing newline 
buf flags 	reflog-walk.h info 
flags 	info commit name 
newlen flags 	info commit 
inc flags 	info date mode 
newlen flags 	force date 
newlen flags 	reflog info 
init initlen 	reflog info reflog 
init 	info dmode 
len len 	force date shorten 
len fmt 	reflog.c reflog 
attribute fmt 	expire usage reflog 
fmt cset 	usage reflog 
start end 	exists usage reflog 
len 	expire reflog 
sep seplen 	expire unreachable revs 
count tokens 	stalefix expire 
count len 	total expire unreachable 
line argc 	recno mark 
setlen argv 	list mark limit 
argc 	cmd tip 
sep argv 	commit tips sha 
argc sep 	reflog alloc 
seplen addlen 	sha desc entry 
incr size 	complete size 
ptr size 	data commit 
ptr 	study found incomplete 
argc argv 	parent sha 
sds type 	commit pending expire 
len sds 	limit leftover 
hdr sds 	parent commit commit 
hdr sds 	sha osha 
hdr 	nsha email timestamp 
sds hdr 	message data 
sds hdr 	old refname oid 
sds hdr 	flags data 
sds hdr 	list tip commit 
sds hdr 	refname sha 
sds 	data elem data 
hdr sds 	elem oid 
hdr sds 	unused data next 
hdr sds 	expire total 
hdr sds 	expire unreachable pattern 
type len 	pattern len 
sds 	ent expire 
hdr sds 	pattern key pattern 
hdr sds 	len expire 
hdr sds 	slot ent slot 
hdr sds 	ent argc 
type len 	argv prefix status 
sds 	expiry flags 
hdr sds 	arg collected sha 
hdr sds 	osha nsha 
hdr sds 	email timestamp message 
hdr sds 	data argc 
hdr sds 	argv prefix status 
hdr 	flags arg 
sds hdr 	spec sha recno 
sds hdr 	argc argv 
sds lib 	prefix start arg 
library copyright 	reflog usage 
salvatore sanfilippo 	argc argv prefix 
antirez 	lookup read 
gmail dot 	sha file 
copyright oran 	init desc entry 
agra copyright 	sha file 
redis labs 	isdir complete free 
inc rights 	buffer memset 
reserved 	memset parse complete 
redistribution use 	free free 
source binary 	sha lookup commit 
forms without 	reference gently 
modification permitted 	commit complete pop 
provided following 	commit parse 
conditions 	commit commit list 
met redistributions 	insert commit 
source code 	list insert sha 
must retain 	lookup commit 
copyright notice 	reference gently mark 
list conditions 	reachable keep 
following 	entry keep entry 
disclaimer redistributions 	unreachable unreachable 
binary form 	lookup commit 
must reproduce 	reference gently commit 
copyright notice 	list insert 
list conditions 	strcmp lookup commit 
following 	reference gently 
disclaimer documentation 	commit list insert 
materials provided 	commit list 
distribution neither 	insert mark reachable 
name redis 	clear commit 
names contributors 	marks free commit 
may 	list clear 
used endorse 	commit marks flex 
promote products 	alloc str 
derived software 	hashcpy alloc grow 
without specific 	strncmp flex 
prior written 	alloc mem config 
permission 	error nonbool 
software provided 	parse expiry 
copyright holders 	date error parse 
contributors express 	config key 
implied warranties 	git config strcmp 
including limited 	parse expire 
implied 	cfg strcmp parse 
warranties merchantability 	expire cfg 
fitness particular 	git config find 
purpose disclaimed 	cfg ent 
shall copyright 	wildmatch strcmp time 
owner contributors 	git config 
liable 	memset strcmp strcmp 
direct indirect 	starts parse 
incidental special 	expiry date die 
exemplary consequential 	starts parse 
damages including 	expiry date die 
limited procurement 	strcmp strcmp 
substitute 	strcmp strcmp strcmp 
goods services 	strcmp usage 
loss use 	init revisions 
data profits 	mark reachable objects 
business interruption 	putchar memset 
however caused 	reflog reflog expiry 
theory 	param reflog 
liability whether 	expire free free 
contract strict 	dwim log 
liability tort 	strlen error reflog 
including negligence 	expiry param 
otherwise arising 	reflog expire memset 
way 	strcmp strcmp 
use software 	strcmp strcmp strcmp 
even advised 	strcmp usage 
possibility damage 	error strstr error 
note sdshdr 	dwim log 
never used 	error strtoul reflog 
access 	ent approxidate 
flags directly 	reflog ent reflog 
however document 	expire free 
layout type 	strcmp usage 
sds lsb 	usage check refname 
type msb 	format die 
length 	reflog exists strcmp 
used excluding 	usage cmd 
header terminator 	log reflog strcmp 
lsb type 	cmd log 
unused bits 	reflog strcmp cmd 
used excluding 	reflog expire 
header 	strcmp cmd reflog 
terminator lsb 	strcmp cmd 
type unused 	reflog exists cmd 
bits used 	log reflog 
excluding header 	needswork parse options 
terminator lsb 	early find 
type 	commits reachable marked 
unused bits 	seen make 
used excluding 	sure trees blobs 
header terminator 	contained complete 
lsb type 	mark commits 
unused bits 	also seen objects 
sdsalloc 	needed complete 
sdsavail sdslen 	commit missing mark 
nothing type 	commit incomplete 
total allocation 	make sure commits 
info low 	found necessary 
level functions 	objects mark found 
exposed 	commits complete 
user api 	iow seen clear 
export allocator 	flags objects 
used sds 	traversed come traversed 
program sds 	ancestry chain 
sometimes program 	commit reach seen 
sds 	commits known 
linked may 	complete made sure 
use different 	commits encountered 
allocators may 	traversal refer 
want allocate 	trees complete means 
free things 	know commits 
sds 	seen process complete 
respectively free 	free arrays 
allocate sds 	make sure everything 
lib library 	commit exists 
copyright salvatore 	walked objects reachable 
sanfilippo antirez 	refs cache 
gmail 	earlier commits reachable 
dot copyright 	commit must 
oran agra 	meet seen commits 
copyright redis 	mark seen 
labs inc 	well starting commits 
rights reserved 	mark list 
redistribution 	mark commits reachable 
use source 	stop traversal 
binary forms 	commits older expire 
without modification 	limit queue 
permitted provided 	back caller 
following conditions 	call restart traversal 
met 	longer expire 
redistributions source 	limit may may 
code must 	commit yet 
retain copyright 	look supplied sha 
notice list 	commit keep 
conditions following 	reachable current prune 
disclaimer 	dig root 
redistributions binary 	iff specified reflog 
form must 	entry expired 
reproduce copyright 	expiry timer slot 
notice list 	given explicitly 
conditions following 	nothing tweak unconfigured 
disclaimer 	make stash 
documentation materials 	never expire nothing 
provided distribution 	matched use 
neither name 	trust commits objects 
redis names 	reachable refs 
contributors may 	even older 
used 	repository cannot trust 
endorse promote 	reachable reflog 
products derived 	repository pruned older 
software without 	git main 
specific prior 	reflog command showing 
written permission 	refs-internal.h refname 
software 	newname extras skip 
provided copyright 	err buf 
holders contributors 	msg refname sha 
express implied 	old sha 
warranties including 	flags type msg 
limited implied 	refname updates 
warranties 	alloc refname old 
merchantability fitness 	sha sha 
particular purpose 	msg flags err 
disclaimed shall 	dirname extras 
copyright owner 	skip oldname newname 
contributors liable 	data structures 
direct 	functions use 
indirect incidental 	refs module code 
special exemplary 	outside refs 
consequential damages 	module use functions 
including limited 	defined refs 
procurement substitute 	include file flag 
goods 	passed sha 
services loss 	basic telling tolerate 
use data 	broken refs 
profits business 	reference deleted anyway 
interruption however 	used flag 
caused theory 	update flags loose 
liability 	pruned used 
whether contract 	flag update flags 
strict liability 	reference updated 
tort including 	sha used flag 
negligence otherwise 	update flags 
arising way 	old sha 
use 	used flag update 
software even 	flags lockfile 
advised possibility 	needs committed force 
damage note 	create reflog 
sdshdr never 	skip adding update 
used access 	flags iff 
flags 	refname minimally safe 
directly however 	safe means 
document layout 	deleting loose reference 
type sds 	name damage 
lsb type 	example causing file 
msb length 	reference deleted 
used 	function check reference 
excluding header 	name legal 
terminator lsb 	use check refname 
type unused 	format consider 
bits used 	refname starts refs 
excluding header 	safe components 
terminator 	might contain 
lsb type 	escape refs names 
unused bits 	start refs 
used excluding 	considered safe iff 
header terminator 	consist entirely 
lsb type 	upper characters like 
unused 	head merge 
bits used 	head config foo 
excluding header 	bar peeled 
terminator lsb 	successfully cannot peeled 
type unused 	named referred 
bits sdsalloc 	tag peel chain 
sdsavail 	exist cannot 
sdslen nothing 	peeled tag entry 
type total 	contains peeled 
allocation info 	symref entry cannot 
low level 	peeled broken 
functions exposed 	symbolic reference cannot 
user 	even resolved 
api export 	name peel 
allocator used 	named tag resolve 
sds program 	tag recursively 
sds sometimes 	non tag found 
program sds 	successful store 
linked 	result sha peel 
may use 	peeled tag 
different allocators 	valid peel non 
may want 	tag peel 
allocate free 	invalid respectively sha 
things sds 	unchanged reference 
respectively 	named refname could 
free allocate 	created without 
sds.h flags 	conflicting name existing 
buf len 	reference otherwise 
alloc flags 	negative write explanation 
buf len 	err extras 
alloc 	non list additional 
flags buf 	refnames refname 
len alloc 	allowed conflict 
flags buf 	skip non ignore 
len alloc 	potential conflicts 
flags buf 	refs skip scheduled 
flags 	deletion operation 
flags newlen 	behavior undefined name 
flags inc 	listed extras 
flags newlen 	skip two reference 
flags newlen 	names conflict 
flags init 	one exactly matches 
initlen 	leading components 
init len 	foo bar conflicts 
len len 	foo foo 
fmt attribute 	bar baz foo 
fmt fmt 	bar foo 
cset start 	barbados extras skip 
end 	must sorted 
len sep 	copy reflog message 
seplen count 	msg buf 
tokens count 	allocated sufficiently 
len line 	large cleaning whitespaces 
argc setlen 	especially convert 
argv 	space reflog file 
argc sep 	one line 
argv argc 	per entry information 
sep seplen 	needed single 
addlen incr 	update sha sha 
size ptr 	check old 
size 	locked flags old 
ptr argc 	old sha 
argv sds 	old sha ensure 
type len 	exist update 
sds hdr 	flags reference flags 
sds hdr 	old check 
sds 	reference previously one 
hdr sds 	old noderef 
hdr sds 	deleting ispruning 
hdr sds 	transaction states open 
hdr sds 	transaction valid 
hdr sds 	state accept updates 
hdr 	open transaction 
sds hdr 	committed closed closed 
sds hdr 	transaction longer 
sds hdr 	active operations free 
sds hdr 	used state 
sds type 	transaction either become 
len 	closed successfully 
sds hdr 	committing active transaction 
sds hdr 	failure building 
sds hdr 	transaction thus rendering 
sds hdr 	failed inactive 
sds type 	data structure holding 
len 	reference transaction 
sds hdr 	consist checks updates 
sds hdr 	multiple references 
sds hdr 	carried atomically 
sds hdr 	possible structure opaque 
sds hdr 	callers check 
sds 	entries extras within 
hdr sds 	specified directory 
hdr sds 	dirname reference directory 
hdr sds 	name including 
lib library 	trailing slash refs 
copyright salvatore 	heads foo 
sanfilippo 	ignore conflicting references 
antirez gmail 	found skip 
dot copyright 	conflicting reference name 
oran agra 	extras skip 
copyright redis 	must sorted lists 
labs inc 	reference names 
rights 	either one signifying 
reserved redistribution 	empty list 
use source 	refs refs refs.c 
binary forms 	refname disposition 
without modification 	refname flags 
permitted 	last disp refname 
provided following 	flags component 
conditions met 	len component count 
redistributions source 	refname buf 
code must 	result refname resolve 
retain copyright 	flags sha 
notice 	flags pattern data 
list conditions 	refname resolve 
following disclaimer 	flags sha flags 
redistributions binary 	refname sha 
form must 	refname sha refname 
reproduce copyright 	oid flags 
notice 	data filter refname 
list conditions 	refnames msg 
following disclaimer 	fmt refname oid 
documentation materials 	flags data 
provided distribution 	resolves junk msg 
neither name 	fmt refname 
redis 	data msg 
names contributors 	fmt refnames data 
may used 	data submodule 
endorse promote 	data data submodule 
products derived 	data data 
software without 	submodule data data 
specific 	buf ret 
prior written 	oid flag pattern 
permission software 	prefix data 
provided copyright 	real pattern filter 
holders contributors 	ret pattern 
express implied 	data name rev 
warranties 	parse rules 
including limited 	abbrev name full 
implied warranties 	name abbrev 
merchantability fitness 	name len len 
particular purpose 	buf ret 
disclaimed shall 	size str 
copyright 	len sha last 
owner contributors 	branch refs 
liable direct 	found fullref sha 
indirect incidental 	result flag 
special exemplary 	str len sha 
consequential damages 	log last 
including 	branch logs found 
limited procurement 	hash path 
substitute goods 	refname refname pseudoref 
services loss 	sha old 
use data 	sha err filename 
profits business 	buf ret 
interruption 	actual old sha 
however caused 	pseudoref old 
theory liability 	sha filename actual 
whether contract 	old sha 
strict liability 	refname old sha 
tort including 	flags transaction 
negligence 	err buf 
otherwise arising 	msg wasspace refname 
way use 	refname refname 
software even 	time cnt reccnt 
advised possibility 	sha found 
damage note 	osha nsha date 
sdshdr 	msg cutoff 
never used 	time cutoff cutoff 
access flags 	cnt osha 
directly however 	nsha email timestamp 
document layout 	message data 
type sds 	osha nsha email 
lsb 	timestamp message 
type msb 	data refname flags 
length used 	time cnt 
excluding header 	sha msg cutoff 
terminator lsb 	time cutoff 
type unused 	cutoff cnt err 
bits 	transaction transaction 
used excluding 	refname update 
header terminator 	transaction refname sha 
lsb type 	old sha 
unused bits 	flags msg err 
used excluding 	update transaction 
header 	refname sha flags 
terminator lsb 	msg err 
type unused 	transaction refname old 
bits used 	sha flags 
excluding header 	msg err transaction 
terminator lsb 	refname old 
type 	sha flags err 
unused bits 	update refname 
sdsalloc sdsavail 	strict scanf fmts 
sdslen nothing 	rules name 
type total 	total len offset 
allocation info 	rules fail 
low 	name len rule 
level functions 	refname hide 
exposed user 	refs section 
api export 	len refname refname 
allocator used 	full match 
sds program 	subject neg len 
sds 	dirname extras 
sometimes program 	skip pos extra 
sds linked 	refname oldname 
may use 	newname skip err 
different allocators 	ret memcmp 
may want 	strcmp check refname 
allocate 	component starts 
free things 	xmallocz strlen normalize 
sds respectively 	path copy 
free allocate 	strlen free isupper 
sds lib 	xstrdup resolve 
library copyright 	resolve read full 
salvatore 	resolve wildmatch 
sanfilippo antirez 	deref tag 
gmail dot 	noverify hashcpy resolve 
copyright oran 	strcmp list 
agra copyright 	fputc rawref rawref 
redis labs 	submodule submodule 
inc 	submodule strbuf addf 
rights reserved 	git read 
redistribution use 	full strbuf release 
source binary 	starts strbuf 
forms without 	addstr strbuf addstr 
modification permitted 	strbuf addstr 
provided 	glob specials strbuf 
following conditions 	complete strbuf 
met redistributions 	addch strbuf release 
source code 	glob starts 
must retain 	starts starts strlen 
copyright notice 	strcmp mkpath 
list 	interpret branch name 
conditions following 	strbuf detach 
disclaimer redistributions 	substitute branch 
binary form 	name mksnpath resolve 
must reproduce 	xstrdup strcmp 
copyright notice 	warning strchr warning 
list 	free substitute 
conditions following 	branch name mksnpath 
disclaimer documentation 	resolve reflog 
materials provided 	exists strcmp reflog 
distribution neither 	exists xstrdup 
name redis 	hashcpy free strcmp 
names 	starts isupper 
contributors may 	pseudoref syntax strbuf 
used endorse 	addf sha 
promote products 	hex git path 
derived software 	hold file 
without specific 	update strbuf addf 
prior 	strerror read 
written permission 	die hashcmp strbuf 
software provided 	addf rollback 
copyright holders 	file write 
contributors express 	full strbuf addf 
implied warranties 	rollback file 
including 	commit file strbuf 
limited implied 	release git 
warranties merchantability 	path sha hold 
fitness particular 	file update 
purpose disclaimed 	die errno read 
shall copyright 	die hashcmp 
owner 	warning rollback file 
contributors liable 	unlink rollback 
direct indirect 	file unlink type 
incidental special 	pseudoref transaction 
exemplary consequential 	begin transaction transaction 
damages including 	commit error 
limited 	transaction free strbuf 
procurement substitute 	release transaction 
goods services 	free strbuf release 
loss use 	isspace isspace 
data profits 	isspace starts 
business interruption 	starts starts strcmp 
however 	strcmp starts 
caused theory 	xstrdup sha hashcpy 
liability whether 	hashcmp warning 
contract strict 	show date date 
liability tort 	mode hashcpy 
including negligence 	hashcmp warning show 
otherwise 	date date 
arising way 	mode hashcpy hashcpy 
use software 	hashcpy hashcpy 
even advised 	xstrdup hashcpy sha 
possibility damage 	hashcpy memset 
note sdshdr 	reflog ent reverse 
never 	exit die 
used access 	reflog ent xcalloc 
flags directly 	free free 
however document 	free free flex 
layout type 	alloc str 
sds lsb 	alloc grow 
type 	die sha check 
msb length 	refname format 
used excluding 	strbuf addf update 
header terminator 	hashcpy hashcpy 
lsb type 	xstrdup sha die 
unused bits 	transaction update 
used 	sha die transaction 
excluding header 	update die 
terminator lsb 	transaction update strlen 
type unused 	xmalloc mult 
bits used 	snprintf xstrdup xstrdup 
excluding header 	sscanf strlen 
terminator 	mksnpath exists free 
lsb type 	xstrdup strcmp 
unused bits 	starts strlen strcmp 
used excluding 	strlen config 
header terminator 	error nonbool 
lsb type 	xstrdup strlen xcalloc 
unused 	list append 
bits sdsalloc 	starts strlen list 
sdsavail sdslen 	find insert 
nothing type 	index starts list 
total allocation 	list insert 
info low 	verify refname available 
level 	error list 
functions exposed 	clear strbuf release 
user api 	backend independent 
export allocator 	part reference module 
used sds 	handle various 
program sds 	characters refnames acceptable 
sometimes 	character refs 
program sds 	end component look 
linked may 	preceding reject 
use different 	refs look preceding 
allocators may 	reject refs 
want allocate 	bad character 
free 	ascii control characters 
things sds 	tab reject 
respectively free 	unless refname refspec 
allocate flags 	pattern read 
buf len 	one refname component 
alloc flags 	front refname 
buf 	length component found 
len alloc 	component legal 
flags buf 	legal something reasonable 
len alloc 	git refs 
flags buf 	like path component 
len alloc 	begins dots 
flags 	ascii control characters 
buf flags 	tab anywhere 
flags newlen 	anywhere unless refname 
flags inc 	refspec pattern 
flags newlen 	ends ends contains 
flags newlen 	portion refname 
flags 	contains refname 
init initlen 	contains refspec pattern 
init len 	unset pattern 
len len 	flag accept single 
fmt attribute 	asterisk one 
fmt fmt 	side refspec component 
cset 	zero length 
start end 	component starts refname 
len sep 	ends refname 
seplen count 	single character start 
tokens count 	path component 
len line 	skip next component 
argc 	refname ends 
setlen argv 	refname one component 
argc sep 	refname escape 
argv argc 	refs example refs 
sep seplen 	foo bar 
addlen incr 	safe refs foo 
size 	bar argument 
ptr size 	filter refs 
ptr argc 	append implied present 
argv sds 	need check 
type len 	none len substituted 
sds hdr 	returned later 
sds 	free ing passed 
hdr sds 	magic hand 
hdr sds 	form name branch 
hdr sds 	yet updated 
hdr sds 	sha still hold 
hdr sds 	values previous 
hdr 	record want first 
sds hdr 	entry pre 
sds hdr 	generate scanf formats 
sds hdr 	rev parse 
sds hdr 	rules generate format 
sds hdr 	suitable scanf 
sds 	rev parse 
type len 	rules rule interpolating 
sds hdr 	location rule 
sds hdr 	list terminated count 
sds hdr 	first strlen 
sds hdr 	strlen nul bail 
sds 	rules buffer 
type len 	scanf result refname 
sds hdr 	must fit 
sds hdr 	skip first rule 
sds hdr 	always match 
sds hdr 	strict mode matched 
sds 	one rules 
hdr sds 	must fail resolve 
hdr sds 	valid non 
hdr sds 	ambiguous check name 
hdr sds 	resolves valid 
lib library 	use rules prior 
copyright 	matched one 
salvatore sanfilippo 	skip matched 
antirez gmail 	rule name ambiguous 
dot copyright 	resolves previous 
oran agra 	rule valid read 
copyright redis 	returns success 
labs 	name non ambiguous 
inc rights 	previous rules 
reserved redistribution 	haven resolved valid 
use source 	needswork use 
binary forms 	parse config key 
without modification 	merged refname 
permitted 	namespaces used look 
provided following 	place dirname 
conditions met 	would inserted extras 
redistributions source 	entry position 
code must 	starts dirname remember 
retain copyright 	dirname includes 
notice 	trailing slash skip 
list conditions 	conflict refs.h 
following disclaimer 	refname resolve 
redistributions binary 	flags sha flags 
form must 	refname resolve 
reproduce copyright 	flags sha flags 
notice 	refname resolve 
list conditions 	flags sha flags 
following disclaimer 	refname sha 
documentation materials 	refname refname refname 
provided distribution 	sha path 
neither name 	refname sha abbrev 
redis 	name full 
names contributors 	name str len 
may used 	sha str 
endorse promote 	len sha data 
products derived 	data prefix 
software without 	data prefix data 
specific 	broken data 
prior written 	data data data 
permission software 	pattern data 
provided copyright 	pattern prefix 
holders contributors 	data submodule data 
express implied 	submodule data 
warranties 	submodule prefix data 
including limited 	submodule data 
implied warranties 	submodule data submodule 
merchantability fitness 	data data 
particular purpose 	data data pattern 
disclaimed shall 	msg fmt 
copyright 	refname msg fmt 
owner contributors 	refnames flags 
liable direct 	refname force create 
indirect incidental 	err refname 
special exemplary 	flags time cnt 
consequential damages 	sha msg 
including 	cutoff time cutoff 
limited procurement 	cutoff cnt 
substitute goods 	refname refname 
services loss 	old sha flags 
use data 	refnames refname 
profits business 	refname data refname 
interruption 	data refname 
however caused 	flags refname refname 
theory liability 	strict oldref 
whether contract 	newref logmsg refname 
strict liability 	target logmsg 
tort including 	err transaction refname 
negligence 	sha old 
otherwise arising 	sha flags msg 
way use 	err transaction 
software even 	refname sha flags 
advised possibility 	msg err 
damage note 	transaction refname old 
sdshdr 	sha flags 
never used 	msg err transaction 
access flags 	refname old 
directly however 	sha flags 
document layout 	err transaction err 
type sds 	transaction err 
lsb 	transaction update refname 
type msb 	sha flags 
length used 	prepare prune cleanup 
excluding header 	policy data 
terminator lsb 	strpbrk resolve reference 
type unused 	recursively following 
bits 	symbolic refererences store 
used excluding 	referred name 
header terminator 	sha name non 
lsb type 	symbolic reference 
unused bits 	ultimately pointed pointer 
used excluding 	either buffer 
header 	input reference cannot 
terminator lsb 	resolved behavior 
type unused 	depends resolve reading 
bits used 	flag resolve 
excluding header 	reading resolve 
terminator lsb 	reading clear sha 
type 	name last 
unused bits 	reference name chain 
sdsalloc sdsavail 	either non 
sdslen nothing 	symbolic reference undefined 
type total 	reference prelude 
allocation info 	writing name actually 
low 	created changed 
level functions 	resolve recurse flag 
exposed user 	passed resolves 
api export 	one level symbolic 
allocator used 	reference stored 
sds program 	sha symbolic reference 
sds 	always sha 
sometimes program 	reference symref refers 
sds linked 	directly flags 
may use 	non points combination 
different allocators 	ispacked reference 
may want 	found among 
allocate 	packed references issymref 
free things 	initial reference 
sds respectively 	symbolic reference bad 
free allocate 	name reference 
sds lib 	name ill formed 
library copyright 	see resolve 
salvatore 	allow bad name 
sanfilippo antirez 	isbroken malformed 
gmail dot 	bad name see 
copyright oran 	refs detail 
agra copyright 	flag properly formatted 
redis labs 	normalized reference 
inc 	maxdepth recursive symbolic 
rights reserved 	lookups needed 
redistribution use 	give resolve allow 
source binary 	bad name 
forms without 	allows resolving refs 
modification permitted 	even name 
provided 	invalid according 
following conditions 	git check format 
met redistributions 	name bad 
source code 	stored sha sha 
must retain 	two flags 
copyright 	isbroken bad name 
notice list 	even resolve 
conditions following 	allow bad name 
disclaimer redistributions 	names escape 
binary form 	refs directory consist 
must reproduce 	caps underscores 
copyright 	cannot resolved function 
notice list 	returns names 
conditions following 	caps underscores refers 
disclaimer documentation 	special refs 
materials provided 	head fetch head 
distribution neither 	friends live 
name 	outside refs 
redis names 	directory refname non 
contributors may 	symbolic reference 
used endorse 	refers tag tag 
promote products 	recursively dereferenced 
derived software 	non tag store 
without 	sha referred 
specific prior 	sha conditions met 
written permission 	non zero 
software provided 	symbolic references considered 
copyright holders 	unpeelable even 
contributors express 	ultimately resolve peelable 
implied 	tag resolve 
warranties including 	refname nested gitlink 
limited implied 	repository located 
warranties merchantability 	path resolution successful 
fitness particular 	sha name 
purpose disclaimed 	otherwise non zero 
shall 	iff abbrev 
copyright owner 	name possible 
contributors liable 	abbreviation full name 
direct indirect 	according rules 
incidental special 	defined rev parse 
exemplary consequential 	rules refs 
damages 	transaction represents collection 
including limited 	updates succeed 
procurement substitute 	fail together calling 
goods services 	sequence allocate 
loss use 	initialize transaction calling 
data profits 	transaction begin 
business 	list intended updates 
interruption however 	calling functions 
caused theory 	like transaction update 
liability whether 	transaction create 
contract strict 	call transaction commit 
liability tort 	execute transaction 
including 	succeeds updates taken 
negligence otherwise 	place transaction 
arising way 	cannot rolled 
use software 	back instead transaction 
even advised 	commit use 
possibility damage 	initial transaction commit 
note 	database known 
sdshdr never 	empty clone likely 
used access 	much faster 
flags directly 	time call transaction 
however document 	free discard 
layout type 	transaction free associated 
sds 	resources particular 
lsb type 	rolls back transaction 
msb length 	successfully committed 
used excluding 	error handling error 
header terminator 	transaction functions 
lsb type 	append message went 
unused 	wrong err 
bits used 	argument message mentions 
excluding header 	updated error 
terminator lsb 	occurred passed 
type unused 	die error message 
bits used 	appended err 
excluding 	without first clearing 
header terminator 	err err 
lsb type 	terminated caveats note 
unused bits 	locks taken 
used excluding 	refs read transaction 
header terminator 	commit called 
lsb 	transaction verify won 
type unused 	report verification 
bits sdsalloc 	failure commit attempted 
sdsavail sdslen 	bit values 
nothing type 	flags argument passed 
total allocation 	reference symbolic 
info 	reference reference packed 
low level 	reference reference 
functions exposed 	cannot resolved 
user api 	name dangling symbolic 
export allocator 	reference directly 
used sds 	indirectly corrupt reference 
program 	file reference 
sds sometimes 	exists name bad 
program sds 	symbolic reference 
linked may 	refers ill formatted 
use different 	reference name 
allocators may 	reference name well 
want 	formed see 
allocate free 	git check format 
things sds 	definition well 
respectively free 	formed names signature 
allocate sdsalloc.h 	callback function 
sds lib 	functions memory pointed 
library 	refname sha 
copyright salvatore 	arguments guaranteed valid 
sanfilippo antirez 	duration single 
gmail dot 	callback invocation 
copyright redis 	following functions invoke 
labs inc 	specified callback 
rights 	function reference indicated 
reserved redistribution 	function ever 
use source 	returns nonzero stop 
binary forms 	iteration please 
without modification 	note safe modify 
permitted provided 	references iteration 
following 	progress unless callback 
conditions met 	function invocation 
redistributions source 	modifies reference also 
code must 	returns nonzero 
retain copyright 	immediately stop iteration 
notice list 	used learn 
conditions 	broken symref flags 
following disclaimer 	controlling behaviour 
redistributions binary 	pack refs pack 
form must 	refs prune 
reproduce copyright 	prune loose 
notice list 	refs packing pack 
conditions 	refs pack 
following disclaimer 	refs tags already 
documentation materials 	packed refs 
provided distribution 	write packed refs 
neither name 	file current 
redis names 	repository flags combination 
contributors 	pack refs 
may used 	flags flags controlling 
endorse promote 	transaction update 
products derived 	transaction create etc 
software without 	noderef act 
specific prior 	directly instead dereferencing 
written 	symbolic references 
permission software 	flags reserved use 
provided copyright 	setup reflog 
holders contributors 	fill err failure 
express implied 	reads log 
warranties including 	time check 
limited 	particular reflog exists 
implied warranties 	specified reference 
merchantability fitness 	old sha non 
particular purpose 	verify current 
disclaimed shall 	reference old sha 
copyright owner 	deleting old 
contributors 	sha reference exists 
liable direct 	regardless old 
indirect incidental 	error old sha 
special exemplary 	sha flags 
consequential damages 	passed transaction specified 
including limited 	references problems 
procurement 	emit errors attempt 
substitute goods 	keep going 
services loss 	deletes done nothing 
use data 	transaction reflog 
profits business 	iterate reflog 
interruption however 	entries calls specified 
caused 	function reflog 
theory liability 	file returns nonzero 
whether contract 	returns iff 
strict liability 	refname correct format 
tort including 	refname according 
negligence otherwise 	rules described documentation 
arising 	git check 
way use 	format txt refname 
software even 	allow onelevel 
advised possibility 	flags accept one 
damage sds 	level reference 
allocator selection 	names refname refspec 
file 	pattern flags 
used order 	allow single wildcard 
change sds 	character refspec 
allocator compile 	leading repeated slashes 
time define 	accepted rename 
following defines 	success begin 
want 	reference transaction reference 
use also 	transaction must 
include alternate 	freed calling transaction 
allocator needed 	free reference 
needed order 	transaction updates following 
use libc 	four functions 
allocator 	reference check update 
sds lib 	transaction common 
library copyright 	similar parameters transaction 
salvatore sanfilippo 	pointer open 
antirez gmail 	transaction obtained transaction 
dot copyright 	begin refname 
redis 	name reference affected 
labs inc 	flags flags 
rights reserved 	affecting update passed 
redistribution use 	update noderef 
source binary 	means symbolic references 
forms without 	followed msg 
modification 	message describing 
permitted provided 	change reflog err 
following conditions 	strbuf receiving 
met redistributions 	description error might 
source code 	occured functions 
must retain 	make copies refname 
copyright 	msg caller 
notice list 	retains ownership parameters 
conditions following 	functions success 
disclaimer redistributions 	non zero failure 
binary form 	failure means 
must reproduce 	transaction whole failed 
copyright 	needs rolled 
notice list 	back reference update 
conditions following 	transaction sha 
disclaimer documentation 	reference update sha 
materials provided 	deleted sha 
distribution neither 	reference changed old 
name 	sha reference 
redis names 	must update 
contributors may 	sha must existed 
used endorse 	beforehand old 
promote products 	taken prevent races 
derived software 	old doesn 
without 	agree old sha 
specific prior 	whole transaction 
written permission 	fails old sha 
software provided 	previous see 
copyright holders 	comment reference transaction 
contributors express 	updates information 
implied 	reference creation transaction 
warranties including 	sha reference 
limited implied 	update must sha 
warranties merchantability 	verified reference 
fitness particular 	exist already see 
purpose disclaimed 	comment reference 
shall 	transaction updates information 
copyright owner 	reference deletion 
contributors liable 	transaction old 
direct indirect 	sha non holds 
incidental special 	reference update 
exemplary consequential 	must sha see 
damages 	comment reference 
including limited 	transaction updates information 
procurement substitute 	verify within 
goods services 	transaction refname old 
loss use 	sha old 
data profits 	sha sha verify 
business 	reference doesn 
interruption however 	exist old sha 
caused theory 	must non 
liability whether 	see comment reference 
contract strict 	transaction updates 
liability tort 	information commit changes 
including 	queued transaction 
negligence otherwise 	atomically possible 
arising way 	returns success one 
use software 	error codes 
even advised 	errors naming conflict 
possibility damage 	example names 
sds 	conflict errors like 
allocator selection 	transaction commit 
file used 	optimized creating references 
order change 	originally initializing 
sds allocator 	repository git clone 
compile time 	writes references 
define 	directly packed refs 
following defines 	without locking 
want use 	individual references bug 
also include 	call function 
alternate allocator 	might processes accessing 
needed needed 	repository existing 
order 	references might conflict 
use libc 	ones created 
allocator sds 	old sha 
lib library 	values must either 
copyright salvatore 	absent sha 
sanfilippo antirez 	free existing transaction 
gmail 	associated data 
dot copyright 	update unlock single 
redis labs 	reference function 
inc rights 	basically transaction containing 
reserved redistribution 	single call 
use source 	transaction update parameters 
binary 	function meaning 
forms without 	corresponding parameters transaction 
modification permitted 	update handle 
provided following 	errors requested onerr 
conditions met 	argument check 
redistributions source 	whether hidden first 
code 	second parameter 
must retain 	point full name 
copyright notice 	inside first 
list conditions 	parameter pointer 
following disclaimer 	name prefix removed 
redistributions binary 	outside first 
form 	parameter second parameter 
must reproduce 	always points 
copyright notice 	full name following 
list conditions 	used reflog 
following disclaimer 	expiration caller calls 
documentation materials 	reflog expire 
provided 	supplying three callback 
distribution neither 	functions following 
name redis 	types callback functions 
names contributors 	define expiration 
may used 	policy desired reflog 
endorse promote 	expiry prepare 
products 	called reference locked 
derived software 	reflog expiry 
without specific 	prune called entry 
prior written 	existing reflog 
permission software 	iff entry 
provided copyright 	pruned reflog expiry 
holders 	cleanup called 
contributors express 	reference unlocked expire 
implied warranties 	reflog entries 
including limited 	specified reference sha 
implied warranties 	old reference 
merchantability fitness 	flags combination constants 
particular 	expire reflog 
purpose disclaimed 	flags three function 
shall copyright 	pointers described 
owner contributors 	success zero refs 
liable direct 	regcomp.c preg 
indirect incidental 	pattern length syntax 
special 	bufp init 
exemplary consequential 	state fastmap dfa 
damages including 	pat len 
limited procurement 	cset preg 
substitute goods 	dfa dfa preg 
services loss 	preorder postorder 
use 	extra node extra 
data profits 	node err 
business interruption 	preg node extra 
however caused 	node extra 
theory liability 	node extra node 
whether contract 	dfa idx 
strict 	constraint dfa node 
liability tort 	constraint dfa 
including negligence 	dfa node root 
otherwise arising 	dfa input 
way use 	token syntax function 
software even 	regexp preg 
advised 	syntax err regexp 
possibility damage 	preg token 
sds allocator 	syntax nest err 
selection file 	regexp preg 
used order 	token syntax 
change sds 	nest err regexp 
allocator 	preg token 
compile time 	syntax nest err 
define following 	regexp preg 
defines want 	token syntax nest 
use also 	err dup 
include alternate 	elem regexp dfa 
allocator 	token syntax 
needed needed 	err regexp dfa 
order use 	token syntax 
libc allocator 	err elem regexp 
sds lib 	token token 
library copyright 	len dfa syntax 
salvatore 	accept hyphen 
sanfilippo antirez 	elem regexp token 
gmail dot 	sbcset mbcset 
copyright redis 	equiv alloc name 
labs inc 	trans sbcset 
rights reserved 	mbcset alloc 
redistribution 	name syntax sbcset 
use source 	name trans 
binary forms 	sbcset name syntax 
without modification 	dfa trans 
permitted provided 	name extra non 
following conditions 	match err 
met 	dfa left right 
redistributions source 	type dfa 
code must 	left right token 
retain copyright 	src dfa 
notice list 	node extra node 
conditions following 	extra node 
disclaimer 	attribute hidden attribute 
redistributions binary 	hidden wtmp 
form must 	tmp pattern length 
reproduce copyright 	bufp ret 
notice list 	syntax options syntax 
conditions following 	ret bufp 
disclaimer 	dfa fastmap 
documentation materials 	fastmap bufp init 
provided distribution 	state fastmap 
neither name 	dfa node cnt 
redis names 	icase node 
contributors may 	type state cset 
used 	table mbs 
endorse promote 	buf state preg 
products derived 	pattern cflags 
software without 	ret syntax errcode 
specific prior 	preg errbuf 
written permission 	errbuf size msg 
software 	msg size 
provided copyright 	utf map utf 
holders contributors 	map dfa 
express implied 	entry state preg 
warranties including 	dfa comp 
limited implied 	buf ret 
warranties 	fastmap preg pattern 
merchantability fitness 	length syntax 
particular purpose 	err dfa regexp 
disclaimed shall 	dfa pat 
copyright owner 	len table size 
contributors liable 	codeset name 
direct 	utf map inited 
indirect incidental 	wch dfa 
special exemplary 	preg dfa storage 
consequential damages 	next dfa 
including limited 	first err init 
procurement substitute 	nodes node 
goods 	idx type clexp 
services loss 	idx clexp 
use data 	node dest idx 
profits business 	err dfa 
interruption however 	node period preg 
caused theory 	dfa ret 
liability 	postorder preorder 
whether contract 	extra node dfa 
strict liability 	idx idx 
tort including 	extra node preg 
negligence otherwise 	err err 
arising way 	preg node dfa 
use 	body cls 
software even 	extra node dfa 
advised possibility 	extra node 
damage sds 	extra node dfa 
allocator selection 	idx err 
file used 	left right dfa 
order 	top node 
change sds 	top clone node 
allocator compile 	root node 
time define 	init constraint node 
following defines 	clone node 
want 	ret constraint dest 
use also 	clone dest 
include alternate 	err dfa 
allocator needed 	node constraint idx 
needed order 	dfa idx 
use libc 	constraint dup idx 
allocator 	dfa src 
sdsalloc.h sds 	idx ret elems 
lib library 	dfa node 
copyright salvatore 	idx incomplete err 
sanfilippo antirez 	eclosure elem 
gmail dot 	dfa node root 
copyright 	err eclosure 
redis labs 	ret incomplete eclosure 
inc rights 	elem edest 
reserved redistribution 	result input syntax 
use source 	token input 
binary forms 	syntax prev next 
without 	token input 
modification permitted 	syntax token len 
provided following 	regexp preg 
conditions met 	syntax err 
redistributions source 	dfa eor root 
code must 	current token 
retain 	regexp preg token 
copyright notice 	syntax nest 
list conditions 	err dfa branch 
following disclaimer 	regexp preg 
redistributions binary 	token syntax nest 
form must 	err exp 
reproduce 	dfa regexp preg 
copyright notice 	token syntax 
list conditions 	nest err dfa 
following disclaimer 	mbc remain 
documentation materials 	first last regexp 
provided distribution 	preg token 
neither 	syntax nest err 
name redis 	dfa cur 
names contributors 	nsub elem regexp 
may used 	dfa token 
endorse promote 	syntax err 
products derived 	old start end 
software 	start idx 
without specific 	start token start 
prior written 	token sbcset 
permission software 	mbcset range alloc 
provided copyright 	start elem 
holders contributors 	end elem start 
express 	end start 
implied warranties 	end cmp buf 
including limited 	start end 
implied warranties 	nranges sbcset mbcset 
merchantability fitness 	coll sym 
particular purpose 	alloc name name 
disclaimed 	len regexp 
shall copyright 	dfa token syntax 
owner contributors 	err collseqmb 
liable direct 	collseqwc nrules 
indirect incidental 	table size symb 
special exemplary 	table extra 
consequential 	name name len 
damages including 	hash elem 
limited procurement 	second elem sym 
substitute goods 	name len 
services loss 	elem idx mbcset 
use data 	range alloc 
profits 	sbcset start elem 
business interruption 	end elem 
however caused 	start collseq end 
theory liability 	collseq start 
whether contract 	end nranges collseq 
strict liability 	mbcset coll 
tort 	sym alloc sbcset 
including negligence 	name elem 
otherwise arising 	idx name len 
way use 	coll sym 
software even 	alloc coll 
advised possibility 	syms token sbcset 
damage 	mbcset mbchar 
sds allocator 	alloc alloc non 
selection file 	match work 
used order 	token len first 
change sds 	round start 
allocator compile 	elem end elem 
time 	start name 
define following 	buf end name 
defines want 	buf ret 
use also 	range exp token 
include alternate 	mbchars mbc 
allocator needed 	sbc idx elem 
needed 	regexp token 
order use 	token len dfa 
libc allocator 	syntax accept 
sds lib 	hyphen cur size 
library copyright 	token elem 
salvatore sanfilippo 	regexp token 
antirez 	delim sbcset mbcset 
gmail dot 	equiv alloc 
copyright redis 	name nrules table 
labs inc 	indirect weights 
rights reserved 	extra buf idx 
redistribution use 	idx len 
source 	cnt equiv alloc 
binary forms 	equiv classes 
without modification 	trans sbcset mbcset 
permitted provided 	alloc name 
following conditions 	syntax alloc classes 
met redistributions 	dfa trans 
source 	name extra non 
code must 	match err 
retain copyright 	sbcset mbcset alloc 
notice list 	ret token 
conditions following 	mbc input token 
disclaimer redistributions 	syntax num 
binary 	cset dfa 
form must 	left right type 
reproduce copyright 	dfa left 
notice list 	right token storage 
conditions following 	extra node 
disclaimer documentation 	idx node extra 
materials 	node root 
provided distribution 	dfa node dup 
neither name 	root dup 
redis names 	node prev mbtowc 
contributors may 	compile gettext 
used endorse 	memset compile fastmap 
promote 	iter compile 
products derived 	fastmap iter compile 
software without 	fastmap iter 
specific prior 	compile fastmap iter 
written permission 	fastmap memset 
software provided 	mbrtowc wcrtomb 
copyright 	towlower fastmap free 
holders contributors 	fastmap current 
express implied 	word current fastmap 
warranties including 	memset mbrtowc 
limited implied 	fastmap memset wcrtomb 
warranties merchantability 	fastmap wcrtomb 
fitness 	towlower fastmap memset 
particular purpose 	malloc compile 
disclaimed shall 	strlen compile fastmap 
copyright owner 	free abort 
contributors liable 	gettext strlen memcpy 
direct indirect 	memcpy free 
incidental 	token free node 
special exemplary 	free node 
consequential damages 	free node free 
including limited 	free free 
procurement substitute 	free free free 
goods services 	state free 
loss 	free free 
use data 	free free free 
profits business 	free dfa 
interruption however 	content free free 
caused theory 	gettext regfree 
liability whether 	memset malloc gettext 
contract 	compile strlen 
strict liability 	gettext regfree realloc 
tort including 	init dfa 
negligence otherwise 	free dfa content 
arising way 	malloc strncpy 
use software 	libc init construct 
even 	free workarea 
advised possibility 	compile destruct free 
damage sds 	dfa content 
allocator selection 	parse analyze optimize 
file used 	utf create 
order change 	initial state free 
sds 	workarea compile 
allocator compile 	destruct free 
time define 	dfa content memset 
following defines 	malloc calloc 
want use 	strcmp current current 
also include 	word langinfo 
alternate 	getenv getenv getenv 
allocator needed 	strchr strchr 
needed order 	calloc btowc isascii 
use libc 	isalnum free 
allocator sds 	free node init 
lib library 	copy node 
copyright 	contains node merge 
salvatore sanfilippo 	acquire state 
antirez gmail 	context acquire state 
dot copyright 	context acquire 
redis labs 	state context acquire 
inc rights 	state context 
reserved 	node free abort 
redistribution use 	malloc malloc 
source binary 	malloc malloc 
forms without 	malloc preorder free 
modification permitted 	postorder postorder 
provided following 	preorder preorder calc 
conditions 	eclosure malloc 
met redistributions 	calc inveclosure lower 
source code 	subexp lower 
must retain 	subexp create create 
copyright notice 	create create 
list conditions 	dfa node node 
following 	init node 
disclaimer redistributions 	init node init 
binary form 	epsilon node 
must reproduce 	node empty duplicate 
copyright notice 	node node 
list conditions 	insert node empty 
following 	node insert 
disclaimer documentation 	duplicate node 
materials provided 	node insert node 
distribution neither 	empty search 
name redis 	duplicated node duplicate 
names contributors 	node node 
may 	insert duplicate node 
used endorse 	closure node 
promote products 	insert duplicate node 
derived software 	node insert 
without specific 	dfa node node 
prior written 	init empty 
permission 	node insert last 
software provided 	calc eclosure 
copyright holders 	iter node free 
contributors express 	node alloc 
implied warranties 	duplicate node closure 
including limited 	epsilon node 
implied 	calc eclosure iter 
warranties merchantability 	node merge 
fitness particular 	node free 
purpose disclaimed 	node insert skip 
shall copyright 	bytes peek 
owner contributors 	token eoi peek 
liable 	first cur 
direct indirect 	idx cur idx 
incidental special 	length peek 
exemplary consequential 	wchar cur idx 
damages including 	wide word 
limited procurement 	word wchar cur 
substitute 	idx wide 
goods services 	word word cur 
loss use 	idx peek 
data profits 	cur idx length 
business interruption 	skip bytes 
however caused 	peek token skip 
theory 	bytes eoi 
liability whether 	peek first cur 
contract strict 	idx cur 
liability tort 	idx length 
including negligence 	skip bytes peek 
otherwise arising 	cur idx 
way 	length peek fetch 
use software 	token parse 
even advised 	reg exp create 
possibility damage 	create parse 
sds allocator 	branch fetch token 
selection file 	parse branch 
used 	create parse expression 
order change 	parse expression 
sds allocator 	create create token 
compile time 	eoi first 
define following 	cur idx fetch 
defines want 	token create 
use 	token create parse 
also include 	sub exp 
alternate allocator 	parse bracket exp 
needed needed 	create token 
order use 	fetch token 
libc allocator 	parse expression create 
sds 	token init 
lib library 	word create token 
copyright salvatore 	create token 
sanfilippo antirez 	create token create 
gmail dot 	create token 
copyright redis 	fetch token create 
labs 	token build 
inc rights 	charclass build charclass 
reserved redistribution 	fetch token 
use source 	parse dup fetch 
binary forms 	token parse 
without modification 	reg exp create 
permitted 	cur idx 
provided following 	memcpy fetch number 
conditions met 	fetch number 
redistributions source 	index fetch token 
code must 	postorder duplicate 
retain copyright 	create duplicate 
notice 	postorder create duplicate 
list conditions 	create create 
following disclaimer 	create strlen strlen 
redistributions binary 	btowc btowc 
form must 	wcscoll realloc realloc 
reproduce copyright 	wcscoll wcscoll 
notice 	bitset bitset strlen 
list conditions 	bitset elem 
following disclaimer 	hash memcmp btowc 
documentation materials 	collseq table 
provided distribution 	lookup collseq table 
neither name 	lookup strlen 
redis 	seek collating symbol 
names contributors 	entry lookup 
may used 	collation sequence lookup 
endorse promote 	collation sequence 
products derived 	realloc realloc 
software without 	collseq table lookup 
specific 	btowc bitset 
prior written 	strlen seek collating 
permission software 	symbol entry 
provided copyright 	bitset realloc bitset 
holders contributors 	current current 
express implied 	word current current 
warranties 	word current 
including limited 	current calloc calloc 
implied warranties 	peek token 
merchantability fitness 	bracket bitset skip 
particular purpose 	bytes peek 
disclaimed shall 	token bracket parse 
copyright 	bracket element 
owner contributors 	peek token bracket 
liable direct 	skip bytes 
indirect incidental 	peek token bracket 
special exemplary 	skip bytes 
consequential damages 	parse bracket 
including 	element peek token 
limited procurement 	bracket build 
substitute goods 	range exp build 
services loss 	range exp 
use data 	build range exp 
profits business 	bitset realloc 
interruption 	build equiv build 
however caused 	collating symbol 
theory liability 	build charclass skip 
whether contract 	bytes bitset 
strict liability 	bitset mask create 
tort including 	token create 
negligence 	token create free 
otherwise arising 	free charset 
way use 	create token free 
software even 	free charset 
advised possibility 	size cur idx 
damage sds 	wchar cur 
allocator 	idx skip 
selection file 	bytes skip bytes 
used order 	parse bracket 
change sds 	symbol peek token 
allocator compile 	bracket eoi 
time define 	fetch fetch eoi 
following 	peek skip 
defines want 	bytes current word 
use also 	current current 
include alternate 	current current findidx 
allocator needed 	strlen findidx 
needed order 	bitset realloc strlen 
use 	bitset strcmp 
libc allocator 	strcmp realloc wctype 
sentinel.c environ 	strcmp build 
myid current 	charclass loop strcmp 
epoch masters 	build charclass 
tilt running 	loop strcmp build 
scripts 	charclass loop 
tilt start 	strcmp build 
time previous 	charclass loop strcmp 
time scripts 	build charclass 
queue announce 	loop strcmp build 
announce port 	charclass loop 
simfailure 	strcmp build charclass 
flags privdata 	loop strcmp 
mask privdata 	build charclass loop 
mask privdata 	strcmp build 
loop privdata 	charclass loop build 
loop privdata 	charclass loop 
loop 	calloc calloc build 
privdata loop 	charclass free 
privdata loop 	free charset bitset 
status status 	bitset bitset 
reply privdata 	mask create token 
name master 	create token 
master 	create free 
level type 	charset free free 
fmt master 	charset fetch 
path master 	token free free 
reply privdata 	free free 
host port 	free free free 
master 	create token 
req epoch 	malloc free charset 
req runid 	free free 
leader epoch 	token create token 
master instances 	extended regular 
port runid 	expression matching search 
key 	library copyright 
privdata key 	free software foundation 
key privdata 	inc file 
obj instances 	part gnu library 
dict type 	contributed isamu 
leader votes 	hasegawa isamu yamato 
dict 	ibm gnu 
type sentinelcmds 	library free 
retval cmd 	software redistribute modify 
hostname port 	terms gnu 
src level 	lesser general license 
type fmt 	published free 
msg 	software foundation either 
channel payload 	version license 
master master 	option later version 
path argv 	gnu library 
argc pid 	distributed hope useful 
pid retry 	without warranty 
num 	without even implied 
delay statloc 	warranty merchantability 
pid exitcode 	fitness particular purpose 
bysignal delay 	see gnu 
master role 	lesser general license 
state fromport 	details received 
toport 	copy gnu lesser 
link link 	general license 
link callbacks 	along gnu 
match reconfigured 	library write free 
match link 	software foundation 
pubsub status 	inc franklin street 
status 	fifth floor 
name flags 	boston usa enable 
hostname port 	enable enable 
quorum master 	table gives error 
addr table 	message error 
slavename sdsname 	codes listed regex 
port 	obviously order 
key slave 	posix doesn require 
buf master 	anything reg 
runid removed 	noerror nice reg 
instances port 	noerror reg 
runid instance 	nomatch reg badpat 
name 	reg ecollate 
sdsname instances 	reg ectype reg 
flags instances 	eescape reg 
flags flags 	esubreg reg 
pattern flags 	ebrack reg eparen 
reset 	reg ebrace 
master port 	reg badbr reg 
oldaddr newaddr 	erange reg 
slaves slave 	espace reg badrpt 
slave recent 	reg eend 
master master 	reg esize reg 
argv 	erparen entry 
argc quorum 	points gnu code 
current epoch 	zos uss 
slave state 	must define btowc 
line master 	compile pattern 
master addr 	gnu regular expression 
slave 	compiler compiles 
addr saved 	pattern length length 
rewrite status 	puts result 
auth pass 	bufp returns 
type name 	pattern valid otherwise 
link retval 	error assumes 
master 	allocated perhaps buffer 
info lines 	translate fields 
numlines role 	bufp entry gnu 
slave port 	code determines 
end slave 	whether information passing 
master port 	regs argument 
wait 	match etc setting 
time retval 	sub unless 
wait time 	sub match anchors 
retval reply 	newline syntax 
privdata link 	current regexp syntax 
reply privdata 	recognize also 
link 	assigned arbitrarily pattern 
reply privdata 	buffer stores 
link reply 	syntax changed regex 
privdata link 	compilations initializer 
hello hello 	initialized variables 
len numtokens 	emacs become read 
port 	dumping specify 
removed master 	precise syntax regexps 
port current 	compilation provides 
epoch master 	compatibility various utilities 
config epoch 	historically different 
token master 	incompatible syntaxes argument 
old 	syntax bit 
addr reply 	mask comprised various 
privdata payload 	bits defined 
retval announce 	regex old syntax 
announce port 	helper function 
master master 	compile fastmap compile 
addr 	fastmap initial 
instances master 	state init state 
retval info 	see bytes 
period ping 	start multiple collation 
period retval 	elements want 
state flags 	since valid 
mbl 	collation element since 
fields instances 	collation element 
name master 	starts caught simple 
usableptr usable 	bracket libc 
result voters 	see start match 
req epoch 	multibyte characters 
leader 	would find invalid 
epoch leader 	sequence applies 
port isdown 	multibyte character sets 
addr quorum 	single character 
port usable 	sets simple bracket 
result copy 	suffices libc 
keeper 	bytes start mbchars 
masters local 	enable enable 
sdi sde 	entry point posix 
sri allsections 	code regcomp 
section sections 	takes regular expression 
info master 	compiles preg 
status 	regex expect 
changes option 	fields initialized since 
elapsed master 	posix says 
odown reply 	shouldn thus buffer 
privdata link 	compiled pattern 
master flags 	used length compiled 
elapsed 	pattern syntax 
port retval 	syntax posix extended 
master req 	reg extended 
epoch req 	bit cflags otherwise 
runid leader 	syntax posix 
epoch runid 	basic newline anchor 
votes 	reg newline 
counters runid 	cflags fastmap allocated 
oldval master 	space fastmap 
epoch counters 	fastmap accurate zero 
voters quorum 	nsub number 
myvote winner 	subexpressions pattern pattern 
leader 	address pattern 
epoch max 	cflags series 
votes votes 	bits affect compilation 
votes host 	reg extended 
port portstr 	use posix extended 
retval master 	syntax otherwise 
master 	use posix basic 
clock ctimebuf 	syntax reg 
runid runid 	newline match newline 
master instance 	also regexec 
selected instances 	match beginning every 
max master 	newline reg 
time 	icase considers upper 
slave info 	lowercase versions 
validity time 	letters equivalent matching 
leader isleader 	reg nosub 
election timeout 	preg passed regexec 
slave retval 	routine report 
master 	success failure 
timeout elapsed 	nothing registers returns 
slave slave 	succeeds nonzero 
retval master 	doesn see regex 
progress slave 	codes meanings 
slave retval 	allocate space fastmap 
master 	reg newline 
instances promoted 	newlines treated differently 
delta redis 	reg newline 
handle read 	implies neither match 
redis handle 	newline also 
write create 	changes matching behavior 
file 	posix doesn 
file create 	distinguish unmatched open 
file file 	unmatched close 
redis del 	reg eparen already 
read redis 	preg fastmap 
del write 	compute fastmap since 
zfree 	regexec cannot 
zmalloc unused 	modify pattern 
release sentinel 	buffer function never 
redis instance 	fails implementation 
dict empty 	error occurred compiling 
dict sdsnew 	expression returns 
server 	message corresponding error 
dict create 	code errcode 
mstime list 	returned either regcomp 
create memset 	regexec use 
server log 	preg error codes 
exit access 	returned rest 
server 	code passed routine 
log strerror 	given anything 
exit random 	regex code generates 
hex chars 	invalid error 
sentinel flush 	code program bug 
config server 	dump core 
log 	fix includes used 
sentinel generate 	map single 
initial monitor 	characters utf 
events anet 	used otherwise would 
resolve zmalloc 	allocate memory 
sdsnew zmalloc 	initialize time utf 
sdsnew 	preferred encoding 
sdsfree zfree 	worthwhile optimization first 
strcasecmp snprintf 	bits gnuc 
sentinel redis 	gnuc enable free 
instance type 	dynamically allocated 
str snprintf 	space used preg 
sentinel 	entry points 
redis instance 	compatible bsd regex 
type str 	library define 
start vsnprintf 	unless specifically requested 
strlen strlen 	bsd one 
end server 	one pattern buffer 
log 	make definitions 
create strlen 	weak libc posix 
create strlen 	programs redefine 
pubsub publish 	names use 
message decr 	functions still use 
count decr 	regcomp regexec 
count 	without link errors 
sentinel schedule 	since exec 
script execution 	always passes regs 
dict iterator 	argument need 
dict next 	initialize pattern buffer 
dict val 	fields affect 
sentinel 	match anchors newlines 
dict release 	yes discarding 
iterator sdsfree 	libintl regex comp 
zfree zfree 	entry point 
start arg 	compile regular expression 
sdsnew end 	pattern whose 
sdsnew 	length length syntax 
zmalloc zmalloc 	indicate regular 
memcpy list 	expression syntax 
node tail 	initialize pattern buffer 
list length 	initialize dfa 
list rewind 	zero allocated buffer 
list 	non realloc 
next list 	enough space loses 
del node 	buffer address 
sentinel release 	bogus user responsibility 
script job 	buffer simple 
server list 	allocation note length 
length 	overflow since 
list rewind 	init dfa parse 
list next 	regular expression 
mstime list 	build structure analyze 
rewind list 	create nfa 
next mstime 	possible searching single 
fork 	encoding speed 
sentinel execve 	things create initial 
exit sentinel 	state dfa 
wait wexitstatus 	release work 
wifsignaled wtermsig 	areas initialize dfa 
sentinel sentinel 	use length 
script 	regular expression pat 
list node 	len initial 
pid server 	length arrays force 
log mstime 	allocation str 
sentinel script 	storage first time 
retry delay 	avoid overflows 
sentinel 	table size ceil 
list del 	log pat 
node sentinel 	len strcasecmp isn 
release script 	standard brute 
job mstime 	force check check 
list rewind 	exhaustively loop 
list 	charset superset ascii 
next sentinel 	bits corresponding 
kill reply 	single chars initialize 
multi bulk 	word table 
len list 	indicate character 
length list 	word word means 
rewind 	word construction 
list next 	character used operators 
reply multi 	like etc 
bulk len 	free work area 
reply bulk 	used compiling 
reply multi 	create initial states 
bulk 	contexts initial 
len reply 	states epsilon closure 
bulk reply 	node first 
bulk reply 	node regular expression 
bulk reply 	back references 
bulk reply 	initial states epsilon 
bulk 	transit since 
reply bulk 	subexpressions epsilon closures 
reply bulk 	nodes next 
mstime mstime 	nodes back references 
reply bulk 	must first 
reply bulk 	time invoke 
reply 	acquire state check 
bulk reply 	err since 
bulk sentinel 	initial state must 
schedule script 	possible searching 
execution zmalloc 	single encoding instead 
mstime mstime 	utf speed 
mstime 	things dfa cur 
redis free 	max clear 
server instance 	utf change dfa 
link close 	nodes needed 
connection instance 	word anchors etc 
link close 	cannot handled 
connection 	okay test opr 
zfree server 	ctx type 
dict iterator 	since constraints dfa 
dict next 	nodes created 
dict val 	ring one 
sentinel redis 	opr ctx type 
instance 	values check 
addr run 	non ascii range 
release instance 	starts search 
link dict 	single locale analyze 
release iterator 	structure calculate 
server dict 	first next edest 
iterator 	eclosure inveclosure 
dict next 	allocate arrays need 
dict val 	prune impossible 
sentinel redis 	nodes pass regexec 
instance addr 	skip run 
run instance 	calc inveclosure quadratic 
link 	parse trees 
close connection 	unbalanced cannot use 
instance link 	stack implement 
close connection 	parse visits instead 
release sentinel 	use parent 
addr dup 	pointers hairy 
sentinel 	code two functions 
addr dict 	descend preferably 
release iterator 	left right child 
sentinel instance 	node reached 
link connection 	right left node 
error unused 	right optimization 
instance 	pass subexp entirely 
link connection 	contained strip 
error server 	tell search map 
server create 	inner one 
sentinel addr 	opr idx one 
anet format 	adjust backreferences 
addr 	well requires preorder 
sdsnew dict 	visit lowering 
find release 	pass turn subexp 
sentinel addr 	node appropriate 
sdsfree zmalloc 	concatenation open subexp 
create instance 	body subexp 
link 	close subexp 
mstime mstime 	optimize empty subexpressions 
mstime dict 	otherwise may 
create dict 	bad concat nodes 
create mstime 	children obviously 
mstime dict 	common lose much 
dict 	example triggers 
release dict 	sed script convert 
release release 	subexp node 
instance link 	concatenation open subexp 
sdsfree sdsfree 	contents close 
sdsfree sdsfree 	subexp pass building 
sdsfree 	nfa compute 
sdsfree sdsfree 	first create unlinked 
sdsfree release 	automaton nodes 
sentinel addr 	requires postorder visit 
zfree server 	pass compute 
anet format 	next preorder visit 
addr 	pass link 
sdsnew dict 	dfa nodes 
fetch sdsfree 	next node order 
dict safe 	duplicate epsilon 
iterator dict 	closure node root 
next dict 	node note 
val 	duplicated nodes constraint 
strcmp dict 	init constraint 
dict release 	addition constraint back 
iterator server 	reference epsilon 
dict iterator 	transit destination must 
dict next 	also constraint 
dict 	duplicate epsilon closure 
val strcmp 	destination back 
strcmp dict 	reference store edests 
release iterator 	back reference 
sdsnew dict 	node epsilon transit 
fetch sdsfree 	duplicate destination 
dict 	store original destination 
iterator dict 	destination node 
next dict 	node epsilon 
val dict 	transit one destination 
release iterator 	node root 
dict iterator 	node means epsilon 
dict 	clsoure loop 
next dict 	tie destination root 
val dict 	node node 
release iterator 	another constraint dfa 
server dict 	edests node 
release dict 	nelem node epsilon 
create 	transit two 
dict release 	destinations bin dfa 
dict create 	search duplicated 
instance link 	node satisfies constraint 
close connection 	duplicated node 
instance link 	create one duplicated 
close 	node satisfies 
connection sdsfree 	constraint use 
sdsfree sdsfree 	avoid infinite loop 
mstime mstime 	search node 
mstime mstime 	duplicated node node 
sentinel dict 	satisfies constraint 
iterator 	constraint found found 
dict next 	duplicate node 
dict val 	whose index idx 
stringmatch sentinel 	constraint constraint 
reset master 	index node insufficient 
dict release 	storage available 
iterator 	store index original 
create sentinel 	node calculate 
addr dict 	eclosure node dfa 
iterator dict 	nodes calculate 
next dict 	epsilon closure already 
val sentinel 	calculated skip 
addr 	calculate epsilon closure 
equal zrealloc 	node idx 
create sentinel 	calculate epsilon 
addr dict 	closure node indicates 
release iterator 	calculating node 
sentinel addr 	reference avoid infinite 
equal 	loop current 
zrealloc create 	node constraints duplicate 
sentinel addr 	nodes since 
sentinel reset 	must inherit constraints 
master create 	expand epsilon 
sentinel redis 	destination nodes calculating 
instance 	epsilon closure 
release sentinel 	edest progress intermediate 
addr sentinel 	result haven 
zfree release 	calculated epsilon closure 
sentinel addr 	edest yet 
sentinel flush 	calculate otherwise use 
config 	calculated epsilon 
mstime dict 	closure merge epsilon 
iterator dict 	closure edest 
next dict 	epsilon closure 
val dict 	edest incomplete epsilon 
release iterator 	closure node 
strcasecmp 	also incomplete epsilon 
atoi create 	closure includes 
sentinel redis 	functions token used 
instance atoi 	parser fetch 
strcasecmp sentinel 	token input must 
master name 	use function 
atoi 	inside bracket expressions 
sentinel propagate 	peek token 
period strcasecmp 	input length token 
sentinel master 	must use 
name atoi 	function inside bracket 
strcasecmp sentinel 	expressions peek 
master 	token input length 
name atoi 	token must 
strcasecmp sentinel 	use function bracket 
master name 	expressions enable 
access sdsnew 	escape character 
strcasecmp sentinel 	special bracket exps 
master 	fall functions 
name access 	parser entry point 
sdsnew strcasecmp 	parser parse 
sentinel master 	regular expression regexp 
name sdsnew 	structure error 
strcasecmp strtoull 	occurred err error 
strcasecmp 	code function 
strlen memcpy 	build following regular 
strcasecmp sentinel 	expression reg 
master name 	exp cat reg 
strtoull strcasecmp 	exp eor 
sentinel master 	cat means concatenation 
name 	eor means 
strtoull strcasecmp 	end regular expression 
sentinel master 	function build 
name create 	following regular 
sentinel redis 	expression branch branch 
instance atoi 	alt branch 
strcasecmp 	branch alt means 
sentinel master 	alternative represents 
name create 	function build following 
sentinel redis 	regular expression 
instance atoi 	exp exp cat 
sdsnew sentinel 	exp exp 
connection 	cat means concatenation 
sharing strcasecmp 	otherwise exp 
strlen sdsnew 	need create function 
strcasecmp atoi 	build following 
sdscatprintf sdsempty 	regular expression fallthrough 
rewrite 	fall fall 
config rewrite 	treat normal character 
line dict 	characters normal 
iterator dict 	characters word bits 
next dict 	initialized already 
val sentinel 	peek token 
current 	must since ancho 
master address 	followed repetition 
sdscatprintf sdsempty 	operators invalid anchor 
rewrite config 	must anchor 
rewrite line 	repeat must happen 
sdscatprintf sdsempty 	bre consecutive 
rewrite 	duplications allowed function 
config rewrite 	build following 
line sdscatprintf 	regular expression reg 
sdsempty rewrite 	exp subexp 
config rewrite 	reg exp subexpression 
line sdscatprintf 	may function 
sdsempty 	parse repetition operators 
rewrite config 	like etc 
rewrite line 	treat invalid treat 
sdscatprintf sdsempty 	invalid sequence 
rewrite config 	syntax bit rollback 
rewrite line 	word bits 
sdscatprintf 	already initialized 
sdsempty rewrite 	peek token first 
config rewrite 	number greater 
line sdscatprintf 	second extract duplicate 
sdsempty rewrite 	elem marked 
config rewrite 	optional loop actually 
line 	executed end 
sdscatprintf sdsempty 	rewrite already created 
rewrite config 	start copy 
rewrite line 	size names collating 
sdscatprintf sdsempty 	symbol equivalence 
rewrite config 	character sure maybe 
rewrite 	enough local 
line dict 	function parse bracket 
iterator dict 	exp used 
next dict 	libc build range 
val sentinel 	expression starts 
addr equal 	start elem ends 
sdscatprintf 	end elem 
sdsempty rewrite 	result written 
config rewrite 	mbcset sbcset range 
line dict 	alloc allocated 
release iterator 	size mbcset range 
dict iterator 	starts mbcset 
dict 	range ends pointer 
next dict 	argument since 
val sdscatprintf 	may update enable 
sdsempty rewrite 	enable equivalence 
config rewrite 	classes character classes 
line dict 	range start 
release 	end handle multi 
iterator sdscatprintf 	character collating 
sdsempty rewrite 	elements without libc 
config rewrite 	support fedora 
line sdsnew 	core maybe others 
sdscatrepr sdslen 	broken btowc 
rewrite 	returns sigh note 
config rewrite 	start end 
line sdscatprintf 	sign extension 
sdsempty rewrite 	problems got valid 
config rewrite 	collation sequence 
line dict 	values entry however 
release 	libc collation 
iterator rewrite 	elements character single 
config open 	single character 
fsync close 	build suffices parse 
close server 	bracket exp 
log strerror 	passes mbcset dfa 
redis 	cur max 
command snprintf 	check space arrays 
redis command 	enough space 
mstime redis 	need realloc mbcset 
connect bind 	nranges use 
sentinel instance 	realloc since mbcset 
link 	range starts 
close connection 	mbcset range 
mstime redis 	ends range alloc 
attach redis 	build table 
connect callback 	single characters enable 
redis disconnect 	build table 
callback 	single characters enable 
sentinel send 	libc helper 
auth needed 	function parse bracket 
sentinel client 	exp used 
name sentinel 	libc build collating 
send ping 	element represented 
redis 	name result written 
connect bind 	mbcset sbcset 
sentinel instance 	coll sym alloc 
link close 	allocated size 
connection mstime 	mbcset coll sym 
redis attach 	pointer argument 
redis 	since may update 
connect callback 	enable enable 
redis disconnect 	libc function 
callback sentinel 	parse bracket expression 
send auth 	like abc 
needed sentinel 	etc local function 
client 	parse bracket 
name redis 	exp used libc 
command instance 	environment seek 
link close 	collating symbol entry 
connection mstime 	correspondings name 
sdsfree sdsnew 	index symbol symb 
sdssplitlen 	table first 
strlen sdslen 	compare hashing compare 
memcmp sdsnewlen 	length name 
strncmp sentinel 	compare name yep 
sdsfree sdsnewlen 	entry next 
sdslen memcmp 	entry local function 
isdigit 	parse bracket 
strstr strchr 	exp used libc 
strchr strchr 	environment look 
strstr strstr 	collation sequence 
strchr strchr 	elem succeeded max 
sentinel redis 	otherwise cur 
instance 	max found entry 
lookup slave 	skip name 
atoi create 	collating element name 
sentinel redis 	skip sequence 
instance atoi 	collating element adjust 
sentinel sentinel 	alignment skip 
flush 	multibyte collation sequence 
config sdslen 	skip wide 
memcmp strtoll 	sequence collating element 
memcmp memcmp 	collation sequence 
sdslen memcmp 	valid character match 
strcasecmp sdsfree 	single character 
sdsnew 	local function parse 
mstime sdslen 	bracket exp 
memcmp atoi 	used libc environment 
mstime sdslen 	build range 
memcmp strcasecmp 	expression starts 
sdslen memcmp 	start elem ends 
atoi 	end elem 
sdslen memcmp 	result written mbcset 
strtoull mstime 	sbcset range 
sdsfreesplitres mstime 	alloc allocated size 
mstime sentinel 	mbcset range 
mstime sentinel 	starts mbcset range 
flush 	ends pointer 
config sentinel 	argument since may 
sentinel sim 	update equivalence 
failure crash 	classes character classes 
sentinel sentinel 	range start 
call client 	end check start 
reconf 	end collation 
script sentinel 	sequence values got 
force hello 	valid collation 
update master 	sequence values 
sentinel master 	entry however collation 
looks sane 	elements character 
sentinel 	single single character 
redis instance 	build suffices 
mstime sentinel 	check space arrays 
send slave 	enough space 
sentinel strcasecmp 	need realloc mbcset 
sentinel master 	nranges build 
looks 	table single characters 
sane sentinel 	cur max 
redis instance 	local function parse 
mstime sentinel 	bracket exp 
send slave 	used libc environment 
sentinel strcmp 	build collating 
sentinel 	element represented name 
sentinel sentinel 	result written 
refresh instance 	mbcset sbcset coll 
info unused 	sym alloc 
unused strncmp 	allocated size 
strncmp strncmp 	mbcset coll sym 
mstime 	pointer argument 
strncmp redis 	since may update 
command mstime 	found entry 
mstime sdssplitlen 	skip name collating 
sentinel master 	element name 
name atoi 	valid character treat 
atoi 	normal character 
sentinel redis 	got valid collation 
instance addr 	sequence entry 
run strtoull 	check space arrays 
strtoull matching 	enough realloc 
sentinel master 	mbcset ncoll syms 
sentinel 	use realloc 
sentinel redis 	since mbcset coll 
instance addr 	syms alloc 
run sentinel 	enable cur max 
sentinel update 	enable enable 
sentinel address 	enable skip 
masters 	token treat first 
create sentinel 	normal character 
redis instance 	information next token 
sentinel sdsnew 	need check 
sentinel connection 	ranges know allowed 
sharing sentinel 	skip treat 
update 	last normal character 
sentinel address 	enable check 
masters sentinel 	whether enough space 
flush config 	enough realloc 
sentinel flush 	mbcset nmbchars use 
config sentinel 	realloc since 
strcmp 	alloc enable enable 
sentinel sentinel 	enable enable 
dup sentinel 	skip token non 
addr sentinel 	matching list 
reset master 	ensure single characters 
change address 	build complex 
sentinel 	bracket bits 
call client 	sbcset point simple 
reconf script 	bracket complex 
release sentinel 	bracket build simple 
addr mstime 	bracket alt 
sdsfreesplitres unused 	node enable build 
mstime 	simple bracket 
strcmp strstr 	enable parse element 
sentinel process 	bracket expression 
hello message 	enable skip token 
sentinel current 	must appear 
master address 	anything range indicator 
anet 	closing bracket 
sock name 	everything error actual 
snprintf redis 	error standardized 
command dict 	since whole undefined 
safe iterator 	erange makes 
dict next 	good sense 
dict 	parse bracket symbol 
val dict 	bracket expression 
release iterator 	bracket symbols character 
sentinel force 	collating element 
hello update 	equivalent helper function 
dict redis 	parse bracket 
instances 	exp build equivalence 
sentinel force 	represented name 
hello update 	result written mbcset 
dict redis 	sbcset equiv 
instances redis 	alloc allocated size 
command mstime 	mbcset equiv 
mstime 	classes pointer argument 
redis command 	since may 
sentinel send 	update enable enable 
ping sentinel 	include defines 
send hello 	local function calculate 
sdsempty deferred 	index equivalence 
multi 	isn valid 
bulk length 	character build single 
reply bulk 	matcing table 
reply bulk 	equivalence idx table 
reply bulk 	isn valid 
reply bulk 	character compare length 
reply 	matches collation 
bulk reply 	rule index check 
bulk reply 	whether enough 
bulk reply 	space enough realloc 
bulk reply 	mbcset nequiv 
bulk sdscat 	classes use realloc 
sdscat 	since alloc 
sdscat sdscat 	libc helper function 
sdscat sdscat 	parse bracket 
sdscat sdscat 	exp build character 
sdscat sdscat 	represented name 
sdscat sdscat 	result written mbcset 
sdslen 	sbcset alloc 
sdsrange reply 	allocated size 
bulk sdsfree 	mbcset classes pointer 
reply bulk 	argument since 
reply bulk 	may update enable 
reply bulk 	enable reg 
reply 	icase upper lower 
bulk reply 	match upper 
bulk reply 	lower cases check 
bulk sentinel 	space arrays 
failover state 	enough realloc mbcset 
str reply 	nchar classes 
bulk 	use realloc since 
reply bulk 	alloc enable 
mstime reply 	see comments enable 
bulk reply 	enable enable 
bulk mstime 	enable enable care 
reply bulk 	syntax enable 
reply 	enable match also 
bulk mstime 	non matching 
reply bulk 	list ensure 
reply bulk 	single characters build 
mstime reply 	simple bracket 
bulk reply 	build complex bracket 
bulk 	alt node 
mstime reply 	enable enable enable 
bulk reply 	intended expressions 
bulk reply 	like fetch number 
bulk reply 	input number 
bulk mstime 	number field empty 
reply 	like error 
bulk reply 	occurred enable functions 
bulk reply 	binary operation 
bulk reply 	create node mark 
bulk mstime 	src optional 
reply bulk 	subexpression called preorder 
reply 	postorder free 
bulk reply 	allocated memory inside 
bulk reply 	node enable 
bulk dict 	worker function 
size reply 	walking free allocated 
bulk reply 	memory inside 
bulk 	node children duplicate 
dict size 	node src 
reply bulk 	node preorder visit 
reply bulk 	similar one 
reply bulk 	implemented visitor need 
reply bulk 	infrastructure maintain 
reply 	two parallel trees 
bulk reply 	easier duplicate 
bulk reply 	create link back 
bulk reply 	current parent 
bulk reply 	left node right 
bulk reply 	regex.c max 
bulk 	failures extended regular 
reply bulk 	expression matching 
reply bulk 	search library 
reply bulk 	copyright free software 
reply bulk 	foundation inc 
reply bulk 	file part gnu 
reply 	library contributed 
bulk reply 	isamu hasegawa isamu 
bulk reply 	yamato ibm 
bulk reply 	gnu library free 
bulk reply 	software redistribute 
bulk reply 	modify terms gnu 
bulk 	lesser general 
reply bulk 	license published free 
reply bulk 	software foundation 
reply bulk 	either version license 
mstime reply 	option later 
bulk reply 	version gnu library 
bulk 	distributed hope 
reply bulk 	useful without warranty 
reply bulk 	without even 
deferred multi 	implied warranty 
bulk length 	merchantability fitness particular 
dict iterator 	purpose see 
reply 	gnu lesser general 
multi bulk 	license details 
len dict 	received copy gnu 
size dict 	lesser general 
next dict 	license along gnu 
val reply 	library write 
sentinel 	free software foundation 
redis instance 	inc franklin 
dict release 	street fifth floor 
iterator dict 	boston usa 
fetch reply 	make sure one 
error dict 	compiles code 
size 	compiler keep clean 
dict iterator 	size systems 
dict next 	limits sets dup 
dict val 	max lower 
dict release 	gnu regex 
iterator strcasecmp 	allows include regex 
reply 	correctly undefs 
dict redis 	dup max sets 
instances strcasecmp 	right binary 
sentinel master 	backward compatibility regex.h 
name reply 	syntax options 
error reply 	nsub num regs 
sentinel 	start end 
redis instance 	syntax pattern length 
strcasecmp sentinel 	buffer buffer 
master name 	buffer cstring length 
reply error 	start range 
reply dict 	regs buffer length 
redis 	length start 
instances strcasecmp 	range regs stop 
sentinel master 	buffer cstring 
name reply 	length start regs 
error reply 	buffer length 
dict redis 	length start 
instances 	regs stop buffer 
strcasecmp reply 	regs num 
reply sentinel 	regs starts ends 
redis instance 	preg pattern 
addr run 	cflags preg cstring 
strcasecmp sentinel 	nmatch pmatch 
vote 	eflags errcode preg 
leader reply 	errbuf errbuf 
multi bulk 	size preg definitions 
len reply 	data structures 
reply bulk 	routines regular expression 
reply sdsfree 	library copyright 
strcasecmp 	free software foundation 
reply sentinel 	inc file 
reset masters 	part gnu library 
pattern strcasecmp 	gnu library 
sentinel master 	free software 
name reply 	redistribute modify terms 
sentinel 	gnu lesser 
current master 	general license published 
address reply 	free software 
multi bulk 	foundation either version 
len reply 	license option 
bulk reply 	later version gnu 
bulk 	library distributed 
strcasecmp sentinel 	hope useful without 
master name 	warranty without 
reply error 	even implied warranty 
reply sds 	merchantability fitness 
sdsnew sentinel 	particular purpose see 
slave 	gnu lesser 
reply sds 	general license details 
sdsnew server 	received copy 
log sentinel 	gnu lesser general 
start failover 	license along 
reply strcasecmp 	gnu library 
sentinel 	write free software 
pending scripts 	foundation inc 
command strcasecmp 	franklin street fifth 
reply reply 	floor boston 
reply error 	usa allow use 
anet resolve 	code following 
reply 	two types integer 
error create 	type wide 
sentinel redis 	enough hold pointer 
instance reply 	ansi compilers 
error reply 	ptrdiff size likely 
error reply 	still size 
error 	two types microsoft 
sentinel flush 	ugh following 
config sentinel 	bits used determine 
reply strcasecmp 	regexp syntax 
sentinel flush 	recognize meanings chosen 
config reply 	emacs syntax 
strcasecmp 	remains bits 
sentinel master 	given alphabetical order 
name reply 	definitions shifted 
error sentinel 	one previous bit 
dict sentinel 	thus bit 
flush 	one definition need 
config reply 	change bit 
strcasecmp sentinel 	inside bracket expression 
master name 	quotes following 
reply error 	character bit operators 
sentinel quorum 	literals operators 
reachable 	literals bit character 
reply sds 	classes supported 
sdscatfmt sdsempty 	alpha upper lower 
sdscatfmt sdsempty 	digit alnum 
sdscat sdscat 	xdigit space print 
sdscat sdscat 	punct graph 
reply 	cntrl character classes 
sds strcasecmp 	supported bit 
sentinel command 	always anchors 
strcasecmp mstime 	outside bracket expressions 
dict create 	course bit 
sentinel master 	depends anchor beginning 
name 	regular expression 
dict reply 	open alternation anchor 
multi bulk 	end regular 
len dict 	expression close alternation 
size dict 	bit could 
iterator dict 	combined context indep 
next 	ops posix 
dict val 	draft says etc 
reply bulk 	leading positions 
buffer strlen 	undefined already implemented 
reply multi 	previous draft 
bulk len 	made constructs invalid 
dict 	though haven 
size reply 	changed code 
multi bulk 	back bit special 
len reply 	characters always 
reply bulk 	special regardless pattern 
buffer sdslen 	bit special 
reply 	characters special contexts 
dict iterator 	otherwise ordinary 
dict next 	specifically intervals special 
dict val 	beginning open 
reply multi 	alternation bit cannot 
bulk len 	first immediately 
reply 	alternation begin bit 
reply bulk 	matches newline 
buffer sdslen 	doesn bit doesn 
reply dict 	match nul 
release iterator 	bit nonmatching lists 
dict release 	match newline 
iterator 	bit either defines 
dict release 	interval depending 
strcasecmp strcasecmp 	braces literals 
server log 	bit aren recognized 
strcasecmp server 	operators bit 
log strcasecmp 	newline alternation newline 
reply 	bit defines 
multi bulk 	interval literals defines 
len reply 	interval bit 
bulk reply 	defines literals defines 
bulk reply 	literals bit 
error reply 	digit matches digit 
reply 	digit back 
error format 	reference bit alternation 
reply error 	alternation bit 
format reply 	ending range point 
strcasecmp strcasecmp 	collating higher 
sdsempty info 	starting range point 
section 	invalid ending 
redis info 	range point collates 
section redis 	higher starting 
info section 	range point 
redis info 	range ignored bit 
section redis 	unmatched ordinary 
strcasecmp 	unmatched invalid bit 
sdscat sdscatprintf 	succeed soon 
dict size 	match whole pattern 
list length 	without backtracking 
dict iterator 	bit process gnu 
dict next 	regex operators 
dict 	gnu regex operators 
val sdscatprintf 	recognized bit 
dict size 	syntactically invalid interval 
dict size 	treated ordinary 
dict release 	characters example ere 
iterator reply 	treated bit 
bulk 	ignore matching significant 
sds reply 	bit used 
multi bulk 	internally like context 
len reply 	indep anchors 
bulk buffer 	difficult scan 
reply multi 	regex backwards find 
bulk 	whether special 
len dict 	bit cannot first 
size dict 	bre immediately 
iterator dict 	alternation begin bit 
next dict 	sub compile 
val reply 	pattern variable defines 
bulk 	particular regexp 
dict release 	syntax use interfaces 
iterator sentinel 	regexp compiled 
master name 	syntax used stored 
reply error 	pattern buffer 
strcasecmp sentinel 	changing affect already 
propagate 	compiled regexps 
period strcasecmp 	define combinations bits 
strcasecmp strcasecmp 	standard possibilities 
strlen access 	comments delimit gets 
reply error 	put texinfo 
sentinel flush 	file begin 
config 	syntaxes section lines 
sdsfree strlen 	syntax bits 
sdsnew strcasecmp 	common basic extended 
strlen access 	posix regex 
reply error 	syntax differs posix 
sentinel flush 	basic plus 
config 	becomes limited ops 
sdsfree strlen 	recognized actually 
sdsnew strcasecmp 	isn minimal since 
sdsfree strlen 	operators aren 
sdsnew strcasecmp 	disabled differs posix 
reply error 	extended context 
format 	indep ops removed 
sentinel flush 	refs added 
config sentinel 	end syntaxes maximum 
sentinel flush 	number duplicates 
config reply 	interval allow 
sentinel flush 	systems erroneously define 
config 	header files 
reply error 	want previous define 
format strcmp 	overflows posix 
reply error 	cflags bits information 
sentinel process 	regcomp bit 
hello message 	use extended regular 
sdslen 	expression syntax 
reply mstime 	use basic regular 
mstime mstime 	expression syntax 
mstime instance 	bit ignore matching 
link close 	significant bit 
connection mstime 	anchors match newline 
mstime 	characters anchors 
instance link 	match newlines bit 
close connection 	report success 
mstime sentinel 	fail regexec returns 
mstime sentinel 	differ matching 
dict iterator 	errors posix 
dict 	eflags bits information 
next dict 	regexec bit 
val dict 	beginning line doesn 
release iterator 	match beginning 
sentinel mstime 	presumably beginning line 
sentinel mstime 	beginning line 
strcmp 	match beginning like 
sdsfree server 	reg notbol 
log sdsnew 	end line use 
dict iterator 	pmatch delimit 
dict next 	start end search 
dict val 	buffer error 
mstime 	codes removed changed 
sdsfree mstime 	added update 
redis command 	error msg table 
dict release 	regex never 
iterator server 	happen implementation success 
log exit 	didn find 
sentinel 	match regexec 
flush config 	posix regcomp error 
sentinel sdsfree 	codes order 
sdsnew sentinel 	listed standard invalid 
flush config 	pattern inalid 
sentinel strcasecmp 	collating element invalid 
mstime 	character name 
rand sdsnew 	trailing backslash invalid 
dict find 	back reference 
dict integer 	unmatched left bracket 
val dict 	parenthesis imbalance 
integer val 	unmatched invalid contents 
dict 	invalid range 
raw server 	end ran memory 
dict integer 	preceding repetition 
val server 	error codes added 
dict create 	premature end 
dict size 	compiled pattern bigger 
dict 	bytes unmatched 
iterator dict 	returned regcomp 
next dict 	data structure represents 
val sentinel 	compiled pattern 
leader incr 	calling pattern compiler 
dict release 	fields buffer 
iterator 	allocated fastmap translate 
dict iterator 	sub pattern 
dict next 	compiled nsub field 
dict integer 	available fields 
val dict 	regex routines space 
key dict 	holds compiled 
release 	pattern declared elements 
iterator sentinel 	sometimes used 
vote leader 	indexes number bytes 
sentinel vote 	buffer points 
leader sentinel 	number bytes actually 
leader incr 	used buffer 
sdsnew 	syntax setting 
sdsfree dict 	pattern compiled pointer 
release memcpy 	fastmap otherwise 
redis command 	zero search uses 
redis command 	fastmap one 
redis command 	skip impossible starting 
redis 	points matches 
command redis 	either translate table 
command server 	apply characters 
sentinel sentinel 	comparing zero translation 
mstime rand 	translation applied 
mstime mstime 	pattern compiled matched 
ctime 	number subexpressions 
server log 	found compiler zero 
sentinel start 	pattern cannot 
failover strcasecmp 	match empty one 
zmalloc dict 	well truth 
size mstime 	used search see 
dict 	whether use 
iterator dict 	fastmap absolutely 
next dict 	perfectly see compile 
val mstime 	fastmap duplicate 
mstime dict 	regs unallocated allocate 
release iterator 	space regs 
qsort 	structure max nregs 
zfree sentinel 	nsub groups 
leader strcasecmp 	regs reallocate reallocate 
sdsfree mstime 	space necessary 
sentinel sentinel 	regs use zero 
abort failover 	regex compile 
sentinel 	compiles pattern one 
sentinel sim 	compile fastmap 
failure crash 	updates fastmap match 
mstime sentinel 	information subexpressions 
sentinel slave 	beginning line anchor 
sentinel sentinel 	doesn match 
abort 	beginning similarly end 
failover sentinel 	line anchor 
mstime sentinel 	anchor newline 
mstime sentinel 	matches type offsets 
sentinel abort 	within posix 
failover sentinel 	mandates structure store 
send 	match data 
slave sentinel 	see regex texinfo 
mstime mstime 	full description 
sentinel sentinel 	registers match regs 
abort failover 	allocated regs 
mstime dict 	unallocated pattern buffer 
iterator 	match returns 
dict next 	information least many 
dict val 	registers first 
dict release 	time regs structure 
iterator sentinel 	passed posix 
sentinel mstime 	specification registers aside 
dict 	different names 
iterator dict 	registers posix uses 
next dict 	structures instead 
val sentinel 	structure arrays 
send slave 	offset start substring 
sentinel dict 	start offset 
release 	start substring end 
iterator dict 	declarations routines 
iterator dict 	sets current syntax 
next dict 	syntax old 
val dict 	syntax also simply 
release iterator 	assign syntax 
dict 	options variable compile 
iterator dict 	regular expression 
next dict 	pattern length length 
val mstime 	syntax given 
sentinel sentinel 	syntax options buffer 
send slave 	buffer successful 
mstime 	error compile fastmap 
sentinel dict 	compiled pattern 
release iterator 	buffer used 
sentinel failover 	accelerate searches successful 
detect end 	error search 
sentinel sentinel 	length length pattern 
reset 	compiled buffer 
master change 	start searching position 
address server 	start range 
sentinel failover 	characters starting position 
wait start 	match match 
sentinel failover 	error also information 
slave 	regs regs 
sentinel failover 	buffer sub nonzero 
send slave 	like search 
one sentinel 	search concatenation also 
failover wait 	stop searching 
promotion sentinel 	index start stop 
failover 	like search 
reconf next 	many characters regexp 
slave server 	buffer matched 
server mstime 	starting position 
sentinel reconnect 	start relates match 
instance sentinel 	search relates 
send 	search regs hold 
periodic commands 	num regs 
mstime sentinel 	registers storing starts 
sentinel check 	ends subsequent 
subjectively sentinel 	matches buffer regs 
check objectively 	use memory 
sentinel 	recording information starts 
start failover 	ends must 
needed sentinel 	allocated malloc must 
ask master 	least num 
state sentinels 	regs regoff bytes 
sentinel failover 	num regs 
state 	subsequent matches allocate 
machine sentinel 	data unless 
ask master 	function called first 
state sentinels 	search match 
dict iterator 	pattern buffer 
dict next 	allocate data without 
dict 	freeing old 
val sentinel 	data use gnu 
handle redis 	bsd compatibility 
instance sentinel 	gcc later restrict 
handle dict 	compilers restrict 
redis instances 	configure may defined 
sentinel 	restrict gcc 
handle dict 	support restrict syntax 
redis instances 	posix compatibility 
sentinel failover 	regex regexec.c function 
promoted slave 	function function 
dict release 	function function function 
iterator 	function function 
mstime mstime 	preg length start 
sentinel mstime 	range stop 
sentinel check 	nmatch pmatch eflags 
tilt condition 	bufp length 
sentinel handle 	length start 
dict 	range regs stop 
redis instances 	ret len 
sentinel run 	bufp length start 
pending scripts 	range stop 
sentinel collect 	regs ret len 
terminated scripts 	regs pmatch 
sentinel 	nregs regs allocated 
kill timedout 	mctx function 
scripts rand 	function function function 
redis sentinel 	function function 
implementation copyright 	function function function 
salvatore sanfilippo 	function function 
antirez 	function function function 
gmail dot 	function function 
rights reserved 	function function function 
redistribution use 	function function 
source binary 	function function function 
forms without 	function function 
modification 	function function 
permitted provided 	function function function 
following conditions 	function function 
met redistributions 	function function function 
source code 	function preg 
must retain 	nmatch pmatch eflags 
copyright 	err start 
notice list 	length preg nmatch 
conditions following 	pmatch eflags 
disclaimer redistributions 	bufp length start 
binary form 	regs bufp 
must reproduce 	length start range 
copyright 	regs bufp 
notice list 	length length start 
conditions following 	regs stop 
disclaimer documentation 	bufp length length 
materials provided 	start range 
distribution neither 	regs stop 
name 	bufp length length 
redis names 	start range 
contributors may 	regs stop ret 
used endorse 	len str 
promote products 	rval len free 
derived software 	str bufp 
without 	length start range 
specific prior 	stop regs 
written permission 	ret len result 
software provided 	pmatch nregs 
copyright holders 	rval eflags regs 
contributors express 	pmatch nregs 
implied 	regs allocated rval 
warranties including 	need regs 
limited implied 	start end bufp 
warranties merchantability 	regs num 
fitness particular 	regs starts ends 
purpose disclaimed 	preg length 
shall 	start range 
copyright owner 	stop nmatch pmatch 
contributors liable 	eflags err 
direct indirect 	dfa left lim 
incidental special 	right lim 
exemplary consequential 	incr longest match 
damages 	match first 
including limited 	match kind match 
procurement substitute 	last extra 
goods services 	nmatch mctx mctx 
loss use 	fastmap offset 
data profits 	pstate reg idx 
business 	mctx dfa 
interruption however 	halt node match 
caused theory 	last ret 
liability whether 	sifted states lim 
contract strict 	states sctx 
liability tort 	acquire init state 
including 	context mctx 
negligence otherwise 	longest match 
arising way 	match first dfa 
use software 	err match 
even advised 	match last cur 
possibility damage 	str idx 
sentinel 	cur state init 
state address 	state next 
used describe 	start idx old 
port pair 	state next 
sentinel redis 	idx dfa node 
instance monitoring 	context type 
subjectively 	constraint mctx state 
quorum objectively 	idx context 
confirmed others 	mctx nregs regs 
sentinel flag 	pidx node 
thinks master 	eps via nodes 
failover progress 	dfa err 
master 	cur nodes edests 
slave selected 	dest node 
promotion slaveof 	candidate naccepted 
newmaster sent 	type subexp idx 
slave synchronization 	buf dest 
progress slave 	node dest node 
master 	str idx 
force failover 	dest node nregs 
master script 	regs eps 
kill already 	via nodes err 
sent busy 	num pidx 
note 	nregs regs eps 
times milliseconds 	via nodes 
failover machine 	num preg mctx 
different states 	nmatch pmatch 
failover progress 	backtrack dfa idx 
wait failover 	cur node 
start 	eps via nodes 
time slave 	body prev 
promote slave 	idx match 
master wait 	prev idx match 
slave change 	malloced reg 
role slaveof 	idx idx dfa 
newmaster 	pmatch prev 
monitor promoted 	idx match cur 
slave flags 	node cur 
used different 	idx nmatch type 
functions use 	reg num 
higher bits 	reg num mctx 
avoid 	sctx err 
colliding function 	cnt str idx 
specific flags 	cur dest 
script execution 	mctx sctx str 
flags limits 	idx cur 
seconds max 	dest dfa cur 
exec 	src prev 
time seconds 	node naccepted ret 
retries sentinel 	type idx 
simulate failure 	mctx next 
command flags 	state log idx 
link sentinel 	top err 
redis 	dfa dst src 
instance sentinels 	num idx 
monitoring many 	err merged mctx 
masters different 	sctx str 
instances representing 	idx dest nodes 
sentinels one 	dfa err 
per 	candidates dfa dest 
master need 	nodes candidates 
share hiredis 	err state dfa 
connections among 	node dest 
oherwise sentinels 	nodes candidates ecl 
monitoring masters 	idx err 
create 	inv eclosure nodes 
outgoing connections 	cur node 
instead structure 	edst edst cur 
represents reference 	node idx 
counted link 	mctx limits 
terms two 	dst node dst 
hiredis 	idx src 
connections commands 	node src idx 
pub sub 	dfa lim 
fields needed 	idx src pos 
failure detection 	dst pos 
since ping 	dst bkref idx 
pong 	src bkref 
time local 	idx subexp idx 
link link 	ent mctx 
available instance 	boundaries subexp idx 
avaialbe way 	node bkref 
connections instead 	idx dfa eclosures 
also 	node idx 
send pings 	node ent dst 
instead links 	cpos mctx 
shared sentinels 	limit subexp idx 
master slave 	node str 
instances link 	idx bkref 
refcount 	idx lim boundaries 
always number 	dfa dest 
sentinel redis 	nodes candidates limits 
instance owners 	bkref ents 
non zero 	str idx err 
need reconnect 	node idx 
number 	lim idx subexp 
commands sent 	idx ent 
waiting reply 	ops node cls 
hiredis context 	node node 
commands hiredis 	type node node 
context pub 	type mctx 
sub 	sctx str idx 
connection time 	candidates dfa 
connection time 	err node idx 
last time 	node local 
received message 	sctx first 
last time 	idx enabled idx 
instance 	type entry 
replied ping 	subexp len idx 
reply consider 	dst node 
valid time 	ret cur state 
last pending 	mctx sctx 
ping pong 	node idx str 
received 	idx max 
sent field 	str idx dfa 
pong received 	naccepted err 
current time 	mctx state trtable 
ping sent 	context err 
time sent 	mctx next state 
last 	dfa cur 
ping used 	idx pstate context 
avoid sending 	next nodes 
many pings 	log nodes table 
failure idle 	nodes err 
time computed 	mctx cur 
act 	state max cur 
ping time 	str idx 
field last 	mctx cur nodes 
time instance 	str idx 
replied ping 	dfa node idx 
whatever reply 	err node 
used 	mctx pstate dfa 
check link 	err dest 
idle must 	nodes nodes cur 
reconnected last 	node idx 
reconnection attempt 	naccepted dest idx 
performed link 	context dest 
see 	state mctx nodes 
sri defines 	dfa err 
master name 	cur str idx 
point view 	dest str 
sentinel run 	idx prev nelem 
instance unique 	bkc idx 
sentinel 	node idx 
configuration epoch 	context node dest 
master host 	nodes subexp 
link instance 	len dest state 
may shared 	bkref ent 
sentinels last 	dest nodes mctx 
time 	bkref node 
sent hello 	bkref str idx 
via pub 	dfa subexp 
sub used 	num sub top 
sri sentinel 	idx buf 
last time 	cache idx entry 
received 	err sub 
hello sentinel 	top sub last 
via pub 	sub last 
sub time 	idx str bkref 
last reply 	str str 
sentinel master 	diff cls node 
command 	str nodes 
subjectively since 	mctx sub 
time objectively 	top sub last 
since time 	bkref node 
consider period 	bkref str err 
time received 	idx dfa 
info 	nodes subexp idx 
output role 	type cls 
first time 	idx cls node 
observed useful 	node mctx 
order delay 	path top node 
replacing instance 	top str 
reports 	last node last 
configuration need 	str type 
always wait 	dfa err subexp 
time order 	num backup 
give chance 	cur idx str 
leader report 	idx cnt 
configuration 	cur state cur 
silly things 	nodes next 
last time 	nodes backup 
slave master 	state log context 
addr changed 	old alloc 
master specific 	mctx str idx 
sentinels 	cur nodes 
monitoring master 	next nodes dfa 
slaves master 	result cur 
instance number 	idx err naccepted 
sentinels need 	cur node 
agree failure 	type dest state 
many 	next node 
slaves reconfigure 	next idx dfa 
time password 	cur nodes 
use auth 	subexp type err 
master slaves 	idx outside 
slave specific 	node nodes cur 
slave 	node eclosure 
replication link 	dfa dst 
time slave 	nodes target subexp 
priority according 	type cur 
info output 	node err mctx 
time sent 	cur nodes 
slave 	cur str subexp 
master instance 	num type 
slave master 	dfa err cache 
host reported 	idx start 
info master 	ent idx next 
port reported 	node dests 
info 	err err ret 
master link 	dfa state 
status reported 	err need word 
info slave 	trtable elem 
replication offset 	mask dests node 
failover master 	malloced dest 
instance 	states malloced ndests 
runid sentinel 	trtable dest 
perform failover 	states word 
sentinel runid 	dest states follows 
sentinel sentinel 	dests node 
voted leader 	dests acceptable dests 
epoch 	node dests 
leader field 	next node dfa 
epoch currently 	state dests 
started failover 	node dests err 
see sentinel 	result ndests 
failover state 	accepts cur nodes 
defines 	node type 
last failover 	constraint accepts newline 
attempt start 	intersec remains 
time max 	intersec subset consumed 
time refresh 	dfa node 
failover state 	idx input str 
failover 	idx node 
start time 	len elem len 
logged failover 	cset pin 
delay promoted 	nrules match 
slave instance 	len collseq table 
scripts executed 	indirect weights 
notify 	extra collseqwc coll 
admin reconfigure 	sym idx 
clients script 	equiv idx weight 
executed cached 	len cnt 
info output 	cmp buf cmp 
main state 	buf mbs 
sentinel 	mbs len nrules 
current epoch 	collseq idx 
dictionary master 	extra extrasize mbs 
sentinel redis 	cnt found 
instances key 	elem mbs len 
instance name 	mctx node 
sentinel 	idx context mctx 
redis instance 	ret pstr 
structure pointer 	mctx eflags mctx 
tilt mode 	idx idx 
number scripts 	top last 
execution right 	mctx mctx node 
titl 	str idx 
started last 	entry mctx str 
time ran 	idx left 
time handler 	right mid last 
queue user 	mctx node 
scripts execute 	str idx asub 
addr 	tops subtop 
gossiped sentinels 	node str idx 
port gossiped 	entry alasts 
sentinels non 	sctx sifted sts 
zero failures 	limited sts 
simulation script 	last node last 
execution 	str idx 
job script 	strlen libc search 
job flags 	search libc 
sentinel script 	unlock versioned 
number times 	symbol regexec compat 
tried execute 	symbol search 
arguments 	stub search stub 
call script 	search stub 
script execution 	search stub malloc 
time script 	memcpy memcpy 
running otherwise 	search stub free 
allowed retry 	libc compile 
execution 	fastmap malloc search 
time script 	copy regs 
running means 	free libc unlock 
run specified 	malloc malloc 
time script 	free realloc realloc 
execution pid 	free regexec 
hiredis 	memset allocate match 
adapters note 	ctx init 
implementation taken 	malloc reconstruct reconstruct 
hiredis adapters 	first check 
however modified 	matching check 
copy sentinel 	halt state context 
order 	prune impossible 
use allocator 	nodes match ctx 
full control 	clean regs 
adapter works 	free match ctx 
nothing attached 	free destruct 
something already 	malloc malloc memset 
attached 	sift ctx 
create container 	init sift states 
context events 	backward node 
functions start 	free check halt 
stop listening 	state context 
events prototypes 	merge state free 
dictionary 	sift ctx 
types instance 	init sift states 
name sds 	backward node 
instance sentinel 	free free free 
redis instance 	free cur 
pointer also 	idx acquire 
used 	init state context 
sentinel redis 	check subexp 
instance sentinels 	matching top transit 
dictionary maps 	state bkref 
sentinels port 	check halt state 
last seen 	context eoi 
time 	cur idx extend 
pub sub 	buffers transit 
hello message 	state merge state 
hash function 	log find 
key dup 	recover state check 
val dup 	halt state 
key 	context cur idx 
compare key 	cur idx 
destructor val 	satisfy next constraint 
destructor instance 	context check 
runid sds 	halt node context 
votes casted 	epsilon node 
useful 	node insert 
sentinel objective 	node contains node 
leader function 	contains push 
order count 	fail stack check 
votes understand 	node accept 
leader hash 	bytes buffer memcmp 
function 	node insert 
key dup 	node contains check 
val dup 	node accept 
key compare 	node contains node 
key destructor 	empty realloc 
val destructor 	malloc memcpy node 
initialization 	init copy 
function overwrites 	memcpy node free 
normal redis 	free malloc 
config sentinel 	node init empty 
specific defaults 	libc use 
perform sentinel 	alloca alloca 
mode 	malloc free fail 
initialization usual 	stack memcpy 
redis commands 	update regs node 
command table 	free free 
sentinel command 	free fail stack 
initialize various 	pop fail 
data 	stack node free 
structures function 	free proceed 
gets called 	next node node 
server sentinel 	free free 
mode started 	free fail stack 
loaded configuration 	pop fail 
ready 	stack node free 
normal operations 	free node 
sentinel yet 	free free free 
configuration file 	fail stack 
pick random 	node free free 
one persist 	free memcpy 
config 	memcpy node 
disk sentinel 	init update cur 
across restarts 	sifted state 
pick presist 	memset node free 
config log 	node empty 
make debugging 	build sifted states 
issues 	update cur 
simpler want 	sifted state node 
generate monitor 	free epsilon 
every configured 	node sift states 
master startup 	iter check 
sentinel addr 	node accept state 
create 	node contains 
sentinel addr 	check dst limits 
success error 	node insert 
returned errno 	extend buffers memset 
enoent resolve 	node init 
hostname einval 	acquire state node 
invalid 	free epsilon 
port number 	src nodes 
duplicate source 	check subexp limits 
address free 	acquire state 
sentinel address 	sift states bkref 
fail non 	acquire state 
zero 	node alloc node 
two addresses 	merge node 
equal events 	intersect node init 
notification send 	empty epsilon 
log pub 	node node contains 
sub user 	node contains 
notification 	node contains node 
script level 	contains node 
log level 	intersect node free 
logging warning 	node contains 
events trigger 	node contains node 
execution user 	node free 
notification 	search cur bkref 
script type 	entry search 
message type 	cur bkref 
also used 	entry check dst 
pub sub 	limits calc 
channel name 	pos check dst 
redis 	limits calc 
instance target 	pos check dst 
applicable used 	limits calc 
obtain path 	pos check dst 
notification script 	limits calc 
execute remaining 	pos sub epsilon 
arguments 	src nodes 
alike format 	node contains node 
specifier starts 	contains sub 
two characters 	epsilon src nodes 
message prefixed 	sub epsilon 
instance following 	src nodes search 
format 	cur bkref 
instance type 	entry state node 
instance name 	contains check 
port instance 	dst limits 
type master 	node init copy 
additional added 	node insert 
specify 	sift states backward 
originating master 	merge state 
master name 	node node free 
master master 	check node 
port specifier 	accept bytes state 
processed handle 	node contains 
use 	transit state fetch 
vsprintf rest 	context cur 
formatting log 	idx word context 
message log 	build trtable 
level allows 	cur idx node 
logged publish 	init context 
message 	cur idx acquire 
via pub 	state context 
sub debugging 	node free 
one call 	check subexp matching 
notification script 	top transit 
applicable function 	state bkref cur 
called 	idx skip 
startup used 	bytes merge state 
generate monitor 	log match 
every configured 	ctx subtop context 
master events 	cur idx 
also generated 	satisfy next constraint 
master 	check node 
monitor added 	accept bytes cur 
runtime via 	idx cur 
sentinel monitor 	idx clean state 
command script 	log needed 
execution release 	node init context 
script 	acquire state 
job structure 	context node free 
associated data 	cur idx 
copy oldest 	context satisfy 
non running 	next constraint subexp 
script 	context acquire 
already hit 	state context node 
limit first 	init node 
node oldest 	free acquire state 
tail lookup 	context node 
script scripts 	free check subexp 
queue 	matching top 
via pid 	transit state bkref 
returns list 	buffer search 
node easily 	cur bkref entry 
queue needed 	clean state 
run pending 	log needed buffer 
scripts 	memcmp subexp 
already max 	sub buffer extend 
number running 	buffers buffer 
scripts find 	find subexp node 
jobs running 	calloc check 
run top 	arrival match 
tail 	ctx sublast subexp 
queue run 	sub check 
older jobs 	arrival match ctx 
first skip 	entry clean 
already running 	state log needed 
skip retry 	realloc memset 
enough 	context node init 
time elapsed 	check arrival 
parent fork 	expand ecl node 
error report 	free node 
fork errors 	init copy node 
signal order 	init empty 
unify 	expand bkref cache 
reporting kind 	node free 
errors child 	acquire state context 
error occurred 	node free 
retry execution 	node empty node 
much delay 	merge node 
execution 	free check 
script need 	arrival next nodes 
retry error 	node free 
retry delay 	check arrival expand 
every retry 	ecl node 
instance retry 	free expand bkref 
delay 	cache node 
seconds max 	free context acquire 
number retries 	state context 
starting second 	node free node 
attempt execute 	free node 
script delays 	contains node init 
sec 	empty epsilon 
sec min 	node check node 
min min 	accept bytes 
min min 	node empty node 
min min 	merge node 
check scripts 	free node 
terminated 	insert node free 
queue script 	acquire state 
terminated successfully 	node free check 
instead script 	node accept 
terminated signal 	node insert node 
returned exit 	free node 
code 	free node alloc 
scheduled run 	find subexp 
max number 	node node merge 
retries already 	node free 
elapsed script 	check arrival expand 
terminated signal 	ecl sub 
returns 	node free node 
exit code 	free node 
means please 	contains node insert 
retry reschedule 	node insert 
max number 	check arrival expand 
retries already 	ecl sub 
reached 	search cur 
otherwise script 	bkref entry node 
log execution 	contains node 
terminated best 	contains node init 
ways kill 	check arrival 
scripts timeout 	expand ecl node 
collected 	merge node 
sentinel collect 	free node contains 
terminated scripts 	node init 
function sentinel 	copy node insert 
pending scripts 	node free 
command function 	node init acquire 
calls 	state node 
client reconfiguration 	free libc use 
script following 	alloca alloca 
parameters master 	malloc nodes astates 
name role 	free calloc 
state port 	node alloc libc 
port 	use alloca 
called every 	alloca malloc 
time failover 	free node free 
performed state 	node free 
currently always 	free bitset empty 
failover role 	node empty 
either 	node merge acquire 
leader observer 	state context 
fields respectively 	acquire state context 
master promoted 	acquire state 
slave addresses 	context bitset merge 
start end 	calloc calloc 
instance 	bitset contain bitset 
link create 	contain free 
yet connected 	node free node 
link act 	free free 
ping time 	bitset empty bitset 
even actually 	bitset merge 
yet 	bitset merge bitset 
connection node 	bitset clear 
sent ping 	bitset clear 
useful detect 	memset bitset clear 
timeout able 	bitset clear 
connect node 	bitset contain bitset 
disconnect 	empty bitset 
hiredis connection 	bitset empty bitset 
context instance 	empty bitset 
link decrement 	empty bitset contain 
refcount link 	bitset copy 
drops zero 	bitset copy node 
actually 	init copy 
free otherwise 	node insert bitset 
anything pointer 	copy node 
going free 	init bitset empty 
link rebind 	node free 
pending requests 	size elem size 
link 	btowc buffer 
hiredis connection 	wchar iswctype 
commands callback 	current word current 
ignore useful 	current collseq 
avoid processing 	table lookup find 
replies instance 	collation sequence 
longer 	current current current 
exists instance 	current findidx 
may pending 	wcscoll wcscoll current 
callbacks hiredis 	word current 
context privdata 	current current bitset 
instance going 	contain context 
free 	satisfy next constraint 
rewrite callback 	realloc buffers 
list directly 	realloc build wcs 
exploiting hiredis 	upper buffer 
data structures 	build upper buffer 
order bind 	build wcs 
callback 	buffer translate buffer 
ignore reply 	malloc malloc 
strictly needed 	free free 
active users 	free free free 
function attempt 	free match 
share instance 	ctx clean free 
link 	free realloc 
already sentinel 	free memset realloc 
context different 	calloc realloc 
master instance 	calloc node init 
passing argument 	empty extended 
way multiple 	regular expression matching 
sentinel 	search library 
objects refer 	copyright free software 
physical sentinel 	foundation inc 
instance context 	file part gnu 
different masters 	library contributed 
use single 	isamu hasegawa isamu 
connection 	yamato ibm 
send single 	gnu library free 
ping per 	software redistribute 
second failure 	modify terms 
detection forth 	gnu lesser general 
matching sentinel 	license published 
found 	free software foundation 
context different 	either version 
master sharing 	license option later 
performed otherwise 	version gnu 
err returned 	library distributed hope 
way identify 	useful without 
already 	warranty without even 
shared want 	implied warranty 
share physical 	merchantability fitness particular 
sentinel referenced 	purpose see 
masters skip 	gnu lesser general 
master match 	license details 
never 	received copy gnu 
happen safer 	lesser general 
identified matching 	license along gnu 
sentinel great 	library write 
free link 	free software 
use one 	foundation inc franklin 
matching 	street fifth 
sentinel detect 	floor boston usa 
sentinel address 	enable enable 
reporting different 	libc enable entry 
port pair 	point posix 
hello messages 	code regexec searches 
update 	given pattern 
matching sentinels 	specified preg nmatch 
context masters 	zero reg 
well disconnect 	nosub cflags argument 
links everybody 	regcomp ignore 
updated number 	pmatch otherwise pmatch 
updated 	least nmatch 
sentinel addresses 	elements offsets corresponding 
address already 	matched substrings 
updated update 	eflags specifies execution 
address matching 	flags affect 
sentinel copying 	matching reg 
address 	notbol match beginning 
sentinel received 	reg noteol 
address update 	match end find 
function called 	match reg 
hiredis connection 	nomatch entry points 
reported error 	gnu code 
mark 	match search match 
link disconnected 	search former 
reconnected note 	two functions operate 
free hiredis 	length length 
context hiredis 	later two operate 
connections hiredis 	concatenation lengths 
connection 	length length respectively 
established disconnected 	match matches 
callbacks need 	compiled pattern bufp 
cleanup link 	starting index 
state sentinel 	start search 
redis instance 	first tries matching 
create 	index start 
redis instance 	tries match starting 
following fields 	index start 
must populated 	last start position 
caller needed 	tried start 
runid populated 	range thus range 
info 	forces search 
output received 	operate way match 
info refresh 	parameter stop 
mean never 	match search specifies 
received info 	match exceeding 
far sri 	first stop characters 
master 	concatenation concerned 
initial flags 	regs bufp sub 
instance added 	offsets match 
sentinel masters 	groups stroed regs 
table sri 	variants offsets 
slave sri 	computed relative 
sentinel 	concatenation relative individual 
master must 	success match 
instance added 	functions length match 
master slaves 	search position 
master sentinels 	start match means 
table instance 	match found 
slave 	indicates error concatenate 
sentinel name 	parameters meaning 
parameter ignored 	search additional parameters 
created automatically 	ret len 
hostname port 	nonzero length match 
function fails 	returned match 
hostname 	style otherwise position 
resolved port 	match returned 
range happens 	check range compile 
returned errno 	fastmap haven 
accordingly create 	yet need least 
sentinel addr 	nothing copied 
function 	regs hope 
function may 	needn fill regs 
also fail 	match found 
errno ebusy 	caller wants contents 
master name 	data back 
slave address 	copy need one 
sentinel 	extra element 
already exists 	beyond num regs 
check address 	marker gnu 
validity slaves 	code uses data 
use port 	arrays allocated 
name make 	allocate malloc yes 
sure 	need elements 
entry duplicated 	already allocated reallocate 
may happen 	need fewer 
name master 	alone function may 
used multiple 	called regs 
times inside 	nregs big copy 
configuration 	regs regs 
multiple times 	hold num 
slave sentinel 	regs registers storing 
port master 	starts ends 
create instance 	subsequent matches pattern 
note instances 	buffer regs 
started 	use memory recording 
disconnected state 	information starts 
loop take 	ends must allocated 
care connecting 	malloc library 
failover state 	routine must least 
role right 	num regs 
table 	regoff bytes num 
release instance 	regs subsequent 
slaves sentinels 	matches allocate data 
hiredis connections 	unless function 
function take 	called first search 
care unlinking 	match pattern 
instance 	buffer allocate 
main masters 	data without freeing 
table master 	old data 
master sentinels 	entry points compatible 
slaves table 	bsd regex 
slave sentinel 	library define unless 
release 	specifically requested 
slaves sentinels 	regex comp entry 
disconnect instance 	point searches 
free resources 	compiled pattern preg 
clear state 	whose length 
master needed 	length nmatch pmatch 
lookup 	eflags mingings 
slave master 	regexec start range 
redis instance 	meanings search 
port name 	reg noerror find 
type instance 	match reg 
function sentinel 	nomatch otherwise error 
specified 	code note 
specified master 	front end 
runid function 	functions already check 
returns asap 	ranges start 
function useful 	range start range 
sentinels address 	length check 
want 	dfa haven compiled 
old entry 	front end 
one address 	functions already check 
function returns 	initial states 
matching sentinel 	non begbuf contexts 
removed otherwise 	elements regex 
sentinel 	must anchored preg 
search instance 	newline anchor 
runid port 	never use init 
dictionary instances 	state check 
found otherwise 	must check longest 
instance pointer 	matching nmatch 
runid 	log dfa states 
search performed 	dfa pass 
non field 	nmatch dfa 
user must 	multibyte node back 
pass least 	reference node 
one search 	accept multibyte character 
param 	multi character 
master lookup 	collating element avoid 
name specified 	overflow check 
flags instances 	incrementally whether input 
specified dictionary 	match advance 
specified flags 	rapidly possible find 
instances 	plausible place 
specified dictionary 	start matching may 
reset state 	done varying 
monitored master 	efficiency various possibilities 
slaves sentinels 	common specialized 
flags resulting 	order save code 
runtime 	size use 
operations reset 	statement speed fastmap 
timers example 	fastmap single 
reset possible 	translation match 
failover master 	forward fastmap without 
asap without 	translation match 
waiting 	forward fastmap without 
failover timeout 	multi translation 
delay process 	match backwards determine 
undo failover 	easily current 
progress disconnect 	since might component 
connections master 	multibyte character 
reconnect 	use constructed buffer 
automatically failover 	instead match 
asap call 	first valid range 
sentinel reset 	reconstruct buffers 
master every 	match first buffer 
master name 	note match 
matching 	first must smaller 
specified pattern 	reconstruct buffers 
reset specified 	matcher matching 
master sentinel 	starts beginning buffer 
reset master 	consider possible 
also change 	match start part 
port 	yet isn 
address take 	head multibyte character 
name instance 	seems appropriate 
unmodified used 	one use matcher 
handle master 	matching starts 
function returns 	found match pmatch 
err 	need initialize 
address resolved 	registers points matching 
reason otherwise 	start end 
returned make 	last offset registers 
list slaves 	since slided 
back reset 	buffers could matching 
include 	starts avoid 
one address 	overflow acquire initial 
switching switching 	state must 
different address 	appropriate initial 
include old 	state depending context 
address slave 	since initial 
well 	states may constraints 
able sense 	like etc 
reconfigure old 	relatively rare calculate 
master reset 	demand must 
address slaves 	happen check whether 
back release 	regular expression 
old 	match input input 
address end 	index matching 
safe even 	end match error 
function gets 	longest match 
master addr 	means want posix 
master addr 	longest matching 
port 	match first match 
arguments non 	fails next 
zero sdown 	place may want 
odown error 	matching note 
associated instance 	matcher matching 
latest milliseconds 	starts current index 
current 	buffer initial 
master address 	state must invalid 
address address 	check open 
promoted slave 	subexp initial state 
already operational 	use later 
failing master 	processing back references 
state 	accepts reached 
already sentinel 	invalid state error 
failover state 	recover valid 
reconf slaves 	state state log 
greater means 	available already 
already configuration 	found valid even 
epoch 	longest match 
master slave 	reached halt state 
acknowledged configuration 	check halt 
advertise address 	state satisfy current 
function sets 	context found 
period field 	appropriate halt 
master 	state found match 
slaves sentinel 	modify match 
instances connected 	first check node 
master config 	match current 
handling monitor 	context check halt 
name host 	state state 
port 	match current context 
quorum milliseconds 	match node 
name milliseconds 	state halt node 
failover timeout 	match context 
name milliseconds 	node compute next 
parallel 	node nfa 
syncs name 	transit node nfa 
milliseconds notification 	nfa corresponding 
script name 	dfa destination node 
path client 	update eps 
reconfig script 	via nodes errors 
name 	pick valid 
path auth 	destination none 
pass name 	found order avoid 
password current 	infinite loop 
epoch epoch 	like second epsilon 
config epoch 	transition first 
name 	already considered otherwise 
epoch following 	push second 
update current 	epsilon transition fail 
epoch really 	stack know 
useful current 	going exit enable 
epoch persisted 	positions subexpressions 
config 	starts ends registers 
file check 	pmatch note 
redundancy leader 	pmatch already pmatch 
epoch name 	pmatch nmatch 
epoch known 	proceed next node 
slave name 	first node 
port 	sub expression 
ignore old 	last node sub 
form without 	expression non 
runid known 	empty match inside 
sentinel name 	optional subexpression 
port runid 	accept right away 
announce 	transited empty 
address announce 	match optional subexpression 
port port 	like subexp 
config rewrite 	first match copy 
sentinel option 	back old 
used rewrite 	content registers matches 
configuration 	inner subexpression 
given user 	undone well like 
configured masters 	completed subexpression 
also order 	may part optional 
retain state 	one update 
sentinel across 	prev idx match 
restarts 	function checks 
config epoch 	state log 
masters associated 	sctx last str 
slaves sentinel 	idx sift 
instances forth 	nodes states according 
sentinel unique 	following rules 
every 	updated state log 
master emit 	wrote state 
sentinel monitor 	log rules away 
config entry 	node state 
sentinel monitor 	log str idx 
sentinel milliseconds 	str idx 
sentinel 	match last last 
failover timeout 	index state 
sentinel parallel 	log isn last 
syncs sentinel 	node epsilon 
notification script 	transit last node 
sentinel client 	away node 
reconfig 	str idx match 
script sentinel 	last accepts 
auth pass 	transit isn 
sentinel config 	state log str 
epoch sentinel 	idx strlen 
leader epoch 	away node state 
sentinel 	log str 
known slave 	idx strlen thrown 
master addr 	away away 
obtained sentinel 	node str idx 
current master 	match last 
address may 	epsilon transit isn 
address 	state log 
promoted slave 	str idx away 
equal slave 	node state 
address failover 	log str idx 
progress slave 	thrown away 
already successfully 	away node build 
promoted 	sifted state 
address slave 	log str idx 
use old 	nodes epsilon 
master address 	transit last 
instead sentinel 	node last node 
known sentinel 	check states 
sentinel 	state log update 
current epoch 	counters nodes 
state valid 	satisfy following conditions 
masters sentinel 	epsilon transit 
announce sentinel 	node cur dest 
announce port 	cur src 
function 	update state log 
uses config 	build next 
rewriting redis 	sifted state build 
engine order 	next sifted 
persist state 	state cur dest 
sentinel current 	update sifted 
configuration 	states str idx 
file returning 	cur dest 
function calls 	note cur 
fsync generated 	dest sifted state 
configuration file 	state log 
make sure 	str idx cur 
changes 	src points 
committed disk 	node old state 
failure function 	log str 
logs warning 	idx epsilon nodes 
redis log 	pre filtered 
hiredis connection 	node may accept 
handling 	multi enable 
send auth 	check backreferences see 
command specified 	update cur 
master password 	sifted state helper 
needed note 	functions first 
slaves password 	nodes epsilon transit 
master 	node dest 
used check 	node check limitations 
command successfully 	current sift 
transmitted instance 	context src 
fails sentinel 	dst subexp subexp 
detect instance 	src dst 
disconnect 	subexp src subexp 
reconnect link 	dst subexp 
forth use 	unrelated limitation boundary 
client setname 	examine nodes 
name connection 	epsilon closure recurse 
redis instance 	trying reach 
sentinel 	open subexp close 
first chars 	subexp cases 
runid connection 	destination node node 
type connection 	source node 
type cmd 	recurse would cause 
pubsub specified 	infinite loop 
type 	regex exhibits behavior 
makes possible 	boundaries boundaries 
list sentinel 	outside range subexpression 
instances connected 	within subexpression 
redis servewr 	examine epsilon 
client list 	closure check limitations 
grepping 	sub expressions 
specific name 	limits nodes limitations 
format create 	dest nodes 
connections instance 	unrelated limitation check 
link link 	limitation open 
disconnected note 	subexpression note ent 
link 	subexp str 
disconnected even 	idx ent subexp 
one two 	check limitation 
links commands 	close subexpression limitation 
pub sub 	form current 
missing port 	sifted state ent 
means 	subexp str 
invalid address 	idx limitation form 
commands connection 	current sifted 
send ping 	state mark hasn 
asap reconnecting 	initialized avoid 
pub sub 	infinite loop 
subscribe 	like mctx bkref 
sentinels hello 	ents may 
channel subscribe 	changed reload pointer 
pub sub 	check node 
connection useless 	accept multi node 
simply disconnect 	accept multi 
clear 	destination already thrown 
disconnected status 	away node 
connections commands 	couldn accept current 
connection sentinel 	input multi 
instance redis 	otherwise sure node 
instances pinging 	could accept 
master 	naccepted bytes input 
looks sane 	enable functions 
actually master 	state transition next 
current configuration 	state current 
reports master 	state state 
sdown odown 	transit accepting current 
obtained 	input update 
last info 	state log necessary 
two times 	state accept 
info period 	multibyte collating element 
time ago 	back reference 
process info 	update destination state 
output 	log current 
masters cache 	state accept multibyte 
full info 	enable decide 
output instance 	next state single 
following fields 	use transition 
must reset 	table use transition 
given 	table retry 
found info 	transition table update 
output process 	state log 
line line 	need state log 
run hex 	cur idx 
chars old 	implies cur 
versions 	idx destination multibyte 
slave port 	collating element 
state versions 	back reference next 
slave port 	state destinations 
old format 	results transition table 
points start 	note already 
address 	nodes initial state 
nul term 	need need 
easy access 	check errors since 
port points 	function next 
start port 	state err already 
number nul 	check open 
term 	subexp current state 
easy access 	use later 
format points 	must check since 
start address 	back references 
port points 	next state might 
start port 	use next 
number 	state back 
nul term 	references skip bytes 
fields easy 	input correspond 
access check 	part multi match 
already slave 	look log 
table otherwise 	state restart matching 
master 	helper functions 
link since 	transit state node 
seconds seconds 	cur nodes 
role role 	pick nodes whose 
master host 	types open 
host master 	subexp corresponding back 
port 	references regular 
port master 	expression use later 
link status 	evaluating correspoding 
status slave 	back references todo 
priority priority 	isn efficient 
slave repl 	might one nodes 
offset 	whose types 
offset acting 	open subexp 
half things 	whose index subexp 
happen sentinel 	idx must 
tilt still 	check nodes next 
processed remember 	state current 
role 	state state transit 
changed log 	accepting current 
role change 	input need check 
role coherent 	errors since 
role change 	function next state 
mismatch current 	err already 
config 	many bytes node 
none following 	accept node 
conditions processed 	accepts naccepted bytes 
tilt mode 	enable check 
asap handle 	whether node backreference 
master slave 	node backreference 
role 	check substring substring 
nothing masters 	matched epsilon 
claiming slaves 	closures dest 
considered unreachable 	nodes backreference appropriate 
sentinel eventually 	state log 
failover triggered 	dest node state 
handle 	log need 
slave master 	check recursively backreference 
role promoted 	epsilon transit 
slave change 	enumerate candidates backreference 
state failover 	bkref node 
state machine 	match bkref str 
sure 	idx match 
slave reconfigured 	ctx entry note 
master master 	might collect 
configuration epoch 	inappropriate candidates however 
epoch won 	cost checking 
election perform 	strictly high delay 
failover 	checking prune 
force sentinels 	impossible nodes 
update config 	already bkref node 
assuming newer 	bkref str 
one already 	idx already sub 
available slave 	expression isn 
turned 	related first check 
master want 	last node 
force view 	sub expressions already 
reconfigure slave 	evaluated matched 
wait time 	sub expression match 
change going 	substring back 
forward 	reference enough chars 
receive configs 	successful match 
handle slaves 	need search sub 
replicating different 	expression reload 
master address 	buf since preceding 
make sure 	call might 
master 	reallocated buffer search 
sane reconfiguring 	last nodes 
instance slave 	sub expression 
detect slave 	matched sub expression 
process reconfigured 	match substring 
changed state 	back reference end 
sri 	input cannot 
reconf sent 	match need search 
sri reconf 	sub expression 
inprog sri 	state sub expression 
reconf inprog 	open subexp 
sri reconf 	node arrive close 
done 	subexp node 
discard reply 	current context helper 
use monitoring 	functions subexp 
command effects 	check sub last 
directly update 	arrive back 
instance available 	reference bkref node 
field 	bkref str 
acceptable reply 	arrive sub expression 
flag pong 	expressed sub 
received send 	top sub 
script kill 	last subexpression arrive 
command instance 	back reference 
appears 	find first node 
busy script 	whose index 
called reply 	subexp idx search 
publish command 	open search 
send master 	otherwise todo function 
advertise sentinel 	isn efficient 
update 	might one nodes 
pub time 	whose types 
actually published 	open subexp whose 
message otherwise 	index subexp 
retry milliseconds 	idx must check 
process hello 	nodes check 
message 	whether node top 
received via 	node top 
pub sub 	str arrive node 
master slave 	last node 
instance sent 	last str 
directly sentinel 	record path onto 
via 	path since 
fake publish 	heavily reused reg 
command sentinel 	noerror arrive 
master name 	reg nomatch otherwise 
specified message 	extend buffer 
known message 	need temporary modify 
discarded 	mctx setup 
format composed 	initial node fix 
tokens port 	mctx check 
runid current 	current node node 
epoch master 	last node 
name master 	helper functions check 
master 	arrival calculate 
port master 	destination nodes cur 
config epoch 	nodes str 
obtain reference 	idx append 
master hello 	next nodes todo 
message unknown 	function similar 
master 	functions transit state 
skip message 	however function 
first see 	many additional works 
already sentinel 	unify node 
sentinels runid 	may accept multi 
address change 	enable nodes 
sentinel 	cur nodes epsilon 
address back 	closures cur 
check another 	nodes however exclude 
sentinel address 	nodes inside 
one reporting 	sub expression whose 
happens port 	number subexp 
signal 	open sub expression 
address invalid 	whose number 
update later 	subexp open create 
hello message 	node nodes 
means invalid 	nodes epsilon 
address sentinel 	closures node cur 
runid 	nodes problematic 
instance creation 	nodes merge problematic 
sentinels later 	nodes calculate 
chance fill 	incrementally helper function 
update local 	check arrival 
current epoch 	expand ecl check 
received 	incrementally epsilon 
current epoch 	closure target isn 
greater update 	problematic append 
master info 	dst nodes back 
received configuration 	references current 
newer update 	state calculate destination 
state 	back references 
sentinel pub 	appropriate entry mctx 
sub callback 	bkref ents 
hello channel 	entry ent appropriate 
useful order 	calculate destination 
discover sentinels 	back reference 
attached 	append mctx state 
master update 	log backreference 
last activity 	epsilon transit must 
pubsub channel 	check node 
note since 	current state todo 
receive messages 	still inefficient 
well 	build transition table 
timestamp used 	state succeeded 
detect link 	otherwise number destination 
probably disconnected 	states state 
even seems 	build dfa states 
otherwise sanity 	corresponds destination 
check 	nodes state dests 
reply expect 	node represents 
code follows 	nodes destination state 
avoid check 	contains dests 
details interested 	represents characters destination 
meeting send 	state accepts 
hello 	initialize transiton 
message via 	table first nodes 
pub sub 	belonging state 
specified redis 	several destinations error 
instance order 	otherwise avoid 
broadcast current 	arithmetic overflow size 
configuraiton 	calculation build 
master advertise 	states destinations merge 
existence sentinel 	follows destination 
time message 	states state context 
following format 	constraint build 
sentinel sentinel 	appropriate states contexts 
port 	care whether 
sentinel runid 	following character word 
current epoch 	character single 
master name 	character discern looking 
master master 	character code 
port master 	allocate entry 
config 	transition table characters 
epoch returns 	must exactly 
publish queued 	one destination accepts 
correctly otherwise 	character see 
err returned 	nodes astates destination 
use specified 	accepts word 
announce 	character care whether 
address specified 	following character 
otherwise obtain 	word character multi 
address format 	character discern 
send hello 	looking character code 
message info 	build two 
sentinel 	entry transition tables 
info current 	one starting 
master reset 	trtable one starting 
last pub 	trtable sbc 
time instances 	max characters must 
specified 	exactly one 
dictionary order 	destination accepts 
force delivery 	character see nodes 
hello update 	astates destination 
asap function 	accepts word character 
forces delivery 	line current 
hello 	state accepts newline 
message see 	character destination 
sentinel send 	accepts newline character 
hello top 	must one 
comment information 	destination accepts newline 
redis sentinel 	see nodes 
instances 	astates nodes belonging 
related specified 	state several 
master technically 	destinations destinations nodes 
needed since 	belonging destination 
send update 	dests node characters 
every instance 	accepted destination 
period 	dest function number 
sentinel publish 	destinations number 
period milliseconds 	destinations state 
however sentinel 	characters node accept 
upgrades configuration 	nodes belonging 
good idea 	state enumerate single 
deliever 	character node 
update sentinels 	accept check accepts 
asap send 	sift characters 
ping specified 	match context divide 
instance refresh 	accepts dfa 
act ping 	states create state 
time 	make sure 
zero received 	accepts empty intersection 
pong previous 	sets see 
ping error 	flags see optimization 
zero returned 	skip state 
consider ping 	doesn accept character 
command 	enumerate intersection 
queued connection 	state accepts skip 
update active 	intersection empty 
ping time 	check state 
received pong 	subset accepts state 
previous ping 	isn subset 
otherwise 	accepts create state 
technically waiting 	remains put 
since first 	position current characters 
ping received 	consumed next 
reply send 	node characters remain 
periodic ping 	create check 
info 	many bytes node 
publish hello 	dfa nodes 
channel specified 	node idx accepts 
master slave 	number bytes 
instance asap 	node accepts str 
already ping 	idx current 
info 	index input function 
already pending 	handles nodes 
instance properly 	accept one character 
connected info 	one collating 
ping publish 	element like 
critical commands 	opposite nodes accept 
send 	one fixme 
also limit 	think needed len 
sentinel max 	accepts one 
pending commands 	character following two 
want use 	cases libc 
lot memory 	match multibyte character 
link 	match character 
working properly 	include defines local 
note anyway 	function match 
redundant protection 	collating symbol compare 
link disconnected 	length input 
reconnected timeout 	collating element length 
condition 	current collating 
detected slave 	element compare bytes 
master condition 	match every 
start sending 	bytes equal 
info every 	match range expression 
second instead 	match equivalence 
usual 	libc match range 
sentinel info 	expression valid 
period period 	character match single 
state want 	character skip 
closely monitor 	name collating element 
slaves turned 	name found 
masters 	entry skip sequence 
another sentinel 	collating element 
sysadmin ping 	adjust alignment skip 
instances every 	collation sequence 
time last 	skip wide sequence 
received pong 	collating element 
older 	found entry sequence 
configured milliseconds 	skip collation 
time every 	sequence libc enable 
second anyway 	check whether 
milliseconds greater 	node accepts 
second send 	idx input fallthrough 
info 	node constraints 
masters slaves 	check whether current 
sentinels send 	context satisfies 
ping three 	constraints extend buffers 
kinds instances 	buffers run 
publish hello 	avoid overflow lengthes 
messages 	buffers length 
three kinds 	state log xxx 
instances sentinel 	indication size 
command redis 	buffer allocation fail 
instance redis 	indication state 
protocol representation 	log right size 
last 	reconstruct buffers 
masters slaves 	enable enable functions 
masters slaves 	matching context 
sentinels output 	initialize mctx already 
number instances 	zero caller 
contained inside 	mctx bkref 
dictionary 	ents mctx nbkref 
redis protocol 	ents mctx 
lookup named 	nsub tops clean 
master sentinel 	entries depend 
masters master 	current input mctx 
found reply 	function must 
client 	invoked matcher changes 
error returns 	start index 
number usable 	input changes input 
sentinels init 	free memory 
count known 	associated mctx first 
sentinels sentinel 	free memory 
masters 	associated mctx sub 
sentinel master 	tops backreference 
name sentinel 	entry mctx note 
slaves master 	caller never 
name sentinel 	call function duplicate 
sentinels master 	entry call 
name 	str idx 
sentinel master 	isn smaller existing 
addr port 	entry cache 
current epoch 	saves negative results 
runid arguments 	check dst 
port port 	limits calc pos 
master 	bit clear 
want sentinel 	means entry won 
note command 	epsilon transition 
check name 	open subexp close 
master theory 	subexp subexpression 
different sentinels 	check dst limits 
may 	calc pos 
monitor differnet 	recurse find one 
masters name 	node backreference 
current epoch 	epsilon transition unless 
needed order 	empty zeros 
understand allowed 	search first 
vote 	entry str idx 
failover leader 	none found 
sentinel vote 	note mctx bkref 
one time 	ents already 
per epoch 	sorted mctx str 
runid seeking 	idx node 
vote 	node whose type 
sentinel order 	open subexp 
elect failover 	matches str idx 
leader otherwise 	node node 
runid want 	whose type close 
sentinel vote 	subexp matches 
already 	str idx whose 
voted exists 	corresponding open 
actually master 	subexp sub top 
subjectively note 	regex internalc 
tilt mode 	function function function 
always reply 	pstr str 
vote 	len init 
master fetch 	len trans icase 
previous vote 	dfa ret 
request includes 	init buf len 
runid otherwise 	pstr str 
sender seeking 	len trans icase 
vote 	dfa ret 
reply three 	pstr buf len 
elements multi 	wcs max 
bulk reply 	size offsets mbs 
state leader 	str len 
vote epoch 	pstr trans icase 
sentinel 	dfa pstr 
reset pattern 	buf buf prev 
sentinel master 	idx end 
addr name 	idx remain len 
master name 	mbclen pstr 
sentinel failover 	prev src idx 
master 	idx end 
name sentinel 	idx remain 
pending scripts 	len mbclen buf 
sentinel monitor 	buf wcu 
name port 	mbcdlen wcu mbcdlen 
quorum make 	pstr raw 
sure 	idx last prev 
field actually 	rawbuf idx 
valid passing 	mbclen remain len 
create sentinel 	pstr idx 
redis instance 	end idx pstr 
otherwise may 	buf idx 
trigger 	end idx pstr 
dns lookup 	idx eflags 
runtime parameters 	offset mid prev 
valid create 	valid len 
master instance 	wcs idx raw 
sentinel name 	end cur 
sentinel 	state mlen buf 
ckquorum name 	mbclen ret 
sentinel info 	peek fetch 
cache name 	pstr input idx 
create hoc 	eflags idx 
dictionary type 	size elem elem 
iterate 	elem dest 
dictionary composed 	src dest src 
master groups 	src delta 
user requested 	sbase alloc elems 
ignore non 	dest src 
existing names 	src dest src 
reply 	sbase delta 
format master 	alloc buffer elem 
name info 	idx elems 
master info 	elem elems node 
replica master 	compare node 
name self 	contains idx dfa 
sentinel 	token nodes 
simulate failure 	alloc nexts 
flag flag 	indices edests eclosures 
flag sentinel 	nodes max 
info section 	size nodes context 
sentinel verison 	hash err 
role 	dfa nodes hash 
command output 	state spot 
sentinel list 	state err dfa 
currently monitored 	nodes context 
master names 	hash state spot 
sentinel mastername 	state dfa 
option 	newstate hash spot 
process option 	err elem 
pairs millisecodns 	alloc state dfa 
milliseconds failover 	nodes hash 
timeout milliseconds 	err newstate node 
parallel syncs 	type dfa 
milliseconds 	nodes context hash 
notification script 	nctx nodes 
path client 	err newstate 
reconfig script 	node type constraint 
path auth 	construct common 
pass password 	realloc buffers memset 
quorum 	construct common 
count bad 	realloc buffers build 
format errors 	wcs upper 
fake publish 	buffer realloc buffers 
command actually 	build upper 
useful receive 	buffer build wcs 
hello 	buffer translate 
messages sentinel 	buffer max realloc 
instances publishing 	realloc mbrtowc 
channel sentinel 	isascii mbsinit toupper 
hello channel 	mbrtowc iswlower 
forbidden sentinel 	towupper wcrtomb memcpy 
publish 	memcpy mbrtowc 
code send 	iswlower towupper wcrtomb 
hello messages 	memcpy malloc 
three kind 	memcpy memcpy 
instances masters 	memcpy mbrtowc islower 
slaves sentinels 	toupper memset 
sentinel 	context memmove memmove 
availability checks 	memset context 
instance point 	memmove memmove isascii 
view check 	memset memset 
need reconnection 	mbrtowc memset skip 
one links 	chars context 
detecting 	wide word wide 
low activity 	newline memset 
check command 	bitset contain newline 
link seems 	build wcs 
connected connected 	upper buffer build 
less sentinel 	wcs buffer 
min 	build upper buffer 
link reconnect 	translate buffer 
period still 	free free free 
pending ping 	wide word 
half timeout 	wide newline 
ther pending 	bitset contain newline 
ping 	memset malloc 
pending ping 	malloc malloc malloc 
delayed received 	memcpy node 
error replies 	init empty realloc 
well check 	memcpy malloc 
pubsub link 	node init copy 
seems 	node init 
connected connected 	copy node init 
less sentinel 	empty memcpy 
min link 	memcpy realloc memcpy 
reconnect period 	memcpy memcpy 
still activity 	node init realloc 
pub 	realloc max 
sub channel 	max realloc realloc 
sentinel publish 	realloc realloc 
period update 	realloc node init 
sdown flag 	empty node 
believe instance 	init empty 
sdown 	calc state hash 
replying believe 	node compare 
master reports 	create newstate calc 
slave enough 	state hash 
time meet 	node compare create 
period plus 	newstate node 
enough 	alloc epsilon node 
time two 	node insert 
times info 	last realloc node 
report instance 	free node 
subjectively subjectively 	free node free 
instance according 	free node 
configured 	free free free 
quorum note 	free calloc 
odown weak 	node init copy 
quorum means 	free state 
enough sentinels 	free state 
reported given 	calloc node init 
time 	copy free 
range instance 	malloc free state 
reachable however 	node init 
messages delayed 	copy satisfy prev 
strong guarantees 	constraint node 
instances agreeing 	state free state 
time 	extended regular 
state enough 	expression matching search 
sentinels current 	library copyright 
sentinel count 	free software foundation 
sentinels flag 	inc file 
accordingly outcome 	part gnu library 
receive 	contributed isamu 
sentinel master 	hasegawa isamu yamato 
addr reply 	ibm gnu 
see sentinel 	library free software 
ask master 	redistribute modify 
state sentinels 	terms gnu 
function 	lesser general license 
information ignore 	published free 
every error 	software foundation either 
unexpected reply 	version license 
note command 	option later version 
returns error 	gnu library 
reason 	distributed hope useful 
end clearing 	without warranty 
sri master 	without even implied 
flag timeout 	warranty merchantability 
anyway runid 	fitness particular purpose 
reply sentinel 	see gnu 
actually 	lesser general license 
replied vote 	details received 
think master 	copy gnu lesser 
start sending 	general license 
sentinel master 	along gnu library 
addr requests 	write free 
sentinels 	software foundation 
order replies 	inc franklin street 
allow reach 	fifth floor 
quorum needed 	boston usa safety 
mark master 	functions operation 
odown state 	function allocate buffers 
trigger 	necessary call 
failover master 	reconstruct ensure least 
state sentinel 	one character 
old clear 	fits buffers function 
ask master 	allocate buffers 
sentinels believe 	initialize enable enable 
failover 	helper functions 
progress sentinel 	allocate construct avoid 
connected received 	overflow realloc 
info within 	enable build wide 
sentinel ask 	character buffer 
period ask 	pstr wcs sequence 
failover 	wide character 
crash user 	buffer weof 
request via 	weof use weof 
sentinel simulate 	padding indicate 
failure command 	position isn first 
vote sentinel 	multibyte character 
req 	note function assumes 
runid old 	pstr valid 
vote already 	len elements already 
voted specifed 	built starts 
req epoch 	pstr valid len 
one greater 	build buffers 
vote 	pstr valid len 
available returns 	either pstr 
otherwise sentinel 	len pstr bufs 
runid populate 	len apply 
leader epoch 	translation need buffer 
epoch vote 	doesn enough 
voted 	space finish 
master failover 	build treat cases 
start time 	singlebyte character 
order force 	write wide character 
delay start 	padding write 
failover master 	paddings build wide 
helper 	character buffer 
function sentinel 	pstr wcs like 
leader increment 	build wcs 
counter relative 	buffer reg icase 
specified runid 	following optimization 
scan sentinels 	assumes ascii characters 
attached 	mapped wide 
master check 	characters simple cast 
leader specified 	singlebyte character 
epoch leader 	next step uses 
given epoch 	assumption wchar 
majority sentinels 	encoded ascii safe 
know 	ascii values 
ever seen 	converted like 
since last 	write paddings invalid 
sentinel reset 	character use 
reported instance 	also cast wide 
leader epoch 	buffer doesn 
sentinels 	enough space finish 
count sentinels 	build write 
votes check 	paddings invalid character 
winner winner 	use also 
win needs 	cast wide buffer 
two conditions 	doesn enough 
absolute 	space finish build 
majority voters 	skip characters 
anyway least 	index becomes greater 
master quorum 	raw idx 
votes count 	index skip characters 
sentinel vote 	necessary check 
sentinel 	treat cases single 
voted yet 	character proceed 
either vote 	next character 
common voted 	enable build buffer 
sentinel vote 	pstr mbs 
exists send 	apply translation need 
slaveof 	function used 
specified instance 	reg icase apply 
always followed 	trans buffer 
config rewrite 	pstr function construct 
command order 	buffers concretely 
store 	convert wide character 
configuration disk 	pstr cur 
possible redis 	max convert upper 
instance recent 	reg icase 
enough support 	apply translation reset 
config rewriting 	buffer enable 
server 	already characters kept 
started configuration 	yes move 
file host 	front buffer quite 
function sends 	complicated handle 
slaveof one 	specially common 
command returns 	easy character different 
slaveof 	length representation 
command accepted 	lower upper present 
later delivery 	offset otherwise 
otherwise err 	find multibyte character 
command replies 	offset fill 
discarded host 	weof enable skip 
send 	characters idx 
slaveof one 	special utf multi 
turn instance 	chars start 
master order 	xbf know wchar 
send slaveof 	encoding ucs 
safe way 	simple ascii characters 
send 	skip conversion 
transaction performing 	step pstr valid 
following tasks 	len xxx 
reconfigure instance 	use mbrtowc 
according specified 	know conversion use 
host port 	utf ucs 
rewrite 	enable build buffers 
configuraiton disconnect 	enable handle 
clients one 	common easiest cases 
sending commnad 	first ensure 
order trigger 	utf backslash dotless 
ask master 	small letter 
reconnection 	function returns capital 
protocol connected 	letter instead 
clients note 	first dotless small 
check replies 	letter latter 
returned commands 	would confuse parser 
since observe 	since peek 
instead 	doesn advance cur 
effects next 	idx way 
info output 	utf islower capital 
client kill 	letter dot 
type type 	lower mbs 
supported starting 	skip whole multi 
redis 	character original 
however sending 	letter side dotless 
instance understanding 	small letter 
command issue 	anything would complicate 
client variadic 	things much 
command redis 	enable context idx 
recognized 	input use 
syntax error 	stored input tip 
transaction fail 	context since 
unsupported command 	know character input 
fail setup 	mbs must 
master state 	happen functions operation 
start 	adr valgrind 
failover function 	says size doesn 
checks conditions 	free block 
start failover 	size harumph seems 
master must 	work though 
odown condition 	calculate intersection 
failover 	sets src src 
already progress 	merge dest 
failover already 	indicate error code 
attempted recently 	reg noerror 
still know 	succeeded note dest 
win election 	elems dest 
possible 	alloc need dest 
start failover 	nelem elems 
able act 	intersection conservative estimate 
non zero 	find items 
failover started 	intersection src src 
failover master 	copy top 
state 	dest already dest 
failover already 	find item 
progress last 	dest maybe could 
failover attempt 	binary search 
started little 	lower highest two 
time ago 	items copy 
newline 	delta becomes 
suitable slave 	zero remaining dest 
promote current 	elements already 
algorithm uses 	place less loop 
following parameters 	node merge 
none following 	copy top slide 
conditions 	bottom copy 
disconnected last 	remaining src elements 
time slave 	calculate sets 
replied ping 	src src store 
times ping 	dest indicate 
period info 	error code reg 
refresh 	noerror succeeded 
older times 	calculate sets dest 
info refresh 	src store 
period master 	dest indicate error 
link time 	code reg 
master since 	noerror succeeded copy 
time 	top dest 
master period 	items src 
basically since 	found dest maybe 
master pov 	could binary 
slave reports 	search dest dest 
disconnected times 	elems src 
configured 	elems dest exhausted 
period pretty 	remaining items 
much black 	src must unique 
magic idea 	copy delta 
master available 	becomes zero remaining 
slave may 	dest elements 
lagging 	already place copy 
certain time 	top slide 
anyway best 	bottom copy remaining 
slave according 	src elements 
replication offset 	insert element elem 
slave priority 	node already 
zero 	elem error 
otherwise slave 	occurred otherwise empty 
discarded among 	already guaranteed 
slaves matching 	alloc realloc need 
conditions slave 	move elements 
order sorting 	follows element test 
key 	first element 
lower slave 	separately skip check 
priority bigger 	inner loop 
processed replication 	insert element insert 
offset lexicographically 	element elem 
smaller runid 	node already element 
basically 	greater equal 
runid slave 	elem error occurred 
processed commands 	otherwise realloc 
master selected 	need insert element 
function returns 	compare two 
pointer selected 	node sets equivalent 
slave 	otherwise idx 
otherwise suitable 	contains element 
slave found 	elem otherwise binary 
helper sentinel 	search element 
slave used 	token token dfa 
qsort order 	nodes index 
sort 	token error occurred 
suitable slaves 	avoid overflows 
better first 	realloc search state 
order take 	whose node 
first list 	equivalent nodes pointer 
priority slave 	state found 
greater 	dfa otherwise create 
replication offset 	one error 
processed data 	error code err 
frmo master 	note invalid 
replication offset 	state possible err 
slave lexicographically 	reg noerror 
smaller 	never non errors 
runid note 	optimization appropriate 
handle runid 	state dfa 
old redis 	create one search 
versions publish 	state whose 
runid info 	node equivalent nodes 
runid 	whose context 
considered bigger 	equivalent context pointer 
runid master 	state found 
sdown state 	dfa otherwise create 
info slaves 	one error 
every second 	error code err 
otherwise 	note invalid 
usual period 	state possible err 
need account 	reg noerror 
larger delay 	never non errors 
failover state 	optimization appropriate 
machine implementation 	state dfa create 
check 	one finish 
leader failover 	initialization state newstate 
epoch leader 	hash hash 
forced failover 	put appropriate 
via sentinel 	bucket dfa state 
failover failover 	table indicates 
election 	error code failed 
timeout min 	create state 
sentinel election 	independ contexts state 
timeout configured 	succeeded otherwise 
failover timeout 	enable state halt 
abort failover 	node state 
leader 	halt state create 
time handle 	state depend 
timeout state 	context context state 
function aborts 	succeeded otherwise 
failover forward 	enable state halt 
next state 	node state 
send 	halt state regex 
command promoted 	internalh attribute 
slave disconnected 	hidden attribute 
retry state 	hidden raw mbs 
timeout reached 	mbs wcs 
abort failover 	offsets cur state 
send 	raw mbs 
slaveof one 	idx valid len 
command turn 	valid raw 
slave master 	len bufs len 
actually callback 	cur idx 
command really 	raw len len 
care 	raw stop 
reply check 	stop tip context 
worked indirectly 	trans word 
observing info 	icase utf map 
returns different 	notascii mbs 
role master 	allocated offsets needed 
instead 	newline anchor 
slave actually 	word ops used 
wait promotion 	cur max 
indirectly checking 	pstr buf 
info slave 	len pstr pstr 
turns master 	pstr pstr 
handle 	attribute parent left 
timeout switching 	right first 
next state 	next token node 
handled function 	idx next 
parsing info 	data hash nodes 
command promoted 	non eps 
slave 	nodes inveclosure entrance 
consider failover 	nodes trtable 
finished promoted 	word trtable num 
slave reachable 	alloc node 
failover terminates 	str idx subexp 
reachable slaves 	subexp unused 
properly 	eps reachable subexps 
configured force 	map idx 
end failover 	node regs eps 
timeout leader 	via nodes 
good idea 	num alloc 
send best 	stack nodes nodes 
effort 	alloc nodes 
slaveof command 	len nexts indices 
slaves still 	edests eclosures 
reconfigured replicate 	inveclosures state table 
master send 	init state 
slave master 	init state word 
address 	init state 
remaining slaves 	init state begbuf 
still appear 	str str 
configuration updated 	storage str storage 
skip promoted 	idx state 
slave already 	hash mask init 
configured 	node nbackref 
slaves much 	used bkref map 
time elapsed 	completed bkref 
without slave 	map cur max 
moving forward 	word syntax 
next state 	subexp map 
consider 	str bitset dest 
reconfigured even 	src bitset 
sentinels detect 	dest src bitset 
slave misconfigured 	size wchar 
fix configuration 	elem size extended 
later nothing 	regular expression 
instances 	matching search library 
disconnected already 	copyright free 
reconf sent 	software foundation inc 
state send 	file part 
slaveof master 	gnu library contributed 
check slaves 	isamu hasegawa 
reconfigured 	isamu yamato ibm 
handle timeout 	gnu library 
function called 	free software redistribute 
slave sentinel 	modify terms 
failover state 	gnu lesser 
update config 	general license published 
state 	free software 
state need 	foundation either version 
master table 	license option 
promoted slave 	later version gnu 
instead abort 	library distributed 
failover progress 	hope useful without 
function 	warranty without 
called promoted 	even implied warranty 
slave acknowledged 	merchantability fitness 
slave master 	particular purpose see 
otherwise failover 	gnu lesser 
aborted reach 	general license details 
end 	received copy 
possibly timeout 	gnu lesser general 
sentinel timer 	license along 
handler main 	gnu library write 
sentinel sentinel 	free software 
completely non 	foundation inc 
blocking 	temple place suite 
design function 	boston usa 
called every 	wchar libc wctype 
second perform 	libc stdbool 
scheduled operations 	libc stdint libc 
specified redis 	zos uss 
instance 	system doesn isblank 
monitoring half 	gawk freaking 
every kind 	mess glibc systems 
instance acting 	define magic 
half proceed 	constant isblank ctype 
acting half 	since function 
tilt 	heck borrow page 
mode tilt 	dfa book 
happens find 	gawk gnu distributions 
something odd 	internationalized messages 
time like 	define xgettext find 
sudden change 	internationalizable loser 
clock 	systems without 
every kind 	definition gawk number 
instance masters 	single character 
slaves nothing 	character represents newline 
far masters 	rename standard 
perform scheduled 	api glibc gawk 
operations 	libc integer 
instances dictionary 	used represent bits 
recursively call 	must must 
function dictionaries 	least wide bits 
slaves number 	bitset word 
things need 	number bits bitset 
perform 	word number 
every master 	bitset word bit 
function checks 	node type 
need enter 	used token node 
titl mode 	enable define 
tilt mode 	epsilon bit macro 
entered 	open subexp 
detect two 	used debugger 
invocations timer 	shows values type 
interrupt negative 	type used 
amount time 	token type used 
much time 	token multibyte 
passed 	characters collating symbols 
note expect 	equivalence classes 
less milliseconds 	range expressions libc 
pass everything 	libc character 
fine however 	classes character non 
see negative 	matching list 
number 	multibyte characters collating 
difference bigger 	symbols equivalence 
sentinel tilt 	classes range expressions 
trigger milliseconds 	character classes 
one following 	enable character simple 
conditions happen 	bracket complex 
sentiel 	bracket enable back 
process time 	anchor context 
blocked every 	constraint bits 
kind random 	moved needed running 
reason load 	bits move 
huge computer 	opr opr move 
frozen 	flags opr 
time alike 	flags indicate raw 
process stopped 	buffer original 
signal everything 	passed argument regexec 
system clock 	search etc 
altered significantly 	store multibyte insensitive 
conditions 	mode like 
see everything 	reg icase upper 
timed failing 	cases stored 
without good 	otherwise mbs points 
reasons instead 	address raw 
enter tilt 	mbs points store 
mode 	wide character 
wait sentinel 	corresponding mbs 
tilt period 	index raw mbs 
elapse starting 	character mbs 
act tilt 	corresponds raw mbs 
time still 	raw mbs 
collect 	idx length valid 
information act 	characters buffers 
continuously change 	corresponding number bytes 
frequency redis 	raw mbs 
timer interrupt 	length buffers mbs 
order desynchronize 	wcs index 
every 	mbs updated fetch 
sentinel every 	length raw 
non determinism 	mbs raw len 
avoids sentinels 	raw mbs 
started time 	idx valid len 
exactly stay 	valid raw 
asking 	len end buffer 
voted time 	may shorter 
resulting nobody 	length cases 
likely winning 	match search use 
election split 	stop end 
brain voting 	buffer instead len 
server.c 	raw stop 
shared zero 	raw mbs idx 
pos inf 	adjusted offsets 
neg inf 	context mbs store 
nan server 	context independently 
redis command 	since context mbs 
table 	may different 
level msg 	raw mbs beginning 
syslog level 	input translation 
map buf 	passed part argument 
rawmode log 	compile pattern 
stdout role 	copy dfa word 
pid 	reg icase 
level fmt 	enable usually guarantees 
msg level 	one guard 
msg log 	page bottom 
stdout buf 	stack page size 
ust retcode 	small bytes 
privdata 	cannot safely allocate 
val privdata 	anything larger 
val privdata 	bytes also care 
key key 	possibility compiler 
privdata key 	allocated temporary stack 
key privdata 	slots alloca 
val 	implemented malloc use 
privdata val 	malloc sun 
privdata key 	realloc doesn accept 
key key 	pointers pre 
key key 	standard sigh node 
privdata key 	idx index 
key 	dfa nodes type 
cmp key 	otherwise type 
buf len 	indicate type node 
hash dict 	state accept 
type zset 	multi note 
dict type 	refer multibyte characters 
dict 	multi character 
type sha 	collating elements multi 
script dict 	state backreference 
type keyptr 	node type used 
dict type 	sub match 
command table 	last sub match 
dict 	top store 
type hash 	information node node 
dict type 	whose type 
keylist dict 	close subexp position 
type cluster 	node match 
nodes 	store information node 
dict type 	node whose 
cluster nodes 	type open subexp 
black list 	information node 
dict type 	whose type 
migrate cache 	close subexp corresponding 
dict 	node stored 
type repl 	lasts allocation size 
script cache 	lasts number 
dict type 	lasts corresponding input 
dict size 	eflags argument 
used dbid 	regexec matching ends 
dbid 	state log 
key keyobj 	used matcher back 
type current 	reference cache 
timelimit exit 	number subexpressions nsub 
last fast 	regex number 
cycle iteration 	backreference dfa bitmap 
dbs 	expressing backreference 
per call 	used dfa multibyte 
timelimit expired 	node backreference 
num slots 	node accept multibyte 
ttl sum 	character multi 
ttl samples 	character collating 
ttl 	element functions bitset 
avg ttl 	operation functions 
elapsed metric 	libc enable regex 
current reading 	remote-curl.c remote 
ops ops 	url verbosity depth 
sec metric 	options cas 
sum 	options name end 
querybuf size 	end val 
idletime numclients 	service buf alloc 
iterations head 	buf len 
resize rehash 	refs shallow last 
dbs per 	discovery heads 
call 	push list heads 
work done 	data start 
loop client 	mid name refs 
data size 	last type 
used vkeys 	charset msg eol 
statloc pid 	service push 
exitcode 	exp type 
bysignal growth 	charset buffer refs 
loop argv 	url effective 
dictid str 	url last http 
dictid len 	ret maybe 
environ flags 	smart options line 
delay 	push heads 
maxfiles limit 	refs posn service 
oldlimit bestlimit 	name argv 
setrlimit error 	stdin preamble service 
decr step 	url hdr 
old maxclients 	content type hdr 
buf 	accept buf 
somaxconn port 	alloc len pos 
fds count 	result ptr 
numcommands retval 	eltsize nmemb buffer 
retval numcommands 	max rpc 
cmd dbid 	avail handle cmd 
argv 	clientp rpc 
argc target 	ptr eltsize 
name cmd 	nmemb buffer size 
name name 	rpc slot 
cmd cmd 	results err results 
dbid argv 	buf msg 
argc 	rpc results slot 
flags cmd 	headers buf 
dbid argv 	err rpc slot 
argc target 	headers use 
argvcopy flags 	gzip gzip body 
flags dirty 	gzip size 
start 	err large request 
duration client 	needs left 
old flags 	buf results stream 
latency propagate 	ret rpc 
flags rop 	heads svc buf 
target hashslot 	preamble client 
error 	err buf 
code retval 	heads fetch walker 
unlink unix 	targets ret 
socket flags 	heads heads fetch 
save nosave 	rpc preamble 
bufa bufb 	depth arg err 
alen 	argv buf 
blen diff 	heads fetch buf 
cmd reply 	fetch list 
cmd flagcount 	head list heads 
flaglen cmd 	name old 
keys numkeys 	oid spec specs 
section 	child heads 
info uptime 	spec specs rpc 
numcommands self 	err args 
lol bib 	cas option preamble 
defsections sections 	spec specs 
call uname 	heads ret buf 
name 	specs ret 
mode hmem 	argc argv 
peak hmem 	buf nongit arg 
total system 	push result 
hmem used 	strcmp strtol strcmp 
memory lua 	strcmp strcmp 
hmem 	strcmp strtoul strcmp 
used memory 	strcmp strcmp 
rss hmem 	strcmp strcmp strcmp 
maxmemory hmem 	strcmp strcmp 
zmalloc used 	strcmp strcmp strbuf 
total system 	addf list 
mem 	append strbuf release 
evict policy 	strcmp strcmp 
memory lua 	strcmp strcmp strcmp 
perc eta 	strcmp strcmp 
elapsed remaining 	strcmp strcmp strcmp 
bytes slave 	strcmp strcmp 
repl 	strcmp strcmp remote 
offset slaveid 	heads die 
slave state 	alloc oid 
port lag 	hex alloc http 
keys vkeys 	fetch resolve 
section sampledict 	remote symref free 
keydict 	free free 
pool count 	free refs free 
samples samples 	strcmp strbuf 
idle key 	reencode log output 
mem used 	encoding strbuf 
mem tofree 	trim strchrnul strcmp 
mem 	free discovery 
freed slaves 	strbuf addf starts 
latency eviction 	starts git 
latency slave 	env strchr strbuf 
obuf bytes 	addch strbuf 
keys freed 	addch strbuf addf 
bestval 	memset http 
bestkey dict 	strbuf show http 
pool thiskey 	message die 
thisval delta 	show http 
keyobj buf 	message die show 
buf mode 	http message 
sig 	die xcalloc strbuf 
msg act 	detach strbuf 
megabytes passes 	addf strbuf cmp 
argc argv 	packet read 
start allocation 	line buf strbuf 
size title 	reset strbuf 
server 	addf strcmp die 
mode upstart 	strbuf release 
job notify 	packet read line 
socket iov 	buf parse 
hdr sendto 	git refs parse 
flags mode 	info refs 
upstart 	strbuf release strbuf 
job notify 	release strbuf 
socket argc 	release strbuf release 
argv options 	strbuf release 
configfile background 	strbuf release 
fopen getpid 	discover refs discover 
gettimeofday 	refs oid 
strftime localtime 	hex fflush packet 
snprintf getpid 	read memcpy 
fflush fclose 	error write die 
syslog start 	run one 
vsnprintf end 	slot strbuf addf 
server 	strbuf addch 
log raw 	strbuf addf strbuf 
open getpid 	addch strbuf 
write strlen 	addstr error strbuf 
write time 	release active 
write strlen 	slot curl slist 
write 	append curl 
write strlen 	slist append curl 
write close 	easy setopt 
gettimeofday ustime 	curl easy 
exit exit 	setopt curl easy 
dict notused 	setopt curl 
zfree 	easy setopt curl 
dict notused 	easy setopt 
list release 	curl easy setopt 
dict notused 	curl easy 
sdslen sdslen 	setopt curl easy 
memcmp dict 	setopt curl 
notused 	easy setopt run 
strcasecmp dict 	slot curl 
notused decr 	slist free strbuf 
count dict 	release packet 
notused sdsfree 	read probe rpc 
dict sds 	credential fill 
key 	curl slist append 
compare dict 	curl slist 
gen hash 	append curl slist 
function sdslen 	append active 
dict gen 	slot curl 
hash function 	easy setopt curl 
sdslen 	easy setopt 
dict gen 	curl easy setopt 
hash function 	curl easy 
sdslen decoded 	setopt curl slist 
decoded dict 	append curl 
sds key 	easy setopt curl 
compare 	easy setopt 
decr count 	curl easy setopt 
decr count 	curl easy 
sds encoded 	setopt fflush curl 
dict gen 	easy setopt 
hash function 	curl easy setopt 
sdslen 	git deflate 
dict gen 	init gzip git 
hash function 	deflate bound 
decoded dict 	xmalloc git deflate 
gen hash 	die git 
function sdslen 	deflate end 
decr 	gently die curl 
count dict 	slist append 
slots dict 	curl easy setopt 
size needs 	curl easy 
resize dict 	setopt fflush curl 
resize needs 	easy setopt 
resize 	curl easy setopt 
dict resize 	fflush curl 
dict rehashing 	easy setopt curl 
dict rehash 	easy setopt 
milliseconds dict 	curl easy setopt 
rehashing dict 	run slot 
rehash 	credential fill curl 
milliseconds dict 	slist free 
enable resize 	free start command 
dict disable 	exit write 
resize dict 	die write die 
integer val 	xmalloc strbuf 
dict 	init strbuf 
key create 	addf strbuf detach 
sdslen propagate 	strbuf addf 
expire notify 	strbuf detach strbuf 
keyspace decr 	addf strbuf 
count ustime 	detach packet read 
dict 	post rpc 
size dict 	close strbuf read 
slots mstime 	xread close 
dict random 	finish command free 
key dict 	free free 
integer val 	free strbuf release 
active 	alloc die 
expire cycle 	xstrdup oid hex 
expire ustime 	http walker 
latency sample 	walker fetch walker 
needed mstime 	free free 
mstime mstime 	free error 
server 	strbuf addf strbuf 
log free 	detach die 
client reply 	packet buf write 
blocked client 	oid hex 
timed unblock 	packet buf flush 
client cluster 	memset rpc 
redirect 	service write die 
blocked client 	strbuf release 
needed unblock 	strbuf release free 
client sds 	discover refs 
alloc size 	fetch git fetch 
sdsavail sds 	dumb skip 
free 	prefix oid hex 
space list 	die die 
length mstime 	alloc oidcpy alloc 
list length 	grow die 
list rotate 	strbuf reset strbuf 
list first 	getline fetch 
list 	exit free 
node clients 	refs free fflush 
cron handle 	strbuf reset 
timeout clients 	argv push argv 
cron resize 	push argv 
query buffer 	push argv push 
active 	argv push 
expire cycle 	argv push run 
resize hash 	command die 
tables incrementally 	argv init argv 
rehash time 	pushl argv 
mstime unused 	push argv push 
unused 	argv push 
unused watchdog 	argv push argv 
schedule signal 	push argv 
update cached 	push argv push 
time track 	argv push 
instantaneous metric 	argv push argv 
track 	push packet 
instantaneous metric 	buf write 
track instantaneous 	packet buf flush 
metric lru 	memset rpc 
clock zmalloc 	service write die 
used memory 	strbuf release 
zmalloc 	strbuf release argv 
used memory 	clear discover 
zmalloc rss 	refs push git 
prepare shutdown 	push dav 
exit server 	free discovery starts 
log dict 	alloc grow 
slots 	xstrdup die strbuf 
dict size 	reset strbuf 
dict size 	getline push fflush 
server log 	exit free 
server log 	free git setup 
list length 	gettext git 
list 	extract argv path 
length list 	setup git 
length zmalloc 	directory gently 
used memory 	error isatty remote 
clients cron 	end url 
databases cron 	slash end url 
rewrite 	slash http 
append file 	init strbuf getline 
background ldb 	ferror error 
pending children 	starts die parse 
wait wexitstatus 	fetch strcmp 
wifsignaled wtermsig 	starts strstr output 
server 	refs refs 
log strerror 	starts parse push 
background save 	skip prefix 
done handler 	strchr option fflush 
background rewrite 	strcmp fflush 
done handler 	error strbuf reset 
ldb 	http cleanup 
child server 	always ends 
log update 	trailing slash one 
dict resize 	send pack 
policy server 	push cert constants 
log rdb 	libcurl version 
save 	num unsupported show 
background server 	text plain 
log rewrite 	parts types likely 
append file 	ugly look 
background flush 	user terminal smart 
append file 	http response 
flush 	validate service pkt 
append file 	line matches 
free clients 	request header include 
free queue 	additional metadata 
clients paused 	lines packet flush 
replication cron 	marker ignore 
cluster 	future might start 
cron sentinel 	scan load 
timer migrate 	entire request 
close timedout 	fit allocated buffer 
sockets unused 	space use 
cluster sleep 	http avoid chunked 
active 	encoding mess 
expire cycle 	request body large 
create create 	size cannot 
create replication 	predicted must use 
feed slaves 	chunked encoding 
decr count 	send looping retry 
decr 	authentication previous 
count decr 	run headers gzip 
count list 	buffer already 
length process 	need send client 
clients waiting 	backend isn 
replicas list 	giving compressed data 
length 	deflate may 
process unblocked 	save transfer time 
clients flush 	know complete 
append file 	request size 
handle clients 	advance use normal 
pending writes 	content length 
create 	approach error already 
sdsnew create 	reported error 
sdsnew create 	already reported remote-ext.c 
sdsnew create 	git req 
sdsnew create 	git req vhost 
sdsnew create 	str service 
sdsnew 	next rpos escape 
create sdsnew 	special service 
create sdsnew 	noprefix ret arg 
create sdsnew 	service expanded 
create sdsnew 	stdin serv repo 
create sdsnew 	vhost arg 
create 	service child child 
sdsnew create 	buffer argc 
sdsnew create 	argv prefix skip 
sdsnew create 	prefix setenv 
sdsnew create 	setenv die 
sdsnew create 	die strbuf addch 
sdsnew 	strbuf addstr 
create sdsnew 	strbuf addstr strbuf 
create sdsnew 	addch strbuf 
create sdsnew 	detach strbuf detach 
create sdsnew 	strbuf detach 
create sdsnew 	strip escapes argv 
create 	push free 
sdsnew create 	packet write packet 
sdsnew create 	write parse 
sdsnew create 	argv start command 
sdsnew create 	die send 
sdsnew create 	git request bidirectional 
sdsnew 	transfer loop 
create sdsnew 	finish command finish 
create sdsnew 	command fgets 
create sdsnew 	ferror die exit 
create sdsnew 	strlen isspace 
create sdscatprintf 	strcmp fflush 
sdsempty 	strncmp fflush run 
create create 	child die 
create create 	command loop url 
create create 	syntax command 
create create 	arg arg invoke 
create create 	command given 
create 	arguments special characters 
create sdscatprintf 	space argument 
sdsempty create 	percent sign name 
sdscatprintf sdsempty 	service git 
create create 	upload pack git 
random hex 	upload archive 
chars 	git receive pack 
zstrdup zstrdup 	possible git 
time zstrdup 	prefix stripped allowed 
zstrdup zstrdup 	first character 
dict create 	argument pass 
lru clock 	argument command instead 
reset 	send name 
server save 	repository line git 
append server 	style request 
save append 	also activates sending 
server save 	style request 
append server 	allowed first character 
save 	argument used 
time dict 	conjunction pass argument 
create dict 	command instead 
create populate 	send vhost git 
command table 	style request 
lookup command 	note activate sending 
lookup 	git style 
command lookup 	request pass service 
command lookup 	command scan 
command lookup 	length argument fall 
command lookup 	error skip 
command lookup 	space actual 
command 	placeholder substitution enough 
access rewrite 	overflow integers 
config prepare 	skip first bytes 
shutdown close 	specials strip 
usleep execve 	end line characters 
exit 	remote-fd.c input 
getrlimit server 	output buffer argc 
log strerror 	argv prefix 
setrlimit server 	input output end 
log exit 	end fgets 
server log 	ferror die strlen 
server 	isspace strcmp 
log strerror 	fflush strncmp fflush 
server log 	bidirectional transfer 
server log 	loop die die 
fopen fgets 	die strtoul 
atoi server 	die strtoul die 
log 	command loop 
fclose anet 	url syntax 
tcp server 	inoutfd anything read 
anet non 	write socket 
block anet 	pair inoutfd infd 
tcp server 	outfd anything 
anet 	read pipe infd 
non block 	write pipe 
strchr anet 	outfd foo indicates 
tcp server 	foo optional 
anet tcp 	anything data output 
server server 	outfd inoutfd 
log 	passed unmolested git 
anet non 	receive pack 
block mstime 	git upload pack 
memset signal 	git upload 
signal setup 	archive output git 
signal handlers 	receive pack 
openlog 	git upload pack 
getpid list 	git upload 
create list 	archive passed 
create list 	unmolested infd inoutfd 
create list 	strip end 
create list 	line characters remote-testsvn.c 
create 	url dump 
list create 	file remote marksfilename 
list create 	notes rev 
list create 	line line line 
zmalloc memory 	name batchable 
size create 	input command list 
shared 	line sha 
objects adjust 	note sha msg 
open files 	msglen msg 
limit create 	res key end 
loop zmalloc 	len end 
listen port 	sha note sha 
exit 	note path 
unlink anet 	data file 
unix server 	msg msglen note 
server log 	ret marksfile 
exit anet 	latestrev marksfile line 
non block 	found line 
server 	code dumpin note 
log exit 	msg head 
dict create 	sha startrev svndump 
dict create 	proc command 
dict create 	note line line 
dict create 	batchlines batch 
dict 	cmd item argc 
create eviction 	argv notes 
pool alloc 	remote url fflush 
dict create 	fflush init 
list create 	notes note read 
list free 	sha file 
method 	error error free 
list match 	free notes 
method aof 	strchrnul starts 
rewrite buffer 	strlen strtol read 
reset sdsempty 	sha file 
time reset 	free parse rev 
server 	note sha 
stats time 	hex fopen die 
update cached 	errno note 
time create 	die fclose init 
time server 	notes fopen 
panic exit 	regenerate marks fopen 
create 	die errno 
file server 	fclose strbuf addf 
panic create 	strbuf getline 
file server 	starts fclose regenerate 
panic open 	marks free 
server log 	notes strbuf release 
strerror 	strbuf release 
exit server 	read read note 
log cluster 	warning parse 
init replication 	rev note 
script cache 	die free check 
init scripting 	regenerate marks 
init 	open die errno 
slowlog init 	argv push 
latency monitor 	argv push argv 
init bio 	push argv 
init server 	pushf start command 
panic dict 	die svndump 
sdsnew 	init svndump read 
dict sdsnew 	svndump deinit 
server zrealloc 	svndump reset close 
decr count 	finish command 
zfree zfree 	warning fflush terminate 
dict fetch 	batch list 
sdsnew 	clear starts die 
dict fetch 	list append 
sdsfree dict 	starts strlen strlen 
fetch dict 	list append 
fetch feed 	die git 
append file 	extract argv path 
replication 	setup git 
feed slaves 	directory usage remote 
zmalloc incr 	starts url 
count redis 	decode end url 
append list 	slash strbuf 
length replication 	addf strbuf addf 
feed 	strbuf addf 
monitors redis 	git dir strbuf 
init ustime 	getline ferror 
proc ustime 	die die command 
latency sample 	strbuf reset 
needed slowlog 	strbuf release strbuf 
push 	release strbuf 
entry needed 	release strbuf release 
propagate propagate 	strbuf release 
redis free 	whether command 
strcasecmp reply 	starts part batch 
lookup command 	terminate current 
flag 	batch fast stream 
transaction reply 	note refers 
error format 	git reference rev 
flag transaction 	refers svn 
reply error 	revision note found 
format flag 	didn find 
transaction 	setup marks file 
reply flag 	export commands 
transaction cluster 	grouped together batch 
redirect client 	batches ended 
node query 	batch active program 
flag transaction 	ends batch 
cluster 	lines buffered passed 
redirect client 	handler function 
free memory 	batch terminated end 
needed flag 	batch reading 
transaction reply 	commands end 
flag transaction 	command stream quit 
reply 	buffer batch 
reply sds 	lines remote.c tag 
sdscatprintf sdsempty 	refspec tag 
strerror flag 	refspec len baselen 
transaction reply 	instead instead 
reply reply 	instead alloc rewrite 
error 	rewrite alloc 
flag transaction 	rewrite remotes remotes 
reply reply 	alloc remotes 
tolower tolower 	remotes hash branches 
flag transaction 	branches alloc 
reply queue 	branches current branch 
multi 	pushremote name 
command reply 	rewrites rewrites push 
call list 	remote url 
length handle 	longest longest remote 
clients blocked 	remote remote 
lists close 	url remote 
close 	pushurl remote url 
close server 	pushurl remote 
log unlink 	url str len 
server log 	key name 
ldb kill 	len ret replaced 
forked sessions 	lookup lookup 
server 	entry branch name 
log kill 	name len 
rdb temp 	ret len ret 
file server 	rewrite instead 
log server 	remote buf remote 
log kill 	frag buf 
server 	key name namelen 
log aof 	subkey remote 
fsync server 	branch rewrite pushurl 
log rdb 	aliases loaded 
save server 	oid head flag 
log server 	refspec refspec 
log 	refspec refspec 
unlink flush 	fetch verify llen 
slaves output 	glob lhs 
buffers close 	rhs flags rlen 
listening sockets 	unused fetch 
server log 	refspec str refspec 
strlen 	refspec refspec 
strlen memset 	refspec refspec refspec 
memset memcpy 	refspec name 
memcpy reply 	branch branch name 
error time 	ret name 
independent strcmp 	given name name 
reply 	remote priv 
reply error 	result map refs 
reply error 	retval item 
format reply 	remote url key 
reply bulk 	name result 
buffer reply 	kstar klen ksuffixlen 
bulk 	namelen ret 
buffer reply 	vstar refs 
bulk reply 	count query results 
reply bulk 	find src 
reply bulk 	refspec key needle 
gettimeofday reply 	result refs 
multi 	count query find 
bulk len 	src needle 
reply bulk 	result refspec key 
reply bulk 	refspecs refspec 
reply status 	name query remote 
reply reply 	refspec prefix 
multi 	prefixlen name len 
bulk len 	name cpy 
reply bulk 	len ret tail 
reply deferred 	next next 
multi bulk 	cmp pattern refs 
length reply 	matched patlen 
command 	matched weak 
flag reply 	matched weak match 
command flag 	match name 
reply command 	namelen tail name 
flag reply 	match oid 
command flag 	name tail ret 
reply 	name peer 
command flag 	buf oid src 
reply command 	match allocated 
flag reply 	match src dst 
command flag 	dst tail 
reply command 	matched src matched 
flag 	dst allocated 
reply command 	src dst dst 
flag reply 	guess oid 
command flag 	flag src dst 
reply command 	dst tail 
flag reply 	errs send mirror 
command 	direction ret 
flag reply 	pat pat 
command flag 	name matching refs 
reply status 	dst side 
deferred multi 	match head tail 
bulk length 	tip alloc 
reply 	tips oid commit 
reply reply 	src dst 
reply multi 	dst tail dst 
bulk len 	tag src 
dict size 	tag item sent 
dict iterator 	tips dst 
dict 	commit list name 
next reply 	index src 
command dict 	refspec refspec names 
val dict 	refspec ret 
release iterator 	src dst refspec 
strcasecmp reply 	refspec flags 
multi 	send send mirror 
bulk len 	send prune 
reply command 	errs refspec 
dict fetch 	dst tail dst 
strcasecmp reply 	index dst 
dict size 	item dst peer 
strcasecmp 	pat dst 
lookup command 	name src index 
reply error 	src name 
format reply 	remote refs send 
error keys 	mirror force 
command reply 	update force update 
multi 	reject reason 
bulk len 	ret remote oid 
reply bulk 	name ret 
keys free 	branch branch refname 
result reply 	err fmt 
error sprintf 	branch err remote 
sprintf 	refname err 
sprintf sprintf 	ret branch err 
sprintf sprintf 	remote dst 
sprintf sdsempty 	ret cur 
strcasecmp strcasecmp 	branch err refname 
getrusage getrusage 	oid flag 
clients 	remote refs refspec 
max buffers 	ret tail 
strcasecmp sdscat 	expn name cpy 
uname sdscatprintf 	refs name 
redis git 	remote refs name 
sha strtol 	name remote 
redis 	refs refspec tail 
git dirty 	missing map 
redis build 	rmp name ignore 
api name 	list list 
getpid intmax 	mark commit oid 
strcasecmp sdscat 	old oid 
sdscatprintf 	old list used 
list length 	found branch 
list length 	num num 
strcasecmp zmalloc 	upstream name oid 
used memory 	revs argv 
maxmemory lua 	branch full upstream 
bytes 	gone refname 
human bytes 	oid flag data 
human bytes 	local tail 
human bytes 	local tail head 
human bytes 	refs list 
human bytes 	tail names stale 
human 	refs tail 
sdscat sdscatprintf 	refs count refname 
zmalloc fragmentation 	oid flags 
ratio strcasecmp 	data info matches 
sdscat sdscatprintf 	query stale 
intmax time 	refs count fetch 
intmax 	map stale 
time sdscatprintf 	refs names info 
sdslen aof 	cas cas 
rewrite buffer 	refname refnamelen 
size bio 	entry cas arg 
pending jobs 	unset colon 
type 	entry opt arg 
time sdscatprintf 	unset cas 
strcasecmp sdscat 	remote refname oid 
sdscatprintf instantaneous 	dst cas 
metric instantaneous 	remote entry cas 
metric instantaneous 	remote remote 
metric 	refs starts xstrfmt 
dict size 	alloc grow 
list length 	alloc grow alloc 
dict size 	grow alloc 
strcasecmp sdscat 	grow url pushurl 
sdscatprintf sdscatprintf 	url url 
sdscatprintf 	pushurl strncmp strcmp 
sdscatprintf sdscatprintf 	hashmap init 
sdscatprintf list 	strlen init remotes 
length sdscatprintf 	hash hashmap 
list length 	entry init 
list rewind 	memhash hashmap xcalloc 
list 	alloc grow 
next list 	xstrndup hashmap entry 
node anet 	init hashmap 
peer time 	put alloc grow 
sdscatprintf sdscatprintf 	strncmp strcmp 
strcasecmp sdscat 	alloc grow xcalloc 
sdscatprintf 	xstrndup xstrdup 
strcasecmp sdscat 	xstrfmt strncmp strcmp 
sdscatprintf sdscatprintf 	alloc grow 
strcasecmp sdscat 	xcalloc xstrndup xstrdup 
sdscatprintf strcasecmp 	strlen alloc 
sdscat sdscatprintf 	grow strlen isspace 
dict 	fopen git 
size dict 	path strbuf getline 
size sdscatprintf 	strbuf rtrim 
reply reply 	skip prefix url 
bulk sds 	xstrdup skip 
gen redis 	spaces skip 
info 	prefix push refspec 
list node 	xstrdup skip 
tail reply 	spaces skip prefix 
zmalloc zmalloc 	fetch refspec 
dict keys 	xstrdup skip spaces 
dict key 	strbuf release 
dict 	fclose fopen git 
find dict 	path strbuf 
val estimate 	getline fclose strbuf 
idle time 	trim strbuf 
memmove sdsfree 	release strchr url 
memmove sdsdup 	strbuf detach 
zfree 	fetch refspec xstrfmt 
list length 	push refspec 
zmalloc used 	xstrfmt parse config 
memory list 	key make 
rewind list 	branch strcmp 
next list 	git config strcmp 
node 	git config 
client output 	strcmp config error 
buffer memory 	nonbool merge 
usage sdslen 	xstrdup parse config 
aof rewrite 	key strcmp 
buffer size 	make rewrite config 
latency 	error nonbool 
start monitor 	instead xstrdup strcmp 
dict size 	make rewrite 
dict random 	config error nonbool 
key dict 	instead xstrdup 
key eviction 	parse config key 
pool 	strcmp git 
populate dict 	config warning make 
find sdsfree 	remote strcmp 
memmove dict 	git config strcmp 
key dict 	git config 
random key 	strcmp git 
dict 	config strcmp git 
key dict 	config strcmp 
val create 	git config url 
sdslen propagate 	strcmp git 
expire zmalloc 	config pushurl strcmp 
used memory 	git config 
latency 	push refspec strcmp 
start monitor 	git config 
latency end 	fetch refspec strcmp 
monitor latency 	git config 
sample needed 	error strcmp git 
latency nested 	config error 
zmalloc 	strcmp strcmp strcmp 
used memory 	strcmp git 
notify keyspace 	config strcmp git 
decr count 	config strcmp 
flush slaves 	git config url 
output buffers 	pushurl url 
latency 	resolve skip 
end monitor 	prefix make branch 
latency sample 	git config 
needed latency 	urls free free 
end monitor 	free xcalloc 
latency sample 	strrchr strlen strchr 
needed 	xstrndup strlen 
fopen fgets 	memchr xstrndup oid 
fclose fclose 	hex check 
atoi linux 	refname format check 
overcommit memory 	refname format 
server log 	check refname format 
thp 	check refname 
enabled server 	format check refname 
log zstrdup 	format free 
fopen getpid 	refspecs die parse 
fclose fork 	refspec free 
exit setsid 	refspecs parse refspec 
open 	parse refspec 
dup dup 	free free 
dup close 	free dot dotdot 
redis git 	strchr remote 
sha atoi 	branch read config 
redis git 	make remote 
dirty 	valid remote nick 
redis build 	valid remote 
exit exit 	read remotes file 
zmalloc server 	valid remote 
log redis 	read branches file 
git sha 	valid remote 
strtol 	url valid remote 
redis git 	parse fetch 
dirty getpid 	refspec parse push 
snprintf redis 	refspec remote 
git sha 	remote read config 
strtol 	parse fetch 
redis git 	refspec parse push 
dirty getpid 	refspec strcmp 
server log 	die warning 
raw zfree 	die die free 
server log 	free list 
handler 	insert handle duplicate 
rdb temp 	list clear 
file getpid 	strcmp strchr die 
exit exit 	strlen strlen 
server log 	strncmp memcmp strchr 
handler sigemptyset 	die strbuf 
sigaction 	strbuf strbuf addstr 
sigaction sigemptyset 	strbuf detach 
sigaction sigaction 	error match name 
sigaction sigaction 	pattern list 
strstr strcmp 	append nodup strcmp 
ustime load 	list append 
append 	error match name 
file server 	pattern strcmp 
log ustime 	xstrdup memset 
rdb load 	query refspecs query 
server log 	refspecs strlen 
ustime server 	xcalloc memcpy memcpy 
log 	alloc prefix 
strerror exit 	strlen xmalloc memcpy 
server log 	xstrdup xstrdup 
server panic 	copy copy free 
setproctitle unused 	free free 
getenv server 	free free strcmp 
log 	llist mergesort 
server log 	strlen strlen refname 
unsetenv getenv 	match starts 
server log 	starts alloc oidclr 
strchr strlen 	alloc sha 
server log 	alloc oidcpy alloc 
socket 	tail link 
server log 	resolve starts strbuf 
memset strncpy 	addstr starts 
memset strlen 	strbuf addstr 
memset offsetof 	strbuf addstr strbuf 
strlen unsetenv 	detach count 
sendmsg 	refspec match name 
server log 	error error 
close close 	match lhs resolve 
getenv getenv 	starts die 
redis supervised 	count refspec match 
upstart redis 	starts make 
supervised 	linked oid error 
systemd redis 	guess make 
supervised upstart 	linked error error 
redis supervised 	error copy 
systemd strcasecmp 	match match name 
strcasecmp ziplist 	pattern match 
test 	name pattern starts 
strcasecmp quicklist 	xstrdup oid 
test strcasecmp 	lookup commit reference 
intset test 	gently alloc 
strcasecmp zipmap 	grow memset 
test strcasecmp 	oid tips tips 
sha 	starts list 
test strcasecmp 	append clear commit 
test strcasecmp 	marks many 
sds test 	list sort starts 
strcasecmp endianconv 	list sha 
test strcasecmp 	info list append 
crc 	list clear 
test spt 	oid lookup commit 
init setlocale 	reference gently 
zmalloc enable 	merge bases many 
safeness zmalloc 	make linked 
oom handler 	oidcpy copy list 
srand 	clear free 
time getpid 	strcmp list append 
gettimeofday dict 	nodup list 
hash function 	sort parse push 
seed getpid 	refspec match 
check sentinel 	lhs free 
mode 	refspec tail parse 
init server 	push refspec 
config absolute 	match refs match 
path zmalloc 	prepare index 
zstrdup init 	list lookup make 
sentinel config 	linked oidcpy 
init 	list insert copy 
sentinel strstr 	free list 
exit redis 	clear missing tags 
check rdb 	match prepare 
main sdsempty 	index list alloc 
strcmp strcmp 	free list 
version 	clear oidcpy oid 
strcmp strcmp 	oidcmp oidcmp 
usage strcmp 	oid starts file 
memtest atoi 	lookup commit 
exit exit 	reference gently 
absolute path 	lookup commit reference 
zfree 	gently newer 
zstrdup strcmp 	remote xcalloc xcalloc 
sdslen sdscat 	xstrdup remote 
sdscat sdscat 	find tracking strcmp 
sdscatrepr strlen 	dwim strlen 
sdscat server 	xstrdup read config 
log 	strcmp make 
server log 	branch merge refname 
exit reset 	match start 
server save 	strbuf vaddf end 
load server 	error buf 
config sdsfree 	exists error buf 
server 	error buf 
log redis 	error buf apply 
supervised daemonize 	refspecs error 
init server 	buf error buf 
create pid 	remote pushremote 
file redis 	branch error 
proc 	buf apply refspecs 
title redis 	error buf 
ascii art 	tracking push dest 
check tcp 	free tracking 
backlog settings 	push dest error 
server log 	buf tracking 
linux 	push dest branch 
memory warnings 	upstream branch 
load data 	upstream tracking push 
disk verify 	dest strcmp 
cluster config 	error buf die 
data server 	branch push 
log 	resolve strchr match 
exit server 	name pattern 
log server 	ignore symref update 
log sentinel 	copy alloc 
running server 	free refname match 
log sleep 	find name 
proc 	abbrev copy 
main loop 	starts alloc starts 
copyright salvatore 	starts starts 
sanfilippo antirez 	alloc prefix alloc 
gmail dot 	prefix expanded 
rights reserved 	map alloc oid 
redistribution 	hex remote 
use source 	die local starts 
binary forms 	check refname 
without modification 	format error free 
permitted provided 	free tail 
following conditions 	link strcmp oidcpy 
met 	pop commit 
redistributions source 	deref tag parse 
code must 	deref tag 
retain copyright 	parse parse commit 
notice list 	commit list 
conditions following 	insert pop recent 
disclaimer 	commit commit 
redistributions binary 	list insert 
form must 	unmark free unmark 
reproduce copyright 	free branch 
notice list 	upstream read lookup 
conditions following 	commit reference 
disclaimer 	read lookup commit 
documentation materials 	reference argv 
provided distribution 	push argv push 
neither name 	argv pushf 
redis names 	oid hex oid 
contributors may 	hex argv 
used 	push init revisions 
endorse promote 	setup revisions 
products derived 	prepare revision walk 
software without 	die revision 
specific prior 	clear commit marks 
written permission 	clear commit 
software 	marks argv 
provided copyright 	clear stat tracking 
holders contributors 	info shorten 
express implied 	unambiguous strbuf addf 
warranties including 	strbuf addf 
limited implied 	strbuf addf strbuf 
warranties 	addf strbuf 
merchantability fitness 	addf strbuf addf 
particular purpose 	strbuf addf 
disclaimed shall 	strbuf addf strbuf 
copyright owner 	addf free 
contributors liable 	check refname format 
direct 	alloc oidcpy 
indirect incidental 	copy find name 
special exemplary 	find name 
consequential damages 	oidcmp copy starts 
including limited 	oidcmp copy 
procurement substitute 	memset query refspecs 
goods 	multiple list 
services loss 	make linked 
use data 	oidcpy list clear 
profits business 	list append 
interruption however 	list sort list 
caused theory 	clear free 
liability 	free memset alloc 
whether contract 	grow memset 
strict liability 	xmemdupz clear cas 
tort including 	option strchrnul 
negligence otherwise 	cas entry sha 
arising way 	error parse 
use 	push cas option 
software even 	apply refspecs 
advised possibility 	read refname match 
damage shared 	hashcpy remote 
common objects 	tracking remote tracking 
vars actually 	apply cas 
used 	unspecified previous entry 
constants following 	overwritten branches 
values used 	file would 
disk serialization 	url optionally branch 
initialized runtime 	specified master 
avoid strange 	specified branch fetched 
compiler 	stored local 
optimizations globals 	branch matching remote 
vars server 	name cogito 
state command 	compatible push push 
table every 	current head 
entry composed 	remote branch master 
following 	missing always 
fields name 	follow handle remote 
representing command 	variables handle 
name function 	remote name variables 
pointer function 	function frees 
implementing command 	refspec warning code 
arity 	paths ensure 
number arguments 	src dst pointers 
possible use 	always freeable 
say sflags 	pointers well 
command flags 	refspec pointer going 
see table 	special refspec 
flags 	pushing matching refs 
flags flags 	lhs empty 
bitmask computed 	means head valid 
redis sflags 	looking rhs 
field keys 	missing empty empty 
proc optional 	means store 
function 	valid looking lhs 
key arguments 	empty allowed 
command used 	means wildcarded must 
following three 	valid looking 
fields enough 	otherwise must extended 
specify arguments 	sha existing 
keys 	way validate empty 
first key 	anything goes 
index first 	rhs missing allowed 
argument key 	lhs must 
last key 	valid looking 
index last 	empty allowed otherwise 
argument 	must valid 
key key 	looking refspec must 
step step 	greater zero 
keys first 	must valid since 
last argument 	possible reach 
instance mset 	point within loop 
step 	slash last 
two since 	possibility doesn occur 
arguments key 	fetch head 
val key 	ignore entries always 
val microseconds 	appear end 
microseconds total 	list entry already 
execution 	existed match 
time command 	weak refs outside 
calls total 	heads tags 
number calls 	specify pattern 
command flags 	full refs remotes 
microseconds calls 	origin master 
fields 	least toplevel remotes 
computed redis 	origin master 
always zero 	otherwise git push 
command flags 	url master 
expressed every 	would result ambiguity 
character represents 	remotes origin 
flag 	master heads master 
later populate 	remote site 
command table 	want weak matches 
function take 	found multiple 
care populating 	matches one strong 
real flags 	matches found 
field 	ambiguous one strong 
characters meaning 	match zero 
flags write 	weak matches acceptable 
command may 	unique match 
modify key 	source could 
space read 	sha format reference 
command 	name refs 
never modify 	way remote end 
key space 	matching refs 
may increase 	traditionally pushed everything 
memory usage 	including refs 
called allow 	outside refs heads 
memory 	hierarchy make 
admin command 	much sense days 
like save 	collect everything 
shutdown pub 	know would end 
sub related 	push collect 
command force 	tags collect tags 
replication 	tag already 
command regardless 	conservative point src 
server dirty 	tag lists 
command allowed 	tags missing dst 
scripts random 	sent tips 
command command 	lists tips 
deterministic 	pushing know already 
command arguments 	element src 
key space 	tag ancestor sent 
may different 	tips needs 
results instance 	sent side pushing 
spop randomkey 	commit error 
two 	tag reachable commits 
random commands 	sending given 
sort command 	local refs sanity 
output called 	check push 
script output 	refspecs errors match 
deterministic allow 	push refs 
command 	would errors early 
loading database 	even talking 
allow command 	remote side given 
slave stale 	refs local 
data allowed 	repository refs remote 
server data 	repository refspec 
normally 	used push 
command accepted 	determine remote refs 
condition automatically 	update setting 
propagate command 	peer pushed force 
monitor perform 	push forced 
asking command 	elements dst function 
command 	may elements 
accepted cluster 	dst pushing branch 
mode slot 	done match 
marked importing 	refs pick remainder 
fast command 	already sending 
log command 	something remote doesn 
never 	pattern mirror 
delay execution 	create one link 
kernel scheduler 	check missing 
giving time 	refs remote already 
note commands 	sending something 
may trigger 	remote moved 
del 	different expect reject 
side effect 	push also 
like fast 	error user told 
commands utility 	check remote 
functions low 	tracking branch find 
level logging 	expect tracking 
use 	branch isn stale 
big messages 	force update 
otherwise server 	update isn already 
log prefer 	rejected check 
clear flags 	usual must fast 
sentinel rdb 	forward rules 
aof 	decide whether individual 
writing child 	refspec pushed 
slave master 	push succeed following 
like server 	remote reference 
log raw 	exist remote reference 
alike support 	removed pushing 
function 	source specified 
used across 	destination refs tags 
code raw 	old commit 
version used 	descendant old forced 
order dump 	notation passing 
info output 	force argument force 
crash 	defeat rejection 
log message 	implemented rules branch 
without alike 	already run 
capabilities way 	merge config make 
safe call 	sure confuse 
signal handler 	callers non zero 
actually 	merge merge 
use signals 	merge config user 
fatal point 	didn define 
view redis 	real branch branch 
signals going 	vivified non 
kill server 	existing refs create 
anyway 	list consisting 
need alike 	copies remote 
features served 	matches refspec refspec 
server log 	must pattern 
unix time 	fill copies peer 
microseconds unix 	describe local 
time 	tracking refs map 
milliseconds rdb 	omit references 
dump aof 	would map existing 
rewrite exit 	local symbolic 
children exit 	dereference item old 
instead exit 	must commit 
latter 	ish descendant old 
may interact 	otherwise require 
file objects 	force compare branch 
used parent 	upstream save 
process however 	differences number commits 
testing coverage 	num num 
normal 	name upstream branch 
exit used 	upstream defined 
order obtain 	returned via 
right coverage 	upstream name returns 
information hash 	num num 
table type 	could filled upstream 
implementation 	defined exist 
hash table 	otherwise cannot stat 
type uses 	unless marked 
sds library 	build top somebody 
keys redis 	cannot stat 
objects values 	used build longer 
objects 	exists run 
hold sds 	rev list left 
lists sets 	right internally 
insensitive version 	ignored count commits 
used command 	side clear 
lookup table 	flags smudged traversal 
places 	anything report 
insensitive non 	otherwise already 
binary safe 	know starts refs 
comparison needed 	transports support 
values swapped 	directly peeking head 
keys sets 	points guess 
type 	refs heads master 
hash table 	could right 
hash function 	look another points 
key dup 	matches find 
val dup 	suitable refspec symref 
key compare 	list refs 
key 	currently exist remote 
destructor val 	consider stale 
destructor sorted 	order deal overlapping 
sets hash 	refspecs need 
note skiplist 	matching refs compare 
used addition 	swap option 
hash 	option option refname 
table hash 	option refname 
function key 	look remote 
dup val 	fetch refspec see 
dup key 	remote tracking 
compare 	branch refname fill 
key destructor 	current sha 
val destructor 	cannot negative signal 
dict keys 	error tracking 
sds vals 	refname remote know 
redis objects 	tracking cannot 
hash 	read find option 
function key 	name entry 
dup val 	option cover branch 
dup key 	another remote 
compare key 	also uses non 
destructor val 	remote tracking 
destructor 	refs advise user 
server lua 	local branches 
scripts sha 	silently skip non 
sds scripts 	remote refs 
robj cache 	make sure 
hash function 	symrefs deleted first 
key 	symrefs rename 
dup val 	rest create symrefs 
dup key 	cannot pass 
compare key 	function deletes branches 
destructor val 	one one 
destructor expires 	since relies cached 
hash 	refs invalidated 
function key 	deleting branch sorting 
dup val 	comparison list 
dup key 	push info structs 
compare key 	field remote 
destructor val 	branch info git 
destructor 	pull info 
command table 	git push info 
sds command 	make sure 
pointer hash 	valid fetch mode 
function key 	use fetch 
dup val 	url push 
dup 	found requested special 
key compare 	cases entry 
key destructor 	old url specified 
val destructor 	demand one 
hash type 	matches builtin remote 
hash table 	usage builtin 
note 	remote usage builtin 
small hashes 	remote rename 
represented ziplists 	usage builtin remote 
hash function 	usage builtin 
key dup 	remote sethead usage 
val dup 	builtin remote 
key 	setbranches usage builtin 
compare key 	remote show 
destructor val 	usage builtin remote 
destructor keylist 	prune usage 
hash table 	builtin remote update 
type unencoded 	usage builtin 
redis 	remote geturl 
objects keys 	usage builtin remote 
lists values 	seturl usage 
used blocking 	verbose name argv 
operations blpop 	key branchname 
map swapped 	remotename mirror tmp 
keys 	mirror advice 
list clients 	opt arg mirror 
waiting keys 	argc argv 
loaded hash 	fetch tags mirror 
function key 	track master 
dup val 	remote buf name 
dup 	url options 
key compare 	remote name merge 
key destructor 	branch list 
val destructor 	name prefix key 
cluster nodes 	orig key 
hash table 	name item 
mapping 	info key len 
nodes addresses 	space merge 
cluster node 	remote stale tracked 
structures hash 	heads push 
function key 	queried remote refs 
dup val 	states tail 
dup 	stale refs item 
key compare 	dest forced 
key destructor 	remote refs states 
val destructor 	remote local 
cluster addition 	refs push map 
blacklist maps 	item info 
node 	states remote item 
time node 	info spec 
goal avoid 	remote refs states 
readding removed 	matches fetch 
node time 	map tail refspec 
hash function 	next remote 
key 	list remote 
dup val 	data remote branches 
dup key 	skipped keep 
compare key 	refname oid flags 
destructor val 	data branches 
destructor migrate 	refspec old remote 
cache 	branches refname 
dict type 	oid flags data 
hash function 	rename buf 
key dup 	item flag orig 
val dup 	oid symref 
key compare 	remote buf argc 
key 	argv options 
destructor val 	oldremote newremote old 
destructor replication 	remote context 
cached script 	remote branches rename 
dict server 	refspec updated 
repl scriptcache 	ptr item info 
dict 	item flag 
keys sds 	oid item 
sha values 	item argc argv 
used current 	options remote 
implementation hash 	buf known remotes 
function key 	branches skipped 
dup 	data result item 
val dup 	info info 
key compare 	states refname oid 
key destructor 	flags data 
val destructor 	states refspec name 
percentage used 	states query 
slots 	transport remote refs 
reaches hashtable 	list states 
min fill 	width width rebase 
resize hash 	item data 
table save 	info item data 
memory hash 	info states 
table 	name fmt arg 
implementation performs 	branch item 
rehashing incrementally 	data show 
write read 	info states branch 
hash table 	info item 
still server 	item data show 
idle 	info branch 
hash table 	info merge also 
use two 	push item 
tables time 	data show info 
use millisecond 	push info 
cpu time 	item push push 
every 	cmp item 
call function 	data show info 
perform rehahsing 	push info 
function returns 	status remote priv 
rehashing performed 	list url 
otherwise returned 	buf url url 
keys 	list result 
dictionary already 	item argc 
used millisecond 	argv query flag 
loop expires 	options states 
already used 	info list info 
millisecond loop 	url url 
function 	argc argv result 
called background 	buf head 
process kind 	name options states 
terminates want 	remote dry 
avoid resizing 	run result states 
hash tables 	refs prune 
child 	item dangling msg 
order play 	refname argc 
well copy 	argv result options 
write otherwise 	key priv 
resize happens 	found argc argv 
lots memory 	prune options 
pages 	fetch argv defined 
copied goal 	retval remote 
function update 	key remote 
ability dict 	branches key remotename 
resize hash 	mirror refspec 
tables accordingly 	remotename branches mode 
fact 	key remote 
running childs 	argc argv mode 
cron called 	options argc 
every helper 	argv mode remotename 
function active 	remote url 
expire cycle 	url options argc 
function 	argv mode 
function expire 	negative matches remotename 
key stored 	newurl oldurl 
hash table 	remote old regex 
entry expires 	urlset urlset 
hash table 	name buf options 
redis 	argc argv 
database key 	prefix options result 
found expired 	run command 
removed database 	opt error 
returned otherwise 	strbuf reset strbuf 
operation performed 	addch strbuf 
returned 	addf strbuf addf 
key expired 	git config 
server stat 	multivar warning strcmp 
expiredkeys incremented 	strcmp error 
parameter current 	parse options usage 
time milliseconds 	options die 
passed 	die remote remote 
function avoid 	configured die 
many gettimeofday 	strbuf addf valid 
syscalls expire 	fetch refspec 
timed keys 	die strbuf addf 
algorithm used 	git config 
adaptive 	strbuf reset strbuf 
use cpu 	addf list 
cycles expiring 	append branch strbuf 
keys otherwise 	reset strbuf 
aggressive avoid 	addf git 
much memory 	config strbuf reset 
used 	strbuf addf 
keys removed 	git config fetch 
keyspace cron 	remote strbuf 
dbs per 	reset strbuf addf 
call databases 	strbuf reset 
tested every 	strbuf addf create 
iteration 	symref error 
kind call 	strbuf release strbuf 
used redis 	release list 
detects timelimit 	clear skip prefix 
exit work 	starts strip 
incrementally sleep 	suffix xmemdupz strip 
function 	suffix xmemdupz 
loop expire 	strip suffix xmemdupz 
cycle type 	list insert 
type active 	xcalloc warning xstrdup 
expire cycle 	strchr abbrev 
fast function 	branch xstrndup 
run 	list append abbrev 
fast expire 	branch strchr 
cycle takes 	list append xstrdup 
longer expire 	git config 
fast cycle 	maybe strcmp strcmp 
duration microseconds 	git config 
repeated 	fetch map die 
amount time 	exists list 
type active 	append abbrev branch 
expire cycle 	list append 
slow normal 	abbrev branch stale 
expire cycle 	heads list 
executed 	append abbrev branch 
time limit 	xstrdup free 
percentage redis 	refs free refs 
period specified 	list sort 
redis expirelookups 	list sort 
time perc 	list sort local 
define 	heads copy 
function state 	list match push 
order work 	refs oidcpy 
incrementally across 	list append abbrev 
calls last 	branch xcalloc 
tested time 	xstrdup abbrev branch 
limit 	oid oidcmp 
hit previous 	oid file newer 
call last 	free refs 
fast cycle 	free refs list 
ran start 	append xcalloc 
fast cycle 	xstrdup list append 
previous 	strlen list 
cycle exited 	append list append 
time limt 	xcalloc xstrdup 
also repeat 	fetch map guess 
fast cycle 	remote head 
period fast 	find name 
cycle 	list append abbrev 
total duration 	branch free 
usually test 	refs free refs 
cron dbs 	strcmp xmalloc 
per call 	memset remote find 
per iteration 	tracking memset 
two 	remote find tracking 
exceptions test 	starts starts 
last time 	list append abbrev 
hit time 	branch unlink 
limit want 	git path list 
scan iteration 	append strbuf 
work 	addf starts list 
want expired 	append xstrdup 
keys use 	resolve xstrdup strbuf 
memory much 	addf git 
time use 	config multivar strbuf 
max active 	reset strbuf 
expire 	addf git 
cycle slow 	config multivar strbuf 
time perc 	reset strbuf 
percentage cpu 	addf git config 
time per 	multivar unlink 
iteration since 	warn git path 
function 	unlink warn 
gets called 	git path usage 
frequency server 	options remote 
times per 	remote configured die 
second following 	strcmp migrate 
max amount 	file remote remote 
microseconds 	configured die 
spend function 	strbuf addf valid 
microseconds increment 	fetch refspec 
sure run 	die strbuf reset 
time current 	strbuf addf 
restart next 	strbuf addf git 
allows 	config rename 
distribute time 	section error 
evenly across 	strbuf reset strbuf 
expire end 	addf git 
cycle keys 	config multivar strbuf 
expired nothing 	addf strbuf 
expire 	reset strbuf addstr 
next asap 	strstr strbuf 
less filled 	splice strlen strlen 
slots getting 	strlen warning 
random keys 	git config multivar 
expensive stop 	read branches 
waiting 	strcmp strbuf reset 
better times 	strbuf addf 
dictionary resized 	git config read 
asap main 	full die 
collection cycle 	strbuf reset strbuf 
sample random 	addstr strbuf 
keys 	splice strlen 
among keys 	strlen strlen strbuf 
expire checking 	reset strbuf 
expired ones 	addf rename die 
want average 	strbuf reset 
ttl keys 	strbuf addstr strbuf 
yet 	splice strlen 
expired update 	strlen strlen strbuf 
average ttl 	reset strbuf 
stats database 	addstr strbuf splice 
simple running 	strlen strlen 
average samples 	strlen strbuf reset 
use 	strbuf addf 
current estimate 	create symref die 
weight previous 	memset usage 
estimate weight 	options remote remote 
block forever 	configured die 
even many 	remote read branches 
keys 	strcmp strbuf 
expire given 	reset strbuf 
amount milliseconds 	addf git config 
caller waiting 	strbuf release 
active expire 	refs list clear 
cycle check 	list clear 
every 	strbuf addf git 
iterations repeat 	config rename 
cycle less 	section error free 
keys found 	free list 
expired current 	clear list clear 
sample operations 	list clear 
per 	list clear list 
second samples 	clear func 
mean samples 	memset remote find 
check timeouts 	tracking list 
returns non 	append abbrev branch 
zero client 	remote error 
terminated 	read branches transport 
function gets 	transport remote 
current time 	refs transport 
milliseconds argument 	disconnect states head 
since gets 	names push 
called multiple 	states list sort 
times 	push states 
loop calling 	noquery strlen list 
gettimeofday iteration 	insert list 
would costly 	list list strcmp 
without actual 	strlen list 
gain timeout 	insert error strlen 
slaves 	strlen list 
timeout masters 	append strcmp strcmp 
timeout blpop 	strbuf addf 
timeout pub 	list append strbuf 
sub clients 	detach list 
blocked ops 	append strbuf addf 
timeout 	list append 
handled milliseconds 	strbuf detach remote 
resolution however 	list sort 
note actual 	strcmp list 
resolution limited 	clear parse options 
server handle 	show memset 
blocking 	memset remote states 
operation specific 	list list 
timeout cluster 	list list list 
handle unblock 	clear list 
redirect clients 	list list clear 
blocked keys 	list qsort 
longer 	list list clear 
served server 	free remote 
client query 	states parse options 
buffer sds 	strbuf addf 
end lot 	xstrdup memset remote 
free space 	states error 
used 	error xstrdup free 
function reclaims 	remote states 
space needed 	error usage 
function always 	options strbuf addf 
returns never 	exists error 
terminates client 	create symref error 
two 	free strbuf 
conditions resize 	release strbuf release 
query buffer 	memset remote 
query buffer 	states free remote 
big arg 	states list 
big latest 	append list sort 
peak 	refs abbrev 
client inactive 	abbrev warn dangling 
buffer bigger 	symrefs list 
resize query 	clear free remote 
buffer actually 	states parse 
wasting space 	options usage options 
reset 	prune remote 
peak capture 	strcmp parse options 
peak memory 	argv push 
usage next 	argv push 
cycle make 	argv push argv 
sure process 	push argv 
least 	push argv push 
numclients server 	strcmp git 
clients per 	config argv pop 
call since 	argv push 
function called 	run command opt 
server times 	argv clear 
per 	git config multivar 
second sure 	gently branch 
worst process 	strbuf release strbuf 
clients second 	addf remote 
process least 	remote configured die 
clients even 	fetch refspecs 
need 	strbuf release branches 
process less 	strbuf release 
clients cron 	parse options error 
min iterations 	usage options 
meet contract 	remote branches 
processing client 	parse options usage 
per 	options remote 
second rotate 	remote configured die 
list take 	die parse 
current head 	options die usage 
process way 	options remote 
client must 	remote configured die 
removed 	strbuf addf 
list first 	strbuf addf git 
element incur 	config multivar 
computation following 	git config strbuf 
functions different 	release regcomp 
service 	die regexec die 
checks client 	die regfree 
protocol non 	git config multivar 
zero client 	git config 
terminated function 	multivar parse options 
handles background 	show strcmp 
operations 	strcmp strcmp 
required incrementally 	strcmp strcmp head 
redis databases 	strcmp branches 
active key 	strcmp url strcmp 
expiring resizing 	url strcmp 
rehashing expire 	show strcmp prune 
keys 	strcmp update 
random sampling 	error usage options 
required slaves 	unspecified previous 
master synthesize 	entry overwritten branches 
perform hash 	file would 
tables rehashing 	url optionally branch 
needed 	specified master 
processes saving 	specified branch fetched 
disk otherwise 	stored local 
rehashing bad 	branch matching remote 
cause lot 	name cogito 
copy write 	compatible push push 
memory 	current head 
pages use 	remote branch 
counters stop 	master missing always 
computation given 	follow handle 
able start 	remote variables handle 
successive next 	remote name 
cron 	variables function frees 
loop iteration 	refspec warning 
test resize 	code paths ensure 
rehash function 	src dst 
work stop 	pointers always freeable 
next cron 	pointers well 
loop 	refspec pointer going 
take cached 	special refspec 
unix time 	pushing matching refs 
state memory 	lhs empty 
aging store 	means head valid 
current time 	looking rhs 
objects 	missing empty 
every access 	empty means store 
accuracy needed 	valid looking 
access lot 	lhs empty allowed 
faster calling 	means wildcarded 
time timer 	must valid looking 
interrupt 	otherwise must 
called server 	extended sha existing 
times per 	way validate 
second number 	empty anything goes 
things need 	rhs missing 
done asynchronously 	allowed lhs must 
instance 	valid looking 
active expired 	empty allowed otherwise 
keys collection 	must valid 
also performed 	looking refspec must 
lazy way 	greater zero 
lookup software 	must valid since 
watchdog 	possible reach 
update statistic 	point within 
incremental rehashing 	loop slash last 
hash tables 	possibility doesn 
triggering bgsave 	occur fetch head 
aof rewrite 	ignore entries 
handling 	always appear end 
terminated children 	list entry 
clients timeout 	already existed match 
different kinds 	weak refs 
replication reconnection 	outside heads tags 
many everything 	specify pattern 
directly 	full refs remotes 
called called 	origin master 
server times 	least toplevel remotes 
per second 	origin master 
order throttle 	otherwise git push 
execution things 	url master 
want 	would result ambiguity 
less frequently 	remotes origin 
macro used 	master heads 
run period 	master remote site 
milliseconds software 	want weak 
watchdog deliver 	matches found multiple 
sigalrm 	matches one 
reach signal 	strong matches found 
handler fast 	ambiguous one 
enough update 	strong match zero 
time cache 	weak matches 
lru bits 	acceptable unique match 
bits 	source could 
per lru 	sha format reference 
information use 	name refs 
eventually wrapping 	way remote end 
lru clock 	matching refs 
note even 	traditionally pushed everything 
counter 	including refs 
wraps big 	outside refs heads 
problem everything 	hierarchy make 
still work 	much sense 
appear younger 	days collect everything 
redis however 	know would 
happen 	end push collect 
given never 	tags collect 
touched time 	tags tag already 
needed counter 	conservative point 
wrap likely 	src tag lists 
note change 	tags missing 
resolution 	dst sent tips 
altering lru 	lists tips 
clock resolution 	pushing know already 
define record 	element src 
max memory 	tag ancestor sent 
used since 	tips needs 
server 	sent side pushing 
started sample 	commit error 
rss since 	tag reachable 
relatively slow 	commits sending given 
call received 	local refs 
sigterm shutting 	sanity check push 
safe 	refspecs errors 
way inside 	match push refs 
signal handler 	would errors 
show info 	early even talking 
non empty 	remote side 
databases dict 	given refs local 
print 	repository refs 
stats server 	remote repository refspec 
dict show 	used push 
information connected 	determine remote refs 
clients need 	update setting 
operations clients 	peer pushed force 
asynchronously 	push forced 
handle background 	elements dst function 
operations redis 	may elements 
databases start 	dst pushing 
scheduled aof 	branch done match 
rewrite requested 	refs pick 
user 	remainder already sending 
bgsave progress 	something remote 
check background 	doesn pattern mirror 
saving aof 	create one 
rewrite progress 	link check missing 
terminated background 	refs remote 
saving 	already sending something 
rewrite progress 	remote moved 
check save 	different expect reject 
rewrite save 	push also 
reached given 	error user told 
amount changes 	check remote 
given 	tracking branch find 
amount seconds 	expect tracking 
latest bgsave 	branch isn stale 
successful error 	force update 
least config 	update isn 
bgsave retry 	already rejected check 
delay 	usual must 
seconds already 	fast forward rules 
elapsed trigger 	decide whether 
aof rewrite 	individual refspec pushed 
needed aof 	push succeed 
postponed flush 	following remote reference 
every 	exist remote 
cron cycle 	reference removed pushing 
slow fsync 	source specified 
completed aof 	destination refs tags 
write errors 	old commit 
buffer flush 	descendant old forced 
well 	notation passing 
clear aof 	force argument force 
error success 	defeat rejection 
make writable 	implemented rules branch 
however every 	already run 
second enough 	merge config 
higher 	make sure confuse 
frequency close 	callers non 
clients need 	zero merge merge 
closed asynchronous 	merge config 
clear paused 	user didn define 
clients flag 	real branch 
needed 	branch vivified non 
check use 	existing refs 
side effect 	create list consisting 
replication cron 	copies remote 
function used 	matches refspec refspec 
reconnect master 	must pattern 
detect 	fill copies peer 
transfer failures 	describe local 
run redis 	tracking refs map 
cluster cron 	omit references 
run sentinel 	would map 
timer sentinel 	existing local symbolic 
mode 	dereference item 
cleanup expired 	old must commit 
migrate cached 	ish descendant 
sockets function 	old otherwise require 
gets called 	force compare 
every time 	branch upstream save 
redis 	differences number 
entering main 	commits num num 
loop driven 	name upstream 
library sleep 	branch upstream defined 
ready file 	returned via 
descriptors call 	upstream name returns 
redis 	num num 
cluster sleep 	could filled upstream 
function note 	defined exist 
function may 	otherwise cannot stat 
change state 	unless marked 
redis cluster 	build top 
fail 	somebody cannot stat 
vice versa 	used build 
good idea 	longer exists run 
call serving 	rev list 
unblocked clients 	left right internally 
later function 	ignored count 
run 	commits side clear 
fast expire 	flags smudged 
cycle called 	traversal anything report 
function asap 	otherwise already 
fast cycle 	know starts refs 
needed send 	transports support 
slaves 	directly peeking head 
ack request 	points guess 
least one 	refs heads master 
client blocked 	could right 
previous loop 	look another points 
iteration used 	matches find 
argument 	suitable refspec 
unblock clients 	symref list refs 
blocked synchronous 	currently exist 
replication wait 	remote consider stale 
process pending 	order deal 
commands clients 	overlapping refspecs need 
unblocked 	matching refs 
write aof 	compare swap option 
buffer disk 	option option 
handle writes 	refname option refname 
pending output 	look remote 
buffers server 	fetch refspec see 
initialization 	remote tracking 
following two 	branch refname fill 
shared objects 	current sha 
minstring maxstrings 	cannot negative signal 
actually used 	error tracking 
special meaning 	refname remote know 
respectively 	tracking cannot 
minimum possible 	read find 
maximum possible 	option name entry 
comparisons zrangebylex 	option cover 
command make 	branch another remote 
sure first 	also uses 
time 	non remote tracking 
match client 	refs advise 
start save 	user local branches 
hour change 	silently skip 
save minutes 	non remote refs 
changes save 	make sure 
minute 	symrefs deleted first 
changes replication 	symrefs rename 
related never 	rest create symrefs 
connected repl 	cannot pass 
since ever 	function deletes branches 
replication resync 	one one 
backlog 	since relies cached 
client output 	refs invalidated 
buffer limits 	deleting branch 
constants initialization 	sorting comparison list 
command table 	push info 
initiialize part 	structs field remote 
initial 	branch info 
configuration since 	git pull info 
command names 	git push 
may changed 	info make sure 
via redis 	valid fetch 
conf rename 	mode use fetch 
command 	url push 
directive slow 	found requested special 
log latency 	cases entry 
monitor debugging 	old url specified 
restart server 	demand one 
executing executable 	matches remote.c tag 
started 	refspec tag 
instance arguments 	refspec len 
configuration file 	baselen instead instead 
function designed 	instead alloc 
directly call 	rewrite rewrite alloc 
execve server 	rewrite remotes 
instance 	remotes alloc remotes 
retain pid 	remotes hash 
previous one 	branches branches alloc 
list flags 	branches current 
may bitwise 	branch pushremote name 
red together 	rewrites rewrites 
alter 	push remote url 
behavior function 	longest longest 
restart server 	remote remote remote 
none flags 	url remote 
restart server 	pushurl remote url 
gracefully proper 	pushurl remote 
shutdown 	url str len 
restarting restart 	key name 
server config 	len ret 
rewrite rewrite 	replaced lookup lookup 
config file 	entry branch 
restarting success 	name name len 
function 	ret len 
process turns 	ret rewrite instead 
different process 	remote buf 
error err 	remote frag buf 
returned check 	key name 
still accesses 	namelen subkey remote 
executable 	branch rewrite 
started server 	pushurl aliases loaded 
instance config 	oid head 
rewriting perform 	flag refspec refspec 
proper shutdown 	refspec refspec 
close file 	fetch verify llen 
descriptors 	glob lhs 
stdin stdout 	rhs flags rlen 
strerr useful 	unused fetch 
restart redis 	refspec str 
server daemonized 	refspec refspec refspec 
execute server 	refspec refspec 
original 	refspec refspec name 
command line 	branch branch 
error occurred 	name ret name 
nothing exit 	given name 
never reached 	name remote priv 
function max 	result map 
number 	refs retval item 
open files 	remote url 
accordingly configured 	key name result 
max number 	kstar klen 
clients also 	ksuffixlen namelen ret 
reserves number 	vstar refs 
file 	count query results 
descriptors config 	find src 
min reserved 	refspec key needle 
fds extra 	result refs 
operations persistence 	count query 
listening sockets 	find src needle 
log 	result refspec 
files forth 	key refspecs refspec 
possible limit 	name query 
accordingly configured 	remote refspec prefix 
max number 	prefixlen name 
clients function 	len name cpy 
reverse 	len ret 
setting server 	tail next next 
maxclients actually 	cmp pattern 
handle max 	refs matched patlen 
number files 	matched weak 
current limit 	matched weak match 
enough 	match name 
needs file 	namelen tail name 
limit match 	match oid 
maxfiles least 	name tail 
higher supported 	ret name peer 
less maxfiles 	buf oid 
failed 	src match allocated 
file limit 	match src 
bestlimit smaller 	dst dst tail 
limit decrementing 	matched src 
per iteration 	matched dst allocated 
limit initially 	src dst 
still 	dst guess oid 
valid last 	flag src 
even lower 	dst dst tail 
check server 	errs send 
tcp backlog 	mirror direction ret 
actually enforced 	pat pat 
linux 	name matching refs 
according proc 	dst side 
sys net 	match head tail 
core somaxconn 	tip alloc 
warn initialize 	tips oid 
file descriptors 	commit src dst 
listen 	dst tail 
specified port 	dst tag src 
binding addresses 	tag item 
specified redis 	sent tips dst 
server configuration 	commit list 
listening file 	name index src 
descriptors 	refspec refspec 
stored integer 	names refspec ret 
fds number 	src dst 
count addresses 	refspec refspec flags 
bind specified 	send send 
server bindaddr 	mirror send prune 
number 	errs refspec 
server bindaddr 	dst tail dst 
count server 	index dst 
configuration contains 	item dst peer 
specific addresses 	pat dst 
bind function 	name src 
bind 	index src name 
addresses protocols 	remote refs 
success function 	send mirror force 
returns error 	update force 
function returns 	update reject reason 
err function 	ret remote 
error 	oid name ret 
least one 	branch branch 
server bindaddr 	refname err fmt 
addresses impossible 	branch err 
bind bind 	remote refname err 
addresses specified 	ret branch 
server 	err remote dst 
configuration function 	ret cur 
able bind 	branch err refname 
least one 	oid flag 
protocols force 	remote refs refspec 
binding bind 	ret tail 
address 	expn name 
specified always 	cpy refs name 
entering loop 	remote refs 
bind enter 	name name remote 
server bindaddr 	refs refspec 
count exit 	tail missing map 
loop 	rmp name 
able bind 	ignore list list 
otherwise fds 	mark commit 
count anet 	oid old oid 
err print 	old list 
error caller 	used found branch 
error 	num num 
bind address 	upstream name oid 
bind address 	revs argv 
resets stats 	branch full upstream 
expose via 	gone refname 
info means 	oid flag 
want 	data local tail 
reset via 	local tail 
config resetstat 	head refs list 
function also 	tail names 
used order 	stale refs tail 
initialize 	refs count 
fields init 	refname oid flags 
server server 	data info 
startup force 	matches query stale 
emit first 	refs count 
command open 	fetch map stale 
tcp 	refs names 
listening socket 	info cas cas 
user commands 	refname refnamelen 
open listening 	entry cas arg 
unix domain 	unset colon 
socket care 	entry opt arg 
fails 	unset cas 
abort listening 	remote refname 
sockets create 	oid dst cas 
redis databases 	remote entry 
initialize state 	cas remote remote 
startup consider 	refs starts 
saved 	xstrfmt alloc grow 
startup never 	alloc grow 
tried bgsave 	alloc grow alloc 
stats want 	grow url 
reset server 	pushurl url url 
startup time 	pushurl strncmp 
peak 	strcmp hashmap init 
mem create 	strlen init 
server cron 	remotes hash hashmap 
time main 	entry init 
way process 	memhash hashmap xcalloc 
background operations 	alloc grow 
create 	xstrndup hashmap entry 
handler accepting 	init hashmap 
connections tcp 	put alloc 
unix domain 	grow strncmp strcmp 
sockets open 	alloc grow 
aof file 	xcalloc xstrndup xstrdup 
needed 	xstrfmt strncmp 
bit instances 	strcmp alloc grow 
limited address 	xcalloc xstrndup 
space limit 	xstrdup strlen alloc 
user provided 	grow strlen 
configuration limit 	isspace fopen git 
maxmemory 	path strbuf 
noeviction policy 	getline strbuf rtrim 
avoids useless 	skip prefix 
crashes redis 	url xstrdup skip 
instance memory 	spaces skip 
populates redis 	prefix push refspec 
command 	xstrdup skip 
table starting 	spaces skip prefix 
hard coded 	fetch refspec 
list top 	xstrdup skip 
redis file 	spaces strbuf release 
populate additional 	fclose fopen 
dictionary 	git path strbuf 
unaffected rename 	getline fclose 
command statements 	strbuf trim strbuf 
redis conf 	release strchr 
redis api 	url strbuf detach 
commands lookup 	fetch refspec 
execution 	xstrfmt push refspec 
lookup command 	xstrfmt parse 
current table 	config key make 
found also 	branch strcmp 
check original 	git config strcmp 
table containing 	git config 
original 	strcmp config error 
command names 	nonbool merge 
unaffected redis 	xstrdup parse config 
conf rename 	key strcmp 
command statement 	make rewrite 
used functions 	config error nonbool 
rewriting 	instead xstrdup 
argument vector 	strcmp make rewrite 
rewrite client 	config error 
command vector 	nonbool instead xstrdup 
order client 	parse config 
cmd pointer 	key strcmp git 
correctly 	config warning 
even command 	make remote strcmp 
renamed propagate 	git config 
specified command 	strcmp git config 
context specified 	strcmp git 
database aof 	config strcmp git 
slaves 	config strcmp 
flags xor 	git config url 
propagate none 	strcmp git 
propagation command 	config pushurl 
propagate aof 	strcmp git config 
propagate aof 	push refspec 
file 	strcmp git config 
enabled propagate 	fetch refspec 
repl propagate 	strcmp git config 
replication link 	error strcmp 
used inside 	git config error 
commands implementation 	strcmp strcmp 
use 	strcmp strcmp git 
instead also 	config strcmp 
propagate prevent 	git config strcmp 
command propagation 	git config 
force command 	url pushurl url 
propagation used 	resolve skip 
inside 	prefix make branch 
commands schedule 	git config 
propagation additional 	urls free free 
commands current 	free xcalloc 
command propagated 	strrchr strlen 
aof replication 	strchr xstrndup strlen 
cmd 	memchr xstrndup 
must pointer 	oid hex check 
redis command 	refname format 
replicate dbid 	check refname format 
database command 	check refname 
propagated arguments 	format check refname 
command 	format check 
propagte passed 	refname format free 
redis objects 	refspecs die 
pointers len 	parse refspec free 
argc argv 	refspecs parse 
vector function 	refspec parse refspec 
take 	free free 
reference passed 	free dot dotdot 
argv vector 	strchr remote 
caller release 	branch read config 
passed argv 	make remote 
usually stack 	valid remote 
allocated 	nick valid remote 
function autoamtically 	read remotes 
increments count 	file valid remote 
passed objects 	read branches 
caller need 	file valid remote 
propagation loading 	url valid 
possible 	remote parse fetch 
call function 	refspec parse 
force command 	push refspec remote 
propagation inside 	remote read 
redis command 	config parse fetch 
implementation order 	refspec parse 
force 	push refspec strcmp 
propagation specific 	die warning 
command execution 	die die free 
aof replication 	free list 
avoid executed 	insert handle duplicate 
command propagated 	list clear 
way 	strcmp strchr 
free propagate 	die strlen strlen 
want also 	strncmp memcmp 
propagate api 	strchr die strbuf 
aof specific 	strbuf strbuf 
version prevent 	addstr strbuf detach 
command 	error match 
propagation replication 	name pattern list 
specific version 	append nodup 
prevent command 	strcmp list append 
propagation call 	error match 
core redis 	name pattern strcmp 
execution 	xstrdup memset 
command following 	query refspecs query 
flags passed 	refspecs strlen 
cmd call 	xcalloc memcpy memcpy 
none flags 	alloc prefix 
cmd call 	strlen xmalloc 
slowlog 	memcpy xstrdup xstrdup 
check command 	copy copy 
speed log 	free free free 
slow log 	free free 
needed cmd 	strcmp llist mergesort 
call stats 	strlen strlen 
populate 	refname match starts 
command stats 	starts alloc 
cmd call 	oidclr alloc sha 
propagate aof 	alloc oidcpy 
append command 	alloc tail link 
aof modified 	resolve starts 
dataset 	strbuf addstr starts 
client flags 	strbuf addstr 
forcing propagation 	strbuf addstr strbuf 
cmd call 	detach count 
propagate repl 	refspec match name 
send command 	error error 
salves 	match lhs 
modified dataset 	resolve starts die 
client flags 	count refspec 
forcing propagation 	match starts make 
cmd call 	linked oid 
propagate propagate 	error guess make 
aof 	linked error 
propagate repl 	error error copy 
cmd call 	match match 
full slowlog 	name pattern match 
stats propagate 	name pattern 
exact propagation 	starts xstrdup oid 
behavior 	lookup commit 
depends client 	reference gently alloc 
flags specifically 	grow memset 
client flags 	oid tips tips 
client force 	starts list 
aof client 	append clear commit 
force 	marks many 
repl assuming 	list sort 
corresponding cmd 	starts list sha 
call propagate 	info list 
aof repl 	append list clear 
call flags 	oid lookup 
command 	commit reference gently 
propagated even 	merge bases 
dataset affected 	many make linked 
command client 	oidcpy copy 
flags client 	list clear free 
prevent repl 	strcmp list 
prop 	append nodup list 
client prevent 	sort parse 
aof prop 	push refspec match 
propagation aof 	lhs free 
slaves performed 	refspec tail parse 
even command 	push refspec 
modified 	match refs match 
dataset note 	prepare index 
regardless client 	list lookup 
flags cmd 	make linked oidcpy 
call propagate 	list insert 
aof cmd 	copy free list 
call 	clear missing 
propagate repl 	tags match prepare 
respectively aof 	index list 
slaves propagation 	alloc free list 
never occur 	clear oidcpy 
client flags 	oid oidcmp oidcmp 
modified 	oid starts 
implementation given 	file lookup commit 
command following 	reference gently 
api force 	lookup commit reference 
command propagation 	gently newer 
client flags 	remote xcalloc xcalloc 
prevent 	xstrdup remote 
command propagation 	find tracking 
client prevent 	strcmp dwim strlen 
command aof 	xstrdup read 
client prevent 	config strcmp make 
command replication 	branch merge 
client 	refname match start 
sent command 	strbuf vaddf 
clients monitor 	end error buf 
mode commands 	exists error 
generated reading 	buf error buf 
aof initialization 	error buf 
clear 	apply refspecs error 
flags must 	buf error 
command demand 	buf remote pushremote 
initialize additional 	branch error 
commands propagation 	buf apply refspecs 
call command 	error buf 
eval 	tracking push dest 
called loading 	free tracking 
aof want 	push dest 
commands called 	error buf tracking 
lua slowlog 	push dest 
populate statistics 	branch upstream branch 
caller 	upstream tracking 
lua want 	push dest strcmp 
force eval 	error buf 
caller propagate 	die branch push 
script command 	resolve strchr 
flag client 	match name pattern 
flag 	ignore symref 
forcing propagation 	update copy alloc 
log command 	free refname 
slow log 	match find name 
needed populate 	abbrev copy 
per command 	starts alloc starts 
statistics 	starts starts 
show info 	alloc prefix alloc 
commandstats propagate 	prefix expanded 
command aof 	map alloc 
replication link 	oid hex remote 
check command 	die local 
operated 	starts check refname 
changes data 	format error 
replication aof 	free free tail 
propagation client 	link strcmp 
forced aof 	oidcpy pop commit 
replication command 	deref tag 
flags 	parse deref tag 
regardless command 	parse parse 
effects data 	commit commit list 
however prevent 	insert pop 
aof replication 	recent commit commit 
propagation command 	list insert 
implementatino 	unmark free unmark 
called prevent 	free branch 
command propagation 	upstream read lookup 
similar call 	commit reference 
flags call 	read lookup 
propagate least 	commit reference argv 
one 	push argv 
aof replication 	push argv pushf 
propagation needed 	oid hex 
restore old 	oid hex argv 
replication flags 	push init 
since call 	revisions setup revisions 
executed 	prepare revision 
recursively handle 	walk die revision 
also propagate 	clear commit 
api handle 	marks clear commit 
commands want 	marks argv 
propagate multiple 	clear stat tracking 
separated 	info shorten 
commands note 	unambiguous strbuf addf 
also propagate 	strbuf addf 
affected client 	strbuf addf strbuf 
prevent prop 	addf strbuf 
flag whatever 	addf strbuf 
command 	addf strbuf addf 
wish honor 	strbuf addf 
call flags 	strbuf addf free 
function gets 	check refname 
called already 	format alloc oidcpy 
read whole 	copy find 
command 	name find name 
arguments client 	oidcmp copy 
argv argc 	starts oidcmp copy 
fields process 	memset query 
command execute 	refspecs multiple list 
command prepare 	make linked 
server 	oidcpy list clear 
bulk read 	list append 
client returned 	list sort list 
client still 	clear free 
alive valid 	free memset 
operations performed 	alloc grow memset 
caller 	xmemdupz clear 
otherwise err 	cas option strchrnul 
returned client 	cas entry 
destroyed quit 	sha error parse 
quit command 	push cas 
handled separately 	option apply refspecs 
normal 	read refname 
command procs 	match hashcpy remote 
checking replication 	tracking remote 
quit cause 	tracking apply cas 
trouble force 	unspecified previous 
replication enabled 	entry overwritten branches 
would 	file would 
implemented regular 	url optionally branch 
command proc 	specified master 
lookup command 	specified branch fetched 
check asap 	stored local 
trivial error 	branch matching 
conditions 	remote name cogito 
wrong arity 	compatible push 
bad command 	push current head 
name forth 	remote branch 
check user 	master missing always 
authenticated cluster 	follow handle 
enabled 	remote variables handle 
perform cluster 	remote name 
redirection however 	variables function frees 
perform redirection 	refspec warning 
sender command 	code paths ensure 
master command 	src dst 
key 	pointers always freeable 
arguments handle 	pointers well 
maxmemory directive 	refspec pointer going 
first free 	special refspec 
memory possible 	pushing matching refs 
keys dataset 	lhs empty 
thing 	means head 
returning error 	valid looking rhs 
free memory 	missing empty 
needed may 	empty means store 
flush slave 	valid looking 
output buffers 	lhs empty allowed 
may 	means wildcarded 
result slave 	must valid looking 
may active 	otherwise must 
client freed 	extended sha existing 
impossible free 	way validate 
enough memory 	empty anything goes 
command 	rhs missing 
client trying 	allowed lhs must 
execute denied 	valid looking 
oom conditions 	empty allowed otherwise 
error accept 	must valid 
write commands 	looking refspec must 
problems 	greater zero 
persisting disk 	must valid 
master instance 	since possible reach 
accept write 	point within 
commands enough 	loop slash last 
good slaves 	possibility doesn 
user 	occur fetch head 
configured min 	ignore entries 
slaves write 	always appear end 
option accept 	list entry 
write commands 	already existed match 
read slave 	weak refs 
accept 	outside heads tags 
write commands 	specify pattern 
master allow 	full refs remotes 
subscribe unsubscribe 	origin master 
context pub 	least toplevel remotes 
sub allow 	origin master 
info 	otherwise git 
slaveof slave 	push url master 
serve stale 	would result 
data slave 	ambiguity remotes origin 
broken link 	master heads 
master loading 	master remote site 
error 	want weak 
command cmd 	matches found multiple 
loading flag 	matches one 
lua script 	strong matches found 
slow allow 	ambiguous one 
limited number 	strong match zero 
commands 	weak matches 
exec command 	acceptable unique match 
shutdown close 	source could 
listening sockets 	sha format reference 
also unlink 	name refs 
unix domain 	way remote end 
socket 	matching refs 
unlink unix 	traditionally pushed 
socket non 	everything including refs 
zero care 	outside refs 
fails kill 	heads hierarchy make 
lua debugger 	much sense 
forked 	days collect everything 
sessions kill 	know would 
saving child 	end push collect 
background saving 	tags collect 
progress want 	tags tag already 
avoid 	conservative point 
race conditions 	src tag lists 
instance saving 	tags missing 
child may 	dst sent tips 
overwrite synchronous 	lists tips 
saving shutdown 	pushing know already 
kill 	element src 
aof saving 	tag ancestor sent 
child aof 	tips needs 
already may 	sent side 
longer contains 	pushing commit error 
full dataset 	tag reachable 
anyway 	commits sending given 
aof enabled 	local refs 
haven written 	sanity check push 
aof yet 	refspecs errors 
shutdown dataset 	match push refs 
lost append 	would errors 
file 	early even talking 
fsync aof 	remote side 
exit create 	given refs local 
rdb file 	repository refs 
exiting snapshotting 	remote repository refspec 
perform sync 	used push 
save 	determine remote refs 
exit ooops 	update setting 
error saving 	peer pushed force 
best operating 	push forced 
note background 	elements dst 
saving process 	function may elements 
next 	dst pushing 
cron redis 	branch done match 
notified background 	refs pick 
saving aborted 	remainder already sending 
handling special 	something remote 
stuff like 	doesn pattern mirror 
slaves 	create one 
pending synchronization 	link check missing 
pid file 	refs remote 
possible needed 	already sending something 
best effort 	remote moved 
flush slave 	different expect reject 
output 	push also 
buffers hopefully 	error user told 
send pending 	check remote 
writes close 	tracking branch 
listening sockets 	find expect tracking 
apparently allows 	branch isn 
faster 	stale force update 
restarts commands 	update isn 
zero non 	already rejected check 
zero comparison 	usual must 
performed way 	fast forward rules 
prevents attacker 	decide whether 
obtain 	individual refspec pushed 
information nature 	push succeed 
monitoring execution 	following remote reference 
time function 	exist remote 
note limiting 	reference removed pushing 
comparison length 	source specified 
bytes 	destination refs tags 
avoid leaking 	old commit 
information password 	descendant old forced 
length possible 	notation passing 
branch misprediction 	force argument 
related leak 	force defeat rejection 
two 	implemented rules 
strlen perform 	branch already run 
len len 	merge config 
operations either 	make sure confuse 
password length 	callers non 
difference relative 	zero merge merge 
length 	merge config 
user provided 	user didn define 
information leak 	real branch 
possible following 	branch vivified non 
two lines 	existing refs 
code compare 	create list consisting 
longer 	copies remote 
buffers note 	matches refspec refspec 
never pass 	must pattern 
first test 	fill copies peer 
practical circumstances 	describe local 
info leak 	tracking refs 
constant 	map omit references 
time constant 	would map 
time time 	existing local symbolic 
following two 	dereference item 
copies proportional 	old must commit 
len len 	ish descendant 
info 	old otherwise require 
leaked always 	force compare 
compare chars 	branch upstream save 
two buffers 	differences number 
without conditional 	commits num num 
expressions length 	name upstream 
must 	branch upstream defined 
equal well 	returned via 
zero ping 	upstream name returns 
command works 	num num 
different way 	could filled upstream 
client pub 	defined exist 
sub 	otherwise cannot 
mode command 	stat unless marked 
takes zero 	build top 
one arguments 	somebody cannot stat 
gettimeofday fail 	used build 
bad address 	longer exists run 
check 	rev list 
errors helper 	left right internally 
function reply 	ignored count 
command output 	commits side clear 
flags output 	flags smudged 
representation redis 	traversal anything report 
command 	otherwise already 
used command 	know starts refs 
command adding 	transports support 
command name 	directly peeking head 
arg count 	points guess 
flags first 	refs heads master 
last 	could right 
offset command 	look another 
subcommand args 	points matches find 
convert amount 	suitable refspec 
bytes human 	symref list refs 
readable form 	currently exist 
forth 	remote consider stale 
bytes hope 	order deal 
never need 	overlapping refspecs need 
create returned 	matching refs 
info command 	compare swap option 
decoupled info 	option option 
command 	refname option refname 
need report 	look remote 
information memory 	fetch refspec see 
corruption problems 	remote tracking 
server uname 	branch refname fill 
slow always 	current sha 
output 	cannot negative 
cache clients 	signal error tracking 
memory peak 	refname remote 
memory updated 	know tracking cannot 
time time 	read find 
server cron 	option name entry 
may 	option cover 
happen instantaneous 	branch another remote 
slightly bigger 	also uses 
peak may 	non remote tracking 
confuse users 	refs advise 
update peak 	user local branches 
found 	silently skip 
smaller current 	non remote refs 
memory usage 	make sure 
persistence fake 	symrefs deleted first 
second figure 	symrefs rename 
enough info 	rest create symrefs 
stats 	cannot pass 
replication min 	function deletes 
slaves write 	branches one one 
active write 	since relies 
number slaves 	cached refs invalidated 
currently considered 	deleting branch 
good 	sorting comparison list 
cpu cmdtime 	push info 
cluster key 	structs field remote 
space ignore 	branch info 
monitor already 	git pull info 
slave monitor 	git push 
mode 	info make sure 
maxmemory directive 	valid fetch 
free memory 	mode use fetch 
needed gets 	url push 
called maxmemory 	found requested special 
config file 	cases entry 
limit 	old url specified 
max memory 	demand one 
used server 	matches builtin 
processing command 	remote usage builtin 
goal function 	remote usage 
free enough 	builtin remote rename 
memory 	usage builtin 
keep redis 	remote usage builtin 
configured memory 	remote sethead 
limit function 	usage builtin remote 
starts calculating 	setbranches usage 
many bytes 	builtin remote show 
freed 	usage builtin 
keep redis 	remote prune usage 
limit enters 	builtin remote 
loop selecting 	update usage builtin 
best keys 	remote geturl 
evict accordingly 	usage builtin remote 
configured 	seturl usage 
policy bytes 	verbose name argv 
needed back 	key branchname 
limit freed 	remotename mirror 
function returns 	tmp mirror advice 
otherwise err 	opt arg 
returned 	mirror argc argv 
caller block 	fetch tags 
execution commands 	mirror track master 
result memory 	remote buf 
used server 	name url options 
lru approximation 	remote name 
algorithm 	merge branch list 
redis uses 	name prefix 
approximation lru 	key orig key 
algorithm runs 	name item 
constant memory 	info key len 
every time 	space merge 
key 	remote stale tracked 
expire sample 	heads push 
keys small 	queried remote 
usually around 	refs states tail 
populate pool 	stale refs 
best keys 	item dest forced 
evict 	remote refs 
keys pool 	states remote local 
size defined 	refs push 
maxmemory eviction 	map item info 
pool size 	states remote 
keys sampled 	item info spec 
added 	remote refs 
pool good 	states matches fetch 
keys expire 	map tail 
one old 	refspec next remote 
access time 	list remote 
better one 	data remote branches 
current 	skipped keep 
keys pool 	refname oid flags 
pool populated 	data branches 
best key 	refspec old 
pool expired 	remote branches refname 
however note 	oid flags 
keys 	data rename buf 
pool deleted 	item flag 
pool may 	orig oid symref 
contain keys 	remote buf 
longer exist 	argc argv options 
evict key 	oldremote newremote 
entries 	old remote context 
pool exist 	remote branches 
populate time 	rename refspec updated 
sure pool 	ptr item 
least one 	info item flag 
key evicted 	oid item 
least 	item argc argv 
one key 	options remote 
evicted whole 	buf known remotes 
database create 	branches skipped 
eviction pool 	data result 
helper function 	item info info 
free 	states refname 
memory needed 	oid flags data 
used order 	states refspec 
populate eviction 	name states query 
pool entries 	transport remote 
every time 	refs list states 
want 	width width 
expire key 	rebase item data 
keys idle 	info item 
time smaller 	data info states 
one current 	name fmt 
keys added 	arg branch item 
keys 	data show 
always added 	info states branch 
free entries 	info item 
insert keys 	item data show 
place order 	info branch 
keys smaller 	info merge 
idle 	also push item 
time left 	data show 
keys higher 	info push info 
idle time 	item push 
right use 	push cmp item 
buffer function 	data show 
big 	info push info 
hit note 	status remote 
actually measured 	priv list url 
helps dictionary 	buf url 
sampling main 	url list result 
dictionary expires 	item argc 
one 	argv query flag 
need lookup 	options states 
key key 	info list info 
dictionary obtain 	url url 
insert element 	argc argv 
inside pool 	result buf head 
first 	name options 
find first 	states remote dry 
empty bucket 	run result 
first populated 	states refs prune 
bucket idle 	item dangling 
time smaller 	msg refname argc 
idle 	argv result 
time insert 	options key priv 
element worst 	found argc 
element empty 	argv prune options 
buckets inserting 	fetch argv 
empty position 	defined retval remote 
setup 	key remote 
needed insert 	branches key remotename 
inserting middle 	mirror refspec 
points first 	remotename branches mode 
element greater 	key remote 
element insert 	argc argv 
free 	mode options argc 
space right 	argv mode 
insert shifting 	remotename remote url 
elements end 	url options 
right free 	argc argv mode 
space right 	negative matches 
insert 	remotename newurl oldurl 
shift elements 	remote old 
left included 	regex urlset urlset 
left discard 	name buf 
element smaller 	options argc argv 
idle time 	prefix options 
size 	result run command 
slaves output 	opt error 
buffers aof 	strbuf reset strbuf 
buffer count 	addch strbuf 
used memory 	addf strbuf addf 
check memory 	git config 
limit 	multivar warning 
need free 	strcmp strcmp error 
memory policy 	parse options 
forbids compute 	usage options die 
much memory 	die remote 
need free 	remote configured die 
prevent 	strbuf addf 
warning random 	valid fetch refspec 
allkeys random 	die strbuf 
policy lru 	addf git config 
allkeys lru 	strbuf reset 
policy backward 	strbuf addf list 
best 	append branch 
worst element 	strbuf reset strbuf 
evict entry 	addf git 
pool shift 	config strbuf reset 
elements right 	strbuf addf 
left clear 	git config fetch 
element 	remote strbuf 
right empty 	reset strbuf 
since shifted 	addf strbuf reset 
one position 	strbuf addf 
left key 	create symref error 
exists pick 	strbuf release 
otherwise 	strbuf release list 
ghost need 	clear skip 
next element 	prefix starts strip 
ghost ttl 	suffix xmemdupz 
expire sooner 	strip suffix xmemdupz 
minor expire 	strip suffix 
unix 	xmemdupz list insert 
timestamp better 	xcalloc warning 
candidate deletion 	xstrdup strchr abbrev 
selected key 	branch xstrndup 
compute amount 	list append abbrev 
memory freed 	branch strchr 
alone 	list append xstrdup 
possible actually 	git config 
memory needed 	maybe strcmp 
propagate del 	strcmp git config 
aof replication 	fetch map 
link greater 	die exists list 
one 	append abbrev 
freeing removing 	branch list append 
key account 	abbrev branch 
otherwise would 	stale heads list 
never exit 	append abbrev 
loop aof 	branch xstrdup free 
output 	refs free 
buffer memory 	refs list sort 
freed eventually 	list sort 
care memory 	list sort local 
used key 	heads copy 
space memory 	list match push 
free 	refs oidcpy 
starts big 	list append 
enough may 	abbrev branch xcalloc 
start spending 	xstrdup abbrev 
much time 	branch oid oidcmp 
impossible deliver 	oid file 
data 	newer free refs 
slaves fast 	free refs 
enough force 	list append xcalloc 
transmission inside 	xstrdup list 
loop nothing 	append strlen list 
free main 	append list 
linux 	append xcalloc xstrdup 
pidfile requested 	fetch map 
pidfile defined 	guess remote head 
use pidfile 	find name 
path write 	list append abbrev 
pid file 	branch free 
best 	refs free refs 
effort way 	strcmp xmalloc 
parent exits 	memset remote 
create session 	find tracking memset 
every output 	remote find 
goes dev 	tracking starts starts 
redis 	list append 
daemonized logfile 	abbrev branch unlink 
stdout configuration 	git path 
file log 	list append strbuf 
sigint often 	addf starts 
delivered via 	list append xstrdup 
ctrl 	resolve xstrdup 
interactive session 	strbuf addf git 
receive signal 	config multivar 
second time 	strbuf reset strbuf 
interpret user 	addf git 
really wanting 	config multivar strbuf 
quit 	reset strbuf 
asap without 	addf git config 
waiting persist 	multivar unlink 
disk exit 	warn git 
error since 	path unlink warn 
clean shutdown 	git path 
siginfo 	usage options remote 
flag flags 	remote configured 
sigaction used 	die strcmp migrate 
otherwise handler 	file remote 
used returns 	remote configured die 
sentinel among 	strbuf addf 
arguments 	valid fetch refspec 
argv exactly 	die strbuf 
redis sentinel 	reset strbuf addf 
function called 	strbuf addf 
startup load 	git config rename 
rdb aof 	section error 
file 	strbuf reset strbuf 
memory check 	addf git 
whether systemd 	config multivar strbuf 
upstart used 	addf strbuf 
start redis 	reset strbuf 
test 	addstr strstr strbuf 
found need 	splice strlen 
initialize libraries 	strlen strlen warning 
server configuration 	git config 
store executable 	multivar read branches 
path arguments 	strcmp strbuf 
safe 	reset strbuf addf 
place order 	git config 
able restart 	read full die 
server later 	strbuf reset 
need init 	strbuf addstr strbuf 
sentinel right 	splice strlen 
parsing 	strlen strlen strbuf 
configuration file 	reset strbuf 
sentinel mode 	addf rename die 
effect populating 	strbuf reset 
sentinel data 	strbuf addstr 
structures master 	strbuf splice strlen 
nodes 	strlen strlen 
monitor check 	strbuf reset strbuf 
need start 	addstr strbuf 
redis check 	splice strlen strlen 
rdb mode 	strlen strbuf 
execute program 	reset strbuf addf 
main 	create symref 
however program 	die memset usage 
part redis 	options remote 
executable easily 	remote configured die 
execute rdb 	remote read 
check loading 	branches strcmp strbuf 
errors 	reset strbuf 
first option 	addf git config 
parse argv 	strbuf release 
handle special 	refs list clear 
options help 	list clear 
version first 	strbuf addf 
argument 	git config rename 
config file 	section error 
name replace 	free free list 
config file 	clear list 
server exec 	clear list clear 
argv absoulte 	list clear 
path 	list clear func 
options parsed 	memset remote 
conceptually appended 	find tracking list 
configuration file 	append abbrev 
instance port 	branch remote error 
generate port 	read branches 
parsed 	transport transport remote 
actual file 	refs transport 
name parsed 	disconnect states head 
option name 	names push 
argument options 	states list sort 
need skip 	push states 
parsing 	noquery strlen 
option argument 	list insert list 
things needed 	list list 
running sentinel 	strcmp strlen list 
mode warning 	insert error 
user suspicious 	strlen strlen list 
maxmemory 	append strcmp 
setting end 	strcmp strbuf addf 
server.h idle 	list append 
key seconds 	strbuf detach list 
changes crlf 	append strbuf 
err emptybulk 	addf list append 
czero 	strbuf detach 
cone cnegone 	remote list sort 
pong space 	strcmp list 
colon nullbulk 	clear parse options 
nullmultibulk queued 	show memset 
emptymultibulk wrongtypeerr 	memset remote states 
nokeyerr 	list list 
syntaxerr sameobjecterr 	list list 
outofrangeerr noscripterr 	list clear list 
loadingerr slowscripterr 	list list 
bgsaveerr masterdownerr 	clear list qsort 
roslaveerr execaborterr 	list list 
noautherr 	clear free remote 
noreplicaserr busykeyerr 	states parse 
oomerr plus 	options strbuf addf 
messagebulk pmessagebulk 	xstrdup memset 
subscribebulk unsubscribebulk 	remote states error 
psubscribebulk punsubscribebulk 	error xstrdup 
del 	free remote states 
rpop lpop 	error usage 
lpush emptyscan 	options strbuf addf 
minstring maxstring 	exists error 
integers mbulkhdr 	create symref error 
bulkhdr client 	free strbuf 
buffer 	release strbuf 
limits defaults 	release memset remote 
pid configfile 	states free 
executable exec 	remote states list 
argv commands 	append list 
orig commands 	sort refs abbrev 
shutdown 	abbrev warn 
asap activerehashing 	dangling symrefs list 
requirepass pidfile 	clear free 
arch bits 	remote states parse 
cronloops runid 	options usage 
sentinel mode 	options prune remote 
port 	strcmp parse 
tcp backlog 	options argv push 
bindaddr bindaddr 	argv push 
count unixsocket 	argv push argv 
unixsocketperm ipfd 	push argv 
ipfd count 	push argv push 
sofd 	strcmp git 
cfd cfd 	config argv 
count clients 	pop argv push 
clients close 	run command 
clients pending 	opt argv clear 
write slaves 	git config 
monitors 	multivar gently branch 
current client 	strbuf release 
clients paused 	strbuf addf remote 
clients pause 	remote configured 
end time 	die fetch refspecs 
neterr migrate 	strbuf release 
cached 	branches strbuf release 
sockets next 	parse options 
client mode 	error usage options 
loading loading 	remote branches 
total bytes 	parse options usage 
loading loaded 	options remote 
bytes 	remote configured die 
loading start 	die parse 
time loading 	options die 
process events 	usage options remote 
interval bytes 	remote configured 
del command 	die strbuf addf 
multi 	strbuf addf 
command lpush 	git config multivar 
command lpop 	git config 
command rpop 	strbuf release regcomp 
command srem 	die regexec 
command exec 	die die regfree 
command 	git config 
stat starttime 	multivar git config 
stat numcommands 	multivar parse 
stat numconnections 	options show strcmp 
stat expiredkeys 	strcmp strcmp 
stat evictedkeys 	strcmp strcmp head 
stat 	strcmp branches 
keyspace hits 	strcmp url strcmp 
stat keyspace 	url strcmp 
misses stat 	show strcmp 
peak memory 	prune strcmp update 
stat fork 	error usage 
time 	options unspecified previous 
stat fork 	entry overwritten 
rate stat 	branches file would 
rejected conn 	url optionally 
stat sync 	branch specified master 
full stat 	specified branch 
sync 	fetched stored local 
stat sync 	branch matching 
err slowlog 	remote name cogito 
slowlog entry 	compatible push 
slowlog log 	push current head 
slower slowlog 	remote branch 
max 	master missing always 
len resident 	follow handle 
size stat 	remote variables handle 
net input 	remote name 
bytes stat 	variables function 
net output 	frees refspec warning 
bytes 	code paths 
last sample 	ensure src dst 
time last 	pointers always 
sample count 	freeable pointers well 
samples idx 	refspec pointer 
verbosity maxidletime 	going special refspec 
tcpkeepalive 	pushing matching 
active expire 	refs lhs empty 
enabled client 	means head 
max querybuf 	valid looking rhs 
len dbnum 	missing empty 
supervised supervised 	empty means store 
mode 	valid looking 
daemonize client 	lhs empty allowed 
obuf limits 	means wildcarded 
aof state 	must valid 
aof fsync 	looking otherwise must 
aof filename 	extended sha 
aof 	existing way validate 
fsync rewrite 	empty anything 
aof rewrite 	goes rhs missing 
perc aof 	allowed lhs 
rewrite min 	must valid looking 
size aof 	empty allowed 
rewrite 	otherwise must valid 
size aof 	looking refspec 
current size 	must greater zero 
aof rewrite 	must valid 
scheduled aof 	since possible reach 
child pid 	point within 
aof 	loop slash last 
rewrite buf 	possibility doesn 
blocks aof 	occur fetch head 
buf aof 	ignore entries 
aof selected 	always appear 
aof flush 	end list entry 
postponed 	already existed 
start aof 	match weak refs 
last fsync 	outside heads 
aof rewrite 	tags specify pattern 
time last 	full refs 
aof rewrite 	remotes origin master 
time 	least toplevel 
start aof 	remotes origin master 
lastbgrewrite status 	otherwise git 
aof delayed 	push url master 
fsync aof 	would result 
rewrite incremental 	ambiguity remotes origin 
fsync 	master heads 
aof last 	master remote site 
write status 	want weak 
aof last 	matches found multiple 
write errno 	matches one 
aof load 	strong matches 
truncated 	found ambiguous one 
aof pipe 	strong match 
write data 	zero weak matches 
child aof 	acceptable unique 
pipe read 	match source could 
data parent 	sha format 
aof 	reference name refs 
pipe write 	way remote 
ack parent 	end matching refs 
aof pipe 	traditionally pushed 
read ack 	everything including refs 
child aof 	outside refs 
pipe 	heads hierarchy make 
write ack 	much sense 
child aof 	days collect everything 
pipe read 	know would 
ack parent 	end push collect 
aof stop 	tags collect 
sending 	tags tag 
diff aof 	already conservative point 
child diff 	src tag 
dirty dirty 	lists tags missing 
bgsave rdb 	dst sent 
child pid 	tips lists tips 
saveparams 	pushing know 
saveparamslen rdb 	already element src 
filename rdb 	tag ancestor 
compression rdb 	sent tips needs 
checksum lastsave 	sent side 
lastbgsave rdb 	pushing commit error 
save 	tag reachable 
time last 	commits sending given 
rdb save 	local refs 
time start 	sanity check push 
rdb child 	refspecs errors 
type lastbgsave 	match push 
status 	refs would errors 
stop writes 	early even 
bgsave err 	talking remote side 
rdb pipe 	given refs 
write result 	local repository refs 
parent rdb 	remote repository 
pipe 	refspec used push 
read result 	determine remote 
child also 	refs update setting 
propagate logfile 	peer pushed 
syslog enabled 	force push forced 
syslog ident 	elements dst 
syslog 	function may elements 
facility slaveseldb 	dst pushing 
master repl 	branch done match 
offset repl 	refs pick 
ping slave 	remainder already sending 
period repl 	something remote 
backlog 	doesn pattern 
repl backlog 	mirror create one 
size repl 	link check 
backlog histlen 	missing refs remote 
repl backlog 	already sending 
idx repl 	something remote moved 
backlog 	different expect 
repl backlog 	reject push also 
time limit 	error user 
repl slaves 	told check remote 
since repl 	tracking branch 
min slaves 	find expect tracking 
write 	branch isn 
repl min 	stale force update 
slaves max 	update isn 
lag repl 	already rejected check 
good slaves 	usual must 
count repl 	fast forward rules 
diskless 	decide whether 
sync repl 	individual refspec 
diskless sync 	pushed push succeed 
delay masterauth 	following remote 
masterhost masterport 	reference exist remote 
repl timeout 	reference removed 
master 	pushing source specified 
cached master 	destination refs 
repl syncio 	tags old commit 
timeout repl 	descendant old 
state repl 	forced notation passing 
transfer size 	force argument 
repl 	force defeat rejection 
transfer read 	implemented rules 
repl transfer 	branch already run 
last fsync 	merge config 
repl transfer 	make sure confuse 
repl transfer 	callers non 
repl 	zero merge merge 
transfer tmpfile 	merge config 
repl transfer 	user didn 
lastio repl 	define real branch 
serve stale 	branch vivified 
data repl 	non existing refs 
slave 	create list 
repl since 	consisting copies remote 
repl disable 	matches refspec 
tcp nodelay 	refspec must pattern 
slave priority 	fill copies 
repl master 	peer describe local 
runid 	tracking refs 
repl master 	map omit references 
initial offset 	would map 
repl scriptcache 	existing local symbolic 
dict repl 	dereference item 
scriptcache fifo 	old must commit 
repl 	ish descendant 
scriptcache size 	old otherwise 
clients waiting 	require force compare 
acks ack 	branch upstream 
slaves maxclients 	save differences number 
maxmemory maxmemory 	commits num 
policy 	num name upstream 
maxmemory samples 	branch upstream 
bpop blocked 	defined returned via 
clients unblocked 	upstream name 
clients ready 	returns num num 
keys sort 	could filled 
desc 	upstream defined exist 
sort alpha 	otherwise cannot 
sort bypattern 	stat unless marked 
sort store 	build top 
hash max 	somebody cannot stat 
ziplist entries 	used build 
hash 	longer exists run 
max ziplist 	rev list 
max intset 	left right 
entries zset 	internally ignored count 
max ziplist 	commits side 
entries zset 	clear flags smudged 
max 	traversal anything 
ziplist hll 	report otherwise already 
sparse max 	know starts 
bytes list 	refs transports support 
max ziplist 	directly peeking 
size list 	head points guess 
compress 	refs heads 
depth unixtime 	master could right 
mstime pubsub 	look another 
channels pubsub 	points matches find 
patterns notify 	suitable refspec 
keyspace events 	symref list refs 
cluster 	currently exist 
enabled cluster 	remote consider stale 
node timeout 	order deal 
cluster configfile 	overlapping refspecs 
cluster cluster 	need matching refs 
migration barrier 	compare swap 
cluster 	option option option 
slave validity 	refname option 
factor cluster 	refname look remote 
require full 	fetch refspec 
coverage lua 	see remote tracking 
lua client 	branch refname 
lua 	fill current sha 
caller lua 	cannot negative 
scripts lua 	signal error tracking 
time limit 	refname remote 
lua time 	know tracking cannot 
start lua 	read find 
write 	option name entry 
dirty lua 	option cover 
random dirty 	branch another remote 
lua replicate 	also uses 
commands lua 	non remote 
multi emitted 	tracking refs advise 
lua 	user local 
repl lua 	branches silently skip 
timedout lua 	non remote 
kill lua 	refs make sure 
always replicate 	symrefs deleted 
commands latency 	first symrefs rename 
monitor 	rest create 
threshold latency 	symrefs cannot pass 
events failed 	function deletes 
file line 	branches one one 
bug report 	since relies 
start watchdog 	cached refs invalidated 
period 	deleting branch 
system memory 	sorting comparison list 
size name 	push info 
proc arity 	structs field remote 
sflags flags 	branch info 
getkeys proc 	git pull 
firstkey 	info git push 
lastkey keystep 	info make 
microseconds calls 	sure valid fetch 
name pointer 	mode use 
server shared 	fetch url push 
dict type 	found requested 
zset 	special cases entry 
dict type 	old url 
cluster nodes 	specified demand one 
dict type 	matches remote.h 
cluster nodes 	ent name origin 
black list 	foreign vcs 
dict 	url url url 
type dict 	alloc pushurl 
type sha 	pushurl pushurl alloc 
script dict 	push refspec 
type zero 	push push 
pos inf 	refspec push refspec 
neg 	alloc fetch 
inf nan 	refspec fetch fetch 
hash dict 	refspec fetch 
type repl 	refspec alloc fetch 
script cache 	tags skip 
dict 	update mirror prune 
type len 	receivepack uploadpack 
crc retcode 	http proxy http 
count title 	proxy authmethod 
privdata mask 	name name remote 
node length 	priv remote 
privdata 	url src dst 
mask privdata 	tag refspec 
mask privdata 	next old oid 
mask privdata 	oid old 
mask obj 	oid expect symref 
len obj 	remote status 
err 	peer name 
status length 	list name name 
dst src 	cmp refs 
longest output 	matched flags src 
list biggest 	buf src 
input buffer 	len list flags 
peerid 	extra shallow 
peerid len 	list oid old 
port client 	oid map 
client argc 	refspec refspec refspec 
newval argc 	refspec refspec 
argv name 	specs query refspecs 
port 	refspec name 
fds count 	src refspec refspec 
duration handler 	src dst 
installed attribute 	refspec refspec remote 
attribute fmt 	refs send 
fmt subject 	mirror force update 
subject 	remote refs 
subject subject 	refspec tail 
subject index 	missing remote refs 
direction entry 	name remote 
entry entry 	refspec name refname 
entry iter 	remote name 
entry 	pushremote name merge 
subject enc 	name merge 
key key 	merge merge alloc 
dbid obj 	push tracking 
type ptr 	name branch branch 
ptr len 	branch branch 
ptr 	branch err branch 
len ptr 	err branch 
len llongval 	num num upstream 
humanfriendly target 	name branch 
msg type 	head refs refs 
target msg 	count fetch 
target 	map expect refname 
msg target 	alloc option 
target target 	arg unset 
msg encoding 	push cas option 
ptr size 	arg unset 
timeout ptr 	push cas option 
size 	push cas 
timeout ptr 	option remote must 
size timeout 	first never 
slaves dictid 	fetch tags follow 
argv argc 	tags heuristic 
monitors dictid 	always follow tags 
argv 	always fetch 
argc bgsaveerr 	tags curl remotes 
type newsize 	used expect 
port sha 	old order important 
sha offset 	write fetch 
slave offset 	head numeric order 
pos 	merge xcalloc 
force cmd 	structures renaming 
dictid argv 	frees entire list 
argc childpid 	peers elements 
filename exitcode 	free first entries 
bysignal zsl 	input list 
zsl 	map remote reference 
score obj 	local reference 
ele score 	two entries map 
zsl score 	different remote 
obj zsl 	references local reference 
range zsl 	emit error 
range 	message die pointer 
sptr eptr 	head resulting 
sptr eptr 	list given list 
sptr zobj 	remote refs 
zobj encoding 	specification things fetch 
zobj maxelelen 	makes separate 
zobj 	list refs fetch 
member score 	local refs 
zsl score 	store tail 
name name 	pointer tail pointer 
flags cmd 	list results 
dbid argv 	beforehand tail pointer 
argc 	list results 
flags cmd 	afterward missing usually 
dbid argv 	adding branch 
argc target 	name merge branch 
flags attribute 	remote anymore 
level fmt 	given remote reads 
level 	refspec src 
msg level 	sets fields fully 
msg dict 	qualified refname 
msg unlink 	tracking branch branch 
unix socket 	branch upstream 
flags delay 	would give returns 
subject 	upstream defined 
subject subject 	err upstream defined 
subject objele 	specific error 
llele setobj 	message recorded 
objele llele 	function err touched 
count aux 	tracking branch 
subject 	corresponds would push 
subject enc 	given bare 
enc subject 	git push branch 
argv start 	err conventions 
end subject 	match branch upstream 
key key 	flags match 
key 	refs reporting tracking 
key subject 	info find 
vstr vlen 	refs list likely 
vll dst 	pointed given 
key notify 	head returns likely 
notify channel 	otherwise returns 
message 	list candidate refs 
type key 	match found 
dbid classes 	head returns returns 
flags filename 	newly allocated 
options seconds 	freed refs 
changes state 	longer exist remote 
option 	compare swap 
line force 	repack.c delta offset 
path key 	pack kept 
key key 	objects write bitmaps 
key key 	packdir packtmp 
key key 	git repack usage 
key 	buf dirlen 
key reply 	prefixlen dir signo 
key reply 	fname list 
key val 	dir fname len 
key val 	dir name 
key val 	name exts buf 
key 	plen argc 
key key 	argv prefix name 
callback key 	cmd item 
dbid hashslot 	names rollback 
keys count 	existing packs line 
hashslot hashslot 	ext ret 
cursor 	failed pack everything 
cursor cmd 	redundant unpack 
argv argc 	unreachable window memory 
numkeys result 	depth max 
cmd argv 	pack size reuse 
argc numkeys 	update server 
cmd 	info quiet local 
argv argc 	builtin repack 
numkeys cmd 	options fname fname 
argv argc 	old rollback 
numkeys cmd 	failure fname fname 
argv argc 	old fname 
numkeys 	fname old statbuffer 
buf len 	exists fname 
key keylen 	opts sha len 
channel message 	strcmp git 
argv argc 	config strcmp 
rdbfilename argv 	git config strcmp 
argc 	strcmp git 
setup pid 	config git config 
btype timeout 	opendir strlen 
unit attribute 	strbuf addstr readdir 
attribute attribute 	strncmp strbuf 
attribute estr 	setlen strbuf addstr 
file 	unlink closedir 
line estr 	strbuf release temporary 
file line 	files sigchain 
msg file 	pop opendir readdir 
line sig 	strip suffix 
info secret 	xmemdupz file exists 
section 	mkpath list 
period period 	append nodup free 
level descr 	closedir strbuf 
len bytes 	addf size strbuf 
passes copyright 	setlen strbuf 
salvatore sanfilippo 	addstr unlink 
antirez 	strbuf release git 
gmail dot 	config parse 
rights reserved 	options die mkpathdup 
redistribution use 	directory mkpathdup 
source binary 	getpid sigchain push 
forms without 	common argv 
modification 	push argv push 
permitted provided 	argv push 
following conditions 	argv push argv 
met redistributions 	push argv 
source code 	push argv push 
must retain 	argv pushf 
copyright 	argv pushf argv 
notice list 	pushf argv 
conditions following 	pushf argv pushf 
disclaimer redistributions 	argv pushf 
binary form 	argv push non 
must reproduce 	kept pack 
copyright 	filenames argv 
notice list 	pushf argv push 
conditions following 	argv push 
disclaimer documentation 	argv push argv 
materials provided 	push argv 
distribution neither 	push argv push 
name 	argv push 
redis names 	argv push argv 
contributors may 	push start 
used endorse 	command xfdopen strbuf 
promote products 	getline die 
derived software 	list append fclose 
without 	finish command 
specific prior 	size mkpathdup file 
written permission 	exists free 
software provided 	mkpathdup file exists 
copyright holders 	unlink rename 
contributors express 	free free list 
implied 	append free 
warranties including 	mkpathdup mkpathdup 
limited implied 	rename list append 
warranties merchantability 	free free 
fitness particular 	exit size mkpathdup 
purpose disclaimed 	mkpathdup stat 
shall 	chmod rename die 
copyright owner 	errno free 
contributors liable 	free size mkpathdup 
direct indirect 	path warning 
incidental special 	free list sort 
exemplary consequential 	strlen list 
damages 	redundant pack isatty 
including limited 	prune packed 
procurement substitute 	objects update server 
goods services 	info temporary 
loss use 	files list clear 
data profits 	list clear 
business 	list clear 
interruption however 	strbuf release temporary 
caused theory 	git directory 
liability whether 	pack tmp pack 
contract strict 	files point 
liability tort 	slash end objects 
including 	pack hold 
negligence otherwise 	length tmp pack 
arising way 	adds packs 
use software 	hex fname list 
even advised 	corresponding keep 
possibility damage 	file variables filled 
millisecond 	option parsing 
time type 	prepared packfiles first 
driven programming 	see packs 
library safe 	name move way 
hash tables 	happen repacked 
linked lists 	immediately packing fully 
total 	ones name 
memory usage 	way old 
aware version 	files end pack 
malloc free 	replacement replace.c 
networking easy 	git replace usage 
way compact 	pattern refname 
list 	oid flag data 
data structure 	data pattern 
compact integer 	format data argv 
structure version 	full hex 
macro misc 	error sha name 
functions useful 	sha prev 
many 	size force replace 
places latency 	repl force 
monitor api 	prev transaction err 
ascii graphs 	replace force 
api following 	repl export force 
includes allow 	raw tmpfile 
test 	old prev buf 
functions called 	argc argv 
redis main 	parents parent 
error codes 	start parent end 
server configuration 	sha argc 
time interrupt 	argv commit extra 
calls 	data mergetag 
sec tcp 	data tag sha 
port tcp 	tag oid 
listen backlog 	commit argc argv 
client timeout 	mergetag data 
infinite maximum 	argc argv force 
length 	old old 
syslog messages 	commit buf buffer 
hour wait 	size argc 
secs trying 	argv prefix force 
inet addrstrlen 	raw format 
need sure 	options wildmatch oid 
must 	hex sha 
enough port 	error sha info 
loopkups per 	sha info 
loop microseconds 	oid hex 
cpu max 	strcmp strcmp strcmp 
keys collection 	die replace 
instantaneous 	sha error sha 
metrics tracking 	hex snprintf 
number samples 	strlen read error 
per metric 	snprintf sha 
number commands 	hex die check 
executed bytes 	refname format 
read 	die read hashclr 
network bytes 	die sha 
written network 	info sha info 
protocol related 	die check 
defines max 	valid transaction begin 
query buffer 	transaction update 
buffer 	transaction commit die 
size output 	transaction free 
buffer max 	sha die 
size reads 	sha die replace 
bytes needed 	sha git 
str fdatasync 	pathdup sha die 
every 	sha info 
configuring server 	die sha hex 
eventloop setup 	check valid 
total number 	export launch editor 
file descriptors 	die free 
handle server 	hashcmp error sha 
maxclients 	hex replace 
reserved fds 	sha starts sha 
stay safe 	die lookup 
since reserved 	commit die strbuf 
fds defaults 	addf sha 
order make 	hex strbuf splice 
sure 	strbuf release 
provisioning fds 	hash sha file 
hash table 	lookup tag 
parameters minimal 	die parse 
hash table 	tag buffer die 
fill command 	sha die 
flags 	oidcmp die sha 
please check 	hex mergetag 
command table 	sha die lookup 
defined redis 	commit die 
file information 	commit buffer strbuf 
meaning every 	unuse commit 
flag 	buffer replace parents 
flag flag 	signature warning 
flag longer 	warning check mergetags 
used flag 	write sha 
flag flag 	file die strbuf 
flag flag 	release hashcmp 
flag 	error sha hex 
flag flag 	replace sha 
flag flag 	parse options usage 
flag types 	msg opt 
objects encoding 	usage msg 
kind objects 	opt usage msg 
like 	opt usage 
hashes internally 	msg opt replace 
represented multiple 	name usage 
ways encoding 	msg opt replace 
field one 	usage msg 
fields raw 	opt edit replace 
representation 	usage msg 
encoded integer 	opt create graft 
encoded hash 	usage msg 
table encoded 	opt list replace 
zipmap encoded 	refs die 
regular linked 	builtin git replace 
list 	copyright christian 
encoded ziplist 	couder chriscool tuxfamily 
encoded intset 	builtin tag 
encoded skiplist 	kristian gsberg krh 
embedded sds 	redhat carlos 
encoding encoded 	rica jasampler 
linked 	gmail git tag 
list ziplists 	mktag linus 
defines related 	torvalds data format 
dump file 	replace format 
format store 	read may reuse 
bits lengths 	buffer write 
keys 	contents named sha 
requires lot 	file filename 
space check 	raw raw contents 
significant bits 	printed according 
first interpreter 	type otherwise pretty 
length two 	print contents 
msb 	human editing read 
len bits 	previously exported 
len byes 	possibly edited back 
bits bits 	filename interpreting 
next bit 	type writing 
integer full 	result database sha 
bit 	written returned 
len follow 	via sha index 
means specially 	close need 
encoded follow 	close run command 
six bits 	index done 
number specify 	find existing parents 
kind 	hex sha 
follows see 	parent hex sha 
rdb enc 	prepare parents 
defines lengths 	replace existing parents 
stored single 	ones iterate 
keys may 	parents found replace 
values 	objectc original 
fit inside 	replacement replace alloc 
length stored 	replace index 
disk first 	table replace sha 
two bits 	replace ignore 
remaining two 	dups pos 
bits 	refname oid flag 
specify special 	data slash 
encoding accordingly 	hash repl obj 
following defines 	replace prepared 
bit integer 	sha pos depth 
bit integer 	cur sha 
bit 	pos replace pos 
integer compressed 	free free 
fastlz aof 	alloc grow memmove 
states aof 	strrchr xmalloc 
aof aof 	strlen sha hex 
waits rewrite 	free warning 
start 	hashcpy replace die 
appending client 	replace prepare 
flags client 	replace die sha 
slave server 	hex replace 
client master 	pos replacements kept 
server client 	sorted original 
slave 	sha sha 
monitor see 	refname copy sha 
monitor client 	read allow 
multi context 	recursive replacement within 
client waiting 	reason though 
blocking operation 	replacement sha replacement 
watched 	name replaced 
keys modified 	recursively necessary either 
exec fail 	sha pointer 
close writing 	permanently allocated function 
entire reply 	always respects 
client unblocked 	replace references regardless 
stored 	check replace 
server unblocked 	refs recursively replace 
clients non 	repo treec 
connected client 	path mode err 
used lua 	buf revision 
client 	src dst err 
issued asking 	mode data 
command close 	path strbuf 
client asap 	reset fast export 
client connected 	die errno 
via unix 	strbuf reset fast 
domain 	export rev 
socket exec 	die errno fast 
fail errors 	export fast 
queueing queue 	export modify fast 
replies even 	export licensed 
master force 	two clause bsd 
aof 	style license 
propagation current 	see license details 
cmd force 	treat missing 
replication current 	paths directories repo 
cmd instance 	treeh revision 
understand psync 	src dst path 
cluster 	mode blob 
client read 	mark path mode 
state client 	path revision 
pub sub 	author log 
mode propagate 	uuid url timestamp 
aof propagate 	rerere.c rerere 
slaves 	resolved rerere enabled 
client output 	rerere autoupdate 
send write 	item file hex 
handler yet 	sha buf 
installed send 	path sha write 
replies client 	buf strbuf 
client 	rerere output wrerror 
reply skip 	count err 
next cmd 	err str size 
send reply 	buf mem 
run eval 	input buf marker 
debug mode 	marker size 
eval 	want sha marker 
debugging without 	size ctx 
fork client 	hunk two 
block type 	buf path sha 
btype field 	output hunk 
client structure 	marker size input 
client 	len path 
blocked flag 	sha output mmfile 
blocked client 	result pos 
blocked flag 	len hunk marker 
blpop wait 	size size 
synchronous replication 	type conflict conflict 
client 	type merge 
request types 	conflict type path 
client classes 	ret result 
client limits 	index update item 
currently used 	item update 
max client 	path conflict update 
output 	sha path 
buffer limit 	ret flags merge 
implementation normal 	path filename 
req reply 	sha ret 
clients monito 	item pathspec conflict 
slaves clients 	merge name 
subscribed 	dir name dir 
pub sub 	name dir 
channels master 	cutoff cutoff noresolve 
number clients 	cutoff resolve 
expose output 	merge free git 
buffer configuration 	path rerere 
first 	hex git path 
three normal 	rerere hex 
slave pubsub 	stat rerere path 
slave replication 	xmalloc xsnprintf 
state used 	rerere hex sha 
server repl 	hex fopen 
state 	git path merge 
slaves remember 	strbuf getwholeline 
next active 	sha hex die 
replication must 	die rerere 
connect master 	hex list 
connecting master 	insert strbuf release 
handshake 	fclose strbuf 
states must 	addf rerere hex 
ordered wait 	write full 
ping reply 	die strbuf release 
send auth 	commit file 
master wait 	die fwrite ferr 
auth 	write strlen 
reply send 	ferr puts memset 
replconf listening 	memset rerere 
port wait 	putstr ferr write 
replconf reply 	strbuf getwholeline 
send replconf 	isspace git sha 
capa 	init getline 
wait replconf 	cmarker cmarker cmarker 
reply send 	cmarker strbuf 
psync wait 	cmp strbuf swap 
psync reply 	rerere putconflict 
end handshake 	rerere putmem 
states 	rerere putconflict rerere 
receiving rdb 	putmem rerere 
master connected 	putconflict git sha 
master state 	update git 
slaves pov 	sha update strbuf 
master used 	reset strbuf 
client 	reset strbuf addbuf 
replstate send 	strbuf addbuf 
bulk online 	rerere putstr strbuf 
state slave 	release strbuf 
receives updates 	release strbuf release 
output queue 	git sha 
wait 	merge marker size 
bgsave states 	memset fopen 
instead server 	error fopen fclose 
waiting start 	error handle 
next background 	path fclose 
saving order 	error strerror fclose 
send 	error strerror 
updates need 	unlink warn error 
produce rdb 	strbuf release 
file waiting 	memchr strbuf strbuf 
rdb file 	merge marker 
creation finish 	size strlen cache 
sending 	name pos 
rdb file 	namelen memcmp stage 
slave rdb 	read sha 
file transmitted 	file xstrdup merge 
sending updates 	free memset 
slave capabilities 	fopen strbuf init 
parse 	strbuf attach 
rdb eof 	handle path strbuf 
streaming format 	release fclose 
synchronous read 	stage stage stage 
timeout slave 	stage name 
side list 	isreg isreg 
related 	name read cache 
stuff sort 	error check 
operations log 	one conflict list 
levels modifier 	insert setup 
log without 	rerere read cache 
timestamp supervision 	error check 
options 	one conflict list 
anti warning 	insert list 
macro enough 	lookup free rerere 
elements skiplist 	handle file 
append defines 	rerere path read 
zip structure 	mmfile rerere 
related 	path read mmfile 
defaults list 	rerere path 
defaults hyper 	read mmfile rerere 
log log 	path merge 
defines sets 	utime rerere path 
operations codes 	warning rerere 
redis 	path strerror 
maxmemory strategies 	fopen error strerror 
scripting milliseconds 	fwrite error 
units shutdown 	strerror fclose error 
flags flags 	strerror free 
force save 	free free free 
shutdown 	hold locked 
even save 	index file cache 
points configured 	exit write 
save shutdown 	locked index die 
command call 	rollback file 
flags see 	rerere resolution merge 
call 	list insert 
function command 	handle file copy 
propagation flags 	file rerere 
see propagate 	path free rerere 
function rdb 	find conflict 
active child 	list handle file 
save 	rerere list 
type rdb 	insert mkdir 
written disk 	gitdir rerere path 
rdb written 	handle file 
slave socket 	rerere path rerere 
keyspace changes 	one path 
notification 	update paths write 
classes every 	git config 
associated character 	git config git 
configuration purposes 	config mkdir 
first bind 	gitdir git path 
addr following 	cache die 
macro 	git path cache 
run code 	git rerere 
inside server 	config rerere enabled 
cron specified 	hold file 
period specified 	update git path 
milliseconds actual 	merge read 
resolution 	setup rerere 
depends server 	plain rerere handle 
print stacktrace 	cache error 
defined way 	rerere rerere path 
data types 	unlink error 
redis type 	error strerror handle 
able 	cache rerere 
hold list 	path list insert 
actual redis 	free rerere 
max obj 	read cache error 
lru lru 	setup rerere 
clock resolution 	unmerge cache find 
lru 	conflict match 
time relative 	pathspec strlen rerere 
server lruclock 	forget one 
macro used 	path write xsnprintf 
obtain current 	dirname stat 
lru clock 	rerere path dirname 
current 	stat rerere 
resolution lower 	path unlink 
frequency refresh 	rerere path unlink 
lru clock 	rerere path 
production servers 	unlink rerere path 
precomputed otherwise 	rmdir rerere 
need 	path time setup 
resort function 	rerere git 
call macro 	config git config 
used initialize 	git config 
redis allocated 	opendir git path 
stack note 	die errno 
macro 	readdir dot dotdot 
taken near 	rerere last 
structure definition 	used rerere created 
make sure 	list append 
update structure 	closedir unlink item 
changed avoid 	dirname list 
bugs 	clear rollback file 
like bug 	setup rerere 
introduced exactly 	rerere resolution 
way improve 	unlink item unlink 
quality lru 	warn git 
approximation take 	path merge rollback 
keys 	file rerere 
good candidate 	enabled fall back 
eviction across 	detection git 
free memory 	cache automatically update 
needed calls 	cleanly resolved 
entries inside 	paths index git 
eviciton 	dir merge 
pool taken 	file collection records 
ordered idle 	conflict pathname 
time putting 	terminated nul used 
greater idle 	keep track 
times right 	paths rerere may 
order 	need work 
empty entries 	left previous invocation 
key pointer 	git rerere 
idle time 	current conflict 
key name 	resolution session hash 
redis database 	tab path 
representation 	nul rerere interacts 
multiple databases 	conflicted file 
identified integers 	contents abstraction reads 
database max 	conflicted contents 
configured database 	one place via 
database number 	getline method 
field 	optionally write normalizing 
structure keyspace 	conflicted hunks 
timeout keys 	output subclasses rerere 
timeout keys 	embed structure 
clients waiting 	beginning rerere stuff 
data blpop 	write conflict 
blocked 	marker output defined 
keys received 	make sure 
push watched 	write everything round 
keys multi 	leaving least 
exec cas 	next round 
eviction pool 	giving next round 
keys 	chance terminating 
database average 	yuck subclass rerere 
ttl stats 	reads disk 
client multi 	file getline method 
exec state 	implementation require 
multi commands 	exact number conflict 
total 	marker letters 
number multi 	less followed whitespace 
commands minreplicas 	including beginning 
synchronous replication 	version end version 
minreplicas timeout 	always labeled 
unixtime structure 	like hence want 
holds 	note version 
blocking operation 	common ancestor diff 
state client 	style output 
fields used 	always labelled 
depend client 	common often seen 
btype fields 	alone also 
blocking 	valid want read 
operation timeout 	contents file 
unix current 	conflicts normalize conflicts 
time timeout 	discarding common 
operation timed 	ancestor version diff 
blocked list 	style reordering 
keys 	side side whichever 
waiting terminate 	sorts alphabetically 
blocking operation 	earlier comes one 
blpop otherwise 	computing conflict 
key receive 	sha hash one 
element brpoplpush 	side conflict 
blocked 	nul side conflict 
wait number 	nul concatenated 
replicas waiting 	together number conflict 
ack replication 	hunks found 
offset reach 	needswork logic 
following structure 	theory operation behind 
represents 	conflict normalization 
node server 	may deserve documented 
ready keys 	somewhere perhaps 
list accumulate 	documentation technical rerere 
keys clients 	txt discard 
blocked blocking 	force error exit 
operation 	scan path 
pop received 	conflicts handle path 
data context 	thing number 
last executed 	conflict hunks found 
command execution 	subclass rerere 
every command 	reads core buffer 
script 	strbuf getline 
run list 	method implementation reproduce 
check result 	conflicted merge 
serve data 	core needswork handle 
clients blocked 	conflicts merges 
unblocking note 	merge renormalize 
server 	grab conflict optionally 
ready keys 	write original 
duplicates dictionary 	contents conflict markers 
also called 	look cache 
ready keys 	entry see conflicting 
every structure 	conflicting willing 
representing 	handle conflicting unable 
redis database 	handle determination 
make sure 	type cache index 
remember given 	looked next 
key already 	skipping stages already 
added server 	looked invocation 
ready 	function handle regular 
keys list 	files stages 
multiplexing need 	skip entries name 
take per 	scan index 
client state 	find paths conflicts 
clients taken 	rerere handle 
linked 	ones stages 
list client 	needswork record replay 
incremental unique 	previous resolve 
client socket 	deletion modify conflict 
pointer currently 	inherently risky 
selec ted 	without knowing modification 
currently 	discarded safe 
selec ted 	side deletion modification 
client setname 	identical previous 
buffer use 	round might want 
accumulate client 	handled though 
queries recent 	merge list meant 
peak 	hold outstanding 
querybuf size 	conflicted paths rerere 
num arguments 	could handle 
current command 	abuse list adding 
arguments current 	types entries 
command last 	allow caller 
command 	show rerere remaining 
executed request 	conflicted paths 
protocol type 	rerere handle added 
proto req 	conflicted paths 
number multi 	resolved marked storing 
bulk arguments 	rerere resolved 
left 	field conflict expected 
read length 	stored write 
bulk argument 	merge file calling 
multi bulk 	function needswork 
request list 	may want fix 
reply objects 	caller rerere 
send 	remaining without abusing 
client tot 	merge find 
bytes objects 	conflict identified change 
reply list 	preimage previous 
amount bytes 	contents conflict markers 
already sent 	postimage corresponding 
current 	contents conflicts 
buffer sent 	resolved may apply 
client creation 	cleanly contents 
time time 	stored path conflict 
last interaction 	time around 
used timeout 	returns successful replay 
client 	recorded resolution 
flags client 	non zero failure 
macros requirepass 	normalize conflicts 
non replication 	path write thisimage 
state slave 	temporary file 
install slave 	three way merge 
write 	note honors 
handler ack 	user customizable low 
replication file 	level merge 
descriptor replication 	driver settings successful 
file offset 	replay recorded 
replication file 	resolution mark postimage 
size 	used help 
replication preamble 	update path 
replication offset 	resolution path indicated 
master replication 	item may 
ack offset 	still conflict recorded 
slave replication 	resolution replay 
ack 	optionally update may 
time slave 	resolved user 
fullresync reply 	may preimage conflict 
offset slaves 	result needs 
copying slave 	recorded resolution postimage 
output buffer 	file recorded 
use 	resolution could attempt 
master run 	apply failed 
master configured 	replay user resolved 
slaveconf listening 	merge records 
port slave 	paths conflicts immediately 
capabilities slave 	merge failed 
capa 	conflicted paths might 
bitwise multi 	hand resolved 
exec state 	working since 
type blocking 	initial run would 
client blocked 	preimages ask 
blocking state 	handle file scan 
last 	assign conflict 
write replication 	need write anything 
offset keys 	yet directory 
watched multi 	exist create mkdir 
exec cas 	gitdir fail 
channels client 	eexist already one 
interested 	needswork make 
subscribe patterns 	sure preimage without 
client interested 	removing directory 
subscribe cached 	first encounter conflict 
peer response 	ask handle 
buffer zse 	file write normalized 
use 	contents preimage 
specialized version 	file main 
skiplists redis 	entry point called 
structure defines 	internally codepaths 
redis operation 	perform mergy operations 
instance command 	possibly leaving 
argument 	conflicted index entries 
vector database 	working files 
propagation target 	recreate original conflict 
propagate command 	stages index 
pointer currently 	compute conflict nuke 
used 	recorded resolution 
additionally propagate 	conflict update preimage 
commands aof 	user resolve 
replication propagation 	conflict working run 
executed command 	record postimage 
defines redis 	remember record resolution 
operations 	conflict user 
api structure 	done paths may 
easy way 	resolved incorrectly 
redis init 	recover original 
redis append 	conflicted state find 
redis free 	conflicted paths 
server 	garbage collection support 
state aix 	note reentrant 
defines use 	used one time 
define order 	matter right 
allow redis 	recorded resolution given 
build aix 	conflict needswork 
need 	rmdir fails wouldn 
undef general 	already preimage 
main process 	recorded plain rerere 
pid absolute 	collect stale 
config file 	conflict one one 
path absolute 	conflict resolution 
executable 	rerere recorded preimages 
file path 	abandon user 
executable argv 	resolve record resolutions 
vector copy 	drop git 
server cron 	dir merge 
calls frequency 	needswork shouldn calling 
hertz 	reset hard 
command table 	prepare later call 
command table 	list clear 
command renaming 	rerere usage dummy 
clock lru 	ptr nbuf 
eviction shutdown 	file label file 
needed 	label xpp 
asap incremental 	xecfg ecb minus 
rehash server 	plus ret 
cron pass 	argc argv prefix 
auth command 	merge flags 
pid file 	options pathspec path 
path 	write full 
depending number 	read mmfile read 
times cron 	mmfile fflush 
function run 	memset memset xdi 
always different 	diff free 
every exec 	free parse 
instance 	options git config 
sentinel networking 	rerere strcmp 
tcp listening 	warning parse pathspec 
port tcp 	rerere forget 
listen backlog 	strcmp rerere clear 
addresses bind 	strcmp rerere 
number 	strcmp setup rerere 
addresses server 	strcmp rerere 
bindaddr unix 	remaining strcmp setup 
socket path 	rerere diff 
unix socket 	two rerere path 
permission tcp 	die rerere 
socket 	path usage options 
file descriptors 	list clear 
used slots 	rerere enabled fall 
ipfd unix 	back detection 
socket file 	git cache automatically 
descriptor cluster 	update cleanly 
bus 	resolved paths 
listening socket 	index git dir 
used slots 	merge file 
cfd list 	collection records conflict 
active clients 	pathname terminated 
clients close 	nul used keep 
asynchronously 	track paths 
write install 	rerere may need 
handler list 	work left 
slaves monito 	previous invocation git 
current client 	rerere current 
used crash 	conflict resolution session 
report 	hash tab 
clients currently 	path nul rerere 
paused time 	interacts conflicted 
undo clients 	file contents abstraction 
paused error 	reads conflicted 
buffer anet 	contents one 
migrate 	place via getline 
cached sockets 	method optionally 
next client 	write normalizing conflicted 
unique incremental 	hunks output 
accept external 	subclasses rerere embed 
connections rdb 	structure beginning 
aof 	rerere stuff write 
loading information 	conflict marker 
loading data 	output defined make 
disk fast 	sure write 
pointers often 	everything round leaving 
looked command 	least next 
fields 	round giving next 
used stats 	round chance 
server start 	terminating yuck subclass 
time number 	rerere reads 
processed commands 	disk file getline 
number connections 	method implementation 
received 	require exact 
number expired 	number conflict marker 
keys number 	letters less 
evicted keys 	followed whitespace including 
maxmemory number 	beginning version 
successful lookups 	end version always 
keys 	labeled like 
number failed 	hence want note 
lookups keys 	version common 
max used 	ancestor diff style 
memory record 	output always 
time needed 	labelled common often 
perform 	seen alone 
latest fork 	also valid want 
fork rate 	read contents 
sec clients 	file conflicts normalize 
rejected maxclients 	conflicts discarding 
number full 	common ancestor version 
resyncs 	diff style 
slaves number 	reordering side 
accepted psync 	side whichever sorts 
requests number 	alphabetically earlier 
unaccepted psync 	comes one computing 
requests slowlog 	conflict sha 
list 	hash one side 
commands slowlog 	conflict nul 
current entry 	side conflict nul 
slowlog time 	concatenated together 
limit logged 	number conflict hunks 
slowlog max 	found needswork 
number 	logic theory operation 
items logged 	behind conflict 
rss sampled 	normalization may deserve 
server cron 	documented somewhere 
bytes read 	perhaps documentation technical 
network bytes 	rerere txt 
written 	discard force error 
network following 	exit scan 
two used 	path conflicts 
track instantaneous 	handle path thing 
metrics like 	number conflict 
number operations 	hunks found subclass 
per 	rerere reads 
second network 	core buffer strbuf 
traffic timestamp 	getline method 
last sample 	implementation reproduce conflicted 
count last 	merge core 
sample configuration 	needswork handle conflicts 
loglevel 	merges merge 
redis conf 	renormalize grab conflict 
client timeout 	optionally write 
seconds keepalive 	original contents conflict 
non zero 	markers look 
disabled testing 	cache entry see 
purposes 	conflicting conflicting 
limit client 	willing handle 
query buffer 	conflicting unable handle 
length total 	determination type 
number configured 	cache index looked 
supervised otherwise 	next skipping 
see 	stages already looked 
supervised running 	invocation function 
daemon aof 	handle regular files 
persistence aof 	stages skip 
wait rewrite 	entries name scan 
kind fsync 	index find 
policy 	paths conflicts rerere 
name aof 	handle ones 
file fsync 	stages needswork record 
rewrite prog 	replay previous 
rewrite aof 	resolve deletion modify 
growth aof 	conflict inherently 
file 	risky without knowing 
least bytes 	modification discarded 
aof size 	safe side 
latest startup 	deletion modification identical 
rewrite aof 	previous round 
current size 	might want handled 
rewrite 	though merge 
bgsave terminates 	list meant hold 
pid rewriting 	outstanding conflicted 
process hold 	paths rerere could 
changes aof 	handle abuse 
rewrite aof 	list adding types 
buffer 	entries allow 
written entering 	caller show rerere 
loop file 	remaining conflicted 
descriptor currently 	paths rerere handle 
selected aof 	added conflicted 
file currently 	paths resolved marked 
selected 	storing rerere 
aof unix 	resolved field conflict 
time postponed 	expected stored 
aof flush 	write merge 
unix time 	file calling function 
last fsync 	needswork may 
time 	want fix caller 
used last 	rerere remaining 
aof rewrite 	without abusing merge 
run current 	find conflict 
aof rewrite 	identified change preimage 
start time 	previous contents 
err 	conflict markers postimage 
delayed aof 	corresponding contents 
fsync counter 	conflicts resolved may 
fsync incrementally 	apply cleanly 
rewriting err 	contents stored path 
valid aof 	conflict time 
last 	around returns successful 
write status 	replay recorded 
err stop 	resolution non zero 
unexpected aof 	failure normalize 
eof aof 	conflicts path 
pipes used 	write thisimage temporary 
communicate 	file three 
parent child 	way merge note 
rewrite stop 	honors user 
sending accumulated 	customizable low level 
diffs child 	merge driver 
process aof 	settings successful replay 
diff 	recorded resolution 
accumulator child 	mark postimage used 
side rdb 	help update 
persistence changes 	path resolution path 
last save 	indicated item 
used restore 	may still conflict 
dirty 	recorded resolution 
failed bgsave 	replay optionally update 
pid rdb 	may resolved 
saving child 	user may 
save points 	preimage conflict result 
rdb number 	needs recorded 
saving 	resolution postimage file 
points name 	recorded resolution 
rdb file 	could attempt apply 
use compression 	failed replay 
rdb use 	user resolved merge 
rdb checksum 	records paths 
unix 	conflicts immediately merge 
time last 	failed conflicted 
successful save 	paths might hand 
unix time 	resolved working 
last attempted 	since initial run 
bgsave time 	would preimages 
used 	ask handle file 
last rdb 	scan assign 
save run 	conflict need write 
current rdb 	anything yet 
save start 	directory exist 
time type 	create mkdir gitdir 
save 	fail eexist 
active child 	already one needswork 
err allow 	make sure 
writes bgsave 	preimage without removing 
rdb pipes 	directory first 
used state 	encounter conflict ask 
slave 	handle file 
diskless sync 	write normalized contents 
propagation commands 	preimage file 
aof replication 	main entry point 
additional command 	called internally 
propagate logging 	codepaths perform mergy 
path 	operations possibly 
log file 	leaving conflicted index 
syslog enabled 	entries working 
syslog ident 	files recreate original 
syslog facility 	conflict stages 
replication master 	index compute 
last 	conflict nuke recorded 
selec ted 	resolution conflict 
replication output 	update preimage user 
replication offset 	resolve conflict 
master pings 	working run record 
slave every 	postimage remember 
seconds 	record resolution conflict 
replication backlog 	user done 
syncs backlog 	paths may resolved 
circular buffer 	incorrectly recover 
size backlog 	original conflicted state 
actual data 	find conflicted 
length 	paths garbage collection 
backlog circular 	support note 
buffer current 	reentrant used one 
offset replication 	time matter 
offset first 	right recorded resolution 
backlog buffer 	given conflict 
time 	needswork rmdir 
without slaves 	fails wouldn already 
backlog gets 	preimage recorded 
released slaves 	plain rerere collect 
since time 	stale conflict 
valid server 	one one conflict 
slaves 	resolution rerere 
len min 	recorded preimages abandon 
number slaves 	user resolve 
write max 	record resolutions drop 
lag count 	git dir 
slaves write 	merge needswork shouldn 
number 	calling reset 
slaves lag 	hard prepare later 
max lag 	call list 
send rdb 	clear rerere.c rerere 
slaves sockets 	resolved rerere 
directly delay 	enabled rerere autoupdate 
start 	item file 
diskless repl 	hex sha 
bgsave replication 	buf path sha 
slave auth 	write buf 
password master 	strbuf rerere output 
hostname master 	wrerror count 
port 	err err str 
master timeout 	size buf 
seconds master 	mem input buf 
idle client 	marker marker 
master slave 	size want sha 
cached master 	marker size 
reused 	ctx hunk two 
psync timeout 	buf path 
synchronous calls 	sha output hunk 
replication status 	marker size 
instance slave 	input len path 
size rdb 	sha output 
read 	mmfile result 
master sync 	pos len hunk 
amount rdb 	marker size 
read master 	size type conflict 
sync offset 	conflict type 
fsync last 	merge conflict type 
time 	path ret 
slave master 	result index update 
sync socket 	item item 
slave master 	update path conflict 
sync temp 	update sha 
file descriptor 	path ret flags 
slave 	merge path 
master sync 	filename sha ret 
temp file 	item pathspec 
name unix 	conflict merge name 
time latest 	dir name 
read timeout 	dir name dir 
serve 	cutoff cutoff 
stale data 	noresolve cutoff 
link slave 	resolve merge free 
read unix 	git path 
time link 	rerere hex git 
master went 	path rerere 
disable 	hex stat rerere 
tcp nodelay 	path xmalloc 
sync reported 	xsnprintf rerere hex 
info used 	sha hex 
sentinel master 	fopen git path 
run psync 	merge strbuf 
master 	getwholeline sha hex 
psync offset 	die die 
replication script 	rerere hex list 
cache sha 	insert strbuf 
slaves aware 	release fclose strbuf 
first first 	addf rerere 
lru 	hex write full 
eviction max 	die strbuf 
number elements 	release commit 
synchronous replication 	file die fwrite 
clients waiting 	ferr write 
wait command 	strlen ferr puts 
send 	memset memset 
replconf getack 	rerere putstr ferr 
limits max 	write strbuf 
number simultaneous 	getwholeline isspace git 
clients max 	sha init 
number memory 	getline cmarker cmarker 
bytes 	cmarker cmarker 
use policy 	strbuf cmp strbuf 
key eviction 	swap rerere 
pricision random 	putconflict rerere putmem 
sampling blocked 	rerere putconflict 
clients number 	rerere putmem rerere 
clients 	putconflict git 
blocked lists 	sha update git 
list clients 	sha update 
unblock next 	strbuf reset 
loop list 	strbuf reset strbuf 
ready list 	addbuf strbuf 
structures 	addbuf rerere putstr 
blpop sort 	strbuf release 
parameters qsort 	strbuf release strbuf 
available bsd 	release git 
take state 	sha merge marker 
order pass 	size memset 
sort 	fopen error fopen 
compare zip 	fclose error 
structure config 	handle path fclose 
see redis 	error strerror 
conf information 	fclose error strerror 
list parameters 	unlink warn 
time 	error strbuf release 
cache unix 	memchr strbuf 
time sampled 	strbuf merge 
every cron 	marker size strlen 
cycle like 	cache name 
unixtime milliseconds 	pos namelen memcmp 
resolution 	stage read 
pubsub map 	sha file xstrdup 
channels list 	merge free 
subscribed clients 	memset fopen strbuf 
list pubsub 	init strbuf 
patterns events 	attach handle path 
propagate 	strbuf release 
via pub 	fclose stage stage 
sub xor 	stage stage 
notify flags 	name isreg isreg 
cluster cluster 	name read 
enabled cluster 	cache error check 
node 	one conflict 
timeout cluster 	list insert setup 
generated config 	rerere read 
file name 	cache error 
state cluster 	check one conflict 
cluster replicas 	list insert 
migration 	list lookup free 
barrier slave 	rerere handle 
max data 	file rerere path 
age failover 	read mmfile 
put cluster 	rerere path read 
least uncovered 	mmfile rerere 
slot 	path read mmfile 
scripting lua 	rerere path 
interpreter use 	merge utime rerere 
one clients 	path warning 
fake client 	rerere path strerror 
query 	fopen error 
redis lua 	strerror fwrite error 
client running 	strerror fclose 
eval right 	error strerror free 
dictionary sha 	free free 
lua scripts 	free hold 
script 	locked index file 
timeout milliseconds 	cache exit 
start time 	write locked index 
script milliseconds 	die rollback 
time write 	file rerere resolution 
command called 	merge list 
execution 	insert handle file 
current script 	copy file 
random command 	rerere path free 
called execution 	rerere find 
current script 	conflict list handle 
single commands 	file rerere 
repl 	list insert mkdir 
already proagated 	gitdir rerere 
multi script 	path handle file 
replication flags 	rerere path 
redis repl 	rerere one path 
reached time 	update paths 
limit 	write git 
script execution 	config git config 
kill script 	git config 
replication type 	mkdir gitdir git 
latency monitor 	path cache 
bug reporting 	die git path 
bug 	cache git 
report header 	rerere config rerere 
already logged 	enabled hold 
software watchdog 	file update git 
period system 	path merge 
hardware info 	read setup rerere 
total 	plain rerere 
memory system 	handle cache error 
reported flags 	rerere rerere 
representation one 	path unlink error 
per flag 	error strerror 
actual flags 	handle cache 
obtained 	rerere path list 
sflags field 	insert free 
use function 	rerere read cache 
determine keys 	error setup 
arguments command 	rerere unmerge cache 
line used 	find conflict 
redis 	match pathspec strlen 
cluster redirect 	rerere forget 
keys loaded 	one path write 
background calling 	xsnprintf dirname 
command first 	stat rerere path 
argument key 	dirname stat 
keys 	rerere path unlink 
last argument 	rerere path 
key step 	unlink rerere path 
first last 	unlink rerere 
key structure 	path rmdir rerere 
hold list 	path time 
iteration 	setup rerere 
abstraction iteration 	git config git 
direction structure 	config git 
entry iterating 	config opendir git 
list entry 	path die 
quicklist structure 	errno readdir dot 
hold 	dotdot rerere 
iteration abstraction 	last used rerere 
intset iterator 	created list 
structure hold 	append closedir unlink 
hash iteration 	item dirname 
abstraction note 	list clear rollback 
iteration 	file setup 
hashes involves 	rerere rerere resolution 
fields values 	unlink item 
possible required 	unlink warn git 
store pointers 	path merge 
iterator avoid 	rollback file rerere 
unnecessary 	enabled fall 
memory allocation 	back detection 
fields values 	git cache automatically 
declarations functions 	update cleanly 
prototypes utils 	resolved paths index 
networking networking 	git dir 
client 	merge file collection 
related operations 	records conflict 
list data 	pathname terminated nul 
type multi 	used keep 
exec watch 	track paths rerere 
redis implementation 	may need 
synchronous 	work left previous 
timeout replication 	invocation git 
persistence functions 	rerere current conflict 
rdb persistence 	resolution session 
aof persistence 	hash tab path 
sorted sets 	nul rerere 
data 	interacts conflicted file 
type hold 	contents abstraction 
inclusive exclusive 	reads conflicted 
range spec 	contents one place 
score comparison 	via getline 
min max 	method optionally write 
exclusive 	normalizing conflicted 
hold inclusive 	hunks output subclasses 
exclusive range 	rerere embed 
spec lexicographic 	structure beginning rerere 
comparison may 	stuff write 
shared minstring 	conflict marker output 
maxstring 	defined make 
min max 	sure write everything 
exclusive core 	round leaving 
functions proper 	least next round 
shutdown config 	giving next 
rewrite restart 	round chance terminating 
data 	yuck subclass 
type hash 	rerere reads disk 
data type 	file getline 
pub sub 	method implementation 
keyspace events 	require exact number 
notification configuration 	conflict marker 
forward 	letters less followed 
declaration export 	whitespace including 
api keyspace 	beginning version end 
access api 	version always 
api key 	labeled like hence 
arguments commands 	want note 
cluster 	version common ancestor 
sentinel redis 	diff style 
check rdb 	output always labelled 
scripting blocked 	common often 
clients git 	seen alone also 
sha commands 	valid want 
prototypes 	read contents file 
debugging stuff 	conflicts normalize 
setproctitle.c environ 	conflicts discarding 
arg end 	common ancestor version 
nul reset 	diff style 
error environ 	reordering side side 
tmp 	whichever sorts 
oldenv environ 	alphabetically earlier comes 
error argc 	one computing 
argv tmp 	conflict sha hash 
argc argv 	one side 
envp end 	conflict nul side 
nul 	conflict nul 
tmp error 	concatenated together number 
fmt buf 	conflict hunks 
nul len 	found needswork logic 
error spt 	theory operation 
min clearenv 	behind conflict normalization 
malloc 	may deserve 
spt clearenv 	documented somewhere perhaps 
strchr setenv 	documentation technical 
strdup strlen 	rerere txt 
strlen strlen 	discard force error 
strdup strdup 	exit scan 
strdup 	path conflicts handle 
strdup getprogname 	path thing 
setprogname spt 	number conflict hunks 
copyenv spt 	found subclass 
copyargs start 	rerere reads core 
vsnprintf end 	buffer strbuf 
snprintf 	getline method implementation 
memset memset 	reproduce conflicted 
spt min 	merge core needswork 
spt min 	handle conflicts 
spt min 	merges merge renormalize 
memcpy setproctitle 	grab conflict 
linux 	optionally write original 
darwin setproctitle 	contents conflict 
copyright william 	markers look cache 
ahern copyright 	entry see 
salvatore sanfilippo 	conflicting conflicting 
copyright stam 	willing handle conflicting 
permission 	unable handle 
hereby granted 	determination type cache 
free charge 	index looked 
person obtaining 	next skipping stages 
copy software 	already looked 
associated documentation 	invocation function handle 
files 	regular files 
software deal 	stages skip entries 
software without 	name scan 
restriction including 	index find paths 
without limitation 	conflicts rerere 
rights use 	handle ones stages 
copy 	needswork record 
modify merge 	replay previous resolve 
publish distribute 	deletion modify 
sublicense sell 	conflict inherently risky 
copies software 	without knowing 
permit persons 	modification discarded 
software 	safe side deletion 
furnished subject 	modification identical 
following conditions 	previous round might 
copyright notice 	want handled 
permission notice 	though merge list 
shall included 	meant hold 
copies 	outstanding conflicted paths 
substantial portions 	rerere could 
software software 	handle abuse list 
provided without 	adding types 
warranty kind 	entries allow caller 
express implied 	show rerere 
including 	remaining conflicted paths 
limited warranties 	rerere handle 
merchantability fitness 	added conflicted paths 
particular purpose 	resolved marked 
noninfringement shall 	storing rerere 
authors copyright 	resolved field conflict 
holders 	expected stored 
liable claim 	write merge file 
damages liability 	calling function 
whether action 	needswork may want 
contract tort 	fix caller 
otherwise arising 	rerere remaining without 
connection 	abusing merge 
software use 	find conflict identified 
dealings software 	change preimage 
size list 	previous contents conflict 
start end 	markers postimage 
malloc setenv 	corresponding contents conflicts 
clearenv 	resolved may 
setproctitle getprogname 	apply cleanly contents 
vsnprintf snprintf 	stored path 
strlen strchr 	conflict time around 
strdup memset 	returns successful 
memcpy errno 	replay recorded 
program 	resolution non zero 
invocation name 	failure normalize 
program invocation 	conflicts path write 
name original 	thisimage temporary 
title space 	file three way 
available pointer 	merge note 
original 	honors user customizable 
nul character 	low level 
within spt 	merge driver settings 
min discussion 	successful replay 
portability various 	recorded resolution mark 
methods see 	postimage used 
http 	help update path 
lists freebsd 	resolution path 
pipermail freebsd 	indicated item may 
stable june 	still conflict 
html spt 	recorded resolution replay 
clearenv spt 	optionally update 
copyenv 	may resolved 
spt copyargs 	user may preimage 
spt init 	conflict result 
use buffer 	needs recorded resolution 
argv passed 	postimage file 
setproctitle linux 	recorded resolution could 
apple 	attempt apply 
setproctitle SFMT-alti.h 	failed replay user 
mask perm 	resolved merge 
perm mask 	records paths conflicts 
perm perm 	immediately merge 
ctx ctx 	failed conflicted paths 
size 	might hand 
size perm 	resolved working since 
vec perm 	initial run 
vec vec 	would preimages ask 
perm vec 	handle file 
vec xor 	scan assign conflict 
vec 	need write 
vec xor 	anything yet 
vec xor 	directory exist create 
vec xor 	mkdir gitdir 
vec recursion 	fail eexist already 
vec recursion 	one needswork 
vec 	make sure preimage 
recursion vec 	without removing 
recursion vec 	directory first encounter 
recursion vec 	conflict ask 
recursion vec 	handle file write 
perm file 	normalized contents 
derives 	preimage file main 
sfmt http 	entry point 
www math 	called internally codepaths 
sci hiroshima 	perform mergy 
mat sfmt 	operations possibly leaving 
index html 	conflicted index 
released 	entries working 
terms following 	files recreate original 
license copyright 	conflict stages 
mutsuo saito 	index compute conflict 
makoto matsumoto 	nuke recorded 
hiroshima university 	resolution conflict update 
rights 	preimage user 
reserved redistribution 	resolve conflict working 
use source 	run record 
binary forms 	postimage remember record 
without modification 	resolution conflict 
permitted provided 	user done paths 
following 	may resolved 
conditions met 	incorrectly recover original 
redistributions source 	conflicted state 
code must 	find conflicted paths 
retain copyright 	garbage collection 
notice list 	support note reentrant 
conditions 	used one 
following disclaimer 	time matter 
redistributions binary 	right recorded resolution 
form must 	given conflict 
reproduce copyright 	needswork rmdir fails 
notice list 	wouldn already 
conditions 	preimage recorded plain 
following disclaimer 	rerere collect 
documentation materials 	stale conflict one 
provided distribution 	one conflict 
neither name 	resolution rerere recorded 
hiroshima university 	preimages abandon 
names 	user resolve record 
contributors may 	resolutions drop 
used endorse 	git dir merge 
promote products 	needswork shouldn 
derived software 	calling reset hard 
without specific 	prepare later 
prior 	call list clear 
written permission 	rerere usage 
software provided 	dummy ptr 
copyright holders 	nbuf file label 
contributors express 	file label 
implied warranties 	xpp xecfg ecb 
including 	minus plus 
limited implied 	ret argc argv 
warranties merchantability 	prefix merge 
fitness particular 	flags options pathspec 
purpose disclaimed 	path write 
shall copyright 	full read mmfile 
owner 	read mmfile 
contributors liable 	fflush memset memset 
direct indirect 	xdi diff 
incidental special 	free free parse 
exemplary consequential 	options git 
damages including 	config rerere strcmp 
limited 	warning parse 
procurement substitute 	pathspec rerere forget 
goods services 	strcmp rerere 
loss use 	clear strcmp 
data profits 	rerere strcmp setup 
business interruption 	rerere strcmp 
however 	rerere remaining strcmp 
caused theory 	setup rerere 
liability whether 	diff two rerere 
contract strict 	path die 
liability tort 	rerere path usage 
including negligence 	options list 
otherwise 	clear rerere enabled 
arising way 	fall back 
use software 	detection git cache 
even advised 	automatically update 
possibility damage 	cleanly resolved paths 
file sfmt 	index git 
alti 	dir merge file 
brief simd 	collection records 
oriented fast 	conflict pathname terminated 
mersenne twister 	nul used 
sfmt pseudorandom 	keep track 
number generator 	paths rerere may 
author 	need work 
mutsuo saito 	left previous invocation 
hiroshima university 	git rerere 
author makoto 	current conflict resolution 
matsumoto hiroshima 	session hash 
university copyright 	tab path nul 
mutsuo 	rerere interacts 
saito makoto 	conflicted file contents 
matsumoto hiroshima 	abstraction reads 
university rights 	conflicted contents one 
reserved bsd 	place via 
license applied 	getline method optionally 
software 	write normalizing 
see license 	conflicted hunks output 
txt function 	subclasses rerere 
represents recursion 	embed structure 
formula alti 	beginning rerere stuff 
vec big 	write conflict 
endian 	marker output defined 
param bit 	make sure 
part interal 	write everything round 
state param 	leaving least 
bit part 	next round giving 
interal state 	next round 
param 	chance terminating yuck 
bit part 	subclass rerere 
interal state 	reads disk file 
param bit 	getline method 
part interal 	implementation require exact 
state output 	number conflict 
function 	marker letters less 
fills state 	followed whitespace 
pseudorandom integers 	including beginning version 
function fills 	end version 
user specified 	always labeled 
pseudorandom integers 	like hence want 
param 	note version 
bit filled 	common ancestor diff 
pseudorandom numbers 	style output 
param size 	always labelled common 
number bit 	often seen 
pesudorandom numbers 	alone also valid 
generated 	want read 
main loop 	contents file conflicts 
function swaps 	normalize conflicts 
high low 	discarding common ancestor 
bit bit 	version diff 
integers user 	style reordering side 
specified 	side whichever 
param bit 	sorts alphabetically earlier 
swaped param 	comes one 
size size 	computing conflict sha 
bit SFMT-params.h 	hash one 
file derives 	side conflict 
sfmt 	nul side conflict 
http www 	nul concatenated 
math sci 	together number conflict 
hiroshima mat 	hunks found 
sfmt index 	needswork logic theory 
html released 	operation behind 
terms 	conflict normalization may 
following license 	deserve documented 
copyright mutsuo 	somewhere perhaps documentation 
saito makoto 	technical rerere 
matsumoto hiroshima 	txt discard force 
university rights 	error exit 
reserved 	scan path conflicts 
redistribution use 	handle path 
source binary 	thing number conflict 
forms without 	hunks found 
modification permitted 	subclass rerere reads 
provided following 	core buffer 
conditions 	strbuf getline 
met redistributions 	method implementation reproduce 
source code 	conflicted merge 
must retain 	core needswork handle 
copyright notice 	conflicts merges 
list 	merge renormalize grab 
conditions following 	conflict optionally 
disclaimer redistributions 	write original contents 
binary form 	conflict markers 
must reproduce 	look cache entry 
copyright notice 	see conflicting 
list 	conflicting willing handle 
conditions following 	conflicting unable 
disclaimer documentation 	handle determination type 
materials provided 	cache index 
distribution neither 	looked next skipping 
name hiroshima 	stages already 
university 	looked invocation 
names contributors 	function handle regular 
may used 	files stages 
endorse promote 	skip entries name 
products derived 	scan index 
software without 	find paths conflicts 
specific 	rerere handle 
prior written 	ones stages needswork 
permission software 	record replay 
provided copyright 	previous resolve deletion 
holders contributors 	modify conflict 
express implied 	inherently risky without 
warranties 	knowing modification 
including limited 	discarded safe side 
implied warranties 	deletion modification 
merchantability fitness 	identical previous round 
particular purpose 	might want 
disclaimed shall 	handled though merge 
copyright 	list meant 
owner contributors 	hold outstanding 
liable direct 	conflicted paths rerere 
indirect incidental 	could handle 
special exemplary 	abuse list adding 
consequential damages 	types entries 
including 	allow caller show 
limited procurement 	rerere remaining 
substitute goods 	conflicted paths rerere 
services loss 	handle added 
use data 	conflicted paths resolved 
profits business 	marked storing 
interruption 	rerere resolved field 
however caused 	conflict expected 
theory liability 	stored write merge 
whether contract 	file calling 
strict liability 	function needswork may 
tort including 	want fix 
negligence 	caller rerere remaining 
otherwise arising 	without abusing 
way use 	merge find 
software even 	conflict identified change 
advised possibility 	preimage previous 
damage basic 	contents conflict markers 
definitions 	postimage corresponding 
mersenne exponent 	contents conflicts resolved 
period sequence 	may apply 
multiple mexp 	cleanly contents stored 
define mexp 	path conflict 
sfmt generator 	time around returns 
state 	successful replay 
bit integers 	recorded resolution non 
size size 	zero failure 
state regarded 	normalize conflicts path 
bit integers 	write thisimage 
size state 	temporary file three 
regarded 	way merge 
bit integers 	note honors user 
parameters sfmt 	customizable low 
following definitions 	level merge 
xxxx file 	driver settings successful 
pick position 	replay recorded 
define 	resolution mark postimage 
pos parameter 	used help 
shift left 	update path resolution 
four bit 	path indicated 
registers define 	item may still 
parameter shift 	conflict recorded 
left 	resolution replay optionally 
one bit 	update may 
bit integer 	resolved user may 
shifted bits 	preimage conflict 
define parameter 	result needs recorded 
shift right 	resolution postimage 
four 	file recorded resolution 
bit registers 	could attempt 
define parameter 	apply failed 
shift right 	replay user resolved 
one bit 	merge records 
bit integer 	paths conflicts immediately 
shifted 	merge failed 
bits define 	conflicted paths might 
bitmask used 	hand resolved 
recursion parameters 	working since initial 
introduced symmetry 	run would 
simd define 	preimages ask handle 
msk 	file scan 
xdfffffef define 	assign conflict need 
msk xddfecb 	write anything 
define msk 	yet directory exist 
xbffaffff define 	create mkdir 
msk xbffffff 	gitdir fail eexist 
definitions 	already one 
part bit 	needswork make sure 
period certification 	preimage without 
vector define 	removing directory 
parity define 	first encounter conflict 
parity define 	ask handle 
parity 	file write normalized 
define parity 	contents preimage 
sfmt SFMT-params11213.h 	file main entry 
file derives 	point called 
sfmt http 	internally codepaths perform 
www math 	mergy operations 
sci 	possibly leaving conflicted 
hiroshima mat 	index entries 
sfmt index 	working files recreate 
html released 	original conflict 
terms following 	stages index compute 
license copyright 	conflict nuke 
mutsuo 	recorded resolution conflict 
saito makoto 	update preimage 
matsumoto hiroshima 	user resolve conflict 
university rights 	working run 
reserved redistribution 	record postimage 
use source 	remember record resolution 
binary 	conflict user 
forms without 	done paths may 
modification permitted 	resolved incorrectly 
provided following 	recover original conflicted 
conditions met 	state find 
redistributions source 	conflicted paths garbage 
code 	collection support 
must retain 	note reentrant used 
copyright notice 	one time 
list conditions 	matter right recorded 
following disclaimer 	resolution given 
redistributions binary 	conflict needswork rmdir 
form 	fails wouldn 
must reproduce 	already preimage recorded 
copyright notice 	plain rerere 
list conditions 	collect stale conflict 
following disclaimer 	one one 
documentation materials 	conflict resolution 
provided 	rerere recorded preimages 
distribution neither 	abandon user 
name hiroshima 	resolve record resolutions 
university names 	drop git 
contributors may 	dir merge needswork 
used endorse 	shouldn calling 
promote 	reset hard prepare 
products derived 	later call 
software without 	list clear rerere.h 
specific prior 	rerere resolved 
written permission 	hex list rerere 
software provided 	file pathspec 
copyright 	list list list 
holders contributors 	marks paths 
express implied 	hand resolved added 
warranties including 	index field 
limited implied 	paths calling rerere 
warranties merchantability 	remaining given 
fitness 	conflict name 
particular purpose 	file used replaying 
disclaimed shall 	recorded resolution 
copyright owner 	preimage postimage path 
contributors liable 	filesystem entity 
direct indirect 	file specified path 
incidental 	directory houses 
special exemplary 	files reset.c git 
consequential damages 	reset usage 
including limited 	reset type names 
procurement substitute 	sha reset 
goods services 	type quiet desc 
loss 	opts head 
use data 	sha commit hex 
profits business 	body msg 
interruption however 	eol len opt 
caused theory 	data intent 
liability whether 	one missing 
contract 	pathspec sha intent 
strict liability 	opt action 
tort including 	rev rla reset 
negligence otherwise 	type pathspec 
arising way 	argv prefix patch 
use software 	mode rev 
even 	ret rev unused 
advised possibility 	rev sha 
damage parameters 	update status msg 
altivec osx 	sha orig 
linux osx 	sha old orig 
sfmt SFMT-params1279.h 	argc argv 
file 	prefix quiet unborn 
derives sfmt 	rev oid 
http www 	pathspec intent options 
math sci 	commit flags 
hiroshima mat 	err access git 
sfmt index 	path merge 
html 	head memset 
released terms 	read cache unmerged 
following license 	sha error 
copyright mutsuo 	fill descriptor error 
saito makoto 	fill descriptor 
matsumoto hiroshima 	error sha hex 
university 	unpack trees 
rights reserved 	parse indirect prime 
redistribution use 	cache find 
source binary 	unique abbrev logmsg 
forms without 	reencode log 
modification permitted 	output encoding strstr 
provided 	strchr strlen 
following conditions 	unuse commit buffer 
met redistributions 	sha file 
source code 	cache make cache 
must retain 	entry die 
copyright notice 	name intent entry 
list 	cache entry 
conditions following 	memset copy 
disclaimer redistributions 	pathspec diff cache 
binary form 	diffcore std 
must reproduce 	diff flush free 
copyright notice 	pathspec getenv 
list 	strbuf reset strbuf 
conditions following 	addf strbuf 
disclaimer documentation 	addf strbuf addf 
materials provided 	merge unmerged 
distribution neither 	cache die strcmp 
name hiroshima 	strcmp sha 
university 	committish sha treeish 
names contributors 	verify non 
may used 	filename verify filename 
endorse promote 	read cache 
products derived 	die parse pathspec 
software without 	sha sha 
specific 	reflog message update 
prior written 	reflog message 
permission software 	update strbuf 
provided copyright 	release git config 
holders contributors 	parse options 
express implied 	parse args strcmp 
warranties 	sha hashcpy 
including limited 	sha committish die 
implied warranties 	lookup commit 
merchantability fitness 	reference die oidcpy 
particular purpose 	sha treeish 
disclaimed shall 	die parse indirect 
copyright 	die oidcpy 
owner contributors 	die run interactive 
liable direct 	warning die 
indirect incidental 	git work setup 
special exemplary 	work bare 
consequential damages 	repository die die 
including 	die unmerged 
limited procurement 	cache xcalloc 
substitute goods 	hold locked index 
services loss 	read git 
use data 	work refresh index 
profits business 	reset index 
interruption 	reset index die 
however caused 	write locked 
theory liability 	index die reset 
whether contract 	refs print 
strict liability 	head line lookup 
tort including 	commit reference 
negligence 	branch state git 
otherwise arising 	reset builtin 
way use 	command copyright carlos 
software even 	rica git 
advised possibility 	reset copyright linus 
damage parameters 	torvalds junio 
altivec 	hamano fallthrough possible 
osx linux 	arguments git 
osx sfmt 	reset opts 
SFMT-params132049.h file 	rev git reset 
derives sfmt 	opts paths 
http www 	git reset opts 
math 	paths git 
sci hiroshima 	reset opts paths 
mat sfmt 	git reset 
index html 	opts paths point 
released terms 	argv points 
following license 	immediately opts reset 
copyright 	head possibly 
mutsuo saito 	paths otherwise argv 
makoto matsumoto 	could either 
hiroshima university 	rev paths unambiguous 
rights reserved 	single argument 
redistribution use 	argv looks like 
source 	commit filename 
binary forms 	otherwise treat filename 
without modification 	reset unborn 
permitted provided 	branch treat 
following conditions 	reset empty git 
met redistributions 	reset paths 
source 	used load chosen 
code must 	paths index 
retain copyright 	without affecting working 
notice list 	head soft 
conditions following 	reset touch index 
disclaimer redistributions 	file working 
binary 	requires good order 
form must 	resets reset 
reproduce copyright 	index file switching 
notice list 	resets without 
conditions following 	paths update head 
disclaimer documentation 	head switched 
materials 	saving previous head 
provided distribution 	orig head 
neither name 	resolve-undo.c istate lost 
hiroshima university 	resolve undo 
names contributors 	stage resolve 
may used 	undo item data 
endorse 	size resolve 
promote products 	undo len endptr 
derived software 	lost istate 
without specific 	resolve undo istate 
prior written 	pos item 
permission software 	matched name nce 
provided 	istate istate 
copyright holders 	pathspec stage xcalloc 
contributors express 	list insert 
implied warranties 	xcalloc hashcpy strbuf 
including limited 	addstr strbuf 
implied warranties 	addch strbuf addf 
merchantability 	strbuf xcalloc 
fitness particular 	strlen list insert 
purpose disclaimed 	xcalloc strtoul 
shall copyright 	hashcpy list 
owner contributors 	clear error list 
liable direct 	clear free 
indirect 	stage strcmp list 
incidental special 	lookup xstrdup 
exemplary consequential 	index entry make 
damages including 	cache entry 
limited procurement 	index entry error 
substitute goods 	free free 
services 	unmerge index entry 
loss use 	unmerge index 
data profits 	entry path match 
business interruption 	unmerge index 
however caused 	entry error run 
theory liability 	memory list 
whether 	already unmerged last 
contract strict 	entry processed 
liability tort 	resolve-undo.h mode sha 
including negligence 	index state 
otherwise arising 	cache entry 
way use 	strbuf list index 
software 	state index 
even advised 	state index state 
possibility damage 	pathspec index 
parameters altivec 	state rev-list.c rev 
osx linux 	list usage 
osx sfmt 	commit data commit 
SFMT-params19937.h 	data info 
file derives 	revs parents children 
sfmt http 	buf ctx 
www math 	commit data obj 
sci hiroshima 	name data 
mat sfmt 	info obj name 
index 	data info 
html released 	commit val val 
terms following 	info reaches 
license copyright 	cnt flags hex 
mutsuo saito 	tried revs 
makoto matsumoto 	show fast 
hiroshima 	argc argv prefix 
university rights 	revs info 
reserved redistribution 	bisect list bisect 
use source 	show vars 
binary forms 	bisect find use 
without modification 	bitmap index 
permitted 	arg commit count 
provided following 	finish commit 
conditions met 	graph show commit 
redistributions source 	finish commit 
code must 	fputs fputs revision 
retain copyright 	mark fputs 
notice 	find unique abbrev 
list conditions 	fputs oid 
following disclaimer 	hex oid hex 
redistributions binary 	lookup decoration 
form must 	oid hex show 
reproduce copyright 	decorations putchar 
notice 	putchar cached 
list conditions 	commit buffer log 
following disclaimer 	output encoding 
documentation materials 	pretty print commit 
provided distribution 	graph show 
neither name 	oneline graph show 
hiroshima 	commit msg 
university names 	graph show padding 
contributors may 	putchar graph 
used endorse 	show remainder putchar 
promote products 	putchar fwrite 
derived software 	putchar strbuf release 
without 	graph show 
specific prior 	remainder putchar maybe 
written permission 	flush die 
software provided 	finish commit free 
copyright holders 	commit list 
contributors express 	free commit buffer 
implied 	file die 
warranties including 	oid hex 
limited implied 	parse finish show 
warranties merchantability 	name oid 
fitness particular 	hex filter skipped 
purpose disclaimed 	sha hex 
shall 	traverse commit list 
copyright owner 	print str 
contributors liable 	print print print 
direct indirect 	print print 
incidental special 	estimate bisect steps 
exemplary consequential 	git config 
damages 	init revisions setup 
including limited 	revisions memset 
procurement substitute 	diff opt tst 
goods services 	strcmp strcmp 
loss use 	strcmp strcmp strcmp 
data profits 	strcmp strcmp 
business 	test bitmap 
interruption however 	walk usage usage 
caused theory 	die prepare 
liability whether 	bitmap walk count 
contract strict 	bitmap commit 
liability tort 	list prepare bitmap 
including 	walk traverse 
negligence otherwise 	bitmap commit list 
arising way 	prepare revision 
use software 	walk die mark 
even advised 	edges uninteresting 
possibility damage 	find bisection show 
parameters 	bisect vars 
altivec osx 	traverse commit list 
linux osx 	newline commit 
sfmt SFMT-params216091.h 	message usually newline 
file derives 	produces blank 
sfmt 	padding line entries 
http www 	need graph 
math sci 	padding line 
hiroshima mat 	however commit message 
sfmt index 	may end 
html released 	newline newline simply 
terms 	ends last 
following license 	line commit message 
copyright mutsuo 	need graph 
saito makoto 	output always happens 
matsumoto hiroshima 	cmit fmt 
university rights 	oneline happens cmit 
reserved 	fmt userformat 
redistribution use 	format doesn explicitly 
source binary 	end newline 
forms without 	message buffer empty 
modification permitted 	show rest 
provided following 	graph output commit 
conditions 	revs commits 
met redistributions 	reach reaches commits 
source code 	among commits 
must retain 	good reaches 
copyright notice 	commits left bisected 
list conditions 	hand bad 
following 	bisect reaches bisect 
disclaimer redistributions 	size commits 
binary form 	test already know 
must reproduce 	one bad 
copyright notice 	one command line 
list conditions 	pretty header 
following 	specified rev-parse.c filter 
disclaimer documentation 	def show 
materials provided 	type symbolic abbrev 
distribution neither 	abbrev abbrev 
name hiroshima 	strict output stuck 
university names 	excludes arg 
contributors 	rev args str 
may used 	len arg 
endorse promote 	type arg type 
products derived 	sha name 
software without 	discard full 
specific prior 	arg sha refname 
written 	oid flag 
permission software 	data refname oid 
provided copyright 	flag data 
holders contributors 	sha data flag 
express implied 	datestr buffer 
warranties including 	arg output prefix 
limited 	prefix arg 
implied warranties 	dotdot sha end 
merchantability fitness 	next symmetric 
particular purpose 	head exclude commit 
disclaimed shall 	arg dotdot 
copyright owner 	sha commit parents 
contributors 	parents arg 
liable direct 	unset parsed argc 
indirect incidental 	argv prefix 
special exemplary 	stop non 
consequential damages 	option parseopt usage 
including limited 	parseopt opts 
procurement 	flag chars parsed 
substitute goods 	usage opts 
services loss 	usz help argc 
use data 	argv buf 
profits business 	quiet builtin rev 
interruption however 	parse usage 
caused 	argc argv prefix 
theory liability 	type dashdash 
whether contract 	output prefix sha 
strict liability 	flags name 
tort including 	unused arg work 
negligence otherwise 	pfx work 
arising 	gitdir cwd len 
way use 	pfx gitdir 
software even 	sha isdigit strlen 
advised possibility 	strcmp strncmp 
damage parameters 	putchar fputs 
altivec osx 	putchar putchar putchar 
linux 	puts putchar 
osx sfmt 	show dwim strlen 
SFMT-params2281.h file 	shorten unambiguous 
derives sfmt 	show type error 
http www 	free show 
math sci 	type show type 
hiroshima 	find unique 
mat sfmt 	abbrev show type 
index html 	sha hex 
released terms 	rev argument show 
following license 	sha show 
copyright mutsuo 	rev excluded show 
saito 	rev show 
makoto matsumoto 	rev show rev 
hiroshima university 	snprintf approxidate 
rights reserved 	show show show 
redistribution use 	prefix filename 
source binary 	strlen show 
forms 	strstr sha committish 
without modification 	sha committish 
permitted provided 	show rev show 
following conditions 	rev lookup 
met redistributions 	commit reference lookup 
source code 	commit reference 
must 	merge bases pop 
retain copyright 	commit show 
notice list 	rev strstr strstr 
conditions following 	sha committish 
disclaimer redistributions 	show rev lookup 
binary form 	commit reference 
must 	show rev strbuf 
reproduce copyright 	addf strbuf 
notice list 	addf strbuf addf 
conditions following 	strbuf addch 
disclaimer documentation 	strbuf addch quote 
materials provided 	buf isspace 
distribution 	strbuf addstr 
neither name 	parse options strcmp 
hiroshima university 	usage options 
names contributors 	strbuf getline die 
may used 	alloc grow 
endorse promote 	strcmp die strbuf 
products 	detach strbuf 
derived software 	getline alloc grow 
without specific 	memset strchr 
prior written 	xstrdup skipspaces xstrdup 
permission software 	skipspaces strpbrk 
provided copyright 	xmemdupz xmemdupz xmemdupz 
holders 	strbuf release 
contributors express 	alloc grow memset 
implied warranties 	parse options 
including limited 	strbuf addf quote 
implied warranties 	argv puts 
merchantability fitness 	quote argv strbuf 
particular 	release exit 
purpose disclaimed 	die strcmp 
shall copyright 	cmd parseopt strcmp 
owner contributors 	cmd quote 
liable direct 	strcmp usage strcmp 
indirect incidental 	setup git 
special 	directory git config 
exemplary consequential 	strcmp die 
damages including 	puts git path 
limited procurement 	show file 
substitute goods 	verify filename strcmp 
services loss 	die show 
use 	show starts show 
data profits 	strcmp show 
business interruption 	file strcmp die 
however caused 	strcmp die 
theory liability 	strcmp strcmp strcmp 
whether contract 	strcmp strcmp 
strict 	strcmp strcmp 
liability tort 	strcmp starts strtoul 
including negligence 	strcmp strcmp 
otherwise arising 	strcmp strcmp starts 
way use 	strcmp strcmp 
software even 	die strcmp starts 
advised 	abbrev strcmp 
possibility damage 	starts glob clear 
parameters altivec 	exclusion strcmp 
osx linux 	branch clear exclusion 
osx sfmt 	starts glob 
SFMT-params4253.h file 	clear exclusion strcmp 
derives 	tag clear 
sfmt http 	exclusion starts glob 
www math 	clear exclusion 
sci hiroshima 	starts glob clear 
mat sfmt 	exclusion strcmp 
index html 	remote clear exclusion 
released 	starts exclusion 
terms following 	strcmp strcmp 
license copyright 	git work puts 
mutsuo saito 	strcmp puts 
makoto matsumoto 	putchar strcmp inside 
hiroshima university 	work git 
rights 	work strchr putchar 
reserved redistribution 	strcmp getenv 
use source 	puts puts xgetcwd 
binary forms 	strlen free 
without modification 	strcmp puts prefix 
permitted provided 	filename strlen 
following 	git common dir 
conditions met 	strcmp die 
redistributions source 	resolve gitdir die 
code must 	puts strcmp 
retain copyright 	inside git dir 
notice list 	strcmp inside 
conditions 	work strcmp bare 
following disclaimer 	repository strcmp 
redistributions binary 	read cache 
form must 	die puts git 
reproduce copyright 	path sha 
notice list 	hex starts show 
conditions 	datestring starts 
following disclaimer 	show datestring starts 
documentation materials 	show datestring 
provided distribution 	starts show datestring 
neither name 	show flag 
hiroshima university 	die single rev 
names 	difference parent 
contributors may 	shorthands sha context 
used endorse 	show rev 
promote products 	die single rev 
derived software 	die show 
without specific 	file verify filename 
prior 	show rev 
written permission 	show die single 
software provided 	rev show 
copyright holders 	rev parse 
contributors express 	copyright linus torvalds 
implied warranties 	arguments relevant 
including 	revision arguments others 
limited implied 	output format 
warranties merchantability 	details sorts accept 
fitness particular 	digit like 
purpose disclaimed 	traditional head output 
shall copyright 	argument either 
owner 	normal like show 
contributors liable 	negation prefix 
direct indirect 	according type output 
incidental special 	revision filter 
exemplary consequential 	allows found could 
damages including 	emit name 
limited 	symbolic full users 
procurement substitute 	interested finding 
goods services 	refs spelled 
loss use 	full would need 
data profits 	filter non 
business interruption 	refs happy ambiguous 
however 	output flag 
caused theory 	filter allows date 
liability whether 	handling requires 
contract strict 	flags revs range 
liability tort 	pathspec parent 
including negligence 	directory usage first 
otherwise 	line parse 
arising way 	arghint help name 
use software 	option option 
even advised 	flags put opt 
possibility damage 	end pass 
parameters altivec 	show anything files 
osx 	flag argument 
linux osx 	revert.c revert usage 
sfmt SFMT-params44497.h 	cherry pick 
file derives 	usage opts 
sfmt http 	opts opt arg 
www math 	unset opts 
sci 	ptr opts opt 
hiroshima mat 	opt argc 
sfmt index 	argv opts usage 
html released 	str cmd 
terms following 	options extra operation 
license copyright 	opt argc 
mutsuo 	argv prefix opts 
saito makoto 	res argc 
matsumoto hiroshima 	argv prefix opts 
university rights 	res alloc 
reserved redistribution 	grow xstrdup start 
use source 	arg arg 
binary 	end die revert 
forms without 	cherry pick 
modification permitted 	usage action name 
provided following 	parse options 
conditions met 	concat size 
redistributions source 	die parse options 
code 	verify opt 
must retain 	compatible verify opt 
copyright notice 	compatible xmalloc 
list conditions 	init revisions usage 
following disclaimer 	options strcmp 
redistributions binary 	memset setup revisions 
form 	usage options 
must reproduce 	memset isatty git 
copyright notice 	config parse 
list conditions 	args sequencer pick 
following disclaimer 	revisions die 
documentation materials 	memset git config 
provided 	parse args 
distribution neither 	sequencer pick revisions 
name hiroshima 	die builtins 
university names 	revert cherry pick 
contributors may 	copyright johannes 
used endorse 	schindelin git 
promote 	revert copyright linus 
products derived 	torvalds copyright 
software without 	junio hamano implies 
specific prior 	allow empty 
written permission 	subcommand check incompatible 
software provided 	command line 
copyright 	arguments revision.c show 
holders contributors 	early output 
express implied 	term bad term 
warranties including 	good obj 
limited implied 	name blob desc 
warranties merchantability 	entry obj 
fitness 	obj commit commit 
particular purpose 	revs obj 
disclaimed shall 	name mode path 
copyright owner 	buf len 
contributors liable 	revs obj 
direct indirect 	name mode revs 
incidental 	obj name 
special exemplary 	revs sha obj 
consequential damages 	revs name 
including limited 	sha flags revs 
procurement substitute 	name sha 
goods services 	flags revs entry 
loss 	name path 
use data 	mode flags tag 
profits business 	commit orig 
interruption however 	interesting cache list 
caused theory 	commit commit 
liability whether 	commit revs orig 
contract 	list relevant 
strict liability 	commit difference options 
tort including 	addremove mode 
negligence otherwise 	sha sha valid 
arising way 	fullpath dirty 
use software 	submodule diff 
even 	options old mode 
advised possibility 	mode old 
damage parameters 	sha sha old 
altivec osx 	sha valid 
linux osx 	sha valid fullpath 
sfmt SFMT-params607.h 	old dirty 
file 	submodule dirty submodule 
derives sfmt 	revs parent 
http www 	commit revs commit 
math sci 	retval nparents 
hiroshima mat 	treesame revs commit 
sfmt index 	revs commit 
html 	nth parent old 
released terms 	revs commit 
following license 	relevant parents relevant 
copyright mutsuo 	change irrelevant 
saito makoto 	change revs revs 
matsumoto hiroshima 	commit parent 
university 	irrelevant change 
rights reserved 	relevant parents nth 
redistribution use 	parent head 
source binary 	cached cache entry 
forms without 	revs commit 
modification permitted 	list cache ptr 
provided 	parent left 
following conditions 	flag cached list 
met redistributions 	revs right 
source code 	count left first 
must retain 	ids cherry 
copyright notice 	flag commit flags 
list 	commit flags 
conditions following 	commit flags commit 
disclaimer redistributions 	ent src 
binary form 	date slop interesting 
must reproduce 	cache bottom 
copyright notice 	list rlist made 
list 	progress parents 
conditions following 	list elem 
disclaimer documentation 	bottom list revs 
materials provided 	commit revs 
distribution neither 	slop date list 
name hiroshima 	newlist bottom 
university 	interesting cache commit 
names contributors 	obj show 
may used 	revs item name 
endorse promote 	whence flags 
products derived 	info revs commit 
software without 	list whence 
specific 	flags flags warned 
prior written 	bad reflog 
permission software 	revs name errormsg 
provided copyright 	excludes path 
holders contributors 	item path oid 
express implied 	flag data 
warranties 	revs flags excludes 
including limited 	excludes exclude 
implied warranties 	submodule revs 
merchantability fitness 	flags sha data 
particular purpose 	osha nsha 
disclaimed shall 	email timestamp message 
copyright 	data path 
owner contributors 	oid flag data 
liable direct 	revs flags 
indirect incidental 	revs path baselen 
special exemplary 	sub revs 
consequential damages 	flags blob path 
including 	revs arg 
limited procurement 	flags sha commit 
substitute goods 	parents arg 
services loss 	revs prefix revs 
use data 	commit list 
profits business 	flags revs bases 
interruption 	head sha 
however caused 	prune prune 
theory liability 	num arg revs 
whether contract 	flags revarg 
strict liability 	opt dotdot sha 
tort including 	local flags 
negligence 	arg cant filename 
otherwise arising 	sha flags 
way use 	sha next symmetric 
software even 	flags exclude 
advised possibility 	head flags obj 
damage parameters 	obj exclude 
altivec 	alloc path prune 
osx linux 	revs prune 
osx sfmt 	revs prune seen 
SFMT-params86243.h file 	dashdash save 
derives sfmt 	warning len grep 
http www 	header grep 
math 	revs pattern revs 
sci hiroshima 	argc argv 
mat sfmt 	unkc unkv 
index html 	arg optarg argcount 
released terms 	count buf 
following license 	opts revs ctx 
copyright 	options usagestr 
mutsuo saito 	submodule data term 
makoto matsumoto 	bisect refs 
hiroshima university 	status submodule data 
rights reserved 	submodule data 
redistribution use 	submodule revs argc 
source 	argv flags 
binary forms 	arg optarg argcount 
without modification 	def sha 
permitted provided 	flags refname argc 
following conditions 	argv revs 
met redistributions 	opt flags left 
source 	seen dashdash 
code must 	read stdin revarg 
retain copyright 	opt prune 
notice list 	data submodule 
conditions following 	arg arg opts 
disclaimer 	sha revs 
redistributions binary 	parent child revs 
form must 	commit surviving 
reproduce copyright 	parents parent simplified 
notice list 	revs commit 
conditions following 	revs commit marked 
disclaimer 	orig cnt 
documentation materials 	cnt revs commit 
provided distribution 	marked parent 
neither name 	revs commit marked 
hiroshima university 	revs commit 
names contributors 	nth parent removed 
may 	parent revs 
used endorse 	commit tail parent 
promote products 	pst cnt 
derived software 	marked revs list 
without specific 	next yet 
prior written 	tail commit 
permission 	revs commit revs 
software provided 	old pending 
copyright holders 	next commit parent 
contributors express 	buf mailmap 
implied warranties 	person endp len 
including limited 	namelen maillen 
implied 	name mail ident 
warranties merchantability 	namemail commit 
fitness particular 	opt retval encoding 
purpose disclaimed 	message buf 
shall copyright 	revs revs commit 
owner contributors 	revs revs 
liable 	commit parents revs 
direct indirect 	commit revs 
incidental special 	commit entry data 
exemplary consequential 	unused revs 
damages including 	objects revs 
limited procurement 	revs reversed revs 
substitute 	commit revs 
goods services 	commit mark oid 
loss use 	hex fputc 
data profits 	fputc file parse 
business interruption 	die oid 
however caused 	hex init desc 
theory 	entry type 
liability whether 	mark uninteresting lookup 
contract strict 	mark blob 
liability tort 	uninteresting lookup blob 
including negligence 	free buffer 
otherwise arising 	mark contents uninteresting 
way 	commit list 
use software 	insert pop commit 
even advised 	file commit 
possibility damage 	list insert interpret 
parameters altivec 	branch name 
osx linux 	strbuf addstr 
osx 	reflog walk strbuf 
sfmt SFMT-sse2.h 	release path 
mask ctx 	pending path pending 
mask ctx 	mode sha 
size mask 	parse pending parse 
load srli 	die reference 
epi 	pending pending die 
srli slli 	parse die 
epi xor 	oid hex parse 
xor slli 	commit die 
xor xor 	mark parents uninteresting 
epi load 	xstrdup mark 
load 	contents uninteresting pending 
recursion store 	path pending 
recursion store 	path die relevant 
epi load 	commit diff 
load recursion 	opt diff opt 
store recursion 	name decoration 
store 	diff opt 
recursion store 	clr diff sha 
load store 	diff opt 
recursion store 	clr diff sha 
store file 	commit list 
derives sfmt 	count xcalloc decoration 
http 	die rev 
www math 	empty lookup decoration 
sci hiroshima 	die memmove 
mat sfmt 	die free decoration 
index html 	lookup decoration 
released terms 	die oid hex 
following 	relevant commit 
license copyright 	rev empty relevant 
mutsuo saito 	commit initialise 
makoto matsumoto 	treesame parse commit 
hiroshima university 	die oid 
rights reserved 	hex oid hex 
redistribution 	rev compare 
use source 	relevant commit 
binary forms 	rev empty parse 
without modification 	commit die 
permitted provided 	oid hex oid 
following conditions 	hex relevant 
met 	commit die oid 
redistributions source 	hex commit 
code must 	list insert date 
retain copyright 	commit list 
notice list 	insert date include 
conditions following 	check parse 
disclaimer 	commit gently mark 
redistributions binary 	parents uninteresting 
form must 	commit list insert 
reproduce copyright 	date cached 
notice list 	simplify commit parse 
conditions following 	commit gently 
disclaimer 	commit list 
documentation materials 	insert date cached 
provided distribution 	init patch 
neither name 	ids commit patch 
hiroshima university 	commit patch 
names contributors 	free patch ids 
may 	everybody uninteresting 
used endorse 	commit list insert 
promote products 	free commit 
derived software 	list commit list 
without specific 	insert collect 
prior written 	bottom commits die 
permission 	pop commit 
software provided 	parents list mark 
copyright holders 	parents uninteresting 
contributors express 	commit list insert 
implied warranties 	still interesting 
including limited 	commit list insert 
implied 	show cherry 
warranties merchantability 	pick list 
fitness particular 	limit left right 
purpose disclaimed 	limit ancestry 
shall copyright 	free commit list 
owner contributors 	limiting increase 
liable 	treesame update treesame 
direct indirect 	alloc grow 
incidental special 	xstrdup rev cmdline 
exemplary consequential 	oid hex 
damages including 	wildmatch excluded reference 
limited procurement 	rev cmdline 
substitute 	pending sha list 
goods services 	clear free 
loss use 	xcalloc list append 
data profits 	init refs 
business interruption 	sha parse pending 
however caused 	warning handle 
theory 	one reflog commit 
liability whether 	handle one 
contract strict 	reflog commit 
liability tort 	reflog ent reflog 
including negligence 	lookup pending 
otherwise arising 	path strbuf addf 
way 	cache strbuf 
use software 	setlen read cache 
even advised 	isgitlink lookup 
possibility damage 	blob die pending 
file sfmt 	path cache 
sse brief 	strbuf release sha 
simd 	committish reference 
oriented fast 	hashcpy rev cmdline 
mersenne twister 	pending memset 
sfmt intel 	diff opt diff 
sse author 	opt init 
mutsuo saito 	grep defaults grep 
hiroshima 	init diff 
university author 	setup strlen pending 
makoto matsumoto 	oid hex 
hiroshima university 	sha die 
note little 	lookup commit die 
endian file 	sha die 
copyright 	lookup commit die 
mutsuo saito 	pending pending 
makoto matsumoto 	merge bases rev 
hiroshima university 	cmdline list 
rights reserved 	pending commit list 
bsd license 	free commit 
applied 	list read cache 
software see 	stage path 
license txt 	match realloc name 
function represents 	free pathspec 
recursion formula 	parse pathspec strstr 
param bit 	sha committish 
part 	sha committish verify 
interal state 	non filename 
param bit 	parse parse die 
part interal 	lookup commit 
state param 	reference lookup 
bit part 	commit reference merge 
interal 	bases rev 
state param 	cmdline list pending 
bit part 	commit list 
interal state 	free commit list 
param mask 	rev cmdline 
bit mask 	rev cmdline pending 
output 	pending strstr 
function fills 	parents strstr parents 
state pseudorandom 	sha context 
integers function 	verify non filename 
fills user 	reference rev 
specified pseudorandom 	cmdline pending mode 
integers 	alloc grow 
param bit 	strbuf getline alloc 
filled pseudorandom 	grow xstrdup 
numbers param 	strbuf init 
size number 	strbuf getline die 
bit pesudorandom 	handle revision 
numbers 	arg die read 
generated main 	pathspec stdin 
loop SFMT.c 	strbuf release grep 
sfmt idx 	strcmp strcmp 
initialized parity 	strcmp strcmp strcmp 
shift shift 	strcmp strcmp 
ctx 	strcmp strcmp starts 
ctx size 	strcmp starts 
ctx size 	starts starts starts 
shift shift 	starts parse 
shift shift 	opt atoi parse 
ctx ctx 	opt atoi 
size 	isdigit strtol die 
size ctx 	strcmp error 
inner work 	atoi starts atoi 
psfmt ctx 	parse opt 
psfmt ctx 	atoi parse 
limit ret 	opt approxidate parse 
ctx 	opt approxidate 
psfmt psfmt 	parse opt atoi 
ctx limit 	parse opt 
ret ctx 	approxidate parse opt 
size ctx 	approxidate strcmp 
size seed 	strcmp strcmp strcmp 
ctx 	init reflog 
psfmt init 	walk strcmp error 
key key 	strcmp strcmp 
length ctx 	strcmp strcmp load 
count lag 	decorations strcmp 
mid size 	strcmp starts atoi 
psfmt 	strcmp strcmp 
ctx lshift 	strcmp strcmp strcmp 
rshift lshift 	strcmp strcmp 
rshift recursion 	starts atoi starts 
recursion recursion 	starts atoi 
recursion recursion 	starts strcmp 
recursion 	strcmp strcmp die 
idxof idxof 	strcmp die 
gen rand 	strcmp die strcmp 
gen rand 	strcmp die 
gen rand 	strcmp die strcmp 
kqu kqu 	strcmp strcmp 
gen 	strcmp strcmp starts 
rand gen 	die strcmp 
rand gen 	diff opt strcmp 
rand swap 	diff opt 
posix memalign 	diff opt strcmp 
idxof idxof 	strcmp strcmp 
idxof 	strcmp strcmp commit 
idxof period 	format starts 
certification posix 	starts commit format 
memalign memset 	strcmp strcmp 
func idxof 	strcmp strcmp starts 
idxof idxof 	starts xstrdup 
idxof 	starts starts 
idxof idxof 	starts strbuf addstr 
func idxof 	strbuf addstr 
idxof idxof 	expand notes list 
idxof idxof 	append strbuf 
idxof func 	detach strcmp list 
idxof 	clear strcmp 
idxof idxof 	strcmp strcmp commit 
idxof idxof 	format strcmp 
idxof func 	graph init strcmp 
idxof idxof 	strcmp strcmp 
idxof idxof 	strcmp strcmp starts 
idxof 	strtoul strcmp 
idxof period 	strcmp strcmp strcmp 
certification free 	strcmp parse 
file derives 	opt parse date 
sfmt http 	format strcmp 
www math 	parse opt 
sci 	header grep parse 
hiroshima mat 	opt header 
sfmt index 	grep parse opt 
html released 	header grep 
terms following 	parse opt message 
license copyright 	grep strcmp 
mutsuo 	strcmp grep pattern 
saito makoto 	type option 
matsumoto hiroshima 	strcmp strcmp grep 
university rights 	pattern type 
reserved redistribution 	option strcmp strcmp 
use source 	diff opt 
binary 	strcmp strcmp grep 
forms without 	pattern type 
modification permitted 	option strcmp grep 
provided following 	pattern type 
conditions met 	option strcmp strcmp 
redistributions source 	parse opt 
code 	strcmp xstrdup 
must retain 	strcmp strcmp strcmp 
copyright notice 	diff opt 
list conditions 	parse die handle 
following disclaimer 	revision opt 
redistributions binary 	error usage options 
form 	strbuf addf 
must reproduce 	submodule strbuf release 
copyright notice 	bisect bisect 
list conditions 	strcmp handle refs 
following disclaimer 	handle refs 
documentation materials 	clear exclusion strcmp 
provided 	handle refs 
distribution neither 	clear exclusion strcmp 
name hiroshima 	read bisect 
university names 	terms handle refs 
contributors may 	handle refs 
used endorse 	strcmp handle refs 
promote 	clear exclusion 
products derived 	strcmp handle 
software without 	refs clear exclusion 
specific prior 	parse opt 
written permission 	init refs glob 
software provided 	clear exclusion 
copyright 	parse opt exclusion 
holders contributors 	starts init 
express implied 	refs glob clear 
warranties including 	exclusion starts 
limited implied 	init refs glob 
warranties merchantability 	clear exclusion 
fitness 	starts init refs 
particular purpose 	glob clear 
disclaimed shall 	exclusion strcmp reflogs 
copyright owner 	pending strcmp 
contributors liable 	index objects pending 
direct indirect 	strcmp strcmp 
incidental 	starts strcmp strcmp 
special exemplary 	error strcmp 
consequential damages 	resolve die 
including limited 	skip prefix die 
procurement substitute 	memset strcmp 
goods services 	append prune data 
loss 	handle revision 
use data 	pseudo opt strcmp 
profits business 	die read 
interruption however 	revisions stdin handle 
caused theory 	revision opt 
liability whether 	exit handle revision 
contract 	arg die 
strict liability 	verify filename append 
tort including 	prune data 
negligence otherwise 	alloc grow parse 
arising way 	pathspec tweak 
use software 	prepare show merge 
even 	sha context 
advised possibility 	diagnose missing 
damage file 	reference pending mode 
sfmt brief 	diff opt 
simd oriented 	tst copy pathspec 
fast mersenne 	diff opt 
twister 	tst copy pathspec 
sfmt author 	diff setup 
mutsuo saito 	done grep commit 
hiroshima university 	pattern type 
author makoto 	compile grep patterns 
matsumoto hiroshima 	die die 
university 	die die die 
copyright mutsuo 	die die 
saito makoto 	xcalloc decoration lookup 
matsumoto hiroshima 	decoration compact 
university rights 	treesame lookup decoration 
reserved bsd 	xcalloc decoration 
license 	reduce heads commit 
applied software 	list count 
see license 	commit list 
txt bit 	count die free 
simd data 	commit list 
type altivec 	lookup decoration free 
sse 	compact treesame 
standard bit 	update treesame locate 
data structure 	simplify state 
bit data 	locate simplify state 
type bit 	commit list 
data structure 	insert commit list 
bit 	insert locate 
data type 	simplify state duplicate 
bit data 	parents mark 
structure bit 	redundant parents mark 
data type 	treesame root 
bit state 	parents one treesame 
index 	parent marked 
counter bit 	parents one relevant 
state flag 	parent locate 
state yet 	simplify state 
initialized file 	commit list insert 
variables state 	pop commit 
index 	simplify one pop 
counter flag 	commit locate 
parity check 	simplify state commit 
vector certificate 	list insert 
period mexp 	child clear flags 
functions function 	memcpy handle 
simulate 	commit commit list 
bit index 	append clear 
little endian 	limiting increase treesame 
big endian 	commit list 
machine function 	sort date limit 
simulates simd 	list sort 
bit 	topological order line 
right shift 	log filter 
standard bit 	simplify merges children 
integer given 	rewrite parent 
shifted shift 	duplicate parents 
bits function 	strstr strlen strchr 
simulates 	split ident 
little endian 	line map user 
simd param 	strbuf addf 
output function 	strbuf splice strbuf 
param bit 	release strbuf 
data shifted 	addstr reflog message 
param 	strbuf addch 
shift shift 	log output encoding 
function simulates 	logmsg reencode 
simd bit 	strbuf addstr strbuf 
left shift 	addstr commit 
standard bit 	rewrite person commit 
integer 	rewrite person 
given shifted 	strbuf addstr format 
shift bits 	display notes 
function simulates 	grep buffer grep 
little endian 	buffer strlen 
simd param 	strbuf release 
output 	unuse commit buffer 
function param 	sha pack 
bit data 	commit list count 
shifted param 	commit match 
shift shift 	want ancestry relevant 
function represents 	commit xmalloc 
recursion 	init saved parents 
formula param 	saved parents 
output param 	copy commit list 
bit part 	clear saved 
state param 	parents saved parents 
bit 	oidcmp free 
part state 	commit list copy 
param bit 	commit list 
part state 	pop commit save 
param bit 	parents fake 
part state 	reflog parent 
function 	parents list die 
fills state 	oid hex 
pseudorandom integers 	simplify commit die 
function fills 	oid hex 
user specified 	track linear filter 
pseudorandom integers 	free commit 
param 	list commit list 
bit filled 	insert sort 
pseudorandom numbers 	topological order pop 
param size 	commit revision 
number bit 	revision create boundary 
pseudorandom numbers 	commit list 
generated 	revision boundary revision 
function represents 	commit list 
function used 	insert pop commit 
initialization init 	revision graph 
param bit 	update free saved 
integer bit 	parents free 
integer 	commit list 
function represents 	revision mark strlen 
function used 	fputs putchar 
initialization init 	subproject commit repository 
param bit 	care marked 
integer bit 	uninteresting missing commit 
integer 	iff parent 
function certificate 	marked uninteresting mark 
period mexp 	thing parsed 
check check 	popped next time 
modification functions 	around won 
function returns 	trying parse error 
identification 	normally haven 
shows word 	parsed parent yet 
size mersenne 	won parent 
exponent parameters 	parent however may 
generator function 	turn reached 
returns minimum 	commit way wasn 
size 	uninteresting need 
used fill 	mark parents 
function minimum 	recursively tag look 
size used 	points handle 
fill function 	tagged looping dropping 
function returns 	non tag 
minimum 	handlers propagate path 
size used 	data tag 
fill function 	pending entry commit 
minimum size 	complex reachability 
used fill 	crud either mark 
function function 	uninteresting list 
generates 	objects look later 
returns bit 	blob know 
pseudorandom number 	drill definition relevant 
init gen 	commit use 
rand init 	simplify limited graphs 
must called 	eliminating side 
function 	branches relevant commit 
bit pseudorandom 	one uninteresting 
number generate 	including list 
random integer 	specified bottom commit 
limit function 	computing limited 
generates returns 	list processing generally 
bit 	ignore boundary 
pseudorandom number 	merges coming outside 
init gen 	graph irrelevant 
rand init 	parents treat merges 
must called 	single parent 
function function 	treesame defined consider 
gen 	relevant parents 
rand called 	treesame graph parents 
gen rand 	care treesame 
unless initialization 	non graph parents 
executed bit 	treating bottom 
pseudorandom number 	commits relevant ensures 
generate 	limited graph 
random integer 	connection actual 
limit function 	bottom commit viewed 
generates pseudorandom 	side branch 
bit integers 	treated part graph 
specified one 	example computing 
call 	connection least important 
number pseudorandom 	despite flagged 
integers specified 	uninteresting computing ancestry 
argument size 	path connection 
must least 	important despite flagged 
multiple four 	uninteresting single 
generation 	relevant commit parent 
function much 	list treesame 
faster following 	commit selects one 
gen rand 	parents safely 
function initialization 	simplify parent parent 
init gen 	commits first 
rand 	parent first parent 
init must 	even relevant 
called first 	definition treesame 
call function 	purely parent multi 
function used 	parent commits 
calling gen 	identify sole relevant 
rand 	parent one 
function without 	relevant parent treesame 
initialization param 	purely regard 
pseudorandom bit 	parent simplify accordingly 
integers filled 	one relevant 
function pointer 	parent relevant parents 
must 	multiple irrelevant 
aligned namely 	ones parent goal 
must multiple 	rev result 
simd version 	diff consists changes 
since refers 	rev old 
address bit 	whole diff removal 
integer 	old data 
standard version 	otherwise rev different 
pointer arbitrary 	course trees 
param size 	want rev 
number bit 	means rev different 
pseudorandom integers 	look simplifying 
generated 	decoration commit worth 
size must 	showing tag 
multiple greater 	pointing commit pointed 
equal mexp 	tag uninteresting 
note memalign 	limited path means 
posix memalign 	see usual 
available 	commits touch paths 
aligned memory 	plus tagged 
mac osx 	commit specifying simplify 
doesn functions 	decoration pathspec 
malloc osx 	must called immediately 
returns pointer 	removing nth 
aligned 	parent commit parent 
memory block 	list maintaining 
function generates 	per parent treesame 
pseudorandom bit 	decoration recalculate 
integers specified 	master treesame 
one call 	flag update treesame 
number 	called update 
pseudorandom integers 	sequence treesame modifications 
specified argument 	may affected 
size must 	removed parent non 
least multiple 	merge different 
two generation 	handling lack decoration 
function 	become non 
much faster 	merge commit update 
following gen 	treesame immediately 
rand function 	longer needed decoration 
initialization init 	still merge 
gen rand 	defer update update 
init 	treesame treesame 
must called 	irrelevant unless prune 
first call 	dense simplify 
function function 	history mixture 
used calling 	treesame treesame interesting 
gen rand 	parents treesame 
function 	decoration anyway first 
without initialization 	parent treesame 
param pseudorandom 	flag locked first 
bit integers 	parent lack 
filled function 	treesame decoration pruning 
pointer must 	everything interesting 
aligned 	normal non merge 
namely must 	commit want 
multiple simd 	make history dense 
version since 	consider always 
refers address 	change second loop 
bit integer 	iteration know 
standard 	dealing merge compare 
version pointer 	later parents 
arbitrary param 	care first parent 
size number 	chain order 
bit pseudorandom 	avoid derailing 
integers generated 	traversal follow side 
size 	branch brought 
must multiple 	everything path limited 
greater equal 	pathspec remain 
mexp note 	potentially simplifiable merge 
memalign posix 	remember per 
memalign available 	parent treesame needed 
aligned 	initialise comparison 
memory mac 	first iteration even 
osx doesn 	merge uninteresting 
functions malloc 	side branch brought 
osx returns 	entire change 
pointer aligned 	interested want lose 
memory 	branches merge 
block function 	keep going adding 
initializes state 	specified paths 
bit integer 	parent history beyond 
seed param 	parent interesting 
seed bit 	parents grandparents 
integer 	iow pretend parent 
used seed 	root commit 
function initializes 	fallthrough treesame straightforward 
state bit 	single parent 
integers used 	commits merge commits 
seeds param 	useful define 
init 	irrelevant parents cannot 
key bit 	make treesame 
integers used 	relevant parents consider 
seed param 	treesam eness 
key length 	respect allowing irrelevant 
length init 	merges uninteresting 
key 	branches simplified away 
file derives 	irrelevant parents 
sfmt http 	treesame note logic 
www math 	replicated update 
sci hiroshima 	treesame kept sync 
mat sfmt 	commit uninteresting 
index 	prune parents 
html released 	want maximal uninteresting 
terms following 	normally haven 
license copyright 	parsed parent yet 
mutsuo saito 	won parent 
makoto matsumoto 	parent however may 
hiroshima 	turn reached 
university rights 	commit way wasn 
reserved redistribution 	uninteresting need 
use source 	mark parents recursively 
binary forms 	commit wasn 
without modification 	uninteresting simplify commit 
permitted 	history find 
provided following 	parent differences path 
conditions met 	one exists 
redistributions source 	first count commits 
code must 	left right 
retain copyright 	compute patch ids 
notice 	one side 
list conditions 	fewer left 
following disclaimer 	left first omit 
redistributions binary 	commits right 
form must 	branch loop fewer 
reproduce copyright 	right skip 
notice 	left ones either 
list conditions 	cherry mark 
following disclaimer 	cherry pick check 
documentation materials 	side fewer 
provided distribution 	left left first 
neither name 	omit commits 
hiroshima 	left branch loop 
university names 	seen patch 
contributors may 	check original side 
used endorse 	seen ones 
promote products 	many extra uninteresting 
derived software 	commits want 
without 	see source 
specific prior 	list definitely done 
written permission 	destination list 
software provided 	contain entries date 
copyright holders 	source list 
contributors express 	definitely done source 
implied 	list still 
warranties including 	interesting commits definitely 
limited implied 	done closing 
warranties merchantability 	rev list ancestry 
fitness particular 	path computes 
purpose disclaimed 	commits ancestors ancestors 
shall 	limits result 
copyright owner 	descendants takes list 
contributors liable 	bottom commits 
direct indirect 	result without ancestry 
incidental special 	path limits 
exemplary consequential 	latter ones reach 
damages 	one commits 
including limited 	bottom reverse 
procurement substitute 	list likely would 
goods services 	process parents 
loss use 	children mark ones 
data profits 	reach bottom 
business 	commits list bottom 
interruption however 	fashion needswork 
caused theory 	decide want parents 
liability whether 	marked tmp 
contract strict 	mark commit parents 
liability tort 	commits resulting 
including 	list may want 
negligence otherwise 	though ones 
arising way 	marked tmp mark 
use software 	uninteresting done 
even advised 	tmp mark walking 
possibility damage 	history keep 
init 	negative refs caller 
gen rand 	asked exclude 
expected init 	used compute 
expected init 	rev list ancestry 
gen rand 	path need 
expected init 	filter result ones 
expected 	actually reach 
jemalloc attr 	assumes either left 
jemalloc attr 	right revs 
ctx jemalloc 	left showing whole 
attr jemalloc 	pending list 
attr ini 	end check commits 
ctx 	become treesame 
jemalloc attr 	parents becoming uninteresting 
jemalloc attr 	entry refs 
ctx jemalloc 	cmdline specified information 
attr jemalloc 	name copied 
attr ini 	cmdlineflags counting terminating 
ctx 	range pathspec 
min size 	parent directory find 
init gen 	merge bases 
rand fill 	two pseudo 
fill fini 	revision arguments accept 
gen rand 	digit like 
init 	traditional head fallthrough 
gen rand 	needs limit 
gen rand 	list detached form 
gen rand 	pretty opposed 
fini gen 	pretty allowed since 
rand min 	argument optional 
size 	strdup ing trick 
init fill 	list free 
fill fini 	ing grepping commit 
gen rand 	log note 
init gen 	commands like git 
rand gen 	shortlog accept 
rand 	options unless parse 
fini gen 	revision opt 
rand min 	queues opposed 
size init 	erroring implementing pseudo 
gen rand 	option remember 
fill fill 	list top handle 
fini 	revision opt 
gen rand 	detached form walk 
init gen 	opposed walk 
rand gen 	allowed since argument 
rand gen 	optional parse 
rand fini 	revision information filling 
gen 	rev info 
rand min 	structure removing used 
size init 	arguments argument 
fill fill 	list returns number 
fini gen 	arguments left 
rand init 	weren recognized also 
gen 	moved head 
rand gen 	argument list first 
rand fini 	search second 
gen rand 	deal arguments 
test file 	options didn filenames 
derives sfmt 	must exist 
http 	rev args must 
www math 	interpretable valid 
sci hiroshima 	filename latter main 
mat sfmt 	loop need 
index html 	introduce magic lone 
released terms 	means pathspec 
following 	whatsoever place prune 
license copyright 	data strcmp 
mutsuo saito 	prune data prune 
makoto matsumoto 	data prune 
hiroshima university 	data alloc free 
rights reserved 	prune data 
redistribution 	path prune data 
use source 	path terminate 
binary forms 	prune data alloc 
without modification 	call init 
permitted provided 	pathspec revs 
following conditions 	prune data user 
met 	ask diff 
redistributions source 	output run diff 
code must 	pickaxe diff 
retain copyright 	filter rename following 
notice list 	need diffs 
conditions following 	prune commits rename 
disclaimer 	following paths 
redistributions binary 	change limitations graph 
form must 	functionality examine 
reproduce copyright 	existing parents marking 
notice list 	ones seen 
conditions following 	clear temporary mark 
disclaimer 	update treesame 
documentation materials 	removing duplicates affect 
provided distribution 	treesame want 
neither name 	sanity checking ready 
hiroshima university 	items yet 
names contributors 	mark output 
may 	reduce heads reduce 
used endorse 	heads outputs 
promote products 	reduced original order 
derived software 	isn hard 
without specific 	awkward naming means 
prior written 	one parent 
permission 	treesame mark treesame 
software provided 	root parents 
copyright holders 	root parents treesame 
contributors express 	empty better 
implied warranties 	name suggestions treesame 
including limited 	marked deletion 
implied 	parent unmarked parents 
warranties merchantability 	unmark first 
fitness particular 	treesame parent parent 
purpose disclaimed 	simplify history 
shall copyright 	scan would 
owner contributors 	followed doesn make 
liable 	sense omit 
direct indirect 	path asking simplified 
incidental special 	full history 
exemplary consequential 	retaining improves chances 
damages including 	understanding odd 
limited procurement 	missed merges took 
substitute 	old version 
goods services 	file example modified 
loss use 	file mainline 
data profits 	merge used took 
business interruption 	version treesame 
however caused 	treesame log would 
theory 	produce without 
liability whether 	check full history 
contract strict 	simplify merges 
liability tort 	would produce showing 
including negligence 	merge commit 
otherwise arising 	changed making 
way 	clear taken version 
use software 	check topology 
even advised 	retained note possible 
possibility damage 	simplification chooses 
file sfmt 	different treesame parent 
brief simd 	test doesn 
oriented 	activate drop parent 
fast mersenne 	example modified 
twister sfmt 	file reverted meaning 
author mutsuo 	mainline merge 
saito hiroshima 	treesame parents log 
university author 	would produce 
makoto 	following first parent 
matsumoto hiroshima 	full history 
university copyright 	simplify merges produce 
mutsuo saito 	reasonable result 
makoto matsumoto 	presents logical full 
hiroshima university 	history leading 
rights 	important merge 
reserved bsd 	removing parents increase 
license applied 	treesam eness 
software see 	handled one uninteresting 
license txt 	commit simplifies 
bit 	root commit rewrite 
simd data 	parents commit 
type altivec 	anyway know commit 
sse standard 	parents matter 
bit data 	rewritten otherwise ready 
structure bit 	rewrite one 
data 	yet rewrite list 
type bit 	parents note 
data structure 	cannot affect treesame 
bit data 	flags way 
type bit 	commit always treesame 
data structure 	simplification possible 
bit 	merge one side 
data type 	branch commit 
bit state 	touches given 
index counter 	paths immediate parent 
bit state 	branch rewritten 
flag state 	merge commit looking 
yet 	commit touches 
initialized file 	paths merge independent 
variables state 	branch doesn 
index counter 	touch path reduce 
flag parity 	treesame root 
check vector 	parent commit looking 
certificate 	commit touches 
period mexp 	paths root commit 
functions function 	touching paths 
simulate bit 	detect simplify cases 
index little 	commit simplifies 
endian big 	root uninteresting touches 
endian 	given paths 
machine function 	merge parents simplify 
simulates simd 	one relevant 
bit right 	commit first 
shift standard 	two cases already 
bit integer 	handled beginning 
given 	function otherwise simplifies 
shifted shift 	sole relevant 
bits function 	parent simplifies feed 
simulates little 	list reversed 
endian simd 	free list yet 
param output 	original list 
function 	used later function 
param bit 	clean result 
data shifted 	removing simplified ones 
param shift 	signal whether 
shift function 	need per parent 
simulates simd 	treesame decoration 
bit 	prepend fake headers 
left shift 	needed grep 
standard bit 	user output 
integer given 	encoding assumption encoding 
shifted shift 	likely write 
bits function 	grep pattern addition 
simulates 	means match 
little endian 	notes encoding end 
simd param 	buffer two 
output function 	different encodings copy 
param bit 	commit temporary 
data shifted 	fake headers append 
param 	fake message 
shift shift 	parts needed find 
function represents 	either original 
recursion formula 	commit message temporary 
param output 	note cast 
param bit 	away constness message 
part 	may come 
state param 	cached commit buffer 
bit part 	know modifiable 
state param 	heap memory 
bit part 	grep buffer may 
state param 	modify speed 
bit 	restore changes returning 
part state 	commit without 
function fills 	changes drop merges 
state pseudorandom 	unless want 
integers function 	parenthood want ancestry 
fills user 	need keep 
specified 	merges relevant commits 
pseudorandom integers 	tie together 
param bit 	topology consistency treesame 
filled pseudorandom 	simplification use 
numbers param 	relevant rather interesting 
size number 	treat bottom 
bit 	commit part topology 
pseudorandom numbers 	may call 
generated function 	save parents per 
represents function 	commit non 
used initialization 	root commits 
init param 	walking reflogs may 
bit 	visit commit 
integer bit 	several times appearance 
integer function 	reflog save 
represents function 	parents called multiple 
used initialization 	times want 
init param 	keep first parents 
bit 	need store 
integer bit 	sentinel empty parent 
integer function 	list distinguish 
certificate period 	yet saved list 
mexp check 	however full 
check modification 	diff simplified parents 
functions 	good show 
function returns 	spurious changes commits 
identification shows 	elided save 
word size 	parents side full 
mersenne exponent 	diff effect 
parameters generator 	first commit 
function 	haven done list 
returns minimum 	limiting need 
size used 	look parents also 
fill function 	need date 
minimum size 	limiting otherwise done 
used fill 	limit list 
function 	entries yet shown 
function returns 	func verge 
minimum size 	realloc garbage collect 
used fill 	entries already 
function minimum 	shown free space 
size used 	revs commits 
fill 	non point error 
function function 	occurred revision 
generates returns 	ignore error printing 
bit pseudorandom 	boundary commits 
number init 	anyway code 
gen rand 	always done put 
init 	actual boundary 
must called 	commits revs boundary 
function bit 	commits revs 
pseudorandom number 	commits revs topo 
generate random 	order sort 
integer limit 	boundary commits topological 
function 	order normal 
generates returns 	commits already returned 
bit pseudorandom 	returning boundary 
number init 	commits create boundary 
gen rand 	commit list 
init must 	populated revs commits 
called 	remaining commits 
function function 	max count counter 
gen rand 	reached zero 
called gen 	done simply still 
rand unless 	might need 
initialization executed 	show boundary 
bit 	commits want avoid 
pseudorandom number 	calling revision 
generate random 	might considerable amount 
integer limit 	work finding 
function generates 	next commit away 
pseudorandom bit 	non zero 
integers 	either max count 
specified one 	still counting 
call number 	decrement revision runs 
pseudorandom integers 	commits done 
specified argument 	computing boundaries boundary 
size must 	commits output 
least 	mode update revs 
multiple four 	commits contain 
generation function 	list boundary commits 
much faster 	boundary commits 
following gen 	commits parents ones 
rand function 	got revision 
initialization 	returned revision 
init gen 	returning need mark 
rand init 	parents could 
must called 	boundaries revision.h alloc 
first call 	item name 
function function 	flags commits pending 
used 	boundary commits 
calling gen 	cmdline excludes prefix 
rand function 	def prune 
without initialization 	data date mode 
param pseudorandom 	abbrev loginfo 
bit integers 	total mime boundary 
filled 	patch suffix 
function pointer 	numbered files reroll 
must aligned 	count message 
namely must 	ident message ids 
multiple simd 	signoff extra 
version since 	headers log reencode 
refers 	subject prefix 
address bit 	show log 
integer standard 	size mailmap grep 
version pointer 	filter invert 
arbitrary param 	grep graph skip 
size number 	count max 
bit 	count max age 
pseudorandom integers 	min age 
generated size 	min parents max 
must multiple 	parents commit 
greater equal 	include check data 
mexp note 	diffopt pruning 
memalign 	reflog info children 
posix memalign 	merge simplification 
available aligned 	treesame notes opt 
memory mac 	count left 
osx doesn 	count right count 
functions malloc 	line log 
osx 	data saved 
returns pointer 	parents slab previous 
aligned memory 	parents bar 
block function 	list path list 
generates pseudorandom 	list exclude 
bit integers 	show early output 
specified 	def rev 
one call 	info setup revision 
number pseudorandom 	opt submodule 
integers specified 	dashdash revarg opt 
argument size 	revs prefix 
must least 	argc argv revs 
multiple 	setup revision 
two generation 	opt revs ctx 
function much 	options usagestr 
faster following 	arg revs flags 
gen rand 	revarg opt 
function initialization 	revs revs revs 
init 	commit revs 
gen rand 	commit commit 
init must 	path name revs 
called first 	obj name 
call function 	revs name sha 
function used 	flags rev 
calling 	info rev info 
gen rand 	flags rev 
function without 	info flags revs 
initialization param 	commit rewrite 
pseudorandom bit 	parent revs commit 
integers filled 	remember update 
function 	flag allocation isolated 
pointer must 	cases clean 
aligned namely 	use parents already 
must multiple 	parsed added 
simd version 	starting list parents 
since refers 	shown commits 
address 	end points specified 
bit integer 	end user 
standard version 	excluding branches 
pointer arbitrary 	refs etc expansion 
param size 	basic information 
number bit 	topo sort traversal 
pseudorandom 	flags diff 
integers generated 	flags format info 
size must 	show linear 
multiple greater 	filter commit log 
equal mexp 	message negate 
note memalign 	match grep filter 
posix 	display history 
memalign available 	graph special limits 
aligned memory 	diff info 
mac osx 	patches paths limiting 
doesn functions 	notes specific 
malloc osx 	options refs show 
returns 	commit counts 
pointer aligned 	line level range 
memory block 	chasing copies 
function initializes 	parent lists 
state bit 	full diff display 
integer seed 	files files 
param 	removed mixed changes 
seed bit 	revision log 
integer used 	machinery saves original 
seed function 	parent list 
initializes state 	saved parents later 
bit integers 	tell real 
used 	parents commits commit 
seeds param 	parents modified 
init key 	history simpification saved 
bit integers 	parents transparently 
used seed 	commit parents history 
param key 	simplification rm.c 
length 	builtin usage alloc 
length init 	name submodule 
key file 	path pos files 
derives sfmt 	list main 
http www 	msg hints 
math sci 	msg errs err 
hiroshima 	msg files 
mat sfmt 	errs errs files 
index html 	name pos 
released terms 	head index head 
following license 	errs files 
copyright mutsuo 	staged files cached 
saito 	files submodule 
makoto matsumoto 	files local pos 
hiroshima university 	name sha 
rights reserved 	mode local changes 
redistribution use 	staged changes 
source binary 	file quiet ignore 
forms 	unmatch builtin 
without modification 	options argc argv 
permitted provided 	prefix pathspec 
following conditions 	seen original 
met redistributions 	seen sha path 
source code 	gitmodules modified 
must 	path buf strcmp 
retain copyright 	stage strbuf 
notice list 	addstr strbuf addf 
conditions following 	strbuf addstr 
disclaimer redistributions 	error strbuf release 
binary form 	print error 
must 	files list clear 
reproduce copyright 	cache name 
notice list 	pos strlen cache 
conditions following 	pos isgitlink 
disclaimer documentation 	file exists empty 
materials provided 	dir submodule 
distribution 	uses gitfile list 
neither name 	append error 
hiroshima university 	removing concrete submodules 
names contributors 	sha cache 
may used 	name pos 
endorse promote 	strlen cache pos 
products 	isgitlink empty 
derived software 	dir lstat warning 
without specific 	strerror isdir 
prior written 	isgitlink match stat 
permission software 	isgitlink submodule 
provided copyright 	entry create mode 
holders 	hashcmp intent 
contributors express 	list append list 
implied warranties 	append isgitlink 
including limited 	submodule uses gitfile 
implied warranties 	list append 
merchantability fitness 	list append print 
particular 	error files 
purpose disclaimed 	list clear print 
shall copyright 	error files 
owner contributors 	list clear error 
liable direct 	removing concrete 
indirect incidental 	submodules print 
special 	error files list 
exemplary consequential 	clear gitmodules 
damages including 	config git config 
limited procurement 	parse options 
substitute goods 	usage options setup 
services loss 	work hold 
use 	locked index read 
data profits 	cache die 
business interruption 	parse pathspec refresh 
however caused 	index xcalloc 
theory liability 	path match alloc 
whether contract 	grow xstrdup 
strict 	isgitlink staging gitmodules 
liability tort 	die die 
including negligence 	die exit sha 
otherwise arising 	hashclr check 
way use 	local mod exit 
software even 	check submodules 
advised 	use gitfiles 
possibility damage 	exit file cache 
SFMT.c sfmt 	die empty 
idx initialized 	dir rmdir path 
parity shift 	gitmodules strbuf 
shift ctx 	addstr dir recursively 
ctx 	path gitmodules 
size ctx 	strbuf release file 
size shift 	exists path 
shift shift 	gitmodules strbuf release 
shift ctx 	path die 
ctx size 	errno stage updated 
size 	gitmodules write 
ctx inner 	locked index die 
work psfmt 	git builtin 
ctx psfmt 	command copyright linus 
ctx limit 	torvalds items 
ret ctx 	list already 
psfmt 	sorted cache order 
psfmt ctx 	could lot 
limit ret 	efficiently desc traversal 
ctx size 	wanted lazy 
ctx size 	cares removal files 
seed ctx 	tad slower 
psfmt 	theoretical maximum speed 
init key 	skip unmerged 
key length 	entries populated submodules 
ctx count 	could lose 
lag mid 	history removed already 
size psfmt 	vanished working 
ctx 	file removed directory 
lshift rshift 	enoent far 
lshift rshift 	git concerned track 
recursion recursion 	directories unless 
recursion recursion 	submodules path changes 
recursion recursion 	need treated 
idxof 	carefully allow 
idxof gen 	losing local changes 
rand gen 	accidentally local 
rand gen 	change could file 
rand kqu 	work different 
kqu gen 	since index user 
rand 	staged content 
gen rand 	different current commit 
gen rand 	index would 
swap posix 	need force removal 
memalign idxof 	however cached 
idxof idxof 	index safe index 
idxof 	matches file 
period certification 	work head commit 
posix memalign 	means content 
memset func 	removed available elsewhere 
idxof idxof 	index different 
idxof idxof 	file work submodule 
idxof 	work modified 
idxof func 	index different 
idxof idxof 	head commit definition 
idxof idxof 	initial commit 
idxof idxof 	anything staged index 
func idxof 	treated way 
idxof 	changed head index 
idxof idxof 	match file 
idxof idxof 	work match head 
func idxof 	commit either 
idxof idxof 	git without cached 
idxof idxof 	definitely lose 
idxof 	information git cached 
period certification 	lose information 
free file 	unless removing intent 
derives sfmt 	entry forced 
http www 	file index head 
math sci 	exists must 
hiroshima 	match file already 
mat sfmt 	removed since 
index html 	sequence natural 
released terms 	novice way git 
following license 	head commit 
copyright mutsuo 	exists diff index 
saito 	cached must 
makoto matsumoto 	report changes unless 
hiroshima university 	forced first 
rights reserved 	names index won 
redistribution use 	commit index 
source 	unless succeed unless 
binary forms 	used cached 
without modification 	filenames workspace fail 
permitted provided 	first one 
following conditions 	abort git successfully 
met redistributions 	removed file 
source 	ahead commit already 
code must 	committed fail 
retain copyright 	middle submodule 
notice list 	removed user fallthrough 
conditions following 	path fail 
disclaimer redistributions 	run-command.c child child 
binary 	pid next 
form must 	children clean installed 
reproduce copyright 	child cleanup 
notice list 	handler sig signal 
conditions following 	sig pid 
disclaimer documentation 	pid clean file 
materials 	buf end 
provided distribution 	file file argv 
neither name 	argv argv 
hiroshima university 	nargv child notifier 
names contributors 	flags pid 
may used 	argv signal status 
endorse 	code waiting 
promote products 	failed errno cmd 
derived software 	need need 
without specific 	need err 
prior written 	fdin fdout fderr 
permission software 	failed errno 
provided 	str notify pipe 
copyright holders 	child err 
contributors express 	fherr sargv nargv 
implied warranties 	cmd ret 
including limited 	cmd cmd code 
implied warranties 	argv opt 
merchantability 	argv opt dir 
fitness particular 	env cmd 
purpose disclaimed 	main main key 
shall copyright 	die counter 
owner contributors 	data ret err 
liable direct 	ret code 
indirect 	alloc git atexit 
incidental special 	installed handler 
exemplary consequential 	process code need 
damages including 	need fdin 
limited procurement 	fdout proc 
substitute goods 	proc err ret 
services 	name path 
loss use 	env name args 
data profits 	hook env 
business interruption 	name args ret 
however caused 	cmd buf 
theory liability 	hint data max 
whether 	processes processes 
contract strict 	next task start 
liability tort 	failure task 
including negligence 	finished process err 
otherwise arising 	data pfd 
way use 	output owner buffered 
software 	output err 
even advised 	task result err 
possibility damage 	task signo 
file sfmt 	signal signo next 
brief simd 	task start 
oriented fast 	failure task 
mersenne 	finished data code 
twister sfmt 	output timeout 
author mutsuo 	code result next 
saito hiroshima 	task start 
university author 	failure task finished 
makoto matsumoto 	code output 
hiroshima 	timeout spawn cap 
university copyright 	memset argv 
mutsuo saito 	init argv init 
makoto matsumoto 	argv clear 
hiroshima university 	argv clear kill 
rights reserved 	free cleanup 
bsd 	children sigchain pop 
license applied 	cleanup children 
software see 	xmalloc atexit sigchain 
license txt 	push common 
bit simd 	free close close 
data type 	open die 
altivec 	errno dup 
sse standard 	die errno close 
bit data 	getenv strchrnul 
structure bit 	strbuf reset strbuf 
data type 	strbuf addch 
bit data 	strbuf addstr access 
structure 	strbuf detach 
bit data 	strbuf release locate 
type bit 	path free 
data structure 	execvp strchr exists 
bit data 	path strchr 
type bit 	die strcspn strlen 
state 	argv push 
index counter 	argv push argv 
bit state 	push argv 
flag state 	push argv pushf 
yet initialized 	argv pushv 
file variables 	prepare shell 
state 	cmd trace argv 
index counter 	sane execvp 
flag parity 	argv clear xwrite 
check vector 	fcntl fcntl 
certificate period 	waitpid error strerror 
mexp functions 	error wifsignaled 
function 	wtermsig error wifexited 
simulate bit 	wexitstatus error 
index little 	clear child cleanup 
endian big 	pipe close 
endian machine 	pipe close pair 
function simulates 	close pipe 
simd 	close pair close 
bit right 	close pair 
shift standard 	close error strerror 
bit integer 	child process 
given shifted 	clear trace argv 
shift bits 	fflush pipe 
function 	fork dup 
simulates little 	cloexec error handle 
endian simd 	fdopen close 
param output 	cloexec atexit dup 
function param 	devnull dup 
bit data 	close pair dup 
shifted 	close dup 
param shift 	devnull dup close 
shift function 	pair dup 
simulates simd 	close dup devnull 
bit left 	dup dup 
shift standard 	close pair dup 
bit 	close chdir 
integer given 	die errno strchr 
shifted shift 	putenv unsetenv 
bits function 	execv git cmd 
simulates little 	execv shell 
endian simd 	cmd sane execvp 
param 	error strerror 
output function 	exit die 
param bit 	errno error strerror 
data shifted 	mark child 
param shift 	cleanup close read 
shift function 	wait whine 
represents 	close open dup 
recursion formula 	dup open 
param output 	dup dup open 
param bit 	dup dup 
part state 	dup prepare git 
param bit 	cmd prepare 
part 	shell cmd mingw 
state param 	spawnvpe error 
bit part 	strerror mark child 
state param 	cleanup argv 
bit part 	clear close close 
state function 	close close 
fills 	pair close close 
state pseudorandom 	pair close 
integers function 	close pair 
fills user 	close child process 
specified pseudorandom 	clear close 
integers param 	close close close 
bit 	close close 
filled pseudorandom 	wait whine child 
numbers param 	process clear 
size number 	wait whine die 
bit pseudorandom 	start command 
numbers generated 	finish command run 
function 	command opt 
represents function 	env run command 
used initialization 	pthread setspecific 
init param 	proc vreportf pthread 
bit integer 	getspecific close 
bit integer 	close pthread exit 
function 	exit pthread 
represents function 	getspecific pthread 
used initialization 	setspecific pthread equal 
init param 	pthread self 
bit integer 	pthread exit free 
bit integer 	memset alloc 
function 	grow atexit exit 
certificate period 	pipe close 
mexp check 	error strerror pipe 
check modification 	close pair 
functions function 	close error strerror 
returns identification 	fflush fork 
shows 	error strerror close 
word size 	close git 
mersenne exponent 	atexit clear exit 
parameters generator 	proc mark 
function returns 	child cleanup close 
minimum size 	close close 
used 	close pthread self 
fill function 	pthread key 
minimum size 	create pthread 
used fill 	key create die 
function function 	routine die 
returns minimum 	recursing routine cloexec 
size 	cloexec pthread 
used fill 	create error strerror 
function minimum 	close pair 
size used 	close close pair 
fill function 	close wait 
function generates 	whine pthread error 
returns 	strbuf reset 
bit pseudorandom 	strbuf git path 
number init 	access find 
gen rand 	hook argv push 
init must 	arg argv 
called function 	push run command 
bit 	start run 
pseudorandom number 	hook end start 
generate random 	command strbuf 
integer limit 	read close 
function generates 	finish command close 
returns bit 	finish command 
pseudorandom 	kill kill children 
number init 	sigchain pop 
gen rand 	online cpus trace 
init must 	die xcalloc 
called function 	xcalloc strbuf init 
function gen 	strbuf init 
rand 	child process init 
called gen 	sigchain push 
rand unless 	common trace strbuf 
initialization executed 	release child 
bit pseudorandom 	process clear free 
number generate 	free fputs 
random 	strbuf release sigchain 
integer limit 	pop common 
function generates 	die next task 
pseudorandom bit 	strbuf addbuf 
integers specified 	strbuf reset 
one call 	start command start 
number 	failure strbuf 
pseudorandom integers 	addbuf strbuf reset 
specified argument 	poll cleanup 
size must 	die errno strbuf 
least multiple 	read close 
four generation 	die errno fputs 
function 	strbuf reset 
much faster 	finish command task 
following gen 	finished child 
rand function 	process init strbuf 
initialization init 	addbuf strbuf 
gen rand 	reset fputs strbuf 
init 	reset fputs 
must called 	strbuf reset init 
first call 	start one 
function function 	kill children 
used calling 	buffer stderr output 
gen rand 	collect finished 
function 	kill children cleanup 
without initialization 	posix specifies 
param pseudorandom 	empty entry current 
bit integers 	directory cannot 
filled function 	happen command found 
pointer must 	one directories 
aligned 	listed path unsearchable 
namely must 	execvp reports 
multiple simd 	eacces careful usability 
version since 	testing read 
refers address 	analysis occasional bug 
bit integer 	reports reveals 
standard 	file directory intuitive 
version pointer 	avoid commands 
arbitrary param 	execvp path lookups 
size number 	reassignment eacces 
bit pseudorandom 	errno looks 
integers generated 	like need protect 
size 	exists path 
must multiple 	overwriting errno extra 
greater equal 	arguments even 
mexp note 	need bother magic 
memalign posix 	execvp failed 
memalign available 	possible like start 
aligned 	command know 
memory mac 	failures like enoent 
osx doesn 	handled right 
functions malloc 	away otherwise finish 
osx returns 	command still 
pointer aligned 	report error nothing 
memory 	chosen code 
block function 	xff mimics exit 
generates pseudorandom 	code posix 
bit integers 	shell would report 
specified one 	program died 
call number 	signal convert 
pseudorandom 	special exit code 
integers specified 	execvp failed 
argument size 	errors must keep 
must least 	promise close 
multiple two 	passed via redirect 
generation function 	channel write 
much 	syscall error messages 
faster following 	redirecting process 
gen rand 	stderr die subsequent 
function initialization 	call paths 
init gen 	use parent stderr 
rand init 	wait child 
must 	execvp execvp succeeds 
called first 	fork failed 
call function 	eof seen immediately 
function used 	parent otherwise 
calling gen 	child process sends 
rand function 	single note 
without 	use infrastructure 
initialization param 	completely advisory therefore 
pseudorandom bit 	keep error 
integers filled 	checks minimal point 
function pointer 	know fork 
must aligned 	succeeded execvp failed 
namely 	errors reported 
must multiple 	stderr asyncs started 
simd version 	yet flush 
since refers 	stdio fork avoid 
address bit 	cloning buffers 
integer standard 	first time start 
version 	called main 
pointer arbitrary 	away exit code 
param size 	pollfd logically 
number bit 	part children system 
pseudorandom integers 	call expects 
generated size 	finished children next 
must 	task added 
multiple greater 	messages buffer 
equal mexp 	last iteration buffered 
note memalign 	output non 
posix memalign 	empty returns task 
available aligned 	started jobs 
memory 	started next task 
mac osx 	ran work 
doesn functions 	non critical problem 
malloc osx 	starting command 
returns pointer 	job started user 
aligned memory 	wishes shutdown 
block 	early use negative 
function initializes 	code signal 
state bit 	children buffer output 
integer seed 	pipes output 
param seed 	finished child processes 
bit integer 	pick next 
used 	process output 
seed function 	live needswork pick 
initializes state 	randomly round 
bit integers 	robin later may 
used seeds 	want pick 
param init 	one output longest 
key 	shortest running 
bit integers 	process time run-command.h 
used seed 	argv args 
param key 	env pid err 
length length 	dir env 
init key 	child process child 
file 	process child 
derives sfmt 	process child process 
http www 	child process 
math sci 	child process name 
hiroshima mat 	env name 
sfmt index 	env name args 
html 	argv opt 
released terms 	argv opt 
following license 	dir env cmd 
copyright mutsuo 	buf hint 
saito makoto 	data data pid 
matsumoto hiroshima 	tid proc 
university 	proc code err 
rights reserved 	specify redirections 
redistribution use 	child inherits stdin 
source binary 	stdout stderr 
forms without 	parent specify pipe 
modification permitted 	allocated follows 
provided 	returns writable pipe 
following conditions 	end parent 
met redistributions 	writes readable pipe 
source code 	end becomes 
must retain 	child stdin err 
copyright notice 	returns readable 
list 	pipe end parent 
conditions following 	reads writable 
disclaimer redistributions 	pipe end 
binary form 	becomes child stdout 
must reproduce 	stderr caller 
copyright notice 	start command must 
list 	close returned 
conditions following 	completed reading writing 
disclaimer documentation 	specify channel 
materials provided 	particular follows readable 
distribution neither 	becomes child 
name hiroshima 	stdin writable becomes 
university 	child stdout 
names contributors 	stderr err writable 
may used 	becomes child 
endorse promote 	stderr specified closed 
products derived 	start command 
software without 	even errors git 
specific 	sub command 
prior written 	returns path hook 
permission software 	file hook 
provided copyright 	missing disabled 
holders contributors 	note points storage 
express implied 	overwritten calls 
warranties 	find hook run 
including limited 	hook git 
implied warranties 	sub command env 
merchantability fitness 	environment formatted 
particular purpose 	like environ unset 
disclaimed shall 	environment variable 
copyright 	use execute given 
owner contributors 	command capturing 
liable direct 	stdout given strbuf 
indirect incidental 	returns starting 
special exemplary 	command fails reading 
consequential damages 	fails otherwise 
including 	returns exit code 
limited procurement 	command output 
substitute goods 	collected buffer 
services loss 	kept even command 
use data 	returns non 
profits business 	zero exit hint 
interruption 	field gives 
however caused 	starting size strbuf 
theory liability 	allocation fields 
whether contract 	cmd would normal 
strict liability 	run command 
tort including 	invocation note need 
negligence 	cmd function 
otherwise arising 	sets caller purpose 
way use 	following functions 
software even 	feed pipe running 
advised possibility 	function asynchronously 
damage init 	providing output caller 
gen 	reads expected 
rand expected 	synchronization mutual exclusion 
init expected 	caller feed 
init gen 	function necessary 
rand expected 	function run without 
init 	interfering caller 
expected jemalloc 	proc reads closes 
attr jemalloc 	proc writes 
attr ctx 	closes returns success 
jemalloc attr 	non zero 
jemalloc attr 	failure caller writes 
ini 	closes caller 
ctx jemalloc 	reads closes callback 
attr jemalloc 	initialize child 
attr ctx 	process preload error 
jemalloc attr 	channel desired 
jemalloc attr 	preloading useful want 
ini 	message printed 
ctx min 	directly output child 
size init 	process callback 
gen rand 	cookie passed run 
fill fill 	processes parallel 
fini gen 	store child 
rand 	process specific callback 
init gen 	cookie task 
rand gen 	even returning indicate 
rand gen 	processes function 
rand fini 	called running child 
gen rand 	processes next 
min 	child ready run 
size init 	currently tasks 
fill fill 	processed send signal 
fini gen 	child processes 
rand init 	abortion negative signal 
gen rand 	number callback 
gen 	called whenever problems 
rand fini 	starting process 
gen rand 	must write stdout 
min size 	stderr function 
init gen 	message strbuf err 
rand fill 	instead printed 
fill 	without messing 
fini gen 	output parallel processes 
rand init 	callback cookie 
gen rand 	passed run processes 
gen rand 	parallel task 
gen rand 	callback cookie passed 
fini 	next task 
gen rand 	parallel processing abort 
min size 	non zero 
init fill 	send signal child 
fill fini 	processes abortion 
gen rand 	negative signal number 
init 	callback called 
gen rand 	every child process 
gen rand 	finished processing 
fini gen 	must write stdout 
rand test 	stderr function 
file derives 	message strbuf 
sfmt 	err instead printed 
http www 	without messing 
math sci 	output parallel processes 
hiroshima mat 	callback cookie 
sfmt index 	passed run processes 
html released 	parallel task 
terms 	callback cookie passed 
following license 	next task 
copyright mutsuo 	parallel processing abort 
saito makoto 	non zero 
matsumoto hiroshima 	send signal child 
university rights 	processes abortion 
reserved 	negative signal number 
redistribution use 	runs processes 
source binary 	time whenever process 
forms without 	started callback 
modification permitted 	next task called 
provided following 	obtain data 
conditions 	required start 
met redistributions 	another child process 
source code 	children started 
must retain 	via function run 
copyright notice 	parallel output 
list conditions 	stdout stderr routed 
following 	stderr manner 
disclaimer redistributions 	output different tasks 
binary form 	interleave start 
must reproduce 	failure task finished 
copyright notice 	omit special 
list conditions 	handling send-pack.c opt 
following 	arg unset 
disclaimer documentation 	sha negative buf 
materials provided 	refs extra 
distribution neither 	args argv buf 
name hiroshima 	refs hint 
university names 	ret line refname 
contributors 	msg data 
may used 	ret graft 
endorse promote 	args line len 
products derived 	req buf 
software without 	remote refs args 
specific prior 	cap push 
written 	cert nonce signing 
permission software 	key cert 
provided copyright 	update seen anon 
holders contributors 	url args 
express implied 	remote refs failing 
warranties including 	nonce len 
limited 	args conn remote 
implied warranties 	refs extra 
merchantability fitness 	req buf cap 
particular purpose 	buf need 
disclaimed shall 	pack data allow 
copyright owner 	deleting refs 
contributors 	status report use 
liable direct 	sideband quiet 
indirect incidental 	supported agent 
special exemplary 	supported use atomic 
consequential damages 	atomic supported 
including limited 	cmds sent ret 
procurement 	demux push 
substitute goods 	cert nonce len 
services loss 	old hex 
use data 	hex git parse 
profits business 	maybe strcasecmp 
interruption however 	die sha file 
caused 	memcpy sha 
theory liability 	hex write whine 
whether contract 	repository shallow 
strict liability 	start command die 
tort including 	errno feed 
negligence otherwise 	oid feed oid 
arising 	feed close 
way use 	xmalloc xread send 
software even 	sideband free 
advised possibility 	close finish 
damage file 	command packet read 
sfmt brief 	line starts 
simd 	error strcmp error 
oriented fast 	packet read 
mersenne twister 	line starts starts 
sfmt author 	error strchr 
mutsuo saito 	find name find 
hiroshima university 	name warning 
author 	warning xstrdup close 
makoto matsumoto 	recv sideband 
hiroshima university 	close packet buf 
copyright mutsuo 	write oid 
saito makoto 	hex repository shallow 
matsumoto hiroshima 	commit graft 
university 	memchr xstrdup signing 
rights reserved 	key strbuf 
bsd license 	addf strbuf 
applied software 	addf datestamp strbuf 
see license 	addch transport 
txt bit 	anonymize url strbuf 
simd 	addf free 
data type 	strbuf addf strbuf 
altivec sse 	addstr check 
standard bit 	send update strbuf 
data structure 	addf oid 
bit data 	hex oid hex 
type 	sign buffer 
bit data 	die packet buf 
structure bit 	write next 
data type 	line packet buf 
bit data 	write packet 
structure bit 	buf write free 
data 	strbuf release 
type bit 	error die isalnum 
state index 	die server 
counter bit 	supports server 
state flag 	supports server supports 
state yet 	server supports 
initialized 	server supports server 
file variables 	supports server 
state index 	supports server supports 
counter flag 	server feature 
parity check 	reject invalid nonce 
vector certificate 	xmemdupz die 
period 	warning die strbuf 
mexp functions 	addstr strbuf 
function simulate 	addstr strbuf addstr 
bit index 	strbuf addstr 
little endian 	strbuf addf git 
big endian 	user agent 
machine 	sanitized advertise shallow 
function simulates 	grafts buf 
simd bit 	generate push cert 
right shift 	check send 
standard bit 	update atomic 
integer given 	push failure check 
shifted 	send update 
shift bits 	oid hex oid 
function simulates 	hex packet 
little endian 	buf write packet 
simd param 	buf write 
output function 	repository shallow packet 
param 	buf flush 
bit data 	send sideband write 
shifted param 	die packet 
shift shift 	flush strbuf release 
function simulates 	strbuf release 
simd bit 	memset start die 
left 	pack objects 
shift standard 	close git connection 
bit integer 	socket shutdown 
given shifted 	finish packet flush 
shift bits 	receive status 
function simulates 	packet flush 
little 	finish error close 
endian simd 	make pack 
param output 	stream spit file 
function param 	descriptor child 
bit data 	becomes pack objects 
shifted param 	revs feed 
shift 	revision parameters via 
shift function 	stdin stdout 
represents recursion 	back end feed 
formula param 	pack objects 
output param 	spawned revision parameters 
bit part 	writing pipe 
state 	first searching hint 
param bit 	falling back 
part state 	refs start next 
param bit 	search next 
part state 	check statuses 
param bit 	status push beginning 
part 	next line 
state function 	end buffer needswork 
fills state 	perhaps move 
pseudorandom integers 	git compat somewhere 
function fills 	convert many 
user specified 	similar uses found 
pseudorandom 	git grep 
integers param 	memchr incomplete line 
bit filled 	mark refs 
pseudorandom numbers 	failed nothing end 
param size 	support reporting 
number bit 	needswork refs specific 
pseudorandom 	send pack 
numbers generated 	machinery status push 
function represents 	cannot bit 
function used 	clear status see 
initialization init 	need send 
param bit 	pack data 
integer 	error know server 
bit integer 	would reject 
function represents 	update send trying 
function used 	send refs 
initialization init 	atomically abort whole 
param bit 	operation fallthrough 
integer 	non atomic tell 
bit integer 	end closed 
function certificate 	pack objects via 
period mexp 	start command 
check check 	mirror incompatible neither 
modification functions 	makes sense 
function 	refspecs match send 
returns identification 	pack usage 
shows word 	args buf msg 
size mersenne 	res argc 
exponent parameters 	argv prefix refspecs 
generator function 	refspecs remote 
returns 	name remote 
minimum size 	dest conn extra 
used fill 	shallow remote 
function minimum 	refs local refs 
size used 	ret helper 
fill function 	status send verbose 
function 	receivepack dry 
returns minimum 	run send mirror 
size used 	force update 
fill function 	quiet push cert 
minimum size 	use thin 
used fill 	pack atomic stateless 
function 	rpc flags 
function generates 	reject reasons progress 
returns bit 	stdin cas 
pseudorandom number 	options refspecs buf 
init gen 	line strbuf 
rand init 	reset strbuf addf 
must 	strbuf addch 
called function 	quote two 
bit pseudorandom 	style strbuf addch 
number generate 	write die 
random integer 	strbuf release git 
limit function 	gpg config 
generates 	strcmp git config 
returns bit 	git config 
pseudorandom number 	maybe strcasecmp error 
init gen 	git config 
rand init 	parse options usage 
must called 	options argv 
function 	push packet read 
function gen 	line argv 
rand called 	push strbuf getline 
gen rand 	argv push 
unless initialization 	strbuf release usage 
executed bit 	options remote 
pseudorandom 	remote url 
number generate 	die isatty git 
random integer 	connect remote 
limit function 	heads transport verify 
generates pseudorandom 	remote names 
bit integers 	local heads match 
specified 	push refs 
one call 	empty cas apply 
number pseudorandom 	push cas 
integers specified 	status push send 
argument size 	pack print 
must least 	helper status close 
multiple 	close finish 
four generation 	connect transport print 
function much 	push status 
faster following 	transport update tracking 
gen rand 	transport refs 
function initialization 	pushed make pack 
init 	stream spit 
gen rand 	file descriptor 
init must 	child becomes pack 
called first 	objects revs 
call function 	feed revision parameters 
function used 	via stdin 
calling 	stdout back end 
gen rand 	feed pack 
function without 	objects spawned revision 
initialization param 	parameters writing 
pseudorandom bit 	pipe first searching 
integers filled 	hint falling 
function 	back refs start 
pointer must 	next search 
aligned namely 	next check statuses 
must multiple 	status push 
simd version 	beginning next line 
since refers 	end buffer 
address 	needswork perhaps move 
bit integer 	git compat 
standard version 	somewhere convert 
pointer arbitrary 	many similar uses 
param size 	found git 
number bit 	grep memchr incomplete 
pseudorandom 	line mark 
integers generated 	refs failed nothing 
size must 	end support 
multiple greater 	reporting needswork refs 
equal mexp 	specific send 
note memalign 	pack machinery status 
posix 	push cannot 
memalign available 	bit clear status 
aligned memory 	see need 
mac osx 	send pack data 
doesn functions 	error know 
malloc osx 	server would reject 
returns 	update send 
pointer aligned 	trying send refs 
memory block 	atomically abort 
function generates 	whole operation 
pseudorandom bit 	fallthrough non atomic 
integers specified 	tell end 
one 	closed pack objects 
call number 	via start 
pseudorandom integers 	command mirror incompatible 
specified argument 	neither makes 
size must 	sense refspecs match 
least multiple 	send-pack.c opt 
two 	arg unset sha 
generation function 	negative buf 
much faster 	refs extra args 
following gen 	argv buf 
rand function 	refs hint ret 
initialization init 	line refname 
gen 	msg data ret 
rand init 	graft args 
must called 	line len req 
first call 	buf remote 
function function 	refs args 
used calling 	cap push cert 
gen 	nonce signing 
rand function 	key cert update 
without initialization 	seen anon 
param pseudorandom 	url args remote 
bit integers 	refs failing 
filled function 	nonce len args 
pointer 	conn remote 
must aligned 	refs extra req 
namely must 	buf cap 
multiple simd 	buf need pack 
version since 	data allow 
refers address 	deleting refs status 
bit 	report use 
integer standard 	sideband quiet supported 
version pointer 	agent supported 
arbitrary param 	use atomic 
size number 	atomic supported cmds 
bit pseudorandom 	sent ret 
integers 	demux push cert 
generated size 	nonce len 
must multiple 	old hex hex 
greater equal 	git parse 
mexp note 	maybe strcasecmp die 
memalign posix 	sha file 
memalign 	memcpy sha hex 
available aligned 	write whine 
memory mac 	repository shallow start 
osx doesn 	command die 
functions malloc 	errno feed oid 
osx returns 	feed oid 
pointer 	feed close xmalloc 
aligned memory 	xread send 
block function 	sideband free close 
initializes state 	finish command 
bit integer 	packet read 
seed param 	line starts error 
seed 	strcmp error 
bit integer 	packet read line 
used seed 	starts starts 
function initializes 	error strchr find 
state bit 	name find 
integers used 	name warning warning 
seeds 	xstrdup close 
param init 	recv sideband close 
key bit 	packet buf 
integers used 	write oid hex 
seed param 	repository shallow 
key length 	commit graft memchr 
length 	xstrdup signing 
init key 	key strbuf addf 
file derives 	strbuf addf 
sfmt http 	datestamp strbuf addch 
www math 	transport anonymize 
sci hiroshima 	url strbuf 
mat 	addf free strbuf 
sfmt index 	addf strbuf 
html released 	addstr check send 
terms following 	update strbuf 
license copyright 	addf oid hex 
mutsuo 	oid hex 
saito makoto 	sign buffer die 
matsumoto hiroshima 	packet buf 
university rights 	write next line 
reserved redistribution 	packet buf 
use source 	write packet buf 
binary 	write free 
forms without 	strbuf release error 
modification permitted 	die isalnum 
provided following 	die server supports 
conditions met 	server supports 
redistributions source 	server supports server 
code 	supports server 
must retain 	supports server 
copyright notice 	supports server supports 
list conditions 	server supports 
following disclaimer 	server feature reject 
redistributions binary 	invalid nonce 
form 	xmemdupz die warning 
must reproduce 	die strbuf 
copyright notice 	addstr strbuf addstr 
list conditions 	strbuf addstr 
following disclaimer 	strbuf addstr strbuf 
documentation materials 	addf git 
provided 	user agent sanitized 
distribution neither 	advertise shallow 
name hiroshima 	grafts buf generate 
university names 	push cert 
contributors may 	check send update 
used endorse 	atomic push 
promote 	failure check 
products derived 	send update oid 
software without 	hex oid 
specific prior 	hex packet buf 
written permission 	write packet 
software provided 	buf write repository 
copyright 	shallow packet 
holders contributors 	buf flush send 
express implied 	sideband write 
warranties including 	die packet flush 
limited implied 	strbuf release 
warranties merchantability 	strbuf release memset 
fitness 	start die 
particular purpose 	pack objects close 
disclaimed shall 	git connection 
copyright owner 	socket shutdown finish 
contributors liable 	packet flush 
direct indirect 	receive status packet 
incidental 	flush finish 
special exemplary 	error close 
consequential damages 	make pack stream 
including limited 	spit file 
procurement substitute 	descriptor child becomes 
goods services 	pack objects 
loss 	revs feed revision 
use data 	parameters via 
profits business 	stdin stdout back 
interruption however 	end feed 
caused theory 	pack objects spawned 
liability whether 	revision parameters 
contract 	writing pipe first 
strict liability 	searching hint 
tort including 	falling back refs 
negligence otherwise 	start next 
arising way 	search next check 
use software 	statuses status 
even 	push beginning next 
advised possibility 	line end 
damage SFMT.h 	buffer needswork 
ctx ctx 	perhaps move git 
limit ctx 	compat somewhere 
ctx limit 	convert many similar 
ctx 	uses found 
size ctx 	git grep memchr 
size seed 	incomplete line 
init key 	mark refs failed 
key length 	nothing end 
ctx ctx 	support reporting needswork 
ctx 	refs specific 
ctx ctx 	send pack machinery 
ctx ctx 	status push 
ctx ctx 	cannot bit clear 
ctx ctx 	status see 
real gen 	need send pack 
rand 	data error 
real gen 	know server would 
rand real 	reject update 
gen rand 	send trying 
res res 	send refs atomically 
gen rand 	abort whole 
gen 	operation fallthrough non 
rand gen 	atomic tell 
rand res 	end closed pack 
mix file 	objects via 
derives sfmt 	start command mirror 
http www 	incompatible neither 
math 	makes sense refspecs 
sci hiroshima 	match send 
mat sfmt 	pack usage args 
index html 	buf msg 
released terms 	res argc argv 
following license 	prefix refspecs 
copyright 	refspecs remote name 
mutsuo saito 	remote dest 
makoto matsumoto 	conn extra 
hiroshima university 	shallow remote refs 
rights reserved 	local refs 
redistribution use 	ret helper status 
source 	send verbose 
binary forms 	receivepack dry run 
without modification 	send mirror 
permitted provided 	force update quiet 
following conditions 	push cert 
met redistributions 	use thin pack 
source 	atomic stateless 
code must 	rpc flags reject 
retain copyright 	reasons progress 
notice list 	stdin cas options 
conditions following 	refspecs buf 
disclaimer redistributions 	line strbuf reset 
binary 	strbuf addf 
form must 	strbuf addch quote 
reproduce copyright 	two style 
notice list 	strbuf addch 
conditions following 	write die strbuf 
disclaimer documentation 	release git 
materials 	gpg config strcmp 
provided distribution 	git config 
neither name 	git config maybe 
hiroshima university 	strcasecmp error 
names contributors 	git config parse 
may used 	options usage 
endorse 	options argv push 
promote products 	packet read 
derived software 	line argv push 
without specific 	strbuf getline 
prior written 	argv push strbuf 
permission software 	release usage 
provided 	options remote remote 
copyright holders 	url die 
contributors express 	isatty git connect 
implied warranties 	remote heads 
including limited 	transport verify 
implied warranties 	remote names local 
merchantability 	heads match 
fitness particular 	push refs empty 
purpose disclaimed 	cas apply 
shall copyright 	push cas status 
owner contributors 	push send 
liable direct 	pack print helper 
indirect 	status close 
incidental special 	close finish connect 
exemplary consequential 	transport print 
damages including 	push status transport 
limited procurement 	update tracking 
substitute goods 	transport refs pushed 
services 	make pack 
loss use 	stream spit file 
data profits 	descriptor child 
business interruption 	becomes pack objects 
however caused 	revs feed 
theory liability 	revision parameters 
whether 	via stdin stdout 
contract strict 	back end 
liability tort 	feed pack objects 
including negligence 	spawned revision 
otherwise arising 	parameters writing pipe 
way use 	first searching 
software 	hint falling back 
even advised 	refs start 
possibility damage 	next search next 
file sfmt 	check statuses 
brief simd 	status push beginning 
oriented fast 	next line 
mersenne 	end buffer needswork 
twister sfmt 	perhaps move 
pseudorandom number 	git compat somewhere 
generator author 	convert many 
mutsuo saito 	similar uses found 
hiroshima university 	git grep 
author 	memchr incomplete 
makoto matsumoto 	line mark refs 
hiroshima university 	failed nothing 
copyright mutsuo 	end support reporting 
saito makoto 	needswork refs 
matsumoto hiroshima 	specific send pack 
university 	machinery status 
rights reserved 	push cannot bit 
bsd license 	clear status 
applied software 	see need send 
see license 	pack data 
txt note 	error know server 
system 	would reject 
inttypes system 	update send trying 
doesn inttypes 	send refs 
define file 	atomically abort whole 
follows verbatim 	operation fallthrough 
define llu 	non atomic 
define 	tell end closed 
llx endverbatim 	pack objects 
must exactly 	via start command 
bit integer 	mirror incompatible 
type less 	neither makes sense 
must exactly 	refspecs match 
bit 	send-pack.h url opt 
integer type 	arg unset 
used function 	args conn remote 
print bit 	refs extra 
bit hexadecimal 	possible values push 
format real 	cert field 
versions 	send pack args 
due isaku 	one send 
wada generates 	pack push cert 
random number 	constants sequencer.c 
real interval 	sign header cherry 
divided generates 	picked prefix 
random 	buf len 
number real 	sob ignore footer 
interval generates 	prev len 
random number 	buf found sob 
real interval 	found rfc 
divided generates 	seq dir opts 
random 	parent label 
number real 	label subject message 
interval generates 	commit abbrev 
random number 	subject subject len 
real interval 	commit msg 
divided generates 	show hint opts 
random 	msg msgbuf 
number real 	filename msg file 
interval real 	msg opts 
versions due 	unborn opts transaction 
isaku wada 	err msgbuf 
generates random 	next label next 
number 	label head 
bit resolution 	msgbuf opts 
generates random 	result next head 
number bit 	clean xopt 
resolution two 	index head sha 
bit integers 	head commit 
generates 	defmsg opts allow 
random number 	empty commit 
bit resolution 	ptree sha parent 
generates random 	opts commit 
number bit 	index unchanged empty 
resolution bit 	commit commit 
integer 	opts head next 
sha1.c state 	parent label 
buffer block 	next label msg 
block context 	msgbuf res 
context data 	allow cnt common 
len digest 	remotes opts 
context 	opts index index 
finalcount argc 	buf todo 
argv ctx 	list opts 
hash buf 	cur sha abbrev 
memcpy memset 	action str 
memcpy sha 	subject subject len 
transform 	commit buffer 
sha transform 	bol eol opts 
memcpy sha 	commit sha 
update sha 	end name saved 
update sha 	status padding 
update memset 	action str buf 
memset 	todo list 
unused unused 	opts next commit 
sha init 	eol todo 
sha update 	list opts buf 
sha valgrind 	res key 
tests sha 	data opts error 
sha 	flag opts 
steve reid 	ptr todo 
steve edmweb 	list opts commit 
domain test 	next head 
vectors fips 	head buf sha 
pub abc 	argv head 
abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq 	sha opts sha 
baae million 	buf todo 
repetitions daa 	list opts todo 
eeb dbad 	buf opts 
define little 	opts file buf 
endian define 	todo list 
already 	opts cur res 
define sha 	argv opts 
handsoff copies 	todo list ret 
data messing 	cmit opts 
blk blk 	opts todo list 
perform initial 	sha sha 
expand 	name cmit msgbuf 
got idea 	ignore footer 
expanding round 	flag dup 
function leay 	sob sob footer 
different operations 	append newlines 
used sha 	len strlen starts 
hash 	rfc line 
single bit 	strncmp cherry picked 
block core 	line strbuf 
algorithm use 	addf git path 
appear pointer 	dir recursively 
following better 	strbuf release logmsg 
never 	reencode commit 
used causes 	output encoding find 
pointer buffer 	unique abbrev 
cast pointer 	find commit subject 
non result 	xmemdupz xstrfmt 
written threw 	xstrfmt free free 
hoping 	free unuse 
cause diagnostic 	commit buffer getenv 
copy context 	unlink git 
state working 	path cherry 
vars rounds 	pick head advise 
operations loop 	advise hold 
unrolled 	file update write 
working vars 	full die 
back context 	errno strbuf release 
state wipe 	commit file 
variables sha 	die lookup read 
init initialize 	cache unmerged 
context 	error resolve conflict 
sha initialization 	action name 
constants run 	error error advise 
data padding 	read cache 
message digest 	checkout fast forward 
untested improvement 	exit strbuf 
dhr 	addf action name 
convert context 	transaction begin 
count sequence 	transaction update transaction 
bytes finalcount 	commit transaction 
second element 	free error 
first big 	strbuf release strbuf 
endian 	release strbuf 
order within 	release strbuf release 
element backwards 	transaction free 
endian independent 	strbuf addch strbuf 
cause sha 	commented addf 
transform wipe 	stage strbuf commented 
variables 	addf strcmp 
end sha 	hold locked index 
sha1.h state 	read cache 
buffer context 	init merge options 
context data 	parse indirect 
len digest 	empty empty parse 
context 	merge opt 
argc argv 	merge trees write 
sha sha 	locked index 
steve reid 	die action 
steve edmweb 	name rollback file 
domain size 	append signoff 
classesc 	append conflicts hint 
nhchunks mib 	resolve error 
miblen max 	lookup commit parse 
size size 	commit cache 
max size 	cache fully valid 
index max 	cache update 
index 	error hashcmp argv 
mallctl mallctlnametomib 	init argv 
mallctlbymib max 	push argv push 
size size 	argv pushf 
index size 	argv push argv 
index size 	push argv 
index 	push git config 
index size 	argv push 
size index 	argv push argv 
index size 	push run 
size index 	command opt 
size index 	argv clear parse 
index 	commit error 
size size 	oid hex parse 
index size 	commit error 
index index 	oid hex hashcmp 
size index 	index unchanged 
size size 	original commit empty 
index 	write cache 
index size 	die sha hashcpy 
index size 	index differs 
size index 	error dirty index 
index size 	discard cache 
test slowlog.c 	error oid hex 
argv 	error oid 
argc duration 	hex error oid 
slargc septr 	hex hashcmp 
argv argc 	fast forward parse 
duration sent 	commit error 
totentries zmalloc 	action name 
zmalloc 	oid hex message 
create sdscatprintf 	error oid 
sdsempty sds 	hex strbuf addstr 
encoded sdslen 	strbuf addstr 
sdsnewlen sdscatprintf 	strbuf addstr strbuf 
sdslen create 	addstr oid 
incr 	hex strbuf addstr 
count time 	strbuf addstr 
decr count 	oid hex strbuf 
zfree zfree 	addstr strstr 
list create 	strbuf addstr conforming 
list free 	footer strbuf 
method 	addch strbuf addstr 
list node 	strbuf addstr 
head slowlog 	oid hex strbuf 
create entry 	addstr strcmp 
list length 	recursive merge write 
list del 	message git 
node 	path merge 
list last 	msg write message 
list length 	git path 
list del 	merge msg commit 
node list 	list insert 
last strcasecmp 	commit list insert 
slowlog 	merge command 
reset reply 	sha hex free 
strcasecmp reply 	commit list 
list length 	free commit list 
strcasecmp reply 	update update 
list rewind 	error find unique 
deferred 	abbrev print 
multi bulk 	advice rerere allow 
length list 	empty run 
next reply 	git commit git 
multi bulk 	path merge 
len reply 	msg free message 
reply 	prepare revision 
reply reply 	walk die 
multi bulk 	die hold locked 
len reply 	index read 
bulk deferred 	index preload die 
multi bulk 	action name 
length 	refresh index write 
reply error 	locked index 
slowlog system 	die action name 
able remember 	rollback file 
latest queries 	commit buffer find 
took microseconds 	unique abbrev 
execute 	find commit subject 
execution time 	strbuf addf 
reach logged 	unuse commit buffer 
slow log 	starts strlen 
slowlog log 	starts strlen strspn 
slower 	strcspn sha 
config directive 	error action 
also readable 	name lookup commit 
writable config 	reference strchrnul 
command slow 	parse insn line 
queries log 	error commit 
actually 	list append error 
logged redis 	open git 
log file 	path todo file 
accessible thanks 	die errno 
slowlog command 	git path todo 
copyright salvatore 	file strbuf 
sanfilippo 	read close strbuf 
antirez gmail 	release die 
dot rights 	git path todo 
reserved redistribution 	file close 
use source 	parse insn buffer 
binary forms 	strbuf release 
without 	die git path 
modification permitted 	todo file 
provided following 	strcmp git 
conditions met 	config strcmp git 
redistributions source 	config strcmp 
code must 	git config strcmp 
retain 	git config 
copyright notice 	strcmp git config 
list conditions 	strcmp git 
following disclaimer 	config strcmp git 
redistributions binary 	config strcmp 
form must 	git config strcmp 
reproduce 	alloc grow 
copyright notice 	xstrdup error error 
list conditions 	file exists 
following disclaimer 	git path opts 
documentation materials 	file git 
provided distribution 	config file git 
neither 	path opts 
name redis 	file die git 
names contributors 	path opts 
may used 	file prepare 
endorse promote 	revs revision commit 
products derived 	list append 
software 	file exists git 
without specific 	path seq 
prior written 	dir error advise 
permission software 	mkdir git 
provided copyright 	path seq dir 
holders contributors 	die errno 
express 	git path seq 
implied warranties 	dir hold 
including limited 	file update git 
implied warranties 	path head 
merchantability fitness 	file strbuf addf 
particular purpose 	write full 
disclaimed 	die errno git 
shall copyright 	path head 
owner contributors 	file commit file 
liable direct 	die git 
indirect incidental 	path head 
special exemplary 	file sha hex 
consequential 	run command 
damages including 	opt file exists 
limited procurement 	git path 
substitute goods 	cherry pick head 
services loss 	file exists 
use data 	git path revert 
profits 	head error 
business interruption 	read full error 
however caused 	sha error 
theory liability 	reset rollback fopen 
whether contract 	git path 
strict liability 	head file rollback 
tort 	single pick 
including negligence 	error git path 
otherwise arising 	head file 
way use 	strerror strbuf 
software even 	getline error git 
advised possibility 	path head 
damage 	file ferror strerror 
create slowlog 	fclose fclose 
entry incrementing 	sha hex error 
count objects 	git path 
retained function 	head file reset 
logging many 	rollback sequencer 
arguments 	state strbuf release 
useless memory 	strbuf release 
waste stop 	hold file update 
slowlog entry 	git path 
max argc 	todo file format 
use last 	todo die 
argument 	git path todo 
specify many 	file write 
remaining arguments 	full strbuf release 
original command 	die errno 
trim well 	git path 
free slow 	todo file commit 
log 	file strbuf 
entry argument 	release die git 
prototype function 	path todo 
matches one 	file strbuf release 
free method 	git path 
adlist function 	opts file git 
take 	config file 
care release 	git config file 
retained initialize 	git config 
slow log 	file git config 
function called 	file git 
single time 	config file strbuf 
server 	addf git 
startup push 	config file strbuf 
entry slow 	release git 
log function 	config file git 
make sure 	config file 
trim slow 	git config 
log 	multivar file setenv 
accordingly configured 	action name 
max length 	read refresh cache 
slowlog disabled 	save todo 
old entries 	pick commit sequencer 
needed entries 	state file 
current 	exists git path 
slow log 	cherry pick 
slowlog command 	head file exists 
subcommands needed 	git path 
handle redis 	revert head error 
slow log 	run command 
slowlog.h 	opt file exists 
argv argc 	git path 
duration copyright 	todo file single 
salvatore sanfilippo 	pick read 
antirez gmail 	populate opts read 
dot rights 	populate todo 
reserved 	file exists 
redistribution use 	git path cherry 
source binary 	pick head 
forms without 	file exists git 
modification permitted 	path revert 
provided following 	head single pick 
conditions 	index differs 
met redistributions 	error dirty index 
source code 	pick commits 
must retain 	setenv action name 
copyright notice 	pick commit 
list conditions 	read refresh cache 
following 	sequencer state 
disclaimer redistributions 	sequencer rollback sequencer 
binary form 	strlen sha 
must reproduce 	lookup commit reference 
copyright notice 	gently die 
list conditions 	die prepare 
following 	revision walk die 
disclaimer documentation 	revision revision 
materials provided 	die single pick 
distribution neither 	walk revs 
name redis 	populate todo create 
names contributors 	seq dir 
may 	sha error error 
used endorse 	save head 
promote products 	sha hex save 
derived software 	opts pick 
without specific 	commits strbuf addstr 
prior written 	strbuf addstr 
permission 	fmt name getenv 
software provided 	getenv strbuf 
copyright holders 	addch strncmp conforming 
contributors express 	footer strbuf 
implied warranties 	splice strlen strbuf 
including limited 	splice strbuf 
implied 	release care 
warranties merchantability 	looks roughly like 
fitness particular 	cherry picked 
purpose disclaimed 	returns non conforming 
shall copyright 	footer returns 
owner contributors 	conforming footer returns 
liable 	sob exists 
direct indirect 	within conforming footer 
incidental special 	returns sob 
exemplary consequential 	exists within conforming 
damages including 	footer last 
limited procurement 	entry footer must 
substitute 	end newline 
goods services 	paragraph require least 
loss use 	one blank 
data profits 	line advance start 
business interruption 	last paragraph 
however caused 	nothing conflict occurred 
theory 	porcelain typically 
liability whether 	rebase interactive 
contract strict 	wants take care 
liability tort 	commit cherry 
including negligence 	pick head different 
otherwise arising 	translation cherry 
way 	pick revert callee 
use software 	complained already 
even advised 	translators revert cherry 
possibility damage 	pick head 
structure defines 	commit check commit 
entry inside 	called lookup 
slow 	commit would indicated 
log list 	head commit 
unique entry 	commit already parse 
time spent 	commit failure 
query nanoseconds 	without complaints otherwise 
unix time 	commit invalid 
query 	parse commit complain 
executed exported 	nothing say 
api exported 	failure cherry 
commands solarisfixes.h 	pick merge result 
solaris specific 	hand editing 
fixes copyright 	hit commit inherit 
salvatore 	original author 
sanfilippo antirez 	date name revert 
gmail dot 	cherry pick 
rights reserved 	results hand merge 
redistribution use 	better say 
source binary 	current user responsible 
forms 	commit root 
without modification 	run git commit 
permitted provided 	allow empty 
following conditions 	three cases allow 
met redistributions 	empty error 
source code 	allow ones initially 
must 	empty forbid 
retain copyright 	ones become empty 
notice list 	allow git 
conditions following 	commit barf 
disclaimer redistributions 	necessary say allow 
binary form 	empty intend 
must 	commit immediately want 
reproduce copyright 	merge differences 
notice list 	compute represents current 
conditions following 	state merge 
disclaimer documentation 	recursive work reverting 
materials provided 	cherry picking 
distribution 	merge commit translators 
neither name 	first revert 
redis names 	cherry pick second 
contributors may 	sha commit 
used endorse 	existing commit would 
promote products 	want apply 
derived 	difference introduces since 
software without 	first parent 
specific prior 	prev top 
written permission 	current head cherry 
software provided 	pick reverse 
copyright holders 	revert append commit 
contributors 	log message 
express implied 	msgbuf starts parent 
warranties including 	author committer 
limited implied 	information followed merge 
warranties merchantability 	clean failed 
fitness particular 	due conflict write 
purpose 	cherry pick 
disclaimed shall 	head subsequent invocation 
copyright owner 	commit use 
contributors liable 	however merge even 
direct indirect 	start want 
incidental special 	write picking reverting 
exemplary 	ranges individual 
consequential damages 	revisions done reverse 
including limited 	eat extra 
procurement substitute 	spaces tabs 
goods services 	name verify action 
loss use 	matches one 
data 	opts support arbitrary 
profits business 	instructions reset 
interruption however 	merge arg multiple 
caused theory 	cherry pick 
liability whether 	progress cherry pick 
contract strict 	head revert 
liability 	head indicates single 
tort including 	cherry pick 
negligence otherwise 	progress abort sequence 
arising way 	picks finished 
use software 	successfully cleanup removing 
even advised 	git sequencer 
possibility 	directory verify conflict 
damage gnuc 	resolved decide 
sun sort.c 	depending arguments fresh 
zsl rank 	cherry pick 
type pattern 	handled differently 
pattern subst 	existing one continued 
spat 	happens stdin 
ssub keyobj 	called git cherry 
prefixlen sublen 	pick commit 
postfixlen fieldlen 	cherry pick revert 
cmp operations 	cherry pick 
outputlen alpha 	head revert head 
start 	touch sequencer 
end vectorlen 	state means possible 
getop convertion 	cherry pick 
error syntax 	middle cherry pick 
error sortval 	sequence start 
storekey vector 	cherry pick revert 
leftargs 	sequence first 
entry entry 	make sure existing 
ele zsl 	one isn 
ele rangelen 	progress whole message 
zsetlen setele 	buffer equal 
byval eptr 	sob pretend 
sop 	found conforming footer 
val sobj 	matching sob 
sop val 	buffer completely empty 
zmalloc incr 	foom title 
count decoded 	body filled user 
strchr decr 	incomplete line 
count 	complete line blank 
strstr sdslen 	one empty 
create sdslen 	line message body 
sdslen create 	sob buffer 
memcpy memcpy 	contains single newline 
memcpy decr 	another room 
count 	title body buffer 
lookup key 	ends single 
read hash 	newline another empty 
type incr 	line message 
count decr 	body sob 
count decr 	buffer already ends 
count 	two newlines 
decr count 	sequencer.h edit record 
decr count 	origin commit 
compare objects 	signoff allow allow 
compare objects 	rerere allow 
strcoll compare 	empty allow empty 
objects 	message keep 
collate objects 	redundant commits mainline 
lookup key 	gpg sign 
read reply 	strategy xopts xopts 
list create 	xopts alloc 
list free 	revs opts sign 
method 	header msgbuf 
incr count 	ignore footer flag 
create quicklist 	msgbuf options 
strcasecmp strcasecmp 	merge strategy used 
strcasecmp strcasecmp 	replay none 
reply reply 	server-info.c path 
strcasecmp 	generate tmp ret 
strcasecmp strchr 	path oid 
reply error 	flag data force 
strcasecmp reply 	path ret 
error list 	old num num 
node tail 	alloc heads 
create 	num pack objdir 
sort operation 	objdirlen name 
reply decr 	line old cnt 
count list 	infofile line 
release zset 	old cnt len 
convert list 	infofile force 
type 	stale force infofile 
length type 	ret force 
size dict 	errs mkpathdup safe 
size server 	create leading 
panic zmalloc 	directories git mkstemp 
list type 	mode fdopen 
init 	generate fclose 
iterator list 	adjust shared perm 
type length 	rename error 
list type 	strerror fclose close 
next list 	unlink free 
type list 	parse oid hex 
type 	deref tag 
release iterator 	oid hex git 
list type 	pathdup update 
init iterator 	info file free 
list type 	strcmp find 
next list 	pack name fopen 
type 	fgets strlen 
list type 	parse pack def 
release iterator 	error fclose 
type init 	fclose directory strlen 
iterator type 	prepare packed 
next type 	git xcalloc xcalloc 
release 	read pack 
iterator dict 	info file 
size zsl 	qsort free free 
element rank 	fputc mkpathdup 
zsl element 	directory init pack 
rank server 	info update 
info 	info file free 
dict iterator 	pack info 
dict next 	free update info 
dict key 	refs update 
dict release 	info packs unlink 
iterator server 	warn git 
panic 	path create file 
server info 	path writing 
lookup key 	temporary file renaming 
pattern decoded 	place contents 
sds encoded 	file come generate 
strtod isnan 	non zero 
server 	encounters error 
info decr 	packs skip pack 
count pqsort 	git objects 
qsort getop 	returns non zero 
reply error 	detect info 
reply multi 	old file useless 
bulk 	file describes 
len reply 	pack longer returns 
bulk list 	non zero 
rewind list 	detect info old 
next lookup 	file useless 
key pattern 	nonexistent error name 
reply 	used emit 
reply bulk 	misguided used emit 
decr count 	nobody uses 
server info 	keep order original 
create quicklist 	existed original 
list type 	obviously newer way 
push 	around matter 
list rewind 	least keep 
list next 	comparison stable ignore 
lookup key 	things alternate 
pattern create 	path since available 
list type 	pullers general 
push 	renumber would dumb 
decr count 	server support 
server info 	files later including 
key notify 	index available 
keyspace signal 	pack files intended 
modified key 	audiences leftover 
notify 	rev cache file 
keyspace decr 	setenv.c name 
count reply 	replace namelen valuelen 
decr count 	envstr oldval 
decr count 	strchr getenv strlen 
list release 	strlen malloc 
decr 	memcpy memcpy putenv 
count zfree 	putenv makes 
sort command 	argument part 
helper functions 	environment changing modifies 
copyright salvatore 	environment means 
sanfilippo antirez 	storage anymore free 
gmail 	envstr setup.c 
dot rights 	inside git dir 
reserved redistribution 	inside work 
use source 	work config bogus 
binary forms 	unknown extensions 
without 	path len wtlen 
modification permitted 	path work 
provided following 	prefix len remaining 
conditions met 	prefix path 
redistributions source 	orig sanitized prefix 
code must 	len path 
retain 	prefix path len 
copyright notice 	prefix arg 
list conditions 	name prefix arg 
following disclaimer 	diagnose misspelt 
redistributions binary 	rev prefix 
form must 	arg diagnose misspelt 
reproduce 	rev prefix 
copyright notice 	arg gitdir git 
list conditions 	env common 
following disclaimer 	dir gitdir data 
documentation materials 	path ret 
provided distribution 	suspect path ret 
neither 	len path 
name redis 	ret gitfile error 
names contributors 	orig path 
may used 	len work git 
endorse promote 	dir initialized 
products derived 	ext gitdir nongit 
software 	repo config 
without specific 	ret path error 
prior written 	code max 
permission software 	file size error 
provided copyright 	code buf 
holders contributors 	dir slash 
express 	len pathlen gitdirenv 
implied warranties 	cwd nongit 
including limited 	work env worktree 
implied warranties 	gitfile offset 
merchantability fitness 	core worktree gitdir 
particular purpose 	cwd offset 
disclaimed 	nongit cwd offset 
shall copyright 	nongit root 
owner contributors 	len gitdir cwd 
liable direct 	nongit path 
indirect incidental 	prefix prefix len 
special exemplary 	buf item 
consequential 	data empty entry 
damages including 	found ceil 
limited procurement 	real path nongit 
substitute goods 	env ceiling 
services loss 	dirs ceiling 
use data 	dirs cwd gitdirenv 
profits 	ret gitfile 
business interruption 	offset offset parent 
however caused 	ceil offset 
theory liability 	current device one 
whether contract 	filesystem empty 
strict liability 	entry found parent 
tort 	device nongit 
including negligence 	prefix endptr ret 
otherwise arising 	suspect git 
way use 	work strlen strlen 
software even 	offset component 
advised possibility 	strncmp memmove memmove 
damage 	strcmp real 
qsort sort 	path memmove strcmp 
limit isnan 	real path 
associated key 	absolute path xmallocz 
name obtained 	strlen normalize 
following rules 	path copy 
first 	len free abspath 
occurrence pattern 	part inside 
substituted subst 	repo free xstrfmt 
pattern matches 	normalize path 
everything left 	copy len free 
arrow treated 	prefix path 
name 	gently die strlen 
hash field 	prefix path 
part left 	gently free starts 
key name 	prefix filename 
containing hash 	strlen lstat die 
specified field 	errno die 
returned 	isalnum maybe die 
pattern function 	misspelt name 
simply returns 	die die check 
subst sort 	filename wildcard 
command used 	die verify filename 
like sort 	inside work 
key 	inside git 
retrieve list 	dir check filename 
elements directly 	die getenv 
returned always 	strbuf addstr common 
refcount increased 	dir noenv 
non pattern 	strbuf addf file 
substitution 	exists strbuf 
order implement 	read file die 
sort feature 	errno strbuf 
substitution may 	reset absolute path 
specially encoded 	strbuf addf 
create decoded 	strbuf addbuf strbuf 
fly 	addstr real 
otherwise decoded 	path strbuf addstr 
increment count 	strbuf release 
decrement later 	strbuf release strbuf 
find pattern 	addf validate 
key make 	headref strbuf reset 
sense 	common dir 
find dealing 	getenv access 
hash dereference 	getenv strbuf setlen 
perform substitution 	strbuf addstr 
incremented decode 	access strbuf setlen 
lookup substituted 	strbuf addstr 
key 	access strbuf release 
retrieve hash 	strbuf complete 
field name 	strbuf addstr read 
operation already 	gitfile gently 
increases refcount 	git directory strbuf 
returned every 	setlen inside 
function 	dir git dir 
returns needs 	inside dir 
refcount increased 	git work die 
sort command 	git work 
decreases sort 	git dir absolute 
compare used 	path real 
qsort 	path git 
sort command 	dir chdir die 
given qsort 	getenv setenv 
additional parameter 	git dir leading 
standard bsd 	path strcmp 
specific pass 	git config strcmp 
sorting 	git config 
parameters via 	perm skip prefix 
server structure 	strcmp strcmp 
numeric sorting 	git config list 
trivial precomputed 	append list 
scores objects 	clear common dir 
score 	strbuf addstr 
want comparison 	git config early 
undefined compare 	die warning 
objects lexicographically 	warning die warning 
way result 	strbuf release 
sort deterministic 	stat isreg open 
alphanumeric 	xmallocz read 
sorting least 	full close 
one compare 	starts absolute path 
objects compare 	strrchr xstrfmt 
use strcoll 	free git directory 
directly sure 	real path 
objects 	die errno die 
decoded objects 	die die 
compare elements 	die die free 
directly sort 	getenv strlen 
command complex 	die read gitfile 
command redis 	xstrdup git 
warning 	directory free die 
code optimized 	check repository 
speed bit 	format gently free 
less readability 	git work 
operation counter 	warning git dir 
resulting vector 	free absolute 
sort 	path git work 
lookup key 	chdir die 
sort must 	errno chdir 
right types 	die errno xgetcwd 
create list 	chdir die 
operations perform 	errno git work 
every 	free git 
sorted element 	env git dir 
operations options 	free git 
start argv 	work git work 
need protect 	strcmp git 
sortval incrementing 	dir free dir 
count 	inside git 
future sort 	dir real path 
may options 	chdir die 
able overwrite 	errno strbuf addch 
keys sorting 	free git 
sorted key 	dir free check 
may 	repository format 
destroyed sort 	gently getenv absolute 
command sql 	path xstrdup 
alike syntax 	real path 
parse pattern 	chdir die errno 
contain constant 	setup git 
need 	dir git dir 
sort lookup 	real path 
weight keys 	chdir die errno 
specified real 	git work 
patter accept 	strcmp git dir 
cluster mode 	strbuf addch 
handle 	check repository format 
syntax errors 	gently setenv 
options parsing 	getenv xmemdupz chdir 
sorting sort 	die errno 
specified must 	setup git dir 
sort output 	chdir die 
result 	errno offset component 
consistent across 	strbuf setlen 
scripting replication 	git dir 
types list 	git dir die 
sorted retain 	chdir die 
order even 	errno stat die 
sort 	errno absolute 
order requested 	path real path 
remain stable 	valid free 
across scripting 	xstrdup getenv git 
replication force 	config clear 
alpha sorting 	strbuf getcwd die 
destructively 	errno getenv 
convert encoded 	setup git dir 
sorted sets 	list split 
sort objtain 	filter list longest 
length sort 	ancestor length 
avoid gcc 	list clear dos 
warning 	drive prefix 
perform limit 	git env device 
start count 	die read 
sanity checking 	gitfile xstrdup 
whenever possible 	git directory setup 
load elements 	discovered git 
output 	dir free free 
direct way 	git directory 
possible sort 	setup bare git 
sorted list 	dir setup 
internally sorted 	nongit device die 
nothing sort 	chdir die 
dontsort 	errno strbuf setlen 
constant special 	die chdir 
limit option 	strbuf setlen die 
actually reduces 	errno setup 
number elements 	git directory gently 
fetch also 	setenv setenv 
optimize 	strcmp strcmp strcmp 
load range 	strcmp strcmp 
interested allocating 	strtol git config 
vector big 	die check 
enough selected 	repo format 
range length 	strcmp git config 
load 	strcmp config 
sorting vector 	error nonbool free 
objects sort 	xstrdup check 
special handling 	repository format gently 
list dontsort 	git dir 
makes sure 	setup git directory 
elements 	gently git 
list original 	directory read gitfile 
ordering accordingly 	open dup 
desc asc 	die errno close 
options note 	fork die 
also handle 	errno exit setsid 
limit 	die errno 
direct way 	close close close 
getting required 	sanitize stdfds 
range optimization 	input parameter must 
fix start 	contain absolute 
end output 	path must 
code 	already normalized find 
aware optimization 	part absolute 
special handling 	path lies inside 
sorted dontsort 	work dereferencing 
makes sure 	symlinks outside work 
elements sorted 	example dir 
original 	repo dir file 
ordering accordingly 	work dir 
desc asc 	repo dir file 
options note 	dir file 
also handle 	work dir file 
limit direct 	dir symlink 
way 	symlink symlink points 
getting required 	work symlink 
range optimization 	dir repolink file 
check starting 	repolink points 
point trivial 	dir repo file 
log lookup 	dir repo 
fix 	exactly equal 
start end 	work empty check 
output code 	work already 
aware optimization 	prefix work root 
time load 	whole path 
right scores 	work might match 
sorting 	beginning symlink 
vector lookup 	work check terminated 
sort use 	level check 
sort need 	whole path normalize 
decode integer 	path prepending 
encoded encoding 	prefix relative paths 
supported 	remaining prefix 
far cast 	actual prefix still 
retrieved lookup 	remains path 
key pattern 	example prefix sub 
refcount needs 	sub path 
decreased send 	foo sub 
command 	sub foo full 
output output 	prefix foo 
buffer performing 	sub foo remaining 
specified del 	prefix sub 
incr decr 	bar bar remaining 
operations store 	prefix sub 
option 	sub foo sub 
specified sent 	sub foo 
sorting result 	remaining prefix pwd 
client always 	bar sub 
fails store 	bar remaining prefix 
option specified 	root dir 
sorting 	always exists file 
result list 	exists file 
list type 	exist saying icase 
push incr 	foo exist 
count take 	index user gave 
care care 	icase foo 
incremented 	stupid magic 
refcount caused 	pathspec begins colon 
either lookup 	followed non 
key pattern 	alnum maybe die 
create always 	misspelt name 
fails cleanup 	even trigger fall 
sparkline.c 	back general 
charset charset 	message verify filename 
fill charset 	got argument 
len label 	pathspec entry note 
margin top 	filename begins 
seq seq 	never verifies even 
label 	filename exist 
seq output 	want preceded marker 
seq rows 	want user 
offset len 	use format like 
flags relmax 	filename diagnose 
steps row 	misspelt rev used 
chars 	provide user 
loop opt 	friendly diagnosis 
fill opt 	dying upon finding 
log relval 	name pathname 
step charidx 	diagnosis diagnose name 
label len 	invalid name 
label 	head foo diagnosis 
output seq 	complain inexisting 
columns rows 	file function typically 
flags sublen 	called check 
zmalloc zstrdup 	file rev argument 
zrealloc zfree 	unambiguous caller 
zfree 	want diagnose misspelt 
zfree zmalloc 	rev verifying 
log memset 	first non rev 
log strlen 	argument could 
sdscatlen sdscatlen 	revision diagnose misspelt 
zfree sdscatlen 	rev next 
sparkline 	ones already saw 
render range 	filename ambiguity 
sparkline ascii 	anymore opposite 
sparklines code 	command line marker 
modified http 	parsed arg 
github antirez 	refname interpretable filename 
aspark 	flag test 
adapted order 	looks like git 
sds instead 	directory want 
outputting directly 	see either objects 
terminal copyright 	directory proper 
salvatore sanfilippo 	git directory environment 
antirez 	variable refs 
gmail rights 	directory either head 
reserved redistribution 	symlink head 
use source 	file formatted proper 
binary forms 	regular file 
without modification 	head properly formatted 
permitted 	sha name 
provided following 	check worktree 
conditions met 	related signatures check 
redistributions source 	non worktree 
code must 	related signatures make 
retain copyright 	sure subsequent 
notice 	git processes find 
list conditions 	correct worktree 
following disclaimer 	git work relative 
redistributions binary 	record known 
form must 	extensions otherwise fall 
reproduce copyright 	recording unknown 
notice 	check repository format 
list conditions 	complain git 
following disclaimer 	config used calls 
documentation materials 	git pathdup 
provided distribution 	git config config 
software provided 	call make 
copyright 	setup git env 
holders contributors 	git dir 
express implied 	git gitdir 
warranties including 	setup git dir 
limited implied 	found useable 
warranties merchantability 	yet use gentler 
fitness 	version git 
particular purpose 	config check repo 
disclaimed shall 	good one 
copyright owner 	read location git 
contributors liable 	directory git 
direct indirect 	file path git 
incidental 	directory found 
special exemplary 	failure error code 
consequential damages 	error code 
including limited 	error code returned 
procurement substitute 	error code 
goods services 	function die instead 
loss 	cases non 
use data 	fatal follow path 
profits business 	see git 
interruption however 	work must 
caused theory 	called git work 
liability whether 	cwd already 
contract 	normalized cwd worktree 
strict liability 	cwd inside 
tort including 	worktree cwd outside 
negligence otherwise 	worktree work 
arising way 	without git dir 
use software 	use discovered 
even 	one see make 
advised possibility 	offset point 
damage charset 	past end see 
used display 	work without 
graphs multiple 	git dir use 
rows used 	discovered one 
increase 	list func function 
resolution sequences 	canonicalizes entry 
arrays samples 	git ceiling directories 
use represent 	real path 
data turn 	valid discards 
sparklines api 	unusable presence empty 
order 	entry git 
generate sparkline 	ceiling directories turns 
sequence seq 	canonicalization subsequent 
create sparkline 	entries keep entry 
sequence sparkline 	canonicalize cannot 
sequence sample 	decide function whether 
seq 	work since 
sparkline sequence 	config read function 
sample seq 	called may 
sparkline sequence 	read incomplete configuration 
sample seq 	setting git 
last 	directory clear cache 
sample label 	next queries 
sds output 	configuration reload complete 
sparkline render 	configuration including 
sdsempty seq 	per repo 
sparkline fill 	config file ignored 
free 	previously git 
sparkline sequence 	repository turns later 
seq create 	somewhere updated 
sequence sample 	accordingly git dir 
sequence free 	explicitly going 
sequence ascii 	discovery still repository 
rendering 	validation test 
sequence render 	following order relative 
part sequence 	cwd git 
render sequence 	file containing gitdir 
call call 	path git 
function differnent 	bare git git 
parts 	bare git 
order create 	etc parse octal 
full output 	numbers octal 
without overflowing 	number maybe treat 
current terminal 	values compatibility 
columns print 	cases otherwise 
character 	chmod restrict filemode 
needed create 	given xxx 
sparkline labels 	mask filemode others 
spacing print 	write permission 
label needed 	flags directories handled 
turn sequence 	separately returns 
ascii 	prefix path current 
representation sparkline.h 	working directory 
label length 	relative work root 
labels samples 	current working 
min max 	directory strict subdirectory 
seq label 	work root 
seq 	prefix always ends 
output seq 	character standard 
rows offset 	file descriptor missing 
len flags 	open dev 
output seq 	sh-i18n--envsubst.c variables argc 
columns rows 	argv callback 
flags 	variable start 
sparkline ascii 	variable end valid 
sparklines header 	ptr len 
file copyright 	item nitems nitems 
salvatore sanfilippo 	max slp 
antirez gmail 	slp pstr pstr 
rights 	str str 
reserved redistribution 	slp slp result 
use source 	variables ptr 
binary forms 	len buffer bufmax 
without modification 	buflen opening 
permitted provided 	brace closing brace 
following 	valid env 
conditions met 	error note variables 
redistributions source 	subst stdin 
code must 	strcmp error print 
retain copyright 	variables error 
notice list 	ferror fflush fclose 
conditions 	exit fclose 
following disclaimer 	exit exit 
redistributions binary 	callback fwrite putchar 
form must 	find variables 
reproduce copyright 	realloc strcmp qsort 
notice list 	strcmp strcmp 
conditions 	xmemdupz list append 
following disclaimer 	list init 
documentation materials 	find variables list 
provided distribution 	sort getc 
software provided 	ferror error ungetc 
copyright holders 	getc getc 
contributors 	getc xrealloc getc 
express implied 	ungetc ungetc 
warranties including 	xrealloc sorted list 
limited implied 	member getenv 
warranties merchantability 	fputs putchar putchar 
fitness particular 	fwrite putchar 
purpose 	ungetc putchar putchar 
disclaimed shall 	putchar envsubst 
copyright owner 	stripped version 
contributors liable 	gettext envsubst copyright 
direct indirect 	arnfj bjarmason 
incidental special 	modified version gettext 
exemplary 	runtime src 
consequential damages 	envsubst gettext git 
including limited 	repository stripped 
procurement substitute 	implement envsubst features 
goods services 	need git 
loss use 	fallbacks close standard 
data 	error part 
profits business 	main dac gnulib 
interruption however 	local lib 
caused theory 	closeout copyright notices 
liability whether 	files reproduced 
contract strict 	immediately substitution environment 
liability 	variables shell 
tort including 	format copyright 
negligence otherwise 	free software foundation 
arising way 	inc written 
use software 	bruno haible bruno 
even advised 	clisp program 
possibility 	free software redistribute 
damage sequence 	modify terms 
represented many 	gnu general license 
samples fill 	published free 
area curve 	software foundation either 
use logarithmic 	version option 
scale 	later version program 
sparkline stats.c 	distributed hope 
opt stats 	useful without warranty 
print stats 	without even 
cactive write 	implied warranty merchantability 
cbopaque write 	fitness particular 
cbopaque 	purpose see gnu 
write cbopaque 	general license 
write cbopaque 	details received 
bins large 	copy gnu general 
huge write 	license along 
cbopaque page 	program write free 
config 	software foundation 
tcache gap 	inc franklin street 
nbins nruns 	fifth floor 
reg size 	boston usa closeout 
run size 	close standard 
curregs availregs 	output standard error 
milli 	copyright free 
curruns nregs 	software foundation inc 
nmalloc ndalloc 	program free 
nrequests nfills 	software redistribute modify 
nflushes reruns 	terms gnu 
write cbopaque 	general license published 
nbins 	free software 
nlruns gap 	foundation either version 
nmalloc ndalloc 	option later 
nrequests run 	version program 
size curruns 	distributed hope useful 
write cbopaque 	without warranty 
nbins 	without even implied 
nlruns nhchunks 	warranty merchantability 
gap nmalloc 	fitness particular purpose 
ndalloc nrequests 	see gnu 
hchunk size 	general license details 
curhchunks write 	received copy 
cbopaque 	gnu general license 
bins large 	along program 
huge nthreads 	write free software 
dss dirty 	foundation inc 
mult page 	franklin street fifth 
pactive pdirty 	floor boston 
mapped 	usa substitution shall 
metadata mapped 	performed variables 
metadata allocated 	forward declaration local 
npurge nmadvise 	functions values 
purged small 	command line 
allocated small 	options show variables 
nmalloc 	variables subst 
small ndalloc 	stdin echo foo 
small nrequests 	bar git 
large allocated 	envsubst variables foo 
large nmalloc 	bar git 
large ndalloc 	envsubst variables foo 
large 	bar show 
nrequests huge 	variables close standard 
allocated huge 	error simpler 
nmalloc huge 	fwriteerror ebadf upon 
ndalloc huge 	failure need 
nrequests write 	errno point exit 
cbopaque 	status parse 
opts err 	invoke callback time 
epoch general 	variable variable 
merged unmerged 	construct seen 
bins large 	variable nonempty sequence 
huge cpv 	ascii alphanumeric 
ssv 	underscore characters starting 
bsz ssz 	ascii alphabetic 
sssz cpsz 	underscore character allow 
cactive allocated 	ascii characters 
active metadata 	avoid dependencies current 
resident mapped 	encoding looks 
narenas 	like variable access 
isz ninitialized 	iso encoding 
narenas isz 	doesn look like 
ctl ctl 	one big 
malloc cprintf 	big hkscs gbk 
malloc cprintf 	shift jis 
ctl 	johab encodings single 
ctl malloc 	character encodings 
cprintf ctl 	print variable stdout 
ctl ctl 	followed newline 
ctl ctl 	print variables 
ctl ctl 	contained stdout one 
ctl 	followed newline 
ctl ctl 	type describing list 
ctl malloc 	immutable implemented 
snprintf malloc 	initialize empty list 
snprintf malloc 	append single 
snprintf malloc 	end list grow 
snprintf 	list end 
malloc cprintf 	list compare two 
malloc cprintf 	given reference 
malloc cprintf 	sort list test 
malloc cprintf 	whether sorted 
ctl ctl 	list contains given 
ctl 	binary search 
ctl ctl 	know list index 
ctl ctl 	variables perform 
malloc cprintf 	substitution used variables 
malloc cprintf 	adds variable 
malloc cprintf 	variables stores 
malloc 	variables occurring variables 
cprintf ctl 	copies stdin 
ctl ctl 	stdout performing substitutions 
ctl ctl 	look variable 
ctl ctl 	variable accumulate variable 
ctl malloc 	buffer terminate 
cprintf 	variable buffer test 
malloc cprintf 	whether variable 
malloc cprintf 	shall substituted substitute 
ctl ctl 	variable environment 
malloc cprintf 	perform substitution since 
ctl malloc 	buffered input 
cprintf 	contains start output 
ctl malloc 	buffered contents 
cprintf malloc 	sha1-array.c sha index 
cprintf ctl 	table sha 
ctl ctl 	data alloc grow 
ctl ctl 	hashcpy hashcmp 
malloc 	qsort sha 
cprintf malloc 	sort sha pos 
cprintf ctl 	free sha 
ctl ctl 	sort hashcmp sha1-array.h 
ctl malloc 	alloc sorted 
cprintf ctl 	sha sha data 
ctl 	sha sha1-chunked.c 
ctl ctl 	data len total 
malloc cprintf 	cdata platform 
ctl ctl 	sha update sha1-chunked.h 
ctl ctl 	data len 
malloc cprintf 	sha1-lookup.c sha sha 
malloc 	table lov 
cprintf malloc 	hiv miv ofs 
cprintf ctl 	cmp table 
malloc cprintf 	elem size key 
ctl ctl 	offset key 
malloc cprintf 	key key 
stats 	ofs debug lookup 
arena bins 	cmp ofs 
print stats 	range lov hiv 
arena lruns 	kyv key 
print stats 	take take take 
arena hchunks 	die hashcmp 
print 	getenv memcmp die 
mallctl malloc 	sha hex 
write malloc 	memcmp conventional binary 
write abort 	search loop 
malloc cprintf 	looks like cmp 
ctl malloc 	entry pointed 
cprintf 	minus target cmp 
ctl malloc 	wanted one 
cprintf malloc 	cmp larger target 
cprintf malloc 	smaller target 
cprintf ctl 	invariants entering loop 
malloc cprintf 	points slot 
malloc 	never target 
cprintf ctl 	could target points 
malloc cprintf 	slot guaranteed 
ctl malloc 	target never target 
cprintf ctl 	find point 
malloc cprintf 	could never check 
malloc 	hits target 
cprintf mallctl 	three cases hit 
malloc cprintf 	happy strictly 
mallctl ctl 	higher target update 
malloc cprintf 	strictly lower 
ctl malloc 	target update one 
cprintf 	slot allow 
malloc cprintf 	target choosing take 
ctl malloc 	middle anywhere 
cprintf ctl 	satisfied somehow know 
ctl ctl 	distance target 
ctl ctl 	much shorter target 
ctl 	could pick 
malloc cprintf 	much closer 
malloc cprintf 	midway table contain 
atomic read 	elements sha 
ctl variable 	element returned table 
xmallctl malloc 	point miv 
cprintf 	could equal hiv 
stats arena 	sha could 
print ctl 	still higher invariant 
variable xmallctl 	kept conventional 
malloc cprintf 	binary search loop 
stats arena 	looks like 
print 	cmp entry pointed 
malloc cprintf 	minus target 
data function 	cmp wanted one 
prototypes non 	cmp larger 
functions yyy 	target smaller target 
refresh stats 	invariants entering 
mallctl 	loop points slot 
called application 	never target 
check oom 	could target 
since refreshing 	points slot guaranteed 
ctl cache 	target never 
trigger allocation 	target find point 
practice 	could never 
none subsequent 	check hits target 
mallctl related 	three cases 
calls function 	hit happy strictly 
cause oom 	higher target 
one succeeds 	repeat search strictly 
print 	lower target 
merged arena 	update one slot 
stats print 	allow target 
stats arena 	loop exits matching 
lazy locking 	entry choosing 
would dodge 	take middle anywhere 
tcache 	satisfied somehow 
testing cactive 	know distance target 
allocated active 	much shorter 
resident mapped 	target could 
expected epoch 	pick much closer 
allocated nmalloc 	midway take 
ndalloc 	advantage fact sha 
nrequests expected 	good hash 
arena little 	function enough entries 
large huge 	table expect 
epoch expected 	uniform distribution entry 
mapped npurge 	begins example 
nmadvise 	deadbeef much likely 
purged arg 	appear much 
thd arena 	later midway table 
allocated epoch 	reasonably expected 
nmalloc ndalloc 	near top table 
nrequests expected 	however want 
arena 	pick precisely entry 
allocated epoch 	example turns 
nmalloc ndalloc 	higher target 
nrequests expected 	looking would end 
arena allocated 	narrowing search 
epoch nmalloc 	space instead would 
ndalloc 	simple binary 
expected arena 	search would want 
curruns curregs 	hedge bets 
epoch nmalloc 	less aggressive table 
ndalloc nrequests 	table holds 
nfills nflushes 	least entries elem 
nruns 	size bytes 
nreruns expected 	entry sha key 
arena epoch 	key offset 
nmalloc ndalloc 	table sorted sha 
nrequests curruns 	key entries 
expected arena 	caller wants find 
epoch 	entry key 
nmalloc ndalloc 	knows entry higher 
curhchunks expected 	entry looking 
mallctl mallctl 	entry higher 
mallctl mallctl 	entry looking thru 
mallctl mallocx 	ofs ofs 
ptr 	first different ofs 
mallctl mallctl 	bytes different 
mallctl mallctl 	meaning entries duplicate 
mallctl dallocx 	keys know 
mallctl mallocx 	solid run entry 
ptr mallocx 	entries sorted 
ptr 	nothing single key 
mallocx ptr 	stop search 
mallctl mallctl 	either one entries 
mallctl mallctl 	care furthermore 
mallctl mallctl 	know one endpoints 
dallocx dallocx 	must edge 
dallocx 	run duplicates example 
thd create 	given sequence 
thd lazy 	idx key searching 
mallctl mallocx 	might hit 
ptr mallctl 	duplicate run 
mallctl mallctl 	first never key 
mallctl 	less run 
mallctl mallctl 	know edge say 
dallocx mallctl 	nothing similarly 
mallocx ptr 	key greater run 
mallctl mallctl 	know edge 
mallctl mallctl 	say nothing therefore 
mallctl 	find also 
dallocx mallctl 	know would exist 
mallocx ptr 	far side 
mallctl mallctl 	edge know even 
mallctl mallctl 	know target 
dallocx mallctl 	much closer pick 
mallocx 	precisely overshoot 
ptr mallctl 	know closer pick 
mallctl mallctl 	higher target 
mallctl mallctl 	end narrowing search 
mallctl mallctl 	space smaller 
mallctl mallctl 	amount distance 
mallctl 	would half hedge 
mallctl dallocx 	bets pick 
mallctl mallocx 	less aggressively make 
ptr mallctl 	bit closer 
mallctl mallctl 	middle would otherwise 
mallctl mallctl 	pick sha1-lookup.h 
dallocx 	sha table table 
mallctl mallocx 	elem size 
ptr mallctl 	key offset key 
mallctl mallctl 	sha1.c ctx 
mallctl dallocx 	block ctx ctx 
test data 	data len 
function 	len left hashout 
prototypes non 	ctx pad 
functions yyy 	padlen memcpy blk 
refresh stats 	sha block 
mallctl called 	blk sha 
application check 	block memcpy htonl 
oom 	htonl blk 
since refreshing 	sha update blk 
ctl cache 	sha update 
trigger allocation 	put sha routine 
practice none 	optimized word 
subsequent mallctl 	accesses rather accesses 
related 	avoid unnecessary 
calls function 	copies context initially 
cause oom 	mozilla sha 
one succeeds 	implementation although none 
print merged 	original mozilla 
arena stats 	code remains definitions 
print 	memcpy ntohl 
stats arena 	htonl force usage 
lazy locking 	rol ror 
would dodge 	selecting one smaller 
tcache testing 	constant generate 
stats.c opt 	slightly smaller 
stats 	code constant special 
print stats 	perhaps importantly 
cactive write 	possibly faster uarch 
cbopaque write 	rotate loop 
cbopaque write 	registers compiler change 
cbopaque 	accesses registers 
write cbopaque 	however machines less 
bins large 	registers won 
huge write 	really work least 
cbopaque page 	gcc make 
config tcache 	unholy mess avoid 
gap 	mess slows 
nbins nruns 	things force stores 
reg size 	memory actually 
run size 	happen might better 
curregs availregs 	val asm 
milli curruns 	instead suggested artur 
nregs 	skawina also 
nmalloc ndalloc 	make gcc 
nrequests nfills 	unable silly optimize 
nflushes reruns 	away loads 
write cbopaque 	part won see 
nbins nlruns 	ben herrenschmidt 
gap 	reports ppc version 
nmalloc ndalloc 	comes close 
nrequests run 	optimized asm ppc 
size curruns 	want since 
write cbopaque 	lots registers arm 
nbins nlruns 	best code 
nhchunks 	generation forcing full 
gap nmalloc 	memory barrier 
ndalloc nrequests 	sha round otherwise 
hchunk size 	gcc happily 
curhchunks write 	wild spilling stack 
cbopaque bins 	frame size 
large 	simply explode performance 
huge nthreads 	goes drain 
dss dirty 	rolls bit 
mult page 	source first iterations 
pactive pdirty 	input data 
mapped metadata 	next mix bit 
mapped 	round iterations 
metadata allocated 	take input block 
npurge nmadvise 	round tail 
purged small 	input bit mixing 
allocated small 	round round 
nmalloc small 	round initialize magic 
ndalloc 	constants see 
small nrequests 	fips constants read 
large allocated 	data process 
large nmalloc 	blocks full pad 
large ndalloc 	binary zeroes 
large nrequests 	length output hash 
huge 	sha implementation 
allocated huge 	copyright paul mackerras 
nmalloc huge 	paulus samba 
ndalloc huge 	version assumes 
nrequests write 	running big endian 
cbopaque opts 	machine calls 
err 	external sha core 
epoch general 	process blocks 
merged unmerged 	bytes hash nblocks 
bins large 	ptr hash 
huge cpv 	cnt memcpy ppc 
ssv bsz 	sha core 
ssz 	ppc sha core 
sssz cpsz 	memset ppc 
cactive allocated 	sha core memset 
active metadata 	ppc sha 
resident mapped 	core memcpy sha 
narenas isz 	routine optimized 
ninitialized 	word accesses rather 
narenas isz 	accesses avoid 
ctl ctl 	unnecessary copies 
malloc cprintf 	context initially mozilla 
malloc cprintf 	sha implementation 
ctl ctl 	although none original 
malloc 	mozilla code 
cprintf ctl 	remains definitions memcpy 
ctl ctl 	ntohl htonl 
ctl ctl 	force usage rol 
ctl ctl 	ror selecting 
ctl ctl 	one smaller constant 
ctl 	generate slightly 
ctl malloc 	smaller code constant 
snprintf malloc 	special perhaps 
snprintf malloc 	importantly possibly faster 
snprintf malloc 	uarch rotate 
snprintf malloc 	loop registers compiler 
cprintf 	change accesses 
malloc cprintf 	registers however machines 
malloc cprintf 	less registers 
malloc cprintf 	won really 
ctl ctl 	work least gcc 
ctl ctl 	make unholy 
ctl 	mess avoid mess 
ctl ctl 	slows things 
malloc cprintf 	force stores memory 
malloc cprintf 	actually happen 
malloc cprintf 	might better val 
malloc cprintf 	asm instead 
ctl 	suggested artur skawina 
ctl ctl 	also make 
ctl ctl 	gcc unable silly 
ctl ctl 	optimize away 
ctl malloc 	loads part won 
cprintf malloc 	see ben 
cprintf 	herrenschmidt reports ppc 
malloc cprintf 	version comes 
ctl ctl 	close optimized asm 
malloc cprintf 	ppc want 
ctl malloc 	since lots 
cprintf ctl 	registers arm best 
malloc 	code generation 
cprintf malloc 	forcing full memory 
cprintf ctl 	barrier sha 
ctl ctl 	round otherwise gcc 
ctl ctl 	happily wild 
malloc cprintf 	spilling stack frame 
malloc 	size simply 
cprintf ctl 	explode performance goes 
ctl ctl 	drain rolls 
ctl malloc 	bit source first 
cprintf ctl 	iterations input 
ctl ctl 	data next mix 
ctl 	bit round 
malloc cprintf 	iterations take input 
ctl ctl 	block round 
ctl ctl 	tail input bit 
malloc cprintf 	mixing round 
malloc cprintf 	round round 
malloc 	initialize magic constants 
cprintf ctl 	see fips 
malloc cprintf 	constants read data 
ctl ctl 	process blocks 
malloc cprintf 	full pad binary 
stats arena 	zeroes length 
bins 	output hash sha 
print stats 	implementation copyright 
arena lruns 	paul mackerras paulus 
print stats 	samba version 
arena hchunks 	assumes running big 
print mallctl 	endian machine 
malloc 	calls external sha 
write malloc 	core process 
write abort 	blocks bytes sha1.c 
malloc cprintf 	ctx block 
ctl malloc 	ctx ctx 
cprintf ctl 	data len len 
malloc 	left hashout 
cprintf malloc 	ctx pad padlen 
cprintf malloc 	memcpy blk 
cprintf ctl 	sha block blk 
malloc cprintf 	sha block 
malloc cprintf 	memcpy htonl htonl 
ctl 	blk sha 
malloc cprintf 	update blk sha 
ctl malloc 	update put 
cprintf ctl 	sha routine optimized 
malloc cprintf 	word accesses 
malloc cprintf 	rather accesses avoid 
mallctl 	unnecessary copies 
malloc cprintf 	context initially mozilla 
mallctl ctl 	sha implementation 
malloc cprintf 	although none original 
ctl malloc 	mozilla code 
cprintf malloc 	remains definitions 
cprintf 	memcpy ntohl htonl 
ctl malloc 	force usage 
cprintf ctl 	rol ror selecting 
ctl ctl 	one smaller 
ctl ctl 	constant generate slightly 
ctl malloc 	smaller code 
cprintf 	constant special perhaps 
malloc cprintf 	importantly possibly 
atomic read 	faster uarch rotate 
ctl variable 	loop registers 
xmallctl malloc 	compiler change accesses 
cprintf stats 	registers however 
arena 	machines less registers 
print ctl 	won really 
variable xmallctl 	work least gcc 
malloc cprintf 	make unholy 
stats arena 	mess avoid mess 
print malloc 	slows things 
cprintf 	force stores 
data function 	memory actually happen 
prototypes non 	might better 
functions yyy 	val asm instead 
refresh stats 	suggested artur 
mallctl called 	skawina also make 
application 	gcc unable 
check oom 	silly optimize away 
since refreshing 	loads part 
ctl cache 	won see ben 
trigger allocation 	herrenschmidt reports 
practice none 	ppc version comes 
subsequent 	close optimized 
mallctl related 	asm ppc want 
calls function 	since lots 
cause oom 	registers arm best 
one succeeds 	code generation 
print merged 	forcing full memory 
arena 	barrier sha 
stats print 	round otherwise 
stats arena 	gcc happily wild 
lazy locking 	spilling stack 
would dodge 	frame size simply 
tcache testing 	explode performance 
cactive 	goes drain rolls 
allocated active 	bit source 
resident mapped 	first iterations input 
expected epoch 	data next 
allocated nmalloc 	mix bit round 
ndalloc nrequests 	iterations take 
expected 	input block round 
arena little 	tail input 
large huge 	bit mixing round 
epoch expected 	round round 
mapped npurge 	initialize magic constants 
nmadvise purged 	see fips 
arg 	constants read 
thd arena 	data process blocks 
allocated epoch 	full pad 
nmalloc ndalloc 	binary zeroes length 
nrequests expected 	output hash 
arena allocated 	sha implementation copyright 
epoch 	paul mackerras 
nmalloc ndalloc 	paulus samba version 
nrequests expected 	assumes running 
arena allocated 	big endian machine 
epoch nmalloc 	calls external 
ndalloc expected 	sha core process 
arena 	blocks bytes 
curruns curregs 	hash nblocks ptr 
epoch nmalloc 	hash cnt 
ndalloc nrequests 	memcpy ppc sha 
nfills nflushes 	core ppc 
nruns nreruns 	sha core memset 
expected 	ppc sha 
arena epoch 	core memset 
nmalloc ndalloc 	ppc sha core 
nrequests curruns 	memcpy sha 
expected arena 	routine optimized word 
epoch nmalloc 	accesses rather 
ndalloc 	accesses avoid unnecessary 
curhchunks expected 	copies context 
mallctl mallctl 	initially mozilla sha 
mallctl mallctl 	implementation although 
mallctl mallocx 	none original mozilla 
ptr mallctl 	code remains 
mallctl 	definitions memcpy ntohl 
mallctl mallctl 	htonl force 
mallctl dallocx 	usage rol ror 
mallctl mallocx 	selecting one 
ptr mallocx 	smaller constant generate 
ptr mallocx 	slightly smaller 
ptr 	code constant special 
mallctl mallctl 	perhaps importantly 
mallctl mallctl 	possibly faster 
mallctl mallctl 	uarch rotate loop 
dallocx dallocx 	registers compiler 
dallocx thd 	change accesses registers 
create 	however machines 
thd lazy 	less registers won 
mallctl mallocx 	really work 
ptr mallctl 	least gcc make 
mallctl mallctl 	unholy mess 
mallctl mallctl 	avoid mess slows 
mallctl 	things force 
dallocx mallctl 	stores memory actually 
mallocx ptr 	happen might 
mallctl mallctl 	better val asm 
mallctl mallctl 	instead suggested 
mallctl dallocx 	artur skawina also 
mallctl 	make gcc 
mallocx ptr 	unable silly optimize 
mallctl mallctl 	away loads 
mallctl mallctl 	part won 
dallocx mallctl 	see ben herrenschmidt 
mallocx ptr 	reports ppc 
mallctl 	version comes close 
mallctl mallctl 	optimized asm 
mallctl mallctl 	ppc want since 
mallctl mallctl 	lots registers 
mallctl mallctl 	arm best code 
mallctl mallctl 	generation forcing 
dallocx 	full memory barrier 
mallctl mallocx 	sha round 
ptr mallctl 	otherwise gcc happily 
mallctl mallctl 	wild spilling 
mallctl mallctl 	stack frame size 
dallocx mallctl 	simply explode 
mallocx 	performance goes drain 
ptr mallctl 	rolls bit 
mallctl mallctl 	source first iterations 
mallctl dallocx 	input data 
test data 	next mix 
function prototypes 	bit round iterations 
non 	take input 
functions yyy 	block round tail 
refresh stats 	input bit 
mallctl called 	mixing round round 
application check 	round initialize 
oom since 	magic constants see 
refreshing 	fips constants 
ctl cache 	read data process 
trigger allocation 	blocks full 
practice none 	pad binary zeroes 
subsequent mallctl 	length output 
related calls 	hash sha implementation 
function 	copyright paul 
cause oom 	mackerras paulus samba 
one succeeds 	version assumes 
print merged 	running big 
arena stats 	endian machine calls 
print stats 	external sha 
arena 	core process blocks 
lazy locking 	bytes sha1.h 
would dodge 	ctx ctx data 
tcache testing 	len hashout 
stats.h nrequests 	ctx sha routine 
nmalloc ndalloc 	optimized word 
nrequests 	accesses rather accesses 
curregs nfills 	avoid unnecessary 
nflushes nruns 	copies context initially 
reruns curruns 	mozilla sha 
nmalloc ndalloc 	implementation although none 
nrequests curruns 	original mozilla 
nmalloc 	code remains sha 
ndalloc curhchunks 	implementation copyright 
mapped npurge 	paul mackerras paulus 
nmadvise purged 	samba hash 
metadata mapped 	sha routine 
metadata allocated 	optimized word accesses 
allocated 	rather accesses 
large nmalloc 	avoid unnecessary copies 
large ndalloc 	context initially 
large nrequests 	mozilla sha implementation 
large allocated 	although none 
huge nmalloc 	original mozilla code 
huge 	remains sha 
ndalloc huge 	implementation copyright paul 
lstats hstats 	mackerras paulus 
opt stats 	samba sha1.h ctx 
print stats 	ctx data 
cactive write 	len hashout ctx 
cbopaque 	sha routine 
opts size 	optimized word accesses 
size size 	rather accesses 
size atomic 	avoid unnecessary copies 
read atomic 	context initially 
atomic sub 	mozilla sha 
jemalloc 	implementation although none 
types number 	original mozilla 
allocation requests 	code remains sha 
corresponded size 	implementation copyright 
bin total 	paul mackerras paulus 
number allocation 	samba hash 
deallocation 	sha routine optimized 
requests served 	word accesses 
directly bin 	rather accesses avoid 
note tcache 	unnecessary copies 
may allocate 	context initially mozilla 
recycle many 	sha implementation 
times 	although none original 
resulting many 	mozilla code 
increments nrequests 	remains sha implementation 
one nmalloc 	copyright paul 
ndalloc number 	mackerras paulus samba 
allocation requests 	sha1 filec 
correspond 	sha oid 
size bin 	sha buf size 
includes requests 	cached cached 
served tcache 	alloc empty last 
though tcache 	found pack 
periodically merges 	sha path saved 
counter 	errno path 
current number 	buf pathbuf sha 
regions size 	hex val 
including regions 	pos sha buf 
currently cached 	objdir len 
tcache number 	sha buf sha 
tcache 	buf sha 
fills bin 	buf alt odb 
number tcache 	list alt 
flushes bin 	odb tail entry 
total number 	relative depth 
runs created 	normalized objdir 
bin 	ent alt pfxlen 
size total 	entlen pathbuf 
number runs 	alt len sep 
reused extracting 	relative depth 
runs bin 	entries alt copy 
size current 	objdirbuf entry 
number 	relative depth map 
runs bin 	mapsz path 
total number 	reference alts line 
allocation deallocation 	found ent 
requests served 	alt freshen sha 
directly arena 	freshen sha 
note 	freshen alt sha 
tcache may 	freshen sha 
allocate recycle 	sha pack used 
many times 	ctr pack 
resulting many 	mmap calls peak 
increments nrequests 	pack open 
one 	windows pack 
nmalloc ndalloc 	open windows pack 
number allocation 	open fds 
requests correspond 	pack max fds 
size includes 	peak pack 
requests served 	mapped pack mapped 
tcache 	packed git 
though tcache 	path idx map 
periodically merges 	hdr idx 
counter current 	size version index 
number runs 	min size 
size including 	max size idx 
runs 	name len 
currently cached 	ret lru lru 
tcache total 	lru current 
number allocation 	lru lru need 
deallocation requests 	cur length 
served directly 	limit start length 
arena 	prot flags 
current number 	offset ret 
multi chunk 	start length prot 
allocations size 	flags offset 
number bytes 	ret lru mru 
currently mapped 	accept windows 
total 	inuse mru windows 
number purge 	inuse lru 
sweeps total 	mru accept windows 
number madvise 	inuse cursor 
calls made 	pack name lim 
total pages 	open max 
purged 	hdr sha idx 
order keep 	sha flag 
dirty unused 	max fds win 
memory control 	offset win 
number bytes 	cursor offset left 
currently 	win window 
mapped purely 	align len extra 
metadata purposes 	size path 
number bytes 	path len 
currently allocated 	local free routine 
metadata via 	alloc sha 
atomic 	idx path path 
per size 	alloc pack 
category statistics 	seen bits path 
one element 	list seen 
large size 	bits first last 
one element 	list seen 
huge 	bits path dot 
size jemalloc 	objdir local 
structs jemalloc 	path dirnamelen dir 
externs jemalloc 	garbage len 
inlines stdbool.h 	len ary prepare 
msvc doesn 	packed git 
define 	run alt sha 
note doesn 	sha sha 
pass autoconf 	map size 
test clang 	type real sha 
uses msvc 	hdr hdrlen 
headers needs 	buf readlen name 
msvc 	sha file 
compat built 	open flag sha 
type stdbool 	alt sha 
stdint.h iso 	alt interesting errno 
compliant stdint 	sha size 
microsoft visual 	map unpack header 
studio 	buffer stream 
iso iec 	map mapsize buffer 
committee draft 	bufsiz stream 
may copyright 	map mapsize buffer 
alexander chemeris 	bufsiz header 
redistribution use 	status stream buffer 
source 	size sha 
binary forms 	bytes buf status 
without modification 	hdr flags 
permitted provided 	type buf 
following conditions 	size type type 
met redistributions 	len hdr 
source 	sizep unpack sha 
code must 	file curs 
retain copyright 	curpos data delta 
notice list 	head stream 
conditions following 	delta delta sha 
disclaimer redistributions 	curs curpos 
binary 	sizep left used 
form must 	obj offset 
reproduce copyright 	type revidx sha 
notice list 	obj offset 
conditions following 	curs size curpos 
disclaimer documentation 	tmp pos 
materials 	offset revidx curs 
provided distribution 	curpos size 
name author 	stream buffer delta 
may used 	cached prev 
endorse promote 	next lru 
products derived 	data offset size 
software 	offset hash 
without specific 	offset hash ent 
prior written 	offset offset 
permission software 	ent ent cache 
provided author 	unpack entry 
express implied 	ent delta cache 
warranties 	read obj 
including limited 	offset pack access 
implied warranties 	check packed 
merchantability fitness 	crc obj offset 
particular purpose 	curpos size 
disclaimed shall 	unpack entry index 
author 	vptr ptr 
liable direct 	start end index 
indirect incidental 	sha level 
special exemplary 	ofs index stride 
consequential damages 	use lookup 
including limited 	debug lookup 
procurement 	pos cmp sha 
substitute goods 	offset sha 
services loss 	sha packs sha 
use data 	flags status 
profits business 	mapsize map stream 
interruption however 	hdr hdrbuf 
caused 	sha flags rtype 
theory liability 	real sha 
whether contract 	sizep read packed 
strict liability 	sha pretend 
tort including 	sha file read 
negligence otherwise 	read sha 
arising 	file extended sha 
way use 	required type 
software even 	name size actual 
advised possibility 	sha buffer 
damage msc 	isize actual sha 
ver visual 	length type 
studio 	buf len 
mode many 	type sha hdr 
visual studio 	hdrlen tmpfile 
versions compiling 	filename ret buf 
arm wrap 	len buf 
wchar include 	len type sha 
compiler 	hdr hdrlen 
give many 	filename tmp filename 
errors like 	dirlen sha 
error second 	hdr hdrlen buf 
linkage overloaded 	len mtime 
function wmemchr 	ret compressed stream 
allowed 	parano sha 
define macros 	tmp file filename 
mark types 	utb sha 
changing size 	sha buf len 
like intptr 	type sha 
integer types 	hdr hdrlen 
exact 	buf len type 
width integer 	sha flags 
types visual 	header hdrlen status 
studio embedded 	sha mtime 
visual doesn 	buf len hdr 
realize size 	hdrlen ret 
give 	sha sha sha 
minimum width 	flags oid 
integer types 	buf size desc 
fastest minimum 	entry buf 
width integer 	size buf size 
types integer 	index mem 
types 	sha path flags 
capable holding 	ret write 
pointers win 	sbuf index pipe 
win greatest 	index core 
width integer 	index stream index 
types limits 	sha path 
specified 	flags errstr 
width integer 	header sha type 
types see 	subdir path 
footnote page 	obj cruft subdir 
footnote page 	data baselen 
limits exact 	dir hex sha 
width 	path obj 
integer types 	cruft subdir data 
limits minimum 	baselen path 
width integer 	obj cruft subdir 
types limits 	data buf 
fastest minimum 	data alt vdata 
width 	data buf 
integer types 	data flags alt 
limits integer 	data sha 
types capable 	data flags pack 
holding pointers 	errors hashcmp 
win win 	hashcmp mkdir lstat 
limits 	islnk strbuf 
greatest width 	readlink absolute 
integer types 	path mkdir strbuf 
limits integer 	release strbuf 
types win 	release adjust shared 
win win 	perm xstrdup 
win 	free directory strlen 
size max 	die memcpy 
wchar min 	fill sha path 
wchar max 	strbuf reset 
also defined 	strbuf addf directory 
wchar wchar 	sha hex 
min 	sha pack name 
wchar max 	sha pack 
stdc limit 	name absolute path 
macros limits 	strbuf addstr 
integer types 	real path strbuf 
see footnote 	addch strbuf 
page 	addstr normalize path 
macros minimum 	copy strlen 
width integer 	xmalloc memcpy 
constants macros 	strbuf release directory 
greatest width 	error free 
integer constants 	memcmp free strcmp 
stdc 	icase free 
constant macros 	read info alternates 
msc stdint 	error strbuf 
strbuf.c fmt 	absolute path directory 
arg len 	normalize path 
size len 	copy xmemdupz list 
increment 	split place 
len buf 	absolute path error 
len reqsize 	link alt 
newsize len 	odb entry list 
newsize str 	clear free 
space len 	strbuf release xstrfmt 
fmt 	git open 
arg fmt 	noatime free 
len fmt 	fstat close xsize 
arg fmt 	xmmap close 
len empty 	link alt odb 
len start 	entries munmap 
vfprintf 	xcalloc git pathdup 
end exit 	hold file 
malloc die 	update fdopen file 
strbuf ensure 	die errno 
malloc die 	fopen strbuf getline 
strbuf init 	strcmp die 
die 	strbuf release fclose 
debug stats 	rollback file 
free free 	die errno die 
debug stats 	commit file 
strbuf ensure 	die errno link 
free die 	alt odb 
calculate 	entries strlen free 
size realloc 	prepare alt 
die strbuf 	odb getenv 
empty length 	link alt odb 
strbuf resize 	entries strlen 
strbuf empty 	read info alternates 
length 	directory time 
strbuf ensure 	utime access freshen 
empty length 	file check 
start vsnprintf 	freshen file sha 
end die 	file name 
start strbuf 	prepare alt odb 
empty 	fill sha 
length vsnprintf 	path check freshen 
end die 	file check 
strbuf resize 	freshen local check 
strbuf buffer 	freshen nonlocal 
routines copyright 	check freshen nonlocal 
mark 	check freshen 
pulford mark 	fmt getpagesize fmt 
kyne permission 	fmt fmt 
hereby granted 	fmt git 
free charge 	open noatime fstat 
person obtaining 	close xsize 
copy 	close error xmmap 
software associated 	close htonl 
documentation files 	ntohl munmap error 
software deal 	ntohl munmap 
software without 	error munmap error 
restriction including 	munmap error 
without 	munmap error strip 
limitation rights 	suffix die 
use copy 	xstrfmt check packed 
modify merge 	git idx 
publish distribute 	free scan windows 
sublicense sell 	scan windows 
copies 	munmap free unuse 
software permit 	one window 
persons software 	git env die 
furnished subject 	mmap limit 
following conditions 	check mmap 
copyright notice 	release pack memory 
permission 	mmap xmmap 
notice shall 	gently die errno 
included copies 	die munmap 
substantial portions 	free close close 
software software 	pack windows 
provided without 	close pack close 
warranty 	pack index 
kind express 	die close pack 
implied including 	find lru 
limited warranties 	pack close pack 
merchantability fitness 	munmap strcmp 
particular purpose 	clear delta cache 
noninfringement 	close pack 
shall authors 	free free getrlimit 
copyright holders 	sysconf open 
liable claim 	pack index 
damages liability 	error max limit 
whether action 	close one 
contract 	pack git open 
tort otherwise 	noatime fstat 
arising connection 	isreg error error 
software use 	fcntl error 
dealings software 	fcntl error read 
terminator strbuf 	full error 
allocation 	htonl error pack 
deallocation increment 	version error 
linear buffer 	ntohl ntohl error 
growth rate 	ntohl lseek 
increment exponential 	error read full 
buffer growth 	error hashcmp 
rate 	error open packed 
strbuf dynamically 	git close 
allocated strbuf 	pack open packed 
free called 	git die 
number times 	die die 
strbuf init 	window window open 
ensure 	packed git 
room optional 	die xcalloc unuse 
termination user 	one window 
requested shrink 	xmmap die strerror 
buffer exactly 	close pack 
exponential sizing 	xsize xmalloc memset 
linear 	release pack 
sizing ensure 	memory free routine 
strbuf handle 	strip suffix 
length bytes 	mem strlen alloc 
ignoring optional 	packed git 
termination strbuf 	memcpy xsnprintf access 
append 	xsnprintf stat 
fmt used 	isreg free sha 
upper bound 	hex hashclr 
known output 	sha pack name 
never happen 	strlen alloc 
strbuf append 	packed git 
fmt 	memcpy hashcpy check 
retry used 	packed git 
known upper 	idx free report 
bound output 	garbage list 
first attempt 	sort strncmp report 
append fails 	helper strrchr 
resize 	report garbage strcmp 
buffer appropriately 	strcmp report 
append formatted 	helper strbuf addstr 
fmt len 	strbuf addstr 
length required 	opendir error strerror 
excluding trailing 	strbuf release 
since 	strbuf addch readdir 
also space 	dot dotdot 
store terminating 	strbuf setlen strbuf 
success strbuf.h 	addstr strip 
len len 	suffix mem strip 
increment len 	suffix memcmp 
len 	packed git 
len len 	install packed git 
len len 	ends ends 
fmt format 	ends ends list 
len str 	append report 
len len 	garbage closedir report 
len 	pack garbage 
len len 	list clear strbuf 
strbuf empty 	release xcalloc 
length strbuf 	qsort free prepare 
resize strbuf 	packed git 
ensure empty 	one directory prepare 
length 	alt odb 
strbuf ensure 	prepare packed git 
empty length 	one rearrange 
memcpy memcpy 	packed git prepare 
strbuf buffer 	packed git 
routines copyright 	hashcmp xrealloc mult 
mark 	hashcpy hashcmp 
pulford mark 	hash sha 
kyne permission 	file hashcmp open 
hereby granted 	istream xsnprintf 
free charge 	git sha init 
person obtaining 	git sha 
copy 	update read istream 
software associated 	close istream 
documentation files 	git sha update 
software deal 	git sha 
software without 	close istream hashcmp 
restriction including 	open lstat 
without 	sha file name 
limitation rights 	prepare alt 
use copy 	odb fill sha 
modify merge 	path lstat 
publish distribute 	git open noatime 
sublicense sell 	sha file 
copies 	name prepare 
software permit 	alt odb fill 
persons software 	sha path 
furnished subject 	git open noatime 
following conditions 	open sha 
copyright notice 	file fstat xsize 
permission 	error sha 
notice shall 	file name xmmap 
included copies 	close memset 
substantial portions 	git inflate init 
software software 	git inflate 
provided without 	unpack sha header 
warranty 	memchr strbuf 
kind express 	git inflate strbuf 
implied including 	memchr strlen 
limited warranties 	xmallocz memcpy git 
merchantability fitness 	inflate git 
particular purpose 	inflate end error 
noninfringement 	sha hex 
shall authors 	error sha 
copyright holders 	hex free type 
liable claim 	gently strbuf 
damages liability 	die parse sha 
whether action 	header extended 
contract 	memset git inflate 
tort otherwise 	init use 
arising connection 	pack git inflate 
software use 	git inflate 
dealings software 	end error delta 
size total 	hdr size 
bytes 	delta hdr size 
allocated buf 	use pack 
length length 	unpack header buffer 
excluding optional 	find pack 
terminator increment 	revindex nth packed 
allocation increments 	sha mark 
resizing 	bad packed sha 
buffer created 	info delta 
via strbuf 	unpack header 
initialise release 	retry bad packed 
management update 	offset free 
reset use 	retry bad packed 
bytes 	offset unpack 
remaining buffer 	header delta size 
ensure space 	delta find 
terminator strings.h 	pack revindex packed 
bit scan 	type delta 
forward ffsl 	sha hashcpy hashclr 
msvc 	unuse pack 
doesn define 	xmallocz gently memset 
ffs ffsl 	git inflate 
dummy header 	init use pack 
provided syncio.c 	git inflate 
ptr size 	git inflate end 
timeout 	free pack 
nwritten ret 	entry hash delta 
start remaining 	cache entry 
wait elapsed 	delta cache 
ptr size 	entry free release 
timeout nread 	delta cache 
totread 	trace key init 
start remaining 	trace key 
wait elapsed 	open pack index 
ptr size 	die die 
timeout nread 	ntohl ntohl check 
mstime write 	pack index 
wait 	ptr ntohl ntohl 
mstime mstime 	getenv open 
read wait 	pack index ntohl 
mstime sync 	ntohl getenv 
read synchronous 	sha entry pos 
socket file 	nth packed 
operations 	offset hashcmp nth 
useful across 	packed offset 
core copyright 	open packed 
salvatore sanfilippo 	git hashcmp find 
antirez gmail 	pack entry 
dot 	one pack valid 
rights reserved 	hashcpy prepare 
redistribution use 	packed git fill 
source binary 	pack entry 
forms without 	fill pack entry 
modification permitted 	find pack 
provided 	entry one hashclr 
following conditions 	stat sha 
met redistributions 	file map sha 
source code 	file unpack 
must retain 	sha header strbuf 
copyright notice 	error sha 
list 	hex unpack sha 
conditions following 	header error 
disclaimer redistributions 	sha hex parse 
binary form 	sha header 
must reproduce 	extended error 
copyright notice 	sha hex parse 
list 	sha header 
conditions following 	extended error sha 
disclaimer documentation 	hex git 
materials provided 	inflate end munmap 
distribution neither 	strbuf release 
name redis 	lookup replace extended 
names 	find cached 
contributors may 	hashclr strbuf addstr 
used endorse 	find pack 
promote products 	entry sha loose 
derived software 	info reprepare 
without specific 	packed git find 
prior 	pack entry 
written permission 	packed info mark 
software provided 	bad packed 
copyright holders 	sha info extended 
contributors express 	delta cache 
implied warranties 	strbuf addstr 
including 	sha info extended 
limited implied 	type hashcpy 
warranties merchantability 	read sha file 
fitness particular 	hashcpy free 
purpose disclaimed 	strlen memcmp sha 
shall copyright 	hex free 
owner 	free xsnprintf git 
contributors liable 	sha init 
direct indirect 	git sha update 
incidental special 	git sha 
exemplary consequential 	update git sha 
damages including 	link rename 
limited 	unlink warn error 
procurement substitute 	strerror adjust 
goods services 	shared perm error 
loss use 	write full 
data profits 	error strerror write 
business interruption 	sha file 
however 	prepare fsync 
caused theory 	die close die 
liability whether 	errno strrchr 
contract strict 	directory size strbuf 
liability tort 	reset strbuf 
including negligence 	strbuf addstr git 
otherwise 	mkstemp mode 
arising way 	strbuf reset strbuf 
use software 	mkdir adjust 
even advised 	shared perm strbuf 
possibility damage 	addstr git 
blocking sockets 	mkstemp mode sha 
timeouts 	file name 
redis performs 	create tmpfile error 
nonblocking way 	directory error 
sync command 	strerror git deflate 
slave blocking 	init git 
way migrate 	sha init 
command 	git deflate git 
must blocking 	sha update 
order atomic 	git deflate git 
point view 	sha update 
two instances 	write buffer die 
one migrating 	die sha 
key 	hex git deflate 
one receiving 	end gently 
key need 	die sha hex 
following blocking 	git sha 
functions functions 	hashcmp die sha 
take timeout 	hex close 
milliseconds 	sha file utime 
resolution milliseconds 	warning strerror 
write specified 	finalize file check 
payload writing 	freshen find 
whole payload 	pack entry freshen 
done within 	file write 
timeout 	sha file 
milliseconds operation 	prepare freshen packed 
succeeds size 	freshen loose 
returned otherwise 	write loose strlen 
operation fails 	xmalloc write 
returned unspecified 	sha file prepare 
write 	freshen packed 
could performed 	freshen loose write 
file descriptor 	loose free 
optimistically write 	loose read packed 
checking file 	sha error 
descriptor actually 	sha hex xsnprintf 
writable 	write loose 
worst eagain 	free stat sha 
wait read 	pack index 
specified amount 	name find pack 
bytes bytes 	entry find 
read within 	pack entry loose 
timeout 	reprepare packed 
milliseconds operation 	git find 
succeed size 	pack entry sha 
returned otherwise 	file init 
operation fails 	desc entry memset 
returned unspecified 	parse commit 
amount 	buffer die memset 
data could 	parse tag 
read file 	buffer die would 
descriptor optimistically 	convert git 
read checking 	filter convert git 
file descriptor 	filter write 
actually 	sha file hash 
readable worst 	sha file 
eagain read 	strbuf release open 
wait read 	error strerror 
line making 	index error strbuf 
sure every 	readlink strerror 
require 	error hash sha 
timeout milliseconds 	file write 
read success 	sha file 
number bytes 	error strbuf release 
read returned 	resolve gitlink 
otherwise success 	error read full 
always 	htonl pack 
correctly terminated 	version opendir error 
tcache.c opt 	strerror readdir 
tcache opt 	dot dotdot strbuf 
tcache max 	setlen strbuf 
tcache bin 	addf strlen snprintf 
info 	sha hex 
stack nelms 	obj cruft closedir 
nhbins tcache 	strbuf setlen 
maxclass tcaches 	subdir strbuf addf 
tcaches past 	file obj 
tcaches avail 	subdir strbuf setlen 
ptr 	strbuf addstr 
tsd tcache 	loose file objdir 
binind tbin 	buf strbuf 
tbin info 	release strbuf 
tsd arena 	loose file objdir 
tcache tbin 	buf strbuf 
binind 	release loose file 
ret tsd 	objdir directory 
tcache tbin 	alt odb nth 
binind rem 	packed sha 
arena ptr 	error prepare packed 
nflush ndeferred 	git open 
merged 	pack index pack 
stats chunk 	git information 
bin arena 	manager hell copyright 
bin pageind 	linus torvalds 
bitselm bin 	handles basic git 
tsd tbin 	sha files 
binind 	packing unpacking creation 
rem tcache 	etc meant 
arena ptr 	hold small 
nflush ndeferred 	number objects would 
merged stats 	want read 
chunk locked 	sha file able 
arena 	yet want 
idump tcache 	write store browse 
arena tcache 	application pointer 
oldarena newarena 	last packed git 
tcache arena 	found sought 
iter tsd 	look packfile first 
arena 	objects looked 
tsd arena 	similar times often 
tcache size 	packfile one 
stack offset 	another looking path 
tsd tcache 	symlinked worktree 
arena tbin 	whose original repository 
bin 	yet git 
tbin tsd 	cache pointing original 
tcache tsd 	repository user 
tcache arena 	hasn performed 
bin tbin 	conflict resolution yet 
lstats tbin 	path exists 
tsd 	somebody created since 
ind tcache 	either mkdir 
elm tsd 	failed somebody pruned 
elm tsd 	containing directory 
ind tsd 	stat failed file 
ind elm 	way removed 
arena 	either way inform 
salloc tcache 	caller might 
bin flush 	worth trying path 
small tcache 	points cache 
bin flush 	entries xstrdup messing 
large arena 	sha sha 
tcache 	name pack index 
fill small 	file specified 
tcache alloc 	sha filename name 
easy arena 	scratch space 
choose chunk 	must provided 
addr extent 	caller pack idx 
node 	prepare alternate 
arena arena 	database registry variable 
prof accum 	alt odb 
prof idump 	list points list 
malloc mutex 	alternate database 
chunk addr 	elements list come 
extent 	non empty 
node arena 	elements colon separated 
arena bitselm 	alternate environment 
arena dalloc 	environment variable git 
bin junked 	directory info 
locked malloc 	alternates whose contents 
mutex 	similar environment 
unlock malloc 	variable separated points 
mutex malloc 	statically allocated 
mutex unlock 	buffer contains directory 
memmove arena 	corresponding git 
choose chunk 	objects name 
addr 	points slash end 
extent node 	git objects 
arena malloc 	example enough space 
mutex arena 	hold hex 
prof accum 	sha extra slash 
locked chunk 	first level 
addr 	indirection terminating nul 
extent node 	trailing slash 
arena arena 	directory name given 
dalloc large 	function end 
junked locked 	duplicates hex hex 
malloc mutex 	nul detect 
unlock 	cases alternate disappeared 
prof idump 	prevent common 
malloc mutex 	mistake listing thing 
malloc mutex 	twice directory 
unlock memmove 	alternate entry 
malloc mutex 	recursively alternates returns 
elm 	successfully freshened 
tail insert 	file otherwise check 
malloc mutex 	freshen functions 
unlock tcache 	file exists freshened 
arena dissociate 	freshening requested 
tcache arena 	otherwise safe skip 
associate 	write either 
malloc mutex 	exist disk stale 
tcache stats 	mtime may 
merge malloc 	subject pruning open 
mutex unlock 	mmap index 
tcache enabled 	file path perform 
tsd 	couple consistency 
nominal tcache 	checks record information 
enabled arena 	success skip 
choose unlikely 	index header total 
tcache create 	size index 
offsetof ptr 	entries bytes 
ceiling 	entries sha offset 
ipallocztm tcache 	sha packfile 
arena associate 	sha file checksum 
arena choose 	minimum size 
tcache arena 	bytes header index 
dissociate tcache 	entries bytes 
bin 	sha entry crc 
flush small 	entry offset 
malloc mutex 	entry sha packfile 
malloc mutex 	sha file 
unlock tcache 	checksum offset table 
bin flush 	might variable 
large 	sized table containing 
malloc mutex 	entries offsets 
malloc mutex 	larger make sure 
unlock arena 	deal large 
prof accum 	pack offsets bit 
prof idump 	offset won 
idalloctm 	enough neither 
tsd tcache 	bit one nothing 
tcache destroy 	lru pack 
tsd tcache 	one oldest mru 
cassert malloc 	window preferring 
mutex malloc 	packs used windows 
mutex 	oldest mtime 
unlock alloc 	windows allocated reject 
tcache create 	pack windows 
tcache destroy 	previously selected one 
tcaches elm 	pack windows 
flush tcaches 	reject pack file 
elm 	newer previously 
flush size 	selected one reject 
index alloc 	pack windows 
data total 	use previously selected 
stack elms 	pack inuse 
per tcache 	windows otherwise record 
index 	pack windows 
first element 	use reject 
within tcaches 	pack windows used 
never used 	recently previously 
head singly 	selected pack previously 
linked list 	selected pack 
tracking 	windows inuse encountered 
available tcaches 	window pack 
elements flush 	inuse skip check 
ceiling objects 	since prefer 
low water 	pack inuse windows 
mark reduce 	one inuse 
fill 	windows pack used 
count limit 	git repack 
fill div 	newly created pack 
fill count 	happens contain 
always least 	objects existing one 
increase fill 	resulting file 
count 	might different 
make sure 	even name would 
fill div 	best close 
stays greater 	reference old pack 
arena bin 	replaced disk 
associated first 	course index pointers 
allocated 	windows given 
via different 	pack must subsist 
arena bin 	point ever 
one currently 	objects pack requested 
locked stash 	version pack 
handled future 	reinitialized reprepare packed 
pass 	git otherwise 
flush loop 	got one two 
didn happen 	reasons sysconf 
flush arena 	understand open max 
stats didn 	signaled error 
merged manually 	sysconf said limit 
arena 	could clear 
associated first 	errno calling 
allocated via 	sysconf tell two 
different arena 	cases apart 
one currently 	huge number latter 
locked stash 	caller cap 
handled 	selfish letting fallback 
future pass 	open max 
flush loop 	codepath take care 
didn happen 	cases lot 
flush arena 	simpler see caller 
stats didn 	call directly 
merged 	leaks pack error 
manually link 	call open 
list extant 	packed git instead 
tcaches unlink 	save stdin 
list extant 	stdout stderr work 
tcaches memoize 	nothing created 
naturally 	pack lack size 
align pointer 	file descriptors 
stacks avoid 	open sliding 
cacheline sharing 	mmap point keeping 
nothing caller 	open across 
must arena 	exec though verify 
merge 	recognize pack 
reset tcache 	file format verify 
stats necessary 	pack matches 
clamp opt 	index must promise 
tcache max 	least bytes 
large maxclass 	one hash offset 
known 	available window 
initialize tcache 	otherwise offset actually 
bin info 	window different 
tcache.h ncached 	window one hash 
max tstats 	excess must 
low water 	used support header 
fill 	delta parsing 
div ncached 	routines since packfiles 
avail prof 	end hash 
accumbytes cnt 	content pointless 
next bin 	ask offset middle 
tbins tcache 	hash window 
next 	function wouldn match 
opt tcache 	allow offset 
opt tcache 	close end file 
max tcache 	nothing make 
bin info 	sure corresponding pack 
nhbins tcache 	file exists 
maxclass 	index looks sane 
tcaches ptr 	pack enough 
tsd tcache 	hold suffix adding 
tsd arena 	use xsnprintf 
tcache tbin 	checks looks sane 
binind tsd 	far check 
tcache 	without actually mapping 
tbin binind 	pack file 
rem tsd 	includes nul reopen 
tbin binind 	pack already 
rem tcache 	see really 
tcache arena 	valid idx file 
tcache 	corresponding pack 
oldarena newarena 	file map local 
tcache arena 	packs tend 
tsd tsd 	contain objects specific 
arena tsd 	variant project 
tsd tcache 	remote ones addition 
arena 	remote ones 
tsd ind 	could network mounted 
tsd ind 	filesystem favor 
tsd ind 	local ones reasons 
tsd tcache 	younger packs 
tsd create 	tend contain recent 
enabled 	objects recent 
tbin tsd 	objects tend accessed 
arena tcache 	often prepare 
size zero 	packed git 
tsd arena 	easier sorting link 
tcache size 	back core 
zero 	data map rehash 
tsd tcache 	make sure 
ptr binind 	name actually matches 
tsd tcache 	sha detect 
ptr size 	corruption map reading 
tsd ind 	named sha 
tsd 	streaming rehash generate 
tsd tcache 	header sha 
enabled enabled 	might failure due 
tsd tcache 	noatime mmap 
enabled tsd 	forbidden empty files 
create tcache 	data stream 
tsd 	check entire header 
tcache tbin 	unpacked first 
ret tsd 	iteration buffer bufsiz 
arena tcache 	large enough 
size zero 	copy result 
ret binind 	header append result 
usize 	reading stream 
tbin tsd 	condition must bytes 
arena tcache 	size bytes 
size zero 	size words even 
ret binind 	though expect 
usize tbin 	output avail zero 
chunk 	input zlib 
pageind tsd 	stream may bytes 
tcache ptr 	express concludes 
binind tbin 	stream want eat 
tbin info 	input otherwise 
tsd 	would able test 
tcache ptr 	consumed input 
size binind 	reach expected size 
tbin tbin 	also want 
info tsd 	check zlib tells 
ind elm 	went well 
cassert 	status stream 
tsd fetch 	end end used 
tcache cleanup 	use sscanf 
cassert tsd 	actually way permissive 
fetch tsd 	want check 
tcache enabled 	anal header parse 
tsd 	hand type 
tcache enabled 	size followed space 
cassert tsd 	type unknown 
fetch tsd 	obtaining type allow 
tcache enabled 	unkown type 
tcache cleanup 	option length must 
tsd 	follow immediately 
tcache unlikely 	canonical format valid 
tsd nominal 	length must 
tcache hard 	followed zero examine 
tsd tcache 	initial part 
unlikely tcache 	delta figure result 
hard 	size ignore 
unlikely unlikely 	size read 
size index 	result size use 
index size 	pack assured 
tcache alloc 	info info range 
easy unlikely 	look without 
tcache 	walking end mapped 
alloc small 	window actually 
hard tcache 	hash size assured 
salloc likely 	ofs delta 
unlikely arena 	longer hash size 
alloc junk 	stupid delta 
small 	would smaller store 
unlikely memset 	overflow bound 
unlikely arena 	entry must pack 
alloc junk 	like delta 
small memset 	sha instead pack 
tcache size 	offset means 
index 	cheaper deltas 
index size 	lookup expensive ofs 
tcache alloc 	deltas load 
easy unlikely 	revidx convert offset 
arena malloc 	back sha 
large chunk 	use pack assures 
addr 	available range 
arena mapbits 	look actually hash 
large binind 	size assured 
likely unlikely 	header encoding maximum 
memset unlikely 	deflated size 
memset memset 	insane know won 
tcache 	exceed given 
tcache salloc 	push going behind 
unlikely arena 	parsing offset 
dalloc junk 	fails unwind getting 
small unlikely 	fails first 
tcache bin 	retry otherwise unwind 
flush 	always representation 
small tcache 	type convert 
tcache salloc 	real type later 
tcache salloc 	caller interested 
size index 	payload larger phase 
unlikely arena 	drill innermost 
dalloc 	bail phase hopes 
junk large 	recovery push 
unlikely tcache 	proceed phase handle 
bin flush 	phase apply 
large tcache 	deltas order invariants 
unlikely tcache 	data holds 
create 	data corruption probably 
arena choose 	deep shit 
tcache pointers 	fetch required anyway 
close used 	another pack 
encode state 	loose costly happen 
information used 	presence corrupted 
two 	pack better failing 
purposes preventing 	outright could 
caching per 	apply delta 
basis cleaning 	warn user keep 
shutdown absolute 	going failure 
minimum number 	noticed either next 
cache 	iteration loop 
slots small 	delta caller code 
bin absolute 	paths take 
maximum number 	care making warning 
cache slots 	retrying another 
small bin 	copy need check 
cache 	underflow idx 
additional constraint 	files must least 
beyond imposed 	bytes already 
twice number 	open pack known 
regions per 	valid pack 
run size 	one window completely 
constant 	covering file 
must even 	size pack known 
number number 	valid even 
cache slots 	descriptor currently 
large size 	open force pack 
classes opt 	open prove 
tcache 	valid tell caller 
max used 	locate requested 
compute tcache 	better make sure 
maxclass tcache 	packfile still 
sweep approximate 	accessed supplying answer 
number allocation 	may deleted 
events 	since index loaded 
full sweeps 	iff pack 
integer rounding 	file contains named 
may cause 	sha store 
actual number 	location already one 
slightly higher 	care type 
since 	size need look 
performed incrementally 	inside note 
number tcache 	optimize stat 
allocation deallocation 	call even caller 
events incremental 	doesn care 
jemalloc types 	disk size since 
enable 	implicitly indicates 
cast read 	whether even exists 
information associated 	nothing likely 
element tcache 	loose loose someone 
tbins stored 	may packed 
separately mainly 	packed info follow 
reduce 	delta chain 
memory usage 	find real type 
upper limit 	unless given 
ncached min 	typep returns type 
cached since 	negative probably 
last fill 	deep shit fetch 
ncached 	required anyway 
max fill 	another pack loose 
div cached 	happen presence 
objects stack 	corrupted pack 
available objects 	better failing outright 
used aggregating 	function dies 
stats 	corrupt objects callers 
cleared arena 	want deal 
prof accum 	arrange call read 
count since 	give error 
incremental next 	messages die replaced 
bin dynamically 	one exist 
sized 	handle references referred 
pointer stacks 	actual sha 
associated tbins 	check generate header 
follow contiguous 	sha move 
tcache initialization 	written resting place 
avail pointer 	coda hack 
element 	coda doesn like 
tbins initialized 	cross directory 
point proper 	links fall back 
offset within 	rename mean 
linkage list 	won able 
available previously 	check collisions big 
used 	deal holds 
tcache jemalloc 	fat formatted media 
structs number 	succeeds nothing 
tcache bins 	left unlink fixme 
nbins small 	collision check 
bins plus 	finalize file disk 
large 	close size 
bins maximum 	directory component including 
cached size 	ending creates 
tcaches managed 	temporary file directory 
via tcache 	filename want 
create flush 	avoid cross directory 
destroy 	filename renames 
mallctls usable 	problems various filesystems 
via mallocx 	fat nfs 
tcache flag 	coda make sure 
automatic per 	directory exists 
tcaches completely 	note contents 
disjoint 	buffer undefined mkstemp 
data structure 	returns error 
tcaches starts 	rewrite whole buffer 
sparse physical 	scratch first 
memory footprint 	header nothing data 
individual pages 	normally pack 
touched 	bother writing git 
allows entire 	objects file 
allocated first 	type length plus 
time tcache 	nul must 
created without 	fit nothing entry 
disproportionate impact 	die malformed 
memory 	entries convert blobs 
usage jemalloc 	git format 
externs allocate 	creates one packfile 
one large 	per large 
time quite 	blob unless bulk 
expensive create 	checkin machinery 
one 	plugged also 
use jemalloc 	bypasses usual convert 
inlines test.c 	git dance 
host port 	purpose could write 
timeout path 	streaming version 
fails reply 	converting functions insert 
keep 	feeding data 
reply config 	fast equivalent core 
dummy ctx 	api described 
cmd len 	however somewhat complicated 
argv lens 	know size 
argc config 	filter result need 
reply 	know beforehand 
cmd len 	writing git since 
reader reply 	primary motivation 
ret config 	trying stream working 
reply config 	file avoid 
reply reply 	mmaping core 
major 	deal large binary 
minor field 	blobs generally 
eptr config 	want conversion callers 
config replies 	avoid code 
num argc 	path filters requested 
argv cfg 	call xsize 
throughput 	needed avoid potentially 
test inherit 	unnecessary die 
gettimeofday redis 	large files eof 
command free 	pack header 
reply redis 	fully read protocol 
command free 	error pack 
reply 	signature mismatch detected 
exit redis 	protocol error 
command free 	pack version unsupported 
reply redis 	copy including 
command free 	trailing sha1 namec 
reply redis 	commit list 
free 	data candidate 
keep redis 	current len hex 
free redis 	pfx alt 
connect redis 	hex fakeent objdir 
connect unix 	objdir len 
redis connect 	dir sha len 
unix 	len bin 
disconnect redis 	pfx num last 
connect exit 	first current 
exit database 	mid current cmp 
test redis 	len bin 
format command 	pfx sha sha 
test 	data unused 
cond strncmp 	kind sha data 
free test 	unused obj 
redis format 	kind sha data 
command test 	unused kind 
cond strncmp 	sha data unused 
free 	obj kind 
test redis 	sha data 
format command 	unused kind name 
test cond 	len bin 
strncmp free 	pfx hex pfx 
test redis 	val name 
format 	len sha flags 
command test 	status hex 
cond strncmp 	pfx bin pfx 
free test 	quietly prefix 
redis format 	data hex pfx 
command test 	bin pfx 
cond 	len hex sha 
strncmp free 	len status 
test redis 	exists sha ret 
format command 	sha len 
test cond 	hex path len 
strncmp free 	slash cnt 
test 	len suffix suffix 
redis format 	len len 
command test 	suffix len 
cond strncmp 	suffix name len 
free integer 	sha lookup 
width test 	flags name namelen 
integer 	buf str 
width test 	len sha flags 
integer width 	warn msg 
test integer 	name msg tmp 
width test 	sha real 
width test 	refs found reflog 
width 	len nth 
test test 	prior buf detached 
redis format 	nth time 
command test 	time cnt errors 
cond test 	tmp name 
redis format 	len result idx 
command 	sha ret 
argv test 	commit name 
cond strncmp 	len result generation 
free test 	sha commit 
redis format 	ret peel type 
command argv 	name len 
test 	sha outer expected 
cond strncmp 	type lookup 
free connect 	flags prefix ret 
test redis 	list name 
format command 	len sha flags 
test cond 	name len 
redis 	sha lookup flags 
append formatted 	ret suffix 
command redis 	num len path 
reply free 	oid flag 
free reply 	data list prefix 
disconnect test 	sha list 
redis 	found negative regex 
reader create 	buf commit 
redis reader 	matches remaining 
feed redis 	buf osha nsha 
reader reply 	email timestamp 
test cond 	message data target 
strcasecmp 	len name 
redis reader 	namelen buf nth 
free test 	retval brace 
redis reader 	num end name 
create redis 	sha one 
reader feed 	two mbs sha 
redis 	tmp dots 
reader feed 	name namelen len 
redis reader 	buf next 
feed redis 	name namelen len 
reader reply 	buf tmp 
test cond 	used ret buf 
strcasecmp 	name namelen 
redis reader 	buf mark data 
free test 	len branch 
redis reader 	err name 
create redis 	str name namelen 
reader feed 	buf start 
redis 	len name len 
reader reply 	used name 
test cond 	name sha unused 
strncasecmp redis 	name sha 
reader free 	unused name sha 
test redis 	unused name 
reader 	sha unused name 
create redis 	sha unused 
reader feed 	name sha unused 
redis reader 	prefix filename 
reply test 	sha name name 
cond redis 	len sha 
reader 	mode fullname stage 
free test 	prefix filename 
redis reader 	pos namelen fullname 
create redis 	rel name 
reader feed 	flags prefix 
redis reader 	sha ret bracket 
reply 	depth namelen 
redis reader 	die stage path 
feed redis 	pos list 
reader reply 	sha len filename 
test cond 	filename name 
redis reader 	prefix sha str 
free 	flags sha 
test redis 	orc hashcpy hashcmp 
reader create 	hashcpy directory 
redis reader 	strlen xmalloc memcpy 
feed redis 	xsnprintf xsnprintf 
reader reply 	opendir readdir strlen 
redis 	memcmp memcpy 
reader reply 	sha hex update 
test cond 	candidates closedir 
redis reader 	open pack 
free test 	index nth packed 
redis reader 	sha hashcmp 
create 	nth packed sha 
redis reader 	match sha 
feed redis 	update candidates prepare 
reader reply 	packed git 
test cond 	unique pack hashcpy 
free reply 	sha info 
redis 	sha info deref 
reader free 	tag parse 
test redis 	sha info sha 
connect test 	info deref 
cond strcmp 	tag lookup sha 
strcmp strcmp 	info hashclr 
strcmp 	memset prepare prefixes 
strcmp redis 	prepare alt 
free test 	odb memset find 
redis connect 	filename find 
test cond 	packed finish 
strcmp redis 	disambiguation error strlen 
free 	prepare prefixes 
test redis 	prepare alt odb 
connect unix 	memset find 
test cond 	filename find packed 
redis free 	sha hex 
connect test 	sha file sha 
redis 	find unique 
command free 	abbrev strlen memcmp 
reply test 	mark size 
redis command 	mark size sha 
free reply 	hex dwim 
test redis 	warning free upstream 
command 	mark push 
free reply 	mark ambiguous path 
redis command 	interpret nth 
test cond 	prior checkout sha 
strcmp free 	hex strbuf 
reply test 	release dwim 
redis 	dwim log dwim 
command free 	sha warning 
reply redis 	xstrndup approxidate careful 
command test 	free free 
free reply 	read starts strlen 
test redis 	warning show 
command 	date date mode 
free reply 	exit die 
test redis 	free sha lookup 
command free 	commit reference 
reply test 	parse commit hashcpy 
free reply 	hashcpy sha 
redis 	lookup commit reference 
command free 	parse commit 
reply redis 	hashcpy starts starts 
command redis 	starts starts 
command free 	starts sha parse 
reply test 	deref tag 
free 	parse hashcpy 
reply redis 	peel type hashcpy 
command free 	xstrndup commit 
reply redis 	list insert sha 
command free 	oneline free 
reply redis 	isxdigit sha parent 
command 	nth ancestor 
redis command 	peel onion sha 
test cond 	basic describe 
memcmp memcmp 	name sha parse 
strcasecmp free 	deref tag 
reply disconnect 	strlen commit list 
connect 	insert regcomp 
redis command 	commit list insert 
strstr strtol 	pop recent 
strlen strtol 	commit parse commit 
free reply 	buffer strstr 
test 	regexec unuse commit 
redis command 	buffer hashcpy 
test cond 	regfree free 
strcasecmp redis 	commit list clear 
reply free 	commit marks 
reply test 	free commit list 
cond 	skip prefix 
strcmp redis 	strstr strbuf reset 
free connect 	strbuf memchr 
test redis 	strtol strbuf init 
timeout test 	reflog ent 
cond redis 	reverse strbuf reset 
reply 	strbuf addbuf 
redis free 	strbuf release strstr 
test redis 	sha sha 
connect timeout 	strbuf init strbuf 
test cond 	sha committish 
test redis 	strbuf release lookup 
connect 	commit reference 
timeout test 	gently sha 
cond redis 	committish lookup commit 
free connect 	reference gently 
test free 	merge bases hashcpy 
reply redis 	free commit 
command 	list memchr strbuf 
malloc usec 	reset strbuf 
redis command 	strbuf interpret branch 
usec free 	name strbuf 
reply free 	setlen strbuf reset 
malloc usec 	strbuf addbuf 
redis 	strbuf release shorten 
command usec 	unambiguous strbuf 
free reply 	reset strbuf addstr 
free malloc 	free mark 
redis append 	memchr xmemdupz branch 
command usec 	free branch 
redis 	data die shortened 
reply usec 	interpret nth 
free reply 	prior checkout 
free malloc 	strlen reinterpret memchr 
redis append 	interpret empty 
command usec 	reinterpret interpret branch 
redis 	mark interpret 
reply usec 	branch mark strlen 
free reply 	interpret branch 
free disconnect 	name strbuf strbuf 
signal strcmp 	branchname strbuf 
strcmp atoi 	splice check refname 
strcmp 	format sha 
strcmp strcmp 	context sha context 
exit test 	sha context 
format commands 	sha context sha 
test reply 	context sha 
reader test 	context file exists 
blocking 	die xstrfmt 
connection errors 	entry die die 
test blocking 	strlen cache 
connection test 	name pos 
blocking errors 	namelen memcmp die 
test invalid 	stage strbuf 
timeout 	addstr strbuf addstr 
errors test 	cache name 
append formatted 	pos namelen memcmp 
commands test 	die stage 
throughput test 	stage file exists 
blocking connection 	die die 
test 	strbuf release starts 
blocking errors 	starts die 
test throughput 	inside work die 
test blocking 	prefix path 
connection following 	strlen strlen memset 
lines make 	sha commit 
testing 	list sort date 
framework testing 	sha oneline 
know chat 	resolve relative path 
make sure 	strlen strlcpy 
empty awesome 	read cache 
empty make 	cache name pos 
sure 	namelen memcmp 
free context 	stage hashcpy free 
well keep 	diagnose invalid 
requested create 	index path free 
dummy connection 	sha resolve 
inherit vararg 	relative path entry 
width 	follow symlinks 
depends type 	entry diagnose invalid 
tests make 	sha path 
sure width 	hashcpy strlcpy free 
correctly determined 	die sha 
format subsequent 	context die sha 
varargs 	context first 
correctly interpolated 	candidate already seen 
reply already 	cannot disambiguate 
contains multiple 	candidate current 
items must 	discard candidate know 
free error 	satisfy reach 
valgrind 	point know candidate 
bark doesn 	satisfies current 
happen regression 	candidate satisfy cannot 
test issue 	disambiguate otherwise 
git hub 	current discarded candidate 
care message 	still good 
test 	create fake alternate 
multi bulk 	database points 
reply reply 	database make easier 
specifically test 	temporary working 
ordering reply 	space alt name 
items parse 	alt iterating 
connect 	databases including every 
target given 	alt odb 
config find 	extra bytes exactly 
redis version 	purpose point 
determine path 	first location 
next test 	lowest name could 
next 	match bin 
first returns 	pfx see objects 
quit read 	actually match 
issued know 	candidate point calling 
descriptor eof 	disambiguation hint 
quit cause 	callback hand current 
connection 	candidate replaced 
closed immediately 	earlier candidate pass 
read reply 	disambiguation hint 
quit error 	callback one objects 
eof quit 	match name 
another read 	given make sure 
needed 	one matches 
issued find 	otherwise discovered one 
socket closed 	one previously 
server conditions 	discarded reverse order 
error eof 	would end 
test callback 	showing different 
flags 	results repository need 
test callback 	hard way 
redis context 	need hard way 
privdata shift 	basic time 
detect execution 	number number format 
order test 	query log 
callback 	start accept unambiguous 
flags test 	paths allow 
callback flags 	mean current branch 
privdata test 	reflog asking 
reply callback 	entry approxidate detached 
redis context 	head type 
redis 	dereferences repeatedly cannot 
reply reply 	dereference anymore 
privdata shift 	given type whichever 
detect execution 	comes first 
order test 	means dereference tags 
callback flags 	non tag 
test 	shorthand commit 
callback flags 	commit could used 
privdata reply 	find top 
free reply 	level given commit 
reply redis 	beginning type 
context connect 	name closing brace 
nonblock 	empty point 
reset callback 	syntax look correct 
flags test 	needed barf 
callback flags 	commit foo commit 
redis connect 	regex implementation 
non block 	may reject need 
port 	regex anyway 
test nonblocking 	pattern always matches 
connection redis 	must looking 
context wdone 	something describe output 
test calls 	name name 
command callback 	name name 
command 	name name suffix 
issued connect 	goes without 
nonblock redis 	saying could describe 
command callback 	output something 
test callback 	xxxx interprets names 
redis command 	like initial 
ping 	revision git searching 
test cond 	history returning 
test callback 	first commit whose 
flags redis 	message starts 
free test 	given regular expression 
calls disconnect 	negative matching 
callback 	prefix pattern part 
redis disconnect 	like wip 
connect nonblock 	character beginning pattern 
redis disconnect 	repeat like 
callback test 	foo future extension 
callback redis 	sequences beginning 
disconnect 	reserved remember 
test cond 	update flag allocation 
test callback 	done parse 
flags redis 	syntax number characters 
free test 	parsed successful 
calls disconnect 	otherwise signal error 
callback 	negative parse 
free callback 	something syntax something 
redis free 	make sure 
connect nonblock 	single foo extra 
redis disconnect 	data might 
callback test 	need processing data 
callback 	interpreted cruft 
redis free 	tweak size versus 
callback test 	expanded name 
callback redis 	reads hand syntax 
free test 	evaluates commit 
cond test 	name also act 
callback 	end user 
flags test 	spelled name 
redis buffer 	branch command line 
write empty 	finds name 
write buffer 	nth previous branch 
connect nonblock 	places name 
test 	branch given buf 
cond redis 	returns number 
buffer write 	characters parsed successful 
wdone redis 	branch upstream 
wdone redis 	finds name branch 
free test 	configured merge 
redis 	missing branch defaults 
buffer write 	current branch 
yet connected 	places name branch 
connect nonblock 	given buf 
redis command 	returns number characters 
ping test 	parsed successful 
cond 	input accepted format 
redis buffer 	returns negative 
write redis 	number signal 
err strncmp 	error input branch 
error write 	switches reflog 
redis free 	returns syntax enough 
test 	switches consumed 
redis buffer 	like sha basic 
write closed 	allows sha 
connect nonblock 	expressions notably xyz 
redis command 	parent xyz 
ping redis 	many callers know 
disconnect 	user meant 
test cond 	name commit ish 
redis buffer 	syntactical positions 
write redis 	name appears calling 
err strncmp 	function allows 
error write 	machinery disambiguate shorter 
redis 	unique abbreviated 
free test 	names commit ish 
process callbacks 	others note 
right sequence 	error named 
connect nonblock 	commit ish merely 
redis command 	give hint 
callback 	disambiguation machinery must 
test reply 	called name 
callback ping 	filename doesn exist 
redis command 	must called 
callback test 	stage filename doesn 
reply callback 	exist wrong 
ping 	stage number confusion 
redis command 	relative absolute 
callback test 	filenames die inside 
reply callback 	prefix path 
ping write 	resolved path outside 
output buffer 	worktree sha 
wdone 	path name path 
wdone usleep 	ent sha 
redis buffer 	path name 
write wdone 	absolute path index 
read least 	path name 
one callback 	path relative cwd 
executed 	index path 
replies arrive 	name path index 
single packet 	stage foo 
causing callbacks 	recent commit matching 
executed single 	foo call 
pass test 	function know name 
callback 	given end 
flags redis 	user must name 
buffer read 	doesn function 
redis redis 	may die better 
process callbacks 	diagnostic message 
test cond 	name path doc 
test 	exist head 
callback flags 	given head doc 
redis free 	may chance 
test redis 	diagnose error 
disconnect executes 	shallow.c shallow shallow 
pending callbacks 	stat alternate 
reply 	shallow file path 
connect nonblock 	sha graft 
redis disconnect 	commit buf path 
callback test 	sha heads 
callback redis 	depth shallow flag 
command callback 	shallow flag 
test 	cur depth result 
reply callback 	stack commit 
ping redis 	graft pointer pointer 
disconnect test 	use pack 
cond test 	protocol count flags 
callback flags 	graft data 
redis 	data hex use 
free ignore 	pack protocol 
broken pipe 	extra flags data 
signal error 	use pack 
tests parse 	protocol extra 
command line 	temporary shallow extra 
options 	shallow alternate 
make sure 	shallow file extra 
initialization occurs 	graft show 
prior running 	shallow trace shallow 
tests tests 	info graft 
special may 	info info dst 
use 	bitmap bits 
facilities prior 	slab free end 
triggering initialization 	slab count 
side effect 	info size info 
calling api 	sha head 
safety works 	bitmap bitmap size 
even 	tmp bitmap 
jemalloc constructor 	refs refs refname 
doesn run 	oid flags 
msvc builds 	data commit info 
test count 	bitmap status 
test counts 	info used 
test 	status shallow shallow 
status test 	bitmap size 
name format 	map commits alloc 
format test 	refname oid 
status name 	flags data status 
ret prefix 	bitmap info 
message 	bitmap status bitmap 
start malloc 	dst bitmap 
vcprintf end 	commit die free 
malloc start 	xstrdup xmalloc 
malloc vcprintf 	lookup commit hashcpy 
end malloc 	commit graft 
reached 	git path shallow 
malloc test 	fopen stat 
status nallocx 	validity clear stat 
malloc start 	validity update 
arg end 	fileno fgets 
malloc test 	sha hex die 
status 	shallow fclose 
test status 	deref tag xmalloc 
test status 	parse commit 
malloc cprintf 	die repository shallow 
following lines 	lookup commit 
make testing 	graft commit list 
framework 	insert xmalloc 
testing know 	die stat validity 
chat make 	check git 
sure empty 	path shallow die 
awesome empty 	oid hex 
make sure 	lookup commit oid 
free 	hex packet 
context well 	buf write strbuf 
keep requested 	addstr strbuf 
create dummy 	addch commit graft 
connection inherit 	strbuf addstr 
vararg width 	sha hex 
depends 	strbuf addch write 
type tests 	shallow commits 
make sure 	write shallow commits 
width correctly 	xmks tempfile 
determined format 	git path write 
subsequent varargs 	full die 
correctly 	errno tempfile path 
interpolated reply 	close tempfile 
already contains 	strbuf release tempfile 
multiple items 	path tempfile 
must free 	path hold file 
error valgrind 	update git 
bark 	path shallow check 
doesn happen 	shallow file 
regression test 	update write shallow 
issue git 	commits write 
hub care 	full die errno 
message test 	file path 
multi 	file path 
bulk reply 	strbuf release packet 
reply specifically 	write oid 
test ordering 	hex repository shallow 
reply items 	commit graft 
parse connect 	write shallow commits 
target 	strbuf release 
given config 	hold file update 
find redis 	git path 
version determine 	shallow check shallow 
path next 	file update 
test next 	write shallow commits 
first 	write full 
returns quit 	die errno file 
read issued 	path commit 
know descriptor 	file unlink git 
eof quit 	path shallow 
cause connection 	rollback file strbuf 
closed 	release trace 
immediately read 	key init 
reply quit 	trace key memset 
error eof 	alloc alloc 
quit another 	sha file lookup 
read needed 	commit graft 
issued 	free free trace 
find socket 	key sha 
closed server 	file define commit 
conditions error 	slab realloc 
eof test 	xmalloc mult xmalloc 
callback flags 	paint alloc 
test 	lookup commit reference 
callback redis 	gently memset 
context privdata 	commit list insert 
shift detect 	pop commit 
execution order 	bitmap memcpy memcmp 
test callback 	paint alloc 
flags 	memcpy parse 
test callback 	commit die oid 
flags privdata 	hex bitmap 
test reply 	commit list insert 
callback redis 	max index 
context redis 	indexed free lookup 
reply 	commit reference 
reply privdata 	gently mark parents 
shift detect 	uninteresting trace 
execution order 	key alloc max 
test callback 	index indexed 
flags test 	memset init bitmap 
callback 	head lookup 
flags privdata 	commit paint memset 
reply free 	lookup commit 
reply reply 	bitmap xmemdupz post 
redis context 	assign shallow 
connect nonblock 	clear bitmap free 
reset 	free free 
callback flags 	alloc grow 
test callback 	lookup commit reference 
flags redis 	gently trace 
connect non 	key memset lookup 
block port 	commit bitmap 
test 	update refstatus memset 
nonblocking connection 	head lookup 
redis context 	commit bitmap merge 
wdone test 	bases many 
calls command 	update refstatus free 
callback 	lookup commit 
command issued 	memset head merge 
connect nonblock 	bases many 
redis command 	fetch pack sets 
callback test 	shallow file 
callback redis 	indicator shallow file 
command 	used could 
ping test 	open likely fail 
cond test 	check instead 
callback flags 	repository shallow 
redis free 	sees empty shallow 
test calls 	file repository 
disconnect 	shallow sees empty 
callback redis 	shallow file 
disconnect connect 	mark reachable objects 
nonblock redis 	run prior 
disconnect callback 	reachable commits marked 
test callback 	seen step 
redis 	split sender shallow 
disconnect test 	commits step 
cond test 	clean git shallow 
callback flags 	step non 
redis free 	existent ones getting 
test calls 	pack given 
disconnect 	commit sha walk 
callback free 	parents either 
callback redis 	seen uninteresting bottom 
free connect 	hit bit 
nonblock redis 	bitmap walked 
disconnect callback 	commits freed xxx 
test 	check uninteresting 
callback redis 	pack bitmaps available 
free callback 	step associate 
test callback 	shallow commits refs 
redis free 	info must 
test cond 	initialized calling function 
test 	used info 
callback flags 	shallow bitmaps bit 
test redis 	bitmap needs 
buffer write 	shallow commit info 
empty write 	shallow used 
buffer connect 	updated status ints 
nonblock 	status needs 
test cond 	shallow commits either 
redis buffer 	info info 
write wdone 	prepare commit graph 
redis wdone 	track refs 
redis free 	reach shallow 
test 	commits cut traversal 
redis buffer 	refs connect 
write yet 	old refs force 
connected connect 	updates current 
nonblock redis 	shallow commits mark 
command ping 	potential bottoms 
test 	won bound unreachable 
cond redis 	shallow commits 
buffer write 	removed user supposed 
redis err 	run step 
strncmp error 	every separately trust 
write redis 	step reachability 
free 	test commit level 
test redis 	unreachable shallow 
buffer write 	commits unreachable shallow 
closed connect 	commits step 
nonblock redis 	reachability test 
command ping 	commit level delayed 
redis 	step reachability 
disconnect test 	test commit level 
cond redis 	shell.c arg 
buffer write 	argv arg cvsserver 
redis err 	argv cmd 
strncmp error 	prog home done 
write 	help argv 
redis free 	argv status line 
test process 	prog full 
callbacks right 	cmd rawargs split 
sequence connect 	args argv 
nonblock redis 	code count name 
command 	arg argc 
callback test 	argv prog user 
reply callback 	argv cmd 
ping redis 	count len arg 
command callback 	setup path 
test reply 	dequote die 
callback 	starts die execv 
ping redis 	git cmd 
command callback 	strcmp die setup 
test reply 	path execv 
callback ping 	git cmd strcspn 
write output 	xstrfmt getenv 
buffer 	die chdir die 
wdone wdone 	access run 
usleep redis 	command opt exit 
buffer write 	exit run 
wdone read 	command opt strbuf 
least one 	getline strbuf 
callback 	release strbuf trim 
executed replies 	strbuf detach 
arrive single 	xstrdup split cmdline 
packet causing 	split cmdline 
callbacks executed 	strerror free free 
single pass 	strcmp strcmp 
test 	strcmp strcmp 
callback flags 	strcmp valid cmd 
redis buffer 	name make 
read redis 	cmd run command 
redis process 	opt free 
callbacks test 	free free git 
cond 	setup gettext 
test callback 	git extract argv 
flags redis 	path sanitize 
free test 	stdfds strcmp homedir 
redis disconnect 	access die 
executes pending 	run shell exit 
callbacks 	strcmp die 
reply connect 	xstrdup strncmp isspace 
nonblock redis 	strlen strncmp 
disconnect callback 	exit exec homedir 
test callback 	split cmdline 
redis command 	valid cmd name 
callback 	make cmd 
test reply 	execv free 
callback ping 	free die free 
redis disconnect 	die split 
test cond 	cmdline strerror test 
test callback 	command contains 
flags 	characters interactive login 
redis free 	disabled print 
ignore broken 	help enabled always 
pipe signal 	open file 
error tests 	descriptors avoid clobbering 
parse command 	files die 
line 	also avoids messing 
options make 	pipes dup 
sure initialization 	onto stdin stdout 
occurs prior 	stderr child 
running tests 	processes spawn special 
tests special 	hack pretend 
may 	cvs server 
use facilities 	allow user run 
prior triggering 	interactive shell 
initialization side 	accept modes followed 
effect calling 	cmd arg 
api safety 	cmd limited subset 
works 	git commands 
even jemalloc 	command command dir 
constructor doesn 	accept git 
run msvc 	foo caller said 
builds test.c 	git foo 
host port 	shortlog.c shortlog usage 
timeout 	log author 
path fails 	oneline item mailbuf 
reply keep 	namebuf namelen 
reply config 	maillen namemailbuf ident 
dummy ctx 	dot buffer 
cmd len 	subject eol eob 
argv 	dot len 
lens argc 	taillen log 
config reply 	author oneline log 
cmd len 	commit author 
reader reply 	oneline ctx rev 
ret config 	log commit 
reply 	arg comma defval 
config reply 	ret endp 
reply major 	wrap arg usage 
minor field 	opt arg 
eptr config 	unset log log 
config replies 	argc argv 
num 	prefix log rev 
argc argv 	nongit options 
cfg throughput 	ctx log log 
test inherit 	item onelines 
gettimeofday redis 	msg split ident 
command free 	line strlen 
reply 	map user strbuf 
redis command 	strbuf addf 
free reply 	list insert 
exit redis 	isspace strchr strlen 
command free 	starts strchr 
reply redis 	isspace format subject 
command 	strbuf detach 
free reply 	strlen strstr strlen 
redis free 	memcpy memmove 
keep redis 	xcalloc list append 
free redis 	strbuf getline 
connect redis 	skip prefix skip 
connect 	prefix strbuf 
unix redis 	getline strbuf getline 
connect unix 	insert one 
disconnect redis 	record strbuf release 
connect exit 	strbuf release 
exit database 	log output encoding 
test 	format commit 
redis format 	message pretty print 
command test 	commit format 
cond strncmp 	commit message 
free test 	insert one record 
redis format 	strbuf release 
command 	strbuf release prepare 
test cond 	revision walk 
strncmp free 	die revision shortlog 
test redis 	commit strtoul 
format command 	parse parse parse 
test cond 	error error 
strncmp 	memset read mailmap 
free test 	git config 
redis format 	shortlog init init 
command test 	revisions parse 
cond strncmp 	options start parse 
free test 	options step 
redis 	exit parse revision 
format command 	opt parse 
test cond 	options end 
strncmp free 	setup revisions error 
test redis 	usage options 
format command 	isatty head pending 
test 	isatty read 
cond strncmp 	stdin rev shortlog 
free test 	output strbuf 
redis format 	wrapped text strbuf 
command test 	addch qsort 
cond strncmp 	strbuf reset wrapped 
free 	shortlog msg 
integer width 	fwrite putchar list 
test integer 	clear free 
width test 	strbuf release list 
integer width 	clear clear 
test integer 	mailmap field list 
width 	items contain 
test width 	one two things 
test width 	summary use 
test test 	point list 
redis format 	oneline subjects assigned 
command test 	author summary 
cond 	use need list 
test redis 	need know 
format command 	size abuse pointer 
argv test 	slot store 
cond strncmp 	integer counter macro 
free test 	accesses latter 
redis 	skip leading whitespace 
format command 	including blank 
argv test 	lines discard headers 
cond strncmp 	discard blanks 
free connect 	head tty shortlog.h 
test redis 	list summary 
format 	wrap lines sort 
command test 	number wrap 
cond redis 	user format abbrev 
append formatted 	common repo 
command redis 	prefix email 
reply free 	mailmap log log 
free 	commit log 
reply disconnect 	show-branch.c show branch 
test redis 	usage showbranch 
reader create 	use color args 
redis reader 	idx list 
feed redis 	commit head name 
reader 	generation commit 
reply test 	head name nth 
cond strcasecmp 	name commit 
redis reader 	parent commit name 
free test 	parent name 
redis reader 	list rev name 
create 	num rev 
redis reader 	parents nth newname 
feed redis 	commit seen 
reader feed 	list seen num 
redis reader 	rev extra 
feed redis 	mask revs 
reader 	parents still interesting 
reply test 	commit flags 
cond strcasecmp 	flag changed parents 
redis reader 	commit name 
free test 	pretty pretty str 
redis reader 	name name 
create 	name cnt ver 
redis reader 	bottom top 
feed redis 	refname oid allow 
reader reply 	dups commit 
test cond 	refname oid flag 
strncasecmp redis 	data tmp 
reader 	ofs refname oid 
free test 	flag data 
redis reader 	tmp ofs refname 
create redis 	oid flag 
reader feed 	data match pattern 
redis reader 	match slash 
reply 	cnt refname 
test cond 	oid flag data 
redis reader 	tail slash 
free test 	head remotes orig 
redis reader 	cnt orig 
create redis 	cnt head headlen 
reader 	name head 
feed redis 	sha sha seen 
reader reply 	num rev 
redis reader 	mask revs exit 
feed redis 	status commit 
reader reply 	flags rev num 
test 	rev name 
cond redis 	rev mask commit 
reader free 	flag revkey 
test redis 	saved matches commit 
reader create 	rev flag 
redis reader 	count reflog 
feed 	opt arg unset 
redis reader 	prefix rev 
reply redis 	commit reflog msg 
reader reply 	seen rev 
test cond 	mask num rev 
redis reader 	extra remotes 
free 	mask revs head 
test redis 	head head 
reader create 	len head oid 
redis reader 	merge independent 
feed redis 	name sha name 
reader reply 	shown merge 
test 	point current branch 
cond free 	head topics 
reply redis 	dense reflog builtin 
reader free 	show branch 
test redis 	options oid flags 
connect test 	fake logmsg 
cond 	nth desc 
strcmp strcmp 	msg timestamp head 
strcmp strcmp 	offset revkey 
strcmp redis 	flag head commit 
free test 	flag merge 
redis connect 	point merge mark 
test 	want color 
cond strcmp 	want color xmalloc 
redis free 	name commit 
test redis 	name parent name 
connect unix 	commit name 
test cond 	first parent chain 
redis 	strbuf addstr 
free connect 	strbuf addf strbuf 
test redis 	addf strbuf 
command free 	addch strbuf addf 
reply test 	name commit 
redis command 	strbuf detach name 
free 	first parent 
reply test 	chain commit 
redis command 	list insert interesting 
free reply 	pop commit 
redis command 	mark seen parse 
test cond 	commit mark 
strcmp 	seen commit list 
free reply 	insert date 
test redis 	commit easy starts 
command free 	find unique 
reply redis 	abbrev puts strbuf 
command test 	release find 
free 	digit prefix find 
reply test 	digit prefix 
redis command 	version cmp qsort 
free reply 	lookup commit 
test redis 	reference gently strcmp 
command free 	warning xstrdup 
reply 	starts sha oidcmp 
test free 	append starts 
reply redis 	sha oidcmp 
command free 	append starts append 
reply redis 	count slash 
command redis 	wildmatch starts append 
command 	head starts 
free reply 	append tag append 
test free 	sort range 
reply redis 	sort range hashcmp 
command free 	starts starts 
reply redis 	starts strcmp pop 
command 	commit puts 
free reply 	oid hex puts 
redis command 	oid hex 
redis command 	sha append strchr 
test cond 	strchr strchr 
memcmp memcmp 	count slash error 
strcasecmp 	sort range 
free reply 	die strcmp 
disconnect connect 	config error nonbool 
redis command 	argv push 
strstr strtol 	argv push strcmp 
strlen strtol 	git config 
free 	colorbool git color 
reply test 	config strtoul 
redis command 	error git config 
test cond 	parse options 
strcasecmp redis 	usage options die 
reply free 	resolve refdup 
reply 	die die die 
test cond 	dwim strlen 
strcmp redis 	die strtoul approxidate 
free connect 	read read 
test redis 	strchr xstrfmt show 
timeout test 	date date 
cond 	mode free xstrfmt 
redis reply 	append free 
redis free 	free append 
test redis 	one rev snarf 
connect timeout 	refs resolve 
test cond 	strlen memcpy rev 
test 	head starts 
redis connect 	append one rev 
timeout test 	exit die 
cond redis 	sha die lookup 
free connect 	commit reference 
test free 	die oid hex 
reply 	parse commit 
redis command 	mark seen commit 
malloc usec 	list insert 
redis command 	date revs commit 
usec free 	list sort 
reply free 	date show merge 
malloc 	show independent 
usec redis 	rev head putchar 
command usec 	color code 
free reply 	color reset 
free malloc 	code show one 
redis append 	commit puts 
command 	putchar putchar exit 
usec redis 	sort topological 
reply usec 	order name commits 
free reply 	pop commit 
free malloc 	omit dense color 
redis append 	code color 
command 	reset code putchar 
usec redis 	show one 
reply usec 	commit exceed bits 
free reply 	per rev 
free disconnect 	shift head ancestor 
signal strcmp 	many parents 
strcmp 	away head name 
atoi strcmp 	name commit 
strcmp strcmp 	nth generation ancestor 
exit test 	head name 
format commands 	count first 
test 	parent relationship naming 
reply reader 	purposes parent 
test blocking 	first parent commit 
connection errors 	may name 
test blocking 	generation ancestor head 
connection test 	name commit 
blocking 	nth generation ancestor 
errors test 	generation number 
invalid timeout 	better name already 
errors test 	first give 
append formatted 	names given heads 
commands test 	commits first 
throughput 	parent ancestry chain 
test blocking 	unnamed commits 
connection test 	postprocess complete well 
blocking errors 	poisoning point 
test throughput 	commits seen 
test blocking 	seen list mark 
connection 	anything reached 
following lines 	uninteresting commits interesting 
make testing 	current commit 
framework testing 	either merge already 
know chat 	uninteresting one 
make sure 	mark parents uninteresting 
empty 	commits already 
awesome empty 	parsed reason find 
make sure 	ones avoid 
free context 	adding thing twice 
well keep 	heads foo 
requested create 	tags foo exists 
dummy 	sha would 
connection inherit 	confused heads foo 
vararg width 	tags foo 
depends type 	exists sha would 
tests make 	confused want 
sure width 	allow pattern 
correctly 	hold asterisk show 
determined format 	branches refs 
subsequent varargs 	heads hold show 
correctly interpolated 	refs tags 
reply already 	friends glob style 
contains multiple 	match arg 
items 	passed parse options 
must free 	need mimic 
error valgrind 	real argv bit 
bark doesn 	better commit 
happen regression 	tip named branches 
test issue 	omit otherwise 
git 	merge reachable one 
hub care 	tip interesting 
message test 	nothing specified first 
multi bulk 	listing mode 
reply reply 	incompatible independent merge 
specifically test 	modes asking 
ordering 	reflog mode 
reply items 	make sense list 
parse connect 	also remotes 
target given 	make sense either 
config find 	nothing specified 
redis version 	show branches specified 
determine 	date spec 
path next 	interested adding branch 
test next 	head points 
first returns 	rev uses bit 
quit read 	rev shift 
issued know 	rev uses bit 
descriptor 	rev shift 
eof quit 	rev shift bits 
cause connection 	bit used 
closed immediately 	bookkeeping show list 
read reply 	means list 
quit error 	header lines never 
eof 	need name 
quit another 	sort topologically 
read needed 	give names commits 
issued find 	show-index.c show 
socket closed 	index usage argc 
server conditions 	argv version 
error 	top index offset 
eof test 	entry sha 
callback flags 	crc offset git 
test callback 	setup gettext 
redis context 	usage fread die 
privdata shift 	htonl ntohl 
detect 	die fread die 
execution order 	fread die 
test callback 	ntohl die fread 
flags test 	die ntohl 
callback flags 	sha hex alloc 
privdata test 	fread die 
reply 	fread die fread 
callback redis 	die ntohl 
context redis 	die fread 
reply reply 	die ntohl ntohl 
privdata shift 	sha hex 
detect execution 	ntohl free show-ref.c 
order 	show usage 
test callback 	deref tags show 
flags test 	head tags 
callback flags 	heads found match 
privdata reply 	verify quiet 
free reply 	hash abbrev exclude 
reply 	arg pattern 
redis context 	exclude existing arg 
connect nonblock 	refname oid 
reset callback 	hex refname oid 
flags test 	flag cbdata 
callback flags 	hex peeled match 
redis 	reflen len 
connect non 	refname oid 
block port 	flag cbdata list 
test nonblocking 	match existing 
connection redis 	refs buf matchlen 
context wdone 	len reflen 
test 	opt arg unset 
calls command 	opt arg 
callback command 	unset show options 
issued connect 	argc argv 
nonblock redis 	prefix oid find 
command callback 	unique abbrev 
test 	strcmp starts starts 
callback redis 	strlen strlen 
command ping 	memcmp sha file 
test cond 	die oid 
test callback 	hex show one 
flags redis 	peel find 
free 	unique abbrev list 
test calls 	insert strlen 
disconnect callback 	fgets strlen 
redis disconnect 	strcmp isspace strncmp 
connect nonblock 	check refname 
redis disconnect 	format warning list 
callback 	parse opt 
test callback 	abbrev parse options 
redis disconnect 	exclude existing 
test cond 	die starts read 
test callback 	show one 
flags redis 	die head die 
free 	verify requires 
test calls 	exact match changes 
disconnect callback 	semantics slightly 
free callback 	even quiet detect 
redis free 	error repository 
connect nonblock 	corrupt points nonexistent 
redis 	read anything 
disconnect callback 	refname standard input 
test callback 	strip end 
redis free 	line ignore 
callback test 	match provided head 
callback redis 	match refname 
free 	warn refname well 
test cond 	formed refname 
test callback 	skip ignore refname 
flags test 	exists local 
redis buffer 	repository otherwise output 
write empty 	line use 
write 	full length sha 
buffer connect 	argument sideband.c 
nonblock test 	stream buf suffix 
cond redis 	term skip 
buffer write 	band len brk 
wdone redis 	save band 
wdone 	data packet max 
redis free 	ssz hdr 
test redis 	strlen memcpy getenv 
buffer write 	isatty strcmp 
yet connected 	strlen packet 
connect nonblock 	read memcpy memcpy 
redis 	memcpy memmove 
command ping 	write die xsnprintf 
test cond 	write die 
redis buffer 	xsnprintf write die 
write redis 	write die 
err strncmp 	receive multiplexed output 
error 	stream git 
write redis 	protocol stream input 
free test 	stream remote 
redis buffer 	carries data pkt 
write closed 	line format 
connect nonblock 	band designator demultiplex 
redis 	err error 
command ping 	appropriately band carries 
redis disconnect 	primary payload 
test cond 	things coming 
redis buffer 	band necessarily error 
write redis 	usually informative 
err 	message standard error 
strncmp error 	stream aka 
write redis 	verbose message band 
free test 	signal remote 
process callbacks 	died unexpectedly flush 
right sequence 	concludes stream 
connect 	large enough last 
nonblock redis 	buffer didn 
command callback 	end line print 
test reply 	prefix time 
callback ping 	around look line 
redis command 	insert suffix 
callback 	clear end screen 
test reply 	line line 
callback ping 	found also skip 
redis command 	prefix non 
callback test 	empty must 
reply callback 	present connected remote 
ping 	side send 
write output 	sideband data multiplexed 
buffer wdone 	packet stream 
wdone usleep 	sideband.h stream band 
redis buffer 	data packet 
write wdone 	max sigchain.c old 
read 	alloc signals 
least one 	sig sig sig 
callback executed 	die check 
replies arrive 	signum alloc grow 
single packet 	signal check 
causing callbacks 	signum signal sigchain 
executed 	push sigchain 
single pass 	push sigchain push 
test callback 	sigchain push 
flags redis 	sigchain push sigchain 
buffer read 	pop sigchain 
redis redis 	pop sigchain 
process 	pop sigchain pop 
callbacks test 	sigchain pop 
cond test 	sigchain.h sig sig 
callback flags 	sigchain sliding 
redis free 	windowc file file 
test redis 	gap file 
disconnect 	buf width offset 
executes pending 	len view 
callbacks reply 	width file offset 
connect nonblock 	buffer ferror 
redis disconnect 	error error strerror 
callback test 	buffer skip 
callback 	bytes input error 
redis command 	buffer read 
callback test 	binary input error 
reply callback 	maximum type 
ping redis 	error overflows error 
disconnect test 	check offset 
cond 	overflow check 
test callback 	offset overflow error 
flags redis 	error strbuf 
free ignore 	skip whine strbuf 
broken pipe 	setlen read 
signal error 	fill whine licensed 
tests 	two clause 
parse command 	bsd style license 
line options 	see license 
make sure 	details move overlapping 
initialization occurs 	region place 
prior running 	seek ahead skip 
tests 	gap already 
tests special 	read sliding windowh 
may use 	file width 
facilities prior 	max buf view 
triggering initialization 	width means 
side effect 	unlimited snprintf.c 
calling 	str maxsize format 
api safety 	ret str 
works even 	maxsize format ret 
jemalloc constructor 	copy vsnprintf 
doesn run 	end realloc copy 
msvc builds 	vsnprintf end 
test 	free start git 
count test 	vsnprintf end 
counts test 	size parameter specifies 
status test 	available space 
name format 	includes trailing nul 
format test 	windows vsnprintf 
status 	uses entire buffer 
name ret 	avoids trailing 
prefix message 	nul buffer exactly 
start malloc 	big enough 
vcprintf end 	result defining snprintf 
malloc start 	size corr 
malloc 	therefore reported 
vcprintf end 	buffer size always 
malloc reached 	room trailing 
malloc test 	nul windows nul 
status nallocx 	terminate result 
malloc start 	fills buffer split-index.c 
arg 	istate istate 
end malloc 	data data ret 
test status 	istate istate 
test status 	pos data istate 
test status 	pos data 
malloc cprintf 	istate dst src 
following 	istate istate 
lines make 	alloc ondisk flags 
testing framework 	flags flags 
testing know 	ret istate istate 
chat make 	istate istate 
sure empty 	old xcalloc error 
awesome 	init split 
empty make 	index hashcpy 
sure free 	ewah ewah read 
context well 	mmap error 
keep requested 	ewah ewah read 
create dummy 	mmap error 
connection 	error strbuf ewah 
inherit vararg 	serialize strbuf 
width depends 	ewah serialize strbuf 
type tests 	xcalloc alloc 
make sure 	grow memcpy mark 
width correctly 	index entries 
determined 	die die die 
format subsequent 	die namelen 
varargs correctly 	die copy cache 
interpolated reply 	entry free 
already contains 	mark index entries 
multiple items 	alloc grow 
must 	memcpy ewah bit 
free error 	ewah bit 
valgrind bark 	marked cache 
doesn happen 	entries namelen die 
regression test 	index entry 
issue git 	ewah free ewah 
hub 	free free 
care message 	init split index 
test multi 	ewah ewah 
bulk reply 	strcmp memcmp offsetof 
reply specifically 	offsetof free 
test ordering 	ewah ewah alloc 
reply 	grow alloc 
items parse 	grow init split 
connect target 	index ewah 
given config 	free ewah free 
find redis 	free discard 
version determine 	index free free 
path 	free free 
next test 	keep track shared 
next first 	entries istate 
returns quit 	cache istate 
read issued 	cache entry position 
know descriptor 	stored entry 
eof 	positions start instead 
quit cause 	resrved say 
connection closed 	entry old index 
immediately read 	entries may 
reply quit 	shared istate cache 
error eof 	accept bit 
quit 	leaking code used 
another read 	lived update 
needed issued 	index zero timestamp 
find socket 	disables racy 
closed server 	test write index 
conditions error 	may replay 
eof 	merge recursive update 
test callback 	stages flag 
flags test 	istate cache 
callback redis 	mark matched entry 
context privdata 	positive index 
shift detect 	cache later entries 
execution 	marked eith 
order test 	either matched update 
callback flags 	istate cache 
test callback 	duplicate deduplicate namelen 
flags privdata 	separately shared 
test reply 	disk flags matter 
callback 	take cache 
redis context 	temporarily put entries 
redis reply 	place writing 
reply privdata 	split-index.h sha bitmap 
shift detect 	replace bitmap 
execution order 	saved cache saved 
test 	cache deletions 
callback flags 	replacements refcount istate 
test callback 	istate replace 
flags privdata 	index entry 
reply free 	istate data istate 
reply reply 	istate istate 
redis 	istate istate istate 
context connect 	stat.c mode 
nonblock reset 	perm bits path 
callback flags 	buf buf 
test callback 	path buf isreg 
flags redis 	isdir islnk 
connect 	isblk ischr isfifo 
non block 	issock stat 
port test 	mode git fstat 
nonblocking connection 	mode git 
redis context 	lstat mode git 
wdone test 	stat mode 
calls 	non standard type 
command callback 	bits given 
command issued 	strbuf.c str prefix 
connect nonblock 	strbuf slopbuf 
redis command 	hint res 
callback test 	buf len alloc 
callback 	extra buf 
redis command 	len end str 
ping test 	slen terminator 
cond test 	max ret alloc 
callback flags 	len end 
redis free 	sbs len cmp 
test 	pos len 
calls disconnect 	data dlen pos 
callback redis 	data len 
disconnect connect 	pos len data 
nonblock redis 	len pos 
disconnect callback 	len fmt prefix 
test 	prefix buf 
callback redis 	size prefix next 
disconnect test 	buf size 
cond test 	prefix prefix fmt 
callback flags 	buf incomplete 
redis free 	line fmt 
test 	len format context 
calls disconnect 	percent consumed 
callback free 	placeholder context len 
callback redis 	dst src 
free connect 	len size res 
nonblock redis 	oldalloc hint 
disconnect 	oldlen oldalloc want 
callback test 	got hint 
callback redis 	cnt path hint 
free callback 	oldalloc len 
test callback 	oldalloc guessed len 
redis free 	term term 
test 	term term len 
cond test 	path hint 
callback flags 	len prefix buf 
test redis 	size buf 
buffer write 	len len 
empty write 	reserved reserved buf 
buffer 	bytes path 
connect nonblock 	cwd stat pwd 
test cond 	stat orig 
redis buffer 	len cwd pwd 
write wdone 	fmt ret 
redis 	fmt ret result 
wdone redis 	len fmt 
free test 	buf fmt ret 
redis buffer 	fmt hint 
write yet 	len munged fmt 
connected connect 	sha abbrev 
nonblock 	len line len 
redis command 	skip comments 
ping test 	empties len newlen 
cond redis 	eol strbuf 
buffer write 	grow free strbuf 
redis err 	init strbuf 
strncmp 	grow strbuf 
error write 	init strbuf release 
redis free 	strbuf grow 
test redis 	overflows overflows die 
buffer write 	alloc grow 
closed connect 	strbuf rtrim strbuf 
nonblock 	ltrim isspace 
redis command 	isspace memmove encoding 
ping redis 	reencode len 
disconnect test 	strbuf attach tolower 
cond redis 	memchr xmalloc 
buffer write 	strbuf init strbuf 
redis 	alloc grow 
err strncmp 	alloc grow strbuf 
error write 	release free 
redis free 	free memcmp overflows 
test process 	die die 
callbacks right 	die strbuf grow 
sequence 	memmove memcpy 
connect nonblock 	strbuf setlen 
redis command 	strbuf splice strbuf 
callback test 	splice strbuf 
reply callback 	grow memcpy strbuf 
ping redis 	setlen strbuf 
command 	grow memcpy strbuf 
callback test 	setlen strbuf 
reply callback 	grow memset strbuf 
ping redis 	setlen start 
command callback 	strbuf vaddf end 
test reply 	memchr strbuf 
callback 	addstr strbuf strbuf 
ping write 	complete line 
output buffer 	xsnprintf xsnprintf lines 
wdone wdone 	start strbuf 
usleep redis 	vaddf end strbuf 
buffer write 	commented lines 
wdone 	strbuf release strbuf 
read least 	avail strbuf 
one callback 	grow copy 
executed replies 	vsnprintf end die 
arrive single 	strbuf avail 
packet causing 	strbuf grow vsnprintf 
callbacks 	strbuf avail 
executed single 	die strbuf setlen 
pass test 	strchrnul strbuf 
callback flags 	strbuf addch strbuf 
redis buffer 	addch strlen 
read redis 	strncmp strbuf addstr 
redis 	strbuf addch 
process callbacks 	strbuf addch strbuf 
test cond 	grow fread 
test callback 	strbuf setlen strbuf 
flags redis 	release strbuf 
free test 	grow read full 
redis 	strbuf release 
disconnect executes 	strbuf setlen 
pending callbacks 	strbuf grow strbuf 
reply connect 	grow xread 
nonblock redis 	strbuf setlen strbuf 
disconnect callback 	grow readlink 
test 	strbuf setlen strbuf 
callback redis 	release strbuf 
command callback 	grow getcwd strbuf 
test reply 	setlen strlen 
callback ping 	strbuf release strbuf 
redis disconnect 	reset feof 
test 	strbuf reset getdelim 
cond test 	die strbuf 
callback flags 	init feof strbuf 
redis free 	reset flockfile 
ignore broken 	getc unlocked strbuf 
pipe signal 	avail strbuf 
error 	grow funlockfile strbuf 
tests parse 	getwholeline strbuf 
command line 	setlen strbuf 
options make 	getwholeline strbuf setlen 
sure initialization 	strbuf setlen 
occurs prior 	strbuf getdelim strbuf 
running 	getdelim strbuf 
tests tests 	reset xread strbuf 
special may 	addch open 
use facilities 	strbuf read close 
prior triggering 	lines strcspn 
initialization side 	strbuf strbuf addstr 
effect 	strbuf addstr 
calling api 	strbuf addstr strbuf 
safety works 	addstr isalnum 
even jemalloc 	strbuf grow rfc 
constructor doesn 	unreserved rfc 
run msvc 	reserved strbuf addch 
builds 	strbuf addf 
test.h jemalloc 	strbuf urlencode strlen 
format jemalloc 	strbuf addf 
format name 	strbuf addf 
prefix message 	strbuf addf strbuf 
changes corresponding 	addf die 
changes 	absolute path xgetcwd 
test test 	getenv strcmp 
also necessary 	stat stat strbuf 
use macros 	addstr strbuf 
testhelp.h failed 	addstr dir sep 
tests test 	strbuf addch 
num 	free strbuf addstr 
really minimal 	start vprintf 
testing framework 	end putchar start 
example test 	vfprintf end 
cond check 	putc strlen xmallocz 
test cond 	tolower strbuf 
check 	vaddf strbuf detach 
test report 	start xstrvfmt 
copyright salvatore 	end strbuf grow 
sanfilippo antirez 	strftime strbuf 
gmail dot 	addf strbuf 
rights reserved 	grow strftime strbuf 
redistribution 	release strbuf 
use source 	setlen strbuf grow 
binary forms 	find unique 
without modification 	abbrev strbuf setlen 
permitted provided 	isspace strbuf 
following conditions 	grow memchr cleanup 
met 	memmove strbuf 
redistributions source 	setlen used buf 
code must 	people always 
retain copyright 	buf non buf 
notice list 	nul terminated 
conditions following 	even freshly initialized 
disclaimer 	strbuf empty 
redistributions binary 	buffer small translate 
form must 	slopbuf cannot 
reproduce copyright 	call realloc normally 
notice list 	would called 
conditions following 	xrealloc free 
disclaimer 	memory recover way 
documentation materials 	tell getdelim 
provided distribution 	worse cannot recover 
neither name 	enomem idea 
redis names 	many bytes read 
contributors may 	getdelim dying 
used 	reasonable mirrors xrealloc 
endorse promote 	would catastrophic 
products derived 	memory failure skip 
software without 	opportunity free 
specific prior 	pack memory retry 
written permission 	unlikely help 
software 	malloc small enough 
provided copyright 	hold single 
holders contributors 	line input anyway 
express implied 	restore slopbuf 
warranties including 	moved way 
limited implied 	rounding rounding strftime 
warranties 	reports could 
merchantability fitness 	fit result buffer 
particular purpose 	unfortunately also 
disclaimed shall 	reports requested time 
copyright owner 	takes bytes 
contributors liable 	strategy munge format 
direct 	output contains 
indirect incidental 	least one character 
special exemplary 	drop extra 
consequential damages 	character returning drop 
including limited 	munged space 
procurement substitute 	returns length line 
goods 	without trailing 
services loss 	spaces line ends 
use data 	newline removed 
profits business 	empty lines beginning 
interruption however 	end also 
caused theory 	trailing spaces 
liability 	every line turn 
whether contract 	multiple consecutive 
strict liability 	empty lines paragraphs 
tort including 	one empty 
negligence otherwise 	line input empty 
arising way 	lines spaces 
use 	output produced last 
software even 	line newline 
advised possibility 	end one added 
damage thd.c 	enable skip 
thd proc 	comments skip every 
arg routine 	line starting 
thd 	comment character may 
ret exit 	newline empty 
code thd 	line strbuf.h alloc 
proc arg 	len buf 
thd ret 	strbuf slopbuf strbuf 
create test 	strbuf strbuf 
fail 	strbuf tmp 
wait single 	strbuf len strbuf 
exit code 	strbuf strbuf 
pthread create 	strbuf strbuf strbuf 
test fail 	pos strbuf 
pthread thd.h 	pos len strbuf 
thd 	pos len 
proc arg 	buf size strbuf 
thd ret 	pos len 
abstraction layer 	format context placeholder 
threading tests 	placeholder context 
thread arenac 	dst src buf 
arg 	bytes fmt 
main arena 	fmt fmt fmt 
ind arena 	strbuf strbuf 
ind size 	hint strbuf hint 
err buf 	path hint 
buf arena 	path hint strbuf 
ind 	strbuf strbuf 
size err 	path buf 
thds buf 	skip comments buf 
ret malloc 	skip comments 
ptr free 	suffix terminator max 
mallctl buferror 	str terminator 
test 	max terminator max 
fail mallctl 	terminator strbuf 
buferror test 	sha abbrev len 
fail malloc 	path buffer 
ptr mallctl 	env prefix buf 
buferror test 	size term 
fail 	name name strbuf 
thd create 	reserved fmt 
thd test 	fmt fmt fmt 
thread tcache 	die strbuf 
enabledc config 	avail strbuf grow 
tcache arg 	strbuf strlen 
err 	strbuf grow 
thd mallctl 	strbuf strbuf stripspace 
mallctl mallctl 	strip suffix 
mallctl mallctl 	mem strbuf setlen 
mallctl free 	strbuf split 
malloc mallctl 	buf strlen strbuf 
free 	split buf 
malloc mallctl 	strbuf split max 
free malloc 	strbuf addch 
mallctl free 	strbuf complete strbuf 
malloc mallctl 	meant used 
free malloc 	usual memory given 
test 	length buffer 
skip thd 	known often better 
start thd 	use mem 
create thd 	functions str one 
test run 	memchr strchr 
tests multiple 	though one careful 
times 	fact str 
check bad 	functions often 
interactions timer.c 	stop strbufs may 
timer timer 	embedded strbuf 
timer buf 	nul terminated convenience 
buflen mult 	function strbuf 
round 	api actually relies 
system time 	free strbufs 
file time 	invariants important keep 
sysconf clock 	mind buf 
gettime gettimeofday 	member never used 
system time 	usual operations 
file 	safely strbuf initialized 
time clock 	either strbuf 
gettime gettimeofday 	init strbuf init 
timer usec 	invariants though 
timer usec 	anything buf really 
malloc snprintf 	allocated memory 
malloc 	use strbuf detach 
snprintf malloc 	unwrap memory 
snprintf whole 	buffer strbuf 
fraction timer.h 	shell safe way 
timer timer 	sole supported 
timer buf 	way give malloced 
buflen 	buffer later 
simple timer 	free however totally 
use benchmark 	safe modify 
reporting tsd.c 	anything pointed buf 
ncleanups cleanups 	member indices 
size wrapper 	len inclusive buf 
arg 	member least 
pending arg 	len bytes allocated 
tsd state 	extra used 
hinst dll 	store allowing buf 
fdw reason 	member valid 
lpv reserved 	every strbuf function 
head 	ensure invariant 
block self 	preserved note play 
iter head 	buffer directly 
block malloc 	work way 
cacheline ceiling 	strbuf grow size 
dalloc reached 	strbuf setlen 
tsd 	len size memory 
tsd reached 	starting buf 
tsd boot 	length strbuf avail 
tsd arenas 	sure strbuf 
cache bypassp 	avail least size 
tsd fetch 	note size 
tsd 	must smaller equal 
boot tsd 	strbuf avail 
arenas cache 	safe though done 
bypassp tsd 	many places 
fetch malloc 	adding missing api 
cleanup pthread 	strbuf module 
self 	way warning area 
malloc mutex 	size alloc 
malloc mutex 	even current 
unlock elm 	implementation alloc somehow 
tail insert 	member messed 
malloc mutex 	use strbuf avail 
unlock 	instead data 
malloc mutex 	structures buffer structure 
malloc mutex 	len member 
unlock data 	used determine current 
nothing previous 	length buf 
time destructor 	member provides access 
called 	life cycle 
state tsd 	functions initialize structure 
state purgatory 	second parameter 
destructors wouldn 	zero bigger number 
cause creation 	allocate memory 
tsd time 	want prevent reallocs 
nothing 	release buffer 
request another 	memory used use 
callback another 	buffer function 
destructor deallocated 	unless initialize 
memory destructor 	detach strbuf returns 
called reset 	storage occupies 
state 	responsibility release free 
tsd state 	done attach 
purgatory request 	buffer specify attach 
another callback 	current length 
check whether 	amount allocated memory 
already inserted 	amount must 
list 	larger length pass 
insert block 	supposed nul 
list allocate 	terminated must malloc 
cleanup two 	attaching pointer 
rounds order 	cannot relied upon 
assure jemalloc 	anymore neither 
tsd 	free directly swap 
reinitialization happens 	contents two 
data cleanup 	buffers functions related 
executed arg 	size buffer 
data arg 	determine amount 
thd data 	allocated unused memory 
tsd 	ensure least 
data tsd 	amount unused memory 
reached mallocx 	available len 
ptr dallocx 	used know typical 
data tsd 	size want 
malloc ptr 	avoid repetitive automatic 
data 	resizing underlying 
tsd data 	buffer never needed 
tsd data 	operation critical 
tsd free 	performance cases length 
thd start 	buffer given 
thd create 	function allocate memory 
thd 	perform strbuf 
data tsd 	setlen length larger 
boot test 	len strbuf 
data nothing 	avail strbuf setlen 
previous time 	meant please 
destructor called 	fix invariants 
state 	strbuf messed empty 
tsd state 	buffer setting 
purgatory destructors 	size zero functions 
wouldn cause 	related contents 
creation tsd 	buffer strip whitespace 
time nothing 	beginning ltrim 
request 	end rtrim side 
another callback 	trim replace 
another destructor 	contents strbuf reencoded 
deallocated memory 	form returns 
destructor called 	error success lowercase 
reset state 	character buffer 
tsd 	tolower compare two 
state purgatory 	buffers returns 
request another 	integer less equal 
callback check 	greater zero 
whether already 	first buffer found 
inserted list 	respectively less 
insert 	match greater 
block list 	second buffer adding 
allocate cleanup 	data buffer 
two rounds 	note functions section 
order assure 	grow buffer 
jemalloc tsd 	necessary fail reason 
reinitialization 	memory shortage 
happens tsd.c 	buffer hadn allocated 
ncleanups cleanups 	strbuf strbuf 
size wrapper 	init free single 
arg pending 	character buffer 
arg tsd 	character specified number 
state 	times buffer 
hinst dll 	insert data given 
fdw reason 	position buffer 
lpv reserved 	remaining contents shifted 
head block 	overwritten given 
self iter 	amount data 
head 	given position buffer 
block malloc 	bytes pos 
cacheline ceiling 	pos len replace 
dalloc reached 	given data 
tsd tsd 	nul terminated buffer 
reached tsd 	line prepended 
boot 	comment character blank 
tsd arenas 	data given 
cache bypassp 	length buffer nul 
tsd fetch 	terminated buffer 
tsd boot 	note function always 
tsd arenas 	implemented macro 
cache 	strlen meaning efficient 
bypassp tsd 	write things 
fetch malloc 	like strbuf addstr 
cleanup pthread 	immediate copy 
self malloc 	contents another buffer 
mutex malloc 	end current 
mutex 	one copy 
unlock elm 	part buffer given 
tail insert 	position till 
malloc mutex 	given length end 
unlock malloc 	buffer function 
mutex malloc 	used expand format 
mutex 	containing placeholders 
unlock data 	end parses calls 
nothing previous 	specified function 
time destructor 	every percent sign 
called state 	found callback 
tsd state 	function given pointer 
purgatory 	character pointer 
destructors wouldn 	strbuf expected expanded 
cause creation 	version placeholder 
tsd time 	strbuf newline character 
nothing request 	letter appears 
another 	function returns length 
callback another 	placeholder recognized 
destructor deallocated 	strbuf expand 
memory destructor 	skips format automatically 
called reset 	expanded single 
state tsd 	quoting mechanism callers 
state 	need handle 
purgatory request 	placeholder callback function 
another callback 	invoked placeholder 
check whether 	characters non percent 
already inserted 	skipped ones 
list insert 	copied verbatim strbuf 
block 	callback returned 
list allocate 	zero meaning placeholder 
cleanup two 	unknown percent 
rounds order 	sign copied order 
assure jemalloc 	facilitate caching 
tsd reinitialization 	make possible give 
happens 	parameters callback 
data cleanup 	strbuf expand passes 
executed arg 	context pointer 
data arg 	used programmer 
thd data 	callback sees fit 
tsd data 	used callback 
tsd 	strbuf expand expects 
reached mallocx 	strbuf expand 
ptr dallocx 	dict entry context 
data tsd 	pairs placeholder 
malloc ptr 	replacement needs terminated 
data tsd 	entry placeholder 
data 	append contents one 
tsd data 	strbuf another 
tsd free 	quoting percent signs 
thd start 	percents destination 
thd create 	useful data fed 
thd data 	either strbuf 
tsd 	expand family functions 
boot test 	append given 
data nothing 	size human 
previous time 	readable formatted buffer 
destructor called 	formatted prepended 
state tsd 	comment character blank 
state 	buffer time 
purgatory destructors 	specified formatted strftime 
wouldn cause 	read given 
creation tsd 	size data file 
time nothing 	pointer buffer 
request another 	note buffer rewound 
callback 	read fails 
another destructor 	returned errno must 
deallocated memory 	consulted like 
destructor called 	would read strbuf 
reset state 	read strbuf 
tsd state 	read file strbuf 
purgatory 	getline family 
request another 	functions behaviour well 
callback check 	read contents 
whether already 	given file 
inserted list 	descriptor third argument 
insert block 	used give 
list 	hint file size 
allocate cleanup 	avoid reallocs 
two rounds 	read fails read 
order assure 	undone read 
jemalloc tsd 	contents given file 
reinitialization happens 	descriptor partially 
tsd.h 	one attempt xread 
data state 	third argument 
tsd initializer 	used give hint 
size wrapper 	file size 
arg head 	avoid reallocs returns 
block head 	number bytes 
block 	appended read contents 
arg tsd 	file specified 
tsd fetch 	path third argument 
tsd maximum 	used give 
number malloc 	hint file 
tsd users 	size avoid reallocs 
cleanup 	read target 
functions tls 	symbolic link specified 
tsd agnostic 	path third 
macro implementation 	argument used give 
specific data 	hint size 
five macros 	avoid reallocs read 
support 	line file 
least three 	overwriting existing contents 
use cases 	strbuf strbuf 
file library 	getline family functions 
library inlined 	share signature 
following example 	different line termination 
library 	conventions reading 
tsd variable 	stops terminator eof 
example example 	terminator removed 
define initializer 	buffer returning returns 
jemalloc concat 	unless nothing 
malloc tsd 	left eof 
types 	returns eof uses 
example example 	line terminator 
malloc tsd 	uses nul line 
protos example 	terminator similar 
example malloc 	strbuf getline additionally 
tsd externs 	treats comes 
example 	immediately part terminator 
example example 	friendly version 
malloc tsd 	used read text 
data example 	files come 
example initializer 	platforms whose text 
malloc tsd 	format crlf 
funcs 	terminated like strbuf 
example example 	getline keeps 
initializer example 	trailing terminator buffer 
tsd cleanup 	like strbuf 
result generated 	getwholeline operates 
functions example 	file descriptor reads 
tsd 	one character 
boot example 	time slow use 
example tsd 	unless need 
example tsd 	correct position file 
example val 	descriptor buffer 
note functions 	path current working 
deal 	directory path 
terms type 	buffer converting relative 
rather type 	path absolute 
possible support 	one process symbolic 
non pointer 	links resolved 
types unlike 	strip whitespace buffer 
pthreads 	second parameter 
tsd example 	controls comments considered 
tsd cleanup 	contents removed 
passed type 	temporary topic branches 
pointer cast 	switched use 
means cleanup 	strbuf stripspace 
function 	directly split str 
needs cast 	length slen 
function argument 	specified terminator character 
type dereference 	terminated pointers 
resulting pointer 	strbuf objects holding 
access fields 	substrings substrings 
example 	include terminator last 
tsd cleanup 	substring might 
arg example 	unterminated original end 
example example 	terminator max 
arg example 	positive split max 
want cleanup 	substrings last 
function 	substring containing everything 
called example 	following max 
tsd example 	terminator character form 
example tsd 	strbuf split 
called within 	buf takes arbitrary 
example tsd 	pointer len 
cleanup 	buffer str 
called similar 	variant takes nul 
pthreads tsd 	terminated max 
destruction works 	variant takes strbuf 
pthreads calls 	strbuf split 
cleanup function 	convenience wrapper drop 
non 	max parameter 
malloc tsd 	lighter weight alternatives 
types malloc 	see list 
tsd protos 	split list split 
malloc tsd 	place free 
externs malloc 	terminated list strbufs 
tsd 	example values 
data malloc 	strbuf split functions 
tsd funcs 	abbreviation generated 
initialization cleanup 	find unique abbrev 
nothing initialization 	sha strbuf 
cleanup nothing 	launch user preferred 
initialization 	editor edit 
cleanup trigger 	file fill 
another cleanup 	buffer file contents 
round initialization 	upon user 
cleanup trigger 	completing editing third 
another cleanup 	argument used 
round 	environment editor run 
jemalloc types 	buffer editor 
name type 	launched usual file 
jemalloc structs 	contents read 
jemalloc externs 	buffer upon completion 
trigger cleanup 	append characters 
handler 	converted xml entities 
registration jemalloc 	complete contents 
inlines t 	ensuring either ends 
hashc argv 	character term 
start end 	empty used example 
subject field 	ensure text 
vstr 	ends newline without 
vlen vll 	creating empty 
vptr ret 	blank line 
field field 	content first place 
vstr vlen 	create newly 
vll aux 	allocated format easily 
field 	strbuf provides 
len vstr 	shortcut save lines 
vlen vll 	strbuf strcasestr.c 
aux field 	haystack needle nlen 
vstr vlen 	hlen strlen 
vll aux 	strlen toupper toupper 
field 	streaming.c close 
update fptr 	read filter open 
vptr field 	istream tbl 
deleted fptr 	upstream filter ibuf 
length subject 	obuf end 
fptr vptr 	ptr end ptr 
vstr 	input finished 
vlen vll 	vtbl size 
ret dst 	buf read ptr 
dst vstr 	mapped mapsize 
vlen vll 	hdr hdr avail 
key enc 	hdr used 
dict 	pack pos filtered 
ret field 	buf open 
enc update 	istream feed receive 
incr oldvalue 	receive filtered 
current incr 	vtbl filter ifs 
current aux 	copy status 
field 	loose vtbl total 
ret vstr 	read status 
vlen vll 	window mapped pack 
keyremoved vstr 	non delta 
vlen vll 	vtbl incore vtbl 
flags multiplier 	sha filter 
length 	seek kept result 
count cursor 	buf wrote 
sds encoded 	holeto readlen 
sdslen hash 	open method decl 
type convert 	open method 
encoding encoding 	decl open method 
server 	decl close 
decoded ziplist 	free read git 
index ziplist 	inflate end 
find sdslen 	stream filter stream 
ziplist next 	filter read 
server decr 	istream xmalloc memcpy 
count 	git inflate 
ziplist server 	git inflate end 
server dict 	git inflate 
find dict 	end close deflated 
val hash 	stream munmap 
type ziplist 	unpack sha header 
create 	git inflate 
create hash 	end munmap parse 
type hash 	sha header 
table incr 	strlen memset 
count server 	git inflate init 
panic hash 	use pack 
type 	git inflate unuse 
ziplist sdigits 	pack git 
hash type 	inflate end git 
hash table 	inflate end 
len server 	free memcpy open 
panic hash 	istream free 
type 	stream filter read 
ziplist hash 	istream lseek 
type hash 	write full lseek 
table server 	xwrite close 
panic decoded 	istream copyright google 
decoded ziplist 	inc forward 
index 	declaration inflated size 
ziplist find 	full read 
sdslen ziplist 	fallthru stream filter 
next server 	filter performance 
ziplist ziplist 	common helpers 
insert sdslen 	filtered stream already 
ziplist 	filtered output 
push sdslen 	anything feed filter 
ziplist push 	tell filter 
sdslen decr 	drain upon input 
count decr 	refill input 
count hash 	upstream unknown loose 
type 	stream non 
length hash 	delta packed stream 
type convert 	deltas core 
dict replace 	stream users streaming 
incr count 	streaming.h open 
incr count 	istream git istream 
server 	git istream 
panic decoded 	stream filter seek 
ziplist index 	copyright google 
ziplist find 	inc opaque 
sdslen ziplist 	streaming string-list.c list 
ziplist decr 	strdup list 
count 	exact match right 
dict needs 	cmp middle 
resize dict 	compare insert list 
resize server 	exact match 
panic ziplist 	index list index 
len dict 	list exact 
size 	match list negative 
server panic 	existing index 
zmalloc dict 	exact match index 
iterator server 	list exact 
panic dict 	match list free 
release iterator 	src dst 
zfree 	cmp list data 
server ziplist 	ret list 
index server 	free want data 
ziplist next 	src dst 
ziplist next 	item unused 
server dict 	list free list 
next 	free list 
server panic 	clearfunc text list 
server ziplist 	retval list 
server ziplist 	compare qsort one 
server server 	two list 
dict key 	list cmp list 
dict 	list free 
val hash 	list delim maxsplit 
type current 	count end 
ziplist create 	list delim maxsplit 
create hash 	count end 
type current 	memset cmp entry 
hash 	index realloc 
table incr 	memmove xstrdup entry 
count server 	entry index 
panic lookup 	entry index entry 
key write 	index cmp 
create hash 	free free 
reply 	want free free 
server hash 	filter list 
type init 	free free free 
iterator dict 	clearfunc free 
create hash 	free alloc grow 
type next 	list append 
hash 	nodup xstrdup compare 
type current 	qsort qsort 
encoding hash 	cmp unsorted list 
type current 	lookup free 
encoding dict 	free die list 
server log 	append strchr 
hex 	list append nodup 
dump ziplist 	xmemdupz list 
blob len 	append die list 
server hash 	append strchr 
type release 	list append list 
iterator zfree 	append exact 
server 	match point 
panic hash 	index entry could 
type convert 	inserted returns 
ziplist server 	index already exists 
panic server 	yuck call 
panic hash 	inside list sort 
type 	string-list.h items 
lookup write 	alloc cmp list 
create hash 	strdup text 
type conversion 	list free list 
hash type 	clearfunc list 
encoding hash 	data list free 
type 	want data 
reply signal 	list free list 
modified key 	list negative 
notify keyspace 	existing index list 
hash type 	list sorted 
lookup write 	list free 
create 	list list list 
hash type 	list list 
conversion hash 	list free list 
type exists 	delim maxsplit 
reply hash 	list delim maxsplit 
type encoding 	uses strcmp 
hash 	use function call 
type reply 	custom clear 
signal modified 	function pointer associated 
key notify 	pointer passed 
keyspace reply 	second argument use 
error hash 	function macro 
type 	iterate item apply 
lookup write 	want item 
create hash 	list retaining ones 
type conversion 	function returns 
hash type 	free call free 
encoding hash 	members items 
type 	deleted preserve 
reply signal 	order items retained 
modified key 	empty list 
notify keyspace 	free call free 
reply hash 	members items 
type lookup 	deleted preserve order 
write 	items retained 
create hash 	use functions sorted 
type reply 	lists inserts 
decr count 	given sorted list 
decr count 	already exists 
reply error 	list altered returns 
create 	list item 
hash type 	part checks given 
encoding hash 	part sorted 
type decr 	list part list 
count reply 	coresponding list 
signal modified 	item otherwise first 
key 	consecutive entries 
notify keyspace 	free call 
reply hash 	free members items 
type lookup 	deleted use 
write create 	functions unsorted lists 
hash type 	end list 
reply 	list strdup copied 
decr count 	otherwise list 
decr count 	entry refers input 
create hash 	like list 
type encoding 	append never copied 
hash type 	list strdup 
reply 	function used hand 
bulk signal 	ownership malloc 
modified key 	list without making 
notify keyspace 	extra copy 
create rewrite 	split substrings character 
client command 	delim append 
argument 	substrings list input 
decr count 	modified list 
rewrite client 	strdup must 
command argument 	memory needs allocated 
decr count 	hold substrings 
reply hash 	maxsplit non negative 
type 	split maxsplit 
ziplist reply 	times number substrings 
reply bulk 	appended list 
buffer reply 	examples list split 
bulk hash 	foo bar 
type hash 	baz foo bar 
table 	baz list 
reply reply 	split foo bar 
bulk server 	baz foo 
panic lookup 	bar baz list 
key read 	split foo 
reply check 	bar baz foo 
type 	bar baz 
hash field 	list split foo 
reply lookup 	bar foo 
key read 	bar list 
reply reply 	split list split 
multi bulk 	like list 
len 	split split place 
hash field 	delimiter characters 
reply lookup 	overwritten list items 
key write 	point therefore 
reply check 	must modified freed 
type 	list use 
hash type 	list strdup must 
hash type 	list stripspace.c 
length signal 	buf msg len 
modified key 	stripspace usage 
notify keyspace 	argc argv prefix 
notify 	buf options 
keyspace reply 	strbuf detach strbuf 
lookup key 	commented lines 
read reply 	free parse 
check type 	options usage options 
reply hash 	git config 
type 	strbuf read die 
length lookup 	errno strbuf 
key read 	stripspace comment lines 
reply check 	write die 
type reply 	strbuf release strlcpy.c 
hash type 	dest src 
length 	size ret len 
hash type 	strlen memcpy 
current ziplist 	strtoimax.c nptr endptr 
reply bulk 	strtol strtoll 
buffer reply 	strtoumax.c nptr endptr 
bulk hash 	strtoul strtoull 
type 	submodule--helper.c entries alloc 
current hash 	argc argv 
table reply 	prefix pathspec list 
bulk server 	result matched 
panic lookup 	argc argv 
key read 	prefix pathspec list 
reply 	module list 
check type 	options git submodule 
hash type 	helper usage 
length reply 	argc argv prefix 
multi bulk 	sub path 
len hash 	gitdir url depth 
type 	reference quiet 
init iterator 	argc argv prefix 
hash type 	url depth 
next hash 	quiet submodule dot 
iterator cursor 	git gitdir 
reply hash 	cwd rel path 
iterator 	module clone 
cursor reply 	options git submodule 
hash type 	helper usage 
release iterator 	cmd commands argc 
server hgetall 	argv prefix 
command hgetall 	parse pathspec 
command 	xcalloc read cache 
hgetall command 	die isgitlink 
lookup key 	match pathspec namelen 
read reply 	alloc grow 
check type 	strcmp report path 
reply hash 	error free 
type 	parse options module 
exists parse 	list compute 
scan cursor 	stage sha hex 
reply lookup 	sha hex 
key read 	stage utf usage 
reply check 	gitmodules config 
type 	submodule path die 
scan command 	child process 
copyright salvatore 	init argv push 
sanfilippo antirez 	argv push 
gmail dot 	argv push argv 
rights reserved 	pushl argv 
redistribution 	pushl argv 
use source 	pushl argv push 
binary forms 	argv push 
without modification 	run command parse 
permitted provided 	options strbuf 
following conditions 	addf git dir 
met 	strbuf detach 
redistributions source 	file exists safe 
code must 	create leading 
retain copyright 	directories die clone 
notice list 	submodule die 
conditions following 	safe create leading 
disclaimer 	directories die 
redistributions binary 	strbuf addf unlink 
form must 	warn strbuf 
reproduce copyright 	reset safe create 
notice list 	leading directories 
conditions following 	die strbuf 
disclaimer 	addf strbuf addstr 
documentation materials 	safe create 
provided distribution 	leading directories die 
neither name 	fopen die 
redis names 	errno relative path 
contributors may 	fclose die 
used 	strbuf reset strbuf 
endorse promote 	reset xgetcwd 
products derived 	absolute path strbuf 
software without 	addf free 
specific prior 	strbuf detach strbuf 
written permission 	addf git 
software 	pathdup submodule die 
provided copyright 	git config 
holders contributors 	file relative path 
express implied 	strbuf release 
warranties including 	strbuf release free 
limited implied 	free free 
warranties 	die size 
merchantability fitness 	strcmp die skip 
particular purpose 	entries name 
disclaimed shall 	different stages make 
copyright owner 	sure entry 
contributors liable 	returned write git 
direct 	file submodule 
indirect incidental 	redirect superproject redirect 
special exemplary 	worktree submodule 
consequential damages 	superproject config submodule-config.c 
including limited 	path name 
procurement substitute 	ent config cache 
goods 	cache init 
services loss 	unused unused cache 
use data 	entry cache 
profits business 	iter entry sha 
interruption however 	cache submodule 
caused theory 	hash cache submodule 
liability 	hash removed 
whether contract 	cache submodule 
strict liability 	hash cache gitmodules 
tort including 	sha path 
negligence otherwise 	entry hash key 
arising way 	key config 
use 	cache gitmodules sha 
software even 	name entry 
advised possibility 	hash key key 
damage hash 	config name 
type api 	item subsection key 
check length 	subsection len 
number 	parse cache gitmodules 
objects see 	sha name 
need convert 	submodule name buf 
ziplist real 	opt arg 
hash note 	die error opt 
check encoded 	arg opt 
objects 	arg die error 
length queried 	opt arg 
constant time 	commit sha 
encode given 	name option commit 
objects place 	cache commit 
hash uses 	sha gitmodules sha 
dict 	overwrite data 
ziplist encoded 	submodule item ret 
hash identified 	die error 
field returns 	commit sha gitmodules 
field cannot 	sha rev 
found grab 	ret config cache 
pointer 	commit sha 
fptr points 	path cache commit 
field hash 	sha name 
table encoded 	parameter commit sha 
hash identified 	name commit 
field returns 	sha path strcmp 
field 	hashcmp strcmp 
cannot found 	hashcmp hashmap 
higher level 	init hashmap init 
function hash 	free free 
type always 	free hashmap iter 
returns redis 	init hashmap 
either 	iter next free 
refcount incremented 	one config 
caller retain 	hashmap free hashmap 
reference call 	free memhash 
decr count 	strhash hash sha 
usage lower 	xmalloc hashmap 
level 	entry init hashmap 
function prevent 	put hash 
copy write 	sha hashmap entry 
preferred way 	init hashmap 
read operations 	free hash sha 
higher level 	xmalloc hashmap 
function 	entry init hashmap 
hash type 	hash sha 
length associated 	hashcpy hashmap 
requested field 	entry init hashmap 
field exist 	hash sha 
test specified 	hashcpy hashmap entry 
field 	init hashmap 
exists given 	parse config key 
hash returns 	strbuf strbuf 
field exists 	addstr cache lookup 
doesn element 	name xmalloc 
discard old 	strbuf addstr strbuf 
key 	detach hashcpy 
already exists 	cache git config 
insert update 	maybe strcmp 
function take 	die parse fetch 
care incrementing 	recurse git 
reference count 	config maybe die 
retained 	strcmp strcmp 
fields objects 	die parse push 
grab pointer 	recurse sha 
fptr points 	hex warning 
field insert 	name item lookup 
push field 	create name 
pair 	strcmp config error 
onto tail 	nonbool warn 
ziplist check 	multiple config cache 
ziplist needs 	path free 
converted hash 	xstrdup cache put 
table insert 	path strcmp 
update 	sha warn multiple 
element hash 	config parse 
deleted found 	fetch recurse strcmp 
always check 	config error 
dictionary needs 	nonbool warn multiple 
resize number 	config strcmp 
elements 	strcmp strcmp strcmp 
hash move 	warning free 
next entry 	xstrdup strcmp config 
hash next 	error nonbool 
entry could 	warn multiple 
found err 	config free xstrdup 
iterator 	strbuf release 
reaches end 	strbuf release sha 
initialize cursor 	hashcpy strbuf 
advance cursor 	addf sha hex 
grab pointer 	sha strbuf 
fptr points 	release config config 
field 	cache init 
fptr vptr 	ensure cache init 
point first 	parse config 
next pair 	ensure cache init 
field iterator 	config name 
cursor iterator 	ensure cache init 
hash 	config path 
encoded ziplist 	cache free submodule 
prototype similar 	cache lookup 
hash type 	structure one shared 
ziplist field 	submodule entries 
iterator cursor 	looked sha 
iterator 	blob gitmodule file 
hash encoded 	either path 
ziplist prototype 	name key path 
similar hash 	stores submodule 
type hash 	entries path key 
table non 	name stores 
copy 	submodule entries name 
write friendly 	key thin 
higher level 	wrapper needed insert 
version hash 	submodule entries 
type current 	hashmap iterate name 
returns incremented 	hash symmetric 
refcount 	allocation submodule entries 
caller decr 	allocated gitmodule 
count reference 	blob sha submodule 
retained nothing 	name simple 
hash type 	pushing also 
commands always 	ensures parse submodule 
replicate 	entries parsing 
hincrbyfloat hset 	worktree configurations die 
command order 	early lookup 
make sure 	submodule configuration name 
differences pricision 	path key 
formatting create 	demand reading appropriate 
differences 	gitmodules revisions 
replicas aof 	parameter cache pointer 
restart abort 	first submodule 
key cannot 	used check whether 
found non 	submodules parsed 
existing keys 	fill submodule config 
empty 	cache submodule-config.h 
hashes hmget 	path name url 
respond series 	fetch recurse 
bulks t 	ignore gitmodules sha 
listc subject 	opt arg 
pos len 	opt arg 
data 	commit sha name 
subject vlong 	commit sha 
subject subject 	path submodule entry 
index direction 	containing information 
iter direction 	certain submodule certain 
entry entry 	revision sha 
entry 	blob responsible gitmodules 
str len 	file submodule 
entry iter 	config submodule.c config 
entry subject 	fetch recurse 
enc zlen 	submodules changed submodule 
depth pushed 	paths initialized 
lobj 	fetch tips tips 
refval val 	fetch tips 
subject iter 	fetch gitmodules unmerged 
entry inserted 	gitmodules modified 
index entry 	oldpath newpath entry 
index replaced 	submodule path 
start 	sect submodule 
end llen 	path objects directory 
rangelen iter 	alt odb 
entry start 	ret alloc diffopt 
end llen 	path submodule 
ltrim rtrim 	work gitmodules path 
subject 	pos diffopt 
obj toremove 	arg rev path 
removed entry 	left right 
dstkey dstobj 	fast forward fast 
sobj dobj 	backward merge 
touchedkey keys 	bases list rev 
numkeys 	line prefix 
timeout target 	del reset format 
retval key 	commit ctx 
key receiver 	path line prefix 
key dstkey 	one two 
argv dstobj 	dirty submodule meta 
clients 	del reset 
numclients clientnode 	rev right 
receiver dstkey 	message fast backward 
timeout timeout 	refname oid 
key decoded 	flags data path 
sdslen quicklist 	sha argv 
push 	buf needs pushing 
decr count 	options data 
server panic 	needs pushing commit 
create quicklist 	needs pushing 
pop custom 	rev sha remotes 
create server 	name needs 
panic 	pushing rev commit 
quicklist count 	argv argc 
server panic 	sha copy remotes 
zmalloc quicklist 	arg path 
iterator idx 	argv sha remotes 
server panic 	name ret 
zfree 	needs pushing 
zfree server 	path path sha 
quicklist next 	present argv 
server panic 	buf options data 
create create 	path oid 
server panic 	flags data sha 
decoded 	sha data 
sdslen quicklist 	rev commit argv 
insert quicklist 	parent diff 
insert decr 	opts count args 
count server 	work prefix 
panic server 	command line option 
info 	quiet result 
sds encoded 	err data task 
quicklist compare 	ret spf 
sdslen server 	submodule path submodule 
panic quicklist 	git dir 
del entry 	submodule prefix git 
server 	dir argv 
panic server 	submodule err 
info server 	task spf retvalue 
info quicklist 	err task 
create ziplist 	spf options prefix 
server panic 	command line 
lookup 	option quiet max 
key write 	parallel jobs 
reply encoding 	spf path ignore 
create quicklist 	untracked len 
quicklist options 	argv buf dirty 
list type 	submodule line 
push 	next line git 
reply list 	dir path 
type length 	argv buf git 
signal modified 	dir path 
key notify 	len argv buf 
keyspace push 	result path 
command 	merges commit contains 
push command 	another merged 
lookup key 	revision rev 
write reply 	args revs rev 
check type 	opts commit 
list type 	ctx result path 
init 	search commit 
iterator list 	commit commit parent 
type next 	count merges 
list type 	work git dir 
equal list 	file name 
type insert 	rel path real 
list 	work file 
type release 	exists die submodule 
iterator signal 	path warning 
modified key 	strbuf addstr strbuf 
notify keyspace 	addstr strbuf 
reply list 	addstr git config 
type 	file gently 
push signal 	warning strbuf release 
modified key 	strbuf release 
notify keyspace 	file exists 
reply list 	die submodule path 
type length 	warning strbuf 
encoding 	addstr strbuf addstr 
pushx command 	git config 
encoding pushx 	rename section file 
command encoding 	warning strbuf 
strcasecmp pushx 	release strbuf release 
command strcasecmp 	file cache 
pushx 	die strbuf git 
command reply 	path submodule 
lookup key 	directory prepare alt 
read reply 	odb strncmp 
check type 	xmalloc xsnprintf read 
reply list 	info alternates 
type 	strbuf release submodule 
length lookup 	path handle 
key read 	ignore submodules 
reply check 	arg diff opt 
type reply 	starts parse 
quicklist index 	submodule config option 
create 	strcmp parse 
create reply 	fetch recurse submodules 
bulk decr 	arg git 
count reply 	work strbuf addstr 
server panic 	strbuf addstr 
lookup key 	read cache die 
write 	cache name 
reply check 	pos namelen memcmp 
type reply 	lstat match 
quicklist replace 	stat git config 
index sdslen 	file strbuf 
reply reply 	release diff opt 
signal 	clr diff 
modified key 	opt clr diff 
notify keyspace 	opt clr 
server panic 	strcmp diff 
lookup key 	opt strcmp diff 
write reply 	opt strcmp 
check 	diff opt strcmp 
type list 	die init 
type pop 	revisions setup revisions 
reply reply 	pending pending 
bulk decr 	merge bases pending 
count notify 	oid hex 
keyspace 	prepare revision walk 
list type 	revision log 
length notify 	output encoding strbuf 
keyspace signal 	setlen strbuf 
modified key 	addstr strbuf addstr 
pop 	strbuf addstr 
command pop 	format commit message 
command reply 	strbuf addstr 
reply lookup 	strbuf addch strbuf 
key read 	release sha 
reply check 	submodule odb 
type 	sha lookup commit 
list type 	reference lookup 
length reply 	commit reference prepare 
reply multi 	submodule summary 
bulk len 	hashcmp strbuf release 
list type 	strbuf addf 
init 	find unique abbrev 
iterator list 	strbuf addch 
type next 	strbuf addf find 
reply bulk 	unique abbrev 
buffer reply 	strbuf addf strbuf 
bulk list 	addf fwrite 
type 	print submodule summary 
release iterator 	clear commit 
server panic 	marks clear commit 
reply reply 	marks strbuf 
lookup key 	release submodule odb 
write reply 	lookup commit 
check 	reference remote 
type list 	submodule sha hex 
type length 	start command 
quicklist del 	die sha hex 
range quicklist 	strbuf read 
del range 	finish command close 
server 	strbuf release 
panic notify 	isgitlink submodule needs 
keyspace list 	pushing list 
type length 	insert init revisions 
notify keyspace 	diff combined 
signal modified 	merge size strbuf 
key 	addf init 
reply reply 	revisions xstrdup sha 
lookup key 	hex setup 
write reply 	revisions prepare revision 
check type 	walk die 
list type 	revision find unpushed 
init 	submodule commits 
iterator list 	reset revision 
type init 	walk free strbuf 
iterator list 	release submodule 
type next 	odb remote submodule 
list type 	run command 
equal 	close find unpushed 
list type 	submodules push 
list type 	submodule list clear 
release iterator 	submodule odb 
signal modified 	lookup commit reference 
key notify 	sha hex 
keyspace 	capture command strbuf 
list type 	release isgitlink 
length notify 	isgitlink unsorted list 
keyspace reply 	lookup submodule 
create quicklist 	commit present list 
quicklist options 	append xstrdup 
signal 	sha append 
modified key 	sha append argv 
list type 	push sha 
push notify 	hex submodule path 
keyspace reply 	init revisions 
bulk lookup 	argv push sha 
key 	unique argv 
write reply 	push sha unique 
check type 	setup revisions 
list type 	prepare revision walk 
length reply 	die revision 
lookup key 	diff setup diff 
write 	opt diff 
check type 	setup done diff 
list type 	sha diffcore 
pop incr 	std diff flush 
count rpoplpush 	argv clear 
handle push 	sha clear sha 
decr 	clear isgitlink 
count notify 	submodule path 
keyspace list 	submodule name unsorted 
type length 	list lookup 
notify keyspace 	unsorted list lookup 
signal modified 	unsorted list 
key 	lookup strbuf addf 
decr count 	strbuf addf 
incr count 	strbuf addf read 
dict incr 	gitfile directory 
count dict 	child process init 
find list 	strbuf detach 
create 	strbuf addf argv 
dict incr 	init argv 
count server 	pushv argv push 
info dict 	argv push 
val list 	argv push strbuf 
node tail 	release strbuf 
block 	release strbuf release 
client server 	git work 
info dict 	read cache 
size dict 	die argv push 
iterator dict 	argv push 
next dict 	argv push calculate 
key 	changed submodule 
dict fetch 	paths run processes 
server info 	parallel argv 
list del 	clear list clear 
node list 	strbuf addf 
search key 	read gitfile directory 
list 	strbuf release 
length dict 	strbuf reset start 
dict release 	command die 
iterator dict 	strbuf read strchr 
empty decr 	close finish 
count dict 	command die strbuf 
find 	release strbuf 
dict find 	addf read gitfile 
zmalloc incr 	strbuf release 
count list 	strbuf release 
node tail 	run command file 
incr count 	exists empty 
server 	dir submodule uses 
dict propagate 	gitfile start 
reply multi 	command die strbuf 
bulk len 	read close 
reply bulk 	finish command die 
reply bulk 	strbuf release 
lookup 	memset memset snprintf 
key write 	oid hex 
check type 	init revisions setup 
propagate rpoplpush 	revisions size 
handle push 	prepare revision walk 
propagate list 	die revision 
length 	merge bases reset 
list create 	revision walk 
list length 	merge bases 
list first 	free format commit 
dict lookup 	message strbuf 
key write 	release hashcpy sha 
dict 	sha sha 
find dict 	submodule odb merge 
val list 	warning lookup 
length list 	commit reference lookup 
first list 	commit reference 
type pop 	lookup commit reference 
incr 	merge warning 
count unblock 	merge bases merge 
client serve 	bases merge 
client blocked 	warning merge bases 
list list 	hashcpy merge 
type push 	bases hashcpy find 
decr 	first merges 
count decr 	merge warning merge 
count list 	warning print 
type length 	commit oid 
decr count 	hex merge warning 
zfree list 	print commit 
del 	free xstrdup real 
node list 	path strbuf 
release timeout 	addf write file 
reply lookup 	relative path 
key write 	strbuf reset strbuf 
reply list 	addf git 
type 	config file relative 
length list 	path strbuf 
type pop 	release strbuf release 
server reply 	free following 
multi bulk 	flag gitmodules file 
len reply 	unmerged disable 
bulk 	recursion submodules git 
reply bulk 	config doesn 
decr count 	matching config entry 
notify keyspace 	guess might 
list type 	configured gitmodules 
length notify 	unless user resolves 
keyspace 	conflict command 
signal modified 	line option given 
key rewrite 	always overrides 
client command 	configuration flag ignored 
vector reply 	flag gitmodules 
block keys 	file unstaged modifications 
blocking 	startup must 
pop command 	allowing modifications gitmodules 
blocking pop 	file intention 
command timeout 	stage later continuing 
reply lookup 	would stage 
key write 	modifications user didn 
reply 	stage might 
block keys 	change future version 
reply server 	learn stage 
info list 	changes without staging 
type length 	previous modifications 
rpoplpush command 	update path 
copyright 	entry submodule name 
salvatore sanfilippo 	section gitmodules 
antirez gmail 	file gitmodules file 
dot rights 	found section 
reserved redistribution 	correct path oldpath 
use source 	setting found 
binary 	could update nothing 
forms without 	without gitmodules 
modification permitted 	maybe user already 
provided following 	error submodule 
conditions met 	name section gitmodules 
redistributions source 	given path 
code 	configured gitmodules file 
must retain 	found section 
copyright notice 	correct path path 
list conditions 	setting found 
following disclaimer 	could nothing without 
redistributions binary 	gitmodules maybe 
form 	user already 
must reproduce 	error avoid adding 
copyright notice 	twice sha 
list conditions 	possible alternates submodule 
following disclaimer 	gitmodules found 
documentation materials 	isn merged gitmodules 
provided 	succeeded setting 
distribution neither 	walk even submodule 
name redis 	commit present 
names contributors 	make sure reachable 
may used 	needswork honor 
endorse promote 	name configured gitmodules 
products 	file commit 
derived software 	examining able correctly 
without specific 	follow submodules 
prior written 	moved around submodule 
permission software 	moved needswork 
provided copyright 	git directories 
holders 	submodules live inside 
contributors express 	superprojects git 
implied warranties 	directory day fetch 
including limited 	submodules directly 
implied warranties 	location config options 
merchantability fitness 	request need 
particular 	check submodules configured 
purpose disclaimed 	argv program 
shall copyright 	name collect submodules 
owner contributors 	whether commits 
liable direct 	recorded upstream changed 
indirect incidental 	submodule paths 
special 	submodule prefix added 
exemplary consequential 	later submodule 
damages including 	modified test nested 
limited procurement 	submodules use 
substitute goods 	gitfile revisions merge 
services loss 	commit save 
use 	revisions list 
data profits 	contain got merges 
business interruption 	contain prune 
however caused 	merges contain another 
theory liability 	found merge 
whether contract 	save result store 
strict 	result fail 
liability tort 	handle deletion conflicts 
including negligence 	check whether 
otherwise arising 	changes forward contained 
way use 	vice versa 
software even 	one merges contain 
advised 	submodule one 
possibility damage 	present suggestion user 
list api 	marked unmerged 
function pushes 	user needs confirm 
element specified 	resolution skip 
list subject 	search makes sense 
head 	calling context 
tail position 	find commit 
specified need 	merges update gitfile 
caller increment 	core worktree 
refcount function 	setting connect work 
takes care 	git dir 
needed 	update gitfile update 
initialize iterator 	core worktree 
specified index 	setting submodule.h oldpath 
list head 	newpath path 
means start 	diffopt path diffopt 
tail move 	path line 
towards 	prefix one two 
head list 	dirty submodule 
tail means 	meta del reset 
start head 	sha options 
move towards 	prefix command line 
tail clean 	option quiet 
iterator 	max parallel jobs 
stores pointer 	path ignore 
current entry 	untracked path 
provided entry 	path result path 
structure advances 	search sha 
position iterator 	remotes name needs 
returns 	pushing sha 
current entry 	remotes name work 
fact entry 	git dir 
otherwise protect 	svn-fe.c argc argv 
converting iterating 	svndump init 
entry current 	svndump read svndump 
position 	deinit svndump 
iterator compare 	reset file domain 
given entry 	may freely 
current position 	use modify distribute 
element pointed 	relicense svndiff.c 
create quicklist 	instructions data ctx 
single 	input delta 
ziplist list 	delta len 
commands seek 	buf len len 
refval head 	magic result 
tail notify 	len buf result 
client failed 	end pos 
insert 	result len val 
convert negative 	result len 
indexes invariant 	val ctx instructions 
start test 	nbytes insns 
end range 	end offset ctx 
empty start 	instructions nbytes 
end 	instructions end offset 
start length 	ctx data 
result form 	pos nbytes pos 
multi bulk 	buf end 
reply convert 	result ctx instructions 
negative indexes 	data pos 
invariant 	instruction insns end 
start test 	nbytes ctx 
end range 	instructions data 
empty start 	pos delta delta 
end start 	len preimage 
length range 	ctx len instructions 
start 	len data 
start end 	len delta delta 
result empty 	len preimage 
list list 	postimage pre pre 
elements perform 	len strbuf 
trim semantic 	release strbuf release 
command 	strbuf release 
rpoplpush srclist 	fwrite error strerror 
dstlist llen 	buffer ferror 
srclist element 	error strerror error 
rpop srclist 	strbuf reset 
lpush dstlist 	buffer read binary 
element 	error read 
element nil 	read chunk strbuf 
end end 	release memcmp 
idea able 	strbuf release 
element list 	error strbuf release 
reliable way 	buffer read 
since 	error read error 
element returned 	read maximum 
pushed another 	type error read 
list well 	error parse 
command originally 	overflows error strbuf 
proposed ezra 	parse error 
zygmuntowicz 	strbuf addch overflows 
create list 	error strbuf 
key exist 	parse parse first 
always send 	operand copyfrom 
pushed client 	source copyfrom target 
may happen 	copyfrom data 
loading 	error execute one 
old rdb 	instruction error 
files recent 	window init read 
versions redis 	length read 
keys empty 	length read 
lists saved 	length read chunk 
touched 	read chunk 
key protect 	strbuf grow apply 
since rpoplpush 	window core 
handle push 	error write strbuf 
may change 	window release 
client command 	read magic read 
argument 	offset read 
vector currently 	length move window 
list type 	apply one 
pop returns 	window licensed two 
refcount incremented 	clause bsd 
source list 	style license see 
empty 	license details 
blocking pop 	svndiff applier see 
operations current 	http svn 
blocking pop 	apache repos 
works use 	asf subversion trunk 
blpop example 	notes svndiff 
user 	svndiff svn window 
calls blpop 	window instructions 
key exists 	data instructions instruction 
contains non 	instruction view 
empty list 	selector copyfrom data 
lpop called 	packed view 
instead 	selector packed copyfrom 
blpop semantically 	data view 
lpop blocking 	selector copyfrom source 
required instead 	copyfrom target 
blpop called 	copyfrom source binary 
key exists 	copyfrom target 
list 	binary copyfrom data 
empty need 	binary packed 
block order 	view selector view 
notification data 	selector bit 
read client 	packed copyfrom 
socket serve 	data copyfrom data 
requests 	bit highdigit 
blocking request 	lowdigit highdigit binary 
served also 	bit lowdigit 
put client 	bit success immediate 
dictionary blocking 	operand fill 
keys mapping 	ctx buf data 
keys 	source target 
list clients 	data views source 
blocking keys 	view offset 
push operation 	length already handled 
key blocked 	window svndiff.h 
clients waiting 	delta delta len 
performed 	preimage postimage 
mark key 	svndump.c input action 
ready current 	src rev 
command multi 	type prop length 
exec block 	text length 
script executed 	src dst 
serve 	text delta prop 
clients waiting 	delta revision 
list one 	timestamp log author 
blocked first 	note version 
last accordingly 	uuid url fname 
number elements 	revision url 
ready 	key buf val 
list client 	type key 
blocking mode 	keylen key val 
specified key 	type len 
specified timeout 	type type props 
key already 	text empty 
exists 	blob old data 
dict ignore 	old mode 
side map 	mode remote note 
keys clients 	mark url 
every key 	local notes val 
take list 	active ctx 
clients 	len end 
blocked unblock 	len report filename 
client waiting 	back strbuf 
blocking operation 	reset strbuf reset 
blpop never 	strbuf addstr 
call 	strbuf reset strbuf 
function directly 	reset strbuf 
unblock client 	reset strbuf reset 
instead client 	strbuf addstr 
may wait 	strbuf reset constcmp 
multiple keys 	die strbuf 
unblock 	swap constcmp strbuf 
every key 	reset strbuf 
client list 	swap constcmp die 
clients waiting 	parse date 
key list 	basic warning strlen 
empty need 	constcmp strlen 
avoid 	constcmp die strlen 
wasting memory 	buffer ferror 
cleanup client 	die errno 
structure specified 	die buffer read 
key clients 	line strcmp 
blocked waiting 	die atoi strbuf 
list 	reset buffer 
pushes function 	read binary die 
put key 	read buffer 
reference server 	read die read 
ready keys 	die strbuf 
list note 	swap handle handle 
ready 	strbuf reset 
keys hash 	die die repo 
table allows 	repo repo 
avoid putting 	copy die die 
key list 	repo read 
multiple pushes 	path die die 
made 	die die 
script context 	read props 
multi exec 	fast export modify 
list processed 	fast export 
handle clients 	modify fast export 
blocked lists 	data fast 
clients 	export modify fast 
blocking key 	export blob 
need queue 	delta fast export 
key already 	begin commit 
signaled need 	fast export end 
queue need 	commit fast 
queue 	export begin note 
key server 	strbuf addf 
ready keys 	fast export note 
also key 	fast export 
ready keys 	buf data reset 
dictionary order 	dump ctx 
avoid 	buffer read line 
adding multiple 	strchr constcmp 
times list 	atoi die 
simple check 	constcmp strbuf reset 
helper function 	strbuf addstr 
handle clients 	constcmp handle node 
blocked 	begin revision 
lists work 	end revision reset 
serve specific 	rev ctx 
client receiver 	atoi strbuf addf 
blocked key 	constcmp constcmp 
context specified 	strlen handle node 
following 	begin revision 
provide client 	reset node ctx 
element dstkey 	strbuf addf 
serving brpoplpush 	constcmp strlen strbuf 
also push 	addf strcmp 
element destination 	strcmp constcmp strbuf 
list 	addf strcmp 
lpush side 	strcmp strcmp strcmp 
command propagate 	constcmp strbuf 
resulting brpop 	reset strbuf 
blpop additional 	addstr strbuf addf 
lpush aof 	constcmp atoi 
replication 	strbuf addf constcmp 
channel argument 	constcmp constcmp 
list tail 	strtoumax isdigit die 
list head 	maximum type 
indicates element 	die constcmp strcmp 
popped fron 	constcmp strcmp 
head 	constcmp atoi buffer 
blpop tail 	read line 
brpop propagate 	die read die 
command properly 	read props 
function returns 	handle node buffer 
able serve 	skip bytes 
client 	die read buffer 
otherwise err 	ferror die 
returned signal 	read handle node 
caller list 	begin revision 
pop operation 	end revision 
undone client 	fast export init 
served 	strbuf init 
happens brpoplpush 	strbuf init strbuf 
fails push 	init strbuf 
destination key 	init strbuf init 
wrong type 	strbuf init 
propagate pop 	strbuf init reset 
operation 	dump ctx 
brpop blpop 	reset rev ctx 
brpoplpush propagate 	reset node 
rpop operation 	ctx buffer init 
propagate lpush 	error strerror 
operation brpoplpush 	init buffer fdinit 
failed 	xdup error 
wrong destination 	strerror init xdup 
type function 	fast export 
called redis 	deinit reset 
every time 	dump ctx reset 
single command 	rev ctx 
multi 	reset node ctx 
exec block 	strbuf release 
lua script 	strbuf release strbuf 
terminated execution 	release strbuf 
called client 	release strbuf release 
keys least 	buffer deinit 
one 	ferror strbuf release 
client blocked 	strbuf release 
received least 	strbuf release strbuf 
one element 	release parse 
via push 	rearrange svnadmin dump 
operation accumulated 	create dump 
server 	svnadmin dump incremental 
ready keys 	startrev endrev 
list function 	repository outfile licensed 
run list 	two clause 
serve clients 	bsd style 
accordingly note 	license see license 
function 	details compare 
iterate result 	start equal length 
serving brpoplpush 	must guarded 
blocking clients 	length test states 
serve push 	dump metadata 
side brpoplpush 	revision metadata node 
point 	metadata nodes 
server ready 	needswork support simple 
keys fresh 	mode changes 
list save 	like svn special 
current one 	svn executable 
locally way 	keep track whether 
run 	mode reset 
old list 	plain file keeping 
free call 	track symlink 
signal list 	executable bits separately 
ready may 	instead discard 
push elements 	trailing newline 
server 	old text node 
ready keys 	directory bug 
handling clients 	empty blob empty 
blocked brpoplpush 	dataref data 
first key 	retrievable fast find 
ready keys 	old content 
safely 	old data decide 
call signal 	mode adjust 
list ready 	mode reflect properties 
key key 	save result 
exists list 	directories tracked fast 
serve blocked 	export functions 
clients 	means empty revision 
data serve 	gets git 
clients order 	commit strlen key 
blocked key 	svndump.h filename 
first blocked 	back url local 
last protect 	notes symbolic-ref.c 
receiver 	git symbolic 
bpop target 	usage head quiet 
freed next 	shorten print 
unblock client 	sha flag refname 
call failed 	argc argv 
serving client 	prefix ret msg 
need 	options resolve 
also undo 	die die shorten 
pop operation 	unambiguous puts 
call signal 	git config parse 
modified key 	options die 
already called 	usage options check 
element 	symref die 
pushed list 	check symref strcmp 
free item 	starts die 
list place 	create symref usage 
point blocking 	options symlinks.c 
rpop lpop 	cache name 
non 	len cache name 
empty list 	len prefix 
like non 	len name len 
normal pop 	name len 
replicate pop 	previous slash max 
instead pop 	len cache 
inside 	cache cache name 
multi exec 	len ret 
list empty 	flags track flags 
thing treating 	prefix len 
timeout even 	stat func match 
timeout list 	len last 
empty 	slash last slash 
key exists 	dir previous 
must block 	slash save flags 
blocking empty 	ret cache 
list multi 	name len track 
state returns 	flags prefix 
immediately 	len stat 
list empty 	func flags cache 
client blocks 	name len 
list exists 	name len name 
elements regular 	len cache 
rpoplpush command 	name len flags 
executed 	match len 
t setc 	name len prefix 
setkeys setnum 	len cache 
dstkey subject 	name len prefix 
llval success 	len removal 
setobj llval 	len name len 
success 	match len 
subject llval 	last slash previous 
subject objele 	slash strbuf 
llele intele 	reset reset lstat 
objele encoding 	cache longest 
setobj objele 	path match strbuf 
llele 	grow stat 
subject setobj 	lstat isdir 
enc intele 	islnk reset lstat 
element added 	cache lstat 
keyremoved srcset 	cache matchlen lstat 
dstset ele 	cache threaded 
count 	symlink leading path 
size propargv 	threaded check 
objele encoding 	leading path lstat 
llele remaining 	cache matchlen 
newset ele 	threaded dirs path 
aux llele 	lstat cache 
encoding 	rmdir longest path 
count size 	match scheduled 
uniq ele 	dirs strbuf scheduled 
llele encoding 	dirs returns 
retval added 	length path component 
ele llele 	basis longest 
encoding 	common prefix match 
setkeys setnum 	name name 
dstkey sets 	name substring 
eleobj dstset 	name way around 
intobj replylen 	name name 
cardinality encoding 	exact track flags 
setobj 	prefix len 
deleted setkeys 	stat func members 
setnum dstkey 	safeguard rule 
sets ele 	inside lstat cache 
dstset cardinality 	check name 
diff algo 	name length len 
setobj 	symlink leading 
algo two 	component directory exists 
work deleted 	real speed 
cursor representable 	check information allowed 
create intset 	cached indicated 
create dict 	track flags argument 
incr 	also used 
count representable 	indicate check full 
intset intset 	path prefix 
len type 	len stat 
convert type 	func parameter used 
convert server 	length prefix 
info 	cache use stat 
dict incr 	function instead 
count server 	lstat function test 
panic dict 	path component 
needs resize 	safeguard rule clear 
dict resize 	cache values 
representable 	track flags prefix 
intset server 	len stat 
panic dict 	func match last 
find representable 	supplied values 
intset find 	check see match 
server panic 	cache excluding 
zmalloc 	path types match 
dict iterator 	len would 
server panic 	know matched 
dict release 	part always directory 
iterator zfree 	also tracking 
dict next 	directories name substring 
dict 	cache path 
key intset 	component basis immediately 
server panic 	okay match 
type next 	cache far check 
create incr 	rest path 
count server 	components end update 
panic 	cache note 
dict random 	max different path 
key dict 	types noent 
key intset 	symlink dir cached 
random server 	moment separate 
panic dict 	test directory since 
size 	could found 
intset len 	symlink non existing 
server panic 	directory track 
server info 	flags says 
dict create 	cannot cache fact 
dict expand 	cache would 
intset 	left empty allowed 
len type 	track real 
init iterator 	directories still cache 
type next 	path components 
create server 	last one found 
info dict 	symlink non 
type 	existing component non 
release iterator 	zero path 
zfree server 	name leading symlink 
panic lookup 	component non 
key write 	zero path name 
type create 	leading symlink 
reply 	component zero path 
encoding type 	name leading 
signal modified 	symlink component leading 
key notify 	path component 
keyspace reply 	exists leading 
lookup key 	path exists directory 
write 	path length 
reply check 	leading path exists 
type type 	neither directory 
type size 	symlink zero path 
signal modified 	name leading 
key notify 	symlink component leading 
keyspace 	path component 
notify keyspace 	exists leading path 
reply lookup 	exists directory 
key write 	path length leading 
lookup key 	path exists 
write encoding 	neither directory symlink 
reply 	non zero 
check type 	path components name 
check type 	exists directory 
reply type 	prefix len test 
member type 	stat function 
reply notify 	instead lstat 
keyspace 	function prefix length 
type size 	prefix len 
notify keyspace 	thus allow symlinks 
signal modified 	prefix part 
key signal 	points real existing 
modified key 	directories non 
type 	zero path components 
create type 	name exists 
notify keyspace 	directory prefix len 
reply lookup 	test stat 
key read 	function instead lstat 
reply check 	function prefix 
type 	length prefix len 
encoding type 	thus allow 
member reply 	symlinks prefix part 
reply lookup 	points real 
key read 	existing directories 
reply check 	find last slash 
type 	inside name 
reply type 	directory check must 
size reply 	first upwards 
reply lookup 	possible empty directories 
key read 	upwards deeper 
reply check 	directory need save 
type 	path components 
reply type 	syslog.c eventlog ident 
size notify 	logopt facility 
keyspace sunion 	priority fmt logtype 
diff command 	str pos 
notify keyspace 	str len source 
rewrite 	warning last 
client command 	error start vsnprintf 
vector signal 	end warning 
modified key 	strerror malloc warning 
create reply 	strerror start 
multi bulk 	vsnprintf end 
len 	strstr realloc warning 
type random 	strerror memmove 
element create 	strlen report free 
incr count 	syslog.h ident 
reply bulk 	logopt facility priority 
type also 	fmt syslog 
propagate 	tag.c tag type 
decr count 	warn warnlen 
type random 	sha obj buf 
element create 	tail dateptr 
incr count 	item data size 
type create 	sha type 
type 	bufptr tail item 
type decr 	data size 
count incr 	ret parse strlen 
count overwrite 	error parse 
type init 	lookup create alloc 
iterator type 	tag node 
next 	type strtoul 
create incr 	memcmp sha hex 
count reply 	starts memchr 
bulk also 	memcpy strcmp lookup 
propagate decr 	blob strcmp 
count type 	lookup strcmp lookup 
release 	commit strcmp 
iterator decr 	lookup tag error 
count decr 	starts memchr 
count prevent 	xmemdupz starts parse 
command propagation 	tag date 
spop count 	read sha file 
command 	error oid 
reply lookup 	hex free error 
key write 	oid hex 
reply check 	parse tag buffer 
type type 	free nada 
random element 	nada dateptr buf 
create 	buf strtoul 
intset incr 	stop buf 
count type 	sha good builtin 
notify keyspace 	git tag 
create rewrite 	copyright kristian gsberg 
client command 	krh redhat 
vector 	carlos rica jasampler 
decr count 	gmail git 
decr count 	tag mktag linus 
reply bulk 	torvalds parse 
type size 	arg given sorting 
notify keyspace 	skip header 
signal 	skip write message 
modified key 	editing git 
reply lookup 	tag usage colopts 
key read 	filter sorting 
reply check 	format free argv 
type type 	error sha 
size 	name sha 
reply reply 	name sha argv 
multi bulk 	verify tag 
len type 	buffer tag tag 
random element 	nocleanup arg 
reply bulk 	sorting tail len 
reply 	status sorting 
bulk sunion 	tail sha size 
diff command 	buf buf 
dict create 	sign result sign 
type init 	tag buf 
iterator type 	opt prev result 
next 	header buf 
dict create 	header len path 
dict dup 	buf given 
server type 	buf opt arg 
release iterator 	unset msg 
server 	name argc argv 
dict size 	prefix buf 
dict random 	prev tag 
key dict 	opt cleanup arg 
dict key 	create reflog 
type random 	force cmdmode keyid 
element 	msg transaction 
create dup 	err filter sorting 
dict decr 	tail format 
count reply 	options ret copts 
multi bulk 	memset xstrfmt 
len dict 	verify format filter 
iterator 	refs sort 
dict next 	show item clear 
reply bulk 	free snprintf 
dict key 	error read error 
dict release 	find unique 
iterator dict 	abbrev sha hex 
release 	run command 
srandmember count 	opt error sign 
command reply 	buffer signing 
lookup key 	key xcalloc 
read reply 	skip prefix skip 
check type 	prefix strlen 
type 	parse filter atom 
random element 	strcmp config 
reply bulk 	error nonbool parse 
reply bulk 	sorting git 
type size 	gpg config starts 
type size 	git column 
type 	config git config 
size type 	read sha 
size zmalloc 	file strstr free 
lookup key 	write die 
write lookup 	parse signature free 
key read 	sign error 
zfree 	write sha file 
signal modified 	error sha 
key reply 	info die snprintf 
reply check 	sha hex 
type zfree 	git committer 
qsort deferred 	info die git 
multi 	pathdup open 
bulk length 	die errno sha 
create intset 	write tag 
type init 	body strbuf addch 
iterator type 	strbuf commented 
next intset 	addf strbuf commented 
find 	addf write 
create type 	die strbuf release 
member decr 	close launch 
count decr 	editor exit strbuf 
count intset 	stripspace die 
find type 	strbuf insert build 
member 	tag exit 
reply bulk 	unlink warn free 
reply bulk 	strbuf addstr 
create type 	strbuf addstr strbuf 
decr count 	reset strbuf 
type type 	addf check 
release 	refname format git 
iterator type 	config memset 
size reply 	memset parse options 
type size 	signing key 
notify keyspace 	usage options finalize 
decr count 	colopts explicitly 
reply 	enable column die 
notify keyspace 	sorting column 
signal modified 	active memset run 
key deferred 	column filter 
multi bulk 	list tags column 
length zfree 	active stop 
sinter 	column filter die 
command sinter 	die die 
command zmalloc 	die tag name 
lookup key 	tag name 
write lookup 	die strbuf 
key read 	addbuf strcmp strbuf 
check 	read die 
type zfree 	errno strbuf read 
type size 	file die 
type size 	errno die sha 
qsort create 	die strbuf 
intset type 	check tag die 
init 	read hashclr 
iterator type 	die strcmp strcmp 
next type 	strcmp die 
decr count 	create tag transaction 
type release 	begin transaction 
iterator type 	update transaction commit 
init 	die transaction 
iterator type 	free sha hashcmp 
next type 	find unique 
member type 	abbrev strbuf release 
decr count 	strbuf release 
type release 	strbuf release 
iterator 	nada nada dateptr 
type init 	buf buf 
iterator type 	strtoul stop buf 
next type 	sha good 
type decr 	builtin git tag 
count type 	copyright kristian 
release 	gsberg krh redhat 
iterator reply 	carlos rica 
multi bulk 	jasampler gmail git 
len type 	tag mktag 
init iterator 	linus torvalds parse 
type next 	arg given 
reply 	sorting skip header 
bulk decr 	skip write 
count type 	message editing tag.c 
release iterator 	tag type 
decr count 	warn warnlen sha 
type size 	obj buf 
reply 	tail dateptr 
type size 	item data size 
notify keyspace 	sha type 
decr count 	bufptr tail item 
reply notify 	data size 
keyspace signal 	ret parse strlen 
modified 	error parse 
key zfree 	lookup create alloc 
sunion diff 	tag node 
command sunion 	type strtoul memcmp 
diff command 	sha hex 
sunion diff 	starts memchr memcpy 
command 	strcmp lookup 
sunion diff 	blob strcmp lookup 
command parse 	strcmp lookup 
scan cursor 	commit strcmp lookup 
reply lookup 	tag error 
key read 	starts memchr xmemdupz 
reply 	starts parse 
check type 	tag date 
scan command 	read sha file 
copyright salvatore 	error oid 
sanfilippo antirez 	hex free error 
gmail dot 	oid hex 
rights 	parse tag buffer 
reserved redistribution 	free nada 
use source 	nada dateptr buf 
binary forms 	buf strtoul 
without modification 	stop buf sha 
permitted provided 	good builtin 
following 	git tag copyright 
conditions met 	kristian gsberg 
redistributions source 	krh redhat carlos 
code must 	rica jasampler 
retain copyright 	gmail git tag 
notice list 	mktag linus 
conditions 	torvalds parse 
following disclaimer 	arg given sorting 
redistributions binary 	skip header 
form must 	skip write message 
reproduce copyright 	editing git 
notice list 	tag usage colopts 
conditions 	filter sorting 
following disclaimer 	format free argv 
documentation materials 	error sha 
provided distribution 	name sha name 
neither name 	sha argv 
redis names 	verify tag buffer 
contributors 	tag tag 
may used 	nocleanup arg sorting 
endorse promote 	tail len 
products derived 	status sorting tail 
software without 	sha size 
specific prior 	buf buf sign 
written 	result sign 
permission software 	tag buf 
provided copyright 	opt prev result 
holders contributors 	header buf 
express implied 	header len path 
warranties including 	buf given 
limited 	buf opt arg 
implied warranties 	unset msg 
merchantability fitness 	name argc argv 
particular purpose 	prefix buf 
disclaimed shall 	prev tag opt 
copyright owner 	cleanup arg 
contributors 	create reflog force 
liable direct 	cmdmode keyid 
indirect incidental 	msg transaction err 
special exemplary 	filter sorting 
consequential damages 	tail format options 
including limited 	ret copts 
procurement 	memset xstrfmt verify 
substitute goods 	format filter 
services loss 	refs sort 
use data 	show item clear 
profits business 	free snprintf 
interruption however 	error read error 
caused 	find unique 
theory liability 	abbrev sha hex 
whether contract 	run command 
strict liability 	opt error sign 
tort including 	buffer signing 
negligence otherwise 	key xcalloc skip 
arising 	prefix skip 
way use 	prefix strlen parse 
software even 	filter atom 
advised possibility 	strcmp config error 
damage commands 	nonbool parse 
factory method 	sorting git gpg 
hold 	config starts 
integer encodable 	git column config 
intset returned 	git config 
otherwise regular 	read sha 
hash table 	file strstr free 
specified function 	write die 
takes 	parse signature free 
care incrementing 	sign error 
reference count 	write sha file 
needed order 	error sha 
retain copy 	info die snprintf 
already member 	sha hex 
nothing 	git committer info 
done returned 	die git 
otherwise element 	pathdup open die 
added returned 	errno sha 
convert regular 	write tag body 
intset contains 	strbuf addch 
many 	strbuf commented addf 
entries failed 	strbuf commented 
integer convert 	addf write 
regular intset 	die strbuf release 
integer encodable 	close launch 
dict always 	editor exit strbuf 
work 	stripspace die 
move next 	strbuf insert build 
entry returns 	tag exit 
current position 	unlink warn free 
since elements 	strbuf addstr 
internally stored 	strbuf addstr strbuf 
redis 	reset strbuf 
objects simple 	addf check refname 
arrays integers 	format git 
type next 	config memset memset 
returns encoding 	parse options 
iterating populate 	signing key usage 
appropriate 	options finalize 
pointer objele 	colopts explicitly enable 
llele accordingly 	column die 
note objele 	sorting column 
llele pointers 	active memset run 
passed cannot 	column filter 
since 	list tags column 
function defensively 	active stop 
populate non 	column filter die 
used field 	die die 
values easy 	die tag name 
trap misused 	tag name 
longer 	die strbuf addbuf 
elements returned 	strcmp strbuf 
returned objects 	read die errno 
count incremented 	strbuf read 
function copy 	file die errno 
write friendly 	die sha 
needed 	die strbuf check 
defensive needed 	tag die 
defensive copy 	read hashclr die 
write friendly 	strcmp strcmp 
version easy 	strcmp die 
use version 	create tag transaction 
type 	begin transaction 
next type 	update transaction commit 
next returning 	die transaction 
objects incrementing 	free sha hashcmp 
count returned 	find unique 
objects retain 	abbrev strbuf release 
pointer 	strbuf release 
call decr 	strbuf release nada 
count function 	nada dateptr 
way write 	buf buf strtoul 
operations cow 	stop buf 
issue result 	sha good builtin 
anyway 	git tag 
incrementing count 	copyright kristian gsberg 
suppress warnings 	krh redhat 
random element 	carlos rica jasampler 
non empty 	gmail git 
returned element 	tag mktag 
encoded 	linus torvalds parse 
intset blob 	arg given 
integers redis 	sorting skip header 
regular caller 	skip write 
provides pointers 	message editing tag.h 
populated right 	tag type 
function 	tagged tag date 
encoding field 	sha item 
used caller 	data size item 
check pointer 	tag tar.h 
redis pointer 	name mode uid 
populated note 	gid size 
objele 	mtime chksum typeflag 
llele pointers 	linkname magic 
passed cannot 	version uname gname 
since function 	devmajor devminor 
defensively populate 	prefix tempfile.c tempfile 
non used 	list skip 
field 	fclose signo 
values easy 	tempfile tempfile path 
trap misused 	save errno 
returned real 	tempfile path tempfile 
count incremented 	suffixlen mode 
function considered 	tempfile suffixlen mode 
copy 	tmpdir tempfile 
write friendly 	mode full tempfile 
needed defensive 	mode tempfile 
needed defensive 	tempfile tempfile tempfile 
convert specified 	err save 
encoding resulting 	errno tempfile tempfile 
dict 	path save 
converting hash 	errno tempfile getpid 
table presized 	tempfile tempfiles 
hold number 	tempfiles sigchain pop 
elements original 	sigchain push 
presize dict 	common atexit 
avoid 	die strbuf init 
rehashing elements 	die prepare 
extract integers 	tempfile strbuf absolute 
create redis 	path open 
objects source 	strbuf reset getpid 
key exist 	adjust shared 
source 	perm error tempfile 
key wrong 	prepare tempfile 
type destination 	strbuf absolute path 
key wrong 	getpid prepare 
type error 	tempfile strbuf absolute 
srcset dstset 	path git 
equal 	mkstemps mode strbuf 
smove element 	reset getpid 
cannot removed 	prepare tempfile getenv 
src src 	strbuf addf 
database empty 	git mkstemps mode 
create destination 	strbuf reset 
doesn 	getpid strbuf 
exist extra 	absolute path mks 
key changed 	tempfile die 
ele successfully 	errno strbuf release 
added dstset 	die die 
handle spop 	fdopen die die 
key 	die ferror 
count variant 	fclose close tempfile 
normal version 	die die 
command handled 	open die close 
spop command 	tempfile rename 
function many 	tempfile strbuf reset 
times 	close tempfile 
bigger compared 	unlink warn strbuf 
remaining size 	reset state 
use create 	diagram cleanup program 
strategy read 	exits temporary 
later implementation 	file active want 
info 	make sure 
count argument 	done remembering 
make sure 	active temporary files 
key name 	linked list 
inputted exists 	tempfile list atexit 
type indeed 	handler signal 
otherwise 	handler registered clean 
nil count 	active temporary 
zero serve 	files signal handler 
empty multibulk 	run time 
asap avoid 	tempfile list tempfile 
special cases 	objects comprise 
later 	must kept self 
generate spop 	consistent states 
keyspace notification 	times possible states 
number requested 	tempfile follows 
elements greater 	uninitialized state list 
equal number 	field must 
elements 	zero rest contents 
inside simply 	need initialized 
whole entire 	soon used 
empty propagate 	way irrevocably registered 
command del 	tempfile list 
operation require 	list active file 
replicate 	open create 
spop serm 	tempfile reopen tempfile 
commands prepare 	state temporary 
replication argument 	file exists active 
vector also 	filename holds 
send length 	filename temporary file 
common 	holds file 
code paths 	descriptor open writing 
common iteration 	holds pointer 
vars elements 	open file fdopen 
left spop 	tempfile called 
number requested 	owner holds pid 
elements 	process created 
less number 	file active 
elements inside 	file closed successful 
also sure 	close tempfile 
count size 	previous state temporary 
use two 	file closed 
different 	inactive tempfile rename 
strategies number 	tempfile failed 
elements small 	attempt create temporary 
compared size 	file failed 
extract random 	close tempfile state 
elements element 	active unset 
client 	filename empty usually 
replicate aof 	though transitory 
command srem 	states condition doesn 
operation number 	hold client 
elements big 	code rely filename 
approaching size 	empty state 
time 	left registered tempfile 
extracting random 	list list 
elements becomes 	temporary file 
computationally expensive 	owned process created 
use different 	tempfile owner 
strategy extract 	field records owner 
random 	pid field 
elements want 	used prevent forked 
elements remain 	process deleting 
part creating 	temporary file created 
stored original 	parent fclose 
elements left 	safe call signal 
original 	handler initialize 
release create 	tempfile necessary tempfile 
remaining elements 	list one 
assign key 	time initialization initialize 
protect old 	tempfile tempfile 
tranfer old 	list shouldn happen 
client 	better safe 
release replicate 	sorry make sure 
aof command 	errno contains 
srem operation 	meaningful error 
propagate command 	note circuiting want 
even 	fclose tempfile.h 
incremented dirty 	next active owner 
counter want 	list filename 
propagate spop 	tempfile path tempfile 
command since 	path tempfile 
propagated command 	suffixlen mode tempfile 
sre 	suffixlen tempfile 
operations also 	mode tempfile tempfile 
propagate api 	suffixlen mode 
make sure 	tempfile suffixlen tempfile 
key name 	mode tempfile 
inputted exists 	tempfile mode tempfile 
type 	tempfile mode 
indeed random 	tempfile tempfile tempfile 
element element 	tempfile tempfile 
replicate aof 	tempfile tempfile tempfile 
command srem 	path handle 
operation element 	temporary files 
reply 	tempfile api allows 
empty modified 	temporary files 
handle srandmember 	created deleted atomically 
key count 	renamed temporary 
variant normal 	files still active 
version command 	program ends 
handled 	cleaned automatically lockfiles 
srandmember command 	see lockfile 
function many 	built top api 
times bigger 	calling sequence 
compared requested 	caller allocates tempfile 
size use 	either variable 
elements 	heap initialized zeros 
strategy read 	use structure 
later implementation 	call create tempfile 
info negative 	belongs tempfile 
count means 	subsystem storage 
elements multiple 	must remain valid 
times 	throughout life 
extracted element 	program cannot use 
every extraction 	stack variable 
count zero 	hold structure attempts 
serve asap 	create temporary 
avoid special 	file calling create 
cases 	tempfile writes 
later count 	content file either 
negative extraction 	writing file 
method random 	descriptor returned create 
elements sampling 	tempfile also 
whole every 	available via tempfile 
time 	calling fdopen 
trivial served 	tempfile file pointer 
without auxiliary 	open file 
data structures 	writing file stdio 
number requested 	finished writing 
elements greater 	caller close 
number 	file descriptor temporary 
elements inside 	file calling 
simply whole 	tempfile close temporary 
need auxiliary 	file rename 
dictionary number 	atomically specified filename 
elements inside 	calling rename 
greater 	tempfile relinquishes control 
srandmember sub 	file close 
strategy mul 	file descriptor without 
times number 	removing renaming 
requested elements 	temporary file calling 
create scratch 	close tempfile 
elements 	later call tempfile 
subtract random 	rename tempfile 
elements reach 	even temporary file 
requested number 	renamed deleted 
elements done 	tempfile must freed 
number requsted 	altered caller 
elements 	however may 
bit less 	reused pass another 
number elements 	call create 
natural approach 	tempfile program exits 
used highly 	rename tempfile 
inefficient elements 	tempfile called atexit 
temporary 	handler close 
dictionary random 	temporary file need 
elements reach 	close file 
right count 	descriptor calling close 
big compared 	tempfile never 
requested number 	call close fclose 
elements 	otherwise tempfile 
simply random 	structure would still 
elements temporary 	think file 
trying eventually 	descriptor needs closed 
enough unique 	later cleanup 
elements reach 	would result duplicate 
specified 	calls close 
count dictionary 	worse yet 
already exists 	close later open 
free otherwise 	another file 
increment number 	descriptor completely different 
objects result 	purpose unrelated 
dictionary 	file descriptor might 
send result 	closed error 
user used 	handling create tempfile 
sdiff receive 	returns file 
handled empty 	descriptor success failure 
sets sort 	errors errno 
sets 	describes reason failure 
smallest largest 	tempfile rename 
improve algorithm 	tempfile close tempfile 
performance first 	success failure 
thing output 	errno appropriately best 
total number 	temporary file 
elements 	attempt create temporary 
since multi 	file specified 
bulk write 	path file 
stage know 	descriptor writing error 
intersection size 	error file 
use trick 	already exists path 
append 	existing file 
empty output 	tempfile meaning deleted 
list save 	program exits 
pointer later 	tempfile considered closed 
modify right 	worked like 
length target 	closed tempfile example 
key 	opened reopen 
store resulting 	tempfile mks tempfile 
create key 	functions following 
empty inside 	functions attempt create 
iterate elements 	open temporary 
first smallest 	files names derived 
test 	automatically manner 
element sets 	mkstemps arrange 
least one 	deleted program ends 
include element 	deleted explicitly 
discarded intset 	whole family functions 
intset simple 	named according 
fast 	following pattern mks 
order compare 	tempfile optional 
integer use 	letters following meanings 
function creating 	die temporary 
optimization source 	file cannot created 
integer encoded 	create temporary 
target 	file tmpdir opposed 
intset much 	relative current 
faster path 	directory variants used 
check easy 	pattern filename 
use type 	alone without path 
agnostic api 	includes suffix 
take 	suffixlen characters temporary 
action sets 	file created 
contain member 	specified mode 
store resulting 	otherwise mode none 
target intersection 	functions modify 
empty diff 	caller wants know 
algorithm 	absolute path 
use algorithm 	file created read 
size element 	tempfile filename 
first total 	success functions file 
number sets 	descriptor open 
algorithm total 	writing temporary file 
number 	errors errno 
elements sets 	appropriately variants die 
compute best 	errors see 
bet current 	mks tempfile functions 
input algorithm 	see mks 
better constant 	tempfile functions see 
times 	mks tempfile 
performs less 	functions see mks 
operations elements 	tempfile functions 
common give 	see mks 
advantage algorithm 	tempfile functions see 
better order 	mks tempfile 
sets 	functions see mks 
subtract decreasing 	tempfile functions 
size likely 	see mks tempfile 
find duplicated 	functions see 
elements asap 	mks tempfile functions 
need temp 	see mks 
store 	tempfile functions associate 
dstkey inside 	stdio stream 
sunionstore operation 	temporary file must 
resulting target 	still open 
key trivial 	without deleting file 
every element 	error stream 
every 	closed automatically close 
temporary non 	tempfile called 
existing keys 	file deleted renamed 
like empty 	path lockfile 
sets diff 	pointer field 
algorithm perform 	within file freed 
diff 	temporary file 
iterating elements 	still open close 
first adding 	file pointer 
target element 	opened fdopen tempfile 
exist sets 	without deleting 
way perform 	file upon success 
max 	failure close 
operations size 	negative file usually 
first number 	tempfile rename 
sets key 	tempfile eventually called 
empty element 	close tempfile 
diff algorithm 	succeeds open temporary 
elements 	file closed 
first auxiliary 	close tempfile yet 
elements next 	deleted renamed 
sets sum 	used implement 
elements every 	sequence operations like 
non existing 	following create 
keys 	temporary file write 
like empty 	contents file 
sets exit 	close tempfile cause 
result empty 	contents written 
additional removal 	disk pass name 
elements effect 	temporary file 
output 	another program allow 
content resulting 	nobody inspect 
store mode 	even modify file 
target key 	contents reopen 
store resulting 	tempfile reopen temporary 
create key 	file make 
result 	updates contents rename 
inside t 	tempfile move 
stringc size 	file permanent location 
flags key 	close file 
val expire 	descriptor file 
unit reply 	pointer temporary file 
abort 	associated tempfile 
reply milliseconds 	call tempfile tempfile 
expire unit 	already deleted 
flags next 	renamed close file 
offset olen 	descriptor file 
start end 	pointer still open 
str 	atomically rename 
llbuf strlen 	temporary file path 
busykeys incr 	path must 
oldvalue incr 	filesystem file success 
incr incr 	failure temporary 
aux totlen 	file errno failing 
append 	call close 
reply error 	rename bug call 
reply reply 	rename tempfile 
error format 	tempfile currently active 
lookup key 	tempfile terminal.c 
write lookup 	sig term 
key 	old term hconin 
write reply 	cmode prompt 
key expire 	echo buf input 
mstime notify 	output prompt 
keyspace notify 	echo restore term 
keyspace reply 	sigchain pop 
reply 	tcsetattr close open 
encoding command 	tcgetattr sigchain 
encoding command 	push common tcsetattr 
encoding command 	close console 
encoding command 	mode close handle 
lookup key 	create file 
read 	console mode sigchain 
reply reply 	push common 
reply bulk 	console mode close 
command command 	handle fopen 
encoding key 	fopen fclose disable 
notify keyspace 	echo fclose 
reply 	fclose fputs 
reply error 	fflush strbuf getline 
lookup key 	putc fflush 
write sdslen 	restore term fclose 
reply check 	fclose getpass 
length sdslen 	terminal.h prompt echo 
create 	compat terminal 
sdsnewlen sdslen 	test-chmtime.c usage str 
check type 	arg time 
len sdslen 	test timespec argc 
reply check 	argv verbose 
length sdslen 	time utb mtime 
unshare 	strtol time 
sdslen sdsgrowzero 	strcmp strcmp timespec 
sdslen memcpy 	arg stat 
sdslen signal 	strerror chmod strerror 
modified key 	utime strerror 
notify keyspace 	program either 
reply 	change modification time 
sdslen reply 	given file 
reply lookup 	print program change 
key read 	atime ctime 
reply check 	values explicitly preserved 
type sdslen 	mtime changed 
reply 	absolute test chmtime 
reply bulk 	seconds file 
buffer reply 	relative current time 
multi bulk 	returned time 
len lookup 	test chmtime seconds 
key read 	seconds file 
reply 	relative current mtime 
reply reply 	file test 
bulk reply 	chmtime seconds file 
error lookup 	test chmtime 
key write 	seconds seconds file 
reply encoding 	examples print 
key 	mtime use 
notify keyspace 	verbose file mtime 
reply mset 	offset test 
command mset 	chmtime file mtime 
command lookup 	current time 
key write 	test chmtime file 
check 	relative future 
type reply 	mtime change test-config.c 
reply error 	argc argv 
create overwrite 	val strptr err 
signal modified 	err git 
key notify 	configset init strcmp 
keyspace 	git config 
reply reply 	strcmp git config 
reply incr 	multi strcmp 
decr command 	git config strcmp 
incr decr 	git config 
command reply 	strcmp git config 
incr 	strcmp git 
decr command 	configset file 
reply incr 	git configset strcmp 
decr command 	git configset 
lookup key 	file git configset 
write check 	multi die 
type 	git configset clear 
reply reply 	git configset 
isnan isinf 	clear git configset 
reply error 	clear program 
create overwrite 	exposes api configuration 
signal modified 	mechanism simple 
key 	commands order facilitate 
notify keyspace 	testing reads 
reply bulk 	stdin prints result 
create rewrite 	command stdout 
client command 	prints highest priority 
argument decr 	entered key 
count 	multi prints values 
rewrite client 	entered key 
command argument 	increasing order 
lookup key 	priority print integer 
write encoding 	entered key 
incr count 	die print entered 
len 	key die 
check type 	print entered key 
len sdslen 	die configset 
check length 	returns highest priority 
unshare sdscatlen 	entered key 
sdslen sdslen 	config constructed files 
signal 	entered arguments 
modified key 	configset multi returns 
notify keyspace 	list entered 
reply lookup 	key sorted order 
key read 	priority config 
reply check 	constructed files entered 
type 	arguments examples 
reply len 	print highest priority 
copyright salvatore 	key foo 
sanfilippo antirez 	baz rock 
gmail dot 	test config foo 
rights reserved 	baz rock 
redistribution 	test-ctype.c argc argv 
use source 	strchr test 
binary forms 	test test test 
without modification 	test find 
permitted provided 	nul strchr classless 
following conditions 	anyway test-date.c 
met 	usage msg argv 
redistributions source 	buf argv 
code must 	result argv argc 
retain copyright 	argv atoi 
notice list 	show date relative 
conditions following 	strbuf release 
disclaimer 	strbuf reset parse 
redistributions binary 	date sscanf 
form must 	show date 
reproduce copyright 	date mode strbuf 
notice list 	release approxidate 
conditions following 	relative show date 
disclaimer 	date mode 
documentation materials 	getenv atoi gettimeofday 
provided distribution 	usage strcmp 
neither name 	show dates strcmp 
redis names 	parse dates 
contributors may 	strcmp parse approxidate 
used 	usage test-delta.c 
endorse promote 	usage str argc 
products derived 	argv buf 
software without 	data buf buf 
specific prior 	size data 
written permission 	size size strcmp 
software 	strcmp open 
provided copyright 	fstat perror mmap 
holders contributors 	perror close 
express implied 	close open 
warranties including 	fstat perror mmap 
limited implied 	perror close 
warranties 	close diff delta 
merchantability fitness 	patch delta 
particular purpose 	open write full 
disclaimed shall 	perror test 
copyright owner 	delta test code 
contributors liable 	exercise diff 
direct 	delta patch delta 
indirect incidental 	nicolas pitre 
special exemplary 	nico fluxnic net 
consequential damages 	code free 
including limited 	software redistribute modify 
procurement substitute 	terms gnu 
goods 	general license version 
services loss 	published free 
use data 	software foundation test-dump-cache-tree.c 
profits business 	pfx pfx 
interruption however 	errs path 
caused theory 	rdwn istate another 
liability 	sha hex 
whether contract 	dump one dump 
strict liability 	one dump 
tort including 	one hashcmp dump 
negligence otherwise 	one cache 
arising way 	sub xsnprintf dump 
use 	cache cache 
software even 	read cache die 
advised possibility 	cache update 
damage isnan 	dump cache missing 
isinf commands 	either invalid 
command function 	claims valid lying 
operation 	test-dump-split-index.c pos 
different options 	data read index 
variants function 	sha hex 
called order 	sha hex sha 
implement following 	hex stage 
commands setex 	ewah bit 
psetex 	ewah bit test-dump-untracked-cache.c 
setnx flags 	ucd len 
changes behavior 	strcmp strcmp qsort 
command see 	qsort strbuf 
belove expire 	addf sha hex 
represents expire 	fputs fputs 
form 	fputs dump strbuf 
redis passed 	setlen setup 
user interpreted 	git directory read 
according specified 	cache die 
unit reply 	sha hex sha 
abort 	hex dump 
reply function 	hack avoid modifying 
reply client 	untracked cache 
operation performed 	read test-fake-ssh.c argc 
flags reply 	argv trash 
used abort 	directory buf 
reply 	child argv getenv 
used key 	die strbuf 
exists key 	addf fopen die 
exists time 	fclose run 
seconds given 	command opt first 
time given 	print parameters 
initialized 	trash directory ssh 
avoid harmness 	output evaluate 
warning key 	last parameter test-genrandom.c 
seconds milliseconds 	argc argv 
setting nothing 	count next strtoul 
non existing 	putchar simple 
resulting 	random data generator 
exceeds allowed 	used create 
size key 	reproducible test files 
exists check 	inspired posix 
type existing 	implementation example rand 
length setting 	copyright nicolas 
nothing 	pitre licensed 
resulting exceeds 	gpl version test-hashmap.c 
allowed size 	ent key 
create copy 	key key hash 
shared encoded 	key klen 
convert negative 	vlen entry method 
indexes 	key hash 
precondition end 	method rounds map 
end strlen 	buf entries 
condition nothing 	hashes argc argv 
returned start 	line map 
end handle 	icase cmd hash 
flag 	entry key 
msetnx semantic 	iter strlen strcmp 
zero nothing 	strcasecmp malloc 
least one 	hashmap entry init 
already key 	memcpy memcpy 
exists always 	strhash malloc malloc 
replicate 	snprintf alloc 
incrbyfloat command 	test entry 
order make 	strlen hash hashmap 
sure differences 	init hashmap 
precision formatting 	entry init hashmap 
create differences 	hashmap free 
replicas 	hashmap init hashmap 
aof restart 	entry init 
create key 	hashmap hashmap hash 
key exists 	hashmap free 
check type 	strcmp hashmap init 
append argument 	hashmap cmp 
always 	fgets strtok strtok 
sds append 	strlen strihash 
t zsetc 	strhash strtok strlen 
spec spec 	strcmp strhash 
level score 	memhash strihash memihash 
obj zsl 	strcmp alloc 
node 	test entry hashmap 
zsl next 	strcmp alloc 
level zsl 	test entry 
score obj 	hashmap put puts 
update rank 	free strcmp 
level zsl 	hashmap hash puts 
update 	puts hashmap 
zsl score 	next strcmp hashmap 
obj update 	entry init 
spec spec 	hashmap puts free 
zsl range 	strcmp hashmap 
zsl range 	iter init hashmap 
zsl 	iter next 
range zsl 	strcmp strcmp strintern 
range dict 	strintern strcmp 
update removed 	strcmp perf hashmap 
next zsl 	atoi atoi 
range dict 	hashmap free key 
update 	two terminated 
removed next 	test performance 
zsl start 	hashmap usage time 
end dict 	echo perfhashmap 
update removed 	method rounds test 
next zsl 	hashmap test 
score 	adding map entries 
rank zsl 	test map 
rank traversed 	lookups fill map 
min max 	sparsely specified 
spec eptr 	read stdin line 
item dest 	line print 
min 	result commands stdout 
max spec 	hash key 
spec spec 	strhash key memhash 
spec zsl 	key strihash 
range zsl 	key memihash key 
range zsl 	put key 
range 	old key key 
sptr vstr 	old iterate 
vlen vlong 	key nkey 
buf score 	size tablesize numentries 
sptr vstr 	perfhashmap method 
vlen vlong 	rounds test hashmap 
eptr 	performance init 
cstr clen 	hash map process 
vstr vlen 	commands stdin 
vlong vbuf 	line command two 
minlen cmp 	parameters ignore 
eptr sptr 	empty lines print 
eptr 	results different 
sptr eptr 	hash functions create 
sptr eptr 	entry key 
sptr range 	hashmap create entry 
score range 	key replace 
sptr score 	entry print free 
range 	replaced entry 
sptr score 	lookup entry hashmap 
spec res 	print result 
spec res 	setup key 
range range 	entry hashmap print 
sptr range 	result free 
sptr 	entry print table 
ele score 	sizes test 
sptr eptr 	strintern works test-index-version.c 
eptr ele 	argc argv 
score sptr 	hdr version memset 
scorebuf scorelen 	read ntohl 
offset 	test-line-buffer.c end command 
ele score 	arg buf 
sptr range 	line stdin buf 
deleted eptr 	arg argc 
sptr score 	argv stdin buf 
num range 	file buf 
deleted 	input filename strtoumax 
eptr sptr 	die starts 
num start 	strbuf addch buffer 
end deleted 	read binary 
num zobj 	strtouint fwrite 
length zobj 	strbuf release starts 
encoding 	buffer copy 
node next 	bytes strtouint starts 
ele score 	buffer skip 
eptr sptr 	bytes strtouint die 
vstr vlen 	strchr die 
vlong zobj 	handle command usage 
maxelelen 	buffer init 
zset zobj 	die errno buffer 
member score 	fdinit strtouint 
flags nanerr 	die errno buffer 
key ele 	init die 
zobj curobj 	errno buffer read 
curscore 	line handle 
elements scoreidx 	line buffer deinit 
added updated 	die buffer 
processed opt 	deinit die ferror 
incr eptr 	die test 
znode key 	line buffer 
zobj 	code exercise svn 
eptr score 	importer input 
rangetype key 	helper test-match-trees.c hash 
zobj keyremoved 	hash shifted 
deleted range 	one two sha 
lexrange start 	die sha 
end 	die parse indirect 
llen val 	die parse 
ell val 	indirect die shift 
val val 	sha hex 
val score 	exit test-mergesort.c text 
target val 	next argc 
aggregate 	argv line lines 
dstkey setnum 	strcmp strbuf 
aggregate src 	getwholeline xmalloc strbuf 
zval tmp 	detach llist 
maxelelen dstobj 	mergesort test-mktemp.c 
dstzset znode 	argc argv usage 
touched 	xmkstemp xstrdup 
obj remaining 	test mktemp code 
score accumulator 	exercise creation 
score ele 	temporary files test-parse-options.c 
reverse key 	integer magnitude 
zobj withscores 	timestamp abbrev quiet 
start 	file ambiguous 
end llen 	list opt arg 
rangelen eptr 	unset opt 
sptr vstr 	arg unset argc 
vlen vlong 	argv prefix 
zsl ele 	usage options strlen 
reverse 	strtol parse 
range key 	options support unset 
zobj limit 	test-path-utils.c item 
withscores rangelen 	unused ceil input 
replylen minidx 	alternative data 
maxidx remaining 	func funcname 
pos 	buffer basename data 
eptr sptr 	dirname data 
vstr vlen 	argc argv buf 
vlong score 	len ceiling 
zsl key 	dirs path prefix 
zobj range 	prefix len 
count 	nongit prefix prefix 
eptr sptr 	rel die 
score zsl 	absolute path die 
rank key 	normalize path 
zobj range 	copy die strcmp 
count eptr 	strcmp die 
sptr 	func xsnprintf func 
zsl rank 	strcmp error 
reverse range 	strcmp error strcmp 
key zobj 	xmallocz strlen 
limit rangelen 	normalize path copy 
replylen minidx 	puts strcmp 
maxidx 	puts real 
remaining pos 	path strcmp puts 
eptr sptr 	absolute path 
vstr vlen 	strcmp xstrdup normalize 
vlong zsl 	path copy 
key zobj 	die list split 
key 	filter list 
zobj score 	longest ancestor length 
reverse key 	list clear 
ele zobj 	free strcmp strlen 
llen rank 	setup git 
eptr sptr 	directory gently puts 
zsl 	prefix path 
score cursor 	strcmp strip path 
zmalloc zmalloc 	suffix strcmp 
zsl create 	puts strcmp normalize 
node decr 	argv normalize 
count zfree 	argv relative path 
zfree 	puts puts 
zsl free 	strlen strbuf 
node zfree 	release strcmp test 
random server 	function strcmp 
isnan compare 	test function list 
objects zsl 	func function 
random 	normalizes entry git 
level zsl 	ceiling directories 
create node 	path unusable reason 
compare objects 	die explanation 
equal objects 	input transform output 
zsl node 	output posix 
zsl 	type paths win 
free node 	type paths 
zsl gte 	posix type paths 
min zsl 	win type 
lte max 	paths normalize arguments 
zsl range 	windows bash 
zsl 	mangles arguments 
gte min 	look like absolute 
server zsl 	posix paths 
lte max 	colon separate lists 
zsl range 	absolute posix 
zsl lte 	paths dos paths 
max 	foo foo 
server zsl 	bar might converted 
gte min 	src msysgit 
zsl node 	foo src msysgit 
dict zsl 	foo bar 
free node 	whereas longest ancestor 
zsl 	length requires 
lex gte 	paths use forward 
min zsl 	slashes test-prio-queue.c 
lex lte 	data argc argv 
max zsl 	free strcmp 
node dict 	show prio queue 
zsl 	strcmp prio 
free node 	queue show 
zsl node 	malloc atoi prio 
dict zsl 	queue put 
free node 	test-read-cache.c argc argv 
compare objects 	cnt strtol 
equal 	read cache discard 
objects strtod 	cache test-regex.c 
isnan strtod 	argc argv pat 
isnan strtod 	str regcomp 
isnan strtod 	die regexec die 
isnan incr 	die exit 
count 	http sourceware bugzilla 
incr count 	show bug 
create sdslen 	cgi matches test-revision-walking.c 
create sdslen 	commit ctx 
zsl parse 	rev commit argv 
lex range 	argc got 
item 	revision argc argv 
zsl parse 	format commit 
lex range 	message strbuf 
item decr 	release size init 
count decr 	revisions setup 
count decr 	revisions prepare revision 
count 	walk die 
decr count 	revision print commit 
compare objects 	reset revision 
compare objects 	walk strcmp run 
lex range 	revision walk 
compare objects 	run revision walk 
lex 	test revision 
range compare 	walking test revision 
objects lex 	walking api 
range compare 	heiko voigt hvoigt 
objects lex 	hvoigt net 
range compare 	code free software 
objects 	redistribute modify 
lex range 	terms gnu general 
compare objects 	license version 
zsl lex 	published free 
gte min 	software foundation test-run-command.c 
zsl lex 	number callbacks 
lte 	err task err 
max zsl 	task result 
lex range 	err task argc 
zsl lex 	argv proc 
gte min 	jobs argv pushv 
server zsl 	strbuf addf 
lex 	strbuf addf strbuf 
lte max 	addf strcmp 
zsl lex 	start command strcmp 
range zsl 	exit run 
lex lte 	command atoi strcmp 
max server 	exit run 
zsl 	processes parallel strcmp 
lex gte 	exit run 
min server 	processes parallel 
server ziplist 	strcmp exit run 
memcpy strtod 	processes parallel 
server server 	test run command 
ziplist 	test run 
create create 	command api ilari 
server ziplist 	liusvaara ilari 
memcmp ziplist 	liusvaara elisanet code 
len server 	free software 
ziplist next 	redistribute modify terms 
ziplist 	gnu general 
next server 	license version published 
server ziplist 	free software 
prev ziplist 	foundation test-scrap-cache-tree.c index 
prev server 	hold locked 
ziplist index 	index read cache 
zzl 	die write 
score zsl 	locked index die 
gte min 	test-sha1-array.c sha 
ziplist index 	data argc 
server zzl 	argv line arg 
score zsl 	sha puts 
lte 	sha hex strbuf 
max ziplist 	getline skip 
index zzl 	prefix sha hex 
range ziplist 	die sha 
next server 	append skip prefix 
zzl score 	sha hex 
zsl 	die sha lookup 
gte min 	strcmp sha 
zsl lte 	clear strcmp sha 
max ziplist 	unique die 
next ziplist 	test-sha1.c ctx sha 
index zzl 	bufsz binary 
range 	buffer room strcmp 
ziplist next 	strtoul malloc 
server zzl 	die git sha 
score zsl 	init xread 
lte max 	die errno 
zsl gte 	git sha update 
min 	git sha 
ziplist prev 	fwrite puts sha 
server ziplist 	hex exit 
prev ziplist 	test-sigchain.c argc argv 
zsl lex 	sigchain push 
gte min 	sigchain push sigchain 
decr 	push test-string-list.c 
count ziplist 	list arg list 
zsl lex 	list item 
lte max 	data prefix argc 
decr count 	argv list 
compare objects 	delim maxsplit list 
lex 	delim maxsplit 
range compare 	list prefix list 
objects ziplist 	strcmp list 
index zzl 	split starts strcmp 
lex gte 	atoi list 
min ziplist 	split write 
index 	list list clear 
server zzl 	strcmp xstrdup 
lex lte 	atoi list split 
max ziplist 	place write 
index zzl 	list list clear 
lex range 	free strcmp 
zzl 	parse list filter 
lex gte 	list write 
min zzl 	list compact list 
lex lte 	clear strcmp 
max ziplist 	parse list list 
next server 	duplicates write 
ziplist 	list compact list 
next ziplist 	clear parse 
index zzl 	argument list arg 
lex range 	either separated 
zzl lex 	list indicate empty 
lte max 	list opposed 
zzl 	indicates list 
lex gte 	containing single empty 
min ziplist 	list strdup 
prev server 	must retain items 
ziplist prev 	specified prefix 
ziplist index 	arguments list prefix 
decoded 	test-submodule-config.c argc 
ziplist next 	argv msg argc 
server info 	argv arg 
ziplist compare 	argc output url 
sdslen zzl 	lookup name 
score decr 	commit sha submodule 
count 	commit path 
ziplist next 	name exit parse 
decr count 	submodule config 
ziplist ziplist 	option starts strcmp 
server info 	strcmp die 
sds encoded 	usage setup 
ziplist 	git directory gitmodules 
push sdslen 	config git 
ziplist push 	config hashcpy sha 
ziplist insert 	die usage 
sdslen server 	submodule name submodule 
info ziplist 	path die 
next 	usage submodule free 
ziplist insert 	test-subprocess.c argc 
ziplist index 	argv nogit setup 
decoded ziplist 	git directory 
next server 	gently die strcmp 
info zzl 	setup work 
score 	run command test-svn-fe.c 
zzl insert 	test svnfe 
zzl compare 	usage argc argv 
elements sdslen 	preimage delta 
zzl insert 	preimage view argc 
ziplist 	argv sliding 
next zzl 	view init 
insert decr 	usage buffer init 
count zzl 	die errno 
first range 	buffer init die 
ziplist next 	errno svndiff 
zzl 	apply strtoumax buffer 
score zsl 	deinit die 
lte max 	errno buffer deinit 
ziplist ziplist 	die errno 
zzl first 	strbuf release svndump 
lex range 	init svndump 
ziplist 	read svndump deinit 
next zzl 	svndump reset 
lex lte 	strcmp apply delta 
max ziplist 	usage test 
ziplist ziplist 	svn code exercise 
range zzl 	svn lib 
length 	test-urlmatch-normalization.c argc argv 
server panic 	usage url 
server panic 	url opt 
zmalloc dict 	info strcmp strcmp 
create zsl 	die url 
create ziplist 	normalize die url 
index 	normalize url 
server info 	normalize strcmp one 
ziplist next 	url succeed 
server info 	url normalize succeeds 
zzl score 	fail otherwise 
server info 	two urls succeed 
ziplist 	url normalize 
create create 	succeeds results compare 
zsl insert 	equal strcmp 
server info 	given one url 
dict incr 	url normalize 
count zzl 	succeeds print result 
next 	followed given 
zfree ziplist 	one url url 
server panic 	normalize succeeds 
dict release 	print returned 
zfree zfree 	length followed test-wildmatch.c 
decoded zzl 	argc argv 
insert 	die strncmp strcmp 
decr count 	wildmatch strcmp 
zsl free 	wildmatch strcmp wildmatch 
node zfree 	test.c help 
server panic 	puts phony program 
zset convert 	test xgettext 
zzl 	message extraction translators 
find dict 	test need 
find dict 	translate translators test 
val server 	need translate 
panic strcasecmp 	translators test need 
strcasecmp strcasecmp 	translate translators 
strcasecmp 	test need translate 
reply reply 	translators test 
error reply 	need translate 
error zmalloc 	translators test need 
reply lookup 	translate thread-utils.c 
key write 	ncpus info psd 
sdslen 	mib len 
create zset 	cpucount ret system 
create zset 	info pstat 
ziplist reply 	getdynamic sysctl sysctl 
zzl find 	sysconf pthread 
isnan reply 	mutexattr init pthread 
error 	mutexattr settype 
zzl zzl 	pthread mutex init 
insert zzl 	pthread mutexattr 
insert zzl 	destroy two steps 
length zset 	least function 
convert sdslen 	somewhat coherent even 
zset 	disgusting nest 
convert encoding 	ifdefs availcpu defined 
dict find 	bsd sysctl 
dict key 	defined ncpu 
dict val 	thread-utils.h compat time.h 
isnan reply 	intentionally empty 
error 	file support building 
server info 	git msvc 
zsl zsl 	trace.c key trace 
insert incr 	trace key 
count dict 	err msg file 
val zsl 	line key 
insert 	buf trace bare 
incr count 	secs key 
server info 	buf len key 
dict incr 	buf file 
count server 	line key format 
panic reply 	buf file 
reply 	line argv format 
reply zfree 	buf file 
signal modified 	line key data 
key notify 	buf trace 
keyspace zadd 	perf key 
command zadd 	file line nanos 
command 	format buf 
lookup key 	format key format 
write reply 	argv format 
check type 	key data nanos 
zzl find 	format start 
zzl zzl 	format file line 
length 	key format 
dict find 	file line argv 
dict val 	format file 
server info 	line nanos format 
zsl dict 	path path 
needs resize 	prefix key git 
dict 	work cwd 
resize dict 	key high scaled 
size server 	low scale 
panic notify 	cnt offset highres 
keyspace notify 	command start 
keyspace signal 	time command 
modified 	line argv getenv 
key reply 	strcmp strcmp 
reply reply 	strcasecmp strcmp strcasecmp 
zsl parse 	strlen isdigit 
range reply 	atoi absolute path 
error zsl 	open strerror 
parse 	close trace key 
lex range 	init trace 
reply error 	want free routine 
lookup key 	trace want 
write reply 	gettimeofday localtime strbuf 
check type 	addf strbuf 
zset 	addf strbuf addch 
length reply 	trace want 
zzl range 	write whine pipe 
rank zzl 	trace strbuf 
range score 	complete line 
zzl range 	write whine pipe 
lex 	trace strbuf 
zzl length 	release prepare trace 
zsl range 	line strbuf 
rank zsl 	vaddf print trace 
range score 	line prepare 
zsl range 	trace line strbuf 
lex 	vaddf quote 
needs resize 	argv print trace 
dict resize 	line prepare 
dict size 	trace line strbuf 
server panic 	addbuf print 
signal modified 	trace line trace 
key 	key init 
notify keyspace 	prepare trace line 
notify keyspace 	strbuf addf 
reply zsl 	strbuf addstr strbuf 
free lex 	vaddf print 
range zremrange 	trace line 
command 	start trace vprintf 
zremrange command 	end start 
zremrange command 	trace vprintf end 
dict iterator 	start trace 
dict next 	argv vprintf end 
server panic 	trace strbuf 
ziplist 	start trace performance 
index ziplist 	vprintf end 
next server 	start trace performance 
server panic 	vprintf getnanotime 
server panic 	end start trace 
unused dict 	vprintf end 
release 	start trace argv 
iterator server 	vprintf end 
panic unused 	start trace performance 
unused server 	vprintf end 
panic server 	strbuf reset strbuf 
panic intset 	addstr strbuf 
len 	addstr strbuf 
dict size 	addstr strbuf addch 
server panic 	trace key 
zzl length 	init trace want 
server panic 	xgetcwd git 
server panic 	work trace key 
decr 	quote crnl 
count memset 	git dir trace 
intset dict 	key quote 
key dict 	crnl git common 
next server 	dir trace 
panic server 	key quote crnl 
ziplist 	trace key 
zzl score 	quote crnl trace 
zzl next 	key quote 
server panic 	crnl free trace 
server panic 	clock gettime 
sds encoded 	query performance frequency 
sdslen 	query performance 
server panic 	counter gettimeofday 
create create 	highres nanos gettimeofday 
sds encoded 	nanos gettimeofday 
sdslen server 	nanos highres nanos 
panic zui 	trace performance 
intset 	since trace want 
find zui 	atexit strbuf 
dict find 	reset quote argv 
server panic 	getnanotime git 
zui zzl 	information manager hell 
find dict 	copyright michael 
find 	elkins mutt copyright 
dict val 	oswald buddenhagen 
server panic 	ossi users net 
server panic 	copyright theodore 
zui length 	tytso mit edu 
zui length 	copyright mike 
isnan 	cormack copyright christian 
server panic 	couder program 
reply reply 	free software 
error reply 	redistribute modify terms 
zcalloc lookup 	gnu general 
key write 	license published free 
zfree 	software foundation 
reply strcasecmp 	either version license 
reply zfree 	option later 
strcasecmp strcasecmp 	version program distributed 
strcasecmp strcasecmp 	hope useful 
zfree reply 	without warranty without 
zfree 	even implied 
reply qsort 	warranty merchantability fitness 
create zset 	particular purpose 
memset zui 	see gnu general 
length zui 	license details 
init iterator 	received copy gnu 
zui 	general license 
next isnan 	along program 
zunion inter 	write free software 
aggregate zui 	foundation inc 
find zunion 	temple place suite 
inter aggregate 	boston usa 
zui 	trace file descriptor 
zsl insert 	key env 
incr count 	variable use git 
dict incr 	trace open 
count sds 	twice never reset 
encoded sdslen 	unit tests 
sdslen 	may want disable 
zui clear 	additional trace 
iterator dict 	output print current 
create dict 	timestamp print 
expand zui 	file line align 
length zui 	trace output 
length 	column catches files 
zui init 	names git 
iterator zui 	variadic macros 
next isnan 	fixme move prefix 
dict find 	startup info 
zui zui 	rid arg high 
sds 	number per 
encoded sdslen 	cnt high part 
sdslen dict 	number per 
raw incr 	cnt low part 
count dict 	frequency high 
val zunion 	maximum precision scale 
inter 	factor fits 
aggregate zui 	within bit won 
clear iterator 	overflow multiplied 
dict iterator 	cnt low part 
dict expand 	qpf worked 
dict size 	initialization expect qpc 
dict 	work well 
next dict 	returns nanoseconds since 
key dict 	epoch performance 
val zsl 	tracing favoring 
insert incr 	high precision wall 
count dict 	clock time 
incr 	accuracy initialization succeeded 
count dict 	offset high 
release iterator 	res time initialization 
dict release 	failed fall 
server panic 	back gettimeofday initialize 
signal modified 	offset high 
key 	resolution timer works 
zset convert 	trace.h key 
ziplist needed 	prefix key key 
reply zset 	argv key 
length signal 	buf len format 
modified key 	key format 
notify 	argv format key 
keyspace decr 	data nanos 
count reply 	format start format 
notify keyspace 	file line 
zfree zunion 	key format 
inter command 	file line argv 
zunion 	format file 
inter command 	line key data 
reply reply 	file line 
strcasecmp reply 	nanos fmt prints 
lookup key 	elapsed time 
read reply 	nanoseconds git trace 
check 	performance enabled 
type zset 	prints elapsed time 
length reply 	since start 
reply multi 	git trace performance 
bulk len 	enabled macros 
ziplist index 	file line see 
ziplist 	style declarations 
index server 	used trace context 
info ziplist 	may function 
next server 	compiler supports 
info server 	file consistent function 
info ziplist 	names necessarily 
reply 	unique file function 
bulk reply 	doesn work 
bulk buffer 	gnuc file supplied 
reply zzl 	preprocessor function 
score zzl 	filled compiler constant 
prev zzl 	note variadic 
next 	macros args must 
zsl element 	include last 
rank zsl 	parameter format otherwise 
element rank 	call without 
server info 	variable arguments surplus 
reply bulk 	define foo 
reply 	format bar format 
server panic 	args foo 
zrange command 	test expand bar 
zrange command 	test invalid 
zsl parse 	note gnuc 
range reply 	args drops comma 
error 	non standard 
strcasecmp strcasecmp 	backend functions use 
reply reply 	non macros 
reply lookup 	instead variadic macros 
key read 	trace trailer.c 
reply check 	name key command 
type 	conf info 
zzl last 	previous next token 
range zzl 	conf first 
first range 	conf item separators 
reply server 	end token 
info ziplist 	len len len 
next 	min len 
deferred multi 	str ptr item 
bulk length 	outfile tok 
zzl prev 	val outfile first 
zzl next 	trim empty 
zzl score 	item last 
zsl 	first tok arg 
gte min 	tok first 
zsl lte 	last tok arg 
max server 	tok check 
info ziplist 	item first last 
reply bulk 	next previous 
reply 	first item command 
bulk buffer 	arg cmd 
reply zzl 	buf argv result 
prev zzl 	tok arg 
next zsl 	tok arg tok 
last range 	arg tok 
zsl 	tok tok first 
first range 	tok last 
reply deferred 	tok first tok 
multi bulk 	last arg 
length zsl 	tok tok tok 
gte min 	first tok 
zsl 	last arg 
lte max 	tok tok tok 
reply bulk 	following tok 
reply server 	middle backwards start 
panic deferred 	tok tok 
multi bulk 	first tok last 
length 	arg tok 
zrangebyscore command 	first arg tok 
zrangebyscore command 	next arg 
zsl parse 	applied item item 
range reply 	item dst 
error lookup 	src name item 
key 	previous name 
read reply 	conf key trailer 
check type 	item variable 
zzl first 	name conf key 
range reply 	trailer item 
ziplist next 	variable name 
zzl 	item conf name 
score server 	tok val 
info zsl 	trailer len seps 
lte max 	item tok 
zzl score 	conf item tok 
zsl lte 	val tok 
max 	item tok len 
zzl next 	tok val 
zsl first 	item tok len 
range zsl 	first last 
rank zsl 	trailers arg tok 
last range 	first arg 
zsl 	tok last item 
rank server 	file lines 
panic reply 	lines count lines 
zsl parse 	count start 
lex range 	end title spaces 
reply error 	lines patch 
lookup 	start ignore 
key read 	bytes lines start 
reply check 	outfile lines 
type zsl 	start end outfile 
free lex 	lines tok 
range zzl 	first tok last 
first 	count patch 
lex range 	start trailer start 
zsl free 	trailer end 
lex range 	first item trailers 
reply ziplist 	tempfile file 
next server 	tail outfile file 
info 	place trim 
zzl lex 	empty trailers tok 
lte max 	first tok 
zzl lex 	last arg tok 
lte max 	first lines 
zzl next 	trailer end outfile 
zsl 	isalnum token 
first lex 	len without 
range zsl 	separator strlen token 
rank zsl 	len without 
last lex 	separator strlen strncasecmp 
range zsl 	strcasecmp token 
rank 	isspace strstr strbuf 
server panic 	splice strlen 
zsl free 	strlen free free 
lex range 	free free 
reply zsl 	free free strlen 
parse lex 	isspace last 
range 	non space strchr 
reply error 	strlen print 
strcasecmp reply 	tok val end 
reply zsl 	update last 
free lex 	update first trailer 
range reply 	end strbuf 
lookup 	addstr strbuf replace 
key read 	capture command 
reply check 	error strbuf 
type zsl 	release xstrdup strbuf 
free lex 	trim strbuf 
range zzl 	detach strbuf release 
last 	xstrdup xstrdup 
lex range 	apply command free 
zzl first 	free trailer 
lex range 	item apply item 
reply zsl 	command arg 
free 	input list list 
lex range 	free trailer 
server info 	item apply item 
ziplist next 	command arg 
deferred multi 	input list apply 
bulk length 	item command 
zzl 	check different arg 
prev zzl 	input list 
next zzl 	free trailer item 
lex gte 	apply item 
min zzl 	command check 
lex lte 	different arg input 
max 	list free 
server info 	trailer item free 
ziplist reply 	trailer item 
bulk reply 	end apply item 
bulk buffer 	command arg 
zzl prev 	input list end 
zzl 	token apply 
next zsl 	arg exists list 
last lex 	find apply 
range zsl 	arg apply arg 
first lex 	missing strcasecmp 
range reply 	strcasecmp strcasecmp strcasecmp 
zsl 	strcasecmp strcasecmp 
free lex 	strcasecmp strcasecmp strcasecmp 
range deferred 	strcasecmp strcasecmp 
multi bulk 	xstrdup xstrdup 
length zsl 	xstrdup strcasecmp xcalloc 
lex gte 	duplicate conf 
min 	xstrdup skip prefix 
zsl lex 	strrchr strcmp 
lte max 	warning strcmp exists 
reply bulk 	warning strcmp 
server panic 	missing warning strcmp 
zsl free 	xstrdup skip 
lex 	prefix strrchr size 
range deferred 	strcmp xstrndup 
multi bulk 	conf item free 
length zrangebylex 	warning xstrdup 
command zrangebylex 	warning xstrdup warning 
command lookup 	exists warning 
key 	missing warning die 
read reply 	strbuf addstr 
check type 	strbuf addch strcspn 
reply zset 	strbuf release 
length lookup 	strlen isspace 
key read 	error strlen strbuf 
reply 	strbuf trim 
check type 	strbuf addstr strbuf 
zset score 	trim strbuf 
reply reply 	addstr strbuf trim 
lookup key 	xcalloc xstrdup 
read reply 	duplicate conf xstrdup 
check 	token item 
type zset 	free duplicate conf 
length server 	strncasecmp strncasecmp 
info sds 	parse trailer token 
encoded ziplist 	len without 
index server 	separator token matches 
info 	item trailer 
ziplist next 	item strbuf detach 
server info 	strbuf detach 
ziplist compare 	trailer item strbuf 
sdslen zzl 	detach strbuf 
next reply 	detach trailer 
reply 	item trailer item 
reply dict 	create trailer 
find dict 	item trailer item 
val zsl 	strbuf read 
rank server 	file die errno 
info reply 	strbuf read 
reply 	fileno die errno 
reply server 	strbuf split 
panic zrank 	strbuf release starts 
command zrank 	contains spaces 
command parse 	contains spaces strcspn 
scan cursor 	strbuf addbuf 
reply 	ignore non trailer 
lookup key 	strbuf release 
read reply 	contains spaces find 
check type 	patch start 
scan command 	find trailer end 
copyright salvatore 	find trailer 
sanfilippo 	start print 
antirez gmail 	lines blank line 
dot copyright 	create trailer 
pieter noordhuis 	item trailer item 
pcnoordhuis gmail 	first free 
dot rights 	trailer item stat 
reserved 	die errno 
redistribution use 	isreg die die 
source binary 	strrchr strbuf 
forms without 	strbuf addstr xmks 
modification permitted 	tempfile strbuf 
provided following 	release fdopen tempfile 
conditions 	die errno 
met redistributions 	git config git 
source code 	config read 
must retain 	input file create 
copyright notice 	place tempfile 
list conditions 	process input 
following 	file process command 
disclaimer redistributions 	line args 
binary form 	process trailers lists 
must reproduce 	print free 
copyright notice 	print lines rename 
list conditions 	tempfile die 
following 	errno strbuf list 
disclaimer documentation 	free copyright 
materials provided 	christian couder chriscool 
distribution neither 	tuxfamily length 
name redis 	including punctuation input 
names contributors 	would stripping 
may 	trailing punctuation retaining 
used endorse 	punctuation want 
promote products 	trailer another one 
derived software 	check one 
without specific 	look item name 
prior written 	item already 
permission 	exists create 
software provided 	lookup token matches 
copyright holders 	something config 
contributors express 	trailer item configured 
implied warranties 	trailer command 
including limited 	trailer item trailer 
implied 	command line 
warranties merchantability 	index start patch 
fitness particular 	line count 
purpose disclaimed 	patch message start 
shall copyright 	patch part 
owner contributors 	index first trailer 
liable 	line count 
direct indirect 	trailers trailers searched 
incidental special 	lines index 
exemplary consequential 	count index first 
damages including 	paragraph title 
limited procurement 	cannot trailers start 
substitute 	trailers looking 
goods services 	starting end 
loss use 	line spaces lines 
data profits 	one separator 
business interruption 	index end trailers 
however caused 	line count 
theory 	print lines trailers 
liability whether 	parse trailer 
contract strict 	lines create temporary 
liability tort 	file directory 
including negligence 	original config must 
otherwise arising 	setup first 
way 	print lines trailers 
use software 	print lines 
even advised 	trailers trailer.h file 
possibility damage 	place trim 
sorted api 	empty trailers trailer 
zse ordered 	transport-helper.c debug 
sets 	name helper export 
two data 	marks marks 
structures hold 	refspecs refspec 
elements order 	transport options helper 
log insert 	buffer helper 
operations sorted 	buffer name helper 
data 	buffer str 
structure elements 	url colon transport 
added hash 	data transport 
table mapping 	data buf helper 
redis objects 	refspecs refspec 
scores time 	refspec alloc duped 
elements 	code capname 
added skip 	arg mandatory transport 
list mapping 	data res 
scores redis 	unsupported options options 
objects objects 	transport name 
sorted scores 	data buf ret 
view 	buf transport 
skiplist implementation 	res data 
almost translation 	transport heads fetch 
original algorithm 	data buf 
described william 	posn name transport 
pugh skip 	fastimport helper 
lists 	data cat blob 
probabilistic alternative 	code transport 
balanced trees 	fastexport revlist args 
modified three 	data helper 
ways implementation 	transport heads fetch 
allows repeated 	fastimport data 
scores 	posn buf name 
comparison key 	transport name 
score satellite 	exec data cmdbuf 
data back 	helper duped 
pointer doubly 	ret input transport 
linked list 	push data 
back 	name exec transport 
pointers level 	name exec 
allows traverse 	data transport 
list tail 	heads fetch data 
head useful 	count buf 
zrevrange returns 	remote refs refname 
random 	msg status 
level skiplist 	forced msg buf 
node going 	end data 
create function 	remote refs flags 
zskiplist maxlevel 	buf ret 
inclusive powerlaw 	transport name flags 
alike 	transport remote 
distribution higher 	refs flags force 
levels less 	mirror data 
likely returned 	buf cas options 
store rank 	cas option 
crossed reach 	cas transport remote 
insert 	refs flags 
position key 	helper exporter data 
already inside 	revlist args 
since allow 	buf oid 
duplicated scores 	name flag transport 
insertion score 	remote refs 
redis 	flags data attrs 
never happen 	attr len 
since caller 	space transport push 
zsl insert 	data helper 
test hash 	ret tail posn 
table element 	buf eov 
already 	eon transport name 
inside update 	data fmt 
span covered 	args msgbuf debug 
update inserted 	enabled src 
increment span 	dest src sock 
untouched levels 	dest sock 
function 	state buf bufuse 
used zsl 	src name 
zsl score 	dest name bytes 
zsl rank 	bytes ptg 
element matching 	gtp udt 
score skiplist 	name err tret 
may 	gtp ptg 
multiple elements 	err ret pid 
score need 	name tret 
find element 	pid pid ret 
right score 	input output 
found returns 	state write full 
part 	die errno 
zset range 	strbuf reset strbuf 
test ranges 	getline recvline 
always empty 	write full strlen 
find first 	strlen die 
node contained 	errno strchr transport 
specified 	take fclose 
range returns 	free xmalloc child 
element contained 	process init 
range everything 	argv pushf argv 
range early 	push argv 
forward range 	push ext 
inner 	force argv pushf 
range next 	git dir 
node cannot 	start command die 
check score 	exit dup 
max find 	die errno xfdopen 
last node 	write constant 
contained 	recvline exit strcmp 
specified range 	strcmp strcmp 
returns element 	strcmp strcmp strcmp 
contained range 	strcmp skip 
everything range 	prefix alloc grow 
early forward 	xstrdup strcmp 
range 	strcmp skip prefix 
inner range 	xstrdup skip 
node cannot 	prefix xstrdup starts 
check score 	die parse 
min elements 	fetch refspec 
score min 	free free warning 
max 	strbuf release 
skiplist min 	standard options sigchain 
max inclusive 	push xwrite 
score min 	sigchain pop close 
score max 	close fclose 
deleted note 	finish command free 
function 	helper size 
takes reference 	strcmp size strcmp 
hash table 	strbuf addf 
view sorted 	strbuf addstr quote 
order elements 	style strbuf 
hash table 	addch sendline recvline 
current 	exit strcmp 
node last 	starts strcmp warning 
score min 	strbuf release 
nodes range 	helper option snprintf 
current node 	die helper 
last score 	option helper 
min 	option helper option 
nodes range 	free refspec 
elements rank 	disconnect helper free 
start end 	strbuf addf 
skiplist start 	oid hex strbuf 
end inclusive 	addch sendline 
note 	recvline exit starts 
start end 	warning xstrdup 
need find 	strcmp warning strbuf 
rank element 	release helper 
score key 	child process init 
returns element 	argv push 
cannot 	argv push xdup 
found rank 	argv pushf 
otherwise note 	start command helper 
rank due 	child process 
span zsl 	init dup argv 
header first 	push argv 
element 	push argv 
might equal 	push argv pushf 
zsl header 	argv pushf 
test obj 	argv push start 
non finds 	command helper 
element rank 	importer die strbuf 
rank 	addf sendline 
argument needs 	strbuf reset write 
populate rangespec 	constant finish 
according objects 	command die apply 
min max 	refspecs xstrdup 
parse min 	read die free 
max 	strbuf release 
interval one 	helper dup die 
values prefixed 	errno xfdopen 
character considered 	setvbuf strcmp helper 
open instance 	option warning 
zrangebyscore zset 	warning strbuf addf 
match 	sendline recvline 
min max 	exit strcmp 
zrangebyscore zset 	strcmp die fclose 
instead match 	process connect 
min max 	service helper die 
lexicographic ranges 	process connect 
parse 	service die process 
max min 	connect take 
argument zrangebylex 	fetch helper option 
foo means 	helper option 
foo open 	helper option fetch 
interval foo 	fetch fetch 
means 	starts starts die 
foo closed 	strchr unquote 
interval means 	style strbuf detach 
min possible 	xstrdup strbuf 
means max 	release strcmp free 
possible valid 	strcmp free 
dest 	strcmp free 
pointer redis 	strcmp free strcmp 
used comparision 	free strcmp 
respectively item 	free strcmp free 
exclusive inclusive 	strcmp free 
returned valid 	find name find 
range 	name warning 
err returned 	recvline push update 
dest undefined 	status apply 
populate rangespec 	refspecs update free 
according objects 	strbuf release 
min max 	helper option die 
success 	helper option 
error err 	die helper option 
returned returned 	die helper 
structure must 	strbuf addstr strbuf 
freed zsl 	addch strbuf 
free lex 	addstr strbuf addstr 
range 	oid hex 
otherwise release 	strbuf addch 
needed range 	strbuf addstr strbuf 
valid objects 	addch strbuf 
integer encoded 	addf oid hex 
every item 	list append 
must 	strbuf detach list 
start free 	clear helper 
lex range 	option common push 
structure must 	options strbuf 
called zel 	addch sendline strbuf 
parse lex 	release push 
range 	update refs status 
populated structure 	die common 
success returned 	push options helper 
wrapper compare 	option warning 
objects able 	helper write constant 
handle shared 	apply refspecs 
minstring 	sha strbuf addf 
shared maxstring 	list append 
equivalent inf 	strbuf detach 
inf makes 	oidcpy free strcmp 
sure handle 	resolve strbuf 
inf inf 	addf strbuf addf 
inf 	list append 
inf asap 	list append strbuf 
one special 	release list 
less returns 	append exporter die 
part zset 	list clear 
lex range 	finish command die 
test 	push update 
ranges always 	refs status strbuf 
empty find 	addf rename 
first node 	strbuf release process 
contained specified 	connect take 
lex range 	push refs push 
returns 	refs push 
element contained 	push refs export 
range everything 	strlen strchrnul 
range early 	strncmp helper 
forward range 	process connect take 
inner range 	refs list 
next 	write str full 
node cannot 	write str 
check score 	full recvline exit 
max find 	strchr die 
last node 	strchr alloc xstrdup 
contained specified 	oid hex 
range 	attribute read die 
returns element 	strbuf release 
contained range 	resolve remote symref 
everything range 	xcalloc transport 
early forward 	check allowed getenv 
range inner 	getenv start 
range 	vsnprintf end state 
node cannot 	needs closing 
check score 	shutdown close 
min ziplist 	transfer debug transfer 
backed sorted 	debug read 
api ziplist 	error strerror transfer 
element 	debug transfer 
redis simple 	debug transfer debug 
abstraction used 	xwrite error 
simplifies code 	strerror memmove transfer 
cost performance 	debug state 
compare element 	needs reading udt 
sorted 	read state 
given element 	needs writing udt 
store representation 	write state 
buf move 	needs closing udt 
next entry 	close finished 
values eptr 	pthread error error 
sptr 	strerror pthread 
next entry 	create die strerror 
next entry 	pthread create 
move previous 	die strerror 
entry values 	tloop tloop close 
eptr 	shutdown close 
sptr next 	waitpid error strerror 
entry previous 	wifexited wexitstatus 
entry returns 	error fork die 
part zset 	errno udt 
range used 	kill transfer exit 
internally 	udt copy 
zzl first 	task routine fork 
range zzl 	die errno 
last range 	udt kill transfer 
test ranges 	exit udt 
always empty 	copy task routine 
last 	udt kill 
score empty 	transfer udt kill 
sorted first 	transfer tloop 
score find 	tloop tloop spawnwait 
pointer first 	tasks remote 
element contained 	name list 
specified 	name transport options 
range returns 	fetch pack 
element contained 	send pack one 
range everything 	invoked open 
range early 	output file strbuf 
check score 	getline family 
max 	functions used duped 
move next 	fclose close 
element find 	stuff like taking 
pointer last 	require remain 
element contained 	ignore write errors 
specified range 	nothing since 
returns 	close pipe anyway 
element contained 	likely error 
range everything 	epipe due helper 
range early 	dying report 
check score 	error already old 
min move 	remote helpers 
previous 	setting need 
element moving 	duplicate helper want 
score previous 	use fastexport 
element returns 	done remote helpers 
know also 	advertise bidi 
element returns 	capability required buffer 
part 	complete batch 
zset range 	commands newline sending 
used internally 	data fast 
zzl first 	helpers read back 
range zzl 	data fast 
last range 	stdin could mixed 
test 	commands otherwise 
ranges always 	fast stream remote 
empty last 	helper advertises 
element first 	refspec capability writes 
element find 	refs named 
pointer first 	right hand side 
element 	first refspec 
contained specified 	matching fetching 
lex range 	refspec capability specified 
returns element 	historical reasons 
contained range 	equivalent store result 
everything range 	fetch old 
early 	sha callers git 
check score 	fetch use 
max move 	write feedback terminal 
next element 	populate fetch 
element score 	head determine written 
skip next 	peer update 
element 	fast forward forced 
find pointer 	update yes 
last element 	dup pipe another 
contained specified 	time need 
lex range 	unbuffered version input 
returns element 	pipe file 
contained 	fclose closes 
range everything 	underlying stream buffering 
range early 	changed first 
check score 	operation handle upload 
min move 	pack friends 
previous element 	fire forget warn 
moving 	fails helper 
score previous 	connect inited earlier 
element returns 	marked pushed 
know also 	ignore status reported 
element matching 	remote helper 
element pull 	latter match propagate 
score 	back update 
move next 	remote check statuses 
element element 	status push 
score pair 	nothing force lease 
ziplist use 	options without 
local copy 	values expect already 
eptr 	expanded old 
want modify 	oid expect 
one given 	field ignore transport 
argument todo 	smart options 
function ziplist 	cas altogether instead 
api elements 	enumerate refs 
offset 	follow symbolic refs 
keep offset 	mainly head 
relative might 	linux pipes buffer 
allocated insert 	bytes platforms 
score element 	buffer less attempt 
insert element 	reads writes 
score 	size enough hold 
pair ziplist 	debugging message 
function assumes 	print bidirectional transfer 
element yet 	loop debug 
present list 	message stream state 
first element 	data may 
score 	coming direction stream 
larger score 	state data 
element inserted 	coming direction 
means take 	flushing rest data 
spot list 	stream state 
maintain ordering 	transfer direction finished 
ensure 	unidirectional transfer 
lexicographical ordering 	source destination source 
elements move 	socket destination 
next element 	socket transfer state 
push tail 	transferring flushing 
list yet 	finished buffer buffer 
inserted 	used name 
tail ziplist 	source name destination 
deleted eptr 	closes target 
point sentinel 	writing transfer finished 
ziplist next 	tries read 
element score 	read data source 
longer 	buffer buffer 
range tail 	full data read 
ziplist deleted 	returns success 
eptr point 	error space 
sentinel ziplist 	tries write data 
next element 	buffer destination 
score 	buffer empty data 
longer range 	written returns 
elements rank 	success error nothing 
start end 	write state 
skiplist start 	bidirectional transfer loop 
end inclusive 	direction program 
note 	git direction git 
start end 	program non 
need common 	appropriate errors failure 
sorted api 	name name 
incremented refcount 	error messages returns 
since created 	success failure 
added 	spawn transfer tasks 
dictionary approach 	wait returns 
similar zsl 	success failure 
free since 	close source target 
want free 	writing transfer 
skiplist time 	socket read end 
creating 	left open 
ziplist convert 	isn disaster nobody 
sorted ziplist 	attempts read 
already ziplist 	mingw compat headers 
number elements 	shut fully 
maximum element 	close socket since 
size 	otherwise gtp 
within expected 	task would first 
ranges reference 	close socket 
score specified 	sends data closing 
member sorted 	ptg file 
storing score 	descriptors process appropriate 
element 	errors failure 
exist err 	name name process 
returned otherwise 	error messages 
returned score 	returns success 
correctly populated 	failure spawn transfer 
zobj member 	tasks wait 
err 	returns success failure 
returned sorted 	fork git 
commands command 	program fork program 
zadd zincrby 	git close 
increment score 	streams parent interfere 
instead setting 	end file 
touch 	detection wait tasks 
elements already 	finish copies 
existing touch 	data stdin output 
elements already 	input stdout 
exisitng num 	simultaneously additionally filtering 
elements added 	given filter 
updated 	filter uses identity 
following vars 	filter fill 
used order 	state fields transport.c 
track command 	transport refs 
actually execution 	pretend localname 
reply client 	tmp remotename sha 
trigger 	flag header 
notification keyspace 	transport push data 
change number 	result transport 
elements added 	heads fetch data 
number elements 	transport data 
updated score 	options conn extra 
number 	shallow opts 
elements processed 	name end transport 
may remain 	push data 
zero options 	flags transport push 
like parse 	data refs 
options end 	transport heads fetch 
scoreidx 	data refs 
argument position 	dest args refs 
score first 	tmp remote 
score element 	verbose flag summary 
pair turn 	msg porcelain 
options simple 	sha porcelain 
check 	quickref type msg 
vars options 	dest count 
expect even 	porcelain dest refs 
number args 	verbose porcelain 
since expect 	reject reasons head 
number score 	sha head 
element 	heads heads local 
pairs holds 	remote transport 
number score 	remote refs flags 
element pairs 	data args 
check incompatible 	ret tmp refs 
options start 	transport name 
parsing 	executable data transport 
scores need 	data transport 
emit syntax 	child data url 
error executing 	buf url 
additions sorted 	enabled allowed 
command either 	type allowed type 
execute 	remote url 
fully nothing 	helper ret data 
lookup key 	data len 
create sorted 	handler transport name 
exist key 	protocol reports 
option nothing 	transport verbosity force 
prefer 	progress needs 
non encoded 	pushing transport remote 
element dealing 	refs proc 
ziplists insert 	buf argv transport 
score changed 	refspec refspec 
optimize check 	flags reject reasons 
element 	remote refs 
large list 	local refs match 
becomes executing 	flags verbose 
zzl insert 	quiet porcelain pretend 
need check 	push ret 
sorted empty 	ret err 
know 	needs pushing transport 
least one 	transport refs 
element insert 	refs heads transport 
score changed 	transport name 
safely key 	exec transport ret 
skiplist since 	url scheme 
dictionary 	prefix anon part 
still reference 	anon len 
inserted skiplist 	prefix len data 
update score 	data len 
ptr inserted 	remote transport extra 
skiplist added 	data oid 
dictionary 	resolve starts starts 
zincrby incr 	starts install 
option zadd 	branch config close 
skiplist hash 	read bundle 
table zremrangebyrank 	header die alloc 
zremrangebyscore zremrangebylex 	hashcpy unbundle 
commands 	close free 
step parse 	strcmp strcmp strcmp 
range step 	strcmp strcmp 
lookup range 	strcmp strcmp strtol 
sanity checks 	die git 
needed sanitize 	connect connect setup 
indexes 	remote heads 
invariant start 	xstrdup memset connect 
test end 	setup remote 
range empty 	heads fetch pack 
start end 	close close 
start length 	finish connect free 
step 	refs free 
perform range 	refs free refs 
deletion operation 	free remote 
step notifications 	find tracking update 
reply sorted 	free prettify 
iterators sorted 	refname prettify refname 
iterators 	fputs prettify 
use dirty 	refname fputs 
flags pointers 	fputs fputc fputc 
need cleaned 	find unique 
next iteration 	abbrev print status 
zsetopval dirty 	oid print 
flag 	status starts strbuf 
special since 	addstr status 
values need 	abbrev strbuf addstr 
cleanup instead 	strbuf addstr 
means already 	strbuf addstr status 
ell holds 	abbrev print 
tried 	status strbuf release 
convert another 	print status 
representation successful 	print status print 
opval valid 	status print 
well store 	status print status 
retrieved iterator 	print status 
buffer 	print status print 
skip skip 	status print 
skip check 	status print 
current valid 	status print status 
store passed 	print status 
structure move 	print status resolve 
next 	refdup print 
element valid 	one push status 
means reached 	print one 
end structure 	push status print 
abort move 	one push 
next element 	status strcmp free 
move 	strrchr check 
next element 	refname format die 
need check 	connect setup 
better move 	remote heads memset 
next element 	send pack 
move next 	close close finish 
element 	connect git 
already flag 	connect packet 
valid find 	flush close close 
pointed val 	finish connect 
source pointer 	free die xcalloc 
found store 	stat isreg 
score 	strchr getenv list 
target otherwise 	split list 
score already 	sort protocol whitelist 
zzl find 	list transport 
result adding 	allowed die protocol 
two doubles 	whitelist xcalloc 
one 	isatty die urlschemechar 
variable inf 	starts xstrndup 
inf numbers 	transport helper init 
added maintain 	starts die 
convention result 	url local ssh 
safety net 	file bundle 
expect 	xcalloc transport check 
setnum input 	allowed url 
keys given 	starts starts 
test expected 	starts starts starts 
number keys 	xcalloc external 
would overflow 	specification len xmemdupz 
read 	transport helper 
keys used 	init git option 
input weights 	option isatty 
parse optional 	list clear die 
extra arguments 	find hook 
sort sets 	start command finish 
smallest 	command sigchain 
largest improve 	push strbuf init 
algorithm performance 	strbuf reset 
skip everything 	strbuf addf oid 
smallest input 	hex oid 
empty precondition 	hex write full 
src 	strbuf release 
non empty 	close sigchain pop 
inputs ordered 	finish command 
size src 	transport verify 
non empty 	remote names die 
safe access 	push local 
zset 	heads check push 
iterating explicitly 	refs refs 
check equal 	list match push 
present every 	refs empty 
input added 	cas apply push 
skiplist added 	cas status 
dictionary 	push run pre 
least large 	push hook 
largest resize 	bare repository oid 
dictionary asap 	push unpushed 
avoid useless 	submodules die bare 
rehashing step 	repository oid 
create 	find unpushed submodules 
dictionary elements 	die unpushed 
aggregated scores 	submodules push refs 
iterating one 	push errors 
sorted initialize 	transport print 
search element 	push status upstreams 
accumulating 	transport update 
dictionary need 	tracking puts transport 
create entry 	refs pushed 
remember longest 	refs list oid 
single element 	oidcmp alloc 
encountered understand 	grow alloc fetch 
possible 	free unlink 
convert ziplist 	warn free connect 
end element 	die disconnect 
initial score 	free strchr url 
update score 	local ssh 
score instance 	strlen strstr strchr 
element 	isalnum strchr 
found current 	xstrfmt xstrdup xstrdup 
sorted access 	real path 
directly dict 	strlen memcmp 
entry inside 	memcpy directory remote 
big speedup 	transport transport 
compared 	remote refs transport 
api step 	disconnect free 
convert dictionary 	alt odb check 
sorted aware 	suitability tracking 
size resulting 	must successful already 
sorted resize 	date create 
dictionary 	modify follow symbolic 
embedded inside 	refs mainly 
sorted right 	head source destination 
size order 	must local 
save rehashing 	branches matching refspec 
time added 	okay maybe 
skiplist 	foreign url deprecated 
added dictionary 	use deprecated 
free accumulator 	use builtin smart 
dictionary sanitize 	transports allowed 
indexes invariant 	transports individually 
start test 	git connect unknown 
end 	protocol url 
range empty 	pass external handler 
start end 	either report 
start length 	report success either 
result form 	reports invalid 
multi bulk 	report otherwise report 
reply 	unknown report 
check starting 	unknown rules used 
point trivial 	determine whether 
log lookup 	report progress processing 
command zrangebyscore 	aborts rule 
zrevrangebyscore parse 	satisfied report progress 
range 	force progress 
arguments range 	progress report progress 
given max 	force progress 
min range 	progress report progress 
given min 	verbosity quiet 
max parse 	report progress 
optional 	isatty mind hook 
extra arguments 	read refs 
note zcount 	maybe fixme important 
exactly arguments 	transport uses 
never enter 	deepening shallow repository 
following 	requested local 
code path 	remote refs likely 
lookup key 	still equal 
range reversed 	feed fetch method 
last node 	condition shouldn 
range starting 	met non deepening 
point 	fetch see 
first element 	builtin fetch quickfetch 
specified interval 	strip username 
score pointer 	password url newly 
first element 	allocated cannot 
know advance 	path name make 
many 	sure scheme 
matching elements 	reasonable rfc 
list push 	isn past first 
represent multi 	slash count 
bulk length 	git repository refs 
output buffer 	transport.h depth 
fix 	uploadpack receivepack cas 
later offset 	remote url 
traverse number 	data remote refs 
elements without 	connection name 
checking score 	transport push transport 
done next 	refs refs 
loop 	transport refs flags 
abort node 	connection refspec 
longer range 	refspec flags connection 
know element 	name executable 
exists ziplist 	connection pack lockfile 
always succeed 	smart options 
move 	remote type 
next node 	type transport name 
reversed last 	transport verbosity 
node range 	force progress connection 
starting point 	refspec refspec 
first element 	flags reject reasons 
specified 	transport transport 
interval know 	refs transport transport 
advance many 	url transport 
matching elements 	child transport name 
list push 	exec transport 
represent multi 	name input output 
bulk 	heads heads 
length output 	remote verbose dest 
buffer fix 	refs verbose 
later offset 	porcelain reject reasons 
traverse number 	indicates whether 
elements without 	already called refs 
checking 	list transport 
score done 	transport remote 
next loop 	refs transports call 
abort node 	take destroys 
longer range 	data specific transport 
move next 	type cannot 
node 	reused hint caller 
parse range 	performing clone 
arguments lookup 	normal fetch iow 
sorted use 	repository guaranteed 
first element 	empty returns successful 
range starting 	positive option 
point 	recognized inapplicable negative 
first element 	option applicable 
first element 	invalid returns list 
range iterate 	remote side 
elements range 	refs order allow 
abort node 	transport share 
longer 	connections push hint 
range find 	whether ultimate 
first element 	operation push 
range use 	fetch transport able 
rank first 	determine remote 
element determine 	hash without huge 
preliminary 	amount effort 
count find 	store old sha 
last element 	field otherwise 
range use 	fetch objects given 
rank last 	refs note 
element determine 	gets ignore list 
actual 	structure transport 
count parse 	hashes refs refs 
range arguments 	list old 
lookup sorted 	sha fields provided 
use first 	refs push 
element range 	objects refs send 
starting 	necessary objects 
point first 	refs peer peer 
element first 	oid different 
element range 	old oid 
iterate elements 	tell remote side 
range abort 	update list 
node 	old oid peer 
longer range 	oid possible 
find first 	status appropriately transport 
element range 	must modify 
use rank 	sha remote accepted 
first element 	change note 
determine 	could different peer 
preliminary count 	oid process 
find last 	involved generating commits 
element range 	refs list 
use rank 	fetch push refs 
last element 	keep resources 
determine 	connection reserved use 
actual count 	disconnect releases 
command zrangebylex 	resources transports directly 
zrevrangebylex parse 	use without 
range arguments 	check isatty 
range given 	quiet transport verbose 
max 	etc checking 
min range 	already done transport 
given min 	verbosity transport 
max parse 	least potentially smart 
optional extra 	points git 
arguments note 	transport options structure 
zcount 	use transport 
exactly arguments 	actually turns smart 
never enter 	returns transport 
following code 	suitable url check 
path lookup 	whether transport 
key range 	allowed environment type 
reversed 	generally url 
last node 	scheme described documentation 
range starting 	git txt 
point first 	check whether 
element specified 	transport allowed environment 
interval score 	die otherwise 
pointer 	returns user attempted 
first element 	turn protocol 
know advance 	restrictions transport options 
many matching 	apply git 
elements list 	scp style program 
push represent 	use remote 
multi 	side send pack 
bulk length 	program use 
output buffer 	remote side receive 
fix later 	pack transfer 
offset traverse 	data thin pack 
number elements 	check current 
without 	remote keep pack 
checking score 	transferred limit 
done next 	depth fetch aggressively 
loop abort 	fetch annotated 
node longer 	tags possible 
range know 	accept refs may 
element 	update git 
exists ziplist 	shallow without depth 
always succeed 	send push 
move next 	certificates returns option 
node reversed 	used non 
last node 	zero otherwise prints 
range 	message stderr 
starting point 	option used transport 
first element 	methods defined 
specified interval 	outside transport common 
know advance 	methods used 
many matching 	transport builtin send 
elements 	pack tree-diff.c 
list push 	sha parents sha 
represent multi 	nparent opt 
bulk length 	old opt cmp 
output buffer 	opt sha 
fix later 	mode addremove 
offset 	last nparent path 
traverse number 	pathlen mode 
elements without 	sha len alloclen 
checking score 	opt nparent 
done next 	imin mode path 
loop abort 	sha pathlen 
node 	old baselen isdir 
longer range 	emitthis keep 
move next 	pprev tpi valid 
node existing 	sha mode 
elements always 	parents sha tpi 
rank util.c 	valid opt 
cbopaque 	nparent sha parents 
uppercase slen 	sha nparent 
sign slen 	opt ttree tptree 
alt form 	imin cmp 
slen alt 	done sha parents 
form uppercase 	sha nparent 
slen 	opt old 
cbopaque result 	opt diff opts 
result err 	choice path 
buf buflen 	old opt phead 
nptr endptr 	pathchange old 
ret digit 	pprev old str 
neg 	opt retval 
pret uppercase 	opt name compare 
slen digits 	entry len 
digits sign 	entry len change 
slen neg 	combine diff 
alt form 	path size free 
slen 	xmalloc memcpy 
alt form 	memcpy hashcpy entry 
uppercase slen 	extract entry 
str size 	len isdir entry 
format ret 	extract entry 
alt form 	len isdir 
left 	diff opt tst 
justify plus 	diff opt 
space plus 	tst path appendnew 
plus prec 	hashcpy pathchange 
width len 	xalloca strbuf strbuf 
uwidth uprec 	addch diff 
slen 	paths xalloca free 
jemalloc silence 	strbuf setlen 
init buf 	entry interesting update 
jemalloc silence 	entry update 
init buf 	entry xalloca xalloca 
jemalloc silence 	fill descriptor 
init 	fill descriptor diff 
buf jemalloc 	opt tst 
silence init 	diff quit early 
buf val 	skip uninteresting 
buf val 	skip uninteresting entry 
buf str 	pathcmp entry 
size 	pathcmp diff 
format ret 	opt tst hashcmp 
write cbopaque 	emit path 
format buf 	update entry update 
write cbopaque 	entries emit 
format format 	path update entry 
syscall 	diff opt 
strlen write 	tst emit path 
strlen malloc 	update entries 
message wrtmessage 	free free xalloca 
format message 	free xalloca 
strerror strncpy 	free diff paths 
strerror 	free diff 
errno errno 	file valid guard 
errno reached 	pathspec diff 
memcpy arg 	setup diff opt 
errno malloc 	diff opt 
strtoumax errno 	diff setup done 
arg 	diff sha 
errno malloc 	diffcore std 
strtoumax errno 	free pathspec strcmp 
append arg 	free pathspec 
numeric append 	parse pathspec diff 
padded arg 	free filepair 
numeric 	diff paths free 
append padded 	strbuf init 
arg numeric 	strbuf addstr diff 
append padded 	sha diff 
arg numeric 	opt tst diff 
append padded 	might rename 
implemented 	follow renames strbuf 
arg append 	release diff 
padded implemented 	sha helper functions 
arg strlen 	diff generation 
append padded 	mode marker saying 
arg numeric 	entry entry 
append 	imin see diff 
padded reached 	paths means 
append start 	update use 
malloc vsnprintf 	emit entry diff 
end malloc 	unset compare 
vsnprintf write 	two entries taking 
start 	account path 
malloc vcprintf 	isdir mode sha 
end start 	note files 
malloc vcprintf 	directories always compare 
end function 	differently even 
prototypes non 	name thanks name 
functions 	compare note 
malloc message 	empty invalid descriptor 
setup use 	take part 
syscall rather 	comparison infty sort 
write possible 	valid entries 
order avoid 	due convention trees 
possibility 	scanned sorted 
memory allocation 	order non 
within libc 	empty descriptors processed 
necessary free 	first empty 
bsd operating 	descriptors sort valid 
systems problem 	entries convert 
though 	path opt diff 
wrapper around 	callbacks emits 
malloc message 	diff first parent 
avoids need 	tells diff 
malloc message 	walker done freed 
throughout code 	done make 
glibc 	combine diff path 
provides non 	path mode 
standard strerror 	sha append paths 
gnu source 	list tail 
defined provide 	memory created elements 
wrapper swallow 	could reused 
leading 	last next memory 
whitespace sign 	allocated last 
fall fall 	next assumed 
prefix note 	last next returned 
first non 	earlier function 
whitespace sign 	next modified memory 
character 	reused clients 
possible tell 	need keep element 
whether digits 	path appendnew 
consumed convert 	process next need 
overflow conversion 	keep element 
performed characters 	processing pprev path 
converted 	appendnew process 
fall left 	pprev forget free 
padding right 	tail next 
padding synthetic 	end parent remains 
used flags 	uninitialized last 
width width 	next pre allocated 
precision 	memory reuse 
separator precision 	next round next 
length conversion 	holds many 
specifier caller 	bytes allocated 
provide alternate 	faster realloc need 
write callback 	copying old 
function 	data path added 
use one 	combine diff 
malloc write 	cases called behaves 
function use 	path added 
malloc message 	parents lack path 
directly print 	removed parents 
callback 	path modified added 
function way 	imin otherwise 
hopefully avoid 	least something valid 
memory allocation 	path present 
print stderr 	resulting path removed 
way avoid 	take path 
memory 	imin parent also 
allocation copyright 	take mode 
salvatore sanfilippo 	parent decide recursion 
antirez gmail 	modes imin 
dot rights 	wrt isdir 
reserved redistribution 	thanks name compare 
use 	valid present 
source binary 	imin otherwise ignore 
forms without 	path filtered 
modification permitted 	consumed need list 
provided following 	reuse memory 
conditions met 	leaving pre allocated 
redistributions 	element tail 
source code 	hand path needs 
must retain 	kept need 
copyright notice 	correct next pre 
list conditions 	initialized much 
following disclaimer 	memory allocated see 
redistributions 	path appendnew 
binary form 	details rule emitthis 
must reproduce 	generate paths 
copyright notice 	combined diff sha 
list conditions 	parents sha 
following disclaimer 	resulting paths 
documentation 	appended combine diff 
materials provided 	path linked 
distribution neither 	list also emitted 
name redis 	via opt 
names contributors 	pathchange callback possible 
may used 	process result 
endorse 	batch incrementally paths 
promote products 	generated scanning 
derived software 	parents trees simultaneously 
without specific 	similarly diff 
prior written 	trees theory behind 
permission software 	scan follows 
provided 	calculation scheme regarding 
copyright holders 	resulting paths 
contributors express 	diff combined diff 
implied warranties 	parents start 
including limited 	trees sorted 
implied warranties 	compare entries step 
merchantability 	imin argmin 
fitness particular 	time could cases 
purpose disclaimed 	imin imin 
shall copyright 	imin schematic deduction 
owner contributors 	every means 
liable direct 	follows imin imin 
indirect 	imin imin 
incidental special 	imin imin imin 
exemplary consequential 	imin imin 
damages including 	imin remains investigate 
limited procurement 	imin investigate 
substitute goods 	looking imin imin 
services 	imin imin 
loss use 	note usual diff 
data profits 	definition combined 
business interruption 	diff diff paths 
however caused 	generator used 
theory liability 	plain diffs 
whether 	generation please keep 
contract strict 	attention common 
liability tort 	working code order 
including negligence 	slow note 
otherwise arising 	nparent must imin 
way use 	load parents 
software 	first probably already 
even advised 	cached log 
possibility damage 	diff parses commit 
glob style 	parent calling 
pattern matching 	via diff sha 
match match 	parent commit 
match 	enable recursion indefinitely 
match match 	comparing finished 
fall match 	trees done lookup 
match convert 	imin argmin 
representing amount 	mark entries whether 
memory number 	imin along 
bytes 	way fixup 
instance memtoll 	markings entries imin 
parsing error 	imin compare 
err otherwise 	imin imin either 
error function 	imin diff 
regardless fact 	imin diff imin 
err 	imin imin 
unit multiplier 	imin imin imin 
search first 	imin imin 
non digit 	free pre allocated 
character copy 	last element 
digits buffer 	see path appendnew 
use 	details look 
strtoll convert 	like resulting diff 
digit without 	might due 
unit number 	rename single entry 
number digits 	valid previous 
converted radix 	file follow rename 
see 	code specific 
information like 	need exactly 
digits values 	one path magic 
abs llong 	matches one 
min requires 	path supported reject 
special handling 	wildcards well 
minus 	unfortunately haven got 
convert returns 	reliable way 
number characters 	detect foo bar 
needed represent 	fact wildcards 
number buffer 	nowildcard len merely 
big enough 	hint optimization 
store 	slip wildmatch taught 
returned following 	dry run 
article apparently 	mode returns wildcard 
provide novel 	info file 
approach publicizes 	creation entry diff 
already 	queue remember 
used technique 	filepairing see 
https www 	find interesting one 
facebook notes 	found source 
facebook engineering 	use diff queued 
three optimization 	diff also 
tips 	use path future 
modified order 	file pairs 
handle integers 	around update path 
since original 	use caller 
code designed 	expects vanilla filepairs 
integers main 	later call 
loop 	diffcore std makes 
works bit 	sort renames 
integers simplicity 	among things already 
convert number 	found renames 
remember negative 	signal diffcore std 
check length 	muck rename 
term 	information discard non 
handle last 	relevant file 
digits sign 	pairs instate 
convert returns 	one want might 
could parsed 	either original 
non overflowing 	one rename copy 
otherwise 	found tree-walk.c 
parsed appropriate 	str modep mode 
special first 	desc buf 
digit abort 	size path mode 
negative sign 	len desc 
first digit 	buffer size desc 
otherwise 	sha size 
overflow overflow 	buf desc buf 
bytes used 	end size 
overflow overflow 	len desc entry 
convert returns 	info pathlen 
could parsed 	dummy path info 
non 	len pathlen 
overflowing otherwise 	prev ptr skip 
parsed appropriate 	len len 
convert representation 	cmp first 
returns number 	first len path 
bytes required 	len probe 
representation 	skip skip info 
always parsable 	still interesting 
strtod see 	info error entry 
http wikipedia 	interesting traverse 
wiki zero 	path trees used 
comparisons check 	mask dirmask 
safe 	first first len 
range casted 	len size 
assuming bit 	sha name result 
also assuming 	mode namelen 
implementations around 	entry sha entrylen 
precision bit 	cmp sha 
assumptions 	name sha mode 
test inside 	retval size 
interval casting 	root parent link 
safe two 	len len 
castings make 	contents contents 
sure part 	start parent match 
zero 	entry item 
use integer 	match len ret 
printing function 	item match 
much faster 	matchlen item baselen 
generate redis 	matched match 
run sha 	matchlen dirlen item 
sized 	match str 
random number 	matched entry offset 
identifies given 	die mode 
execution redis 	die strlen canon 
talking instance 	mode decode 
run reconnect 	entry read reference 
run 	die sha 
sure either 	hex init desc 
different instance 	memset die 
restarted state 	decode entry 
sha seed 	update entry strlen 
dev urandom 	memset entry 
counter 	len memcpy entry 
hash seed 	len name 
initialize seed 	compare memcmp entry 
use sha 	clear entry 
counter mode 	extract update entry 
hash seed 	entry len 
progressive 	check entry match 
counter goals 	entry clear 
function need 	entry extract entry 
non colliding 	len check 
cryptographic security 	entry match entry 
needs convert 	clear update 
hex 	entry entry clear 
digits read 	update entry 
dev urandom 	xmalloc free entry 
reasonable effort 	interesting xmalloc 
order create 	xcalloc strbuf 
entropy since 	grow make traverse 
function 	path strbuf 
used generate 	setlen xstrndup xstrndup 
run cluster 	extended entry 
instance use 	extract entry len 
time pid 	name compare 
fill initial 	extended entry extract 
xor 	entry len 
rand output 	name compare entry 
already seeded 	clear isdir 
time startup 	prune traversal update 
convert hex 	extended entry 
digits given 	free free extended 
filename 	entry free 
absolute path 	free strbuf release 
sds fails 	strlen entry 
reason note 	extract entry len 
filename may 	update entry 
absolute path 	memcmp hashcpy 
already 	isdir hashcpy entry 
detected handled 	read reference 
correctly function 	hashcpy free init 
normalize everything 	desc find 
obvious one 	entry free init 
appearning start 	desc strchr 
filename 	strcmp strbuf free 
relative path 	init desc 
path already 	strbuf hashcpy find 
absolute path 	entry isdir 
relative cwd 	hashcpy strbuf isreg 
relative path 	hashcpy islnk 
point 	read sha file 
current path 	strbuf addstr 
always ending 	free init desc 
trimmed relative 	strbuf splice 
path normalize 	free free free 
obvious trailing 	strbuf release 
elements 	strncmp strncmp 
start path 	basecmp basecmp basecmp 
every find 	match dir 
filename also 	prefix within depth 
last element 	isdir basecmp 
cwd unless 	match entry git 
current 	fnmatch isdir 
cwd glue 	match wildcard strbuf 
two parts 	git fnmatch 
together specified 	strbuf setlen strbuf 
path file 	setlen isdir 
basename without 	match match isdir 
relative 	initialize descriptor 
absolute path 	entry caller wants 
function checks 	pick nothing 
character exists 	looking name trivially 
inside specified 	happy three 
path enough 	possibilities could hiding 
environments 	behind sorts 
redis runs 	earlier matter 
may start 	subtree blob otherwise 
leading space 	know won 
trailing space 	appear without scanning 
may start 	common first 
overflow 	reading sync trees 
overflow may 	comes matter 
start may 	len len memcmp 
start overflow 	len len 
overflow pow 	keep looking comes 
err input 	looking keep 
expected 	looking cannot appear 
remainder expected 	extended desc 
errno expected 	extract first name 
errno name 	entry paying 
expected tests 	attention candidate first 
test err 	name importantly 
result 	looking entry 
remainder buf 	entries sorts earlier 
result len 	representation name 
buf result 	skip process named 
pow ceil 	entry first 
pow ceil 	remember haven processed 
pow 	first entry 
ceil pow 	yet later call 
ceil pow 	skip entry 
ceil errno 	processed early update 
malloc strtoumax 	extended entry 
errno errno 	called underlying entries 
malloc 	blob blob 
strtoumax errno 	blob first asks 
str test 	remember still 
test test 	need process extract 
test test 	processing entry 
test test 	call caller know 
test 	calling update 
test test 	extended entry 
test test 	remember processed already 
test test 	extract first 
test test 	entry desc skip 
test test 	ones already 
test 	returned earlier rounds 
test test 	found found 
test test 	processed entry already 
test test 	caller wants 
test test 	first nothing need 
test test 	look ahead 
test 	suspect subtree whose 
test test 	name first 
test test 	may hiding behind 
test test 	current entry 
test test 	path keep looking 
test test 	returned entry 
test 	early may current 
test test 	location even 
test test 	though may 
test test 	subtree behind another 
test test 	may want 
test test 	grab trees match 
test 	cull ones 
test test 	earliest entry earliest 
test test 	name trees 
test test 	linux built max 
test test 	number symlinks 
test test 	follow limit course 
test 	affect git 
test test 	reasonable choice find 
test test 	entry following 
test test 	symlinks sha assumed 
test test 	root repository 
test test 	symlink points outside 
test 	repository link 
test test 	foo root level 
test test 	link foo 
test test 	portion link 
test test 	outside repository returned 
test test 	result path 
test 	mode assumed result 
test test 	path uninitialized 
test test 	symlinks end result 
test test 	symlink chain 
test test 	points inside repository 
test test 	result filled 
function 	sha found mode 
prototypes non 	hold mode 
functions malloc 	see code follow 
message setup 	symlink result 
use syscall 	description values descend 
rather write 	handle symlinks 
possible 	removing leading slashes 
order avoid 	split namebuf 
possibility memory 	first component 
allocation within 	remainder could end 
libc necessary 	namebuf appears 
free bsd 	symlink could end 
operating 	via symlink 
systems problem 	dir look first 
though wrapper 	path component 
around malloc 	descend follow symlink 
message avoids 	many symlinks 
need malloc 	followed point followed 
message 	least one 
throughout code 	symlink error need 
glibc provides 	report signals 
non standard 	haven called strncmp 
strerror gnu 	never interesting 
source defined 	trick requires exact 
provide 	matching could 
wrapper swallow 	something clever inexact 
leading whitespace 	matching trickier 
sign fall 	forget strcasecmp 
fall prefix 	locale dependent least 
note first 	glibc disable 
non 	worse wildcard codepath 
whitespace sign 	pattern seen 
character possible 	match sorts later 
tell whether 	current path 
digits consumed 	match sort strictly 
convert overflow 	earlier path 
conversion 	common parts come 
performed characters 	even means 
converted fall 	least one pathspec 
left padding 	would sort 
right padding 	equal later path 
synthetic used 	currently looking 
flags 	words never reached 
width width 	point iterating 
precision separator 	pathspecs means pathspecs 
precision length 	either outside 
conversion specifier 	inside sorts 
caller provide 	strictly earlier current 
alternate 	one either 
write callback 	never match subsequent 
function use 	entries initialized 
one malloc 	variable returned allowing 
write function 	caller terminate 
use malloc 	early cheated strncmp 
message 	common part 
directly print 	matched earlier hit 
callback function 	rejected path 
way hopefully 	leading directory shorter 
avoid memory 	match match 
allocation print 	entry check prefix 
stderr 	part matched 
way avoid 	sensitively entry directory 
memory allocation 	part prefix 
copyright salvatore 	rematched eventually basecmp 
sanfilippo antirez 	special treatment 
gmail dot 	prefix icase 
rights 	aware compare subdirectory 
reserved redistribution 	path specified 
use source 	interesting random prefix 
binary forms 	match perform 
without modification 	matching leading non 
permitted provided 	wildcard part 
following 	pathspec item nowildcard 
conditions met 	len must 
redistributions source 	greater zero non 
code must 	zero matched 
retain copyright 	wildcard part considered 
notice list 	function early 
conditions 	longer non wildcard 
following disclaimer 	part match 
redistributions binary 	early shorter non 
form must 	wildcard part 
reproduce copyright 	match note 
notice list 	ends sure really 
conditions 	matches directory 
following disclaimer 	could entry non 
documentation materials 	wildcard part 
provided distribution 	similar never interesting 
neither name 	optimization match 
redis names 	entry happy comparison 
contributors 	entry interesting 
may used 	given pathspec pre 
endorse promote 	condition either 
products derived 	baselen offset empty 
software without 	path baselen 
specific prior 	trailing slash doesn 
written 	match move 
permission software 	along either must 
provided copyright 	must match 
holders contributors 	match directories match 
express implied 	files later 
warranties including 	concatenate entry 
limited 	path one fnmatch 
implied warranties 	could avoid 
merchantability fitness 	concatenation certain cases 
particular purpose 	saves memcpy 
disclaimed shall 	potentially realloc turns 
copyright owner 	worth measurement 
contributors 	linux show clear 
liable direct 	improvements partly 
indirect incidental 	nowildcard len optimization 
special exemplary 	git fnmatch 
consequential damages 	avoid micro optimizations 
including limited 	match wildcard 
procurement 	says directory already 
substitute goods 	matched need 
services loss 	match rest shorter 
use data 	theory faster 
profits business 	match directories match 
interruption however 	files later 
caused 	max depth 
theory liability 	ignored may consider 
whether contract 	support future 
strict liability 	see http gmane 
tort including 	gmane comp 
negligence otherwise 	version control git 
arising 	focus matches 
way use 	entry interesting given 
software even 	pathspec pre 
advised possibility 	condition either baselen 
damage glob 	offset empty 
style pattern 	path baselen trailing 
matching 	slash entry 
match match 	positive negative result 
match match 	file file 
match fall 	file file file 
match match 	file file 
convert representing 	file file file 
amount 	dir dir 
memory number 	dir dir 
bytes instance 	dir dir dir 
memtoll parsing 	dir dir 
error err 	dir exclude pattern 
otherwise error 	interested directory 
function 	necessarily mean exclude 
regardless fact 	directory wildcard 
err unit 	decide looking individual 
multiplier search 	files inside 
first non 	write directories yet 
digit character 	tree-walk.h sha 
copy 	path mode buffer 
digits buffer 	entry size 
use strtoll 	desc pathp modep 
convert digit 	desc desc 
without unit 	buf size desc 
number number 	name entry 
digits 	desc sha info 
converted radix 	traverse path 
see information 	prev name 
like digits 	pathlen pathspec conflicts 
values abs 	data show 
llong min 	errors path info 
requires 	info info 
special handling 	entry len helper 
minus convert 	function entry 
returns number 	extract update entry 
characters needed 	returns success 
represent number 	includes links initial 
buffer 	symlink missing 
big enough 	initial symlink transitively 
store returned 	points missing 
following article 	file somewhere along 
apparently provide 	symlink chain 
novel approach 	path requested contains 
publicizes 	file non 
already used 	element general 
technique https 	positive means kind 
www facebook 	interesting subsequent 
notes facebook 	entries either yes 
engineering three 	subsequent entries 
optimization 	tree.c type sha 
tips modified 	baselen pathname 
order handle 	mode stage opt 
integers since 	len size 
original code 	sha pathname mode 
designed integers 	stage context 
main 	sha pathname mode 
loop works 	stage context 
bit integers 	stage pathspec context 
simplicity convert 	desc entry 
number remember 	sha len oldlen 
negative check 	commit baselen 
length 	stage pathspec context 
term handle 	ret stage 
last digits 	match err 
sign convert 	sha obj item 
returns could 	buffer size 
parsed non 	item quiet missing 
overflowing 	buffer size 
otherwise parsed 	sha obj isdir 
appropriate special 	strlen cache 
first digit 	entry size xcalloc 
abort negative 	create mode 
sign 	create flags memcpy 
first digit 	memcpy hashcpy 
otherwise overflow 	cache entry read 
overflow bytes 	one entry 
used overflow 	opt read one 
overflow convert 	entry opt 
returns 	parse init desc 
could parsed 	entry entry 
non overflowing 	interesting isdir hashcpy 
otherwise parsed 	isgitlink lookup 
appropriate convert 	commit die 
representation returns 	sha hex parse 
number 	commit die 
bytes required 	sha hex hashcpy 
representation always 	entry len 
parsable strtod 	strbuf strbuf addch 
see http 	read lookup 
wikipedia wiki 	strbuf setlen strbuf 
zero 	read strbuf 
comparisons check 	release cache name 
safe range 	stage compare 
casted assuming 	stage stage stage 
bit also 	read recursive 
assuming implementations 	cache free qsort 
around 	lookup create 
precision bit 	alloc node type 
assumptions test 	read sha 
inside interval 	file error oid 
casting safe 	hex free 
two castings 	error oid 
make 	hex parse buffer 
sure part 	free parse 
zero use 	parse used caller 
integer printing 	knows existing 
function much 	entries stage conflict 
faster generate 	entry added 
redis 	currently existing callers 
run sha 	function call 
sized random 	stage making sure 
number identifies 	nothing stage 
given execution 	could always use 
redis talking 	read one 
instance 	entry quick decide 
run reconnect 	straighten git 
run sure 	read use unpack 
either different 	trees cases 
instance restarted 	probably start 
state sha 	matter see cache 
seed 	entry stage 
dev urandom 	original slow way 
counter hash 	otherwise append 
seed initialize 	sort end sort 
seed use 	cache entry 
sha counter 	need nuke cache 
mode 	though tree.h 
hash seed 	type buffer size 
progressive counter 	sha item 
goals function 	buffer size quiet 
need non 	missing sha 
colliding cryptographic 	baselen stage pathspec 
security 	context stage 
needs convert 	pathspec parse gently 
hex digits 	parses returns 
read dev 	given ent chasing 
urandom reasonable 	tags commits 
effort order 	unicode widthh 
create 	zero width width 
entropy since 	plane plane 
function used 	plane plane plane 
generate run 	plane plane 
cluster instance 	plane plane plane 
use time 	plane plane 
pid 	plane plane plane 
fill initial 	plane plane 
xor rand 	unistd.h win define 
output already 	porting git 
seeded time 	mode ssize defines 
startup convert 	access access 
hex 	mode doesn define 
digits given 	doesn seem 
filename absolute 	hurt check file 
path sds 	existence well 
fails reason 	maybe hurt newer 
note filename 	versions msvcrt 
may 	access mode 
absolute path 	causes invalid parameter 
already detected 	error access 
handled correctly 	doesn check execute 
function normalize 	permission check 
everything obvious 	write permission check 
one 	read permission 
appearning start 	fifo character block 
filename relative 	ever directory 
path path 	regular file type 
already absolute 	mask unix-socket.c 
path relative 	orig len path 
cwd 	orig dir 
relative path 	ctx path ctx 
point current 	size slash 
path always 	dir cwd path 
ending trimmed 	saved errno 
relative path 	ctx path saved 
normalize 	errno ctx 
obvious trailing 	socket die 
elements start 	errno xmemdupz chdir 
path every 	free chdir 
find filename 	die free strlen 
also last 	find last 
element 	dir sep strlen 
cwd unless 	strbuf getcwd 
current cwd 	strbuf detach chdir 
glue two 	len memset 
parts together 	memcpy unix sockaddr 
specified path 	init unix 
file 	stream socket connect 
basename without 	unix sockaddr 
relative absolute 	cleanup unix sockaddr 
path function 	cleanup close 
checks character 	unlink unix sockaddr 
exists inside 	init unix 
specified 	stream socket bind 
path enough 	listen unix 
environments redis 	sockaddr cleanup 
runs may 	unix sockaddr cleanup 
start leading 	close fail 
space trailing 	error since moved 
space 	cwd whole 
may start 	process could confuse 
overflow overflow 	calling code 
may start 	better die unix-socket.h 
may start 	path path 
overflow overflow 	unix socket unpack-file.c 
pattern 	sha path 
pattern len 	buf size argc 
len nocase 	argv prefix 
match start 	sha read sha 
end pattern 	file die 
nocase err 	sha hex xsnprintf 
buf 	xmkstemp write 
mul val 	full die 
digits endptr 	errno close strcmp 
dst dstlen 	usage sha 
svalue digits 	die git config 
negative length 	puts create 
next 	temp file unpack-objects.c 
slen plen 	dry run 
negative slen 	quiet recover errors 
lval llval 	strict unpack 
buf len 	usage buffer offset 
min max 	len consumed 
len 	bytes ctx fsck 
charset seed 	options buffer 
initialized seed 	size obj decorate 
counter digest 	buffer size 
ctx copylen 	obj min ret 
pid filename 	bytes size 
cwd 	stream buf ret 
abspath relpath 	sha offset 
trimlen path 	size delta 
buf buf 	next delta list 
buf argc 	sha offset 
argv stringmatchlen 	delta size info 
tolower 	offset sha 
tolower tolower 	obj obj list 
tolower tolower 	objects obj 
tolower tolower 	obj buf sha 
stringmatchlen strlen 	obj type 
strlen isdigit 	data options obj 
strcasecmp 	buf size 
strcasecmp strcasecmp 	type added write 
strcasecmp strcasecmp 	resolve delta 
strcasecmp strcasecmp 	added unpack non 
memcpy strtoll 	delta entry 
digits digits 	delta data delta 
digits 	size obj 
digits isnan 	obj buffer unpack 
snprintf isinf 	delta entry 
snprintf snprintf 	shift pack 
snprintf snprintf 	size progress hdr 
snprintf fopen 	argc argv 
fread 	prefix sha arg 
fclose sha 	hdr ret 
init sha 	lookup decoration xcalloc 
update sha 	decoration die 
update sha 	oid hex die 
memcpy getpid 	git sha 
gettimeofday 	update memmove xread 
memcpy memcpy 	die die 
memcpy rand 	errno die overflows 
sdsnew sdstrim 	die xmallocz 
getcwd sdsfree 	memset fill git 
sdsnew sdslen 	inflate init 
sdslen 	git inflate use 
sdscat sdslen 	error free 
sdsrange sdslen 	exit fill git 
sdslen sdsrange 	inflate end 
sdscatsds sdsfree 	xmalloc hashcpy 
strchr strchr 	write sha file 
strcpy 	die oid 
strlen strcpy 	hex die sha 
strlen strcpy 	info die 
strlen strcpy 	lookup buffer die 
strlen strcpy 	oid hex 
strlen strcpy 	fsck die fsck 
strlen 	walk die 
strcpy strlen 	oid hex write 
strcpy strlen 	cached check 
strcpy strlen 	lookup lookup buffer 
strcpy strlen 	resolve delta 
strcpy strlen 	fill use fill 
strcpy 	use unpack 
strlen strcpy 	non delta entry 
strlen strcpy 	unpack delta 
strlen strcpy 	entry error 
strlen strcpy 	exit fill ntohl 
strlen strcpy 	ntohl die 
strlen 	pack version die 
strcpy strlen 	ntohl use 
strcpy strlen 	start progress xcalloc 
strcpy strlen 	unpack one 
strcpy strlen 	display progress stop 
strcpy strlen 	progress die 
strcpy 	git config isatty 
strlen strcpy 	strcmp strcmp 
strlen strcmp 	strcmp strcmp skip 
strcmp strcmp 	prefix fsck 
strcmp strcmp 	msg types starts 
strcmp strcmp 	htonl htonl 
unused 	strtoul die htonl 
unused test 	strtoul die 
test test 	usage usage git 
function prototypes 	sha init 
non functions 	unpack git 
malloc message 	sha update git 
setup 	sha write 
use syscall 	rest hashcmp fill 
rather write 	die use 
possible order 	xwrite always read 
avoid possibility 	chunks running 
memory allocation 	strict mode objects 
within 	whose reachability 
libc necessary 	suspect kept core 
free bsd 	without getting 
operating systems 	written store make 
problem though 	sure least 
wrapper around 	min bytes available 
malloc 	buffer pointer 
message avoids 	buffer make sure 
need malloc 	sufficiently large 
message throughout 	wrap called check 
code glibc 	verified end 
provides non 	processing write 
standard 	rest scans objects 
strerror gnu 	reachability requirements 
source defined 	calls function verify 
provide wrapper 	reachability validity 
swallow leading 	recursively write write 
whitespace sign 	list know 
fall 	contents strict buffers 
fall prefix 	structured objects 
note first 	core end know 
non whitespace 	contents pack 
sign character 	resolve deltified objects 
possible tell 	one done 
whether 	cannot resolve yet 
digits consumed 	queue delta 
convert overflow 	delta resolved yet 
conversion performed 	take non 
characters converted 	flag arguments maybe 
fall left 	day write 
padding 	last part 
right padding 	buffer stdout done 
synthetic used 	unpack-trees.c unpack 
flags width 	plumbing errors opts 
width precision 	cmd msgs 
separator precision 	msg cmd clear 
length 	size clear 
conversion specifier 	rejected path something 
caller provide 	displayed rejects 
alternate write 	path state total 
callback function 	progress index 
use one 	errs verify absent 
malloc 	sparse istate 
write function 	skip worktree src 
use malloc 	ret bottom 
message directly 	index index len 
print callback 	pos index 
function way 	len pos 
hopefully 	next index pos 
avoid memory 	index len 
allocation print 	pos next src 
stderr way 	ret traverse 
avoid memory 	info name entry 
allocation copyright 	info bottom 
salvatore 	info ret pos 
sanfilippo antirez 	dirmask conflicts 
gmail dot 	names info ret 
rights reserved 	bottom buf 
redistribution use 	newinfo sha info 
source binary 	len pathlen 
forms 	len name cmp 
without modification 	info len 
permitted provided 	pathlen len name 
following conditions 	cmp info 
met redistributions 	cmp info info 
source code 	stage len 
must 	mask dirmask 
retain copyright 	src names info 
notice list 	conflicts stage 
conditions following 	bit message info 
disclaimer redistributions 	pos index 
binary form 	pfxlen len name 
must 	slash cmp 
reproduce copyright 	len info pos 
notice list 	info mask 
conditions following 	dirmask names info 
disclaimer documentation 	mask dirmask 
materials provided 	names info src 
distribution 	cmp matches 
neither name 	cache prefix mask 
redis names 	clear mask 
contributors may 	defval cache prefix 
used endorse 	basename mask 
promote products 	clear mask defval 
derived 	cache end 
software without 	dtype ret 
specific prior 	cache prefix mask 
written permission 	clear mask 
software provided 	defval cache end 
copyright holders 	name slash 
contributors 	len dtype ret 
express implied 	processed cache 
warranties including 	mask clear mask 
limited implied 	prefix index 
warranties merchantability 	flag skip flag 
fitness particular 	verify absent 
purpose 	len ret dfc 
disclaimed shall 	sparse prefix 
copyright owner 	info empty worktree 
contributors liable 	verify uptodate 
direct indirect 	verify clean submodule 
incidental special 	verify clean 
exemplary 	subdirectory name len 
consequential damages 	src check 
including limited 	verify absent 
procurement substitute 	verify absent verify 
goods services 	absent sparse 
loss use 	old update merge 
data 	old label 
profits business 	stages index head 
interruption however 	remote count 
caused theory 	head match remote 
liability whether 	match conflict 
contract strict 	head conflict remote 
liability 	anc missing 
tort including 	anc exists head 
negligence otherwise 	deleted remote 
arising way 	deleted src current 
use software 	oldtree newtree 
even advised 	src old src 
possibility 	old update 
damage glob 	strcmp xstrfmt xstrfmt 
style pattern 	xstrfmt size 
matching match 	index entry 
match match 	size xmalloc memcpy 
match match 	entry dup 
fall 	entry strbuf addf 
match match 	error errormsg 
convert representing 	strbuf release list 
amount memory 	clear check 
number bytes 	leading path namelen 
instance memtoll 	warn schedule 
parsing 	dir removal namelen 
error err 	start progress 
otherwise error 	delay git attr 
function regardless 	direction display 
fact err 	progress unlink entry 
unit multiplier 	marked cache 
search 	entries scheduled dirs 
first non 	die display 
digit character 	progress checkout 
copy digits 	entry stop progress 
buffer use 	git attr 
strtoll convert 	direction skip worktree 
digit 	skip worktree 
without unit 	skip worktree skip 
number number 	worktree verify 
digits converted 	uptodate sparse skip 
radix see 	worktree verify 
information like 	absent sparse namelen 
digits 	index name 
values abs 	pos namelen locate 
llong min 	src index 
requires special 	namelen memcmp mark 
handling minus 	used namelen 
convert returns 	index name pos 
number 	die namelen 
characters needed 	memcmp entry mark 
represent number 	used mark 
buffer big 	used stage 
enough store 	entry call unpack 
returned following 	stage mark 
article 	used name find 
apparently provide 	cache pos 
novel approach 	entry len fill 
publicizes already 	descriptor cache 
used technique 	bottom traverse trees 
https www 	restore cache 
facebook 	bottom free compare 
notes facebook 	entry piecewise 
engineering three 	namelen entry len 
optimization tips 	name compare 
modified order 	compare entry piecewise 
handle integers 	strncmp namelen 
since 	entry len name 
original code 	compare compare 
designed integers 	entry namelen traverse 
main loop 	path len 
works bit 	compare entry 
integers simplicity 	namelen traverse path 
convert 	len xcalloc 
number remember 	cache entry size 
negative check 	create mode 
length term 	create flags hashcpy 
handle last 	make traverse 
digits sign 	path create entry 
convert 	call unpack 
returns could 	free entry discard 
parsed non 	index error 
overflowing otherwise 	entry len traverse 
parsed appropriate 	path strncmp 
special 	strchr namelen name 
first digit 	compare memcmp 
abort negative 	find cache pos 
sign first 	debug path 
digit otherwise 	putchar debug path 
overflow overflow 	putchar debug 
bytes 	name entry 
used overflow 	debug unpack callback 
overflow convert 	next cache 
returns could 	entry find cache 
parsed non 	entry compare 
overflowing otherwise 	entry unpack index 
parsed 	entry unpack 
appropriate convert 	failed stage unmerged 
representation returns 	unpack nondirectories 
number bytes 	stage mark used 
required representation 	name mark 
always parsable 	used isdir cache 
strtod 	matches traversal 
see http 	traverse trees recursive 
wikipedia wiki 	excluded list 
zero comparisons 	strbuf addch strncmp 
check safe 	clear flags 
range casted 	strbuf setlen 
assuming 	strncmp strchr strbuf 
bit also 	clear flags 
assuming implementations 	dir strbuf setlen 
around precision 	strbuf addch 
bit assumptions 	clear flags strbuf 
test inside 	setlen dtype 
interval 	excluded list namelen 
casting safe 	strbuf reset 
two castings 	clear flags stage 
make sure 	clear flags 
part zero 	die memset memset 
use integer 	git pathdup 
printing 	excludes file list 
function much 	free memset 
faster generate 	hashcpy mark unused 
redis run 	mark skip 
sha sized 	worktree xcalloc cache 
random number 	entry size 
identifies 	setup traverse 
given execution 	info next cache 
redis talking 	entry traverse 
instance run 	path unpack index 
reconnect run 	entry traverse 
sure either 	trees next cache 
different 	entry unpack 
instance restarted 	index entry mark 
state sha 	unused unpack 
seed dev 	failed mark skip 
urandom counter 	worktree verify 
hash seed 	absent apply sparse 
initialize 	checkout skip 
seed use 	worktree unpack failed 
sha counter 	check updates 
mode hash 	cache cache fully 
seed progressive 	valid cache 
counter goals 	update discard index 
function 	discard index 
need non 	clear exclude 
colliding cryptographic 	list display error 
security needs 	msgs mark 
convert hex 	unused unpack failed 
digits read 	rejected path 
dev 	hashcmp verify uptodate 
urandom reasonable 	verify uptodate 
effort order 	cache invalidate path 
create entropy 	untracked cache 
since function 	invalidate path index 
used generate 	file exists 
run 	match stat dup 
cluster instance 	entry verify 
use time 	absent free invalidate 
pid fill 	path copy 
initial xor 	cache entry verify 
rand output 	uptodate free 
already 	invalidate path invalidate 
seeded time 	path entry 
startup convert 	verify absent 
hex digits 	verify uptodate entry 
given filename 	invalidate path 
absolute path 	entry sha hex 
sds 	stage reject 
fails reason 	merge merged entry 
note filename 	reject merge 
may absolute 	merged entry merged 
path already 	entry deleted 
detected handled 	entry verify absent 
correctly 	merged entry 
function normalize 	verify uptodate keep 
everything obvious 	entry show 
one appearning 	stage entry show 
start filename 	stage entry 
relative path 	keep entry keep 
path 	entry error 
already absolute 	deleted entry 
path relative 	merged entry reject 
cwd relative 	merge keep 
path point 	entry deleted entry 
current path 	merged entry 
always 	reject merge reject 
ending trimmed 	merge merged 
relative path 	entry deleted entry 
normalize obvious 	error error 
trailing elements 	errormsg keep entry 
start path 	merged entry 
every 	error deleted entry 
find filename 	uptodate skip 
also last 	worktree lstat match 
element cwd 	stat entry 
unless current 	merged entry error 
cwd glue 	messages expected 
two 	scripts plumbing commands 
parts together 	read non 
specified path 	scripted porcelain 
file basename 	required use messages 
without relative 	fact encouraged 
absolute path 	reword better suit 
function 	particular situation 
checks character 	better see git 
exists inside 	checkout git 
specified path 	merge replaces setup 
enough environments 	unpack trees 
redis runs 	porcelain example error 
may 	would overwrite 
start leading 	error uptodate file 
space trailing 	error uptodate 
space may 	dir error would 
start overflow 	lose untracked 
overflow may 	overwritten error would 
start 	lose untracked 
may start 	removed error bind 
overflow overflow 	overlap error 
util.c cbopaque 	sparse uptodate 
uppercase slen 	file error would 
sign slen 	lose orphaned 
alt 	overwritten error would 
form slen 	lose orphaned 
alt form 	removed special error 
uppercase slen 	bind overlap 
cbopaque result 	refers pair paths 
result err 	cannot easily 
buf 	display list rejected 
buflen nptr 	paths may 
endptr ret 	buffer error messages 
digit neg 	path path 
pret uppercase 	corresponding type message 
slen digits 	msg indicating 
digits 	display porcelain otherwise 
sign slen 	insert list 
neg alt 	future display display 
form slen 	error msgs 
alt form 	display error 
uppercase slen 	messages stored nice 
str 	way unlink 
size format 	last component schedule 
ret alt 	leading directories 
form left 	removal empty directories 
justify plus 	removed skip 
space plus 	worktree skip worktree 
plus 	perfectly normal 
prec width 	move merge strategies 
len uwidth 	may update 
uprec slen 	outside checkout area 
jemalloc silence 	result skip 
init buf 	worktree shortcuts verify 
jemalloc 	absent verify 
silence init 	uptodate make sure 
buf jemalloc 	modify worktree 
silence init 	already outside checkout 
buf jemalloc 	area also 
silence init 	file removed 
buf 	index worktree file 
val buf 	already outside 
val buf 	worktree area bother 
str size 	update verify 
format ret 	uptodate must called 
write cbopaque 	already also 
format 	stat info may 
buf write 	lost merged 
cbopaque format 	entry calling verify 
format syscall 	uptodate may 
strlen write 	fail call unpack 
strlen malloc 	index entry 
message 	unmerged cache entry 
wrtmessage format 	diff index 
message strerror 	wants single callback 
strncpy strerror 	skip unmerged 
errno errno 	entry name 
errno reached 	compare traverse path 
memcpy 	cache entry 
arg errno 	without actually generate 
malloc strtoumax 	textual representation 
errno arg 	traverse path note 
errno malloc 	compares size 
strtoumax errno 	traverse path caller 
append 	needs check 
arg numeric 	cache entry data 
append padded 	end len 
arg numeric 	pathlen must previously 
append padded 	hit name 
arg numeric 	directory entry precomputed 
append 	traverse path 
padded arg 	quicker avoid precomputed 
numeric append 	quicker use 
padded implemented 	precomputed version even 
arg append 	beginning compared 
padded implemented 	identically compare 
arg 	bigger directory leading 
strlen append 	blob name 
padded arg 	path won inside 
numeric append 	directories nothing 
padded reached 	filled potential index 
append start 	entry src 
malloc 	rest traversal looking 
vsnprintf end 	name matching 
malloc vsnprintf 	entry name directory 
write start 	index anything 
malloc vcprintf 	want match traversal 
end start 	descends directory 
malloc 	cache bottom entry 
vcprintf end 	already unpacked 
function prototypes 	never match check 
non functions 	check skip 
malloc message 	future cache checks 
setup use 	already past 
syscall 	possible entries 
rather write 	traverse path exact 
possible order 	match directory 
avoid possibility 	need delay returning 
memory allocation 	keep looking 
within libc 	name sorts path 
necessary 	could files 
free bsd 	path directory index 
operating systems 	name path 
problem though 	may index keep 
wrapper around 	looking find 
malloc message 	first entry real 
avoids 	name could 
need malloc 	use mask supposed 
message throughout 	look index 
code glibc 	skip unmerged index 
provides non 	entries skip 
standard strerror 	entry entries associated 
gnu 	handle directories 
source defined 	special diff 
provide wrapper 	index cached looking 
swallow leading 	everything name 
whitespace sign 	matches skip entire 
fall fall 	hierarchy diff 
prefix 	index cached codepath 
note first 	special cases 
non whitespace 	conflicts way look 
sign character 	ahead safe 
possible tell 	whole directory matching 
whether digits 	undecided use 
consumed 	matching result parent 
convert overflow 	dir defval 
conversion performed 	todo check patterns 
characters converted 	may conflict 
fall left 	ret iow know 
padding right 	advance incl 
padding 	excl decision 
synthetic used 	entire directory clear 
flags width 	flag without 
width precision 	calling clear flags 
separator precision 	function call 
length conversion 	expensive excluded list 
specifier 	every entry 
caller provide 	traverse index find 
alternate write 	every entry 
callback function 	matches according flags 
use one 	clear mask 
malloc write 	entries number traversed 
function 	entries mask 
use malloc 	non zero entries 
message directly 	whose flags 
print callback 	bits enabled traversed 
function way 	cache pointer 
hopefully avoid 	index entry prefix 
memory 	len offset 
allocation print 	path current 
stderr way 	path prefix including 
avoid memory 	trailing cache 
allocation copyright 	name prefix len 
salvatore sanfilippo 	top level 
antirez 	path prefix len 
gmail dot 	zero process 
rights reserved 	entries given prefix 
redistribution use 	meet mask 
source binary 	condition directory whole 
forms without 	directory match 
modification 	first clear dir 
permitted provided 	eats whole 
following conditions 	dir already non 
met redistributions 	directory clear 
source code 	skip worktree according 
must retain 	git dir 
copyright 	info sparse checkout 
notice list 	pretend narrowest 
conditions following 	worktree unmerged 
disclaimer redistributions 	entries widen worktree 
binary form 	according sparse 
must reproduce 	checkout file matched 
copyright 	entries skip 
notice list 	flag cleared way 
conditions following 	merge len 
disclaimer documentation 	trees returns success 
materials provided 	failure manipulate 
distribution neither 	resulting index failure 
name 	reflect changes 
redis names 	work added unpacked 
contributors may 	skip worktree 
used endorse 	used internally sparse 
promote products 	checkout loop 
derived software 	skip worktree existing 
without 	entries unpack 
specific prior 	existing index entries 
written permission 	sort prefix 
software provided 	spliced note 
copyright holders 	merge always left 
contributors express 	entries index 
implied 	sparse checkout loop 
warranties including 	skip worktree 
limited implied 	entries loop skip 
warranties merchantability 	worktree also 
fitness particular 	skip worktree apply 
purpose disclaimed 	sparse checkout 
shall 	won attempt worktree 
copyright owner 	entries marked 
contributors liable 	added merged entry 
direct indirect 	verify absent 
incidental special 	check check effectively 
exemplary consequential 	disabled skip 
damages 	worktree unconditionally real 
including limited 	check correct 
procurement substitute 	skip worktree 
goods services 	sparse checkout meant 
loss use 	narrow checkout 
data profits 	area make sense 
business 	narrow empty 
interruption however 	working usually mistake 
caused theory 	sparse checkout 
liability whether 	rules allow users 
contract strict 	come merge 
liability tort 	functions gets turned 
including 	unmerged entry 
negligence otherwise 	want date valid 
arising way 	skip worktree 
use software 	cheat better check 
even advised 	entry truly 
possibility damage 	date file may 
glob 	overwritten keep 
style pattern 	checking needswork current 
matching match 	policy allow 
match match 	submodule sync 
match match 	wrt superproject index 
fall match 	needs tightened 
match 	later submodules marked 
convert representing 	automatically check 
amount memory 	checking sha subdir 
number bytes 	name going 
instance memtoll 	overwrite working files 
parsing error 	currently git 
err 	checkout subprojects superproject 
otherwise error 	checkout going 
function regardless 	overwrite anything extract 
fact err 	name would 
unit multiplier 	want lose anything 
search first 	existing directory 
non 	going update submodule 
digit character 	care first 
copy digits 	make sure local 
buffer use 	modification directory 
strtoll convert 	name entry 
digit without 	subdirectory removed need 
unit 	make sure 
number number 	lose locally present 
digits converted 	file ignored 
radix see 	gets called index 
information like 	entry entry 
digits values 	dst found file 
abs 	working lstat 
llong min 	said fine insensitive 
requires special 	filesystem see 
handling minus 	find insensitive match 
convert returns 	index also 
number characters 	matches stat information 
needed 	file may 
represent number 	lstat succeeded even 
buffer big 	though target 
enough store 	absent old entry 
returned following 	different ignore 
article apparently 	lstat matches 
provide 	name explicitly excluded 
novel approach 	overwrite checking 
publicizes already 	path foo found 
used technique 	foo working 
https www 	tricky modified files 
facebook notes 	foo would 
facebook 	lose previous round 
engineering three 	may already 
optimization tips 	decided path subdirectory 
modified order 	replaced blob 
handle integers 	want overwrite working 
since original 	file tracked 
code 	unless ignored index 
designed integers 	entries sparse 
main loop 	checkout following verify 
works bit 	absent delayed 
integers simplicity 	traverse trees finishes 
convert number 	unpack trees 
remember 	skip worktree 
negative check 	computed correctly verify 
length term 	absent called 
handle last 	time correct skip 
digits sign 	worktree verify 
convert returns 	absent call nothing 
could 	sparse checkout 
parsed non 	skip sparse checkout 
overflowing otherwise 	see use 
parsed appropriate 	old directly way 
special first 	uptodate stat 
digit abort 	info also removes 
negative 	update flag 
sign first 	match otherwise end 
digit otherwise 	overwriting local 
overflow overflow 	changes work migrate 
bytes used 	old flags 
overflow overflow 	previously unmerged 
convert 	entry left existence 
returns could 	marker read 
parsed non 	index unmerged exist 
overflowing otherwise 	index first 
parsed appropriate 	situation note prevent 
convert 	start cases 
representation returns 	index allowed match 
number bytes 	something head 
required representation 	alt alt permitted 
always parsable 	match result 
strtod see 	instead alt alt 
http 	entry index 
wikipedia wiki 	cache want make 
zero comparisons 	sure matches 
check safe 	head alt alt 
range casted 	aggressive rule 
assuming bit 	resolve mostly trivial 
also 	cases historically 
assuming implementations 	git merge 
around precision 	one file resolve 
bit assumptions 	deleted deleted 
test inside 	one unchanged added 
interval casting 	identically merge 
safe 	cases require index 
two castings 	date avoid 
make sure 	files getting overwritten 
part zero 	conflict resolution 
use integer 	files two way 
printing function 	merge rule 
much 	carry forward index 
faster generate 	without losing 
redis run 	information across fast 
sha sized 	forward favoring 
random number 	successful merge merge 
identifies given 	failure makes 
execution 	sense details carry 
redis talking 	forward rule 
instance run 	please see 
reconnect run 	documentation git read 
sure either 	txt deletion 
different instance 	path staged bind 
restarted 	merge keep 
state sha 	index entries stage 
seed dev 	collapse stage 
urandom counter 	make sure stage 
hash seed 	anything one 
initialize seed 	way merge rule 
use 	take stat 
sha counter 	information stage take 
mode hash 	data stage 
seed progressive 	unpack-trees.h opts cmd 
counter goals 	reset merge 
function need 	update index nontrivial 
non 	merge trivial 
colliding cryptographic 	merges verbose update 
security needs 	aggressive skip 
convert hex 	unmerged initial 
digits read 	checkout diff index 
dev urandom 	cached debug 
reasonable 	unpack skip sparse 
effort order 	checkout gently 
create entropy 	exiting early show 
since function 	errors dry 
used generate 	run prefix cache 
run cluster 	bottom dir 
instance 	pathspec msgs unpack 
use time 	rejects head 
pid fill 	idx merge size 
initial xor 	conflict entry 
rand output 	unpack data dst 
already seeded 	index src 
time 	index result options 
startup convert 	stages src 
hex digits 	src src 
given filename 	sets list user 
absolute path 	friendly error 
sds fails 	messages used command 
reason 	cmd either 
note filename 	merge checkout show 
may absolute 	errors store 
path already 	error messages corresponding 
detected handled 	error message 
correctly function 	type use unsetenv.c 
normalize 	name environ 
everything obvious 	src dst nmln 
one appearning 	enln strlen 
start filename 	strlen strncmp might 
relative path 	match test 
path already 	safely matches skip 
absolute 	update-index.c allow 
path relative 	allow allow replace 
cwd relative 	info force 
path point 	verbose mark 
current path 	valid mark skip 
always ending 	worktree mtime 
trimmed 	dir fmt path 
relative path 	path path 
normalize obvious 	path path ret 
trailing elements 	path flag 
start path 	mark namelen pos 
every find 	path path 
filename 	err old path 
also last 	len option 
element cwd 	size path len 
unless current 	sha pos 
cwd glue 	path pos len 
two parts 	mode sha 
together 	path stage size 
specified path 	len option 
file basename 	flip path pos 
without relative 	mode path 
absolute path 	nul term 
function checks 	line buf getline 
character 	ptr tab 
exists inside 	path name sha 
specified path 	mode stage 
enough environments 	update index usage 
redis runs 	head sha 
may start 	merge head sha 
leading 	ent path 
space trailing 	namelen stage mode 
space may 	sha size 
start overflow 	path namelen pos 
overflow may 	ret prefix 
start may 	prefix length err 
start 	arg prefix 
overflow overflow 	prefix length pos 
pow err 	head pathspec 
input expected 	old save path 
remainder expected 	flags errors 
errno expected 	flag opt 
errno 	arg unset opt 
name expected 	arg unset 
tests test 	opt arg unset 
err result 	flip opt 
remainder buf 	arg unset arg 
result len 	mode sha 
buf 	path endp ctx 
result pow 	opt unset 
ceil pow 	sha mode path 
ceil pow 	ctx opt 
ceil pow 	unset nul term 
ceil pow 	line ctx 
ceil 	opt unset read 
errno malloc 	stdin ctx 
strtoumax errno 	opt flags errors 
errno malloc 	prefix ctx 
strtoumax errno 	opt flags 
str test 	errors prefix argc 
test 	argv prefix 
test test 	newfd entries nul 
test test 	term line 
test test 	read stdin prefix 
test test 	length preferred 
test test 	index format executable 
test 	bit refresh 
test test 	args error split 
test test 	index file 
test test 	ctx getline parseopt 
test test 	state options 
test test 	path buf unquoted 
test 	start vprintf 
test test 	putchar end dir 
test test 	recursively strbuf 
test test 	reset strbuf addf 
test test 	mtime path 
test test 	mkdir die 
test 	errno stat die 
test test 	errno mtime 
test test 	path open die 
test test 	errno mtime 
test test 	path unlink die 
test test 	errno mtime 
test 	path rmdir die 
test test 	errno sleep 
test test 	strbuf addstr mkdtemp 
test test 	die errno 
test test 	xgetcwd atexit xstat 
test test 	mtime dir 
test 	fill stat data 
test test 	fputc avoid 
test test 	racy create file 
test test 	xstat mtime 
test test 	dir match stat 
test test 	data close 
test 	fputc fill 
test test 	stat data fputc 
test test 	avoid racy 
test test 	xmkdir xstat mtime 
test test 	dir match 
test test 	stat data close 
test 	fputc fill 
test test 	stat data fputc 
test test 	avoid racy 
test test 	write die close 
test test 	xstat mtime 
test test 	dir match stat 
test 	data fputc 
test test 	fputc avoid racy 
test test 	close create 
test function 	file xstat mtime 
prototypes non 	dir match 
functions malloc 	stat data fputc 
message 	fputc avoid 
setup use 	racy xunlink 
syscall rather 	xstat mtime dir 
write possible 	match stat 
order avoid 	data fputc fill 
possibility memory 	stat data 
allocation 	fputc avoid racy 
within libc 	xunlink xrmdir 
necessary free 	xstat mtime dir 
bsd operating 	match stat 
systems problem 	data fputc rmdir 
though wrapper 	die errno 
around 	strbuf release strlen 
malloc message 	cache name 
avoids need 	pos cache invalidate 
malloc message 	path error 
throughout code 	file cache error 
glibc provides 	one path 
non 	error strerror stage 
standard strerror 	match stat 
gnu source 	cache entry 
defined provide 	size xcalloc memcpy 
wrapper swallow 	create flags 
leading whitespace 	fill stat cache 
sign 	info mode 
fall fall 	stat index path 
prefix note 	free cache 
first non 	entry error cache 
whitespace sign 	name pos 
character possible 	isgitlink resolve gitlink 
tell 	one path 
whether digits 	one path strncmp 
consumed convert 	error resolve 
overflow conversion 	gitlink one path 
performed characters 	error strlen 
converted fall 	symlink leading path 
left 	error cache 
padding right 	name pos 
padding synthetic 	skip worktree file 
used flags 	cache error 
width width 	lstat process lstat 
precision separator 	error isdir 
precision 	process directory one 
length conversion 	path verify 
specifier caller 	path error strlen 
provide alternate 	cache entry 
write callback 	size xcalloc hashcpy 
function use 	memcpy create 
one 	flags create mode 
malloc write 	cache entry 
function use 	error report cache 
malloc message 	name pos 
directly print 	strlen isreg cache 
callback function 	invalidate path 
way 	report die verify 
hopefully avoid 	path mark 
memory allocation 	flags die 
print stderr 	mark flags die 
way avoid 	file cache 
memory allocation 	die report process 
copyright 	path die 
salvatore sanfilippo 	report getline strtoul 
antirez gmail 	strchr sha 
dot rights 	hex strbuf reset 
reserved redistribution 	unquote style 
use source 	die verify path 
binary 	file cache 
forms without 	die cacheinfo die 
modification permitted 	die strbuf 
provided following 	release strbuf release 
conditions met 	entry error 
redistributions source 	error cache entry 
code 	size xcalloc 
must retain 	hashcpy memcpy create 
copyright notice 	flags create 
list conditions 	mode strlen 
following disclaimer 	cache name pos 
redistributions binary 	unmerge cache 
form 	entry stage namelen 
must reproduce 	memcmp namelen 
copyright notice 	memcmp read one 
list conditions 	ent read 
following disclaimer 	one ent hashcmp 
documentation materials 	file cache 
provided 	cache entry error 
distribution neither 	cache entry 
name redis 	error free free 
names contributors 	read die 
may used 	read exit read 
endorse promote 	head pointers 
products 	prefix path unresolve 
derived software 	one free 
without specific 	parse pathspec read 
prior written 	stage path 
permission software 	match read 
provided copyright 	one ent namelen 
holders 	hashcmp free 
contributors express 	xstrdup update one 
implied warranties 	free free 
including limited 	free pathspec setup 
implied warranties 	work read 
merchantability fitness 	cache preload refresh 
particular 	cache refresh 
purpose disclaimed 	refresh error resolve 
shall copyright 	undo clear 
owner contributors 	strtoul sha hex 
liable direct 	parse style 
indirect incidental 	cacheinfo cacheinfo die 
special 	error strtoul 
exemplary consequential 	sha hex cacheinfo 
damages including 	die error 
limited procurement 	read index 
substitute goods 	info error unresolve 
services loss 	strlen setup 
use 	work reupdate strlen 
data profits 	strlen strcmp 
business interruption 	usage options git 
however caused 	config xcalloc 
theory liability 	hold locked index 
whether contract 	read cache 
strict 	die parse options 
liability tort 	start parse 
including negligence 	options step exit 
otherwise arising 	setup work 
way use 	prefix path update 
software even 	one chmod 
advised 	path free error 
possibility damage 	error usage 
glob style 	options parse options 
pattern matching 	end die 
match match 	setup work 
match match 	getline strbuf reset 
match 	unquote style 
fall match 	die strbuf swap 
match convert 	prefix path 
representing amount 	update one chmod 
memory number 	path free 
bytes instance 	strbuf release strbuf 
memtoll 	release init 
parsing error 	split index git 
err otherwise 	config untracked 
error function 	cache warning untracked 
regardless fact 	cache report 
err unit 	setup work test 
multiplier 	untracked cache 
search first 	supported git config 
non digit 	untracked cache 
character copy 	warning untracked cache 
digits buffer 	report git 
use strtoll 	work die 
convert 	exit unable die 
digit without 	index file 
unit number 	write locked index 
number digits 	die rollback 
converted radix 	file git information 
see information 	manager hell 
like 	copyright linus torvalds 
digits values 	allowing changes 
abs llong 	list files tool 
min requires 	doesn actually 
special handling 	care makes harder 
minus convert 	files revision 
returns 	control mistake something 
number characters 	like git 
needed represent 	update index suddenly 
number buffer 	files revision 
big enough 	controlled untracked cache 
store returned 	mode use 
following 	could usleep 
article apparently 	use nsec defined 
provide novel 	field nsec 
approach publicizes 	could could choose 
already used 	ignore handle 
technique https 	path couldn lstat 
www 	either missing 
facebook notes 	file enoent enotdir 
facebook engineering 	supposed removing 
three optimization 	removal actually succeeds 
tips modified 	permission error 
order handle 	never old index 
integers 	entry already 
since original 	date handle path 
code designed 	directory four 
integers main 	cases already gitlink 
loop works 	index keep 
bit integers 	way update 
simplicity 	cannot find head 
convert number 	going keep 
remember negative 	unchanged index file 
check length 	index removed 
term handle 	file removal allowed 
last digits 	since doesn 
sign 	exist removal isn 
convert returns 	allowed error 
could parsed 	note old arguably 
non overflowing 	fairly strange 
otherwise parsed 	behaviour might want 
appropriate special 	make error 
first 	unconditionally use force 
digit abort 	actually want 
negative sign 	force removal used 
first digit 	exist subdirectory 
otherwise overflow 	multiple files particular 
overflow bytes 	prefix index 
used 	wrong update 
overflow overflow 	directory doesn exist 
convert returns 	index valid 
could parsed 	git directory added 
non overflowing 	gitlink exact 
otherwise parsed 	match file existing 
appropriate 	gitlink nothing 
convert representation 	index head unconditional 
returns number 	error inexact 
bytes required 	match perhaps subdirectory 
representation always 	match subdirectory 
parsable strtod 	match error match 
see 	gitlink error 
http wikipedia 	working directory version 
wiki zero 	assumed good 
comparisons check 	updating make sense 
safe range 	hand removing 
casted assuming 	index work first 
bit 	things first 
also assuming 	stat information 
implementations around 	decide pathname reads 
precision bit 	lines formatted 
assumptions test 	one three formats 
inside interval 	mode sha 
casting 	tab path first 
safe two 	format git 
castings make 	apply index info 
sure part 	reports used 
zero use 	reconstruct used phony 
integer 	merge falling 
printing function 	back way merge 
much faster 	mode type 
generate redis 	sha tab path 
run sha 	second format 
sized random 	stuff git output 
number 	index file 
identifies given 	mode sha stage 
execution redis 	tab path 
talking instance 	format put 
run reconnect 	higher order stages 
run sure 	index file 
either 	matches git files 
different instance 	stage output 
restarted state 	point head path 
sha seed 	point tail 
dev urandom 	sha point head 
counter hash 	path mode 
seed 	means path mode 
initialize seed 	sha name 
use sha 	ptr points tab 
counter mode 	ptr beginning 
hash seed 	sha see entry 
progressive counter 	index already 
goals 	merged resolve undo 
function need 	information fall 
non colliding 	back isn either 
cryptographic security 	unmerged resolved 
needs convert 	removed mistake 
hex digits 	want anything former 
read 	grab blobs 
dev urandom 	given path head 
reasonable effort 	merge head 
order create 	stuff head version 
entropy since 	stage stuff 
function used 	merge head version 
generate 	stage read 
run cluster 	head merge head 
instance use 	merge head 
time pid 	exist merge exit 
fill initial 	success status 
xor rand 	read head run 
output 	update index 
already seeded 	paths merged already 
time startup 	different index 
convert hex 	head head 
digits given 	means initial commit 
filename absolute 	update everything 
path 	index unchanged careful 
sds fails 	working may 
reason note 	path anymore allow 
filename may 	worse yet 
absolute path 	allow replace active 
already detected 	may decrease 
handled 	style cacheinfo consume 
correctly function 	remaining arguments 
normalize everything 	consume remaining arguments 
obvious one 	disallow cacheinfo 
appearning start 	mode form free 
filename relative 	memory becomes 
path 	part linked list 
path already 	parsed atexit 
absolute path 	custom copy parse 
relative cwd 	options want 
relative path 	handle filename 
point current 	arguments come discard 
path 	split index 
always ending 	index destroy split 
trimmed relative 	index cache 
path normalize 	may shared index 
obvious trailing 	cache yeah 
elements start 	leaking bit update-ref.c 
path 	git update 
every find 	usage line termination 
filename also 	update flags 
last element 	create reflog flag 
cwd unless 	msg next 
current cwd 	arg orig input 
glue 	next input 
two parts 	next sha command 
together specified 	refname flags 
path file 	arg ret transaction 
basename without 	input next 
relative absolute 	err refname 
path 	sha old sha 
function checks 	old transaction 
character exists 	input next err 
inside specified 	refname sha 
path enough 	transaction input next 
environments redis 	err refname 
runs 	old sha old 
may start 	transaction input 
leading space 	next err refname 
trailing space 	old sha 
may start 	input next transaction 
overflow overflow 	input next 
may 	argc argv prefix 
start may 	refname oldval 
start overflow 	sha oldsha end 
overflow pattern 	flags create 
pattern len 	reflog options err 
len nocase 	transaction unquote 
match 	style die 
start end 	isspace die isspace 
pattern nocase 	strbuf addch 
err buf 	parse arg strbuf 
mul val 	addstr strbuf 
digits endptr 	release check refname 
dst 	format die 
dstlen svalue 	strbuf detach die 
digits negative 	parse arg 
length next 	sha hashclr die 
slen plen 	strbuf addstr 
negative slen 	sha warning hashclr 
lval 	strbuf release 
llval buf 	die die parse 
len min 	refname die 
max len 	parse next sha 
charset seed 	die parse 
initialized seed 	next sha 
counter 	die transaction update 
digest ctx 	die free 
copylen pid 	strbuf release parse 
filename cwd 	refname die 
abspath relpath 	parse next sha 
trimlen path 	die sha 
buf 	die die transaction 
buf buf 	create die 
argc argv 	free strbuf release 
stringmatchlen tolower 	parse refname 
tolower tolower 	die parse next 
tolower tolower 	sha sha 
tolower 	die die transaction 
tolower stringmatchlen 	die free 
strlen strlen 	strbuf release parse 
isdigit strcasecmp 	refname die 
strcasecmp strcasecmp 	parse next sha 
strcasecmp strcasecmp 	hashclr die 
strcasecmp 	transaction verify 
strcasecmp memcpy 	die free strbuf 
strtoll digits 	release strncmp 
digits digits 	die strbuf read 
digits isnan 	die errno 
snprintf isinf 	die isspace die 
snprintf 	starts parse 
snprintf snprintf 	cmd update starts 
snprintf snprintf 	parse cmd 
fopen fread 	create starts parse 
fclose sha 	cmd starts 
init sha 	parse cmd verify 
update 	starts parse 
sha update 	cmd option die 
sha memcpy 	strbuf release 
getpid gettimeofday 	git config parse 
memcpy memcpy 	options die 
memcpy rand 	transaction begin die 
sdsnew 	usage options 
sdstrim getcwd 	update refs 
sdsfree sdsnew 	stdin transaction commit 
sdslen sdslen 	die transaction 
sdscat sdslen 	free strbuf release 
sdsrange sdslen 	usage options 
sdslen 	usage options usage 
sdsrange sdscatsds 	options sha 
sdsfree strchr 	die hashclr sha 
strchr strcpy 	die sha 
strlen strcpy 	update parse one 
strlen strcpy 	whitespace nul 
strlen 	terminated possibly quoted 
strcpy strlen 	argument append 
strcpy strlen 	result arg pointer 
strcpy strlen 	terminator die 
strcpy strlen 	error argument quoted 
strcpy strlen 	function used 
strcpy 	parse reference name 
strlen strcpy 	immediately command 
strlen strcpy 	handle quoting 
strlen strcpy 	pointer newly allocated 
strlen strcpy 	containing name 
strlen strcpy 	reference error update 
strlen 	next point 
strcpy strlen 	character terminates argument 
strcpy strlen 	die quoting 
strcpy strlen 	malformed reference name 
strcpy strlen 	invalid without 
strcpy strlen 	use next argument 
strcpy 	use everything 
strlen strcpy 	next nul parsed 
strlen strcpy 	oldvalue opposed 
strlen strcpy 	newvalue difference affects 
strlen strcpy 	error messages 
strlen strcmp 	generated backwards compatibility 
strcmp 	accept empty 
strcmp strcmp 	update newvalue 
strcmp strcmp 	binary mode equivalent 
strcmp unused 	specifying zeros 
unused test 	parse argument separator 
test test 	followed next 
function 	argument argument convert 
prototypes non 	sha write 
functions malloc 	sha next point 
message setup 	character terminating 
use syscall 	argument argument even 
rather write 	empty next 
possible 	unchanged provided cannot 
order avoid 	converted sha 
possibility memory 	die flags include 
allocation within 	parse sha 
libc necessary 	old parse sha 
free bsd 	allow empty 
operating 	without consume use 
systems problem 	next argument 
though wrapper 	without empty 
around malloc 	means zeros read 
message avoids 	next nul 
need malloc 	terminated line treat 
message 	empty zeros 
throughout code 	empty non required 
glibc provides 	means unspecified 
non standard 	following five parse 
strerror gnu 	cmd functions 
source defined 	parse corresponding command 
provide 	next points 
wrapper swallow 	character following command 
leading whitespace 	name following 
sign fall 	space pointer character 
fall prefix 	terminating command 
note first 	die explanatory message 
non 	parsing problems 
whitespace sign 	functions handle either 
character possible 	text binary 
tell whether 	format input 
digits consumed 	depending line termination 
convert overflow 	read line 
conversion 	dispatch command empty 
performed characters 	implies reference 
converted fall 	must already exist 
left padding 	purposes backwards 
right padding 	compatibility treat sha 
synthetic used 	care update-server-info.c 
flags 	update server info 
width width 	usage argc 
precision separator 	argv prefix force 
precision length 	options git 
conversion specifier 	config parse options 
caller provide 	usage options 
alternate 	update server info 
write callback 	upload-archive.c upload 
function use 	archive usage deadchild 
one malloc 	argc argv 
write function 	prefix sent 
use malloc 	argv arg cmd 
message 	buf fmt 
directly print 	buf child band 
callback function 	buf argc 
way hopefully 	argv prefix writer 
avoid memory 	err pfd 
allocation print 	usage enter repo 
stderr 	die argv 
way avoid 	push packet read 
memory allocation 	line die 
copyright salvatore 	starts die argv 
sanfilippo antirez 	push strlen 
gmail dot 	write archive start 
rights 	strbuf vaddf 
reserved redistribution 	end send sideband 
use source 	die read 
binary forms 	error clnt strerror 
without modification 	send sideband 
permitted provided 	start command 
following 	packet write die 
conditions met 	strerror packet 
redistributions source 	write packet flush 
code must 	poll error 
retain copyright 	strerror sleep process 
notice list 	input process 
conditions 	input finish command 
following disclaimer 	error clnt 
redistributions binary 	packet flush copyright 
form must 	franck bui 
reproduce copyright 	huu put received 
notice list 	options sent 
conditions 	argv got flush 
following disclaimer 	parse options 
documentation materials 	sent client sideband 
provided distribution 	subprocess parent 
neither name 	monitor read 
redis names 	child sending multiplexed 
contributors 	child dies 
may used 	tell end channel 
endorse promote 	status stream 
products derived 	ready data stream 
software without 	ready upload-pack.c 
specific prior 	upload pack usage 
written 	oldest multi 
permission software 	ack done use 
provided copyright 	thin pack 
holders contributors 	use ofs delta 
express implied 	use include 
warranties including 	tag progress daemon 
limited 	mode allow 
implied warranties 	unadvertised request shallow 
merchantability fitness 	obj want 
particular purpose 	obj extra edge 
disclaimed shall 	obj timeout 
copyright owner 	keepalive use 
contributors 	sideband advertise refs 
liable direct 	stateless rpc 
indirect incidental 	data graft data 
special exemplary 	pack objects 
consequential damages 	data progress abort 
including limited 	msg buffered 
procurement 	argv arg pipe 
substitute goods 	pfd pollsize 
services loss 	ret outsz buf 
use data 	hex sha 
profits business 	knew parents commit 
interruption however 	want work 
caused 	list commit parent 
theory liability 	want sha 
whether contract 	last hex got 
strict liability 	common got 
tort including 	sent ready line 
negligence otherwise 	hex allow 
arising 	hidden argv 
way use 	cmd namebuf shallows 
software even 	depth non 
advised possibility 	tip features sha 
damage glob 	buf line 
style pattern 	sha end backup 
matching 	parents refname 
match match 	refname full oid 
match match 	refname full 
match fall 	oid flag data 
match match 	refname buf 
convert representing 	symref item refname 
amount 	oid flag 
memory number 	data capabilities refname 
bytes instance 	nons peeled 
memtoll parsing 	symref info refname 
error err 	oid flag 
otherwise error 	data symref target 
function 	item unused 
regardless fact 	symref unused 
err unit 	argc argv dir 
multiplier search 	strict arg 
first non 	alarm send sideband 
digit character 	xwrite write 
copy 	die oid hex 
digits buffer 	start command 
use strtoll 	die xfdopen commit 
convert digit 	graft oid 
without unit 	hex oid hex 
number number 	oid hex 
digits 	fflush fclose reset 
converted radix 	timeout poll 
see information 	error strerror sleep 
like digits 	xread send 
values abs 	client data close 
llong min 	xread close 
requires 	send client 
special handling 	data write die 
minus convert 	finish command 
returns number 	error send client 
characters needed 	data packet 
represent number 	flush send client 
buffer 	data die 
big enough 	sha hex die 
store returned 	sha file 
following article 	parse die sha 
apparently provide 	hex commit 
novel approach 	list insert date 
publicizes 	pop commit 
already used 	parse commit list 
technique https 	insert date 
www facebook 	clear commit marks 
notes facebook 	free commit 
engineering three 	list deref tag 
optimization 	reachable packet 
tips modified 	read line 
order handle 	reset timeout give 
integers since 	packet write 
original code 	packet write packet 
designed integers 	write exit 
main 	starts got sha 
loop works 	give sha 
bit integers 	hex packet write 
simplicity convert 	packet write 
number remember 	memcpy sha hex 
negative check 	packet write 
length 	packet write packet 
term handle 	write strcmp 
last digits 	packet write packet 
sign convert 	write die 
returns could 	start command sigchain 
parsed non 	push max 
overflowing 	index indexed memcpy 
otherwise parsed 	oid hex 
appropriate special 	write full 
first digit 	memcpy oid hex 
abort negative 	write full 
sign first 	close sigchain pop 
digit 	read full 
otherwise overflow 	close finish command 
overflow bytes 	die oid 
used overflow 	hex packet read 
overflow convert 	line reset 
returns could 	timeout starts sha 
parsed 	hex die 
non overflowing 	parse die sha 
otherwise parsed 	hex starts 
appropriate convert 	strtol die starts 
representation returns 	sha hex 
number bytes 	die parse feature 
required 	request parse 
representation always 	feature request parse 
parsable strtod 	feature request 
see http 	parse feature 
wikipedia wiki 	request parse feature 
zero comparisons 	request parse 
check 	feature request parse 
safe range 	feature request 
casted assuming 	parse feature request 
bit also 	parse feature 
assuming implementations 	request parse die 
around precision 	sha hex 
bit 	check non tip 
assumptions test 	repository shallow 
inside interval 	shallow commits packet 
casting safe 	write oid 
two castings 	hex shallow free 
make sure 	commit list 
part 	packet write oid 
zero use 	hex unregister 
integer printing 	shallow parse 
function much 	commit die shallow 
faster generate 	packet flush 
redis 	shallow free lookup 
run sha 	unknown hidden 
sized random 	strip mark strbuf 
number identifies 	addf strip 
given execution 	mark format symref 
redis talking 	info packet 
instance 	write oid hex 
run reconnect 	git user 
run sure 	agent sanitized strbuf 
either different 	release packet 
instance restarted 	write oid hex 
state sha 	peel packet 
seed 	write oid hex 
dev urandom 	resolve die 
counter hash 	list append xstrdup 
seed initialize 	head namespaced 
seed use 	reset timeout 
sha counter 	head namespaced namespaced 
mode 	advertise shallow 
hash seed 	grafts packet flush 
progressive counter 	head namespaced 
goals function 	namespaced list clear 
need non 	receive needs 
colliding cryptographic 	common commits create 
security 	pack file 
needs convert 	strcmp git config 
hex digits 	strcmp git 
read dev 	config strcmp git 
urandom reasonable 	config parse 
effort order 	hide refs config 
create 	git setup 
entropy since 	gettext packet trace 
function used 	identity git 
generate run 	extract argv path 
cluster instance 	strcmp strcmp 
use time 	strcmp starts 
pid 	atoi strcmp usage 
fill initial 	setup path 
xor rand 	enter repo die 
output already 	git config 
seeded time 	upload pack remember 
startup convert 	update flag 
hex 	allocation allow specifying 
digits given 	sha tip 
filename absolute 	allow request sha 
path sds 	reachable possibly 
fails reason 	hidden sideband otherwise 
note filename 	maximum packet 
may 	size bytes emergency 
absolute path 	quit xxx 
already detected 	happy lose stuff 
handled correctly 	read pack 
function normalize 	objects err capture 
everything obvious 	stderr output 
one 	progress bar 
appearning start 	pack objects capture 
filename relative 	pack data 
path path 	status ready ship 
already absolute 	side band 
path relative 	dump standard error 
cwd 	give priority 
relative path 	status messages data 
point current 	ready keep 
path always 	last detect broken 
ending trimmed 	rev list 
relative path 	stream corrupted unfortunate 
normalize 	unpack objects 
obvious trailing 	would happily accept 
elements start 	valid packdata 
path every 	trailing garbage appending 
find filename 	garbage pass 
also last 	pack data good 
element 	enough signal 
cwd unless 	breakage downstream 
current cwd 	hit keepalive timeout 
glue two 	without saying 
parts together 	anything send empty 
specified path 	message data 
file 	sideband side know 
basename without 	still working 
relative absolute 	data yet sideband 
path function 	channel room 
checks character 	protocol say anything 
exists inside 	clients luck 
specified 	flush data way 
path enough 	tell reachable 
environments redis 	looking ancestry chain 
runs may 	alone note 
start leading 	worry anymore sha 
space trailing 	normal process 
space 	without uploadpack 
may start 	allow reachable sha 
overflow overflow 	want non 
may start 	tip requests never 
may start 	happen rev 
overflow overflow 	list stdin encounters 
util.c 	unknown commit 
cbopaque uppercase 	terminates cause sigpipe 
slen sign 	write loop 
slen alt 	commits rev list 
form slen 	ancestors rev 
alt form 	list may died 
uppercase 	encountering bad 
slen cbopaque 	commit history want 
result result 	bail even 
err buf 	showed commit non 
buflen nptr 	tip ones 
endptr ret 	ancestors advertised pick 
digit 	one know 
neg pret 	least one 
uppercase slen 	sent refs already 
digits digits 	end chosen 
sign slen 	operating stateless rpc 
neg alt 	mode however 
form 	choice may older 
slen alt 	refs advertised 
form uppercase 	another process handled 
slen str 	initial request 
size format 	make sure real 
ret alt 	parents parsed 
form 	make sure commit 
left justify 	traversal conforms 
plus space 	client non zero 
plus plus 	hidden otherwise 
prec width 	url.c first flag 
len uwidth 	alphanumeric special 
uprec 	url val query 
slen jemalloc 	len stop 
silence init 	decode plus 
buf jemalloc 	val url url 
silence init 	len colon 
buf jemalloc 	query query buf 
silence 	url url 
init buf 	dest buf isalnum 
jemalloc silence 	urlschemechar urlschemechar 
init buf 	strchr url decode 
val buf 	strbuf addch 
val buf 	strbuf addch strbuf 
str 	addch strbuf 
size format 	detach url decode 
ret write 	mem strlen 
cbopaque format 	memchr strbuf url 
buf write 	decode url 
cbopaque format 	decode url decode 
format 	strbuf addstr 
syscall strlen 	strbuf complete end 
write strlen 	url slash 
malloc message 	free strbuf 
wrtmessage format 	detach valid url 
message strerror 	schemes per 
strncpy 	std rfc use 
strerror errno 	sightly looser 
errno errno 	check earlier version 
reached memcpy 	check used 
arg errno 	remote helpers scheme 
malloc strtoumax 	part reasonable 
errno 	seen scheme want 
arg errno 	colon slash 
malloc strtoumax 	slash skip protocol 
errno append 	part present 
arg numeric 	url.h url first 
append padded 	flag url 
arg 	url len query 
numeric append 	query buf 
padded arg 	url url 
numeric append 	dest url urlmatch.c 
padded arg 	buf len 
numeric append 	esc extra esc 
padded 	esc url 
implemented arg 	info url len 
append padded 	norm spanned 
implemented arg 	scheme len passwd 
strlen append 	len path 
padded arg 	path len result 
numeric 	len slash 
append padded 	ptr ptr colon 
reached append 	ptr path 
start malloc 	start result pnum 
vsnprintf end 	seg start 
malloc vsnprintf 	seg start next 
write 	slash skip 
start malloc 	slash prev slash 
vcprintf end 	url url 
start malloc 	prefix url 
vcprintf end 	prefix len url 
function prototypes 	url prefix 
non 	exactusermatch usermatched pathmatchlen 
functions malloc 	item collect 
message setup 	matched url key 
use syscall 	dot synthkey 
rather write 	matched len user 
possible order 	matched retval 
avoid 	config url norm 
possibility memory 	url norm 
allocation within 	info isxdigit isxdigit 
libc necessary 	hexval hexval 
free bsd 	strchr strchr strchr 
operating systems 	strbuf addf 
problem 	strbuf addch strlen 
though wrapper 	strspn isalpha 
around malloc 	strbuf init strbuf 
message avoids 	addch tolower 
need malloc 	strchr strcspn 
message throughout 	append normalized escapes 
code 	strbuf release 
glibc provides 	strchr strbuf addch 
non standard 	strchr strncmp 
strerror gnu 	strbuf release strbuf 
source defined 	release strspn 
provide wrapper 	strbuf release strbuf 
swallow 	addch tolower 
leading whitespace 	strspn strncmp strncmp 
sign fall 	strncmp strncmp 
fall prefix 	strspn strbuf release 
note first 	strtoul strbuf 
non whitespace 	release strbuf addch 
sign 	strbuf strbuf 
character possible 	addch strcspn append 
tell whether 	normalized escapes 
digits consumed 	strbuf release strcmp 
convert overflow 	strbuf setlen 
conversion performed 	strbuf setlen 
characters 	strcmp strbuf release 
converted fall 	strbuf setlen 
left padding 	strbuf setlen strbuf 
right padding 	addch append 
synthetic used 	normalized escapes strbuf 
flags width 	release strbuf 
width 	detach strncmp strlen 
precision separator 	strncmp strncmp 
precision length 	strncmp url match 
conversion specifier 	prefix skip 
caller provide 	prefix cascade strrchr 
alternate write 	xmemdupz url 
callback 	normalize free match 
function use 	urls free 
one malloc 	strcmp list insert 
write function 	xcalloc strbuf 
use malloc 	addstr strbuf 
message directly 	addch strbuf addstr 
print 	collect strbuf 
callback function 	release literals need 
way hopefully 	plus allowed 
avoid memory 	delims append strbuf 
allocation print 	buf characters 
stderr way 	length len unescaping 
avoid 	characters need 
memory allocation 	escaped escaping characters 
copyright salvatore 	characters escape 
sanfilippo antirez 	complement unescaped starts 
gmail dot 	rfc characters 
rights reserved 	esc extra additional 
redistribution 	characters also 
use source 	always escaped esc 
binary forms 	characters left 
without modification 	escaped found way 
permitted provided 	unescaped otherwise 
following conditions 	used delimiters 
met 	escape sequence encountered 
redistributions source 	followed hexadecimal 
code must 	digits sequence invalid 
retain copyright 	returned otherwise 
notice list 	returned success note 
conditions following 	escape sequences 
disclaimer 	normalized uppercase indicated 
redistributions binary 	rfc unless 
form must 	included esc extra 
reproduce copyright 	esc alphanumerics 
notice list 	always unescaped per 
conditions following 	rfc normalize 
disclaimer 	nul terminated url 
documentation materials 	following rules 
provided distribution 	insensitive parts url 
neither name 	converted lower 
redis names 	encoded characters need 
contributors may 	unencoded characters 
used 	encoded must 
endorse promote 	encoded encodings converted 
products derived 	upper hexadecimal 
software without 	leading removed port 
specific prior 	numbers port 
written permission 	scheme given removed 
software 	path part 
provided copyright 	including empty starting 
holders contributors 	one added 
express implied 	dot segments path 
warranties including 	resolved removed 
limited implied 	host literals allowed 
warranties 	normalized validated 
merchantability fitness 	rules information rfc 
particular purpose 	please note 
disclaimed shall 	function requires full 
copyright owner 	url including 
contributors liable 	scheme host part 
direct 	file may 
indirect incidental 	empty host 
special exemplary 	newly allocated must 
consequential damages 	freed url 
including limited 	valid info non 
procurement substitute 	url err 
goods 	fields therein always 
services loss 	non returned 
use data 	stored info url 
profits business 	well info 
interruption however 	err fields info 
caused theory 	also filled 
liability 	returned stored info 
whether contract 	url info 
strict liability 	err brief translated 
tort including 	error message 
negligence otherwise 	fields filled url 
arising way 	validation function 
use 	full url validation 
software even 	performed invalid 
advised possibility 	host names 
damage glob 	passed function undetected 
style pattern 	however problems 
matching match 	make url invalid 
match 	detected including 
match match 	missing host non 
match fall 	file copy 
match match 	lowercased scheme suffix 
convert representing 	escapes allowed 
amount memory 	first character scheme 
number 	must url 
bytes instance 	alpha bad scheme 
memtoll parsing 	missing part 
error err 	copy username password 
otherwise error 	present normalizing 
function regardless 	escapes copy host 
fact 	part excluding 
err unit 	port part 
multiplier search 	escapes allowed missing 
first non 	host invalid 
digit character 	url schemes file 
copy digits 	file may 
buffer 	port number host 
use strtoll 	name invalid 
convert digit 	characters check port 
without unit 	part copy 
number number 	removing leading escapes 
digits converted 	allowed skip 
radix 	leading last one 
see information 	skip port 
like digits 	number skip http 
values abs 	skip https 
llong min 	port number must 
requires special 	digits leading 
handling 	removed since protocols 
minus convert 	deal bit 
returns number 	port number 
characters needed 	must also range 
represent number 	allowed means 
buffer big 	next available every 
enough 	system therefore 
store returned 	cannot used port 
following article 	number invalid 
apparently provide 	characters port number 
novel approach 	range copy 
publicizes already 	path resolving segments 
used 	careful corrupt 
technique https 	url unescaping delimiters 
www facebook 	initial missing 
notes facebook 	normalize escape sequences 
engineering three 	rfc indicates 
optimization tips 	segments unescaped ignore 
modified 	segment careful 
order handle 	initial ignore segment 
integers since 	previous segment 
original code 	careful initial 
designed integers 	path invalid previous 
main loop 	segment next 
works 	done path simply 
bit integers 	copy rest 
simplicity convert 	normalizing escapes careful 
number remember 	corrupt url 
negative check 	unescaping delimiters url 
length term 	prefix matches 
handle 	url url prefix 
last digits 	exact match 
sign convert 	url prefix url 
returns could 	match ends 
parsed non 	path component boundary 
overflowing otherwise 	url url 
parsed 	prefix considered end 
appropriate special 	matching purposes 
first digit 	already url must 
abort negative 	nul terminated 
sign first 	url prefix 
digit otherwise 	len length url 
overflow 	prefix need 
overflow bytes 	nul terminated length 
used overflow 	match characters 
overflow convert 	including even match 
returns could 	passing url 
parsed non 	url prefix always 
overflowing 	cause returned 
otherwise parsed 	without causing faults 
appropriate convert 	url prefix 
representation returns 	matches url scheme 
number bytes 	host port 
required representation 	url prefix url 
always 	path portion 
parsable strtod 	url prefix path 
see http 	portion url 
wikipedia wiki 	prefix matches 
zero comparisons 	boundary url prefix 
check safe 	contains user 
range 	name must also 
casted assuming 	exactly match 
bit also 	user name url 
assuming implementations 	user host 
around precision 	port path match 
bit assumptions 	fashion returned 
test 	length path match 
inside interval 	including example 
casting safe 	http example path 
two castings 	matched http 
make sure 	example path length 
part zero 	match exactusermatch 
use 	exactusermatch url url 
integer printing 	prefix contained 
function much 	user name url 
faster generate 	prefix user 
redis run 	name match 
sha sized 	exactusermatch left untouched 
random 	check scheme 
number identifies 	schemes match check 
given execution 	user name 
redis talking 	url prefix one 
instance run 	url prefix 
reconnect run 	user match check 
sure 	host port 
either different 	host names ports 
instance restarted 	match check 
state sha 	path interested match 
seed dev 	shorter match 
urandom 	length without user 
counter hash 	current candidate 
seed initialize 	user cannot use 
seed use 	otherwise replace 
sha counter 	one urlmatch.h url 
mode hash 	err url 
seed 	len scheme 
progressive counter 	len user user 
goals function 	len passwd 
need non 	passwd len host 
colliding cryptographic 	host len 
security needs 	port len path 
convert 	path len 
hex digits 	url info matched 
read dev 	len user 
urandom reasonable 	matched vars url 
effort order 	section key 
create entropy 	normalized url success 
since 	must freed 
function used 	otherwise url brief 
generate run 	reason failure 
cluster instance 	otherwise rest fields 
use time 	url total 
pid fill 	length url normalized 
initial 	length scheme 
xor rand 	name excluding 
output already 	offset url start 
seeded time 	user name 
startup convert 	none length user 
hex digits 	name user 
given 	user len empty 
filename absolute 	user name 
path sds 	given offset url 
fails reason 	start passwd 
note filename 	none length passwd 
may absolute 	passwd passwd 
path 	len empty passwd 
already detected 	given offset 
handled correctly 	url start host 
function normalize 	name none 
everything obvious 	length host name 
one appearning 	includes portnum 
start 	file urls 
filename relative 	may host len 
path path 	portnum present 
already absolute 	port len length 
path relative 	excluding leading 
cwd relative 	end host name 
path 	always file 
point current 	urls offset url 
path always 	start url 
ending trimmed 	path always point 
relative path 	character url 
normalize obvious 	normalized length path 
trailing 	portion excluding 
elements start 	trailing portion always 
path every 	url match 
find filename 	usage.c error handle 
also last 	tweaked error 
element cwd 	buffering prefix err 
unless 	err err 
current cwd 	err warn 
glue two 	dying die routine 
parts together 	routine routine 
specified path 	err err err 
file basename 	fmt fmt 
without 	err str error 
relative absolute 	err err 
path function 	warn fflush setvbuf 
checks character 	fputs vfprintf 
exists inside 	fputc vreportf exit 
specified path 	vreportf exit 
enough 	vreportf vreportf start 
environments redis 	usage routine 
runs may 	end usagef die 
start leading 	recursing fputs 
space trailing 	exit start die 
space may 	routine end 
start 	die recursing fputs 
overflow overflow 	exit strerror 
may start 	snprintf start 
may start 	die routine end 
overflow overflow 	start error 
pow err 	routine end start 
input 	warn routine 
expected remainder 	end git information 
expected errno 	manager hell 
expected errno 	copyright linus torvalds 
name expected 	dlopen write 
tests test 	variable would segfault 
err 	ugh keep 
result remainder 	things room overwrite 
buf result 	userdiff.c drivers 
len buf 	ndrivers drivers alloc 
result pow 	builtin drivers 
ceil pow 	driver driver len 
ceil 	drv drv 
pow ceil 	cflags drv name 
pow ceil 	type namelen 
pow ceil 	name len 
errno malloc 	path attr check 
strtoumax errno 	driver name 
errno 	strncmp size strncmp 
malloc strtoumax 	git config 
errno str 	strcasecmp git config 
test test 	git config 
test test 	parse config key 
test test 	userdiff find 
test 	namelen alloc grow 
test test 	memset xmemdupz 
test test 	strcmp parse funcname 
test test 	strcmp parse 
test test 	funcname strcmp parse 
test test 	tristate strcmp 
test 	git config strcmp 
test test 	git config 
test test 	strcmp parse strcmp 
test test 	git config 
test test 	strlen userdiff 
test test 	find namelen git 
test 	attr git 
test test 	check attr attr 
test test 	attr attr 
test test 	unset userdiff find 
test test 	name xmalloc 
test test 	strbuf addf notes 
test 	cache init 
test test 	numbers format statements 
test test 	like worry 
test test 	format statements without 
test test 	leading digits 
test test 	since would matched 
test 	variable anyway 
test test 	negate statements look 
test test 	like functions 
test test 	objective methods 
test test 	functions objective protocol 
test test 	definitions prototype 
test 	attributes regex count 
test test 	nested parentheses 
test test 	slurp whatever see 
test test 	taking care 
test test 	accept lines like 
test test 	sub foo 
test 	defined elsewhere attribute 
test test 	could contain 
test test 	semicolon point seems 
test test 	reasonable enough 
test test 	give brace come 
test test 	next line 
test 	comment brace come 
test test 	next line 
test test 	pod taking care 
test test 	interpret jump 
test test 	targets access 
test test 	declarations functions methods 
test 	variables compounds 
function prototypes 	top level keywords 
non functions 	methods constructors 
malloc message 	properties type definitions 
setup use 	userdiff.h pattern 
syscall rather 	cflags name external 
write 	binary funcname 
possible order 	word regex textconv 
avoid possibility 	textconv cache 
memory allocation 	textconv want cache 
within libc 	name path 
necessary free 	driver initialize textconv 
bsd 	related fields 
operating systems 	driver textconv enabled 
problem though 	userdiff utf8.c 
wrapper around 	first last ucs 
malloc message 	table max 
avoids need 	min mid 
malloc 	start remainder remainder 
message throughout 	incr start 
code glibc 	remainder len skip 
provides non 	ansi width 
standard strerror 	orig skip text 
gnu source 	buf text 
defined 	indent indent eol 
provide wrapper 	buf text 
swallow leading 	indent indent width 
whitespace sign 	indent utf 
fall fall 	bol space start 
prefix note 	orig len 
first 	skip start buf 
non whitespace 	data len 
sign character 	indent indent width 
possible tell 	tmp src 
whether digits 	pos width subst 
consumed convert 	dst src 
overflow 	end dst 
conversion performed 	subst len old 
characters converted 	name src 
fall left 	dst stream format 
padding right 	buf arg 
padding synthetic 	columns insz conv 
used 	outsz outsz 
flags width 	outalloc outpos cnt 
width precision 	sofar insz 
separator precision 	encoding encoding outsz 
length conversion 	conv text 
specifier caller 	remainder encoding chrlen 
provide 	path utf 
alternate write 	bom text len 
callback function 	buf position 
use one 	width slen display 
malloc write 	len utf 
function use 	compensation left 
malloc 	isdigit bisearch bisearch 
message directly 	pick one 
print callback 	utf git wcwidth 
function way 	strlen display 
hopefully avoid 	mode esc sequence 
memory allocation 	len utf 
print 	width utf strnwidth 
stderr way 	utf width 
avoid memory 	strchrnul strbuf addchars 
allocation copyright 	strbuf strbuf 
salvatore sanfilippo 	indented text display 
antirez gmail 	mode esc 
dot 	sequence len isspace 
rights reserved 	strbuf addchars 
redistribution use 	strbuf strbuf addch 
source binary 	isalnum strbuf 
forms without 	addch strbuf addch 
modification permitted 	isspace utf 
provided 	width strbuf 
following conditions 	setlen xstrndup strbuf 
met redistributions 	wrapped text 
source code 	free strlen strbuf 
must retain 	grow display 
copyright notice 	mode esc sequence 
list 	len memcpy 
conditions following 	utf width memcpy 
disclaimer redistributions 	memcpy strbuf 
binary form 	setlen strbuf swap 
must reproduce 	strbuf release 
copyright notice 	strcasecmp strcasecmp encoding 
list 	utf encoding 
conditions following 	utf strcasecmp start 
disclaimer documentation 	strbuf vaddf 
materials provided 	end fputs utf 
distribution neither 	strwidth strbuf 
name redis 	release xmalloc iconv 
names 	free xrealloc 
contributors may 	iconv open 
used endorse 	encoding utf encoding 
promote products 	utf iconv 
derived software 	open reencode iconv 
without specific 	iconv close 
prior 	encoding utf pick 
written permission 	one utf 
software provided 	pick one utf 
copyright holders 	next hfs 
contributors express 	next hfs next 
implied warranties 	hfs next 
including 	hfs next hfs 
limited implied 	dir sep 
warranties merchantability 	strlen memcmp strlen 
fitness particular 	strlen strlen 
purpose disclaimed 	utf strnwidth strbuf 
shall copyright 	addstr strbuf 
owner 	addf strbuf addf 
contributors liable 	strbuf addf 
direct indirect 	code originally 
incidental special 	http www cam 
exemplary consequential 	mgk ucs 
damages including 	auxiliary function binary 
limited 	search interval 
procurement substitute 	table following two 
goods services 	functions define 
loss use 	column width iso 
data profits 	character follows 
business interruption 	character column width 
however 	control characters 
caused theory 	del lead non 
liability whether 	spacing enclosing 
contract strict 	combining characters general 
liability tort 	category code 
including negligence 	unicode database column 
otherwise 	width soft 
arising way 	hyphen column 
use software 	width format characters 
even advised 	general category 
possibility damage 	code unicode database 
glob style 	zero width 
pattern 	space column width 
matching match 	hangul jamo 
match match 	medial vowels consonants 
match match 	column width 
fall match 	spacing characters east 
match convert 	asian wide 
representing 	east asian full 
amount memory 	width category 
number bytes 	defined unicode technical 
instance memtoll 	report column 
parsing error 	width remaining characters 
err otherwise 	including printable 
error 	iso wgl characters 
function regardless 	unicode control 
fact err 	characters etc 
unit multiplier 	column width implementation 
search first 	assumes ucs 
non digit 	characters encoded iso 
character 	sorted list 
copy digits 	non overlapping intervals 
buffer use 	non spacing 
strtoll convert 	characters test bit 
digit without 	control characters 
unit number 	binary search table 
number 	non spacing 
digits converted 	characters binary search 
radix see 	table width 
information like 	characters pick one 
digits values 	ucs character 
abs llong 	starting location start 
min 	points updating 
requires special 	start pointer point 
handling minus 	end character 
convert returns 	remainder location 
number characters 	holds number bytes 
needed represent 	remaining allowed 
number 	pick otherwise allowed 
buffer big 	pick nul 
enough store 	would eventually appear 
returned following 	remainder also 
article apparently 	reduced number bytes 
provide novel 	consumed valid 
approach 	utf start pointer 
publicizes already 	undefined caller 
used technique 	assumes nul terminated 
https www 	text choose 
facebook notes 	bother remainder length 
facebook engineering 	stop first 
three 	nul xxxxxxx xxx 
optimization tips 	xxxxxx xxxx 
modified order 	xxxxxx xxxxxx overlong 
handle integers 	surrogate fffe 
since original 	ffff xxx 
code designed 	xxxxx xxxxxx xxxxxx 
integers 	overlong ffff 
main loop 	function returns number 
works bit 	columns occupied 
integers simplicity 	character pointed variable 
convert number 	start pointer 
remember negative 	updated point next 
check 	character remainder 
length term 	points location stores 
handle last 	number remaining 
digits sign 	bytes use pick 
convert returns 	character see 
could parsed 	pick one utf 
non 	returns total 
overflowing otherwise 	number columns required 
parsed appropriate 	terminated assuming 
special first 	utf returns strlen 
digit abort 	instead look 
negative sign 	like valid 
first 	utf wrap text 
digit otherwise 	necessary variable 
overflow overflow 	indent indent first 
bytes used 	line indent 
overflow overflow 	indent lines indent 
convert returns 	negative already 
could 	indent columns consumed 
parsed non 	extra indent 
overflowing otherwise 	necessary first line 
parsed appropriate 	broken utf 
convert representation 	nothing wrapper returns 
returns number 	total number 
bytes 	columns required printed 
required representation 	assuming utf 
always parsable 	keep error given 
strtod see 	buffer encoding 
http wikipedia 	encoded iconv 
wiki zero 	conversion fails returns 
comparisons 	terminating nul 
check safe 	insz remaining number 
range casted 	bytes since 
assuming bit 	started outsz insz 
also assuming 	likely insz 
implementations around 	enough converting rest 
precision 	platforms variously 
bit assumptions 	spelled variants utf 
test inside 	fall back 
interval casting 	trying official spelling 
safe two 	fallback platform 
castings make 	understand user spelling 
sure 	official one 
part zero 	returns first character 
use integer 	length bytes 
printing function 	multi text according 
much faster 	encoding text 
generate redis 	pointer updated 
run 	point next character 
sha sized 	remainder entry 
random number 	remainder much bytes 
identifies given 	consume text 
execution redis 	exit remainder reduced 
talking instance 	returned character 
run 	length otherwise text 
reconnect run 	treated limited 
sure either 	nul valid utf 
different instance 	raw sequence 
restarted state 	todo use iconv 
sha seed 	decode one 
dev 	obtain chrlen treat 
urandom counter 	encodings utf 
hash seed 	one pick next 
initialize seed 	stream ignoring 
use sha 	codepoints hfs would 
counter mode 	note complete 
hash 	means enough 
seed progressive 	make hfs dotgit 
counter goals 	work used 
function need 	otherwise check malformed 
non colliding 	utf technically 
cryptographic security 	gets converted percent 
needs 	sequence returning 
convert hex 	good enough hfs 
digits read 	dotgit realize 
dev urandom 	cannot git code 
reasonable effort 	points ignored 
order create 	completely zero width 
entropy 	non joiner 
since function 	zero width joiner 
used generate 	left right 
run cluster 	mark right left 
instance use 	mark left 
time 	right embedding right 
pid fill 	left embedding 
initial xor 	pop directional 
rand output 	formatting left right 
already seeded 	right left 
time startup 	inhibit symmetric swapping 
convert 	activate symmetric 
hex digits 	swapping inhibit arabic 
given filename 	form shaping 
absolute path 	activate arabic form 
sds fails 	shaping national 
reason note 	digit shapes nominal 
filename 	digit shapes 
may absolute 	zero width space 
path already 	great deal 
detected handled 	folding occurs hfs 
correctly function 	enough anything 
normalize everything 	convert git utf8.h 
obvious 	start remainder 
one appearning 	len skip 
start filename 	ansi text name 
relative path 	utf bom 
path already 	buf text indent 
absolute path 	indent width 
relative 	buf data len 
cwd relative 	indent indent 
path point 	width pos width 
current path 	subst insz 
always ending 	conv outsz insz 
trimmed relative 	encoding encoding 
path 	outsz encoding encoding 
normalize obvious 	text remainder 
trailing elements 	encoding path buf 
start path 	position width 
every find 	reencode len strlen 
filename also 	assuming bit 
last 	returns path would 
element cwd 	match git 
unless current 	hfs folding 
cwd glue 	path nul terminated 
two parts 	match variants 
together specified 	git git git 
path 	makes suitable 
file basename 	fsck verify path 
without relative 	align given 
absolute path 	store strbuf per 
function checks 	position width 
character exists 	given length larger 
inside 	width input 
specified path 	truncated alignment done 
enough environments 	utime.h utime 
redis runs 	file copyright assigned 
may start 	placed domain 
leading space 	file part mingw 
trailing 	runtime mingw 
space may 	runtime code distributed 
start overflow 	hope useful 
overflow may 	without warranty 
start may 	warranties expressed implied 
start overflow 	hereby disclaimed 
overflow 	includes limited warranties 
pattern pattern 	merchantability fitness 
len len 	particular purpose free 
nocase match 	use code 
start end 	without limitation structure 
pattern nocase 	used utime 
err 	function access time 
buf mul 	modification time 
val digits 	note must utimbuf 
endptr dst 	oldnames actime 
dstlen svalue 	modtime actime modtime 
digits negative 	utime file 
length 	copyright assigned placed 
next slen 	domain file 
plen negative 	part mingw runtime 
slen lval 	mingw runtime 
llval buf 	code distributed 
len min 	hope useful without 
max 	warranty warranties 
len charset 	expressed implied hereby 
seed initialized 	disclaimed includes 
seed counter 	limited warranties merchantability 
digest ctx 	fitness particular 
copylen pid 	purpose free use 
filename 	code without 
cwd abspath 	limitation structure used 
relpath trimlen 	utime function 
path buf 	access time modification 
buf buf 	time note 
argc argv 	must utimbuf oldnames 
stringmatchlen 	utime.h utime 
tolower tolower 	file copyright assigned 
tolower tolower 	placed domain 
tolower tolower 	file part 
tolower stringmatchlen 	mingw runtime mingw 
strlen strlen 	runtime code 
isdigit 	distributed hope useful 
strcasecmp strcasecmp 	without warranty 
strcasecmp strcasecmp 	warranties expressed implied 
strcasecmp strcasecmp 	hereby disclaimed 
strcasecmp memcpy 	includes limited warranties 
strtoll digits 	merchantability fitness 
digits 	particular purpose free 
digits digits 	use code 
isnan snprintf 	without limitation structure 
isinf snprintf 	used utime 
snprintf snprintf 	function access time 
snprintf snprintf 	modification time 
fopen 	note must utimbuf 
fread fclose 	oldnames actime 
sha init 	modtime actime modtime 
sha update 	utime file 
sha update 	copyright assigned 
sha memcpy 	placed domain file 
getpid 	part mingw 
gettimeofday memcpy 	runtime mingw runtime 
memcpy memcpy 	code distributed 
rand sdsnew 	hope useful without 
sdstrim getcwd 	warranty warranties 
sdsfree sdsnew 	expressed implied hereby 
sdslen 	disclaimed includes 
sdslen sdscat 	limited warranties merchantability 
sdslen sdsrange 	fitness particular 
sdslen sdslen 	purpose free use 
sdsrange sdscatsds 	code without 
sdsfree strchr 	limitation structure used 
strchr 	utime function 
strcpy strlen 	access time modification 
strcpy strlen 	time note 
strcpy strlen 	must utimbuf oldnames 
strcpy strlen 	var.c usage 
strcpy strlen 	flag pgm 
strcpy 	flag pgm name 
strlen strcpy 	git vars 
strlen strcpy 	ptr val ptr 
strlen strcpy 	val argc 
strlen strcpy 	argv prefix val 
strlen strcpy 	git editor 
strlen 	die git pager 
strcpy strlen 	read strcmp 
strcpy strlen 	read git config 
strcpy strlen 	usage strcmp 
strcpy strlen 	git config list 
strcpy strlen 	vars git 
strcpy 	config read usage 
strlen strcpy 	git information 
strlen strcpy 	manager hell copyright 
strlen strcpy 	eric biederman 
strlen strcpy 	varint.c bufp buf 
strlen strcpy 	val buf 
strlen 	varint pos 
strcpy strlen 	msb memcpy overflow 
strcpy strlen 	varint.h varint 
strcmp strcmp 	verify-commit.c verify commit 
strcmp strcmp 	usage sha 
strcmp strcmp 	buf size flags 
strcmp 	signature check 
unused unused 	ret name flags 
test test 	sha buf 
test function 	size ret status 
prototypes non 	argc argv 
functions malloc 	prefix error flags 
message 	verify commit 
setup use 	options memset check 
syscall rather 	commit signature 
write possible 	lookup commit print 
order avoid 	signature buffer 
possibility memory 	signature check clear 
allocation 	sha error 
within libc 	read sha 
necessary free 	file error error 
bsd operating 	run gpg 
systems problem 	verify free git 
though wrapper 	gpg config 
around 	git config git 
malloc message 	config parse 
avoids need 	options usage options 
malloc message 	signal verify 
throughout code 	commit builtin git 
glibc provides 	commit commit 
non 	copyright michael gruber 
standard strerror 	git drmicha 
gnu source 	warpmail net git 
defined provide 	verify tag 
wrapper swallow 	sometimes program terminated 
leading whitespace 	signal received 
sign 	process writing 
fall fall 	gpg input verify-pack.c 
prefix note 	path flags 
first non 	index pack argv 
whitespace sign 	arg verbose 
character possible 	stat err verify 
tell 	pack usage 
whether digits 	argc argv prefix 
consumed convert 	err flags 
overflow conversion 	verify pack options 
performed characters 	strbuf addstr 
converted fall 	strbuf strip suffix 
left 	ends strbuf 
padding right 	addstr run command 
padding synthetic 	strbuf release 
used flags 	git config parse 
width width 	options usage 
precision separator 	options verify one 
precision 	pack addition 
length conversion 	foo pack 
specifier caller 	accept foo idx 
provide alternate 	foo normalize 
write callback 	forms foo pack 
function use 	index pack 
one 	verify verify-tag.c verify 
malloc write 	tag usage 
function use 	buf size flags 
malloc message 	sigc len 
directly print 	ret name flags 
callback function 	sha buf 
way 	size ret status 
hopefully avoid 	argc argv 
memory allocation 	prefix error flags 
print stderr 	verify tag 
way avoid 	options memset parse 
memory allocation 	signature write 
copyright 	full error check 
salvatore sanfilippo 	signature print 
antirez gmail 	signature buffer 
dot rights 	signature check clear 
reserved redistribution 	sha error 
use source 	sha info error 
binary 	read sha 
forms without 	file error run 
modification permitted 	gpg verify 
provided following 	free git gpg 
conditions met 	config git 
redistributions source 	config git config 
code 	parse options 
must retain 	usage options signal 
copyright notice 	verify tag 
list conditions 	builtin git verify 
following disclaimer 	tag copyright 
redistributions binary 	carlos rica jasampler 
form 	gmail git 
must reproduce 	verify tag sometimes 
copyright notice 	program terminated 
list conditions 	signal received 
following disclaimer 	process writing gpg 
documentation materials 	input version.c 
provided 	git version agent 
distribution neither 	agent buf 
name redis 	getenv strbuf addstr 
names contributors 	git user 
may used 	agent strbuf trim 
endorse promote 	version.h git 
products 	version version versioncmp.c 
derived software 	prereleases initialized 
without specific 	diff suffix state 
prior written 	diff next 
permission software 	state result type 
provided copyright 	starts starts 
holders 	isdigit isdigit git 
contributors express 	config multi 
implied warranties 	swap prereleases 
including limited 	isdigit isdigit isdigit 
implied warranties 	isdigit versioncmp 
merchantability fitness 	copied strverscmp glibc 
particular 	commit def 
purpose disclaimed 	cfb bef cfdc 
shall copyright 	reformatted git 
owner contributors 	coding style implementation 
liable direct 	lgpl git 
indirect incidental 	relicenses states normal 
special 	comparing integral 
exemplary consequential 	part comparing fractionnal 
damages including 	parts idem 
limited procurement 	leading zeroes result 
substitute goods 	type cmp 
services loss 	diff len compare 
use 	len diff 
data profits 	diff point first 
business interruption 	different character 
however caused 	two either 
theory liability 	starts prerelease suffix 
whether contract 	forced top 
strict 	start different suffix 
liability tort 	order determined 
including negligence 	config file note 
otherwise arising 	deal situation 
way use 	start suffix common 
software even 	part already 
advised 	consumed caller non 
possibility damage 	zero diff 
glob style 	contains versioncmp compare 
pattern matching 	holding indices 
match match 	version numbers returning 
match match 	less equal 
match 	greater zero less 
fall match 	equal greater 
match convert 	info see texinfo 
representing amount 	doc symbol 
memory number 	others transition 
bytes instance 	state state hint 
memtoll 	digit walker.c 
parsing error 	current commit sha 
err otherwise 	walker fmt 
error function 	hex obj walker 
regardless fact 	obj walker 
err unit 	desc entry obj 
multiplier 	blob complete 
search first 	walker commit parents 
non digit 	walker tag 
character copy 	process queue process 
digits buffer 	queue end 
use strtoll 	walker obj walker 
convert 	obj walker 
digit without 	elem obj walker 
unit number 	target sha 
number digits 	path oid flag 
converted radix 	data commit 
see information 	target write 
like 	targets alloc buf 
digits values 	one one 
abs llong 	targets target write 
min requires 	walker targets 
special handling 	target write write 
minus convert 	log details 
returns 	refname err transaction 
number characters 	sha msg 
needed represent 	ret walker oid 
number buffer 	hex sha 
big enough 	sha hex parse 
store returned 	init desc 
following 	entry isgitlink isdir 
article apparently 	lookup lookup 
provide novel 	blob process free 
approach publicizes 	buffer parse 
already used 	commit pop 
technique https 	recent commit hashcpy 
www 	walker say 
facebook notes 	oid hex process 
facebook engineering 	process parse 
three optimization 	tag process process 
tips modified 	commit process 
order handle 	process tag error 
integers 	oid hex 
since original 	file prefetch list 
code designed 	insert free 
integers main 	fetch report missing 
loop works 	parse process 
bit integers 	sha hex check 
simplicity 	refname format 
convert number 	alloc fetch hashcpy 
remember negative 	free free 
check length 	lookup commit reference 
term handle 	gently commit 
last digits 	list insert 
sign 	strbuf getline strchr 
convert returns 	realloc realloc 
could parsed 	xstrdup xstrdup strbuf 
non overflowing 	release free 
otherwise parsed 	free xmalloc transaction 
appropriate special 	begin error 
first 	commit list sort 
digit abort 	date interpret 
negative sign 	target error process 
first digit 	lookup unknown 
otherwise overflow 	loop xstrfmt strbuf 
overflow bytes 	reset strbuf 
used 	addf transaction update 
overflow overflow 	error transaction 
convert returns 	commit error transaction 
could parsed 	free free 
non overflowing 	free strbuf release 
otherwise parsed 	strbuf release 
appropriate 	cleanup free 
convert representation 	submodule commits stored 
returns number 	superproject remember 
bytes required 	update flag allocation 
representation always 	already scan 
parsable strtod 	scanning placed queue 
see 	needed fetch 
http wikipedia 	first walker.h data 
wiki zero 	walker walker 
comparisons check 	sha walker sha 
safe range 	walker history 
casted assuming 	verbosely recover corrupt 
bit 	found walker 
also assuming 	target write targets 
implementations around 	target write 
precision bit 	impl targets target 
assumptions test 	write write 
inside interval 	log details walker 
casting 	url report 
safe two 	got verbosely 
castings make 	load pull targets 
sure part 	stdin free 
zero use 	loaded targets write 
integer printing 	filename write 
function 	target write log 
much faster 	details additional 
generate redis 	text appear log 
run sha 	walker wildmatch.c 
sized random 	text flags pattern 
number identifies 	matched match 
given 	slash negated prev 
execution redis 	prev slash 
talking instance 	upper pattern text 
run reconnect 	flags isupper 
run sure 	tolower isupper tolower 
either different 	dowild strchr 
instance 	strchr glob special 
restarted state 	isupper tolower 
sha seed 	isupper tolower 
dev urandom 	dowild islower toupper 
counter hash 	isalnum isalpha 
seed initialize 	isblank iscntrl isdigit 
seed 	isgraph islower 
use sha 	isprint ispunct isspace 
counter mode 	isupper islower 
hash seed 	isxdigit dowild shell 
progressive counter 	style pattern 
goals function 	matching characters bit 
need 	clean written 
non colliding 	rich alz mirror 
cryptographic security 	wed nov 
needs convert 	est rich alz 
hex digits 	rsalz bbn 
read dev 	modified wayne davison 
urandom 	special matching 
reasonable effort 	make work 
order create 	differently fix character 
entropy since 	code character 
function used 	marks inverted character 
generate run 	match pattern 
cluster 	text match following 
instance use 	character note 
time pid 	test handles failure 
fill initial 	fallthrough match 
xor rand 	anything without pathname 
output 	assuming already 
already seeded 	match foo star 
time startup 	star slash 
convert hex 	matches nothing ahead 
digits given 	match rest 
filename absolute 	pattern remaining helps 
path 	make foo 
sds fails 	bar otherwise breaks 
reason note 	comment syntax 
filename may 	match foo 
absolute path 	bar foo bar 
already detected 	without pathname 
handled 	trailing matches everything 
correctly function 	trailing matches 
normalize everything 	slash characters one 
obvious one 	asterisk followed 
appearning start 	slash pathname matches 
filename relative 	next directory 
path 	slash consumed top 
path already 	level loop 
absolute path 	advance faster asterisk 
relative cwd 	followed know 
relative path 	must belong match 
point current 	slash look 
path 	past first slash 
always ending 	cannot belong 
trimmed relative 	assign matched comparison 
path normalize 	inverted character 
obvious trailing 	makes prev 
elements start 	shared iterator didn 
path 	find treat 
every find 	like normal malformed 
filename also 	makes prev 
last element 	match pattern text 
cwd unless 	wildmatch.h pattern 
current cwd 	text flags win32.h 
glue 	attr mode 
two parts 	fname fdata file 
together specified 	attributes last 
path file 	error common win 
basename without 	functions min 
relative absolute 	cygwin defined cygwin 
path 	win32mmap.c start 
function checks 	length prot flags 
character exists 	offset hmap 
inside specified 	temp len start 
path enough 	length fstat 
environments redis 	die xsize 
runs 	die create file 
may start 	mapping osfhandle 
leading space 	map view file 
trailing space 	close handle 
may start 	warning unmap view 
overflow overflow 	file winansi.c 
may 	console plain attr 
start may 	attr negative 
start overflow 	non ascii used 
overflow util.h 	hthread hread 
err buf 	hwrite hconsole hconsole 
buflen nptr 	font family 
endptr 	current console font 
str size 	cfi hkey 
format jemalloc 	size msg dummy 
format write 	sbi hcon 
cbopaque format 	initialized str 
jemalloc format 	len wbuf dummy 
jemalloc 	wlen attributes 
format bitmap 	sbi dummy func 
bitmap errnum 	paramlen unused 
bitmap bitmap 	buffer bytes start 
ret ret 	state fmt 
errnum jemalloc 	hnd hresult hproc 
ffsl 	pioinfo ioinfo 
jemalloc ffs 	istty wastty handle 
bit scan 	pioinfo old 
reverse bit 	handle con con 
scan reverse 	name hnd 
builtin clz 	proc address module 
builtin 	handle current 
clzl kzu 	console font reg 
jemalloc ffsl 	open key 
kzu jemalloc 	reg query reg 
ffs last 	close key 
error last 	write console 
error 	wcslen osfhandle file 
size stack 	type console 
allocated buffer 	screen buffer info 
passed buferror 	xutftowcsn size 
size stack 	write console console 
allocated buffer 	text attribute 
used 	console screen buffer 
malloc must 	info fill 
large enough 	console output character 
possible uses 	console attr 
within jemalloc 	erase line read 
wrap cpp 	file last 
argument 	error last error 
contains commas 	write console 
isn broken 	memset attr write 
multiple arguments 	console memmove 
silence compiler 	warn raster font 
warnings due 	close handle 
uninitialized 	flushall flush 
values used 	file buffers disconnect 
wherever compiler 	named pipe 
fails recognize 	wait single close 
variable never 	handle close 
used uninitialized 	handle start err 
define 	win posix 
custom order 	last error die 
reduce chances 	errno end 
deadlock assertion 	current process duplicate 
failure use 	handle die 
particular configuration 	lasterr ioinfo isatty 
cassert 	pioinfo isatty 
config debug 	pioinfo error init 
jemalloc types 	ioinfo pioinfo 
jemalloc structs 	console console xsnprintf 
malloc vsnprintf 	current process 
supports subset 	create named pipe 
snprintf 	die lasterr 
avoids floating 	create file 
point math 	die lasterr create 
jemalloc externs 	die lasterr 
sanity check 	atexit die errno 
compute smallest 	swap osfhnd 
power 	duplicate handle swap 
outputs inputs 	osfhnd duplicate 
error code 	handle osfhandle isatty 
last error 	file type 
code jemalloc 	copyright peter harris 
inlines copyright 	git peter 
salvatore 	geek ansi codes 
sanfilippo antirez 	used git 
gmail dot 	file git specific 
rights reserved 	therefore file 
redistribution use 	attempt implement codes 
source binary 	used git 
forms 	bother output 
without modification 	ascii current console 
permitted provided 	font available 
following conditions 	since vista pre 
met redistributions 	vista check 
source code 	console font registry 
must 	handle file 
retain copyright 	descriptor check device 
notice list 	console printer 
conditions following 	serial port check 
disclaimer redistributions 	handle console 
binary form 	output screen buffer 
must 	initialize attributes 
reproduce copyright 	called console buffer 
notice list 	convert utf 
conditions following 	utf write directly 
disclaimer documentation 	console remember 
materials provided 	non ascii characters 
distribution 	printed could 
neither name 	probably use 
redis names 	bitmask instead series 
contributors may 	ifs needed 
used endorse 	windows vista regression 
promote products 	reset bold 
derived 	faint normal italic 
software without 	unsupported underline 
specific prior 	underline wikipedia says 
written permission 	flag nothing 
software provided 	furthermore mingw doesn 
copyright holders 	define flag 
contributors 	attr common lvb 
express implied 	underscore underline 
warranties including 	attr common lvb 
limited implied 	underscore slow 
warranties merchantability 	blink fast blink 
fitness particular 	blink background 
purpose 	intensity blink negative 
disclaimed shall 	positive conceal 
copyright owner 	reveal unsupported 
contributors liable 	black red green 
direct indirect 	yellow blue 
incidental special 	magenta cyan white 
exemplary 	unknown reset 
consequential damages 	black red green 
including limited 	yellow blue 
procurement substitute 	magenta cyan white 
goods services 	unknown reset 
loss use 	unsupported code unsupported 
data 	code read 
profits business 	next chunk bytes 
interruption however 	pipe exit 
caused theory 	pipe closed disconnected 
liability whether 	ignore errors 
contract strict 	scan bytes handle 
liability 	ansi control 
tort including 	codes print text 
negligence otherwise 	seen far 
arising way 	start parsing 
use software 	escape sequence otherwise 
even advised 	bail parse 
possibility 	parameters next parameter 
damage plen 	bail bounds 
slen nocase 	end escape sequence 
nocase err 	change console 
len slen 	attributes print remaining 
slen buf 	text unless 
len 	parsing escape sequence 
filename path 	check incomplete 
argc argv 	utf sequences fix 
size stack 	end print 
allocated buffer 	remaining complete utf 
passed buferror 	sequences move 
size 	remaining bytes front 
stack allocated 	data consumed 
buffer used 	mark buffer empty 
malloc must 	check console 
large enough 	font supports 
possible uses 	unicode flush streams 
within 	signal console 
jemalloc wrap 	exit wait console 
cpp argument 	copy remaining 
contains commas 	data cleanup handles 
isn broken 	make msvcrt 
multiple arguments 	file descriptor control 
silence 	structure accessible 
compiler warnings 	tweak handles flags 
due uninitialized 	directly need 
values used 	msvcrt treat pipe 
wherever compiler 	handle console 
fails recognize 	ioinfo structure exposed 
variable 	msvcrt dll 
never used 	via pioinfo starts 
uninitialized define 	handle flags 
custom order 	exact size 
reduce chances 	varies msvcrt versions 
deadlock assertion 	different sizes 
failure 	toggling fdev bit 
use particular 	pioinfo osflags 
configuration cassert 	reflected isatty init 
config debug 	twice toggle 
jemalloc types 	fdev flag check 
jemalloc structs 	isatty toggle 
malloc 	back found correct 
vsnprintf supports 	size init 
subset snprintf 	ioinfo size haven 
avoids floating 	done ioinfo 
point math 	pointer change handles 
jemalloc externs 	check either 
sanity 	stdout stderr console 
check compute 	output screen 
smallest power 	buffer create named 
outputs inputs 	pipe communicate 
error code 	console start 
last error 	console spool pipe 
code 	read end 
jemalloc inlines 	schedule cleanup routine 
copyright salvatore 	redirect stdout 
sanfilippo antirez 	stderr pipe returns 
gmail dot 	real console 
rights reserved 	handle stdout stderr 
redistribution 	pipe redirecting 
use source 	console allows spawn 
binary forms 	exec pass 
without modification 	console next process 
permitted provided 	worktree.c worktrees 
following conditions 	path detached head 
met 	worktree worktree 
redistributions source 	path worktree path 
code must 	gitdir head 
retain copyright 	bare detached worktree 
notice list 	path worktree 
conditions following 	path gitdir 
disclaimer 	head detached list 
redistributions binary 	path dir 
form must 	alloc linked symref 
reproduce copyright 	target existing 
notice list 	path worktrees free 
conditions following 	free free 
disclaimer 	free free strbuf 
documentation materials 	readlink starts 
provided distribution 	check refname format 
neither name 	strbuf read 
redis names 	file starts strbuf 
contributors may 	strlen strbuf 
used 	trim check refname 
endorse promote 	format sha 
products derived 	hex resolve strbuf 
software without 	detach strbuf 
specific prior 	addf absolute path 
written permission 	git common 
software 	dir strbuf 
provided copyright 	addbuf strbuf strip 
holders contributors 	suffix strbuf 
express implied 	strip suffix strbuf 
warranties including 	addf git 
limited implied 	common dir parse 
warranties 	xmalloc strbuf 
merchantability fitness 	detach strbuf detach 
particular purpose 	head info 
disclaimed shall 	strbuf release strbuf 
copyright owner 	release strbuf 
contributors liable 	release strbuf release 
direct 	die strbuf 
indirect incidental 	addf absolute path 
special exemplary 	git common 
consequential damages 	dir strbuf addf 
including limited 	strbuf read 
procurement substitute 	file strbuf 
goods 	rtrim strbuf strip 
services loss 	suffix strbuf 
use data 	reset strbuf addstr 
profits business 	absolute path 
interruption however 	strbuf strip suffix 
caused theory 	strbuf reset 
liability 	strbuf addf git 
whether contract 	common dir 
strict liability 	parse xmalloc strbuf 
tort including 	detach strbuf 
negligence otherwise 	detach head info 
arising way 	strbuf release 
use 	strbuf release strbuf 
software even 	release strbuf 
advised possibility 	release xmalloc main 
damage util.h 	worktree strbuf 
err buf 	addf git common 
buflen nptr 	dir opendir 
endptr 	strbuf release 
str size 	readdir strcmp strcmp 
format jemalloc 	linked worktree 
format write 	alloc grow closedir 
cbopaque format 	alloc grow 
jemalloc format 	worktrees strbuf reset 
jemalloc 	strbuf reset 
format bitmap 	strbuf addf parse 
bitmap errnum 	strcmp xstrdup 
bitmap bitmap 	strbuf release strbuf 
ret ret 	release free 
errnum jemalloc 	worktrees read path 
ffsl 	also detached 
jemalloc ffs 	detached detatched detached 
bit scan 	git common 
reverse bit 	dir symref head 
scan reverse 	practically outside 
builtin clz 	git dir linked 
builtin 	worktrees resolve 
clzl kzu 	won work 
jemalloc ffsl 	uses git path 
kzu jemalloc 	parse proper 
ffs last 	otherwise success head 
error last 	symbolic link 
error 	textual symref detached 
size stack 	head sha 
allocated buffer 	head detached given 
passed buferror 	worktree main 
size stack 	worktree invalid gitdir 
allocated buffer 	file repo 
used 	moved manually accessed 
malloc must 	since refname 
large enough 	branch commit branch 
possible uses 	must commit 
within jemalloc 	incomplete repo prune 
wrap cpp 	won unlock 
argument 	preparation keep resolve 
contains commas 	happy need 
isn broken 	valid head 
multiple arguments 	git directory reject 
silence compiler 	directory looks 
warnings due 	like since immediately 
uninitialized 	replaced symbolic 
values used 	update invocation worktree 
wherever compiler 	worktree usage 
fails recognize 	force detach branch 
variable never 	force branch 
used uninitialized 	show verbose expire 
define 	reason path 
custom order 	len link reason 
reduce chances 	path dir 
deadlock assertion 	ret prefix options 
failure use 	junk work 
particular configuration 	junk git dir 
cassert 	junk junk 
config debug 	pid signo 
jemalloc types 	path olen name 
jemalloc structs 	len path 
malloc vsnprintf 	refname opts repo 
supports subset 	name child 
snprintf 	env len ret 
avoids floating 	symref commit 
point math 	prefix opts branch 
jemalloc externs 	force path 
sanity check 	branch options symref 
compute smallest 	path maxlen 
power 	abbrev len cur 
outputs inputs 	path len 
error code 	path adj abbrev 
last error 	maxlen sha 
code jemalloc 	len path len 
inlines copyright 	prefix porcelain 
salvatore 	options worktrees prefix 
sanfilippo antirez 	options directory 
gmail dot 	git path 
rights reserved 	strbuf addf file 
redistribution use 	exists git 
source binary 	path stat git 
forms 	path strbuf 
without modification 	addf open git 
permitted provided 	path strbuf 
following conditions 	addf strerror xmallocz 
met redistributions 	read full 
source code 	close strbuf addf 
must 	free file 
retain copyright 	exists free stat 
notice list 	git path 
conditions following 	strbuf addf free 
disclaimer redistributions 	opendir git 
binary form 	path readdir strcmp 
must 	strcmp strbuf 
reproduce copyright 	reset prune worktree 
notice list 	strbuf reset 
conditions following 	strbuf addstr 
disclaimer documentation 	git path dir 
materials provided 	recursively unlink 
distribution 	error strerror closedir 
neither name 	rmdir git 
redis names 	path strbuf release 
contributors may 	strbuf release 
used endorse 	parse options usage 
promote products 	options prune 
derived 	worktrees getpid strbuf 
software without 	addstr dir 
specific prior 	recursively strbuf reset 
written permission 	strbuf addstr 
software provided 	dir recursively strbuf 
copyright holders 	release junk 
contributors 	sigchain pop strlen 
express implied 	dir sep 
warranties including 	dir sep file 
limited implied 	exists empty 
warranties merchantability 	dir die 
fitness 	strbuf check branch 
particular purpose 	exists die 
disclaimed shall 	lookup commit reference 
copyright owner 	name die 
contributors liable 	worktree basename strbuf 
direct indirect 	addstr git 
incidental 	path safe create 
special exemplary 	leading directories 
consequential damages 	die errno stat 
including limited 	strbuf setlen 
procurement substitute 	strbuf addf strrchr 
goods services 	getpid atexit 
loss 	sigchain push common 
use data 	mkdir die 
profits business 	errno xstrdup strbuf 
interruption however 	addf write 
caused theory 	file strbuf addf 
liability whether 	safe create 
contract 	leading directories 
strict liability 	die errno xstrdup 
tort including 	strbuf reset 
negligence otherwise 	strbuf addf write 
arising way 	file real 
use software 	path write file 
even 	real path 
advised possibility 	git common dir 
damage plen 	strbuf reset 
slen nocase 	strbuf addf write 
nocase err 	file strbuf 
len slen 	reset strbuf addf 
slen 	write file 
buf len 	argv pushf argv 
filename path 	pushf memset 
argc argv 	argv pushl oid 
size stack 	hex argv 
allocated buffer 	pushl run 
passed 	command argv clear 
buferror size 	argv pushl 
stack allocated 	run command free 
buffer used 	free strbuf 
malloc must 	reset strbuf addf 
large enough 	unlink warn 
possible 	argv clear strbuf 
uses within 	release strbuf 
jemalloc wrap 	release strbuf release 
cpp argument 	strbuf release 
contains commas 	memset parse options 
isn broken 	die usage 
multiple 	options prefix filename 
arguments silence 	strlen strbuf 
compiler warnings 	check branch exists 
due uninitialized 	die strbuf 
values used 	release worktree basename 
wherever compiler 	xstrndup memset 
fails 	argv push 
recognize variable 	argv push argv 
never used 	push argv 
uninitialized define 	push run command 
custom order 	worktree sha 
reduce chances 	hex strlen utf 
deadlock 	strwidth strbuf 
assertion failure 	addf strbuf addstr 
use particular 	strbuf addf 
configuration cassert 	find unique abbrev 
config debug 	strbuf addf 
jemalloc types 	shorten unambiguous strbuf 
jemalloc 	addstr strbuf 
structs malloc 	release strlen strlen 
vsnprintf supports 	find unique 
subset snprintf 	abbrev parse options 
avoids floating 	usage options 
point math 	worktrees measure widths 
jemalloc 	show worktree 
externs sanity 	porcelain show 
check compute 	worktree free worktrees 
smallest power 	usage options 
outputs inputs 	strcmp strcmp prune 
error code 	strcmp list 
last 	usage options read 
error code 	path also 
jemalloc inlines 	detached detached detatched 
copyright salvatore 	detached git 
sanfilippo antirez 	common dir symref 
gmail dot 	head practically 
rights 	outside git dir 
reserved redistribution 	linked worktrees 
use source 	resolve won work 
binary forms 	uses git 
without modification 	path parse proper 
permitted provided 	otherwise success 
following 	head symbolic link 
conditions met 	textual symref 
redistributions source 	detached head 
code must 	sha head detached 
retain copyright 	given worktree 
notice list 	main worktree invalid 
conditions 	gitdir file 
following disclaimer 	repo moved manually 
redistributions binary 	accessed since 
form must 	refname branch commit 
reproduce copyright 	branch must 
notice list 	commit incomplete repo 
conditions 	prune won 
following disclaimer 	unlock preparation keep 
documentation materials 	resolve happy 
provided distribution 	need valid head 
neither name 	git directory 
redis names 	reject directory looks 
contributors 	like since 
may used 	immediately replaced 
endorse promote 	symbolic update invocation 
products derived 	worktree worktree.c 
software without 	worktrees path detached 
specific prior 	head worktree 
written 	worktree path worktree 
permission software 	path gitdir 
provided copyright 	head bare detached 
holders contributors 	worktree path 
express implied 	worktree path gitdir 
warranties including 	head detached 
limited 	list path dir 
implied warranties 	alloc linked 
merchantability fitness 	symref target existing 
particular purpose 	path worktrees 
disclaimed shall 	free free free 
copyright owner 	free free 
contributors 	strbuf readlink starts 
liable direct 	check refname 
indirect incidental 	format strbuf 
special exemplary 	read file starts 
consequential damages 	strbuf strlen 
including limited 	strbuf trim check 
procurement 	refname format 
substitute goods 	sha hex resolve 
services loss 	strbuf detach 
use data 	strbuf addf absolute 
profits business 	path git 
interruption however 	common dir strbuf 
caused 	addbuf strbuf 
theory liability 	strip suffix strbuf 
whether contract 	strip suffix 
strict liability 	strbuf addf git 
tort including 	common dir 
negligence otherwise 	parse xmalloc strbuf 
arising 	detach strbuf 
way use 	detach head info 
software even 	strbuf release 
advised possibility 	strbuf release 
damage valgrind.c 	strbuf release strbuf 
ptr usize 	release die 
ptr 	strbuf addf absolute 
usize ptr 	path git 
usize ptr 	common dir strbuf 
usize valgrind 	addf strbuf 
make mem 	read file strbuf 
noaccess valgrind 	rtrim strbuf 
make 	strip suffix strbuf 
mem undefined 	reset strbuf 
valgrind make 	addstr absolute path 
mem defined 	strbuf strip 
valgrind freelike 	suffix strbuf reset 
block valgrind.h 	strbuf addf 
ptr 	git common dir 
usize ptr 	parse xmalloc 
usize ptr 	strbuf detach strbuf 
usize ptr 	detach head 
usize size 	info strbuf 
reported valgrind 	release strbuf release 
must 	strbuf release 
consistent chain 	strbuf release xmalloc 
malloc realloc 	main worktree 
realloc calls 	strbuf addf git 
request size 	common dir 
isn recorded 	opendir strbuf release 
anywhere 	readdir strcmp 
jemalloc critical 	strcmp linked worktree 
callers macros 	alloc grow 
provide usize 	closedir alloc grow 
rather request 	worktrees strbuf 
size result 	reset strbuf reset 
buffer 	strbuf addf 
overflow detection 	parse strcmp xstrdup 
technically weakened 	strbuf release 
standard api 	strbuf release 
though generally 	free worktrees read 
accepted practice 	path also 
consider 	detached detached detatched 
extra bytes 	detached git 
reported malloc 	common dir symref 
usable size 	head practically 
usable space 	outside git dir 
valgrind malloclike 	linked worktrees 
block 	resolve won work 
valgrind resizeinplace 	uses git 
block macro 	path parse proper 
calls must 	otherwise success 
embedded macros 	head symbolic link 
rather functions 	textual symref 
valgrind 	detached head sha 
reports errors 	head detached 
extra stack 	given worktree main 
frames backtraces 	worktree invalid 
jemalloc types 	gitdir file 
jemalloc structs 	repo moved manually 
jemalloc 	accessed since 
externs jemalloc 	refname branch commit 
inlines version.h 	branch must 
windows extrah 	commit incomplete repo 
msvc compat 	prune won 
windows extra 	unlock preparation keep 
xallocx.c 	resolve happy 
tsz tsz 	need valid head 
tsz cmd 	git directory 
ret cmd 	reject directory looks 
ind ret 	like since 
mib miblen 	immediately replaced symbolic 
ind 	update invocation 
ind ind 	worktree worktree usage 
small hugemax 	force detach 
small hugemax 	branch force branch 
small small 	show verbose 
hugemax smallmax 	expire reason 
large 	path len link 
large large 	reason path 
huge hugemax 	dir ret prefix 
largemax huge 	options junk 
huge huge 	work junk git 
hugemax len 	dir junk 
range 	junk pid signo 
offset len 	path olen 
err szmin 	name len path 
szmax nsz 	refname opts 
large largemax 	repo name child 
huge huge 	env len 
mallocx 	ret symref commit 
ptr sallocx 	prefix opts 
xallocx dallocx 	branch force path 
mallocx ptr 	branch options 
sallocx xallocx 	symref path maxlen 
dallocx mallocx 	abbrev len 
ptr 	cur path 
sallocx xallocx 	len path adj 
dallocx mallctl 	abbrev maxlen 
nsizes impl 	sha len path 
nsizes impl 	len prefix 
nsizes impl 	porcelain options worktrees 
mallctlnametomib 	prefix options 
mallctlbymib size 	directory git path 
impl size 	strbuf addf 
impl size 	file exists git 
impl small 	path stat 
size huge 	git path strbuf 
size 	addf open 
nhuge mallocx 	git path strbuf 
ptr xallocx 	addf strerror 
xallocx xallocx 	xmallocz read full 
xallocx dallocx 	close strbuf 
small size 	addf free file 
huge 	exists free 
size nhuge 	stat git 
mallocx ptr 	path strbuf addf 
xallocx xallocx 	free opendir 
xallocx xallocx 	git path readdir 
xallocx xallocx 	strcmp strcmp 
dallocx 	strbuf reset prune 
small size 	worktree strbuf 
small size 	reset strbuf addstr 
huge size 	git path 
nhuge mallocx 	dir recursively unlink 
ptr xallocx 	error strerror 
xallocx 	closedir rmdir git 
xallocx xallocx 	path strbuf 
xallocx dallocx 	release strbuf release 
small size 	parse options 
nsmall large 	usage options prune 
size large 	worktrees getpid 
size 	strbuf addstr 
large size 	dir recursively strbuf 
huge size 	reset strbuf 
huge size 	addstr dir recursively 
nhuge mallocx 	strbuf release 
ptr xallocx 	junk sigchain pop 
xallocx 	strlen dir 
xallocx xallocx 	sep dir sep 
xallocx xallocx 	file exists 
xallocx xallocx 	empty dir die 
xallocx xallocx 	strbuf check 
xallocx xallocx 	branch exists die 
xallocx 	lookup commit 
xallocx xallocx 	reference name die 
xallocx xallocx 	worktree basename 
dallocx large 	strbuf addstr git 
size nlarge 	path safe 
huge size 	create leading directories 
huge 	die errno 
size huge 	stat strbuf 
size huge 	setlen strbuf addf 
size nhuge 	strrchr getpid 
mallocx ptr 	atexit sigchain push 
xallocx xallocx 	common mkdir 
xallocx 	die errno xstrdup 
xallocx xallocx 	strbuf addf 
xallocx xallocx 	write file strbuf 
xallocx xallocx 	addf safe 
xallocx xallocx 	create leading directories 
xallocx xallocx 	die errno 
xallocx 	xstrdup strbuf reset 
xallocx xallocx 	strbuf addf 
xallocx dallocx 	write file real 
malloc malloc 	path write 
malloc print 	file real path 
filled extents 	git common 
mallocx 	dir strbuf reset 
ptr validate 	strbuf addf 
fill memset 	write file 
validate fill 	strbuf reset strbuf 
xallocx validate 	addf write 
fill nallocx 	file argv pushf 
xallocx 	argv pushf 
validate fill 	memset argv pushl 
validate fill 	oid hex 
memset validate 	argv pushl run 
fill dallocx 	command argv 
large size 	clear argv pushl 
large 	run command 
size nlarge 	free free strbuf 
test zero 	reset strbuf 
huge size 	addf unlink warn 
huge size 	argv clear 
test zero 	strbuf release strbuf 
test 	release strbuf 
size classes 	release strbuf release 
test smallest 	memset parse 
supported size 	options die 
test largest 	usage options prefix 
supported size 	filename strlen 
test 	strbuf check branch 
size overflow 	exists die 
size classes 	strbuf release worktree 
test overflows 	basename xstrndup 
resolved clamping 	memset argv push 
extra test 	argv push 
overflow 	argv push argv 
hugemax size 	push run 
underflows size 	command worktree sha 
classes test 	hex strlen 
size extra 	utf strwidth strbuf 
overflow size 	addf strbuf 
classes 	addstr strbuf addf 
test size 	find unique 
decrease zero 	abbrev strbuf 
extra test 	addf shorten unambiguous 
size decrease 	strbuf addstr 
non zero 	strbuf release strlen 
extra 	strlen find 
test size 	unique abbrev parse 
increase zero 	options usage 
extra test 	options worktrees measure 
size increase 	widths show 
non zero 	worktree porcelain show 
extra 	worktree free 
test size 	worktrees usage options 
increase non 	strcmp strcmp 
zero extra 	prune strcmp list 
test size 	usage options 
extra overflow 	read path also 
size 	detached detached 
classes test 	detatched detached git 
size decrease 	common dir 
zero extra 	symref head 
test size 	practically outside git 
decrease non 	dir linked 
zero 	worktrees resolve won 
extra test 	work uses 
size increase 	git path parse 
zero extra 	proper otherwise 
test size 	success head symbolic 
increase non 	link textual 
zero 	symref detached head 
extra test 	sha head 
size increase 	detached given worktree 
non zero 	main worktree 
extra test 	invalid gitdir file 
size extra 	repo moved 
overflow 	manually accessed since 
fill non 	refname branch 
zero non 	commit branch must 
debug builds 	commit incomplete 
likely detect 	repo prune 
errors shrink 	won unlock preparation 
place 	keep resolve 
expect growing 	happy need valid 
place succeed 	head git 
size classes 	directory reject directory 
size classes 	looks like 
zero.c malloc 	since immediately replaced 
conf 	symbolic update 
min max 	invocation worktree worktree.h 
prev mallocx 	path git 
ptr sallocx 	dir head head 
xallocx rallocx 	sha detached 
ptr dallocx 	bare worktree symref 
test 	target functions 
skip test 	acting information worktrees 
zero test 	worktrees primary 
skip test 	worktree always first 
zero test 	returned linked 
skip test 	worktrees pointed 
zero 	next subsequent worktree 
test ziplist.c 	specific ordering 
encoding encoding 	done linked worktrees 
rawlen buf 	caller responsible 
len len 	freeing memory returned 
len prevlensize 	worktree free 
prevlensize 	memory worktree check 
encoding lensize 	per worktree 
len entry 	symref points main 
entrylen encoding 	worktree linked 
encoding encoding 	worktree path exising 
ret bytes 	worktree returns 
len 	existing caller responsible 
rawlen rawlensize 	freeing returned 
offset noffset 	path wrapper.c size 
extra cur 	size gentle 
next num 	limit routine 
totlen deleted 	old str ret 
offset 	size gentle 
nextdiff first 	ret size size 
tail slen 	gentle ret 
reqlen prevlensize 	size size data 
prevlen offset 	len str 
nextdiff 	len ptr size 
encoding tail 	ret nmemb 
ptail first 	size ret path 
second first 	oflag mode 
bytes first 	buf len pfd 
len second 	buf len 
bytes 	buf len offset 
second len 	buf count 
append source 	total loaded buf 
target target 	count total 
bytes source 	written buf count 
bytes zlbytes 	offset total 
zllength 	loaded ret 
first offset 	path mode mode 
second offset 	stream path 
slen index 	ret origtemplate saved 
prevlensize prevlen 	errno nonrelative 
prevlensize prevlen 	path len tmp 
sstr 	path len 
slen sval 	suffix len tmp 
entry slen 	pattern suffix 
offset index 	len mode letters 
num sstr 	num letters 
slen entry 	len count pattern 
sencoding 	mode pattern 
zval sval 	suffix len mode 
vstr vlen 	origtemplate saved 
skip skipcnt 	errno nonrelative file 
vencoding vll 	err file 
prevlensize encoding 	err file file 
lensize 	mode file 
len len 	path err 
index entry 	flag path mode 
buf pos 	flag ret 
num maxsize 	path mode flag 
dnum posstr 	ret dst 
start 	max fmt len 
vstr vlen 	path fatal 
vlong target 	fmt err path 
min max 	fmt status 
len minval 	path fmt status 
maxval len 	millisec git 
argc 	env error die 
argv entry 	strdup free 
elen buf 	routine strlen strdup 
len len 	die memory 
buf buflen 	limit check malloc 
refnode sstr 	malloc free 
slen 	routine malloc malloc 
sval zip 	die error 
str memcpy 	memset xmalloc 
memcpy memrev 	overflows error die 
ifbe memcpy 	xmalloc xmallocz 
memrev ifbe 	xmallocz memcpy xmallocz 
zip 	memchr xmemdupz 
decode prevlensize 	memory limit check 
zip prev 	realloc realloc 
encode length 	free routine realloc 
zip decode 	realloc die 
prevlensize zip 	mult overflows die 
decode 	memory limit 
length memcpy 	check calloc calloc 
memrev ifbe 	free routine 
memrev ifbe 	calloc calloc die 
memcpy memcpy 	start arg 
memrev ifbe 	end open die 
memcpy 	errno die 
memrev ifbe 	errno die errno 
memcpy memrev 	read poll 
ifbe memcpy 	write pread 
memrev ifbe 	xread xwrite xpread 
memcpy memrev 	dup die 
ifbe 	errno fopen die 
memcpy memrev 	errno die 
ifbe zip 	errno die errno 
decode prevlen 	fdopen die 
zip decode 	errno fopen unlink 
length zmalloc 	fopen strlcpy 
ziplist 	mkstemp strlen strlen 
bytes intrev 	absolute path 
ifbe ziplist 	die errno getenv 
tail offset 	snprintf mkstemp 
intrev ifbe 	getenv snprintf mkstemps 
ziplist length 	strlen strncmp 
zrealloc 	gettimeofday size getpid 
ziplist bytes 	open git 
intrev ifbe 	mkstemps mode 
intrev ifbe 	git mkstemps mode 
ziplist bytes 	strlcpy git 
zip entry 	mkstemp mode absolute 
zip 	path die 
prev encode 	errno warning strerror 
length zip 	unlink strbuf 
entry ziplist 	addf strerror warn 
resize intrev 	unremovable unlink 
ifbe ziplist 	warn unremovable rmdir 
tail 	isgitlink rmdir 
offset ziplist 	warn unlink warn 
tail offset 	warning strerror 
intrev ifbe 	access access error 
intrev ifbe 	warn inaccessible 
ziplist tail 	access access error 
offset 	die errno 
memmove zip 	strbuf getcwd die 
prev encode 	errno strbuf 
length zip 	detach start 
prev encode 	vsnprintf end die 
length force 	die open 
large 	die errno strbuf 
zip prev 	vaddf strbuf 
encode length 	complete line write 
zip entry 	full close 
zip raw 	strbuf release die 
entry length 	errno strbuf 
zip 	release close die 
prev len 	errno start 
diff zip 	write file end 
prev encode 	start write 
length ziplist 	file end poll 
tail offset 	various trivial 
intrev 	helper wrappers around 
ifbe intrev 	standard functions 
ifbe ziplist 	xmemdupz allocates len 
tail offset 	bytes memory 
zip entry 	duplicates len 
ziplist tail 	bytes data allocated 
offset 	memory zero 
intrev ifbe 	terminates allocated memory 
intrev ifbe 	returns pointer 
ziplist tail 	allocated memory allocation 
offset memmove 	fails program 
intrev ifbe 	dies limit size 
ziplist 	chunks huge 
bytes ziplist 	chunks cause pain 
tail offset 	bit buggy 
intrev ifbe 	returning einval len 
ziplist resize 	max even 
intrev ifbe 	absence bugs large 
ziplist 	chunks result 
bytes ziplist 	bad latencies decide 
incr length 	kill process 
ziplist cascade 	pick platform defines 
update intrev 	ssize max 
ifbe ziplist 	smaller clip 
bytes 	ssize max call 
zip decode 	read write 
prevlen ziplist 	larger allowed fail 
entry tail 	last resort 
zip raw 	allow port pass 
entry length 	via cflags 
zip 	dmax size definition 
encoding zip 	ssize max 
size zip 	given platform broken 
prev encode 	xopen open 
length zip 	die open fails 
encode length 	arg undefined 
zip 	behavior specified type 
prev len 	compatible argument 
diff ziplist 	type since integers 
resize memmove 	promoted ints 
zip prev 	fetch next 
encode length 	argument cast mode 
ziplist 	avoid undefined 
tail offset 	behavior xread read 
intrev ifbe 	automatically restarts 
intrev ifbe 	read operations recoverable 
ziplist tail 	error eagain 
offset zip 	eintr xread guarantee 
entry 	len bytes 
ziplist tail 	read even data 
offset intrev 	available poll 
ifbe intrev 	failed want infinite 
ifbe ziplist 	loop read 
tail offset 	returns success expected 
ziplist 	failure would 
tail offset 	next call read 
intrev ifbe 	xwrite write 
ziplist cascade 	automatically restarts write 
update zip 	operations recoverable 
prev encode 	error eagain 
length 	eintr xwrite guarantee 
zip encode 	len bytes 
length zip 	written even operation 
str memcpy 	successful xpread 
zip save 	pread automatically restarts 
integer ziplist 	pread operations 
incr 	recoverable error eagain 
length intrev 	eintr xpread 
ifbe ziplist 	guarantee len bytes 
bytes intrev 	read even 
ifbe ziplist 	data available xfopen 
length intrev 	fopen die 
ifbe 	fopen fails git 
ziplist bytes 	mkstemp create 
intrev ifbe 	tmp file honoring 
ziplist length 	tmpdir variable 
intrev ifbe 	git mkstemps create 
ziplist tail 	tmp file 
offset 	suffix honoring 
intrev ifbe 	tmpdir variable adapted 
ziplist tail 	libiberty mkstemp 
offset zrealloc 	replace pattern xxxxxx 
memcpy memmove 	characters randomness 
memcpy ziplist 	tmp max different 
bytes 	filenames fill 
intrev ifbe 	random bits fatal 
ziplist length 	error eperm 
intrev ifbe 	enospc etc doesn 
ziplist tail 	make sense 
offset intrev 	loop random necessary 
ifbe 	next tmp 
ziplist cascade 	max values generated 
update zfree 	adding different 
zfree ziplist 	module find unique 
entry head 	file name 
ziplist entry 	mkstemp mkstemps suffix 
end 	write-tree.c write 
ziplist insert 	usage argc 
ziplist entry 	argv unused prefix 
tail zip 	ret prefix 
decode prevlen 	sha write options 
zip decode 	git config 
prevlen 	parse options write 
ziplist entry 	cache sha 
head zip 	hex die die 
raw entry 	die git 
length zip 	information manager hell 
raw entry 	copyright linus 
length 	torvalds write diec 
ziplist entry 	err desc 
tail ziplist 	skip stdout flush 
entry head 	fmt ret 
zip decode 	msg buf count 
prevlen zip 	buf count 
entry 	msg buf 
zip str 	count msg exit 
zip load 	signal exit 
integer ziplist 	getenv atoi fstat 
insert ziplist 	fileno isreg 
ziplist index 	ferror fflush check 
ziplist 	pipe die 
zip entry 	errno start vfprintf 
zip str 	end check 
memcmp zip 	pipe die errno 
encoding zip 	fsync die 
load integer 	errno write full 
zip 	check pipe 
decode prevlensize 	die errno write 
zip decode 	full check 
length zip 	pipe strerror write 
str memcmp 	full strerror 
zip encoding 	never happen cases 
zip 	use stdio 
load integer 	want flush 
intrev ifbe 	write error handling 
ziplist length 	better interactive 
intrev ifbe 	behaviour buffering excessively 
ziplist length 	course flush 
zip 	happened within write 
raw entry 	already lost 
length ziplist 	error code cannot 
length intrev 	report ignore 
ifbe intrev 	instead hope right 
ifbe ziplist 	error code 
bytes 	flush file handle 
intrev ifbe 	stdout stdout 
ziplist bytes 	file skip flush 
intrev ifbe 	entirely since 
ziplist length 	needed ws.c rule 
intrev ifbe 	name rule 
ziplist 	bits rule len 
tail offset 	negated tabwidth 
ziplist entry 	check attr 
head zip 	whitespace pathname attr 
entry zip 	whitespace rule 
str fwrite 	rule err line 
perror 	len rule 
fwrite perror 	stream reset result 
zip load 	written trailing 
integer ziplist 	whitespace trailing newline 
ziplist push 	trailing carriage 
ziplist push 	line len rule 
ziplist 	stream reset 
push ziplist 	line len rule 
push ziplist 	line len 
sprintf ziplist 	rule dst src 
push strlen 	len rule 
sprintf ziplist 	error count tail 
push 	tail last 
strlen sprintf 	tab indent last 
ziplist push 	space indent 
strlen sprintf 	need fix 
ziplist push 	leading space consecutive 
strlen sprintf 	spaces last 
ziplist 	start last strspn 
push strlen 	strchrnul size 
sprintf ziplist 	strncmp strncmp atoi 
push strlen 	warning die 
gettimeofday ziplist 	git attr setup 
ziplist push 	whitespace attr 
usec 	check git check 
ziplist push 	attr attr 
ziplist range 	tab width size 
intrev ifbe 	attr tab 
ziplist bytes 	width attr unset 
usec zfree 	parse whitespace 
ziplist 	rule strbuf addstr 
index ziplist 	strbuf addstr 
fwrite perror 	strbuf addstr strbuf 
ziplist exit 	addstr strbuf 
rand rand 	addstr strbuf 
rand ziplist 	addstr strbuf addstr 
len 	strbuf addstr 
ziplist entry 	strbuf addstr strbuf 
zero memset 	addstr strbuf 
zip entry 	detach isspace fputs 
ziplist index 	fwrite fputs 
memset zip 	fwrite fwrite fputs 
entry 	fwrite fputs 
ziplist index 	fwrite tab width 
memcmp srand 	fputs fwrite 
atoi create 	fputs fputs fwrite 
list ziplist 	fputs fputs 
repr zfree 	fwrite fputs fputc 
create 	fputc check 
list ziplist 	emit check emit 
repr pop 	isspace isspace 
ziplist repr 	isspace tab 
pop ziplist 	width strbuf addch 
repr pop 	tab width 
ziplist 	strbuf addch strbuf 
repr pop 	addch tab 
ziplist repr 	width strbuf addch 
zfree create 	strbuf addch 
list ziplist 	strbuf strbuf addch 
index ziplist 	strbuf addch 
fwrite 	whitespace rules copyright 
perror zfree 	junio hamano 
create list 	whitespace whitespace reset 
ziplist index 	whitespace returned 
zfree create 	freed caller stream 
list ziplist 	non emits 
index 	line checking logic 
ziplist fwrite 	simpler temporarily 
perror zfree 	ignore trailing newline 
create list 	check trailing 
ziplist index 	whitespace check 
ziplist fwrite 	indentation check indent 
perror 	non tab 
zfree create 	rest line starts 
list ziplist 	written non 
index zfree 	highlighted part ends 
create list 	trailing whitespace 
ziplist index 	emit non highlighted 
ziplist 	middle segment 
fwrite perror 	highlight errors trailing 
ziplist next 	whitespace might 
zfree create 	want treat differently 
list ziplist 	whitespace characters 
index ziplist 	rule eol use 
fwrite 	stupid definition 
perror ziplist 	copy line onto 
next zfree 	end strbuf 
create list 	fixing whitespaces len 
ziplist index 	number bytes 
ziplist fwrite 	copied src 
perror 	starting src typically 
ziplist next 	src len 
zfree create 	unless incomplete last 
list ziplist 	line strip 
index ziplist 	trailing whitespace check 
zfree create 	leading whitespaces 
list 	indent process indent 
ziplist index 	last point 
ziplist fwrite 	one past indent 
perror ziplist 	src last 
prev zfree 	strip funny spaces 
create list 	updating tab 
ziplist 	needed expand tabs 
index ziplist 	spaces wt-status.c 
fwrite perror 	cut line status 
ziplist ziplist 	colors slot 
prev zfree 	bol color fmt 
create list 	trail linebuf 
ziplist 	line eol 
range ziplist 	color fmt color 
repr zfree 	fmt color 
create list 	fmt sha del 
ziplist range 	mod conflict 
ziplist repr 	deleted deleted deleted 
zfree 	dirty submodules 
create list 	stagemask status label 
ziplist range 	minval maxval 
ziplist repr 	len onebuf padding 
zfree create 	label width 
list ziplist 	one len change 
range 	type status 
ziplist repr 	one name two 
zfree create 	name one 
list ziplist 	two twobuf extra 
range ziplist 	padding label 
repr zfree 	width len 
create 	options data path 
list ziplist 	pos mask 
index ziplist 	options data rev 
strncmp ziplist 	rev opt 
fwrite perror 	dir begin ent 
ziplist next 	ent shown 
ziplist 	header shown header 
repr zfree 	dirty submodules 
memset memset 	changes dirty submodules 
ziplist ziplist 	worktree changes 
push strlen 	uncommitted summary cmd 
ziplist push 	stdout summary 
strlen 	summary content len 
ziplist index 	buf output 
ziplist strncmp 	copts path buf 
ziplist index 	pattern explanation 
ziplist strncmp 	buf rev opt 
zfree memset 	dirty submodules 
ziplist 	branch name 
ziplist push 	branch comment line 
strlen verify 	state color 
ziplist verify 	state color filename 
zfree ziplist 	buf split 
sprintf ziplist 	progress head orig 
push 	head rebase 
ziplist index 	amend rebase orig 
ziplist ziplist 	head line 
index ziplist 	split sha abbrev 
zfree create 	fname lines 
list ziplist 	line state color 
index 	lines show 
ziplist compare 	done yet state 
ziplist compare 	color state 
ziplist index 	color state color 
ziplist compare 	state color 
ziplist 	state color path 
compare zfree 	sha branch 
create list 	name abbrev 
create list 	buf nsha osha 
ziplist ziplist 	nsha email 
ziplist merge 	timestamp message data 
ziplist 	end state 
merge ziplist 	commit sha state 
repr ziplist 	detached sha 
len zfree 	state state color 
ziplist merge 	branch color 
ziplist repr 	branch status color 
ziplist 	state branch 
len ziplist 	name onebuf one 
len ziplist 	onebuf one 
index ziplist 	sign onebuf one 
compare ziplist 	branch header 
compare ziplist 	color branch color 
index 	local branch 
ziplist compare 	color remote branch 
ziplist compare 	name num 
ziplist index 	num upstream 
ziplist compare 	gone want color 
ziplist compare 	color nil 
ziplist 	strbuf vaddf strbuf 
index ziplist 	addch strbuf 
compare ziplist 	addch color print 
compare zfree 	strbuf strbuf 
ziplist list 	release strchr strbuf 
create list 	reset strbuf 
free 	addch strbuf addch 
method rand 	strbuf strbuf 
rand rand 	addstr color print 
randstring rand 	strbuf strbuf 
sprintf rand 	release strbuf release 
sprintf rand 	start status 
sprintf 	vprintf end start 
rand ziplist 	status vprintf 
push list 	end start status 
node head 	vprintf end 
sdsnewlen list 	memset memcpy 
node tail 	resolve refdup index 
sdsnewlen 	file color 
list length 	status status status 
ziplist len 	status status 
ziplist index 	status status status 
list index 	color status 
ziplist sprintf 	status status status 
memcpy 	color status 
memcmp list 	status status status 
node zfree 	status status 
list release 	color status status 
stress stress 	status status 
ziplist specially 	color die label 
encoded 	utf strwidth 
dually linked 	color maxwidth strlen 
list designed 	xmallocz memset 
memory efficient 	quote path 
stores integer 	status color status 
values integers 	unmerged status 
encoded 	utf strwidth status 
actual integers 	strbuf release 
instead series 	color maxwidth strlen 
characters allows 	xmallocz memset 
push pop 	strbuf addstr strbuf 
operations either 	addf strbuf 
side 	addf strbuf addf 
list time 	strbuf setlen 
however every 	strbuf addch die 
operation requires 	quote path 
reallocation memory 	quote path status 
used ziplist 	color status 
actual 	diff status die 
complexity related 	utf strwidth 
amount memory 	status status status 
used ziplist 	color strbuf 
ziplist overall 	release status 
layout general 	strbuf release strbuf 
layout 	release list 
ziplist follows 	insert xcalloc isgitlink 
zlbytes zltail 	hashcmp cache 
zllen entry 	name pos strlen 
entry zlend 	strcmp stage 
zlbytes integer 	stage list insert 
hold 	xcalloc xstrdup 
number bytes 	unmerged mask init 
ziplist occupies 	revisions setup 
needs stored 	revisions diff opt 
able resize 	diff opt 
entire structure 	diff opt handle 
without 	ignore submodules 
need traverse 	arg copy pathspec 
first zltail 	run diff 
offset last 	files init revisions 
entry list 	memset setup 
allows pop 	revisions diff 
operation 	opt handle ignore 
far side 	submodules arg 
list without 	handle ignore submodules 
need full 	arg copy 
traversal zllen 	pathspec run diff 
number entries 	index path 
larger 	match list insert 
need traverse 	xcalloc stage 
entire list 	stage getnanotime memset 
know many 	setup standard 
items holds 	excludes fill directory 
zlend single 	cache name 
special 	dir path match 
equal indicates 	list insert 
end list 	free cache name 
ziplist entries 	dir path 
every entry 	match list insert 
ziplist prefixed 	free free 
header 	free clear 
contains two 	directory getnanotime status 
pieces information 	collect changes 
first length 	worktree status collect 
previous entry 	changes initial 
stored able 	status collect changes 
traverse 	index status 
list back 	collect untracked status 
front second 	print unmerged 
encoding optional 	header status print 
length entry 	unmerged data 
stored length 	status print trailer 
previous 	status print 
entry encoded 	cached header status 
following way 	print change 
length smaller 	data status print 
bytes consume 	trailer status 
single takes 	check worktree 
length 	changes status print 
length greater 	dirty header 
equal consume 	status print change 
bytes first 	data status 
indicate larger 	print trailer argv 
following remaining 	pushf argv 
bytes 	push argv push 
take length 	argv push 
previous entry 	argv push argv 
header field 	push argv 
entry depends 	pushf argv push 
contents entry 	capture command 
entry 	strbuf addstr strbuf 
first bits 	addstr strbuf 
header hold 	addstr strbuf addbuf 
type encoding 	strbuf release 
used store 	strbuf detach strbuf 
length followed 	commented lines 
actual 	free fputs 
length entry 	strbuf release status 
integer first 	print header 
bits following 	quote path column 
bits used 	active list 
specify kind 	append status color 
integer 	status color 
stored header 	strbuf release column 
overview different 	active strbuf 
types encodings 	addf color color 
follows pppppp 	memset want 
length less 	color print columns 
equal 	list clear 
bytes bits 	strbuf release status 
pppppp qqqqqqqq 	strbuf addf 
bytes length 	starts strbuf setlen 
less equal 	strstr strbuf 
bytes bits 	setlen strbuf release 
qqqqqqqq 	strbuf commented 
rrrrrrrr ssssssss 	lines strlen 
tttttttt bytes 	fputs strbuf release 
length greater 	color init 
equal bytes 	revisions diff opt 
integer encoded 	memset setup 
bytes 	revisions status cut 
integer encoded 	line status 
bytes integer 	print trailer status 
encoded bytes 	run diff 
integer encoded 	index status check 
bit bytes 	worktree changes 
integer 	status status setup 
encoded bit 	work run 
xxxx xxxx 	diff files skip 
immediate bit 	prefix branch 
integer integer 	format tracking info 
encoded actually 	strchr color 
used 	color color color 
subtracted encoded 	fputs unmerged 
bit obtain 	status status 
right end 	status status status 
ziplist integers 	print trailer 
represented little 	status status status 
endian 	status status 
order copyright 	status print trailer 
pieter noordhuis 	fopen git 
pcnoordhuis gmail 	path strbuf release 
dot copyright 	strbuf getline 
salvatore sanfilippo 	fclose strbuf detach 
antirez 	strbuf release 
gmail dot 	read line git 
rights reserved 	path read 
redistribution use 	line git path 
source binary 	read line 
forms without 	git path read 
modification 	line git 
permitted provided 	path strcmp 
following conditions 	strcmp strcmp strcmp 
met redistributions 	free free 
source code 	free free starts 
must retain 	starts strbuf 
copyright 	split max strbuf 
notice list 	trim sha 
conditions following 	find unique abbrev 
disclaimer redistributions 	strbuf reset 
binary form 	strbuf addf strbuf 
must reproduce 	reset strbuf 
copyright 	addf strbuf release 
notice list 	fopen git 
conditions following 	path die errno 
disclaimer documentation 	git path 
materials provided 	strbuf getline strbuf 
distribution neither 	trim abbrev 
name 	sha line list 
redis names 	append read 
contributors may 	rebase todolist 
used endorse 	read rebase todolist 
promote products 	status status 
derived software 	status status git 
without 	path status 
specific prior 	status status status 
written permission 	list clear 
software provided 	list clear status 
copyright holders 	status show 
contributors express 	rebase information unmerged 
implied 	print rebase 
warranties including 	state status status 
limited implied 	status stat 
warranties merchantability 	git path merge 
fitness particular 	msg print 
purpose disclaimed 	rebase state status 
shall 	split commit 
copyright owner 	progress status status 
contributors liable 	status status 
direct indirect 	status status 
incidental special 	status status print 
exemplary consequential 	trailer status 
damages 	find unique abbrev 
including limited 	unmerged status 
procurement substitute 	status status status 
goods services 	print trailer 
loss use 	status find unique 
data profits 	abbrev unmerged 
business 	status status status 
interruption however 	status print 
caused theory 	trailer status status 
liability whether 	status status 
contract strict 	print trailer strbuf 
liability tort 	read file 
including 	git path strbuf 
negligence otherwise 	setlen skip 
arising way 	prefix strbuf starts 
use software 	sha hex 
even advised 	find unique 
possibility damage 	abbrev strbuf reset 
different 	strbuf addstr 
encoding length 	strcmp strbuf detach 
possibilities bit 	strbuf release 
integer immediate 	skip prefix strstr 
encoding macro 	strlen strbuf 
determine type 	reset hashcpy strchrnul 
utility 	strbuf strcmp 
macros know 	strbuf reset strbuf 
positive increment 	addstr find 
entries pushed 	unique abbrev strbuf 
one time 	init reflog 
extract encoding 	ent reverse strbuf 
pointed 	release dwim 
ptr encoding 	hashcmp lookup commit 
bytes needed 	reference gently 
store integer 	hashcmp skip prefix 
encoded encoding 	skip prefix 
bit immediate 	xstrdup xstrdup 
encode 	find unique abbrev 
length rawlen 	hashcpy sha 
writing returns 	hashcmp free strbuf 
amount bytes 	release stat 
required encode 	git path merge 
length although 	head stat 
encoding 	git path stat 
given may 	git path 
determine raw 	stat git path 
length implies 	read strip 
integer encoding 	branch read strip 
length always 	branch stat 
store 	git path stat 
length decode 	git path 
length encoded 	read strip branch 
ptr encoding 	read strip 
variable hold 	branch stat 
entries encoding 	git path cherry 
lensize 	pick head 
variable hold 	sha hashcpy stat 
number bytes 	git path 
required encode 	read strip branch 
entries length 	stat git 
len variable 	path revert head 
hold 	sha hashcpy 
entries length 	status detached color 
encode length 	show merge 
previous entry 	progress show progress 
write number 	show rebase 
bytes needed 	progress show cherry 
encode 	pick progress 
length encode 	show revert progress 
length previous 	show bisect 
entry write 	progress color color 
uses larger 	memset status 
encoding required 	state strcmp 
ziplist 	strcmp color skip 
cascade update 	prefix status 
decode number 	color status status 
bytes required 	status print 
store length 	tracking status print 
previous element 	state free 
perspective 	free free status 
entry pointed 	color status 
ptr decode 	color status color 
length previous 	status print 
element perspective 	updated status print 
entry pointed 	unmerged status 
ptr 	print changed strcmp 
difference number 	status print 
bytes needed 	submodule summary status 
store length 	print submodule 
previous element 	summary status print 
len entry 	status print 
pointed 	status status 
total number 	status status print 
bytes used 	verbose status 
entry pointed 	color color quote 
check pointed 	path strbuf 
entry encoded 	release color color 
integer 	putchar color 
stores integer 	color putchar putchar 
encoding encoding 	quote path 
great encoded 	strchr putchar strbuf 
check smallest 	addch strbuf 
encoding types 	release quote path 
hold 	strchr putchar 
store integer 	strbuf addch strbuf 
encoded encoding 	release quote 
nothing stored 	path color color 
encoding read 	strbuf release 
integer encoded 	color color color 
encoding 	color color 
information entry 	color strcmp 
create empty 	color color skip 
ziplist resize 	prefix branch 
ziplist entry 	color stat tracking 
inserted need 	info shorten 
prevlen 	unambiguous color color 
field next 	free color 
entry equal 	color label color 
length inserted 	label color 
entry occur 	color label color 
length cannot 	color label 
encoded 	color color label 
next entry 	color color 
needs grow 	fputc shortstatus print 
bit larger 	tracking shortstatus 
hold encoded 	unmerged shortstatus status 
prevlen done 	shortstatus shortstatus 
free 	shortstatus print 
happens entry 	status header status 
already inserted 	updated status 
causes realloc 	changed status untracked 
memmove however 	status nobranch 
encoding prevlen 	status unmerged status 
may 	local branch 
require entry 	status remote branch 
grown well 	status onbranch 
effect may 	unspecified needswork use 
cascade throughout 	git reset 
ziplist consecutive 	unresolve diff status 
entries 	uses outside 
size close 	range trouble unless 
zip biglen 	user explicitly 
need check 	request submodule ignore 
prevlen encoded 	mode passing 
every consecutive 	command line option 
entry 	ignore changed 
note effect 	submodule sha 
also happen 	comparing index head 
reverse bytes 	matter configured 
required encode 	otherwise user won 
prevlen field 	shown submodules 
shrink 	manually added staged 
effect deliberately 	committed would 
ignored cause 	really confusing change 
flapping effect 	change prepend 
chain prevlen 	header actual output 
fields first 	going stdout 
grown 	definitely want color 
shrunk consecutive 	since going 
inserts rather 	commit message file 
field allowed 	even setting 
stay larger 	won work since 
necessary large 	isatty stdout 
prevlen 	want insert scissor 
field implies 	line reliably 
ziplist holding 	diff committing 
large entries 	print updated printed 
anyway pointer 	header use 
points first 	prefix per user 
entry 	config turn 
need updated 	pick ccb message 
consecutive fields 	pick message 
may need 	function assumes line 
update abort 	contain useless 
next entry 	spaces command strbuf 
abort 	split max 
prevlen changed 	left space trim 
prevlen field 	abbreviation extract 
next needs 	branch information rebase 
bytes hold 	bisect rebase 
raw length 	bisect head relative 
cur 	resolve right 
current pointer 	reflog entry sha 
offset next 	commit match 
element update 	without lookup 
tail offset 	perhaps sha tag 
next 	dereference commit 
element tail 	staged unstaged nothing 
element move 	deleted added 
tail back 	deleted added deleted 
advance cursor 	added modified 
would result 	wt-status.h worktree status 
shrinking 	index status 
want avoid 	stagemask head path 
rawlen available 	initial branch 
bytes stop 	reference pathspec verbose 
raw length 	amend nowarn 
next changed 	use color gettext 
num 	display comment 
entries starting 	prefix relative paths 
returns pointer 	submodule summary 
ziplist storing 	show ignored 
prevrawlen entry 	files ignore submodule 
may increase 	arg color 
decrease 	palette colopts termination 
number bytes 	show branch 
required compare 	hints commitable workdir 
current prevrawlen 	dirty index 
always room 	file prefix change 
store previously 	untracked ignored 
stored 	untracked merge progress 
entry deleted 	progress empty 
update offset 	patch rebase progress 
tail tail 	rebase interactive 
contains one 	progress cherry pick 
entry need 	progress bisect 
take 	progress revert progress 
nextdiff account 	detached branch 
well otherwise 	onto detached detached 
change size 	sha revert 
prevlen doesn 	head sha 
effect tail 	cherry pick head 
offset 	sha strbuf 
move tail 	state detached color 
front ziplist 	fmt color 
entire tail 	fmt commit originate 
deleted need 	normal commit 
move memory 	came merge commit 
resize 	came cherry 
update length 	pick computed processing 
nextdiff raw 	individual sections 
length next 	status xdiff-interface.c consume 
entry changed 	consume callback 
need cascade 	data remainder num 
update 	num line 
throughout ziplist 	len priv size 
insert item 	priv size 
initialized avoid 	priv nbuf priv 
warning easy 	ctx blk 
see reason 	recovered smaller 
use 	xpp xecfg xecb 
uninitialized find 	consume callback 
prevlen entry 	data xpp xecfg 
inserted see 	ret state 
entry encoded 	ecb ptr filename 
encoding appropriate 	ptr sha 
integer 	size ptr size 
encoding encoding 	negate line 
untouched however 	len buffer buffer 
zip encode 	size priv 
length use 	line buffer regs 
length figure 	pmatch result 
encode 	reg xecfg cflags 
need space 	regs reg 
length previous 	expression buffer xecfg 
entry length 	regs git 
payload insert 	xmerge style parse 
position equal 	num error 
tail 	parse num 
need make 	parse num parse 
sure next 	num memcmp 
entry hold 	memchr consume strbuf 
entry length 	consume one 
prevlen field 	strbuf consume one 
store 	strbuf reset 
offset realloc 	consume one strbuf 
may change 	reset memcmp 
address apply 	trim common tail 
memory move 	xdl diff 
necessary update 	memset memset strbuf 
tail 	init xdi 
offset subtract 	diff strbuf release 
one zip 	stat error 
end bytes 	fopen error xsize 
encode entry 	xmalloc fread 
raw length 	fclose error fclose 
next 	hashcmp xstrdup 
entry update 	read sha 
offset tail 	file die sha 
tail contains 	hex memchr 
one entry 	xstrndup regexec isspace 
need take 	memcpy free 
nextdiff 	xmalloc alloc strchr 
account well 	die xstrndup 
otherwise change 	regcomp die free 
size prevlen 	regfree free 
doesn effect 	free strcmp die 
tail offset 	strcmp strcmp 
element 	die git config 
tail nextdiff 	incomplete line 
raw length 	complete line trim 
next entry 	common substring 
changed need 	end buffers least 
cascade update 	ctx lines 
throughout 	end exclude 
ziplist write 	terminating newline matching 
entry merge 	make nul 
ziplists first 	terminated xdiff-interface.h xpp 
second appending 	xecfg ecb 
second first 	consume callback data 
note 	xpp xecfg 
larger ziplist 	line len ptr 
reallocated contain 	filename ptr 
merged ziplist 	sha ptr size 
either first 	xecfg line 
second used 	cflags xecfg git 
result 	xmerge style 
parameter used 	xdiff isn equipped 
free calling 	handle content 
function input 	gigabyte make cutoff 
parameters longer 	give breathing 
valid since 	room constant sized 
changed 	additions merge 
free place 	markers xdiff.h 
result ziplist 	mmf size mmf 
contents first 	xpp xecfg 
followed second 	ecb orig xmp 
failure returns 	result lib 
merge 	diff davide libenzi 
impossible success 	file differential 
returns merged 	library copyright davide 
ziplist expanded 	libenzi library 
version either 	free software redistribute 
first second 	modify terms 
also 	gnu lesser general 
frees unused 	license published 
input ziplist 	free software foundation 
sets input 	either version 
ziplist argument 	license option later 
equal newly 	version library 
reallocated 	distributed hope useful 
ziplist merge 	without warranty 
merge list 	without even 
pick largest 	implied warranty merchantability 
ziplist resize 	fitness particular 
easily place 	purpose see gnu 
must 	lesser general 
also track 	license details received 
appending prepending 	copy gnu 
target ziplist 	lesser general license 
retain first 	along library 
append second 	write free software 
first 	foundation inc 
retain second 	temple place suite 
prepend first 	boston usa 
second calculate 	davide libenzi davidel 
bytes subtract 	xmailserver ifdef 
one pair 	cplusplus merge simplification 
metadata 	levels merge 
combined length 	favor modes merge 
limited within 	output styles 
max save 	label orig 
offset positions 	label label ifdef 
start ripping 	cplusplus defined 
memory 	xdiff xdiffi.c lim 
apart extend 	lim kvdf 
target zlbytes 	kvdb need min 
append prepend 	spl xenv 
source append 	xscr chg chg 
appending target 	lim lim 
copy 	kvdf kvdb need 
source target 	min spl 
copying original 	xenv dmax bmid 
end target 	odd fmax 
end source 	bmax prev best 
header append 	got snake 
prepending 	fbest fbest bbest 
target move 	bbest lim 
target contents 	lim kvdf 
exactly size 	kvdb need min 
source end 	xenv rchg 
copy source 	rindex rchg rindex 
vacataed 	spl xpp 
space source 	ndiags kvd kvdf 
end source 	kvdb xenv 
end target 	xscr chg chg 
header update 	xch xdf 
header metadata 	xdfo flags ixo 
tail 	ixs ixref 
offset bytes 	grpsiz nrec rchgo 
first ziplist 	recs xscr 
end first 	xch rchg xscr 
ziplist bytes 	xch xscr 
offset original 	ecb xecfg xch 
tail 	xche xscr 
second ziplist 	flags xch ignore 
bytes header 	rec xpp 
second offset 	xecfg ecb 
keeps header 	xscr xdl min 
ziplist cascade 	xdl max 
update 	xdl split xdl 
fixes prev 	recs cmp 
length values 	xdl recs cmp 
finds correct 	xdf diff 
prev length 	alg xdl patience 
assumes rest 	diff xdf 
list 	diff alg xdl 
okay tell 	histogram diff 
cascade update 	xdl prepare env 
start first 	xdl malloc 
ziplist tail 	xdl free env 
element fix 	xdl bogosqrt 
merge 	xdl recs cmp 
seam free 	xdl free 
didn realloc 	xdl free env 
returns offset 	xdl free 
use iterating 	xdl malloc 
ziplist next 	xdl recmatch xdl 
given 	recmatch xdl 
index negative 	change xdl free 
list traversed 	script xdl 
back front 	free xdl hunk 
list doesn 	hunk func 
contain element 	xdl blankline xdl 
provided 	blankline xdl 
index returned 	diff xdl change 
pointer next 	compact xdl 
entry ziplist 	change compact xdl 
pointer ziplist 	build script 
pointer current 	xdl free env 
element 	xdl mark 
element returned 	ignorable xdl free 
otherwise end 	script xdl 
could equal 	free env xdl 
zip end 	free script 
caused ziplist 	xdl free 
otherwise 	env lib diff 
next element 	davide libenzi 
zip end 	file differential library 
next entry 	copyright davide 
pointer previous 	libenzi library free 
entry ziplist 	software redistribute 
iterating 	modify terms gnu 
backwards zip 	lesser general 
end tail 	license published free 
equal first 	software foundation 
element list 	either version license 
already head 	option later 
entry 	version library distributed 
pointed store 	hope useful 
either sstr 	without warranty without 
sval depending 	even implied 
encoding entry 	warranty merchantability 
sstr always 	fitness particular purpose 
able 	see gnu 
find whether 	lesser general license 
pointer integer 	details received 
points end 	copy gnu lesser 
ziplist otherwise 	general license 
insert entry 	along library write 
single 	free software 
entry ziplist 	foundation inc temple 
pointed also 	place suite 
update place 	boston usa davide 
able iterate 	libenzi davidel 
ziplist deleting 	xmailserver see difference 
entries 	algorithm variations 
store pointer 	eugene myers basically 
current element 	considers box 
ziplist realloc 	lim lim scan 
might result 	forward diagonal 
different pointer 	starting backward 
direction 	diagonal starting lim 
back front 	lim values 
might last 	diagonal crosses returns 
entry end 	furthest point 
pointing zip 	reach might end 
end check 	expensive cases 
range 	algorithm full little 
entries ziplist 	bit heuristic 
compare entry 	needed cut search 
pointer sstr 	suboptimal point 
length slen 	initial diagonal values 
equal raw 	forward backward 
compare 	path need extent 
compare encoded 	diagonal domain 
values compare 	one next values 
encoding different 	exits box 
implementations may 	boundaries need change 
encoded integers 	opposite direction 
differently 	max min 
find pointer 	must power two 
entry equal 	also initialize 
specified entry 	external avoid extra 
skip skip 	conditions check 
entries every 	inside core loop 
comparison 	need extent 
returns field 	diagonal domain one 
could found 	next values 
compare current 	exits box boundaries 
entry specified 	need change 
entry find 	opposite direction max 
searched 	min must 
field encoded 	power two also 
note first 	initialize external 
time done 	avoid extra conditions 
vencoding non 	check inside 
zero vll 	core loop edit 
integer 	cost heuristic 
entry encoded 	trigger got 
uchar max 	good snake sample 
retry next 	current diagonals 
time must 	see reached interesting 
non zero 	path measure 
compare 	function distance diagonal 
current entry 	corner penalized 
specified entry 	distance mid diagonal 
vencoding uchar 	current edit 
max encoding 	cost times magic 
possible field 	factor xdl 
valid 	heur consider interesting 
integer reset 	enough enough 
skip count 	spent much time 
skip entry 	collect furthest 
move next 	reaching path measure 
entry length 	rule divide 
ziplist 	impera recursively split 
store length 	box sub 
small enough 	boxes calling 
ziplist blob 	box splitting function 
size bytes 	note real 
num times 	job marking changed 
push 	lines done 
pop pos 	two boundary reaching 
argument given 	checks shrink 
use random 	box walking diagonal 
seed pop 	snake one 
values compare 	dimension empty records 
deleting 	one must 
entry increase 	obviously changed divide 
prevrawlensize entry 	impera allocate 
create list 	setup vectors used 
gives hello 	differential algorithm 
foo quux 	one store forward 
merge 	path one 
two empty 	store backward 
ziplists empty 	path gnu diff 
result back 	move back 
merge gives 	forward change groups 
hello foo 	consistent pretty 
quux 	diff output also 
hello foo 	helps finding 
quux hold 	joinable change groups 
temp vars 	reduce diff 
ziplist create 	size find first 
lists ziplist 	changed line 
reference 	compacted file need 
list naive 	keep track 
way elements 	indexes find changed 
similar stresser 	lines file 
executed tcl 	scanning compacted file 
test suite 	need skip 
ziplist.h 	properly note loops 
first second 	testing changed 
slen index 	lines rchg 
sval slen 	need index bounding 
lval slen 	since prepared 
index num 	zero position record 
slen 	start changed 
vstr vlen 	compacted file find 
skip argc 	end compacted 
argv copyright 	file indexes ixo 
pieter noordhuis 	line current 
pcnoordhuis gmail 	change equal last 
dot 	line current 
copyright salvatore 	change shift backward 
sanfilippo antirez 	change might 
gmail dot 	joined two change 
rights reserved 	groups take 
redistribution use 	scenario account moving 
source 	start index 
binary forms 	accordingly file end 
without modification 	index record 
permitted provided 	end position 
following conditions 	matched changes file 
met redistributions 	change record 
source 	end index file 
code must 	first line 
retain copyright 	current change equal 
notice list 	line next 
conditions following 	current change shift 
disclaimer redistributions 	forward change 
binary 	might joined two 
form must 	change groups 
reproduce copyright 	take scenario account 
notice list 	moving start 
conditions following 	index accordingly file 
disclaimer documentation 	end index 
materials 	keep tracking reference 
provided distribution 	index shifting 
neither name 	together corresponding changes 
redis names 	file move 
contributors may 	back possibly 
used endorse 	merged changes match 
promote 	recorded position 
products derived 	file trivial collects 
software without 	groups changes 
specific prior 	creates edit script 
written permission 	xdiffi.h lim 
software provided 	lim kvdf kvdb 
copyright 	need min 
holders contributors 	xenv xpp xdf 
express implied 	xdfo flags 
warranties including 	xscr xscr xscr 
limited implied 	ecb xecfg 
warranties merchantability 	xpp env xpp 
fitness 	env lib 
particular purpose 	diff davide libenzi 
disclaimed shall 	file differential 
copyright owner 	library copyright 
contributors liable 	davide libenzi library 
direct indirect 	free software 
incidental 	redistribute modify terms 
special exemplary 	gnu lesser 
consequential damages 	general license published 
including limited 	free software 
procurement substitute 	foundation either version 
goods services 	license option 
loss 	later version library 
use data 	distributed hope 
profits business 	useful without warranty 
interruption however 	without even 
caused theory 	implied warranty merchantability 
liability 	fitness particular 
whether contract 	purpose see gnu 
strict liability 	lesser general 
tort including 	license details received 
negligence otherwise 	copy gnu 
arising way 	lesser general 
use 	license along library 
software even 	write free 
advised possibility 	software foundation inc 
damage ziplist 	temple place 
zipmap.c len 	suite boston usa 
len key 	davide libenzi 
klen 	davidel xmailserver defined 
totlen llen 	xdiffi xemit.c 
free klen 	xdf rec xdf 
vlen used 	pre ecb 
len key 	xdf rec xdf 
klen val 	pre ecb 
vlen 	size psize rec 
update zmlen 	xscr xecfg 
offset freelen 	xch xchp lxch 
reqlen empty 	max common 
vempty key 	max ignorable ignored 
klen deleted 	distance rec 
zmlen 	len buf 
freelen key 	priv len buf 
klen vlen 	xecfg func 
key klen 	line start limit 
vlen key 	size step 
klen len 	buf dummy rec 
totlen 	reclen len 
argc argv 	xscr ecb xecfg 
buf vlen 	lctx xch 
vlen key 	xche funclineprev func 
klen vlen 	line strlen 
zmalloc memcpy 	xdl rec xdl 
memrev 	emit diffrec 
ifbe zipmap 	isalpha isspace memcpy 
len bytes 	xdl rec 
memcpy memrev 	xdl hunk xdl 
ifbe zipmap 	max xdl 
decode length 	max func line 
zipmap 	xdl min 
encode length 	xdl min 
memcmp zipmap 	func line func 
decode length 	line func 
zipmap encode 	line xdl emit 
length zipmap 	hunk hdr 
decode 	xdl emit record 
length zipmap 	xdl emit 
encode length 	record xdl emit 
zipmap decode 	record xdl 
length zipmap 	emit record xdl 
encode length 	emit record 
zipmap 	lib diff davide 
raw key 	libenzi file 
length zipmap 	differential library copyright 
raw length 	davide libenzi 
zrealloc zipmap 	library free software 
required length 	redistribute modify 
zipmap 	terms gnu 
lookup raw 	lesser general license 
zipmap resize 	published free 
zipmap raw 	software foundation either 
entry length 	version license 
zipmap resize 	option later version 
memmove 	library distributed 
memmove zipmap 	hope useful without 
resize zipmap 	warranty without 
encode length 	even implied warranty 
memcpy zipmap 	merchantability fitness 
encode length 	particular purpose see 
memcpy 	gnu lesser 
zipmap lookup 	general license details 
raw zipmap 	received copy 
raw entry 	gnu lesser general 
length memmove 	license along 
zipmap resize 	library write free 
zipmap 	software foundation 
decode length 	inc temple 
zipmap len 	place suite boston 
bytes zipmap 	usa davide 
raw key 	libenzi davidel xmailserver 
length zipmap 	starting passed 
decode 	change atom find 
length zipmap 	latest change 
len bytes 	atom included inside 
zipmap raw 	differential hunk 
length zipmap 	according specified configuration 
lookup raw 	also advance 
zipmap 	xscr first changes 
raw key 	must discarded 
length zipmap 	number ignored blank 
decode length 	lines ignorable 
zipmap len 	changes far changes 
bytes zipmap 	also identifiers 
lookup 	vms esoterico overlap 
raw zipmap 	next change 
rewind zipmap 	include current 
next zipmap 	hunk start find 
lookup raw 	end emit 
zipmap decode 	current hunk header 
length 	emit pre 
zipmap encode 	context merge previous 
length fwrite 	current change 
perror zipmap 	atom removes lines 
decode length 	first file 
zipmap encode 	adds lines second 
length 	file emit 
fwrite perror 	post context xemit.h 
unused unused 	xscr xecfg 
zipmap zipmap 	xscr ecb xecfg 
zipmap zipmap 	lib diff 
zipmap repr 	davide libenzi file 
zipmap 	differential library 
zipmap zipmap 	copyright davide libenzi 
zipmap repr 	library free 
zipmap zipmap 	software redistribute 
repr zipmap 	modify terms gnu 
zipmap zipmap 	lesser general 
repr 	license published free 
zipmap del 	software foundation 
zipmap repr 	either version license 
zipmap zipmap 	option later 
zipmap zipmap 	version library distributed 
rewind zipmap 	hope useful 
next 	without warranty without 
map data 	even implied 
structure optimized 	warranty merchantability fitness 
size file 	particular purpose 
data structure 	see gnu lesser 
mapping implementing 	general license 
lookup 	details received copy 
data structure 	gnu lesser 
designed memory 	general license along 
efficient redis 	library write 
hash type 	free software 
uses data 	foundation inc temple 
structure 	place suite 
hashes composed 	boston usa davide 
small number 	libenzi davidel 
elements hash 	xmailserver defined xemit 
table given 	xhistogram.c ptr 
number elements 	cnt next rcha 
reached 	next ptrs 
given many 	table bits records 
times redis 	size line 
hashes used 	map size max 
represent objects 	chain length 
composed fields 	key shift ptr 
big 	shift cnt 
win terms 	common env xpp 
used memory 	begin end 
copyright salvatore 	begin end 
sanfilippo antirez 	xpp index line 
gmail dot 	count ptr 
rights 	tbl idx chain 
reserved redistribution 	len rec 
use source 	chain rec index 
binary forms 	lcs ptr 
without modification 	line count line 
permitted provided 	count next 
following 	rec index lcs 
conditions met 	line count 
redistributions source 	line count ptr 
code must 	index line 
retain copyright 	count line count 
notice list 	xpp xpp 
conditions 	env line count 
following disclaimer 	line count 
redistributions binary 	index lcs result 
form must 	file file 
reproduce copyright 	xpp env 
notice list 	xdl recmatch line 
conditions 	end table 
following disclaimer 	hash cmp next 
documentation materials 	ptr xdl 
provided distribution 	min line map 
neither name 	xdl cha 
redis names 	alloc line map 
contributors 	table hash 
may used 	cmp cmp next 
endorse promote 	ptr cmp 
products derived 	xdl min cnt 
software without 	line end 
specific prior 	line end cmp 
written 	xdl min 
permission software 	cnt next ptr 
provided copyright 	scan line 
holders contributors 	end lcs xdl 
express implied 	fall back 
warranties including 	diff line 
limited 	end memset xdl 
implied warranties 	hashbits xdl 
merchantability fitness 	malloc memset xdl 
particular purpose 	malloc memset 
disclaimed shall 	xdl malloc memset 
copyright owner 	xdl cha 
contributors 	init memset find 
liable direct 	lcs fall 
indirect incidental 	back classic diff 
special exemplary 	histogram diff 
consequential damages 	histogram diff line 
including limited 	end line 
procurement 	end xdl free 
substitute goods 	xdl free 
services loss 	xdl free xdl 
use data 	cha free 
profits business 	xdl prepare env 
interruption however 	histogram diff 
caused 	copyright google 
theory liability 	inc copyright owners 
whether contract 	documented git 
strict liability 	log program accompanying 
tort including 	materials made 
negligence otherwise 	available terms eclipse 
arising 	distribution license 
way use 	accompanies distribution reproduced 
software even 	available http 
advised possibility 	www eclipse documents 
damage memory 	edl php 
layout zipmap 	rights reserved redistribution 
map 	use source 
foo bar 	binary forms without 
hello world 	modification permitted 
zmlen len 	provided following conditions 
foo len 	met redistributions 
free bar 	source code 
len 	must retain copyright 
hello len 	notice list 
free world 	conditions following disclaimer 
zmlen length 	redistributions binary 
holds current 	form must reproduce 
size zipmap 	copyright notice 
zipmap 	list conditions following 
length greater 	disclaimer documentation 
equal used 	materials provided distribution 
zipmap needs 	neither name 
traversed find 	eclipse foundation inc 
length len 	names contributors 
length 	may used endorse 
following key 	promote products 
len lengths 	derived software without 
encoded single 	specific prior 
bytes first 	written permission software 
bit single 	provided copyright 
length 	holders contributors 
four bytes 	express implied warranties 
integer follows 	including limited 
host ordering 	implied warranties merchantability 
used signal 	fitness particular 
end hash 	purpose disclaimed shall 
free 	copyright owner 
number free 	contributors liable direct 
unused bytes 	indirect incidental 
resulting modification 	special exemplary consequential 
values associated 	damages including 
key instance 	limited procurement substitute 
foo 	goods services 
bar later 	loss use data 
foo free 	profits business 
use enlarge 	interruption however caused 
later even 	theory liability 
order key 	whether contract strict 
pair 	liability tort 
fits free 	including negligence 
always bit 	otherwise arising way 
number update 	use software 
operation free 	even advised possibility 
bytes zipmap 	damage occurrence 
reallocated 	map line record 
make sure 	chain ptr 
small possible 	identical another element 
compact representation 	insert onto 
two elements 	front existing element 
hash actually 	chain cap 
foo 	rec cnt max 
bar hello 	cnt first 
world xff 	time ever seen 
note keys 	particular element 
values prefixed 	sequence construct chain 
length objects 	early xdl 
lookup 	cha free lines 
take number 	comes xprepare 
elements zipmap 	xdl prepare 
number bytes 	ctx xinclude.h lib 
needed represent 	diff davide 
zipmap lowers 	libenzi file differential 
constant 	library copyright 
times considerably 	davide libenzi library 
following defines 	free software 
max free 	redistribute modify terms 
field described 	gnu lesser 
comments max 	general license published 
number 	free software 
trailing bytes 	foundation either version 
following macro 	license option 
returns number 	later version library 
bytes needed 	distributed hope 
encode length 	useful without warranty 
integer 	without even 
lengths zipmap 	implied warranty 
biglen bytes 	merchantability fitness particular 
lengths create 	purpose see 
empty zipmap 	gnu lesser general 
length decode 	license details 
encoded 	received copy gnu 
length pointed 	lesser general 
encode length 	license along library 
writing returns 	write free 
amount bytes 	software foundation inc 
required encode 	temple place 
length 	suite boston usa 
search matching 	davide libenzi 
key returning 	davidel xmailserver defined 
pointer entry 	xinclude xmacros.h 
inside zipmap 	lib diff davide 
returns key 	libenzi file 
found 	differential library copyright 
returned totlen 	davide libenzi 
entire size 	library free 
zimap calling 	software redistribute modify 
function able 	terms gnu 
reallocate original 	lesser general license 
zipmap 	published free 
make room 	software foundation either 
entries match 	version license 
skip key 	option later version 
user doesn 	library distributed 
care total 	hope useful without 
length 	warranty without 
zipmap skip 	even implied warranty 
well skip 	merchantability fitness 
free total 	particular purpose see 
amount used 	gnu lesser 
key encoded 	general license details 
length 	received copy 
payload total 	gnu lesser general 
amount used 	license along 
encoded length 	library write 
single free 	free software foundation 
count payload 	inc temple 
points 	place suite boston 
key function 	usa davide 
returns total 	libenzi davidel xmailserver 
amount bytes 	defined xmacros 
used store 	xmerge.c merge mode 
entry entry 	chg chg 
key 	chg count next 
associated trailing 	line count 
free space 	flags rec rec 
key creating 	result use 
key already 	orig count needs 
exist update 	dest recs 
update 	size count needs 
key already 	dest count 
preset otherwise 	needs dest file 
key found 	size needs 
enlarge increase 	name name 
zipmap length 	name size style 
insert 	dest marker 
key found 	size marker size 
enough space 	marker size 
compute total 	marker size needs 
length store 	name name 
offset key 	ancestor name favor 
within 	dest style 
current zipmap 	marker size size 
resized move 	needs xpp 
tail backwards 	xscr ptr size 
pair fits 	chg next 
current position 	simplify alnum result 
number 	next begin 
bytes moved 	end xscr xscr 
caused end 	xmp result 
zipmap note 	changes xpp ancestor 
original zmlen 	name name 
used suitable 	name chg 
block 	chg chg level 
key entry 	style favor 
written much 	ffo marker size 
free space 	size orig 
move tail 	xmp result xscr 
zipmap bytes 	xscr status 
front 	xpp xdl malloc 
shrink zipmap 	free xdl 
want zipmaps 	recmatch memcpy xdl 
space efficient 	recs copy 
first move 	xdl recs copy 
tail empty 	eol crlf 
bytes 	eol crlf eol 
front resize 	crlf strlen 
zipmap empty 	strlen strlen needed 
bytes smaller 	xdl recs 
write key 	copy memset 
done key 	memcpy xdl recs 
specified 	copy memset 
key deleted 	memcpy xdl orig 
pointed integer 	copy memset 
key found 	xdl recs copy 
found deleted 	memset memcpy 
decrease zipmap 	fill conflict hunk 
length 	xdl recs 
call iterating 	copy needed xdl 
elements via 	recs copy 
zipmap next 	xdl recs copy 
function used 	xdl recs 
iterate zipmap 	copy xdl diff 
elements 	xdl change 
first call 	compact xdl change 
first argument 	compact xdl 
pointer zipmap 	build script xdl 
next calls 	free env 
zipmap next 	xdl free 
returns 	env xdl malloc 
used first 	xdl free 
argument example 	env xdl free 
zipmap rewind 	script xdl 
zipmap zipmap 	free env xdl 
next key 	free script 
klen 	isalnum line contains 
vlen bytes 	alnum free 
key klen 	lines contain alnum 
key bytes 	xdl merge 
vlen search 	two conflicts xdl 
key retrieve 	append merge 
pointer 	xdl cleanup merge 
len associated 	xdl append 
key found 	merge xdl cleanup 
function returns 	merge xdl 
otherwise key 	merge cmp lines 
exists otherwise 	xdl append 
returned 	merge xdl 
number entries 	cleanup merge xdl 
inside zipmap 	append merge 
store length 	xdl cleanup merge 
small enough 	xdl append 
raw 	merge xdl cleanup 
size bytes 	merge xdl 
zipmap serialize 	refine conflicts xdl 
zipmap disk 	simplify non 
everywhere needed 	conflicts xdl cleanup 
writing returned 	merge xdl 
amount 	fill merge buffer 
bytes starting 	xdl malloc 
zipmap pointer 	xdl cleanup merge 
zipmap.h key 	xdl fill 
klen val 	merge buffer xdl 
vlen update 	cleanup merge 
key 	xdl diff xdl 
klen deleted 	diff xdl 
key klen 	free env 
vlen key 	xdl change compact 
klen vlen 	xdl change 
key klen 	compact xdl build 
argc 	script xdl 
argv map 	free env xdl 
data structure 	change compact 
optimized size 	xdl change compact 
see zipmap 	xdl build 
info copyright 	script xdl free 
salvatore 	script xdl 
sanfilippo antirez 	free env xdl 
gmail dot 	free env 
rights reserved 	xdl malloc memcpy 
redistribution use 	xdl malloc 
source binary 	memcpy xdl merge 
forms 	xdl free 
without modification 	script xdl 
permitted provided 	free script xdl 
following conditions 	free env 
met redistributions 	xdl free env 
source code 	lib diff 
must 	davide libenzi file 
retain copyright 	differential library 
notice list 	copyright davide libenzi 
conditions following 	johannes schindelin 
disclaimer redistributions 	library free software 
binary form 	redistribute modify 
must 	terms gnu lesser 
reproduce copyright 	general license 
notice list 	published free software 
conditions following 	foundation either 
disclaimer documentation 	version license option 
materials provided 	later version 
distribution 	library distributed hope 
neither name 	useful without 
redis names 	warranty without 
contributors may 	even implied warranty 
used endorse 	merchantability fitness 
promote products 	particular purpose see 
derived 	gnu lesser 
software without 	general license details 
specific prior 	received copy 
written permission 	gnu lesser general 
software provided 	license along 
copyright holders 	library write free 
contributors 	software foundation 
express implied 	inc temple place 
warranties including 	suite boston 
limited implied 	usa davide libenzi 
warranties merchantability 	davidel xmailserver 
fitness particular 	conflict conflict take 
purpose 	first conflict 
disclaimed shall 	take second conflict 
copyright owner 	take point 
contributors liable 	respective postimages 
direct indirect 	chg side wants 
incidental special 	change common 
exemplary 	ancestor overlap lines 
consequential damages 	postimage side 
including limited 	appear merge result 
procurement substitute 	region touched 
goods services 	neither side point 
loss use 	preimage course 
data 	one preimage shared 
profits business 	common ancestor 
interruption however 	conflicts returns line 
caused theory 	ends last 
liability whether 	line eol preceding 
contract strict 	line ends 
liability 	line ending cannot 
tort including 	determined lines 
negligence otherwise 	last must end 
arising way 	cannot determine 
use software 	eol style 
even advised 	empty file last 
possibility 	line ends 
damage zmalloc.c 	line eol determine 
ptr used 	eol second 
memory zmalloc 	last line match 
safe used 	post images 
memory mutex 	preceding first lines 
size 	end line 
size ptr 	style look pre 
size ptr 	image first 
ptr size 	line unless already 
realptr oldsize 	settled still 
newptr ptr 	undecided use conflicting 
realptr 	part postimage 
size ptr 	side shared preimage 
realptr oldsize 	postimage side 
oom handler 	conflicting part 
page rss 	postimage side postimage 
buf filename 	side sometimes 
count 	changes quite identical 
task info 	differ lines 
info count 	hard show lines 
rss field 	conflicting handle 
line bytes 	conflicts sense refining 
flen field 	conflict one 
mib 	side empty probably 
size len 	work outside 
mib size 	git since simple 
len free 	mmfile structure 
fflush abort 	happens changes identical 
malloc zmalloc 	function merges 
oom 	next marking everything 
handler update 	hunks conflicting 
zmalloc stat 	less non conflicting 
alloc zmalloc 	lines conflicts 
size update 	appears simpler 
zmalloc stat 	takes less many 
alloc 	lines lines 
calloc zmalloc 	moved conflicts level 
oom handler 	mark overlapping 
update zmalloc 	changes conflict level 
stat alloc 	mark overlapping 
zmalloc size 	changes conflict identical 
update 	level analyze 
zmalloc stat 	non identical changes 
alloc zmalloc 	minimal conflict 
zmalloc size 	level analyze non 
realloc zmalloc 	identical changes 
oom handler 	minimal conflict treat 
update 	hunks containing 
zmalloc stat 	letter number conflicting 
free update 	returns error 
zmalloc stat 	conflicts number conflicts 
alloc zmalloc 	diff output 
size realloc 	make sense 
zmalloc 	anything aggressive xdl 
oom handler 	merge eager 
update zmalloc 	conflict refine conflicts 
stat free 	output xpatience.c 
update zmalloc 	alloc hash line 
stat alloc 	line next 
update 	previous matches file 
zmalloc stat 	file env 
free zmalloc 	xpp line map 
size free 	pass records 
update zmalloc 	index file file 
stat free 	xpp env 
free 	result line count 
strlen zmalloc 	line count 
memcpy update 	sequence longest entry 
zmalloc stat 	right middle 
pthread mutex 	map sequence entry 
pthread mutex 	map line 
unlock 	line record 
sysconf snprintf 	record file file 
getpid open 	xpp env 
read close 	line count line 
close strchr 	count map 
strchr strtoll 	first line count 
task 	line count 
pid current 	end next next 
task getpid 	submap map 
task info 	line count line 
zmalloc used 	count xpp 
memory zmalloc 	file file xpp 
used 	env line 
memory fopen 	count line count 
strlen fgets 	map first 
strncmp strchr 	result file file 
strtol fclose 	xpp env 
zmalloc smap 	xdl recmatch xdl 
bytes 	malloc memset 
field sysctl 	insert record 
sysconf sysconf 	insert record xdl 
sysctl zmalloc 	malloc binary 
total amount 	search xdl free 
allocated memory 	xdl free 
aware 	xdl recmatch match 
version malloc 	match memset 
copyright salvatore 	patience diff xdl 
sanfilippo antirez 	fall back 
gmail dot 	diff memset fill 
rights reserved 	hashmap xdl 
redistribution 	free find longest 
use source 	common sequence 
binary forms 	walk common sequence 
without modification 	fall back 
permitted provided 	classic diff xdl 
following conditions 	free xdl 
met 	prepare env 
redistributions source 	patience diff lib 
code must 	diff davide 
retain copyright 	libenzi file differential 
notice list 	library copyright 
conditions following 	davide libenzi johannes 
disclaimer 	schindelin library 
redistributions binary 	free software redistribute 
form must 	modify terms 
reproduce copyright 	gnu lesser general 
notice list 	license published 
conditions following 	free software foundation 
disclaimer 	either version 
documentation materials 	license option later 
provided distribution 	version library 
neither name 	distributed hope useful 
redis names 	without warranty 
contributors may 	without even implied 
used 	warranty merchantability 
endorse promote 	fitness particular 
products derived 	purpose see gnu 
software without 	lesser general 
specific prior 	license details received 
written permission 	copy gnu 
software 	lesser general license 
provided copyright 	along library 
holders contributors 	write free software 
express implied 	foundation inc 
warranties including 	temple place suite 
limited implied 	boston usa 
warranties 	davide libenzi davidel 
merchantability fitness 	xmailserver basic 
particular purpose 	idea patience diff 
disclaimed shall 	find lines 
copyright owner 	unique files intuitively 
contributors liable 	ones want 
direct 	see common lines 
indirect incidental 	maximal ordered 
special exemplary 	sequence line 
consequential damages 	pairs ordered means 
including limited 	order sequence 
procurement substitute 	agrees order lines 
goods 	files naturally 
services loss 	defines initial common 
use data 	lines algorithm 
profits business 	tries extend common 
interruption however 	lines growing 
caused theory 	line ranges files 
liability 	identical lines 
whether contract 	common lines patience 
strict liability 	diff algorithm 
tort including 	applied recursively unique 
negligence otherwise 	line pairs 
arising way 	found line ranges 
use 	handled well 
software even 	known myers algorithm 
advised possibility 	hash mapping 
damage function 	line hash 
provide access 	line numbers first 
original libc 	second file 
free 	unused entry first 
useful instance 	line second 
free results 	etc line non 
obtained backtrace 	unique line 
symbols need 	unique either first 
define function 	second file 
including 	next previous used 
zmalloc may 	longest common 
shadow free 	sequence initially next 
implementation use 	reflects order 
jemalloc another 	file common records 
non standard 	found argument 
allocator 	pass first file 
explicitly malloc 	second xdl 
free etc 	prepare env 
tcmalloc provide 	precisely due xdl 
zmalloc size 	classify record 
systems function 	member records aka 
provided 	lines hash 
malloc given 	anymore linearized version 
store header 	words member 
information first 	guaranteed start second 
bytes every 	record etc 
allocation least 	multiply hope hashing 
allocations 	unique enough 
padded underlying 	function called recursion 
allocator rss 	inter hunk 
information specific 	parts previously non 
way warning 	unique lines 
function zmalloc 	become unique restricted 
rss 	smaller part 
designed fast 	files assumed env 
may called 	prepared xdl 
busy loops 	prepare know 
redis tries 	exactly large want 
release memory 	hash map 
expiring 	first fill entries 
swapping objects 	first file 
kind fast 	search matches second 
rss reporting 	file find 
usages use 	longest sequence smaller 
instead function 	last element 
redis 	meaning smaller line 
estimate rss 	construct sequence 
much faster 	entries ordered line 
less precise 	construction two 
version function 	entries equal index 
rss field 	sequence sequence 
proc 	length idea start 
pid stat 	list common 
rss specific 	unique lines sorted 
way system 	order file 
memory usage 	pairs longest 
estimated zmalloc 	sequence whose last 
fragmentation 	element line 
appear always 	smaller determined efficiency 
fragmentation course 	sequences kept 
fragmentation rss 	list containing exactly 
allocated bytes 	one item 
sum specified 	per sequence length 
field 	sequence smallest 
converted form 	last element terms 
bytes proc 	line common 
self smaps 	unique lines found 
field must 	iterate starting 
specified trailing 	last element adjusting 
apperas 	next members 
smaps output 	grow line ranges 
example zmalloc 	common lines 
smap bytes 	recurse recursively find 
field rss 	longest common 
returns size 	sequence unique 
physical 	lines none found 
memory ram 	ask xdl 
bytes looks 	diff job function 
ugly cleanest 	assumes env 
way achive 	prepared xdl prepare 
cross platform 	env trivial 
results 	one side empty 
cleaned http 	matching lines 
nadeausoftware articles 	environment cleaned xdl 
tip physical 	diff xprepare.c 
memory size 	size flags pass 
system note 	rhash hbits 
function 	rec pass narec 
released following 	xpp xdf 
attribution license 	xdf dis xdf 
http creativecommons 	xdf xdf 
licenses deed 	xdf xdf 
originally implemented 	xdf size flags 
david 	pass rhash 
robert nadeau 	hbits rec line 
modified redis 	rcrec rcrecs 
matt stancliff 	pass narec xpp 
note exists 	xdf hbits 
order comply 	nrec hsize bsize 
original 	hav blk 
license osx 	cur top prev 
net bsd 	crec recs 
open bsd 	rrecs rhash rchg 
bit failed 	rindex xdf 
free bsd 	xpp enl enl 
linux 	sample dis 
open bsd 	rdis rpdis rdis 
solaris dragon 	rpdis xdf 
fly bsd 	xdf nreff mlim 
free bsd 	recs rcrec 
net bsd 	dis dis 
open 	dis xdf xdf 
bsd osx 	lim recs 
free bsd 	recs xdf xdf 
others bit 	xdl hashbits 
failed sysctl 	xdl cha init 
sysconf variants 	xdl malloc 
unknown 	xdl cha free 
zmalloc.h drop 	memset xdl 
replacement zmalloc 	malloc xdl free 
order use 	xdl cha 
libc malloc 	free xdl free 
without wrappering 	xdl free 
zmalloc 	xdl cha free 
total amount 	xdl hashlong 
allocated memory 	xdl recmatch xdl 
aware version 	cha alloc 
malloc copyright 	xdl realloc xdl 
salvatore sanfilippo 	hashlong xdl 
antirez 	cha init 
gmail dot 	xdl malloc xdf 
rights reserved 	diff alg 
redistribution use 	xdl hashbits xdl 
source binary 	malloc memset 
forms without 	xdl mmfile first 
modification 	xdl hash 
permitted provided 	record xdl realloc 
following conditions 	xdl cha 
met redistributions 	alloc xdf diff 
source code 	alg xdl 
must retain 	classify record xdl 
copyright 	malloc memset 
notice list 	xdl malloc xdl 
conditions following 	malloc xdl 
disclaimer redistributions 	free xdl free 
binary form 	xdl free 
must reproduce 	xdl free xdl 
copyright 	free xdl 
notice list 	cha free 
conditions following 	xdl free xdl 
disclaimer documentation 	free xdl 
materials provided 	free xdl free 
distribution neither 	xdl free 
name 	xdl cha free 
redis names 	memset xdf 
contributors may 	diff alg xdl 
used endorse 	guess lines 
promote products 	xdl guess lines 
derived software 	xdf diff 
without 	alg xdl init 
specific prior 	classifier xdl 
written permission 	prepare ctx xdl 
software provided 	free classifier 
copyright holders 	xdl prepare ctx 
contributors express 	xdl free 
implied 	ctx xdl free 
warranties including 	classifier xdf 
limited implied 	diff alg 
warranties merchantability 	xdf diff alg 
fitness particular 	xdl optimize 
purpose disclaimed 	ctxs xdl free 
shall 	ctx xdl 
copyright owner 	free ctx xdl 
contributors liable 	free classifier 
direct indirect 	xdl free ctx 
incidental special 	xdl free 
exemplary 	ctx xdl malloc 
consequential damages 	memset xdl 
including limited 	bogosqrt xdl bogosqrt 
procurement substitute 	xdl clean 
goods services 	mmatch xdl clean 
loss use 	mmatch xdl 
data 	free xdl trim 
profits business 	ends xdl 
interruption however 	cleanup records 
caused theory 	lib diff davide 
liability whether 	libenzi file 
contract strict 	differential library copyright 
liability 	davide libenzi 
tort including 	library free software 
negligence otherwise 	redistribute modify 
arising way 	terms gnu lesser 
use software 	general license 
even advised 	published free software 
possibility 	foundation either 
damage expansion 	version license option 
needed stringification 	later version 
macro values 	library distributed hope 
zmalloc size 	useful without 
size ptr 	warranty without even 
size 	implied warranty 
ptr oom 	merchantability fitness particular 
handler rss 	purpose see 
field ptr 	gnu lesser 
ptr drop 	general license details 
replacement zmalloc 	received copy 
order 	gnu lesser general 
use libc 	license along 
malloc without 	library write free 
wrappering zmalloc 	software foundation 
total amount 	inc temple place 
allocated memory 	suite boston 
aware 	usa davide libenzi 
version malloc 	davidel xmailserver 
copyright salvatore 	histogram diff afford 
sanfilippo antirez 	smaller sample 
gmail dot 	size thus poorer 
rights reserved 	estimate number 
redistribution 	lines hash table 
use source 	rhash won 
binary forms 	filled grown number 
without modification 	lines nrecs 
permitted provided 	updated correctly 
following conditions 	anyway xdl prepare 
met 	ctx limits 
redistributions source 	window examined similar 
code must 	lines scan 
retain copyright 	loops stops dis 
notice list 	line match 
conditions following 	corner cases loop 
disclaimer 	proceed way 
redistributions binary 	extremities causing huge 
form must 	performance penalties 
reproduce copyright 	big files scans 
notice list 	lines find 
conditions following 	run lines either 
disclaimer 	match dis 
documentation materials 	multiple matches dis 
provided distribution 	note always 
neither name 	call function dis 
redis names 	current line 
contributors may 	already multimatch 
used 	line run line 
endorse promote 	found multimatch 
products derived 	lines hence make 
software without 	current line 
specific prior 	discarded want discard 
written permission 	multimatch lines 
software 	appear middle runs 
provided copyright 	nomatch lines 
holders contributors 	dis run line 
express implied 	found multimatch 
warranties including 	lines hence make 
limited implied 	current line 
warranties 	discarded reduce problem 
merchantability fitness 	complexity discard 
particular purpose 	records matches file 
disclaimed shall 	also lines 
copyright owner 	multiple matches 
contributors liable 	might potentially discarded 
direct 	happear run 
indirect incidental 	discardable early trim 
special exemplary 	initial terminal 
consequential damages 	matching records xprepare.h 
including limited 	xpp lib 
procurement substitute 	diff davide libenzi 
goods 	file differential 
services loss 	library copyright davide 
use data 	libenzi library 
profits business 	free software redistribute 
interruption however 	modify terms 
caused theory 	gnu lesser general 
liability 	license published 
whether contract 	free software foundation 
strict liability 	either version 
tort including 	license option later 
negligence otherwise 	version library 
arising way 	distributed hope 
use 	useful without warranty 
software even 	without even 
advised possibility 	implied warranty merchantability 
damage expansion 	fitness particular 
needed stringification 	purpose see gnu 
macro values 	lesser general 
zmalloc 	license details received 
zmalloc.h drop 	copy gnu 
replacement zmalloc 	lesser general license 
order use 	along library 
libc malloc 	write free software 
without wrappering 	foundation inc 
zmalloc 	temple place suite 
total amount 	boston usa 
allocated memory 	davide libenzi davidel 
aware version 	xmailserver defined 
malloc copyright 	xprepare xtypes.h lib 
salvatore sanfilippo 	diff davide 
antirez 	libenzi file 
gmail dot 	differential library copyright 
rights reserved 	davide libenzi 
redistribution use 	library free software 
source binary 	redistribute modify 
forms without 	terms gnu lesser 
modification 	general license 
permitted provided 	published free software 
following conditions 	foundation either 
met redistributions 	version license option 
source code 	later version 
must retain 	library distributed hope 
copyright 	useful without 
notice list 	warranty without even 
conditions following 	implied warranty 
disclaimer redistributions 	merchantability fitness particular 
binary form 	purpose see 
must reproduce 	gnu lesser general 
copyright 	license details 
notice list 	received copy 
conditions following 	gnu lesser general 
disclaimer documentation 	license along 
materials provided 	library write free 
distribution neither 	software foundation 
name 	inc temple place 
redis names 	suite boston 
contributors may 	usa davide libenzi 
used endorse 	davidel xmailserver 
promote products 	defined xtypes xutils.c 
derived software 	rec size 
without 	pre psize ecb 
specific prior 	mmf size 
written permission 	mmf cha isize 
software provided 	icount cha 
copyright holders 	cur tmp cha 
contributors express 	ancur data 
implied 	sample size 
warranties including 	tsize data cur 
limited implied 	top line 
warranties merchantability 	size flags flags 
fitness particular 	data top 
purpose disclaimed 	flags ptr ptr 
shall 	eol mask 
copyright owner 	data top flags 
contributors liable 	hash mask 
direct indirect 	ptr end data 
incidental special 	top flags 
exemplary consequential 	ptr size bits 
damages 	val ptr 
including limited 	str buf func 
procurement substitute 	funclen ecb 
goods services 	buf diff env 
loss use 	xpp line 
data profits 	count line count 
business 	subfile subfile 
interruption however 	env strlen 
caused theory 	outf xdl free 
liability whether 	xdl malloc 
contract strict 	xdl mmfile first 
liability tort 	memchr xdl 
including 	mmfile size xdl 
negligence otherwise 	isspace memcmp 
arising way 	xdl isspace xdl 
use software 	isspace xdl 
even advised 	isspace xdl isspace 
possibility damage 	xdl isspace 
expansion 	xdl isspace xdl 
needed stringification 	isspace xdl 
macro values 	isspace xdl isspace 
zmalloc size 	xdl isspace 
size ptr 	repeat xdl hash 
size ptr 	record whitespace 
oom 	zero zero count 
handler rss 	masked bytes 
field ptr 	xdl hash 
ptr drop 	record whitespace memcpy 
replacement zmalloc 	xdl num 
order use 	memcpy xdl num 
libc 	memcpy xdl 
malloc without 	num memcpy xdl 
wrappering zmalloc 	num memcpy 
total amount 	memcpy outf xdl 
allocated memory 	diff memcpy 
aware version 	memcpy xdl free 
malloc 	env lib 
copyright salvatore 	diff davide libenzi 
sanfilippo antirez 	file differential 
gmail dot 	library copyright davide 
rights reserved 	libenzi library 
redistribution use 	free software redistribute 
source 	modify terms 
binary forms 	gnu lesser general 
without modification 	license published 
permitted provided 	free software 
following conditions 	foundation either version 
met redistributions 	license option 
source 	later version library 
code must 	distributed hope 
retain copyright 	useful without warranty 
notice list 	without even 
conditions following 	implied warranty merchantability 
disclaimer redistributions 	fitness particular 
binary 	purpose see gnu 
form must 	lesser general 
reproduce copyright 	license details received 
notice list 	copy gnu 
conditions following 	lesser general license 
disclaimer documentation 	along library 
materials 	write free software 
provided distribution 	foundation inc 
neither name 	temple place suite 
redis names 	boston usa 
contributors may 	davide libenzi 
used endorse 	davidel xmailserver classical 
promote 	integer square 
products derived 	root approximation shifts 
software without 	matches everything 
specific prior 	matches turn matches 
written permission 	everything matches 
software provided 	ignore space eol 
copyright 	flavor ignoring 
holders contributors 	needs different logic 
express implied 	skip whitespaces 
warranties including 	sides compare skip 
limited implied 	matching spaces 
warranties merchantability 	keep going running 
fitness 	one side 
particular purpose 	remaining side must 
disclaimed shall 	nothing whitespace 
copyright owner 	lines match 
contributors liable 	note ignore whitespace 
direct indirect 	eol may 
incidental 	loop still characters 
special exemplary 	remaining lines 
consequential damages 	already handled high 
including limited 	bit first 
procurement substitute 	zero jan achrenius 
goods services 	microoptimized version 
loss 	simpler mask onebytes 
use data 	onebytes works 
profits business 	bytemasks without mask 
interruption however 	first mask 
caused theory 	like avoids warnings 
liability whether 	bit machines 
contract 	carl chatfield jan 
strict liability 	achrenius version 
tort including 	bit ffff ffffff 
negligence otherwise 	fix bytes 
arising way 	word word 
use software 	left end buffer 
even 	may work 
advised possibility 	memory mapping grab 
damage expansion 	rest instead 
needed stringification 	blindly reading avoid 
macro values 	problems masking 
zmalloc zone.c 	use found word 
zone 	make mask 
zone introspect 	matches read mask 
zone ptr 	first high 
zone size 	bit advance past 
zone num 	last possibly 
size zone 	word xdl fast 
size 	hash xdl 
zone ptr 	fast hash probably 
zone ptr 	work outside 
size zone 	git since simple 
alignment size 	mmfile structure 
zone ptr 	note ideally 
size 	would reuse prepared 
zone zone 	environment libxdiff 
size zone 	yet allow diffing 
zone zone 	ranges lines 
ptr zone 	instead whole files 
size zone 	xutils.h rec 
num 	size pre psize 
size zone 	ecb cha 
size ret 	isize icount cha 
zone ptr 	cha sample 
zone ptr 	line size flags 
size zone 	flags data 
alignment 	top flags size 
size ret 	val func 
zone ptr 	funclen ecb diff 
size zone 	env xpp 
zone size 	line count line 
zone zone 	count lib 
zone 	diff davide 
purgeable zone 	libenzi file differential 
ivsalloc malloc 	library copyright 
calloc posix 	davide libenzi library 
memalign ivsalloc 	free software 
free free 	redistribute modify terms 
ivsalloc 	gnu lesser 
realloc realloc 	general license published 
posix memalign 	free software 
ivsalloc ivsalloc 	foundation either version 
free free 	license option 
reached jemalloc 	later version library 
prefork 	distributed hope 
jemalloc postfork 	useful without warranty 
parent malloc 	without even 
zone strcmp 	implied warranty merchantability 
malloc purgeable 	fitness particular 
zone malloc 	purpose see 
zone 	gnu lesser general 
malloc zone 	license details 
malloc zone 	received copy gnu 
malloc zone 	lesser general 
unregister malloc 	license along library 
zone malloc 	write free 
zone 	software foundation inc 
unregister malloc 	temple place 
zone malloc 	suite boston usa 
purgeable zone 	davide libenzi 
function available 	davidel xmailserver defined 
need check 	xutils zlib.c 
whether 	status len bytes 
present runtime 	consumed bytes 
thus weak 	produced strm status 
data function 	strm window 
prototypes non 	bits status strm 
functions functions 	status strm 
appear 	flush status 
places within 	strm size strm 
darwin setenv 	level status 
cause calls 	strm level window 
function pointers 	bits status 
zone owns 	strm level strm 
knew 	level strm 
pointers owned 	status strm status 
zone could 	strm status 
split zone 	strm flush status 
two parts 	zlib buf 
use one 	cap zlib buf 
allocator 	cap die 
deallocator reallocator 	die zlib pre 
since work 	call inflate 
practice must 	init zlib post 
check pointers 	call die 
assure reside 	zerr zlib pre 
within 	call inflate 
mapped chunk 	init zlib 
determining size 	post call die 
assignment avoids 	zerr zlib 
useless compiler 	pre call inflate 
warning assignment 	end zlib 
avoids 	post call error 
useless compiler 	zerr zlib 
warning function 	pre call inflate 
never called 	die zlib 
something replaced 	post call error 
system zone 	zerr deflate 
allocator 	bound memset zlib 
jemalloc purgeable 	pre call 
zone created 	deflate init zlib 
lazily osx 	post call 
libc uses 	die zerr memset 
zone created 	zlib pre 
small 	call deflate init 
allocations assumes 	zlib post 
zone scalable 	call die 
zone obviously 	zerr git deflate 
fails zone 	init git 
jemalloc zone 	deflate init zlib 
malloc 	pre call 
purgeable zone 	deflate end zlib 
called beforehand 	post call 
purgeable zone 	git deflate abort 
created zone 	error zerr 
still scalable 	zlib pre call 
zone 	deflate end 
purgeable zones 	zlib post call 
exist need 	zlib pre 
check existence 	call deflate die 
malloc purgeable 	zlib post 
zone run 	call error zerr 
time 	zlib wrappers 
custom zone 	make sure 
point won 	silently miss errors 
unregister reregister 	init time 
zone osx 	avail avail zlib 
unregistering takes 	counted typically 
last 	limits size buffer 
registered zone 	use interacting 
places location 	zlib single call 
specified zone 	inflate deflate 
unregistering zone 	define zlib buf 
thus makes 	max use 
last 	bits accept gzip 
registered one 	data error 
osx unregistering 	fed zlib format 
shifts registered 	never say 
zones first 	finish unless feeding 
registered zone 	everything zlib 
becomes 	work another round 
osx purgeable 	still make 
zone appear 	progress buf 
zone makes 	error normal needs 
things crash 	space output 
thinks owns 	buffer use bits 
zone 	generate gzip 
allocated pointers 	header trailer instead 
thus unregister 	zlib wrapper 
order ensure 	use bits negate 
always zone 	raw compressed 
osx purgeable 	data without zlib 
zone 	header trailer 
nothing osx 	never say finish 
unregistering replaces 	unless feeding 
purgeable zone 	everything zlib work 
last registered 	another round 
zone zone 	still make progress 
registering 	buf error 
puts end 	normal needs space 
obviously zone 	output buffer 
