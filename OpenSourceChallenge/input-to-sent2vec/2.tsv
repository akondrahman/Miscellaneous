abspath.c path 	adlist.c list 
path die error 	list len 
retval cwd 	current 
depth last elem 	next list 
last slash 	node list 
next len path 	node list 
path path 	old node 
pfx pfx len 	node list 
arg path 	node 
stat isdir die 	list direction 
strbuf reset 	iter iter 
strbuf addstr directory 	list list 
find last 	iter current 
dir sep xstrdup 	orig copy 
strbuf setlen 	iter 
xmemdupz strbuf reset 	node list 
strbuf getcwd 	key iter 
die errno chdir 	node list 
die errno 	index list 
strbuf getcwd 	tail zmalloc 
die errno dir 	free 
sep strbuf 	zfree zfree 
addch strbuf addstr 	zmalloc zmalloc 
free lstat 	zmalloc free 
islnk strbuf readlink 	zfree zmalloc 
die errno 	zfree list 
strbuf swap strbuf 	create 
release free 	list iterator 
chdir die errno 	list next 
strbuf release 	dup list 
real path real 	release list 
path strbuf 	release iterator 
reset strbuf absolute 	list 
path absolute 	node tail 
path strbuf reset 	list release 
strbuf strbuf 	list release 
addstr strbuf reset 	iterator list 
absolute path 	release iterator 
strbuf strbuf 	list 
addstr use inspecting 	iterator list 
tracked content 	next match 
path symlink directory 	list release 
want say 	iterator list 
directory dealing tracked 	release iterator 
content working 	list 
allow recursive symbolic 	release iterator 
links within 	list length 
reason though real 	adlist doubly 
path absolute 	linked list 
path symlinks resolved 	implementation copyright 
extra slashes 	salvatore 
removed equivalent specified 	sanfilippo antirez 
path want 	gmail dot 
absolute path mind 	rights reserved 
links use 	redistribution use 
absolute path 	source binary 
pointer buffer input 	forms 
intermediate paths 	without modification 
must shorter max 	permitted provided 
path directory 	following conditions 
part path everything 	met redistributions 
last dir 	source code 
sep must denote 	must 
valid existing 	retain copyright 
directory last component 	notice list 
need exist 	conditions following 
die error die 	disclaimer redistributions 
informative error 	binary form 
message problem otherwise 	must 
errors without 	reproduce copyright 
generating output path 	notice list 
buffer path 	conditions following 
already user wants 	disclaimer documentation 
temporarily chdir 	materials provided 
store original 	distribution 
cwd chdir back 	neither name 
end function 	redis names 
already done use 	contributors may 
absolute path 	used endorse 
relative one want 	promote products 
resolve links 	derived 
use real path 	software without 
unlike prefix 	specific prior 
path used named 	written permission 
file interact 	software provided 
index entry name 	copyright holders 
random file 	contributors 
filesystem prefix absolute 	express implied 
paths still 	warranties including 
replace add.c builtin 	limited implied 
usage patch 	warranties merchantability 
interactive interactive edit 	fitness particular 
interactive take 	purpose 
worktree changes 	disclaimed shall 
flags errors data 	copyright owner 
opt cbdata 	contributors liable 
data path prefix 	direct indirect 
pathspec flags 	incidental special 
data rev dir 	exemplary 
pathspec prefix 	consequential damages 
seen src dst 	including limited 
entry verbose 	procurement substitute 
pathspec seen revision 	goods services 
patch mode 	loss use 
pathspec status argv 	data 
argc argv 	profits business 
prefix patch pathspec 	interruption however 
argc argv 	caused theory 
prefix file apply 	liability whether 
argv child 	contract strict 
rev file ignore 	liability 
error verbose 	tort including 
show ignored 	negligence otherwise 
refresh ignore errors 	arising way 
intent ignore 	use software 
missing addremove addremove 	even advised 
opt arg 	possibility 
unset builtin options 	damage create 
dir flags 	list created 
exit status argc 	list freed 
argv prefix 	free list 
exit status pathspec 	every node 
dir flags 	need 
files require pathspec 	freed user 
seen baselen 	call free 
path dtype fix 	list error 
unmerged status 	returned otherwise 
die file index 	pointer list 
die file 	free 
index memset 	whole list 
init revisions setup 	function fail 
revisions copy 	node list 
pathspec run diff 	head containing 
files xcalloc 	specified pointer 
dir path match 	error 
pathspec matches 	returned operation 
index xcalloc refresh 	performed list 
index die 	remains unaltered 
free argv push 	success list 
argv push 	pointer pass 
argv push argv 	function 
push argv 	returned node 
push run command 	list tail 
opt argv 	containing specified 
clear parse pathspec 	pointer error 
run interactive 	returned operation 
git pathdup git 	performed 
config read 	list remains 
cache die 	unaltered success 
init revisions setup 	list pointer 
revisions diff 	pass function 
opt open die 	returned specified 
xfdopen run 	node 
diff files die 	specified list 
launch editor 	caller free 
die stat die 	node function 
errno die 	fail returns 
run command die 	list iterator 
unlink free 	iter 
strcmp strcmp git 	initialization every 
config git 	call list 
config file cache 	next next 
die git 	element list 
config parse options 	function fail 
exit interactive 	release 
edit patch die 	iterator memory 
die hold 	create iterator 
locked index 	list iterator 
read cache die 	structure next 
parse pathspec 	element iterator 
memset setup standard 	valid 
excludes fill 	currently returned 
directory prune directory 	element list 
refresh find 	del node 
pathspecs matching index 	elements function 
guard pathspec 	returns pointer 
file exists excluded 	next 
dir ignored 	element list 
die free plug 	elements classical 
bulk checkin 	usage patter 
files cache files 	iter list 
unplug bulk 	iterator list 
checkin write locked 	direction 
index die 	node list 
git builtin command 	next iter 
copyright linus 	something list 
torvalds request 	node node 
path missing working 	duplicate whole 
deleted either 	list 
request path exists 	memory returned 
working attempt 	success copy 
explicitly path exist 	original list 
working caught 	returned dup 
error caller immediately 	method list 
compare unmerged 	dup 
paths stage pass 	method function 
original pathspec 	used copy 
parsed diff options 	node otherwise 
unspecified told 	pointer original 
ignore adding removals 	node used 
takes arguments 	copied 
given turn git 	node original 
pathspec git 	list success 
pathspec check 	error never 
pathspec match files 	modified search 
block enabling 	list node 
magic git porcelain 	matching 
excludes picks 	given key 
paths tracked file 	match performed 
exists assumes 	match method 
exact match advice.c 	list match 
advice push 	method match 
update rejected advice 	method 
push non 	pointer every 
current advice push 	node directly 
non matching 	compared key 
advice push already 	pointer success 
exists advice 	first matching 
push fetch first 	node 
advice push 	pointer returned 
needs force advice 	search starts 
status hints 	head matching 
advice status 	node exists 
option advice commit 	returned element 
merge advice 	specified 
resolve conflict advice 	zero index 
identity advice 	head element 
detached head advice 	next head 
upstream failure 	negative integers 
advice name warning 	used order 
advice hints 	count 
name preference advice 	tail last 
buf name 	element penultimate 
fmt start strbuf 	index range 
vaddf end 	returned rotate 
strchrnul strbuf release 	list removing 
skip prefix 	tail 
size strcmp git 	node inserting 
config error 	head detach 
advise error resolve 	current tail 
conflict die 	move head 
error advise 	adlist.h list 
die make backward 	list 
compatibility message 	list list 
used git commit 	old node 
fails commands 	list node 
merge advice.h advice 	list direction 
push update 	iter iter 
rejected advice push 	orig 
non current 	list key 
advice push non 	list index 
matching advice 	list list 
push already exists 	list adlist 
advice push 	doubly linked 
fetch first advice 	list 
push needs 	implementation copyright 
force advice status 	salvatore sanfilippo 
hints advice 	antirez gmail 
status option advice 	dot rights 
commit merge 	reserved redistribution 
advice resolve 	use 
conflict advice identity 	source binary 
advice detached 	forms without 
head advice upstream 	modification permitted 
failure advice 	provided following 
name warning advice 	conditions met 
hints advice 	redistributions 
name advice alias.c 	source code 
key split 	must retain 
cmdline errors cmdline 	copyright notice 
argv src 	list conditions 
dst size quoted 	following disclaimer 
split cmdline 	redistributions 
errno strbuf addf 	binary form 
git config 	must reproduce 
key valid git 	copyright notice 
config strbuf 	list conditions 
release alloc isspace 	following disclaimer 
isspace alloc 	documentation 
grow free 	materials provided 
free alloc grow 	distribution neither 
split skip 	name redis 
alloc.c blob commit 	names contributors 
tag count 	may used 
node size ret 	endorse 
blob state 	promote products 
state tag state 	derived software 
state obj 	without specific 
commit state count 	prior written 
name count 	permission software 
size xmalloc memset 	provided 
alloc node 	copyright holders 
alloc node alloc 	contributors express 
node alloc 	implied warranties 
node alloc node 	including limited 
alloc commit 	implied warranties 
index report 	merchantability 
report report report 	fitness particular 
report alloc 	purpose disclaimed 
specialized allocator objects 	shall copyright 
copyright linus 	owner contributors 
torvalds standard malloc 	liable direct 
free wastes 	indirect 
much space objects 	incidental special 
partly maintains 	exemplary consequential 
allocation infrastructure isn 	damages including 
needed since 	limited procurement 
never free descriptor 	substitute goods 
anyway even 	services 
ends maximal alignment 	loss use 
doesn know 	data profits 
alignment allocation total 	business interruption 
number nodes 	however caused 
allocated number nodes 	theory liability 
left current 	whether 
allocation first 	contract strict 
free node current 	liability tort 
allocation alloca.h 	including negligence 
am.c filename msg 	otherwise arising 
str dir 	way use 
cur last author 	software 
name author 	even advised 
email author date 	possibility damage 
msg msg 	node list 
len orig commit 	iterator data 
prec interactive 	structures used 
threeway quiet signoff 	currently 
utf keep 	functions implemented 
message scissors git 	macros prototypes 
apply opts 	directions iterators 
resolvemsg committer date 	adlist ae.c 
author date 	setsize loop 
ignore date allow 	loop 
rerere autoupdate 	loop setsize 
sign commit 	loop loop 
rebasing state dir 	loop mask 
gpgsign state 	proc client 
state path state 	data loop 
name state 	mask 
name state name 	loop seconds 
state fmt 	milliseconds milliseconds 
state state file 	sec cur 
trim key 	sec cur 
str state filename 	sec loop 
state state 	milliseconds 
state filename state 	proc client 
state state 	data finalizer 
ret state hook 	proc loop 
ret state 	prev loop 
invalid line msg 	nearest loop 
ret obj 	processed 
obj header regex 	max sec 
regex ret 	retval loop 
paths state 	flags numevents 
paths keep last 	shortest tvp 
state paths 	sec mask 
keep stdin mail 	rfired 
ret keep 	mask milliseconds 
subject printed str 	pfd retval 
state paths 	loop loop 
keep series dir 	beforesleep zmalloc 
series dir 	zmalloc zmalloc 
buf patches ret 	time 
keep str 	api create 
timestamp end split 	zfree zfree 
mail setup 	zfree api 
state head state 	resize zrealloc 
file head 	zrealloc api 
opt state cmdline 	free 
mine state 	zfree zfree 
state mail 	zfree api 
msg author name 	api del 
author date 	gettimeofday time 
author email ret 	zmalloc milliseconds 
commit mail 	finalizer 
state commit buffer 	proc zfree 
ident line 	time time 
author date msg 	time proc 
ident len 	milliseconds time 
ident split state 	search nearest 
commit rev 	timer 
info state head 	time api 
rev info 	poll rfile 
state mail commit 	proc wfile 
commit sha 	proc process 
state index file 	time events 
state index 	memset 
file state orig 	poll beforesleep 
status state 	process events 
index path 	api name 
orig rev info 	simple driven 
diff filter 	programming library 
str state parent 	originally 
commit ptr 	wrote code 
parents reflog msg 	jim loop 
author state 	jim tcl 
state reply msg 	interpreter later 
pager state 	translated form 
resume argv mail 	library 
apply status 	easy reuse 
skip advice amworkdir 	copyright salvatore 
state head 	sanfilippo antirez 
remote reset file 	gmail dot 
opts file 	rights reserved 
opts head remote 	redistribution 
head remote 	use source 
index index merge 	binary forms 
state head 	without modification 
state abort 	permitted provided 
safety head state 	following conditions 
curr head 	met 
orig head curr 	redistributions source 
head orig 	code must 
head curr branch 	retain copyright 
opt arg 	notice list 
unset opt status 	conditions following 
argc argv 	disclaimer 
prefix state binary 	redistributions binary 
keep patch 	form must 
format progress usage 	reproduce copyright 
options paths 	notice list 
stat die errno 	conditions following 
strchrnul isspace 	disclaimer 
memset xstrdup git 	documentation materials 
config git 	provided distribution 
config argv init 	neither name 
git config 	redis names 
free free 	contributors may 
free free free 	used 
argv clear 	endorse promote 
mkpath write file 	products derived 
path write 	software without 
file path write 	specific prior 
state text 	written permission 
start vfprintf putc 	software 
end lstat 	provided copyright 
isdir lstat path 	holders contributors 
isreg lstat 	express implied 
path isreg strbuf 	warranties including 
reset strbuf 	limited 
read file path 	implied warranties 
strbuf trim 	merchantability fitness 
die errno path 	particular purpose 
strbuf getline 	disclaimed shall 
skip prefix 	copyright owner 
skip prefix strbuf 	contributors 
dequote strbuf 	liable direct 
detach strbuf release 	indirect incidental 
path fopen 	special exemplary 
die errno read 	consequential damages 
shell fclose 	including limited 
read shell fclose 	procurement 
read shell 	substitute goods 
fclose fgetc fclose 	services loss 
fclose strbuf 	use data 
addstr quote buf 	profits business 
strbuf addch 	interruption however 
strbuf addstr quote 	caused 
buf strbuf 	theory liability 
addch strbuf addstr 	whether contract 
quote buf 	strict liability 
strbuf addch write 	tort including 
state text 	negligence otherwise 
strbuf release 	arising 
read state file 	way use 
strbuf release 	software even 
strbuf detach path 	advised possibility 
xopen write 	damage include 
full die errno 	best multiplexing 
close read 	layer 
state file die 	supported system 
strtol read 	following ordered 
state file die 	performances events 
strtol read 	mask none 
author script die 	initialize vector 
read commit 	current 
msg read state 	size resize 
file hashclr 	maximum size 
sha hex die 	loop requested 
path read 	size smaller 
state file strcmp 	current size 
read state 	already 
file strcmp 	file descriptor 
read state file 	use requested 
strcmp read 	size minus 
state file strcmp 	one err 
read state 	returned operation 
file strcmp strcmp 	performed 
read state 	otherwise returned 
file strcmp read 	operation successful 
state file 	make sure 
strcmp strcmp read 	created slots 
state file 	initialized none 
argv clear dequote 	mask 
argv die 	update max 
path file exists 	specified found 
path strbuf 	search first 
release strbuf addstr 	timer fire 
dir recursively 	operation useful 
strbuf release run 	know 
hook path 	many time 
free read 	put sleep 
commit msg die 	without delay 
path find 	timers returned 
hook argv push 	note since 
argv push 	time 
xopen path run 	events unsorted 
command close 	possible optimizations 
init copy notes 	needed redis 
rewrite xfopen 	far insert 
path strbuf getline 	order nearest 
error sha 	head 
hex error error 	much better 
sha hex 	still insertion 
error copy note 	deletion timers 
rewrite error 	use skiplist 
sha hex sha 	operation insertion 
hex finish 	log 
copy notes rewrite 	process time 
fclose strbuf 	events system 
release fseek 	clock moved 
die errno regcomp 	future back 
die strbuf 	right time 
getline regexec regfree 	events 
strbuf release 	may delayed 
strcmp directory xfopen 	random way 
strbuf getline 	often means 
starts starts starts 	scheduled operations 
strcmp strbuf 	performed soon 
reset strbuf getline 	enough 
strbuf reset 	detect system 
strbuf getline starts 	clock skews 
starts starts 	force time 
mail fclose strbuf 	events processed 
release argv 	asap happens 
push argv pushf 	idea 
argv pushf 	processing events 
argv push 	earlier less 
argv push argv 	dangerous delaying 
push argv 	indefinitely practice 
pushv capture command 	suggests processed 
strtol strcmp 	time 
fopen error strerror 	list may 
mkpath fopen 	longer restart 
error strerror fclose 	head still 
fclose error 	make sure 
strbuf getline str 	process events 
isspace skip 	registered 
prefix starts starts 	handlers order 
strbuf reset 	loop forever 
strbuf fread fwrite 	saved max 
strbuf reset 	want handle 
strbuf release error 	future optimizations 
xstrdup dirname 	note 
fopen error strerror 	great algorithmically 
strbuf getline 	redis uses 
argv push 	single time 
mkpath fclose strbuf 	problem right 
release free 	way elements 
split mail conv 	head 
argv clear 	flag deleted 
strbuf getline skip 	elements special 
prefix skip 	way later 
prefix strtoul error 	deletion putting 
skip prefix 	references nodes 
error strtol error 	another 
error labs 	linked list 
labs show date 	process every 
date mode 	pending time 
starts strbuf reset 	every pending 
strbuf fread 	file may 
fwrite strbuf reset 	registered 
strbuf release 	time callbacks 
free free free 	processed without 
free unlink 	special flags 
path unlink 	function sleeps 
path hashclr unlink 	file fires 
path sha 	next 
write state text 	time occurs 
sha hex 	flags function 
write state text 	nothing returns 
write state 	flags events 
count strbuf reset 	kind events 
strbuf addf 	processed 
xcalloc hold locked 	flags file 
index refresh 	events file 
cache write locked 	events processed 
index die 	flags time 
sha diff setup 	events time 
diff opt 	events 
diff opt diff 	processed flags 
cache diffcore 	dont wait 
std strbuf addch 	function returns 
strbuf addstr 	asap events 
diff flush 	possible process 
diff opt tst 	without 
strbuf addch 	wait processed 
strbuf addstr exit 	function returns 
strbuf addf 	number events 
fmt name getenv 	processed nothing 
getenv strcmp 	asap note 
strstr strchr strbuf 	want 
addstr strbuf 	call even 
release strbuf attach 	file events 
signoff strbuf 	process want 
detach setup mailinfo 	process time 
commit output 	events order 
encoding die die 	sleep 
fopen die 	next time 
fopen path die 	ready fire 
mailinfo path 	calculate time 
path die 	missing nearest 
fclose fclose xfopen 	timer fire 
path strbuf 	check 
getline skip prefix 	events need 
strbuf addch 	asap dont 
strbuf addstr skip 	wait need 
prefix strbuf 	timeout zero 
addstr skip prefix 	otherwise block 
strbuf addstr 	wait 
skip prefix strbuf 	forever note 
addstr fclose 	mask mask 
strcmp empty file 	code maybe 
path die 	already processed 
user resolve strbuf 	removed element 
addstr strbuf 	fired 
addbuf strbuf stripspace 	still didn 
signoff strbuf 	processed check 
detach strbuf detach 	still valid 
strbuf detach 	check time 
strbuf detach 	events number 
strbuf release strbuf 	processed 
release strbuf 	file time 
release strbuf release 	events wait 
strbuf release 	milliseconds given 
clear mailinfo xfopen 	file descriptor 
strbuf getline 	becomes writable 
skip prefix sha 	readable 
hex strbuf 	ae.h privdata 
release fclose logmsg 	mask privdata 
reencode commit 	mask privdata 
output encoding find 	loop privdata 
commit header 	loop privdata 
split ident line 	loop 
strbuf die 	privdata loop 
strbuf strbuf detach 	privdata loop 
xstrdup strbuf 	redis handle 
strbuf detach xstrdup 	read redis 
show ident 	handle write 
date date 	create 
mode strbuf addstr 	file file 
strbuf detach 	create file 
strstr die oid 	file redis 
hex xstrdup 	del read 
strlen xfopen path 	redis del 
init revisions 	write 
diff opt diff 	free malloc 
opt pending 	copyright pieter 
diff setup done 	noordhuis pcnoordhuis 
log commit 	gmail dot 
sha lookup lookup 	rights reserved 
xfopen path 	redistribution 
init revisions pending 	use source 
diff setup 	binary forms 
done run diff 	without modification 
index mail 	permitted provided 
commit sha die 	following conditions 
lookup commit 	met 
die commit 	redistributions source 
info write commit 	code must 
patch hashcpy 	retain copyright 
write state text 	notice list 
sha hex 	conditions following 
argv pushf argv 	disclaimer 
push argv 	redistributions binary 
pushv argv push 	form must 
argv push 	reproduce copyright 
argv push path 	notice list 
run command 	conditions following 
discard cache read 	disclaimer 
cache index 	documentation materials 
file argv push 	provided distribution 
argv pushv 	neither name 
argv pushf argv 	redis names 
push path 	contributors may 
run command 	used 
argv pushf sha 	endorse promote 
hex linelen 	products derived 
argv push argv 	software without 
push argv 	specific prior 
push sha hex 	written permission 
argv push 	software 
argv push sha 	provided copyright 
hex argv 	holders contributors 
push sha hex 	express implied 
run command 	warranties including 
discard cache read 	limited implied 
cache sha 	warranties 
hashcpy build fake 	merchantability fitness 
ancestor error 	particular purpose 
discard cache read 	disclaimed shall 
cache write 	copyright owner 
index error say 	contributors liable 
init revisions 	direct 
diff opt 	indirect incidental 
parse pending sha 	special exemplary 
diff setup 	consequential damages 
done run diff 	including limited 
index run 	procurement substitute 
apply error write 	goods 
index error 	services loss 
say discard cache 	use data 
read cache 	profits business 
run fallback merge 	interruption however 
recursive rerere 	caused theory 
error run hook 	liability 
exit write 	whether contract 
cache die sha 	strict liability 
commit commit 	tort including 
list insert lookup 	negligence otherwise 
commit say 	arising way 
fmt ident setenv 	use 
commit die 	software even 
getenv strbuf 	advised possibility 
addf linelen update 	damage nothing 
xfopen path 	attached something 
sha sha hex 	already attached 
sha hex 	create 
fclose run hook 	container context 
strbuf release 	events functions 
die path die 	start stop 
path isatty 	listening events 
die puts puts 	simple driven 
puts git 	programming 
prompt launch editor 	library originally 
path free 	wrote code 
strbuf detach strbuf 	jim loop 
release git 	jim tcl 
pager prepare pager 	interpreter later 
args argv 	translated 
push path run 	form library 
command unlink 	easy reuse 
path refresh 	copyright salvatore 
write cache index 	sanfilippo antirez 
changes write 	gmail dot 
state die strbuf 	rights 
release path 	reserved redistribution 
msgnum file exists 	use source 
validate resume 	binary forms 
state parse mail 	without modification 
rebase parse 	permitted provided 
mail write author 	following 
script write 	conditions met 
commit msg interactive 	redistributions source 
run applypatch 	code must 
msg hook exit 	retain copyright 
say linelen 	notice list 
run apply strbuf 	conditions 
addstr path 	following disclaimer 
fall back threeway 	redistributions binary 
strbuf release 	form must 
index changes 	reproduce copyright 
say msgnum linelen 	notice list 
git config 	conditions 
path die user 	following disclaimer 
resolve commit 	documentation materials 
next load empty 	provided distribution 
file path 	neither name 
copy notes rebase 	redis names 
run post 	contributors 
rewrite hook destroy 	may used 
close packs 	endorse promote 
run command opt 	products derived 
validate resume 	software without 
state say linelen 	specific prior 
index changes 	written 
die user resolve 	permission software 
unmerged cache 	provided copyright 
die user 	holders contributors 
resolve write index 	express implied 
patch interactive 	warranties including 
rerere commit next 	limited 
load run 	implied warranties 
parse parse xcalloc 	merchantability fitness 
hold locked 	particular purpose 
index refresh cache 	disclaimed shall 
memset init 	copyright owner 
desc init desc 	contributors 
unpack trees 	liable direct 
rollback file write 	indirect incidental 
locked index 	special exemplary 
die parse xcalloc 	consequential damages 
hold locked 	including limited 
index memset init 	procurement 
desc unpack 	substitute goods 
trees rollback file 	services loss 
write locked 	use data 
index die 	profits business 
parse indirect error 	interruption however 
sha hex 	caused 
parse indirect error 	theory liability 
sha hex 	whether contract 
read cache unmerged 	strict liability 
fast forward 	tort including 
write cache parse 	negligence otherwise 
indirect error 	arising 
sha hex fast 	way use 
forward merge 	software even 
branch state rerere 	advised possibility 
clear list 	damage macros 
clear rerere clear 	types data 
sha hashcpy 	structures 
clean index die 	file structure 
next load 	one readable 
run file exists 	writable time 
path read 	structure time 
state file 	seconds milliseconds 
sha hex die 	fired 
path hashclr 	state program 
sha hashclr hashcmp 	highest file 
error safe 	descriptor currently 
abort destroy rerere 	registered max 
clear resolve 	number file 
refdup sha hashcpy 	descriptors 
sha hashcpy 	tracked used 
clean index update 	detect system 
free destroy 	clock skew 
strcmp strcmp strcmp 	registered events 
strcmp error 	fired events 
git gpg config 	used 
git config 	polling api 
git config state 	specific data 
init git 	prototypes setsize 
path progress load 	loop loop 
parse options 	loop mask 
git committer 	proc 
info read index 	client data 
preload die 	loop mask 
isatty die append 	loop loop 
signoff file 	milliseconds proc 
exists destroy state 	client data 
release die 	finalizer 
die absolute path 	proc loop 
argv push 	loop flags 
argv push mkpath 	mask milliseconds 
setup argv 	loop loop 
clear run run 	beforesleep loop 
resolve skip 	loop 
abort die state 	setsize copyright 
release builtin 	pieter noordhuis 
git git junio 	pcnoordhuis gmail 
hamano returns 	dot rights 
file empty 	reserved redistribution 
exist otherwise returns 	use 
length first 	source binary 
line msg returns 	forms without 
str consists 	modification permitted 
whitespace otherwise pass 	provided following 
flag git 	conditions met 
mailinfo pass flag 	redistributions 
git mailinfo 	source code 
pass scissors git 	must retain 
mailinfo pass 	copyright notice 
scissors git mailinfo 	list conditions 
signoff command 	following disclaimer 
line state directory 	redistributions 
path current 	binary form 
last patch numbers 	must reproduce 
indexed commit 	copyright notice 
metadata message rebasing 	list conditions 
records original 	following 
commit patch 	disclaimer documentation 
came number digits 	materials provided 
patch filename 	distribution neither 
various operating modes 	name redis 
command line 	names contributors 
options signoff type 	may 
keep type 	used endorse 
scissors type initializes 	promote products 
state values 	derived software 
state directory dir 	without specific 
releases memory 	prior written 
allocated state returns 	permission 
path relative 	software provided 
state directory convenience 	copyright holders 
call write 	contributors express 
file state quiet 	implied warranties 
calls fmt 	including limited 
appends newline end 	implied 
returns session 	warranties merchantability 
progress otherwise 	fitness particular 
reads contents file 	purpose disclaimed 
state directory 	shall copyright 
returns number bytes 	owner contributors 
read success 	liable 
file exist trim 	direct indirect 
trailing whitespace 	incidental special 
removed reads key 	exemplary consequential 
shell variable 	damages including 
assignment returning newly 	limited procurement 
allocated must 	substitute 
quoted key must 	goods services 
match key 	loss use 
returns failure used 	data profits 
read author 	business interruption 
script read git 	however caused 
author variables 	theory 
author script reads 	liability whether 
parses state 	contract strict 
directory author 	liability tort 
script file sets 	including negligence 
state author 	otherwise arising 
name state author 	way 
email state 	use software 
author date accordingly 	even advised 
returns success 	possibility damage 
file could parsed 	nothing attached 
author script 	something already 
format git author 	attached 
name author 	create container 
name git author 	context events 
email author 	functions start 
email git author 	stop listening 
date author 	events simple 
date author name 	driven 
author email 	programming library 
author date 	originally wrote 
quoted strict parsing 	code jim 
file meant 	loop jim 
eval old git 	tcl interpreter 
script thus 	later 
file differs function 	translated form 
expects better 	library easy 
bail something user 	reuse copyright 
expect saves 	salvatore sanfilippo 
state author name 	antirez gmail 
state author 	dot 
email state author 	rights reserved 
date state 	redistribution use 
directory author script 	source binary 
file reads 	forms without 
commit message state 	modification permitted 
directory commit 	provided 
file setting state 	following conditions 
msg contents 	met redistributions 
state msg 	source code 
len length contents 	must retain 
bytes returns 	copyright notice 
success file exist 	list 
saves state 	conditions following 
msg state directory 	disclaimer redistributions 
commit file 	binary form 
loads state disk 	must reproduce 
removes state 	copyright notice 
directory forcefully terminating 	list 
current session 	conditions following 
runs applypatch msg 	disclaimer documentation 
hook returns 	materials provided 
exit code runs 	distribution neither 
post rewrite 	name redis 
hook returns exit 	names 
code reads 	contributors may 
state directory rewritten 	used endorse 
file copies 	promote products 
notes old 	derived software 
commits listed file 	without specific 
rewritten commits 	prior 
returns success failure 	written permission 
determines file 	software provided 
looks like piece 	copyright holders 
rfc mail 	contributors express 
grabbing non indented 	implied warranties 
lines checking 	including 
look like begin 	limited implied 
valid header 	warranties merchantability 
field names returns 	fitness particular 
file looks 	purpose disclaimed 
like piece mail 	shall copyright 
otherwise end 	owner 
header ignore indented 	contributors liable 
folded lines 	direct indirect 
header matches header 	incidental special 
regex attempts 	exemplary consequential 
detect patch 	damages including 
format patches contained 	limited 
paths returning 	procurement substitute 
patch format returns 	goods services 
patch format 	loss use 
unknown detection fails 	data profits 
mbox format 	business interruption 
input stdin directories 	however 
otherwise check 	caused theory 
first lines first 	liability whether 
patch starting 	contract strict 
first non blank 	liability tort 
line detect 	including negligence 
format second line 	otherwise 
empty third 	arising way 
author date entry 	use software 
likely git 	even advised 
patch splits individual 	possibility damage 
email patches 	macros types 
paths path 	data 
either mbox file 	structures file 
maildir returns 	structure one 
success failure callback 	readable writable 
signature split 	time structure 
mail conv foreign 	time seconds 
patch read 	milliseconds 
converted patch rfc 	fired state 
mail format 	program highest 
written success failure 	file descriptor 
calls file 	currently registered 
paths convert foreign 	max number 
patch rfc 	file 
mail format suitable 	descriptors tracked 
parsing git 	used detect 
mailinfo returns success 	system clock 
failure split 	skew registered 
mail conv 	events fired 
callback converts git 	events 
patch rfc 	used polling 
message suitable parsing 	api specific 
git mailinfo 	data prototypes 
function supports single 	ae.h privdata 
git series 	mask privdata 
file paths given 	mask 
git series 	privdata loop 
file converts git 	privdata loop 
patches series 	privdata loop 
rfc messages suitable 	privdata loop 
parsing git 	privdata loop 
mailinfo queues state 	redis 
directory returns 	handle read 
success failure skip 	redis handle 
comment lines 	write create 
split patches conv 	file file 
callback converts 	create file 
mercurial patch 	file 
rfc message suitable 	redis del 
parsing git 	read redis 
mailinfo mercurial timezone 	del write 
seconds west 	free malloc 
utc however git 	copyright pieter 
timezone hours 	noordhuis 
minutes east utc 	pcnoordhuis gmail 
convert splits 	dot rights 
list files directories 	reserved redistribution 
individual email 	use source 
patches path paths 	binary forms 
must file 	without 
directory formatted according 	modification permitted 
patch format 	provided following 
split individual email 	conditions met 
patches stored 	redistributions source 
state directory patch 	code must 
filename index 	retain 
padded state 	copyright notice 
prec digits state 	list conditions 
cur index 	following disclaimer 
first mail state 	redistributions binary 
last index 	form must 
last mail keep 	reproduce 
convert lines 	copyright notice 
ending end disable 	list conditions 
behavior use 	following disclaimer 
configured setting returns 	documentation materials 
success failure 	provided distribution 
setup session applying 	neither 
patches note 	name redis 
since next last 	names contributors 
files determine 	may used 
state session progress 	endorse promote 
written last 	products derived 
increments patch pointer 	software 
cleans state 	without specific 
application next 	prior written 
patch returns filename 	permission software 
current patch 	provided copyright 
email refresh write 	holders contributors 
index returns 	express 
index differs head 	implied warranties 
otherwise unborn 	including limited 
branch returns entries 	implied warranties 
index otherwise 	merchantability fitness 
strbuf provided space 	particular purpose 
separated list 	disclaimed 
files differ appended 	shall copyright 
dies user 	owner contributors 
friendly message proceed 	liable direct 
resolving problem 	indirect incidental 
message overridden state 	special exemplary 
resolvemsg end 	consequential 
sign need 	damages including 
duplicate text appends 	limited procurement 
signoff msg 	substitute goods 
field state parses 	services loss 
mail git 	use data 
mailinfo extracting patch 	profits 
authorship info 	business interruption 
state msg patch 	however caused 
message state 	theory liability 
author name state 	whether contract 
author email 	strict liability 
state author date 	tort 
patch author 	including negligence 
name email date 	otherwise arising 
respectively patch 	way use 
body written state 	software even 
directory patch 	advised possibility 
file returns patch 	damage 
skipped otherwise 	nothing attached 
extract message 	something already 
author information skip 	attached create 
pine folder 	container context 
data sets commit 	events functions 
commit hash 	start 
mail generated returns 	stop listening 
success failure 	events simple 
sets state msg 	driven programming 
state author 	library originally 
name state author 	wrote code 
email state 	jim 
author date commit 	loop jim 
respective info 	tcl interpreter 
writes commit patch 	later translated 
state directory 	form library 
patch file writes 	easy reuse 
diff index 	copyright 
head patch state 	salvatore sanfilippo 
directory patch 	antirez gmail 
file like 	dot rights 
parse mail parses 	reserved redistribution 
mail looking 	use source 
commit directly used 	binary 
rebasing mode 	forms without 
bypass git mailinfo 	modification permitted 
munging patches 	provided following 
state orig commit 	conditions met 
original commit 	redistributions source 
always patch never 	code 
skipped applies 	must retain 
current patch git 	copyright notice 
apply returns 	list conditions 
success otherwise index 	following disclaimer 
file patch 	redistributions binary 
applied index allowed 	form 
fall back 	must reproduce 
way merge give 	copyright notice 
errors initial 	list conditions 
attempt reload 	following disclaimer 
index git apply 	documentation materials 
modified builds 	provided 
index contains blobs 	distribution neither 
needed way 	name redis 
merge three way 	names contributors 
merge fake 	may used 
ancestor constructed fake 	endorse promote 
ancestor postimage 	products 
patch state attempt 	derived software 
threeway merge 	without specific 
index path temporary 	prior written 
index list 	permission software 
paths needed way 	provided copyright 
fallback user 	holders 
review extra care 	contributors express 
spot mismerges 	implied warranties 
wrong depending 	including limited 
picked orig may 	implied warranties 
wildly different 	merchantability fitness 
wildly different changes 	particular 
parts patch 	purpose disclaimed 
touch recursive ends 	shall copyright 
canceling saying 	owner contributors 
reverted changes commits 	liable direct 
current index 	indirect incidental 
state msg commit 	special 
message state 	exemplary consequential 
author name state 	damages including 
author email 	limited procurement 
state author date 	substitute goods 
author information 	services loss 
validates state resuming 	use 
msg authorship 	data profits 
fields must filled 	business interruption 
interactively prompt 	however caused 
user whether 	theory liability 
current patch applied 	whether contract 
returns user 	strict 
chooses apply patch 	liability tort 
user chooses 	including negligence 
skip translators make 	otherwise arising 
sure include 	way use 
translation program accept 	software even 
english input 	advised 
point applies queued 	possibility damage 
mail resume 	macros types 
resuming msg authorship 	data structures 
fields well 	file structure 
state directory patch 	one readable 
file used 	writable 
applying patch committing 	time structure 
mail skipped 	time seconds 
applying patch earlier 	milliseconds fired 
merging result 	state program 
may produced 	highest file 
rebasing mode caller 	descriptor 
take care 	currently registered 
housekeeping resume current 	max number 
session patch 	file descriptors 
application failure user 	tracked used 
hard work 	detect system 
patch application trust 	clock 
commit user 	skew registered 
index working performs 	events fired 
checkout fast 	events used 
forward head remote 	polling api 
reset unmerged 	specific data 
entries discarded returns 	prototypes 
success failure 	setsize loop 
merges index index 	loop loop 
stat info 	mask proc 
take precedence merged 	client data 
returns success 	loop mask 
failure clean 	loop 
index without touching 	loop milliseconds 
entries modified 	proc client 
head remote resets 	data finalizer 
rerere merge 	proc loop 
resolution metadata resume 	loop flags 
current session 	mask 
skipping current patch 	milliseconds loop 
returns safe 	loop beforesleep 
reset head orig 	loop loop 
head otherwise 	setsize copyright 
safe reset head 	pieter noordhuis 
git previously 	pcnoordhuis 
failed index dirty 	gmail dot 
head moved 	rights reserved 
since git previously 	redistribution use 
failed aborts 	source binary 
current session safe 	forms without 
parse options 	modification 
callback validates 	permitted provided 
sets opt patch 	following conditions 
format corresponding 	met redistributions 
arg ensure valid 	source code 
committer ident 	must retain 
constructed user error 	copyright 
feed patches 	notice list 
session progress mbox 	conditions following 
path provided 	disclaimer redistributions 
command line stdin 	binary form 
tty user 	must reproduce 
trying feed patch 	copyright 
standard input 	notice list 
somewhat unreliable stdin 	conditions following 
could dev 	disclaimer documentation 
example caller intend 	materials provided 
feed patch 	distribution neither 
wanted unattended 	name 
handle stray state 	redis names 
directory independent 	contributors may 
run rebasing caller 	used endorse 
take care 	promote products 
stray directories annotate.c 	derived software 
argc argv 	without 
prefix args argv 	specific prior 
pushl argv 	written permission 
push cmd blame 	software provided 
git annotate 	copyright holders 
builtin copyright ryan 	contributors express 
anderson apple-common-crypto.h 	implied 
inlen err encoder 	warranties including 
input output 	limited implied 
length inlen err 	warranties merchantability 
decoder input 	fitness particular 
output length sec 	purpose disclaimed 
encode transform 	shall 
create git 	copyright owner 
error check data 	contributors liable 
create sec 	direct indirect 
transform attribute git 	incidental special 
error check 	exemplary consequential 
sec transform execute 	damages 
git error 	including limited 
check data length 	procurement substitute 
data bytes 	goods services 
range make release 	loss use 
release release 	data profits 
strlen sec decode 	business 
transform create 	interruption however 
git error check 	caused theory 
data create 	liability whether 
sec transform attribute 	contract strict 
git error 	liability tort 
check sec transform 	including 
execute git 	negligence otherwise 
error check 	arising way 
data length data 	use software 
bytes range 	even advised 
make release release 	possibility damage 
release strlen 	nothing 
suppress inclusion conflicting 	attached something 
openssl functions 	already attached 
apple type conflicts 	create container 
config apple 	context events 
lion newer apply.c 	functions 
prefix prefix 	start stop 
length newfd unidiff 	listening events 
zero known 	simple driven 
check index update 	programming library 
index cached 	originally wrote 
diffstat numstat summary 	code 
check apply 	jim loop 
apply reverse apply 	jim tcl 
reject apply 	interpreter later 
verbosely allow 	translated form 
overlap threeway paths 	library easy 
fake ancestor 	reuse 
line termination context 	copyright salvatore 
apply usage 	sanfilippo antirez 
whitespace error squelch 	gmail dot 
whitespace errors 	rights reserved 
applied fixing patch 	redistribution use 
input file 	source 
root read stdin 	binary forms 
options option 	without modification 
option whitespace option 	permitted provided 
max change 	following conditions 
max len linenr 	met redistributions 
leading trailing 	source 
oldpos oldlines newpos 	code must 
newlines patch 	retain copyright 
size linenr 	notice list 
next name old 	conditions following 
name def 	disclaimer redistributions 
name old mode 	binary 
mode rejected 	form must 
rule lines added 	reproduce copyright 
lines deleted 	notice list 
score fragments result 	conditions following 
resultsize old 	disclaimer documentation 
sha prefix sha 	materials 
prefix next 	provided distribution 
threeway stage list 	neither name 
next patch 	redis names 
list next len 	contributors may 
buf len 	used endorse 
alloc line allocated 	promote 
line table 	products derived 
len last last 	software without 
result img 	specific prior 
bol len 	written permission 
flag image buf 	software provided 
len prepare 	copyright 
linetable next image 	holders contributors 
output fmt 	express implied 
patch buffer size 	warranties including 
len str 	limited implied 
name namelen terminate 	warranties merchantability 
name line 	fitness 
def name line 	particular purpose 
len line 	disclaimed shall 
len line len 	copyright owner 
date line 	contributors liable 
len time line 	direct indirect 
len line 	incidental 
len line len 	special exemplary 
end line 	consequential damages 
def end terminate 	including limited 
len start 	procurement substitute 
deflen ret 	goods services 
line def terminate 	loss 
name line 	use data 
def len date 	profits business 
len name 	interruption however 
cnt nameline name 	caused theory 
val nameline 	liability whether 
stamp regexp colon 	contract 
stamp zoneoffset 	strict liability 
hourminute status first 	tort including 
second patch 	negligence otherwise 
name first name 	arising way 
line patch 	use software 
line isnull orig 	even 
name side 	advised possibility 
len name another 	damage macros 
line patch 	types data 
orig line patch 	structures file 
orig line 	structure one 
patch line 	readable 
patch line patch 	writable time 
line patch 	structure time 
line patch line 	seconds milliseconds 
patch line 	fired state 
patch line patch 	program highest 
line patch 	file 
val line patch 	descriptor currently 
val line 	registered max 
patch ptr eol 	number file 
len line 	descriptors tracked 
patch line llen 	used detect 
nslash line 	system 
llen name second 	clock skew 
len line 	registered events 
len first line 	fired events 
len size 	used polling 
patch offset 	api specific 
str patch oplen 	data 
line ptr 	prototypes ae 
line len offset 	epollc loop 
expect digits 	state loop 
line size fragment 	setsize state 
ret len 	loop state 
line len fragment 	loop 
offset line 	mask state 
size hdrsize patch 	loop delmask 
offset len 	state mask 
nextlen dummy git 	loop tvp 
hdr len 	state retval 
result line len 	numevents 
linenr err 	mask zmalloc 
line len rule 	zmalloc zfree 
result line 	epoll create 
size patch fragment 	zfree zfree 
added deleted 	zrealloc close 
offset oldlines 	zfree 
newlines leading trailing 	zfree epoll 
line size 	ctl epoll 
patch offset context 	ctl epoll 
fragp fragment 	ctl epoll 
len patch data 	wait linux 
size inflated 	epoll 
size stream buf 	module copyright 
status used 	salvatore sanfilippo 
llen used size 	antirez gmail 
buffer patch 	dot rights 
method origlen data 	reserved redistribution 
hunk size 	use 
frag length max 	source binary 
length newsize 	forms without 
buffer size patch 	modification permitted 
forward reverse 	provided following 
status used used 	conditions met 
name old 	redistributions 
name limit 	source code 
name include name 	must retain 
exclude pathname 	copyright notice 
pathlen buffer size 	list conditions 
patch hdrsize 	following disclaimer 
patchsize offset git 	redistributions 
binary llen 	binary form 
used binhdr len 	must reproduce 
frag pluses 	copyright notice 
minuses patch qname 	list conditions 
max del 	following disclaimer 
total path buf 	documentation 
preimage postimage 	materials provided 
buf len postlen 	distribution neither 
ctx reduced 	name redis 
old preimage len 	names contributors 
img preimage 	may used 
postimage lno rule 	endorse 
match beginning 	promote products 
match end 	derived software 
buf buf orig 	without specific 
target len 	prior written 
postlen preimage limit 	permission software 
buf end 	provided 
imgoff preoff postlen 	copyright holders 
extra chars 	contributors express 
preimage eof preimage 	implied warranties 
end prelen 	including limited 
imglen oldlen tgtlen 	implied warranties 
fixstart tgtfix 	merchantability 
match fixstart oldlen 	fitness particular 
img preimage 	purpose disclaimed 
postimage line rule 	shall copyright 
match beginning 	owner contributors 
match end backwards 	liable direct 
forwards backwards 	indirect 
lno forwards lno 	incidental special 
lno img 	exemplary consequential 
img img 	damages including 
applied pos preimage 	limited procurement 
postimage count 	substitute goods 
insert count applied 	services 
result preimage 	loss use 
limit img frag 	data profits 
inaccurate eof 	business interruption 
rule nth fragment 	however caused 
match beginning 	theory liability 
match end patch 	whether 
size old 	contract strict 
oldlines newlines blank 	liability tort 
lines end 	including negligence 
found blank lines 	otherwise arising 
end hunk 	way use 
linenr leading trailing 	software 
pos applied 	even advised 
pos preimage 	possibility damage 
postimage first len 	hint kernel 
plen added 	already monitored 
blank line blank 	need mod 
context start 	operation 
offset img patch 	otherwise need 
fragment len 	operation merge 
dst img patch 	old events 
name sha 	avoid valgrind 
size result img 	warning avoid 
patch frag 	valgrind 
name rule inaccurate 	warning note 
eof nth 	kernel requires 
buf sha mode 	non pointer 
result buf 	even epoll 
name item patch 	ctl del 
patch patch 	ae 
item patch item 	evportc evport 
istate costate 	debug loop 
patch gone 	state loop 
previous buf name 	setsize loop 
expected mode 	state state 
image patch buf 	portfd 
len img 	mask events 
previous status image 	err loop 
path file 	mask state 
file file result 	fullmask pfd 
status image 	loop mask 
patch buf status 	state 
pos len 	fullmask pfd 
img name mode 	loop tvp 
image patch 	state timeout 
pre sha post 	tsp mask 
sha sha 	nevents zmalloc 
buf len status 	port 
img tmp 	create zfree 
image patch image 	close zfree 
patch old 	port associate 
name previous 	strerror strerror 
status mode pos 	api lookup 
name exists 	pending 
nst symlink changes 	api associate 
path ent 	api lookup 
path ent patch 	pending port 
name change 	dissociate perror 
name ret name 	abort api 
patch old 	associate 
name name patch 	abort api 
old name 	associate abort 
name name tpatch 	port getn 
exists status 	perror abort 
err patch err 	module illumos 
path sha 	ports 
pos sha hunk 	copyright joyent 
heading preimage 	inc rights 
list filename patch 	reserved redistribution 
result sha 	use source 
name patch 	binary forms 
files adds dels 	without 
patch name 	modification permitted 
newdelete mode name 	provided following 
show name 	conditions met 
renamecopy old slash 	redistributions source 
old slash 	code must 
patch patch lines 	retain 
len len 	copyright notice 
patch rmdir empty 	list conditions 
path mode 	following disclaimer 
buf size namelen 	redistributions binary 
size path 	form must 
mode buf size 	reproduce 
nbuf path 	copyright notice 
mode buf size 	list conditions 
newpath patch 	following disclaimer 
stage namelen 	documentation materials 
size mode patch 	provided distribution 
path mode 	neither 
size buf patch 	name redis 
phase patch 	names contributors 
rej namebuf frag 	may used 
cnt list 	endorse promote 
phase errs cpath 	products derived 
item file 	software 
filename options offset 	without specific 
buf listp 	prior written 
skipped patch patch 	permission software 
opt arg 	provided copyright 
unset opt arg 	holders contributors 
unset opt 	express 
arg unset opt 	implied warranties 
arg unset 	including limited 
opt arg unset 	implied warranties 
whitespace option 	merchantability fitness 
opt arg 	particular purpose 
unset argc argv 	disclaimed 
prefix errs 	shall copyright 
gitdir force apply 	owner contributors 
whitespace option 	liable direct 
builtin apply options 	indirect incidental 
arg squelched 	special exemplary 
strcmp strcmp strcmp 	consequential 
strcmp strcmp 	damages including 
strcmp die strcmp 	limited procurement 
strcmp strcmp 	substitute goods 
strcmp strcmp die 	services loss 
free free 	use data 
free fragment list 	profits 
free free 	business interruption 
free free free 	however caused 
free patch 	theory liability 
isspace isspace isspace 	whether contract 
isspace isspace 	strict liability 
isspace isspace 	tort 
isspace isspace alloc 	including negligence 
grow hash 	otherwise arising 
line memset line 	way use 
info free 	software even 
free memset strcmp 	advised possibility 
quote style 	damage 
strbuf addstr quote 	file api 
style quote 	ports present 
style fputc strbuf 	solaris systems 
release strbuf 	since solaris 
read die errno 	port associate 
strbuf grow 	file 
memset skip prefix 	descriptors port 
isspace unquote 	association also 
style strbuf release 	includes poll 
strchr strbuf 	events consumer 
release strbuf strbuf 	interested pollin 
insert squash 	pollout 
slash strbuf 	one tricky 
detach strlen strlen 	piece implementation 
strlen isdigit 	events via 
strlen strlen strlen 	api poll 
isdigit isdigit 	corresponding file 
isdigit isdigit strlen 	descriptors 
strlen strlen 	become dissociated 
isdigit isdigit isdigit 	port necessary 
isdigit isdigit 	poll events 
isdigit strlen isdigit 	level triggered 
isdigit strlen 	didn become 
strlen strlen strlen 	dissociated 
isdigit isdigit 	would immediately 
isdigit isdigit isdigit 	fire another 
isdigit isdigit 	since underlying 
isdigit time len 	state hasn 
isdigit sane 	changed yet 
len colon 	must 
len time len 	associate file 
fractional time 	descriptor know 
len date len 	caller actually 
trailing spaces 	read api 
len isspace name 	tell exactly 
terminate squash 	happens 
slash xstrdup squash 	know must 
slash xstrdup 	happen time 
strlen strncmp squash 	api poll 
slash xstrdup 	called solution 
xstrfmt squash slash 	keep track 
squash slash 	last 
xmemdupz find name 	fds returned 
gnu find 	api poll 
name common find 	associate next 
name gnu 	time api 
strchrnul diff timestamp 	poll invoked 
len find 	summarize 
name common 	module association 
find name common 	either represented 
dev find 	via kernel 
name traditional strchr 	association represented 
strncmp count 	pending fds 
slashes strncmp count 	pending 
slashes free 	masks last 
xmalloc regcomp warning 	fds returned 
regexec size 	api poll 
warning strtol strtol 	enter api 
memcmp memcmp 	poll point 
strtol strtol guess 	restore 
guess dev 	kernel association 
find name traditional 	port pending 
dev find 	fds pending 
name traditional find 	fds pending 
name traditional 	fds masks 
find name traditional 	nothing 
free epoch 	resize helper 
timestamp epoch 	function invoke 
timestamp xstrdup die 	port associate 
find name 	given mask 
strlen die find 	since port 
name memcmp 	associate 
die free memcmp 	events argument 
die gitdiff 	replaces existing 
verify name free 	events must 
gitdiff verify 	sure include 
name free strtoul 	whatever events 
strtoul free 	already 
xstrdup gitdiff oldmode 	associated call 
free xstrdup 	port associate 
gitdiff newmode free 	recently returned 
find name 	api poll 
free find name 	safe consumer 
free find 	processed 
name free find 	poll play 
name strtoul 	safer simply 
strtoul strchr 	updating pending 
memcpy strchr strchrnul 	mask associated 
memcpy strtoul 	usual api 
strlen strlen unquote 	poll 
style skip 	called returned 
prefix strbuf isspace 	api poll 
unquote style 	currently associated 
skip prefix strcmp 	port need 
strbuf release 	update pending 
strbuf detach skip 	mask 
prefix memcmp 	appropriately currently 
strbuf detach strbuf 	associated port 
release strbuf 	like must 
release skip prefix 	look full 
unquote style 	mask file 
skip prefix strncmp 	descriptor 
isspace strbuf 	updating association 
strbuf detach strbuf 	good way 
release strchr 	knowing events 
skip prefix 	without looking 
strncmp xmemdupz git 	loop state 
header name 	directly 
xstrfmt free linelen 	rely fact 
size strlen 	caller already 
memcmp isdigit strtoul 	updated mask 
parse num 	loop removing 
parse num strlen 	events use 
memcmp warning 	port 
linelen starts starts 	dissociate association 
warning linelen 	completely failure 
parse range parse 	indicates bug 
range linelen 	enomem potentially 
memcmp parse fragment 	condition kernel 
header die 	won 
memcmp parse git 	generally unless 
header die 	things really 
xstrdup xstrdup 	bad eagain 
die memcmp memcmp 	indicates reached 
linelen memcmp 	resource 
parse traditional patch 	limit doesn 
whitespace error 	make sense 
free check record 	retry counter 
error linelen 	intuitively errors 
parse fragment header 	indicate bug 
recount diff 	cases 
linelen check whitespace 	best abort 
check whitespace 	returned events 
check whitespace memcmp 	must associate 
memcmp linelen 	port calling 
error error memcmp 	port see 
xcalloc parse 	block 
fragment die die 	comment top 
die memset 	file explanation 
xmalloc git inflate 	since deleted 
init git 	see api 
inflate git 	del fatal 
inflate end free 	port 
linelen starts 	getn errno 
strtoul starts strtoul 	etime returned 
linelen xrealloc 	events etime 
decode xcalloc inflate 	check nevents 
free free 	error indicates 
error parse binary 	bug 
hunk error 	ae kqueuec 
parse binary hunk 	loop state 
free free 	loop setsize 
xstrdup prefix filename 	state loop 
free prefix 	state loop 
one prefix one 	mask 
list append 	state loop 
strlen memcmp wildmatch 	mask state 
find header 	loop tvp 
prefix patch use 	state retval 
patch whitespace 	numevents timeout 
rule parse 	mask 
single patch linelen 	zmalloc zmalloc 
memcmp parse 	zfree kqueue 
binary memcmp strlen 	zfree zfree 
memcmp metadata 	zrealloc close 
changes die swap 	zfree zfree 
swap swap 	kevent 
swap swap swap 	kevent kevent 
swap quote 	kevent kevent 
style strchr strbuf 	kevent kqueue 
splice strbuf 	module copyright 
release strbuf release 	harish mallipeddi 
strbuf readlink 	harish 
error strbuf read 	mallipeddi gmail 
file error 	rights reserved 
convert git prepare 	redistribution use 
image free 	source binary 
xmalloc memmove memcpy 	forms without 
die memcmp 	modification 
isspace fuzzy 	permitted provided 
matchlines isspace strbuf 	following conditions 
init strbuf 	met redistributions 
strbuf strbuf detach 	source code 
update pre 	must retain 
post images strbuf 	copyright 
init fix 	notice list 
copy strbuf init 	conditions following 
fix copy 	disclaimer redistributions 
memcmp strbuf release 	binary form 
fix copy 	must reproduce 
isspace strbuf detach 	copyright 
update pre 	notice list 
post images strbuf 	conditions following 
release match 	disclaimer documentation 
fragment xmalloc sub 	materials provided 
memcpy memcpy 	distribution neither 
memcpy free 	name 
realloc memmove memcpy 	redis names 
memset memset 	contributors may 
xmalloc strbuf init 	used endorse 
linelen strbuf 	promote products 
addch line info 	derived software 
line info 	without 
blank line memcpy 	specific prior 
line info 	written permission 
strbuf fix copy 	software provided 
line info 	copyright holders 
blank line error 	contributors express 
strbuf setlen 	implied 
find pos first 	warranties including 
line first 	limited implied 
line last line 	warranties merchantability 
last line 	fitness particular 
record error last 	purpose disclaimed 
line update 	shall 
image error 	copyright owner 
free strbuf release 	contributors liable 
free free 	direct indirect 
error error patch 	incidental special 
delta clear 	exemplary consequential 
image clear image 	damages 
xmemdupz strlen 	including limited 
strlen sha hex 	procurement substitute 
sha hex 	goods services 
error hash sha 	loss use 
file strcmp 	data profits 
sha hex error 	business 
sha hex 	interruption however 
error sha hex 	caused theory 
sha clear 	liability whether 
image sha file 	contract strict 
read sha 	liability tort 
file error clear 	including 
image apply 	negligence otherwise 
binary fragment 	arising way 
error hash sha 	use software 
file strcmp 	even advised 
sha hex error 	possibility damage 
sha hex 	ae 
apply binary apply 	selectc loop 
one fragment 	state loop 
error isgitlink strbuf 	setsize loop 
grow strbuf 	loop mask 
addf sha hex 	state loop 
read sha 	mask 
file strbuf attach 	state loop 
read blob 	tvp state 
list lookup list 	retval numevents 
insert list 	mask zmalloc 
insert list insert 	zero zero 
memset checkout 	zfree 
entry lstat error 	clr clr 
table deleted 	memcpy memcpy 
deleted isgitlink 	isset isset 
isdir match stat 	module copyright 
read file 	salvatore sanfilippo 
gitlink error isgitlink 	antirez 
read file 	gmail dot 
gitlink symlink leading 	rights reserved 
path strlen 	redistribution use 
error read old 	source binary 
data error 	forms without 
previous patch error 	modification 
strbuf load 	permitted provided 
patch target free 	following conditions 
fragment list 	met redistributions 
error strbuf detach 	source code 
prepare image 	must retain 
read mmblob read 	copyright 
mmblob read 	notice list 
mmblob merge 	conditions following 
free free free 	disclaimer redistributions 
free clear 	binary form 
image die cache 	must reproduce 
name pos 	copyright 
strlen error lstat 	notice list 
error strerror 	conditions following 
checkout target verify 	disclaimer documentation 
index match 	materials provided 
error load patch 	distribution neither 
target strbuf 	name 
detach prepare image 	redis names 
isgitlink isgitlink 	contributors may 
write sha file 	used endorse 
sha read 	promote products 
blob error strbuf 	derived software 
detach prepare 	without 
image apply fragments 	specific prior 
clear image 	written permission 
write sha 	software provided 
file clear image 	copyright holders 
load current 	contributors express 
error load preimage 	implied 
error write 	warranties including 
sha file clear 	limited implied 
image three 	warranties merchantability 
way merge oidclr 	fitness particular 
hashcpy hashcpy 	purpose disclaimed 
hashcpy load preimage 	shall 
apply fragments 	copyright owner 
threeway table free 	contributors liable 
error previous 	direct indirect 
patch error lstat 	incidental special 
error strerror 	exemplary consequential 
cache name pos 	damages 
strlen error 	including limited 
checkout target verify 	procurement substitute 
index match 	goods services 
error error 	loss use 
strerror mode stat 	data profits 
error warning 	business 
free cache name 	interruption however 
pos strlen 	caused theory 
lstat isdir symlink 	liability whether 
leading path 	contract strict 
strlen error strerror 	liability tort 
list lookup 	including 
list insert list 	negligence otherwise 
lookup islnk 	arising way 
symlink changes islnk 	use software 
symlink changes 	even advised 
check symlink changes 	possibility damage 
cache file 	need 
exists islnk lstat 	copy sets 
islnk strbuf 	safe reuse 
addstr path beyond 	sets ensure 
symlink strbuf 	enough room 
release verify 	type aligned 
path die verify 	allocc 
path die 	alignment alignment 
check preimage table 	size alignment 
deleted deleted 	size total 
check create error 	buf errno 
error strcmp 	aligned alloc 
error error die 	errno 
path path 	errno aligned 
beyond symlink error 	alloc errno 
apply data 	errno aligned 
error prepare symlink 	alloc errno 
changes prepare 	errno aligned 
table say patch 	alloc 
name check 	errno errno 
patch read cache 	aligned alloc 
cache name 	errno aligned 
pos strlen hashcpy 	alloc buferror 
memchr starts 	errno test 
sha hex 	fail 
starts sha hex 	malloc usable 
isgitlink preimage 	size free 
sha gitlink patch 	test define 
die sha 	maxalign size 
blob current sha 	all.c lua 
die die 	core 
make cache entry 	libraries interpreter 
die index 	single file 
entry die hold 	allocated.c config 
file update 	stats arg 
write locked index 	err usize 
die discard 	thd 
index show stats 	mallctl test 
print stat 	fail strerror 
summary write name 	mallctl test 
quoted strchr 	fail strerror 
strchr memcmp 	mallctl test 
show mode change 	fail 
show file 	strerror mallctl 
mode name show 	test fail 
file mode 	strerror malloc 
name show rename 	ptr mallctl 
copy show 	mallctl ptr 
mode change show 	malloc 
mode change 	usable size 
quote style strlen 	free mallctl 
quote style 	mallctl ptr 
strlen file cache 	test skip 
die warn 	thd start 
path strlen cache 	thd 
entry size 	create thd 
xcalloc memcpy create 	test run 
mode create 	tests multiple 
flags isgitlink skip 	times check 
prefix sha 	bad interactions 
hex die 	anet.c 
lstat die errno 	err fmt 
fill stat 	err non 
cache info write 	block flags 
sha file 	err err 
die cache entry 	err interval 
die isgitlink 	val 
lstat isdir mkdir 	err val 
islnk symlink 	err err 
open convert working 	err buffsize 
write die 	err yes 
strbuf release close 	err err 
die errno 	host 
create file safe 	ipbuf ipbuf 
create leading 	len flags 
directories create file 	hints info 
lstat isdir 	err host 
rmdir getpid mksnpath 	ipbuf ipbuf 
create file 	len 
rename unlink 	err host 
warn die errno 	ipbuf ipbuf 
strlen cache 	len err 
entry size file 	yes err 
cache oid 	domain err 
xcalloc memcpy create 	addr 
mode create 	port source 
flags hashcpy cache 	addr flags 
entry die 	portstr hints 
create one file 	servinfo bservinfo 
conflicted stages 	bound err 
file index file 	addr 
file create 	port err 
file file create 	addr port 
file say 	err addr 
patch name die 	port source 
strbuf addf 	addr err 
say patch name 	addr 
strbuf release 	port source 
strlen size 	addr err 
size warning memcpy 	path flags 
memcpy fopen 	err path 
error strerror fputc 	err path 
fclose write 	buf 
one result write 	count nread 
one reject 	totlen buf 
list append list 	count nwritten 
sort list 	totlen err 
clear rerere read 	len backlog 
patch file 	err 
xcalloc parse chunk 	yes err 
reverse patches 	port bindaddr 
use patch patch 	backlog port 
stats free 	hints servinfo 
patch die hold 	err port 
locked index 	bindaddr 
read cache 	backlog err 
die check patch 	port bindaddr 
list exit 	backlog err 
write results exit 	path perm 
build fake 	backlog err 
ancestor stat patch 	len 
list numstat 	err len 
patch list summary 	port salen 
patch list 	err salen 
free patch list 	len port 
strbuf release 	salen buf 
list clear git 	buf 
config git 	len port 
config git config 	buf buf 
name limit 	len port 
name limit atoi 	len port 
parse whitespace 	salen fmt 
option strbuf reset 	fmt 
strbuf addstr 	len port 
strbuf complete 	start vsnprintf 
strlen git apply 	end fcntl 
config parse 	anet error 
whitespace option parse 	strerror fcntl 
ignorewhitespace option 	anet 
parse options die 	error strerror 
die die 	anet block 
die die strcmp 	anet block 
apply patch 	setsockopt anet 
prefix filename open 	error strerror 
die errno 	setsockopt 
whitespace mode apply 	anet error 
patch close 	strerror setsockopt 
whitespace mode apply 	anet error 
patch warning 	strerror setsockopt 
die warning warning 	anet error 
write locked 	strerror 
index die apply 	setsockopt anet 
copyright linus 	error strerror 
torvalds applies 	anet tcp 
patches top arbitrary 	delay anet 
version scm 	tcp delay 
check turns checking 	setsockopt 
working matches 	anet error 
files modified doesn 	strerror setsockopt 
apply patch 	anet error 
stat diffstat doesn 	strerror setsockopt 
actually apply 	anet error 
numstat numeric diffstat 	strerror 
doesn actually 	memset getaddrinfo 
apply index info 	anet error 
shows old 	gai strerror 
index info paths 	inet ntop 
available index 	inet ntop 
updates cache well 	freeaddrinfo 
cached updates 	anet resolve 
cache without ever 	anet resolve 
touching working 	setsockopt anet 
diff stat 	error strerror 
like behaviour keep 	socket anet 
track biggest 	error 
change seen longest 	strerror anet 
filename allows 	reuse addr 
simple scaling various 	close snprintf 
current state 	memset getaddrinfo 
notably line numbers 	anet error 
file patching 	gai 
right xxxx things 	strerror socket 
flags means 	anet reuse 
know yet represents 	addr anet 
one hunk 	non block 
patch starting oldpos 	getaddrinfo anet 
oldlines newpos 	error 
newlines marker patch 	gai strerror 
text pointed 	bind freeaddrinfo 
patch length 	anet error 
stored size leading 	strerror connect 
trailing number 	close anet 
context lines patch 	error 
usually borrowed 	strerror close 
buf apply patch 	freeaddrinfo anet 
codepaths store 	tcp connect 
allocated buffer dealing 	anet tcp 
binary patch 	connect anet 
reuse leading field 	tcp 
store type 	connect anet 
binary hunk either 	tcp connect 
deflated delta 	anet tcp 
deflated represents patch 	connect anet 
file metainfo 	create socket 
changes creation deletion 	strncpy 
filemode content 	anet non 
changes represented series 	block connect 
fragments unknown 	anet error 
three way 	strerror close 
fallback result line 	anet unix 
file len 	connect 
bytes includes terminating 	anet unix 
incomplete line 	connect read 
end file ends 	write bind 
one contents 	anet error 
hashes hash represents 	strerror close 
file lines 	listen 
records filenames touched 	anet error 
order handle 	strerror close 
one patches touch 	setsockopt anet 
file compare 	error strerror 
lines length length 	close snprintf 
ignoring whitespace 	memset 
difference returns match 	getaddrinfo anet 
otherwise ignore 	error gai 
line endings skip 	strerror socket 
leading whitespaces 	anet anet 
begin whitespace 	reuse addr 
early lines empty 	anet 
skip whitespace 	listen anet 
inside check whitespace 	error freeaddrinfo 
buffers want 	anet tcp 
match reached end 	server anet 
one side 	tcp 
lines match buf 	server anet 
file contents 	create socket 
patched read various 	memset strncpy 
sources attach 	anet listen 
image line index 	chmod accept 
image owns 	anet 
buf fmt must 	error strerror 
contain one 	anet accept 
substitution make sure 	inet ntop 
slop buffer 	ntohs inet 
speculative memcmp etc 	ntop ntohs 
see nul 	anet 
filled slashes 	accept getpeername 
make index work 	inet ntop 
filenames proposed 	ntohs inet 
style gnu patch 	ntop ntohs 
diff format 	strncpy snprintf 
see http marc 	strchr 
info git 	anet peer 
date digit year 	anet format 
permit digit 	addr getsockname 
hours time expected 	inet ntop 
format fractional 	ntohs inet 
seconds hours minutes 	ntop 
whole seconds 	ntohs anet 
expected format spaces 	sock name 
posix gnu 	anet format 
date bad space 	addr anet 
date success 	basic tcp 
space date whitespace 	socket 
damage generally 	stuff made 
prefer shorter 	bit less 
name especially one 	boring copyright 
variation something 	salvatore sanfilippo 
tacked end file 	antirez gmail 
orig file 	dot 
given guess appropriate 	rights reserved 
given patch 	redistribution use 
begin prefix likely 	source binary 
apply directory 	forms without 
line posix timestamp 	modification permitted 
last gnu 	provided 
diff puts epoch 	following conditions 
signal creation 	met redistributions 
deletion timestamp interested 	source code 
epoch timestamp 	must retain 
non zero fraction 	copyright notice 
cannot one 	list 
hence regexp 	conditions following 
reason date must 	disclaimer redistributions 
either seconds 	binary form 
part must yyyy 	must reproduce 
must either 	copyright notice 
west gmt east 	list 
gmt name 	conditions following 
etc info lines 	disclaimer documentation 
traditional patch 	materials provided 
header fixme end 	distribution neither 
filename heuristics 	name redis 
kind screwy existing 	names 
files happily 	contributors may 
check index match 	used endorse 
creating file 	promote products 
match whatever patch 	derived software 
idea skip 	without specific 
skip anal diff 	prior 
header consistency 	written permission 
make sure 	software provided 
end strange ambiguous 	copyright holders 
patches floating 	contributors express 
around result gitdiff 	implied warranties 
old name 	including 
check names previous 	limited implied 
information make 	warranties merchantability 
sure expect dev 	fitness particular 
index line 	purpose disclaimed 
hexadecimal hexadecimal optional 	shall copyright 
space octal 	owner 
mode normal diff 	contributors liable 
doesn change 	direct indirect 
anything fall next 	incidental special 
diff tell 	exemplary consequential 
parser skip leading 	damages including 
components line 	limited 
accept absolute paths 	procurement substitute 
extract name 	goods services 
appears diff 	loss use 
git line find 	data profits 
anything rename 	business interruption 
patch find name 	however 
elsewhere need 	caused theory 
reliably find name 	liability whether 
mode change 	contract strict 
creation deletion empty 	liability tort 
file cases 	including negligence 
sides name respectively 	otherwise 
strip prefix 	arising way 
including trailing slash 	use software 
second points 	even advised 
one past closing 	possibility damage 
name find 	socket blocking 
second name must 	non 
match otherwise 	block zero 
ignore unquoted second 	non blocking 
unquoted first 	note fcntl 
name since 	getfl setfl 
first name unquoted 	interrupted signal 
exists must 	tcp 
beginning second name 	keep alive 
good accept 	option detect 
name shows twice 	dead peers 
exactly form 	interval option 
separator preimage postimage 	used linux 
pathname interested 	linux 
rename def name 	specific probe 
rename patch 	send time 
names elsewhere unambiguous 	interval count 
form postimage 	settings less 
name len bytes 	garbage keepalive 
starting name 	time 
second separated one 	linux modify 
found exactly 	settings make 
match verify 	feature actually 
recognize lines following 	useful send 
git header 	first probe 
git diff information 	interval 
guess things 	send next 
may old name 	probes specified 
rest headers 	interval note 
anywhere pure mode 	delay interval 
changes removing 	send three 
adding empty files 	probes 
name header 	detecting error 
fall parse unified 	see next 
diff fragment 	setsockopt call 
header form figure 	consider socket 
number lines 	error state 
fragment testing early 	three 
allows take 	send three 
shortcuts make sure 	ack probes 
find unconnected 	without getting 
patch fragments 	reply avoid 
sign didn find 	unused warning 
header patch 	non 
become corrupted broken 	linux systems 
git patch 	socket send 
might real patch 	timeout sndtimeo 
rename mode 	socket option 
change handle specially 	specified number 
followed accept 	milliseconds 
unified patches want 	disable argument 
least chars 	zero anet 
minimum shortest consider 	resolve called 
patch parse 	anet resolve 
unified diff note 	anet resolve 
really needs 	actual 
parse fragment separately 	work resolves 
since way 	hostname host 
know difference part 	representation address 
patch starts 	buffer pointed 
next patch 	ipbuf flags 
look line counts 	anet 
parse thing 	function resolves 
newer gnu diff 	hostnames actually 
empty context 	already addresses 
line allow newline 	turns function 
end file 	validating normalizing 
depending locale settings 	function 
patch produced 	specify socktype 
know line looks 	avoid dups 
like thing 	make sure 
know begins checking 	connection intensive 
sanity check 	things like 
newline least fragment 	redis 
ends incomplete 	benckmark able 
line failed include 	close open 
loop hit 	sockets zillion 
oldlines newlines seeing 	times make 
seen diff 	sure connection 
git header 	intensive 
traditional patch header 	things like 
read hunks 	redis benchmark 
belong patch fragments 	able close 
hang given 	open sockets 
patch structure fragment 	zillion times 
patch fragment 	best 
size pair points 	effort binding 
memory given 	strlen create 
caller copy something 	socket connect 
removed old 	fail socket 
lines cannot creation 	call connect 
something added 	retry 
cannot deletion however 	next entry 
reverse unified 	servinfo getaddrinfo 
patches necessarily creation 	saves self 
even though 	determining socket 
old lines ones 	non blocking 
necessarily deletion 	connect 
unfortunately real 	einprogress error 
creation deletion patch 	ended iteration 
context line 	loop without 
definition cannot safely 	errors connected 
tell apart 	socket caller 
unified insanity least 	handle 
patch one 	best effort 
hunk creation deletion 	binding binding 
read binary 	address used 
hunk fragment fragment 	possible create 
patch points 	socket without 
allocated memory caller 	binding 
must free 	address like 
marked free patch 	read make 
expect line 	sure count 
begins binary patch 	read unless 
method delta 	error eof 
followed length 	condition 
data deflating sequence 	encountered like 
length followed 	write make 
encoded data follow 	sure count 
terminated newline 	written unless 
sequence encodes bytes 	error encountered 
would limit 	strlen 
patch line characters 	effect bindaddr 
one line 	format port 
fit groups would 	pair something 
decode bytes 	easy parse 
max length corresponds 	matches surrounded 
bytes corresponds 	port 
bytes consume blank 	separated colons 
line minimum 	standard display 
line line length 	addresses within 
must multiple 	redis like 
plus input length 	anet format 
multiple would 	addr 
filler end 	extract port 
filler never exceed 	socket peer 
bytes read 	anet.h err 
git binary patch 	addr port 
follows line 	err addr 
says patch method 	port 
currently either 	err addr 
delta length data 	port source 
deflating sequence 	addr err 
length followed encoded 	addr port 
data follows 	source addr 
binary patch reversible 	err 
another binary 	path err 
hunk format starting 	path buf 
patch method 	count err 
either delta length 	host ipbuf 
data sequence 	ipbuf len 
length encoded data 	err 
terminated another 	host ipbuf 
empty line 	ipbuf len 
data applied postimage 	err port 
produces preimage 	bindaddr backlog 
one hunk forward 	err port 
hunk otherwise 	bindaddr 
already gave error 	backlog err 
message reverse 	path perm 
hunk error corrupt 	backlog err 
reverse hunk 	serversock len 
include exclude paths 	port err 
outside touched 	serversock 
regardless include see 	buf count 
matches exclude 	err err 
include rule include 	err err 
path match 	err err 
rule used otherwise 	len port 
saw bunch 	err 
exclude rules none 	interval len 
path used 	port fmt 
read patch 	fmt len 
text buffer size 	port fmt 
bytes stop 	fmt len 
reading seeing single 	fmt 
patch changes 	fmt len 
single file create 	anet basic 
fragments patch 	tcp socket 
hunks hang given 	stuff made 
patch number 	bit less 
bytes consumed caller 	boring 
call next 	copyright salvatore 
patch empty patch 	sanfilippo antirez 
cannot applied 	gmail dot 
text patch without 	rights reserved 
metadata change 	redistribution use 
binary patch appears 	source 
empty scale 	binary forms 
filename scale 	without modification 
update preimage common 	permitted provided 
lines postimage 	following conditions 
buffer buf length 	met redistributions 
len postlen 	source 
postimage updated place 	code must 
otherwise updated 	retain copyright 
buffer length postlen 	notice list 
update preimage 	conditions following 
whitespace fixes note 	disclaimer redistributions 
losing preimage 	binary 
buf apply one 	form must 
fragment free 	reproduce copyright 
oldlines adjust common 	notice list 
context lines 	conditions following 
postimage done place 	disclaimer documentation 
shrinking whitespace 	materials 
fixing needs buffer 	provided distribution 
ignoring whitespace 	neither name 
expanding leading 	redis names 
tabs spaces trust 	contributors may 
caller tell 	used endorse 
update done place 	promote 
postlen added 	products derived 
line counterparts preimage 	software without 
common context 	specific prior 
skip original postimage 	written permission 
find corresponding 	software provided 
one preimage preimage 	copyright 
expected run 	holders contributors 
caller addition trailing 	express implied 
blank lines 	warranties including 
copy fixing line 	limited implied 
length fix 	warranties merchantability 
length whole thing 	fitness 
hunk falls 	particular purpose 
within boundaries img 	disclaimed shall 
hunk beyond 	copyright owner 
end img 	contributors liable 
removing blank lines 	direct indirect 
end file 	incidental 
many lines beginning 	special exemplary 
preimage must 	consequential damages 
match img remainder 	including limited 
preimage must 	procurement substitute 
blank hunk beyond 	goods services 
end img 	loss 
removing blanks end 	use data 
reject hunk 	profits business 
position quick hash 	interruption however 
check exact 	caused theory 
match told match 	liability whether 
end size 	contract 
must exactly fragsize 	strict liability 
otherwise fragsize 	tort including 
must still within 	negligence otherwise 
preimage either 	arising way 
old piece 	use software 
match preimage exactly 	even 
preimage beyond 	advised possibility 
end img cannot 	damage flags 
exact match 	used certain 
must one non 	functions aof.c 
blank context 	size block 
line match line 	privdata 
end img 	mask block 
exact match ignoring 	nwritten len 
whitespace run 	block thislen 
line line fuzzy 	numblocks level 
matching collect 	count block 
line length information 	nwritten 
need adjust 	statloc cwd 
whitespace match preimage 	cwdp force 
matches whitespace 	nwritten sync 
fuzz imgoff 	progress latency 
holds length target 	last write 
matches preimage 	error 
end file count 	log log 
number characters 	dst argc 
preimage fall beyond 	argv buf 
end file 	len buf 
make sure whitespace 	cmd key 
characters happen 	seconds 
removing blank lines 	argv cmd 
end file 	dictid argv 
update preimage common 	argc buf 
postimage context 	tmpargv seldb 
lines use whitespace 	filename fake 
target whitespace 	client 
missing target preimage 	old aof 
beyond end 	state loops 
file use whitespace 	valid argc 
preimage hunk 	len argv 
apply hash 	buf argsds 
says might whitespace 	cmd 
fuzz weren 	obj key 
asked ignore whitespace 	items list 
asked correct 	entry cmd 
whitespace errors matching 	items key 
whitespace correction 	items llval 
checking preimage target 	cmd 
whitespace errors 	items eleobj 
count large corresponding 	cmd items 
postimage needs 	key items 
postimage prepared apply 	eptr sptr 
one fragment 	vstr vlen 
whitespace errors added 	vll 
lines already 	score cmd 
common lines propagated 	items eleobj 
may become 	score cmd 
longer whitespace errors 	items vstr 
first count 	vlen vll 
added lines 	key 
postimage preimage may 	items cmd 
extend beyond 	items buf 
end file loop 	nread total 
handle part 	filename aof 
preimage falls within 	tmpfile processed 
file fixing 	selectcmd 
line preimage fixing 	keystr key 
line target 	expiretime cmd 
match either preimage 	cmd nodata 
version whitespace 	start privdata 
breakage lacking whitespace 	mask fds 
fix patch 	childpid 
preimage already target 	start tmpfile 
whitespace breakage 	dirty childpid 
preimage doesn either 	tmpfile latency 
fixing whitespace 	exitcode bysignal 
breakages might well 	newfd oldfd 
take fix 	tmpfile 
together real 	latency list 
change length common 	release list 
postimage handle 	create list 
lines preimage falls 	free method 
beyond end 	list rewind 
file match empty 	list 
contain whitespace 	next list 
blank eol start 	node unused 
preimage fixing 	unused unused 
line preimage yes 	unused list 
preimage older 	first file 
version still whitespace 	write 
breakages unfixed 	memmove list 
fixing makes hunk 	del node 
match update 	list last 
context lines postimage 	memcpy zmalloc 
match beginning 	list 
match end specified 	node tail 
point starting 	list length 
wrong line 	server log 
never match wander 	aof rewrite 
around wait 	buffer size 
match specified end 	file 
comparison following 	events create 
test also take 	file list 
care negative 	rewind list 
line number result 	next list 
match end 	node write 
preimage larger target 	bio 
probably smart 	create background 
way smart beautiful 	job server 
people simple 	flush append 
stupid change preimage 	file aof 
postimage found 	fsync close 
apply applied pos 	server 
counts line 	log kill 
numbers img 	wait aof 
update img preimage 	rewrite buffer 
replace postimage 	reset aof 
copy preimage offset 	temp file 
img replace 	aof 
postimage removing blank 	close pipes 
lines end 	open server 
img preimage may 	getcwd server 
extend beyond 	log strerror 
end must careful 	rewrite append 
part preimage 	file 
falls within boundaries 	background close 
img initialize 	server log 
preimage limit number 	sdslen bio 
lines preimage 	pending jobs 
falls within boundaries 	type server 
adjust contents 	log 
adjust line table 	latency start 
note knows 	monitor write 
never call 	sdslen latency 
first line anything 	end monitor 
pre post 	latency sample 
image use patch 	needed 
hunk text 	latency sample 
frag prepare two 	needed latency 
images preimage 	sample needed 
postimage hunk find 	latency sample 
lines match 	needed sdslen 
preimage img replace 	server 
part img 	log strerror 
postimage text plen 	server log 
much line 	sdslen ftruncate 
use actual patch 	server log 
data normally 	strerror server 
first character line 	log 
line followed 	exit sdsrange 
newline also last 	server log 
one newline 	sdslen sdsavail 
course newer 	sdsclear sdsfree 
gnu diff empty 	sdsempty latency 
context line 	start 
followed newline nothing 	monitor aof 
fall lines 	fsync latency 
ignore already handled 	end monitor 
hunk change 	latency sample 
lines beginning would 	needed aof 
begin need 	background 
careful inserts second 	fsync sdscatlen 
line also 	decoded sdslen 
pattern hunk empty 	sdscatlen sdscatlen 
file would 	sdslen sdscatlen 
begin words hunk 	decr count 
frag oldpos 	decoded 
without leading context 	strtoll mstime 
must match 	decr count 
beginning hunk without 	create create 
trailing lines 	cat append 
must match 	command decr 
end however simply 	count 
cannot tell 	decr count 
hunk must match 	sdsempty snprintf 
end lack 	sdscatprintf strlen 
trailing lines patch 	cat append 
generated unidiff 	expire command 
without context context 	create 
limits reduce 	cat append 
number context lines 	command decr 
reduce leading 	count cat 
trailing equal otherwise 	append expire 
reduce larger 	command cat 
context would want 	append 
prevent write 	command sdscatlen 
results taking place 	sdslen aof 
apply patch 	rewrite buffer 
follows callchain 	append sdslen 
led apply patch 	sdsfree zmalloc 
check patch 	sdsempty 
list check patch 	list create 
apply data 	list create 
apply fragments apply 	list free 
one fragment 	method list 
warn necessary reduce 	dup method 
number context 	init 
lines binary patch 	client multi 
irreversible without 	state decr 
optional second hunk 	count zfree 
replace img 	sdsfree list 
result applying binary 	release list 
patch binary 	release 
patch data patch 	free client 
fragment still 	multi state 
kept preimage prepared 	zfree fopen 
caller img 	redis fstat 
freed helper 	fileno fclose 
function apply binary 	server 
fragment calls 	log strerror 
safety require patch 	exit create 
index line 	fake client 
contain full textual 	start loading 
sha old 	loading progress 
least see old 	ftello 
one matches 	process events 
patch applies otherwise 	blocked fgets 
old one 	feof atoi 
must empty deletion 	zmalloc fgets 
patch already 	free fake 
postimage verified buf 	client 
matches preimage 	argv strtol 
apply patch data 	sdsnewlen fread 
stored patch 	sdsfree free 
fragments patch size 	fake client 
verify result 	argv create 
matches xxx 	fread 
read sha file 	free fake 
nul terminates 	client argv 
item filename table 	lookup command 
records status 	server log 
path usually points 	exit proc 
patch whose 	server 
result records contents 	list length 
applying could 	server free 
path deleted path 	fake client 
previously applied 	argv ftello 
patch already removed 	fclose free 
path deleted 	fake 
path later patch 	client stop 
would latter 	loading aof 
needed deal two 	update current 
paths swapped 	size feof 
first renaming renaming 	server log 
moving prevented 	strerror 
due presence 	exit server 
later patch always 	log server 
name unless 	log truncate 
patch deletion cover 	server log 
cases normal 	server log 
diffs file creations 	strerror 
copies store 	lseek server 
failure rename deletion 	log strerror 
cases later 	server log 
chunks shouldn patch 	server log 
old names 	exit server 
store information incoming 	log 
file deletion 	exit rio 
git patches depend 	write bulk 
order deletion 	sds encoded 
hasn happened yet 	rio write 
apply patch 	bulk sdslen 
populate image 	server 
current version working 	panic quicklist 
index depending 	iterator quicklist 
situation cached index 	next rio 
applying non 	write bulk 
git patch incrementally 	count rio 
updates read 	write 
result previous diff 	bulk rio 
patched copy 	write bulk 
memory use way 	rio write 
apply subproject 	bulk rio 
patch without looking 	write bulk 
index needswork 	quicklist 
shouldn flagged error 	release iterator 
directly falling 	server panic 
back three way 	intset rio 
merge read 	write bulk 
current contents name 	count rio 
cases function 	write 
called point 	bulk rio 
falling back way 	write bulk 
merge cases 	rio write 
preimage patch prepared 	bulk dict 
apply patch 	iterator dict 
post image post 	next 
sha sha 	dict key 
core three way 	rio write 
merge post 	bulk count 
pre note reject 	rio write 
apply fragments 	bulk rio 
returns patch looking 	write 
modifies deletes 	bulk rio 
would want lose 	write bulk 
local modification 	dict release 
either working index 	iterator server 
also decides 	panic ziplist 
non git patch 	index 
creation patch 	server ziplist 
modification existing 	next server 
empty file check 	server ziplist 
state current 	zzl score 
creation patch function 	rio write 
caller check 	bulk 
patch separately makes 	count rio 
sure errors 	write bulk 
otherwise path patch 	rio write 
creates exist 	bulk rio 
current leading component 	write bulk 
name might 	rio 
symlink going removed 	write bulk 
patch still 	rio write 
pointing somewhere path 	bulk zzl 
path name 	next dict 
exist far git 	iterator dict 
concerned need 	next 
keep track symlinks 	dict key 
preimage manipulated 	dict val 
patches patch 	rio write 
symlink allowed affect 	bulk count 
directory symlink 	rio write 
points patch removes 	bulk 
perfectly fine 	rio write 
patch removes make 	bulk rio 
room create 	write bulk 
directory created symlink 	rio write 
patch old 	bulk dict 
name removed symlink 	release 
patch name 	iterator server 
created remains scan 	panic hash 
backwards cannot 	type current 
may see one 	ziplist rio 
created higher 	write bulk 
level otherwise check 	rio 
preimage check 	write bulk 
apply patch core 	hash type 
result patch 	current hash 
result caller 	table rio 
write destination drop 	write bulk 
succeed type 	server 
change diff always 	panic hash 
split patch 	type init 
old immediately followed 	iterator hash 
patch create 	type next 
see diff run 	rio write 
diff entry 	bulk 
deleted previous patch 	count rio 
still working 	write bulk 
index patch swap 	rio write 
rename would 	bulk rio 
first rename rename 	write hash 
applying first 	iterator 
one presence stop 	cursor rio 
getting renamed 	write hash 
ask deleted 	iterator cursor 
later rename removal 	hash type 
rename handled 	release iterator 
way asking deleted 	read 
happy attempt 	sdscatlen mstime 
read path beyond 	snprintf getpid 
symbolic link 	fopen server 
prevented load patch 	log strerror 
target called 	sdsempty rio 
beginning apply data 	init 
worry patch 	file rio 
marked bit however 	sync dict 
need make 	size dict 
sure patch result 	safe iterator 
deposited path 	fclose rio 
beyond symbolic link 	write 
function tries 	rio write 
read sha current 	bulk dict 
index usable 	next dict 
gitlink patch 	key dict 
one fragment hunk 	val init 
looks like 	expire 
subproject commit old 	rio write 
sha subproject 	rio write 
commit sha subproject 	bulk rio 
commit old 	write bulk 
sha removal patch 	rewrite list 
patch one 	rewrite 
hunk preimage one 	rewrite sorted 
line preimage 	rewrite hash 
begin heading record 	server panic 
full sha 	rio write 
abbreviated name index 	rio write 
line agree 	bulk 
looks fine may 	rio write 
full name 	bulk aof 
index line build 	read diff 
index contains 	parent dict 
files needed 	release iterator 
way merge start 	fflush 
supporting reverse 	fsync fileno 
patch may worth 	mstime mstime 
showing sha 	wait aof 
prefix textual part 	read diff 
looks sane 	parent write 
mode change update 	anet 
current find 	non block 
common prefix old 	sync read 
name thru 	server log 
old common prefix 	aof read 
old end 	diff parent 
names renames although 	server 
buf size 	log sdslen 
counted also nul 	rio write 
terminated optimistically 	sdslen fflush 
directories exist time 	fsync fileno 
anyway create 	fclose rename 
may trying 	server 
create file directory 	log strerror 
used phase 	unlink server 
zero phase one 	log server 
create rename 	log strerror 
modification boils thing 	fclose unlink 
old write 	dict 
happen removal patch 	release iterator 
leaves contents 	unused unused 
marked rejected patch 	unused read 
level say 	server log 
even without verbose 	write server 
normal git 	log 
tools never deal 	strerror file 
rej pretend 	pipe pipe 
git patch saying 	pipe anet 
git giving 	non block 
extended headers 	anet non 
maybe please kompare 	block 
wants trailing 	create file 
tab garbage end 	server log 
line owns 	strerror close 
patch text way 	file file 
still need 	close close 
write index think 	close 
twice adding 	close close 
nul synonym archive-tar.c 	close aof 
block offset 	create pipes 
tar umask args 	ustime fork 
data size 	close listening 
buf chunk tail 	sockets 
data size 	redis proc 
tail sha buf 	title snprintf 
readlen keyword 	getpid rewrite 
valuelen len tmp 	append file 
header chksum 	zmalloc dirty 
path pathlen 	server 
maxlen args header 	log exit 
mode size 	child exit 
args sha buffer 	child ustime 
size header 	zmalloc used 
mode args sha 	memory latency 
path pathlen 	sample 
mode header ext 	needed server 
header old 	log strerror 
mode size buffer 	server log 
err plen 	time update 
rest args sha 	dict resize 
ext header 	policy 
header mode err 	replication script 
tar filters 	cache flush 
tar filters alloc 	reply error 
tar filters 	reply status 
name len data 	rewrite append 
name type 	file 
namelen args 	background reply 
err args cmd 	status reply 
filter argv 	snprintf unlink 
tar archiver write 	latency start 
die memcpy 	monitor redis 
write needed write 	fstat 
die memcpy 	server log 
memset write needed 	strerror latency 
write blocked 	end monitor 
finish record memset 	latency sample 
write die 	needed ustime 
memset write die 	server 
open istream 	log latency 
error sha hex 	start monitor 
read istream 	snprintf open 
write blocked close 	server log 
istream finish 	strerror aof 
record strlen strbuf 	rewrite 
grow strbuf 	buffer write 
addf strbuf 	server log 
strbuf addch xsnprintf 	strerror close 
xsnprintf isreg 	latency end 
xsnprintf xsnprintf xsnprintf 	monitor latency 
strlcpy strlcpy 	sample 
xsnprintf xsnprintf memcpy 	needed server 
memcpy snprintf 	log aof 
ustar header chksum 	rewrite buffer 
memset xsnprintf 	size open 
sha hex prepare 	latency start 
header write 	monitor 
blocked write blocked 	rename server 
memset isdir 	log strerror 
isgitlink islnk isreg 	close close 
error sha 	latency end 
hex path prefix 	monitor latency 
memcpy memcpy 	sample 
xsnprintf sha 	needed close 
hex strbuf append 	aof fsync 
ext header 	aof background 
memcpy isreg sha 	fsync aof 
info islnk 	update current 
isreg sha file 	size 
archive error 	sdsfree sdsempty 
sha hex islnk 	server log 
xsnprintf sha 	bio create 
hex strbuf append 	background job 
ext header 	server log 
memcpy prepare header 	ustime 
write extended 	server log 
header free strbuf 	server log 
release write 	aof close 
blocked isreg write 	pipes aof 
blocked stream 	rewrite buffer 
blocked free strbuf 	reset 
append ext 	aof temp 
header sha 	file time 
hex memset xsnprintf 	copyright salvatore 
prepare header 	sanfilippo antirez 
write blocked write 	gmail 
blocked strbuf 	dot rights 
release strncmp parse 	reserved redistribution 
config key 	use source 
find tar filter 	binary forms 
xcalloc xmemdupz 	without modification 
alloc grow strcmp 	permitted 
config error 	provided following 
nonbool free xstrdup 	conditions met 
strcmp git 	redistributions source 
config strcmp strcmp 	code must 
umask umask 	retain copyright 
git config tar 	notice 
filter config 	list conditions 
write extended header 	following disclaimer 
write archive 	redistributions binary 
entries write 	form must 
trailer die strbuf 	reproduce copyright 
addstr strbuf 	notice 
addf start command 	list conditions 
die errno 	following disclaimer 
close dup die 	documentation materials 
errno close 	provided distribution 
write tar archive 	neither name 
close finish 	redis 
command die strbuf 	names contributors 
release archiver 	may used 
tar filter config 	endorse promote 
tar filter 	products derived 
config tar filter 	software without 
config tar 	specific 
filter config git 	prior written 
config archiver 	permission software 
copyright rene scharfe 	provided copyright 
writes whole 	holders contributors 
block full 	express implied 
queues writes write 	warranties 
calls write 	including limited 
exactly one full 	implied warranties 
block pads 	merchantability fitness 
writes recordsize end 	particular purpose 
tar archives 	disclaimed shall 
marked nul bytes 	copyright 
follows rest 	owner contributors 
block queues writes 	liable direct 
write calls 	indirect incidental 
write exactly one 	special exemplary 
full block 	consequential damages 
pads writes recordsize 	including 
pax extended 	limited procurement 
header records format 	substitute goods 
contains size 	services loss 
whole including first 	use data 
keyword second 	profits business 
one function 	interruption 
constructs appends strbuf 	however caused 
omit filters 	theory liability 
never command configured 	whether contract 
archive-zip.c zip 	strict liability 
date zip time 	tort including 
zip dir 	negligence 
zip dir size 	otherwise arising 
zip offset 	way use 
zip dir offset 	software even 
zip dir 	advised possibility 
entries max creator 	damage aof 
version magic 	rewrite 
version flags compression 	buffer implementation 
method mtime 	following code 
mdate crc compressed 	implement simple 
size size 	buffer used 
filename length 	order accumulate 
extra length end 	changes 
magic crc 	background process 
compressed size size 	rewriting aof 
end magic 	file need 
creator version version 	append use 
flags compression 	realloc large 
method mtime mdate 	block 
crc compressed 	huge reallocs 
size size filename 	always handled 
length extra 	one could 
length comment length 	expect via 
disk attr 	remapping pages 
attr offset end 	level 
magic disk 	may involve 
directory start disk 	copying data 
entries disk 	reason use 
entries size offset 	list blocks 
comment length 	every block 
end magic 	aof 
extra size flags 	buf block 
mtime end 	size bytes 
magic record size 	per block 
creator version 	function free 
version disk directory 	old aof 
start disk 	rewrite 
entries disk entries 	buffer needed 
size offset 	initialize fresh 
end magic disk 	one tests 
offset number 	server aof 
disks end dest 	rewrite buf 
dest dest 	blocks 
max clamped dest 	equal used 
clamped data 	first initialization 
size compression level 	well current 
compressed size 	size aof 
stream maxsize buffer 	rewrite buffer 
result size 	handler 
compressed size 	used send 
crc trailer header 	data child 
size compressed 	process aof 
size crc header 	rewrite send 
size compressed 	pieces aof 
size crc path 	differences 
buffer size 	buffer write 
driver args sha 	child finishes 
path pathlen 	rewrite small 
mode header dirent 	append data 
extra attr 	aof rewrite 
compressed size crc 	buffer 
direntsize method 	allocating blocks 
deflated buffer stream 	needed already 
flags size 	got least 
binary path without 	allocated block 
prefix creator 	appending least 
version buf readlen 	piece 
buf readlen 	current block 
zstream result 	already full 
len compressed trailer 	first block 
locator sha 	allocate need 
trailer clamped time 	another block 
dos date 	log 
dos time args 	every time 
err zip 	cross blocks 
archiver copy clamp 	respectively notice 
max git 	warning install 
deflate init raw 	file send 
git deflate 	data 
bound xmalloc git 	rewrite child 
deflate free 	one already 
git deflate end 	write buffer 
copy copy 	possibly composed 
copy copy write 	multiple blocks 
die copy 	specified 
copy copy 	write error 
copy copy copy 	happens returned 
isascii userdiff 	otherwise number 
find path userdiff 	bytes written 
find name 	returned aof 
buffer binary crc 	file 
ascii utf 	implementation starts 
warning error sha 	background task 
hex isdir 	performs fsync 
isgitlink isreg islnk 	specified file 
islnk islnk 	descriptor one 
isreg isreg open 	aof 
istream error 	file another 
sha hex sha 	called user 
file archive 	switches appendonly 
error sha hex 	yes appendonly 
crc entry 	runtime config 
binary error sha 	command 
hex zlib 	rewrite operation 
deflate raw 	progress kill 
copy copy copy 	wait child 
xrealloc copy 	exit reset 
copy copy copy 	buffer accumulating 
copy copy 	changes 
copy zip dir 	child saves 
data desc 	close pipes 
copy copy copy 	used ipc 
copy copy 	two processes 
copy copy copy 	called user 
copy copy 	switches 
copy copy zip 	appendonly appendonly 
header data 	yes runtime 
desc copy copy 	config command 
write die 	current working 
write die write 	dir path 
die read 	error 
istream crc entry 	messages correctly 
binary write 	switched aof 
die close 	wait rewrite 
istream write zip 	complete order 
data desc 	append data 
zip dir data 	disk 
desc git 	write append 
deflate init raw 	file buffer 
read istream 	disk since 
crc entry binary 	required write 
git deflate 	aof replying 
die write die 	client 
close istream 	way client 
git deflate die 	socket write 
git deflate 	entering loop 
end write die 	accumulate aof 
write zip 	writes memory 
data desc zip 	buffer 
dir data 	write disk 
desc write die 	function entering 
free free 	loop force 
copy memcpy 	argument fsync 
memcpy memcpy copy 	policy everysec 
copy copy 	may 
copy copy copy 	delay flush 
copy copy 	still fsync 
copy copy copy 	going background 
copy copy 	since instance 
copy write die 	linux write 
write die 	blocked 
copy copy copy 	background fsync 
copy clamp 	anyway happens 
copy clamp copy 	remember aof 
copy copy 	buffer flushed 
write die write 	asap server 
zip trailer 	cron 
write die write 	function however 
die sha 	force write 
hex localtime 	regardless background 
dos time xmalloc 	fsync seconds 
write archive 	errors logging 
entries write zip 	append 
trailer free 	fsync policy 
archiver copyright rene 	background fsyncing 
scharfe arm 	fsync still 
padding added end 	progress delay 
simple reports 	write couple 
two bytes payload 	seconds 
size interested 	previous write 
mtime make sure 	postponing remember 
enough free 	postponing flush 
space dictionary archive.c 	already waiting 
archive usage 	fsync finish 
archivers archivers alloc 	less 
archivers remote 	two seconds 
allow unreachable commit 	still postpone 
src len 	otherwise fall 
buf free 	trough write 
fmt ctx sha 	since wait 
file archive 	two 
check attr export 	seconds want 
ignore attr 	perform single 
export subst oid 	write guaranteed 
baselen len 	atomic least 
mode stage path 	filesystem writing 
args write 	real 
entry bottom sha 	physical one 
baselen filename 	save server 
mode stage context 	killed think 
path args 	much whole 
write entry check 	server stopping 
path without 	power 
prefix err sha 	problems alike 
filename mode 	want capture 
stage context sha 	different events 
filename mode 	delayed writes 
stage len 	delay happens 
ret sha filename 	pending 
mode stage 	fsync saving 
context next args 	child active 
write entry 	two conditions 
context opts err 	missing also 
len next 	use additional 
name sha filename 	name 
mode stage 	save samples 
context ret path 	useful graphing 
paths pathspec 	monitoring purposes 
ret pathspec args 	performed write 
argv args 	reset postponed 
prefix remote name 	flush 
commit sha 	sentinel zero 
archive time commit 	limit logging 
oid colon 	rate line 
refnamelen oid mode 	per aof 
err argc 	write log 
argv args 	error 
name hint remote 	rate seconds 
format remote 	log aof 
exec output compression 	write error 
level verbose 	record error 
list worktree attributes 	code ftruncate 
opts argc 	succeeded 
argv prefix setup 	nwritten since 
prefix name 	longer data 
hint remote nongit 	aof handle 
args filename 	aof write 
ext prefixlen filename 	error recover 
alloc grow 	fsync 
strbuf detach memmem 	policy always 
memchr strbuf 	since reply 
reset strbuf strbuf 	client already 
format commit 	output buffers 
message strbuf strbuf 	contract user 
release free 	acknowledged 
git attr 	write data 
git attr strbuf 	synced disk 
reset strbuf 	recover failed 
grow strbuf strbuf 	write leaving 
strbuf addstr 	data buffer 
isdir isgitlink strbuf 	however 
addch setup 	error stop 
archive check git 	accepting writes 
check attr 	error condition 
size attr attr 	cleared trim 
isdir isgitlink 	sds buffer 
write entry isdir 	write 
write entry 	way undo 
write archive entry 	ftruncate next 
strlen xmalloc 	call successful 
xsnprintf hashcpy write 	write aof 
directory write 	error state 
archive entry 	restore 
free strncmp free 	state log 
isdir queue 	use aof 
directory write directory 	buffer small 
write archive 	enough maximum 
entry write entry 	comes arena 
memset memset 	size 
init desc unpack 	minus overhead 
trees git 	otherwise arbitrary 
attr direction read 	fsync appendfsync 
recursive free 	rewrite yes 
strcmp isdir strbuf 	children background 
addbuf strbuf 	perform 
addstr match pathspec 	fsync needed 
strbuf release 	aof fsync 
parse pathspec read 	defined fdatasync 
recursive free 	linux order 
pathspec parse pathspec 	avoid flushing 
path exists 	metadata 
die strchrnul 	data disk 
dwim die free 	create sds 
sha die 	representation pexpireat 
lookup commit reference 	command seconds 
gently time 	time live 
parse indirect die 	cmd 
entry isdir 	understand command 
die parse indirect 	translating pexpireat 
parse options 	command used 
die die die 	order translate 
exit archive 	expire pexpire 
format filename usage 	commands 
options lookup 	pexpireat command 
archiver die die 	retain precision 
strlen setup 	append file 
git directory gently 	time always 
git config 	absolute relative 
git config init 	make 
tar archiver 	sure use 
init zip 	strtoll convert 
archiver parse archive 	argument milliseconds 
args setup 	expire setex 
git directory parse 	expireat convert 
treeish arg 	absolute 
parse pathspec arg 	time expire 
write archive 	pexpire setex 
strlen strlen strcmp 	psetex command 
match extension 	targeting last 
trailing slash setup 	command appended 
index instruct 	issue 
attr read index 	command needed 
must consistent 	translate expire 
parse pathspec path 	pexpire expireat 
exists also 	pexpireat translate 
pathspec patterns dependent 	setex psetex 
big trouble 	pexpireat 
test one separately 	commands need 
remotes allowed 	translation need 
fetch actual 	translation already 
refs need least 	operated command 
one parameter 	vector replication 
ish know die 	append 
error could 	aof buffer 
die error message 	flushed disk 
specific could 	entering loop 
write need character 	client positive 
character ensure 	reply operation 
prefix non empty 	performed 
match tar 	background append 
actual filename copyright 	file rewriting 
franck bui 	progress want 
huu copyright rene 	accumulate differences 
scharfe inject 	child current 
fake format field 	one 
beginning arguments 	buffer child 
format inferred 	process work 
output filename way 	append differences 
format options 	append file 
start reading spit 	aof loading 
stdout output 	redis 
file output argc 	commands always 
argv remote 	executed context 
exec name hint 	client order 
buf transport 	load append 
remote format argc 	file need 
argv prefix 	create 
exec output remote 	fake client 
local opts 	fake client 
open die errno 	slave waiting 
dup die 	synchronization redis 
errno close remote 	send replies 
die transport 	client 
transport connect archive 	replay append 
format filename 	log file 
packet write 	success returned 
packet write packet 	non fatal 
flush packet 	error append 
read line die 	file 
strcmp starts 	zero length 
die starts die 	err returned 
die packet 	fatal error 
read line die 	error message 
recv sideband 	logged program 
transport disconnect parse 	exists 
options create 	offset latest 
output file run 	well formed 
remote archiver 	command loaded 
setvbuf write archive 	temporarily disable 
trailing slash 	aof prevent 
setup index instruct 	exec 
attr read 	feeding multi 
index must consistent 	file read 
parse pathspec 	serve clients 
path exists 	time time 
also pathspec patterns 	free free 
dependent big 	free 
trouble test one 	discard crlf 
separately remotes 	command lookup 
allowed fetch actual 	run command 
refs need 	context fake 
least one parameter 	client fake 
ish know 	client 
die error could 	reply fake 
die error 	client never 
message specific could 	blocked clean 
write need 	command code 
character character ensure 	may 
prefix non 	changed argv 
empty match tar 	argc use 
actual filename 	argv argc 
copyright franck bui 	client instead 
huu copyright 	local variables 
rene scharfe 	point 
inject fake format 	reached eof 
field beginning 	reached without 
arguments format inferred 	errors client 
output filename 	middle multi 
way format options 	exec log 
start reading 	error 
spit stdout archive.c 	quit loaded 
archive usage 	cleanup caller 
archivers archivers alloc 	read error 
archivers remote 	feof fall 
allow unreachable commit 	unexpected eof 
src len 	unexpected 
buf free fmt 	aof end 
ctx sha 	file make 
file archive check 	sure aof 
attr export 	file descriptor 
ignore attr 	points end 
export subst oid 	file 
baselen len 	truncate call 
mode stage path 	format error 
args write 	aof rewrite 
entry bottom sha 	writing writing 
baselen filename 	bulk bulk 
mode stage context 	placed 
path args 	rio since 
write entry check 	adds redis 
path without 	dependency avoid 
prefix err sha 	decoded help 
filename mode 	copy write 
stage context sha 	often 
filename mode 	child process 
stage len ret 	function called 
sha filename 	emit commands 
mode stage context 	needed rebuild 
next args 	list function 
write entry 	returns 
context opts err 	error success 
len next 	emit commands 
name sha filename 	needed rebuild 
mode stage 	function returns 
context ret path 	error success 
paths pathspec 	emit 
ret pathspec args 	commands needed 
argv args 	rebuild sorted 
prefix remote name 	function returns 
commit sha 	error success 
archive time commit 	write either 
oid colon 	key 
refnamelen oid mode 	currently selected 
err argc 	item hash 
argv args name 	argument passes 
hint remote 	valid redis 
format remote exec 	hash iterator 
output compression 	filed 
level verbose 	specifies write 
list worktree attributes 	key either 
opts argc 	obj hash 
argv prefix setup 	key obj 
prefix name 	hash function 
hint remote nongit 	returns 
args filename 	error non 
ext prefixlen filename 	zero success 
alloc grow 	emit commands 
strbuf detach memmem 	needed rebuild 
memchr strbuf 	hash function 
reset strbuf strbuf 	returns 
format commit 	error success 
message strbuf strbuf 	function called 
release free 	child rewriting 
git attr git 	aof file 
attr strbuf 	read difference 
reset strbuf grow 	accumulated 
strbuf strbuf 	parent buffer 
strbuf addstr 	concatenated end 
isdir isgitlink strbuf 	rewrite pipe 
addch setup 	buffer size 
archive check git 	linux systems 
check attr 	write 
size attr attr 	sequence commands 
isdir isgitlink 	able fully 
write entry isdir 	rebuild dataset 
write entry 	filename used 
write archive entry 	rewriteaof bgrewriteaof 
strlen xmalloc 	order 
xsnprintf hashcpy write 	minimize number 
directory write 	commands needed 
archive entry free 	rewritten log 
strncmp free 	redis uses 
isdir queue directory 	variadic commands 
write directory 	possible 
write archive entry 	rpush sadd 
write entry 	zadd however 
memset memset 	max aof 
init desc unpack 	rewrite items 
trees git 	per cmd 
attr direction read 	items 
recursive free 	per time 
strcmp isdir strbuf 	inserted single 
addbuf strbuf 	command note 
addstr match pathspec 	use different 
strbuf release 	temp name 
parse pathspec read 	compared 
recursive free 	one used 
pathspec parse pathspec 	rewrite append 
path exists 	file background 
die strchrnul dwim 	function iterate 
die free 	writing every 
sha die lookup 	entry 
commit reference 	key already 
gently time 	expired skip 
parse indirect die 	save key 
entry isdir 	associated emit 
die parse indirect 	command key 
parse options 	save 
die die die 	expire time 
exit archive 	read diff 
format filename usage 	parent process 
options lookup 	time time 
archiver die die 	initial slow 
strlen setup 	fsync 
git directory gently 	parent still 
git config 	sending data 
git config init 	order make 
tar archiver 	next fsync 
init zip archiver 	faster read 
parse archive 	times 
args setup git 	data parent 
directory parse 	read forever 
treeish arg 	server may 
parse pathspec arg 	receive data 
write archive 	clients faster 
strlen strlen strcmp 	able 
match extension 	send data 
trailing slash setup 	child read 
index instruct 	data loop 
attr read index 	soon good 
must consistent 	chance data 
parse pathspec path 	come 
exists also 	looks like 
pathspec patterns dependent 	wasting time 
big trouble 	abort happens 
test one separately 	without data 
remotes allowed 	start counting 
fetch actual refs 	zero 
need least 	stop contiguous 
one parameter ish 	timeouts ask 
know die 	master stop 
error could 	sending diffs 
die error message 	read ack 
specific could 	server 
write need character 	seconds timeout 
character ensure 	normally reply 
prefix non empty 	asap lose 
match tar 	reply sure 
actual filename copyright 	child eventually 
franck bui 	terminated 
huu copyright rene 	read diff 
scharfe inject 	write received 
fake format field 	diff file 
beginning arguments 	make sure 
format inferred output 	data remain 
filename way 	output 
format options start 	buffers use 
reading spit 	rename make 
stdout output file 	sure file 
output argc 	changed atomically 
argv remote 	generate file 
exec name hint 	aof 
buf transport 	rewrite pipes 
remote format argc 	ipc handler 
argv prefix 	called aof 
exec output remote 	rewriting child 
local opts 	sends single 
open die errno 	signal 
dup die 	stop sending 
errno close remote 	buffer diffs 
die transport 	parent sends 
transport connect archive 	well acknowledge 
format filename 	send ack 
packet write packet 	inform 
write packet 	user since 
flush packet read 	side children 
line die 	use timeout 
strcmp starts 	kernel buffer 
die starts die 	write children 
die packet 	terminated 
read line die 	handler since 
recv sideband 	called one 
transport disconnect parse 	time rewrite 
options create 	create pipes 
output file run 	used parent 
remote archiver 	child 
setvbuf write archive 	process ipc 
trailing slash 	rewrite data 
setup index instruct 	pipe used 
attr read 	send aof 
index must consistent 	incremental diffs 
parse pathspec 	child 
path exists also 	two pipes 
pathspec patterns 	used children 
dependent big trouble 	signal finished 
test one 	rewrite data 
separately remotes 	written another 
allowed fetch actual 	parent 
refs need 	acknowledge understood 
least one parameter 	condition parent 
ish know 	children data 
die error could 	children parent 
die error 	ack children 
message specific could 	parent 
write need 	ack parent 
character character ensure 	children data 
prefix non 	non blocking 
empty match tar 	aof background 
actual filename 	rewrite rewriting 
copyright franck bui 	append 
huu copyright 	file background 
rene scharfe inject 	works user 
fake format 	calls bgrewriteaof 
field beginning arguments 	redis calls 
format inferred 	function forks 
output filename 	child 
way format options 	rewrite append 
start reading 	file temp 
spit stdout archive.h 	file parent 
baselen commit 	accumulates differences 
sha commit time 	server aof 
pathspec compression 	rewrite 
level name archiver 	buf child 
archiver args 	finished exists 
flags data archiver 	parent trap 
args write 	exit code 
entry argc argv 	append data 
prefix setup 	accumulated 
prefix name hint 	server aof 
remote filename 	rewrite buf 
sha file archive 	temp file 
archive argv-array.c 	rename temp 
empty argv fmt 	file actual 
arg argv 	file 
ret alloc 	name file 
grow argv push 	reopened append 
nodup xstrdup 	file profit 
start strbuf vaddf 	child parent 
end argv 	per second 
push nodup strbuf 	appendseldb 
detach start 	order force 
arg argv push 	next call 
end argv 	feed append 
push free free 	file issue 
free argv 	command differences 
init xcalloc argv 	accumulated 
init argv-array.h 	parent server 
empty argv argv 	aof rewrite 
argc alloc 	buf start 
argv argv argv 	statement safe 
fmt argv 	merge unreached 
argv argv 	update 
argv argv argv 	server aof 
attr.c git 	current size 
attr git attr 	field explicitly 
git attr 	stat check 
unknown next attr 	size file 
maybe macro 	useful 
maybe real name 	rewrite restart 
attr cannot 	normally size 
trust maybe real 	updated adding 
check attr 	write length 
attr name namelen 	current length 
name namelen 	much 
name len hval 	faster background 
pos name 	append file 
attr setto pattern 	rewriting bgrewriteaof 
patternlen nowildcardlen 	terminated work 
flags pat attr 	handle flush 
macro num 	differences 
attr state 	accumulated parent 
blank src lineno 	rewritten aof 
len line 	remaining thing 
src lineno macro 	rename temporary 
namelen num 	file configured 
attr name states 	file 
res macro 	file descriptor 
prev origin originlen 	used aof 
num matches 	writes want 
alloc attrs setto 	close rename 
builtin attr 	calls block 
res line src 	server 
lineno macro 	old file 
list res line 	deletion two 
lineno use 	possible scenarios 
index path macro 	aof disabled 
res buf 	one time 
lineno bufp path 	rewrite 
macro res 	temporary file 
buf lineno 	renamed configured 
path macro res 	file file 
elem match 	already exists 
attr elem system 	unlinked may 
wide path 	block 
dirlen elem info 	server aof 
len namelen 	enabled rewritten 
pathbuf pathname pathlen 	aof immediately 
basename offset 	start receiving 
pat baselen pattern 	writes temporary 
prefix isdir 	file 
attr rem rem 	renamed configured 
check attr 	file original 
path pathlen basename 	aof file 
offset stk 	descriptor closed 
rem rem stk 	since last 
path num 	reference 
check stk pathlen 	file closing 
rem dirlen 	causes underlying 
last slash 	file unlinked 
basename offset path 	may block 
num check 	server mitigate 
path num check 	blocking 
count git 	effect unlink 
attr direction hash 	operation either 
name memcmp 	caused rename 
invalid attr name 	scenario close 
flex alloc 	scenario use 
mem realloc git 	background 
attr strlen 	take care 
strcspn strchr invalid 	first make 
attr name 	scenario identical 
xmemdupz git attr 	scenario opening 
strspn strspn 	target file 
strcspn strlen starts 	exists 
strlen strspn 	unlink operation 
strcspn invalid attr 	rename executed 
name strspn 	upon calling 
parse attr 	close descriptor 
xcalloc git attr 	everything guarantee 
memcpy parse 	atomicity 
exclude pattern warning 	already happened 
parse attr 	care outcome 
free free free 	duration close 
free free 	operation file 
parse attr line 	descriptor released 
alloc grow 	aof 
xcalloc handle attr 	disabled care 
line fopen 	fails oldfd 
warn inaccessible xcalloc 	handle one 
fgets skip 	notable old 
utf bom strlen 	file exist 
handle attr 	aof 
line fclose read 	enabled current 
blob data 	aof filedes 
index xcalloc 	later rename 
handle attr line 	temporary file 
free read 	unlink target 
attr index read 	file 
attr file 	exists reference 
read attr file 	oldfd aof 
read attr 	disabled need 
index read attr 	aof file 
index xcalloc 	descriptor file 
attr attr attr 	close 
unset free 	aof enabled 
attr elem system 	replace old 
path git 	one make 
env git attr 	sure issued 
system read 	clear regular 
attr file git 	aof 
etc gitattributes 	buffer since 
xdg config home 	contents written 
read attr 	aof background 
file bare 	rewrite buffer 
repository read attr 	change state 
xstrdup debug 	wait 
push read attr 	rewrite needed 
file git 	asynchronously close 
path info attributes 	overwritten aof 
xcalloc bootstrap 	sigusr whitelisted 
attr stack strlen 	way kill 
strncmp debug 	child 
pop free attr 	without tirggering 
elem bare 	error conditon 
repository strlen memchr 	schedule rewrite 
strbuf strbuf 	waiting aof 
addch strbuf addstr 	arena.c opt 
read attr 	dirty 
strbuf setlen strbuf 	mult dirty 
detach debug 	mult arena 
push strbuf release 	bin info 
match basename 	map bias 
match pathname 	map misc 
debug macroexpand one 	offset 
path matches 	arena maxrun 
fill one fill 	large maxclass 
one prepare 	small maxrun 
attr stack fill 	small run 
collect attrs 	tab nlclasses 
collect attrs alloc 	nhclasses 
handle git 	arena arena 
attributes see gitattributes 	run dirty 
description file 	cleaned decommitted 
syntax documentation technical 	arena chunk 
api gitattributes 	run bin 
txt description api 	arena 
one basic 	chunk run 
design decision going 	bin size 
support insanely 	miscelm miscelm 
large number attributes 	miscelm chunk 
randomly chosen 	pageind mapbits 
prime attribute 	miscelm 
name cannot begin 	miscelm size 
must consist 	qsize size 
characters matched pattern 	large run 
decide exc 	size next 
flag one rule 	size qsize 
gitattributes file 	ret 
macro attr pointer 	miscelm qsize 
git attr 	qsize miscelm 
defined macro pattern 	arena chunk 
points filename 	pageind npages 
pattern rule applies 	arena chunk 
memory pointed 	pageind 
part memory block 	npages arena 
allocated match 	chunk pageind 
attr instance either 	npages miscelm 
num attr 	arena chunk 
number attributes 	pageind npages 
affected rule state 	miscelm 
listing attributes 	node arena 
listed appear file 	node cache 
macros unexpanded 	arena node 
parse whitespace delimited 	dirty run 
attribute state 	bin 
attr attr attr 	info ret 
attr starting 	regind miscelm 
src write results 	rpages run 
pointer remainder 	ptr chunk 
leading whitespace removed 	pageind mapbits 
error first 	binind 
pass count attr 	bin info 
states second 	regind chunk 
pass fill attr 	run ind 
states like 	npages chunk 
info exclude gitignore 	run ind 
attribute information 	chunk 
come many 	run ind 
places gitattribute file 	arena pages 
directory gitattribute 	sub pages 
file parent directory 	cactive diff 
match goes 	arena chunk 
recursively upwards like 	run 
gitignore git 	ind flag 
dir info attributes 	dirty flag 
overrides file 	decommitted need 
later entries earlier 	pages total 
match list 	pages rem 
would entries info 	pages 
attributes earliest 	flags flag 
reading file top 	unzeroed mask 
bottom gitattribute 	arena run 
root directory reading 	size zero 
file top 	chunk miscelm 
bottom current directory 	flag 
scan list 	dirty flag 
backwards find 	decommitted run 
first match exactly 	ind need 
excluded dir 	pages flag 
deal gitignore gitattributes 	unzeroed mask 
file might 	arena 
index allow operation 	run size 
sparsely work 	zero arena 
read bottom attribute 	run size 
stack built 	zero arena 
attribute definitions followed 	run size 
contents prefix 	binind 
etc gitattributes file 	chunk miscelm 
specified core 	flag dirty 
attributesfile contents gitattribute 	flag decommitted 
files directories 	run ind 
closer root ones 	need pages 
deeper directories 	flag 
pushed stack top 	unzeroed arena 
stack always 	chunk arena 
keep contents 	chunk zero 
git dir info 	arena chunk 
attributes checking 	hooks zero 
use entries near 	commit 
top stack 	chunk arena 
preferring git dir 	zero commit 
info attributes 	chunk chunk 
gitattributes deeper directories 	hooks arena 
shallower ones 	chunk zero 
use built pop 	commit 
info one 	flag unzeroed 
always top stack 	flag decommitted 
pop ones 	arena chunk 
directories prefix path 	arena chunk 
checking loop 	spare chunk 
see root one 	hooks 
whose origin 	committed arena 
empty builtin 	usize index 
one whose origin 	arena usize 
without popping 	index arena 
read parent directories 	usize index 
push bootstrap 	arena 
attr stack added 	usize index 
loop stopped 	arena oldsize 
popping root element 	usize arena 
whose attr 	oldsize usize 
stack origin empty 	arena node 
push info 	arena 
one top stack 	node arena 
collect attributes 	chunk hooks 
path pointed check 	usize alignment 
attr num 	zero csize 
non zero attributes 	ret commit 
check collected 	arena 
otherwise attributes collected 	usize alignment 
count number 	zero ret 
attributes attr.h 	chunk hooks 
git attr git 	csize arena 
attr attr 	chunk usize 
git attr path 	chunk 
git attr 	hooks csize 
check path num 	arena chunk 
check git 	oldsize usize 
attr direction attribute 	udiff udiff 
pointer opaque 	arena chunk 
structure given gitattribute 	oldsize 
corresponds use 	usize udiff 
check git attr 	cdiff chunk 
check results 	hooks nchunk 
send one git 	arena chunk 
attr check 	hooks chunk 
git check attr 	oldsize 
member tells 	usize zero 
unset one returned 	nchunk udiff 
name attribute 	cdiff err 
represented argument 	commit arena 
pointer delimited part 	chunk oldsize 
data structure 	usize 
modified freed retrieve 	zero err 
attributes apply 	chunk hooks 
specified path num 	nchunk udiff 
number attributes 	cdiff arena 
path check point 	size search 
newly allocated 	size 
git attr check 	key miscelm 
objects describing 	arena size 
attributes values check 	zero run 
must free 	arena size 
caller attr base85.c 	zero chunk 
dst buffer 	run 
len acc cnt 	arena size 
buf data 	binind run 
bytes acc cnt 	arena size 
val buf 	binind chunk 
len len 	run dirty 
size prep say 	mult 
error error 	arena dirty 
error say say 	mult arena 
say say 	dirty mult 
say strcmp strlen 	arena threshold 
encode strcmp 	arena ndirty 
decode strcmp encode 	rdelm 
nothing nothing 	chunkselm npages 
nothing detect overflow 	chunk miscelm 
basename.c path 	pageind arena 
path buf dos 	npurge threshold 
drive prefix 	arena chunk 
tentative skip dos 	hooks 
drive prefix 	npurge purge 
dir sep dir 	runs sentinel 
sep dir 	purge chunks 
sep skip dos 	sentinel rdelm 
drive prefix 	rdelm next 
dir sep 	chunkselm 
dir sep dir 	nstashed npages 
sep dir 	chunkselm next 
sep strbuf reset 	zero chunk 
strbuf addf 	chunk miscelm 
adapted libiberty basename 	pageind run 
posix says 	run 
dirname dirname dirname 	size arena 
posix says 	chunk hooks 
ignore trailing slashes 	purge runs 
bisect--helper.c git 	sentinel purge 
bisect helper usage 	chunks sentinel 
argc argv 	npurged 
prefix next checkout 	nmadvise rdelm 
options parse 	chunkselm npages 
options usage options 	size pageind 
bisect next 	run size 
next bisect.c 	flag unzeroed 
good revs skipped 	flags 
revs current 	decommitted chunk 
bad oid argv 	miscelm arena 
checkout argv 	chunk hooks 
show branch term 	purge runs 
bad term 	sentinel purge 
good entry commit 	chunks 
list commit 	sentinel rdelm 
elem elem weight 	rdelm next 
commit count 	chunkselm chunkselm 
debug counted list 	next addr 
commit flags 	size zeroed 
size buf subject 	committed 
start subject 	chunk miscelm 
len list best 	pageind decommitted 
best distance 	run arena 
distance flags commit 	chunk hooks 
distance list 	npurge npurgeable 
cnt distance 	npurged 
flags buf obj 	purge runs 
list weights 	sentinel purge 
find counted commit 	chunks sentinel 
flags flags 	ndirty arena 
list reaches find 	arena chunk 
list best 	size 
next last weights 	run ind 
flags refname 	run pages 
oid flags data 	flag dirty 
good prefix 	flag decommitted 
delim joined hexs 	size run 
list tried 	ind 
show count skipped 	run pages 
first next 	nrun size 
count val list 	nrun pages 
count cur 	prun size 
previous prn index 	prun pages 
list tried 	arena 
count skipped 	chunk run 
first revs prefix 	run ind 
bad format 	size bin 
good format read 	info arena 
paths rev 	chunk run 
argv revs tried 	miscelm 
bad oid 	run ind 
filename str res 	offset length 
bisect rev 	arena run 
checkout bisect rev 	dirty cleaned 
hex res 	decommitted chunk 
sha rev rev 	miscelm 
bad hex 	size run 
good hex hex 	ind run 
bad hex 	pages flag 
good hex checkout 	dirty flag 
result rev 	decommitted flags 
rev prefix revs 	arena 
pending copy 	chunk run 
res prefix 	committed arena 
checkout filename prefix 	chunk run 
commit opt 	oldsize newsize 
read bad read 	miscelm pageind 
good str 	head 
filename prefix checkout 	npages flag 
revs tried 	dirty flag 
steps bisect rev 	decommitted flag 
log count 	unzeroed mask 
distance weight read 	tail npages 
sha file 	arena 
weight sha hex 	chunk run 
sha hex 	oldsize newsize 
find commit subject 	dirty miscelm 
weight oidcmp 	pageind head 
xcalloc weight qsort 	npages flag 
snprintf name 	dirty 
decoration free 	flag decommitted 
count interesting parents 	flag unzeroed 
weight show 	mask tail 
list weight weight 	miscelm tail 
show list 	run tail 
weight weight count 	npages 
distance clear 	bin miscelm 
distance halfway show 	bin run 
list weight 	miscelm bin 
weight weight weight 	run miscelm 
show list 	bin run 
weight weight halfway 	arena 
show list 	bin run 
best bisection best 	binind bin 
bisection sorted 	info arena 
show list show 	bin binind 
list xcalloc 	bin info 
find bisection weight 	run 
free strbuf 	ret chunk 
addstr strbuf 	arena tbin 
addstr strcmp xmalloc 	binind prof 
oidcpy starts 	accumbytes nfill 
sha append starts 	bin run 
sha append 	ptr 
strbuf release strbuf 	ptr bin 
getline strbuf 	info zero 
trim dequote argv 	redzone size 
die strbuf 	ptr usize 
release fclose strbuf 	offset arena 
addstr sha 	redzone 
hex strbuf addch 	corruption ptr 
strbuf detach 	bin info 
sha lookup prn 	reset error 
sqrti sqrti 	size redzone 
oidcmp filter skipped 	size ptr 
skip away 	bin 
init revisions argv 	info redzone 
push argv 	size arena 
pushf oid 	dalloc junk 
hex argv pushf 	small ptr 
sha hex 	usize binind 
argv push read 	bin 
bisect paths 	info arena 
setup revisions prepare 	size zero 
revision walk 	ret bin 
die mark edges 	run binind 
uninteresting print 	arena size 
commit list oid 	zero 
hex exit 	ret usize 
git path bisect 	random offset 
expected rev 	run miscelm 
stat isreg fopen 	idump index 
strbuf getline 	tsd arena 
strcmp oid hex 	usize 
strbuf release 	alignment zero 
fclose memcpy sha 	ret alloc 
hex update 	size leadsize 
update run 	trailsize run 
command opt exit 	chunk miscelm 
run command 	rpages 
opt lookup commit 	head miscelm 
reference die 	head run 
sha hex alloc 	run ind 
commit reference 	dirty decommitted 
commit reference expected 	index tsd 
rev oid 	arena 
hex sha hex 	usize alignment 
strcmp strcmp 	zero tcache 
strcmp strcmp exit 	ret ptr 
exit sha 	size chunk 
hex sha hex 	pageind binind 
sha hex 	chunk 
warning free bad 	run bin 
good commits 	binind bin 
merge bases 	info arena 
many hashcmp handle 	chunk run 
bad merge 	bin arena 
sha lookup sha 	chunk 
lookup handle 	run bin 
skipped merge exit 	arena chunk 
bisect checkout 	ptr bitselm 
free free commit 	junked pageind 
list bisect 	rpages ind 
rev setup bisect 	run 
common clear 	bin bin 
commit marks free 	info binind 
git pathdup 	arena chunk 
die stat isreg 	ptr bitselm 
check ancestors 	arena chunk 
check merge bases 	ptr 
open warning 	pageind bitselm 
strerror close free 	run bin 
init revisions 	rpages ind 
git config 	arena chunk 
log commit git 	ptr pageind 
path fopen 	bitselm 
die strerror strbuf 	ptr usize 
getline strbuf 	arena dalloc 
detach strbuf getline 	junk large 
strbuf detach 	arena chunk 
strbuf release fclose 	ptr junked 
read bisect 	pageind 
terms read bisect 	miscelm run 
refs die 	usize index 
check good ancestors 	arena chunk 
bad bisect 	ptr arena 
rev setup bisect 	chunk ptr 
common find 	arena 
bisection managed skipped 	chunk ptr 
exit skipped 	oldsize size 
commits oid hex 	pageind miscelm 
exit exit 	run oldindex 
hashcmp exit 	index arena 
skipped commits sha 	chunk 
hex show 	ptr oldsize 
diff exit estimate 	usize min 
bisect steps 	usize max 
bisect checkout log 	zero pageind 
exp remember 	npages followsize 
update flag allocation 	run 
truly stupid 	usize splitsize 
algorithm used bisection 	size flag 
care enough 	dirty flag 
care barely enough 	unzeroed mask 
avoid recursing 	oldindex index 
non merge entries 	ptr 
cut something 	old usize 
going halfway halfway 	usize arena 
debug bisect 	ralloc junk 
desc sort enough 	large ptr 
dist zero 	oldsize usize 
positive weight 	min 
number interesting commits 	usize max 
reach including 	zero chunk 
especially weight means 	arena ret 
reach changing 	ptr oldsize 
commits uninteresting one 	size extra 
traversal pathspec 	zero 
weight means one 	usize min 
parent distance 	usize max 
yet computed weight 	tsd arena 
means one 	usize alignment 
parent distance unknown 	zero tcache 
running count 	tsd 
distance first zero 	arena ptr 
positive distance 	oldsize size 
otherwise known reach 	alignment zero 
changing commit 	tcache ret 
gets weight one 	usize copysize 
parent resulting 	arena 
reach one 	ret arena 
commit parent reach 	dss prec 
run expensive 	dirty mult 
count distance single 	arena dss 
strand pearls 	dirty mult 
however one parents 	nactive 
cannot distance 	ndirty astats 
one since usually 	bstats lstats 
reach ancestor 	hstats bin 
would end counting 	ind arena 
twice way 	bin bin 
first count distance 	info 
merges usual 	pad size 
way fill blanks 	run size 
cheaper algorithm 	perfect run 
happen exactly half 	size actual 
way weight 	run size 
unknown known 	nregs 
one counted otherwise 	perfect nregs 
inherit directly 	actual nregs 
happen exactly half 	align min 
way count 	bin info 
number total changing 	header size 
items list 	arena 
reversing list real 	arena arena 
work finding 	arena chunk 
bisection commit function 	map misc 
passing skipped 	arena mapbits 
first special means 	size encode 
want know 	arena 
first commit list 	miscelm key 
skipped want 	arena mapbits 
test commit away 	size decode 
indeed skipped 	arena miscelm 
first commit skipped 	key chunk 
cannot take 	addr 
shortcut list 	arena miscelm 
find first non 	pageind arena 
skipped commit 	mapbits arena 
fully filtered list 	mapbits size 
use skipped 	decode page 
first mean found 	ceiling 
first commit 	index size 
skipped skipped first 	size index 
back function 	run quantize 
returns move current 	page ceiling 
tried list 	page 
means know skipped 	ceiling index 
move current 	size size 
filtered list pseudo 	index run 
random number 	quantize run 
generator man rand 	quantize next 
used properly 	run 
seed argument increased 	quantize arena 
one call 	miscelm key 
matter application 	arena miscelm 
custom integer square 	key size 
root http 	arena miscelm 
wikipedia wiki integer 	size 
square root 	run quantize 
rev argv argv 	arena miscelm 
ignored setup 	size arena 
revisions xxx leak 	miscelm key 
rev argv 	arena mapbits 
revs may still 	unallocated 
pointing check 	size arena 
merge bases checks 	avail insert 
merge bases 	arena miscelm 
bad one bad 	arena mapbits 
means user 	unallocated size 
assumed something wrong 	arena 
must exit 	avail arena 
non error code 	miscelm arena 
one good 	miscelm arena 
old good 	mapbits unallocated 
nothing one skipped 	size arena 
know warn 	mapbits 
know check ask 	dirty arena 
user test 	mapbits dirty 
save pending objects 	meld arena 
cleaned later 	miscelm arena 
bisect common calls 	mapbits unallocated 
prepare revision 	size 
walk right away 	arena mapbits 
together leak 	dirty arena 
pending makes sole 	mapbits dirty 
owner list 	extent node 
pending objects clean 	size extent 
objects used 	node 
reused check good 	dirty linkage 
ancestors bad 	init extent 
checks good 	node dirty 
revs ancestor bad 	insert arena 
rev need 	chunk dirty 
check merge bases 	npages 
merge must 	extent node 
tested user source 	dirty arena 
code tested 	chunk dirty 
user exit check 	npages arena 
file bisect 	chunk dirty 
ancestors exists bisecting 	npages 
good rev 	bitmap full 
check good revs 	bitmap sfu 
ancestor bad 	arena run 
rev create file 	miscelm arena 
bisect ancestors 	miscelm rpages 
git diff pretty 	uintptr 
commit without 	chunk addr 
one fork exec 	arena mapbits 
diff init 	arena ptr 
diff options 	small binind 
pretty diff init 	arena run 
terms used 	regind 
bisect session stored 	arena miscelm 
bisect terms 	rpages arena 
read store adapt 	run miscelm 
messages accordingly 	arena miscelm 
bad good use 	rpages arena 
convention exiting 	run 
exit code means 	miscelm bitmap 
bisection process 	bitmap unset 
finished successfully calling 	jemalloc valgrind 
shell script 	make mem 
exit checkout non 	undefined memset 
zero bisection 	jemalloc 
process checkout trial 	valgrind make 
commit instead 	mem defined 
simply updates bisect 	size arena 
head exit 	run page 
bad commit 	mark zeroed 
also skip commit 	chunk 
means bisection 	ceiling chunk 
process succeeded estimate 	ceiling stats 
number bisect 	cactive arena 
steps left current 	mapbits unallocated 
step included 	size arena 
excluded probability steps 	mapbits 
left looks 	dirty arena 
like means bisect.h 	avail arena 
list reaches 	run dirty 
find list tried 	arena cactive 
show count 	update arena 
skipped first revs 	mapbits 
flags show 	unallocated arena 
timestamp hdr termination 	mapbits unzeroed 
header prefix 	arena mapbits 
prefix checkout bad 	unallocated arena 
good bitmap.c 	mapbits unzeroed 
bitmap self 	arena 
pos block old 	run dirty 
size self 	insert arena 
pos block self 	avail insert 
pos block 	chunk addr 
bitmap ewah running 	arena run 
empty words 	miscelm 
last word ewah 	arena miscelm 
bitmap blowup 	pageind arena 
self count self 	mapbits dirty 
original size 	arena mapbits 
word self callback 	decommitted commit 
data word 	arena 
offset self count 	run split 
self big 	jemalloc valgrind 
small bitmap bitmap 	make mem 
xmalloc xcalloc 	defined arena 
ewah block 	run zero 
realloc memset ewah 	arena 
mask ewah 	mapbits unzeroed 
block ewah mask 	arena run 
ewah block 	zero arena 
ewah mask ewah 	run page 
ewah ewah 	validate zeroed 
empty words ewah 	arena 
bitmap ewah 	run page 
iterator init ewah 	mark zeroed 
iterator next 	jemalloc valgrind 
alloc grow realloc 	make mem 
memset ewah 	undefined arena 
iterator init ewah 	mapbits 
iterator next 	large arena 
callback ewah bit 	mapbits unzeroed 
ctz callback 	arena mapbits 
ewah bit popcount 	large arena 
memset free 	mapbits unzeroed 
free copyright 	arena 
git hub inc 	run split 
copyright daniel 	large helper 
lemire cliff moon 	arena run 
david intosh 	split large 
robert becho google 	helper chunk 
inc veronika 	addr 
zenz program free 	arena run 
software redistribute 	miscelm arena 
modify terms gnu 	miscelm pageind 
general license 	arena mapbits 
published free software 	dirty arena 
foundation either 	mapbits 
version license option 	decommitted commit 
later version 	arena run 
program distributed hope 	split arena 
useful without 	mapbits unzeroed 
warranty without even 	arena mapbits 
implied warranty 	small 
merchantability fitness 	arena run 
particular purpose see 	page validate 
gnu general 	zeroed jemalloc 
license details received 	valgrind make 
copy gnu 	mem undefined 
general license along 	arena 
program write 	mapbits allocated 
free software foundation 	arena mapbits 
inc franklin 	allocated arena 
street fifth floor 	mapbits unallocated 
boston usa 	size arena 
blame.c blame usage 	mapbits 
blame opt 	unallocated size 
usage longest file 	arena mapbits 
longest author 	dirty arena 
max orig digits 	mapbits dirty 
max digits 	extent node 
max score digits 	init 
show root 	extent node 
reverse blank 	achunk chunk 
boundary incremental xdl 	malloc mutex 
opts abbrev 	unlock chunk 
whole file rename 	alloc wrapper 
show progress 	commit 
blame date mode 	chunk dalloc 
blame date 	wrapper arena 
width mailmap num 	chunk decommit 
read blob 	chunk dalloc 
num patch num 	wrapper malloc 
commits blame 	mutex 
move score blame 	chunk alloc 
copy score 	cache arena 
refcnt previous next 	chunk chunk 
commit suspects 	dalloc cache 
file blob sha 	arena chunk 
mode guilty 	alloc 
path progress blamed 	hard arena 
lines file 	chunk alloc 
file ctxlen 	arena mapbits 
hunk func data 	unallocated jemalloc 
xpp xecfg 	valgrind make 
ecb path mode 	mem 
sha sha 	undefined arena 
valid buf buf 	bitselm size 
size textconv 	arena bitselm 
opt file file 	arena bitselm 
size next 	arena mapbits 
lno num lines 	jemalloc 
suspect lno 	valgrind make 
score list list 	mem defined 
tail head 	arena bitselm 
compare commits revs 	size arena 
path buf 	bitselm arena 
buf size ent 	bitselm 
num lines 	arena mapbits 
lineno scoreboard 	unzeroed arena 
ent next porigin 	mapbits unallocated 
sorted commit 	arena chunk 
path commit path 	init spare 
origin parent 	arena 
origin porigin diff 	chunk init 
opts paths 	hard arena 
name parent origin 	avail insert 
porigin diff 	arena mapbits 
opts queue queue 	allocated arena 
dst src 	mapbits 
lno data lno 	allocated arena 
split tlno 	mapbits unallocated 
plno parent chunk 	size arena 
end lno 	mapbits unallocated 
blamed unblamed split 	size arena 
entry split 	mapbits 
head tail next 	dirty arena 
dstq srcq 	mapbits dirty 
tlno offset 	arena mapbits 
parent diffp next 	decommitted arena 
len next 	mapbits decommitted 
len parent offset 	arena 
dstq srcq 	avail arena 
start count start 	mapbits dirty 
count data 	arena run 
target parent file 	dirty chunk 
file newdest 	deregister arena 
score best far 	mapbits 
ent tlno 	decommitted chunk 
plno parent split 	hooks decommit 
ent parent 	chunk dalloc 
split plno tlno 	cache size 
start count 	index cassert 
start count data 	size 
ent parent 	index cassert 
split file file 	size index 
small source 	cassert size 
score min 	index cassert 
oldsmall blamed toosmall 	arena huge 
target parent 	dalloc 
split unblamed leftover 	stats update 
file unblamedtail 	arena huge 
next ent split 	malloc stats 
unblamed num 	update arena 
ents num ents 	huge dalloc 
blame list 	stats 
blamed toosmall target 	update undo 
parent porigin 	arena huge 
opt diff opts 	malloc stats 
blame list 	update undo 
num ents unblamed 	malloc mutex 
leftover unblamedtail 	last 
norigin file split 	malloc mutex 
origin porigin 	unlock alloc 
suspects revs commit 	tail malloc 
revs commit 	mutex unlock 
blamed porigin 	malloc mutex 
suspects next origin 	elm 
opt revs 	tail insert 
pass num commit 	malloc mutex 
buf porigin 	unlock chunk 
origin toosmall blames 	alloc wrapper 
blametail scoreboard 	malloc mutex 
commit origin porigin 	arena 
porigin porigin 	huge malloc 
tail author author 	stats update 
mail author 	undo malloc 
time author committer 	mutex unlock 
committer mail 	chunk ceiling 
committer time committer 	malloc 
summary inbuf 	mutex arena 
name mail time 	huge malloc 
ident len 	stats update 
maillen namelen 	chunk alloc 
tmp endp namebuf 	cache malloc 
mailbuf commit 	mutex 
ret detailed len 	unlock arena 
subject encoding 	chunk alloc 
message path suspect 	huge hard 
repeat prev 	stats cactive 
ent suspect opt 	chunk ceiling 
revs commit 	malloc 
ent suspect next 	mutex arena 
time str 	huge dalloc 
show raw time 	stats update 
time buf 	stats cactive 
time str time 	sub chunk 
width suspect 	dalloc 
repeat ent opt 	cache malloc 
repeat cnt 	mutex unlock 
suspect hex ent 	chunk ceiling 
opt cnt 	chunk ceiling 
suspect hex 	malloc mutex 
show raw time 	arena 
length name 	huge ralloc 
name pad option 	stats update 
ent count 	stats cactive 
suspect commit start 	stats cactive 
end buf 	sub malloc 
len end lineno 	mutex 
num graft 	unlock chunk 
file buf graft 	ceiling chunk 
abbrev suspect 	ceiling malloc 
uniq len option 	mutex arena 
longest src 	huge ralloc 
lines longest dst 	stats 
lines largest 	update stats 
score compute abbrev 	cactive sub 
abbrev suspect 	chunk ceiling 
num baa ent 	chunk dalloc 
opt arg 	cache malloc 
end score 	mutex 
prefix path output 	unlock chunk 
option work 	alloc wrapper 
path parents commit 	malloc mutex 
sha blob 	arena huge 
sha mode tail 	ralloc stats 
sha parent 	update 
tail merge head 	undo malloc 
line sha 	mutex unlock 
len buf opt 	merge chunk 
path contents 	ceiling chunk 
commit origin parent 	dalloc arena 
tail parent 	chunk 
head sha buf 	hooks chunk 
ident size 	ceiling chunk 
len mode msg 	ceiling chunk 
read buf 	ceiling malloc 
ptr buf len 	mutex arena 
pos revs 	huge 
name found 	ralloc stats 
name obj name 	update chunk 
commit name 	alloc cache 
revs obj option 	malloc mutex 
arg unset 	unlock arena 
opt option arg 	chunk 
unset opt 	ralloc huge 
argc argv prefix 	expand hard 
revs path 	merge chunk 
ent dashdash pos 	ceiling chunk 
lno commit 	dalloc arena 
name commit range 	stats 
list opt 	cactive run 
show stats revs 	quantize first 
file contents 	arena miscelm 
options ctx cmd 	key create 
annotate ranges 	arena avail 
range anchor 	nsearch 
bottom top bottom 	arena run 
top next 	first best 
xdi diff alloc 	fit arena 
filespec fill 	run split 
filespec textconv free 	large page 
filespec fill 	ceiling 
textconv free filespec 	arena run 
diff opt 	alloc large 
tst textconv read 	helper arena 
sha file 	chunk alloc 
die sha hex 	arena miscelm 
origin decref 	arena 
free free die 	run split 
free llist 	large arena 
mergesort compare commits 	run alloc 
commit date 	large helper 
origin decref free 	arena run 
sanity check 	first 
refcnt blame 	best fit 
merge prio queue 	arena run 
put flex 	split small 
alloc str strcmp 	page ceiling 
origin incref 	arena run 
make origin sha 	alloc 
entry sha 	small helper 
info hashclr strcmp 	arena chunk 
origin incref 	alloc arena 
diff setup diff 	miscelm arena 
opt parse 	run split 
pathspec diff setup 	small 
done oid 	arena run 
diff cache diff 	alloc small 
sha diffcore 	helper ssize 
std origin hashcpy 	malloc mutex 
strcmp die 	malloc mutex 
die origin hashcpy 	unlock 
diff flush 	arena dirty 
free pathspec 	mult valid 
diff setup diff 	malloc mutex 
opt diff 	arena maybe 
setup done oid 	purge malloc 
diff cache 	mutex 
diff sha diffcore 	unlock arena 
std strcmp 	purge next 
origin hashcpy diff 	next extent 
flush free 	node size 
pathspec origin incref 	next chunk 
origin incref 	addr 
origin decref memcpy 	arena miscelm 
nth line 	arena miscelm 
memset origin incref 	pageind arena 
origin incref 	mapbits allocated 
origin incref dup 	arena mapbits 
entry xmalloc 	large 
memcpy blame entry 	arena mapbits 
xmalloc memcpy 	dirty arena 
blame entry 	mapbits unallocated 
dup entry dup 	size next 
entry xmalloc 	next next 
memcpy blame entry 	chunk 
dup entry 	alloc cache 
xmalloc memcpy blame 	extent node 
entry origin 	addr extent 
decref xcalloc origin 	node size 
decref origin 	extent node 
incref reverse blame 	addr 
reverse blame 	extent node 
xcalloc origin incref 	zeroed extent 
reverse blame 	node dirty 
reverse blame die 	insert extent 
blame chunk 	node size 
fill origin blob 	chunk 
fill origin 	addr arena 
blob diff hunks 	miscelm arena 
die oid 	miscelm pageind 
hex oid 	arena mapbits 
hex blame chunk 	unallocated 
queue blames 	size arena 
nth line nth 	mapbits dirty 
line isalnum 	arena mapbits 
ent score ent 	dirty arena 
score origin 	chunk alloc 
incref decref split 	arena 
memcpy split 	run split 
overlap copy split 	large next 
better decref 	prev meld 
split handle split 	malloc mutex 
memset nth 	unlock next 
line nth line 	next 
memset diff 	extent node 
hunks die oid 	size next 
hex handle 	chunk addr 
split ent 	arena miscelm 
score fill origin 	arena miscelm 
blob find 	pageind 
copy blob ent 	arena mapbits 
score split 	large size 
blame decref split 	arena mapbits 
filter small 	decommitted arena 
reverse blame xcalloc 	mapbits decommitted 
diff setup 	decommit 
diff opt diff 	chunk purge 
setup done 	wrapper arena 
strcmp diff opt 	mapbits large 
oid diff 	arena mapbits 
cache diff sha 	large arena 
diff opt 	mapbits 
tst diffcore std 	malloc mutex 
setup blame 	next next 
list diff file 	next extent 
valid isgitlink 	node addr 
strcmp origin 	extent node 
hashcpy fill origin 	size 
blob find 	extent node 
copy blob copy 	zeroed extent 
split better 	node committed 
decref split origin 	extent node 
decref ent 	dirty arena 
score split blame 	node 
decref split 	dalloc chunk 
free filter small 	dalloc arena 
reverse blame 	chunk addr 
diff flush free 	arena miscelm 
pathspec origin 	arena miscelm 
incref origin decref 	pageind 
queue blames 	arena mapbits 
free commit list 	decommitted arena 
lookup decoration 	run dalloc 
first scapegoat commit 	chunk hooks 
list count 	arena dirty 
blame sort 	count 
reverse blame queue 	arena compute 
blames num 	npurge extent 
scapegoats size memset 	node dirty 
xcalloc parse 	linkage init 
commit find hashcmp 	arena stash 
pass whole 	dirty 
blame origin decref 	arena purge 
hashcmp origin 	stashed arena 
decref origin incref 	unstash purged 
pass blame 	malloc mutex 
parent filter small 	arena purge 
find move 	malloc 
parent filter small 	mutex unlock 
blame merge 	arena mapbits 
filter small find 	allocated arena 
copy parent 	mapbits dirty 
distribute blame drop 	arena mapbits 
origin blob 	decommitted 
origin decref 	arena mapbits 
drop origin blob 	unallocated size 
free strstr 	arena mapbits 
strlen strchr strlen 	unallocated size 
split ident 	arena mapbits 
line strbuf addstr 	dirty 
strbuf addstr 	arena mapbits 
strbuf addstr strtoul 	decommitted arena 
strbuf strbuf 	avail arena 
addstr map user 	run dirty 
strbuf addf 	arena mapbits 
strbuf strbuf init 	unallocated 
strbuf init 	size arena 
strbuf init strbuf 	mapbits unallocated 
init strbuf 	size arena 
init strbuf init 	mapbits allocated 
strbuf init 	arena mapbits 
strbuf release 	dirty 
strbuf release strbuf 	arena mapbits 
release strbuf 	decommitted arena 
release strbuf release 	mapbits unallocated 
strbuf release 	size arena 
strbuf release commit 	mapbits unallocated 
info init 	size 
log output encoding 	arena mapbits 
logmsg reencode 	dirty arena 
line unuse commit 	mapbits decommitted 
buffer line 	arena avail 
find commit subject 	arena run 
strbuf strbuf 	dirty 
addf oid hex 	arena mapbits 
unuse commit 	unallocated size 
buffer write name 	arena mapbits 
quoted commit 	unallocated size 
info oid hex 	arena mapbits 
write name 	large 
quoted commit 	arena mapbits 
info destroy oid 	large size 
hex emit 	arena mapbits 
one suspect detail 	large size 
write filename 	arena run 
info maybe flush 	miscelm 
die display 	arena miscelm 
progress prio queue 	pageind arena 
start progress 	run size 
delay prio queue 	decommit chunk 
origin incref 	addr arena 
parse commit pass 	run 
blame mark 	miscelm arena 
parents uninteresting found 	miscelm pageind 
guilty entry 	arena run 
origin decref sanity 	size arena 
check refcnt 	cactive update 
stop progress strbuf 	arena 
reset strbuf 	mapbits dirty 
addf atoi 	arena mapbits 
show date strbuf 	dirty arena 
addstr utf 	mapbits dirty 
strwidth strbuf addch 	arena mapbits 
emit one 	unallocated 
suspect detail write 	arena mapbits 
filename info 	unallocated arena 
sha hex emit 	mapbits unallocated 
porcelain details 	arena mapbits 
nth line emit 	unzeroed arena 
porcelain details 	mapbits 
putchar putchar putchar 	unallocated arena 
commit info 	mapbits unzeroed 
sha hex nth 	arena run 
line memset 	coalesce arena 
putchar format time 	mapbits unallocated 
utf strwidth 	size 
format time putchar 	arena mapbits 
putchar commit 	unallocated size 
info destroy 	arena mapbits 
emit porcelain emit 	dirty arena 
memchr next 	mapbits dirty 
line alloc next 	arena 
line fopen 	mapbits decommitted 
strbuf getwholeline read 	arena mapbits 
graft line 	decommitted arena 
commit graft fclose 	avail insert 
strbuf release 	arena run 
find unique abbrev 	dirty 
strlen update 	insert arena 
abbrev strcmp strlen 	chunk dalloc 
commit info 	arena maybe 
utf strwidth utf 	purge arena 
strwidth commit 	run decommit 
info destroy ent 	arena 
score ent 	run dalloc 
score width 	arena run 
width width oid 	miscelm arena 
hex find 	miscelm pageind 
alignment output die 	arena mapbits 
strtoul prefix 	dirty 
path strlen strcmp 	arena mapbits 
git config 	decommitted arena 
strcmp git config 	mapbits large 
strcmp git 	size arena 
config strcmp config 	mapbits large 
error nonbool 	arena 
parse date format 	mapbits unzeroed 
userdiff config 	arena mapbits 
git config entry 	large arena 
sha info 	mapbits unzeroed 
die lookup commit 	arena mapbits 
reference die 	large 
sha hex commit 	size arena 
list insert 	mapbits dirty 
open git 	arena mapbits 
path merge head 	large arena 
die git 	mapbits unzeroed 
path merge head 	arena 
strbuf getwholeline 	run dalloc 
sha hex die 	arena run 
git path 	miscelm arena 
merge head append 	miscelm pageind 
parent close 	arena mapbits 
strbuf release strbuf 	dirty 
detach commit 	arena mapbits 
buffer time alloc 	decommitted arena 
commit node 	mapbits large 
resolve die append 	size arena 
parent append 	mapbits large 
merge parents verify 	arena 
working path 	mapbits unzeroed 
make origin fmt 	arena mapbits 
ident strbuf 	large arena 
addstr strbuf 	mapbits unzeroed 
addf oid hex 	arena mapbits 
strbuf addf 	large 
strcmp commit buffer 	size arena 
strbuf strcmp 	mapbits dirty 
stat die errno 	arena mapbits 
lstat die 	large arena 
errno canon mode 	mapbits unzeroed 
diff opt 	arena 
tst textconv strbuf 	miscelm arena 
attach strbuf 	run dalloc 
read file die 	arena run 
errno strbuf 	first arena 
readlink die errno 	run miscelm 
die strbuf 	arena 
read die errno 	run search 
convert git 	arena run 
pretend sha file 	insert arena 
discard cache 	run miscelm 
read cache 	arena run 
strlen cache name 	search 
pos cache 	arena run 
entry size xcalloc 	arena bin 
hashcpy memcpy 	runs first 
create flags create 	arena bin 
mode cache 	runs arena 
entry cache invalidate 	bin 
path deref 	nonfull run 
tag die die 	tryget arena 
find single 	bin index 
xstrdup deref tag 	malloc mutex 
die die 	unlock malloc 
die xstrdup parse 	mutex 
score parse 	arena run 
score strcmp git 	alloc small 
config init 	bitmap init 
revisions diff opt 	malloc mutex 
diff opt 	unlock malloc 
parse options 	mutex 
start parse options 	arena bin 
step exit 	nonfull run 
strcmp parse revision 	tryget arena 
opt diff 	bin index 
opt tst diff 	arena bin 
opt clr 	nonfull 
parse options end 	run arena 
die isatty 	run reg 
read ancestry die 	alloc chunk 
errno utf 	addr arena 
strwidth strlen show 	dalloc bin 
date diff 	run 
opt tst usage 	arena bin 
options prefix 	lower run 
usage options usage 	arena run 
options prefix 	reg alloc 
file exists 	arena prof 
prefix setup work 	accum 
file exists 	prof idump 
die errno setup 	malloc mutex 
revisions memset 	arena run 
prepare die prepare 	reg alloc 
initial setup 	arena bin 
work fake working 	malloc 
commit pending 	hard memmove 
die find single 	unlikely arena 
die prepare 	alloc junk 
revision walk die 	small malloc 
oidcmp xcalloc 	mutex unlock 
decoration die oidcmp 	memset 
die oid 	memset memset 
xmemdupz origin fill 	malloc jemalloc 
blob sha 	arena redzone 
mode die diff 	corruption arena 
opt tst 	redzone corruption 
textconv read 	abort 
sha file die 	arena redzones 
sha hex 	validate memset 
prepare lines list 	jemalloc cassert 
append xstrdup 	size index 
range init parse 	arena redzones 
range arg 	validate 
usage die range 	size index 
append sort 	index size 
merge range xcalloc 	malloc mutex 
origin incref 	arena run 
prio queue put 	reg alloc 
origin decref 	arena 
range release list 	bin malloc 
clear read 	hard malloc 
mailmap assign blame 	mutex unlock 
setup pager 	malloc mutex 
free blame sort 	unlock arena 
coalesce find 	prof 
alignment output 	accum prof 
free free blame 	idump unlikely 
copyright authors 	arena alloc 
see copying licensing 	junk small 
conditions stats 	unlikely memset 
blame blame entry 	jemalloc 
score lower 	valgrind make 
thresholds passed parent 	mem undefined 
move copy 	unlikely arena 
logic remember update 	alloc junk 
flag allocation 	small jemalloc 
one blob commit 	valgrind 
suspected record 	make mem 
preceding blame record 	undefined memset 
blob origins 	malloc mutex 
put list linked 	prng arena 
via next 	run alloc 
hanging corresponding commit 	large 
field order 	malloc mutex 
make finding 	unlock arena 
fast presence chain 	run miscelm 
count towards 	arena miscelm 
origin reference count 	rpages size 
tempting count 	index 
commit pending examination 	arena prof 
even circumstances 	accum locked 
commit present multiple 	malloc mutex 
times priority 	unlock prof 
queue unexamined commits 	idump unlikely 
processing first 	memset 
instance work requiring 	unlikely memset 
origin data 	page ceiling 
second instance interspersed 	arena choose 
commit changing 	unlikely page 
would preexisting different 	ceiling malloc 
ancestry commit 	mutex 
date order 	arena run 
wedge two instances 	alloc large 
commit priority 	malloc mutex 
queue produce blame 	unlock chunk 
entries relevant 	addr arena 
want tripped certainly 	run 
seem worth 	miscelm arena 
optimizing suspects contains 	miscelm rpages 
blame entries 	alignment ceiling 
may attributed origin 	arena miscelm 
commit parent 	arena miscelm 
commits commit processed 	pageind 
suspects moved 	arena run 
either assigning origin 	trim head 
different commit 	arena run 
shipping scoreboard ent 	trim tail 
list cannot 	arena run 
attributed different commit 	init 
guilty gets 	large arena 
shipping suspects 	miscelm pageind 
blame list instead 	arena run 
commits prepare 	miscelm arena 
diff filespec convert 	mapbits dirty 
diff textconv 	arena 
api textconv driver 	mapbits decommitted 
exists conversion 	arena run 
succeeds otherwise given 	dalloc malloc 
origin prepare 	mutex unlock 
mmfile structure used 	arena miscelm 
diff machinery 	rpages 
origin refcounted usually 	size index 
keep blob 	malloc mutex 
contents reused present 	unlock unlikely 
exactly commit 	memset unlikely 
chain lines described 	memset arena 
blame entry 	malloc 
split pass blame 	arena malloc 
parents arranged 	likely arena 
linked lists 	palloc large 
kept suspects unprocessed 	likely huge 
origin entered 	malloc huge 
blame origin finalized 	palloc 
scoreboard structure 	cassert chunk 
scoreboard structure sorted 	addr isalloc 
end processing 	isalloc chunk 
according image line 	addr size 
number lists 	index arena 
attached origin sorted 	mapbits 
target line 	large binind 
number first line 	isalloc isalloc 
image internally 	arena bin 
line numbers many 	index extent 
lines commit 	node arena 
introduced image line 	arena 
number first 	bin runs 
line suspect file 	arena run 
internally line 	search arena 
numbers significant 	run miscelm 
entry cached avoid 	malloc mutex 
scanning lines 	unlock 
merge blames happens 	malloc mutex 
lists blames 	arena run 
arrived via different 	dalloc decommit 
parents single 	malloc mutex 
suspect want sort 	unlock malloc 
according suspect 	mutex 
line numbers opposed 	arena bin 
image line 	runs insert 
numbers function body 	arena bin 
somewhat longish 	runs insert 
avoids unnecessary writes 	arena mapbits 
image line 	small 
numbers different need 	runind arena 
three way 	miscelm unlikely 
comparison allow 	arena dalloc 
collating suspects sort 	junk small 
according respective 	arena run 
pointer primary sorting 	reg 
criterion actual 	dalloc arena 
relation pretty unimportant 	dissociate bin 
establishes total 	run arena 
order comparing integers 	dalloc bin 
gives current 	run arena 
state blame assignment 	bin 
commit started 	lower run 
digging priority queue 	arena dalloc 
commits unassigned 	bin locked 
blame records contents 	impl arena 
image used 	mapbits small 
many functions obtain 	runind 
contents nth 	arena miscelm 
line indexed scoreboard 	malloc mutex 
lineno blame 	arena dalloc 
entry lno 	bin locked 
linked list blames 	impl malloc 
look line 	mutex 
buffer two blame 	unlock arena 
entries next 	ptr small 
came contiguous lines 	binind arena 
origin commit 	mapbits arena 
path pair merge 	bitselm arena 
together sanity 	dalloc 
merge given sorted 	bin unlikely 
list blames 	memset jemalloc 
preexisting origin previous 	arena miscelm 
blames commit 	arena mapbits 
entered commit priority 	large 
queue score 	size arena 
board given commit 	dalloc junk 
path create 	large size 
origin structure callers 	index arena 
blame scoreboard 	run dalloc 
use origin 	decommit 
obtain shared refcounted 	arena dalloc 
copy instead 	large locked 
calling function directly 	impl malloc 
locate existing 	mutex arena 
origin create one 	dalloc large 
moves origin 	locked 
front position commit 	impl malloc 
list bump 	mutex unlock 
front fill blob 	arena miscelm 
sha field 	malloc mutex 
origin hasn later 	arena run 
call fill 	trim 
origin blob use 	tail size 
locate data 	index size 
blob sha origin 	index malloc 
also used 	mutex unlock 
pass blame entire 	arena mapbits 
file parent 	large 
detect child 	size malloc 
blob identical parent 	mutex arena 
also fills 	mapbits allocated 
origin mode corresponding 	arena mapbits 
path origin 	unallocated size 
check path exists 	index 
parent origin 	size size 
structure represent first 	index arena 
check existing 	miscelm arena 
origins path origin 	run split 
parent without 	large page 
renaming common see 	ceiling 
origin path 	memset page 
different parent origin 	ceiling arena 
first time 	mapbits dirty 
diff fairly efficient 	arena mapbits 
path parent 	dirty arena 
since origin path 	mapbits 
pathspec parent 	large arena 
commit directory 	mapbits unzeroed 
see whole bunch 	arena mapbits 
deletion files 	large arena 
directory care exist 	mapbits unzeroed 
parent type 	size 
changed origin find 	index size 
path corresponds 	index malloc 
parent origin structure 	mutex unlock 
represent append 	malloc mutex 
blame entry given 	unlock unlikely 
output queue 	memset 
src typically stack 	jemalloc chunk 
want copy 	addr extent 
information malloced blame 	node arena 
entry gets 	arena ralloc 
added given queue 	large grow 
origin dst 	unlikely 
loses refcnt 	memset isalloc 
known lines tlno 	unlikely memset 
came parent 	isalloc arena 
overlap range also 	ralloc junk 
known parent 	large arena 
line plno corresponds 	ralloc 
line tlno 	large shrink 
split potentially three 	likely size 
parts chunk 	index size 
chunk blamed parent 	index size 
portion pre 	index arena 
chunk part blamed 	ralloc 
parent post 	large huge 
chunk part blamed 	ralloc move 
parent turns 	arena malloc 
nothing blame parent 	ipalloct likely 
forget splitting 	arena ralloc 
split suspect signals 	move 
split overlap 	arena ralloc 
divided existing 	move helper 
blame three parts 	jemalloc valgrind 
split assigned 	make mem 
blame moved queue 	undefined memcpy 
reflect split 	isqalloc 
first part reuse 	huge ralloc 
storage existing 	malloc mutex 
entry last part 	malloc mutex 
middle part 	unlock malloc 
parent parent covers 	mutex malloc 
entire area 	mutex 
reuse storage replace 	unlock atomic 
parent parent 	read arena 
parent splitting blame 	dirty mult 
origins used 	valid atomic 
stack blame entry 	write malloc 
lose one 	mutex 
refcnt reverse blame 	arena metadata 
reverses list 	allocated malloc 
given head 	mutex unlock 
appending tail allows 	malloc mutex 
build lists 	malloc mutex 
reverse order reverse 	unlock 
afterwards faster 	alloc cacheline 
building list proper 	ceiling quantum 
order right 	ceiling alloc 
away reason building 	malloc mutex 
proper order 	init memset 
requires writing link 	malloc 
previous element 	large stats 
building reverse order 	cacheline ceiling 
requires placing 	memset malloc 
list head current 	huge stats 
element process 	cacheline ceiling 
one hunk patch 	quantum 
current suspect 	ceiling memset 
blame entry parent 	chunk dss 
first blames 	prec arena 
unfinished entries 	dirty mult 
chunk target parent 	arena avail 
start differing 	malloc 
parent splits blame 	mutex init 
entries start 	extent szad 
end difference region 	extent extent 
since use 	szad extent 
options may lead 	malloc mutex 
overlapping duplicate 	init 
source line number 	malloc mutex 
ranges rely 	init malloc 
sorting merging order 	mutex init 
first suspect 	arena run 
line number current 	memset unlikely 
record starts 	jemalloc 
differing portion reaches 	ffs unlikely 
need split 	alloc arena 
examine second 	dirty mult 
part separately move 	offsetof offsetof 
second half 	index size 
record push record 	size 
diffp pass 	index size 
blame everything differing 	index size 
chunk parent 	index bin 
know much common 	info init 
stretch diff 	small run 
occur currently blamed 	size 
parts assign 	init malloc 
parent prepend split 	mutex prefork 
portions everything 	malloc mutex 
starts blameable portion 	prefork malloc 
retain records 	mutex prefork 
target parts different 	malloc 
parent current 	mutex prefork 
record sameness need 	malloc mutex 
split move 	prefork malloc 
second half 	mutex postfork 
record processed later 	parent malloc 
chunks push 	mutex 
record samep move 	postfork parent 
across elements 	malloc mutex 
unblamable portion diff 	postfork parent 
chunks parent 	malloc mutex 
target looking origin 	postfork parent 
target aiming 	malloc 
pass blame lines 	mutex postfork 
suspected parent 	parent malloc 
run diff find 	mutex postfork 
lines came 	child malloc 
parent pass blame 	mutex postfork 
nothing remains 	child 
target rest parent 	malloc mutex 
lines blame 	postfork child 
entry splitting blames 	malloc mutex 
many times 	postfork child 
become small 	malloc mutex 
trivial point becomes 	postfork 
pointless blame 	child data 
parents appears everywhere 	max run 
ordinary program 	size arenas 
worth say copied 	max large 
totally unrelated 	size max 
file parent compute 	run 
trivial lines 	size used 
blame entry best 	small size 
far split 	classes valid 
existing blame entry 	small run 
passes blame 	page multiples 
parent maintain best 	number 
far best 	large size 
split far comparing 	classes number 
best far 	huge size 
copying bst far 	classes function 
needed looking 	prototypes functions 
part image 	referenced 
represented ent tlno 	prior definition 
offset ent 	generate red 
lno tlno looking 	black functions 
image including 	change sizes 
match preimage plno 	valid small 
looking preimage 	run 
image ent tlno 	sizes round 
preimage plno 	nearest run 
line numbers find 	size actually 
lines parent 	requested normal 
ent pass blames 	large allocation 
file blob 	large 
contents parent prepare 	pad cache 
mmfile contains 	index randomization 
lines ent file 	offset allocation 
part image 	page boundary 
annotating file 	next quantized 
partially may match 	size 
image remainder 	greater input 
match preimage move 	size quantized 
blame entries 	sizes comprise 
list source score 	run sizes 
smaller score 	back small 
min front list 	region 
small returns 	runs run 
pointer link pointing 	sizes back 
old head 	large regions 
small list see 	alignment constraints 
lines currently 	skip quantization 
target suspected attributed 	may 
parent nothing 	adequately large 
remains target iteration 	run sized 
unblamed terminated 	runs may 
list entries yet 	mixed happens 
tested blame 	unusual size 
leftover contains 	requested 
reversed list entries 	aligned allocation 
tested without 	one several 
assignable parent count 	places linear 
number entries 	search would 
target suspected prepare 	potentially find 
list entry 	sufficiently 
best split lines 	aligned available 
target suspected 	memory somewhere 
see find code 	lower compare 
movement across 	quantized size 
file boundary parent 	rather size 
commit porigin 	order 
path parent already 	sort equally 
tried nothing 	useful runs 
remains target find 	address treat 
copies harder 	keys lower 
path requested want 	anything generate 
use diffcore 	red 
rename actually 	black functions 
match things find 	freeing interior 
copies harder 	pointer cause 
force diff sha 	assertion failure 
feed filepairs 	freeing unallocated 
diff queue code 	pointer 
needs diff 	cause assertion 
setup done usually 	failure keep 
makes find 	track trailing 
copies harder imply 	unused pages 
copy detection 	later use 
exist parent ignore 	run 
git links 	untouched therefore 
find move already 	zeroed run 
dealt path 	dirty pages 
blobs origin porigin 	must zeroed 
exactly match 	run clean 
everything origin suspected 	pages 
blamed parent 	may zeroed 
steal file 	never touched 
pass blame current 	last element 
commit parents 	first run 
keep saying parent 	contains one 
porigin mean 	page 
find scapegoat exonerate 	statements element 
distribute collected 	extent node 
unsorted blames respected 	notion committed 
sorted lists 	doesn directly 
various origins first 	apply arena 
pass looks 	chunks 
unrenamed path optimize 	arbitrarily mark 
common cases 	committed commit 
look renames second 	state runs 
pass optionally 	tracked individually 
find moves parents 	upon chunk 
files optionally 	deallocation 
find copies parents 	entire chunk 
files prepend 	consistent commit 
toosmall origin 	state commit 
suspects point sorting 	header undo 
ends big 	commit header 
unsorted list caller 	initialize 
anyway information 	map contain 
commits used output 	one maximal 
filled asked 	free untouched 
details parse author 	run mark 
committer line 	pages zeroed 
commit buffer ugh 	chunk 
convert name 	alloc returned 
mail mailmap allow 	zeroed decommitted 
nonportable characters 	chunk need 
pathnames style quoted 	initialize page 
needed porcelain 	map entries 
incremental format wants 	unless 
show lot 	chunk zeroed 
details per 	insert run 
commit instead repeating 	runs avail 
every line 	run runs 
emit first time 	avail arena 
commit appears 	use 
output unless user 	decommit header 
specifically asked 	mark chunk 
repeat blame entry 	decommitted even 
found guilty 	header decommit 
range show incremental 	fails since 
output main 	treating 
loop blobs lines 	partially committed 
whose origin 	chunk committed 
still unknown pick 	high potential 
one blob 	causing later 
allow lines pass 	access decommitted 
blames parents 	memory 
find one suspect 	revert optimistic 
use suspect 	stats updates 
later loop 	optimistically update 
hold onto meantime 	stats revert 
treat root 	optimistic stats 
commit boundary take 	updates 
responsibility remaining 	optimistically update 
entries sanity space 	stats first 
paddings time 	best fit 
buf display width 	run selection 
use time 	lowest run 
width display width 	best 
calibration allow 	fits run 
quick access contents 	sizes quantized 
nth line 	candidate runs 
image prepare index 	necessarily exactly 
scoreboard phony 	size search 
grafts use primarily 	arena 
support git 	chunks lowest 
cvsserver wants give 	best fit 
linear history 	usable runs 
clients format 	create chunk 
commit parent parent 	allocate run 
many columns 	arena 
need show line 	chunk alloc 
numbers authors 	failed another 
filenames one abbrev 	may made 
length needed 	sufficient memory 
boundary commit debugging 	available one 
origin refcounted 	dropped 
asserts underflow nobody 	arena arena 
zero negative 	chunk alloc 
refcnt isn simple 	search one 
passing buf 	time search 
len want transfer 	arena chunks 
ownership buffer 	lowest 
commit must use 	best fit 
detach prepare 	usable runs 
dummy commit represents 	create chunk 
work staged 	allocate run 
item note 	arena chunk 
annotating work item 	alloc 
never works 	failed another 
reverse reading stdin 	may made 
read current 	sufficient memory 
index replace path 	available one 
entry origin 	dropped arena 
blob sha without 	arena 
mucking mode 	chunk alloc 
type bits going 	search one 
write index 	time purge 
want run diff 	option disabled 
index cached 	recursively purge 
bother reading head 	iterate 
must one 	since preventing 
one negative commit 	recursive purging 
must boundary 	could otherwise 
enables copy 	many dirty 
removed files enables 	pages purge 
copy existing 	unless 
files blaming file 	number purgeable 
enables copy 	pages exceeds 
existing files everybody 	threshold compute 
one abbrev 	minimum number 
length needed boundary 	pages purge 
commit maximum 	stash 
width used show 	least npurge 
dates translators 	pages allocate 
used tell maximum 	chunkselm remains 
display width 	valid due 
relative timestamp git 	dalloc node 
blame output 	argument 
locale years months 	chunk alloc 
ago takes 	cache purging 
places longest among 	spare chunk 
various forms 	run make 
relative timestamps 	available prior 
language may need 	allocation 
fewer display 	temporarily allocate 
columns strip collected 	free dirty 
options unknown 	run stash 
argv unk passed 	redundant actually 
revision machinery 	purge chunk 
going bottom processing 	chunkselm 
remaining dashdash 	embedded chunk 
pos either blame 	must remain 
revisions path 	valid deallocate 
blame path rev 	chunk arena 
otherwise one 	unstash purged 
two blame revisions 	destroyed 
path blame 	decommitted purged 
path rev note 	depending chunk 
must strip 	deallocation policy 
path arguments want 	unzeroed flag 
path pruning 	pages chunk 
may want 	purge 
bottom processing reorder 	wrapper returned 
way rev 	whether pages 
path fallthrough path 	zeroed side 
without anything 	effect purging 
positive head use 	chunk map 
working contents 	modification 
bottom mark ancestors 	safe even 
bottom commits 	though arena 
would reach traversing 	mutex isn 
uninteresting blob.c 	currently owned 
blob type sha 	run marked 
obj item 	allocated 
buffer size lookup 	thus protecting 
create alloc 	modified writes 
blob node type 	perturb first 
blob.h blob 	last elements 
type sha item 	chunk 
buffer size 	map allocated 
blobs contain 	bits behavior 
references objects structured 	well defined 
data needs 	deallocate chunks 
parsing however code 	runs calls 
may use 	arena 
parsed bit blob 	dirty count 
determine whether 	disabled even 
content found actually 	debug builds 
available parse 	overhead grows 
blob buffer used 	nonlinearly memory 
flag read 	usage 
successfully database blob 	increases coalesce 
branch.c spec 	forward successor 
src remote matches 	runs avail 
remote priv 	coalesced run 
tracking origin tracking 	inserted later 
advice flag 	successor 
local origin 	dirty dirty 
remote shortname key 	pages coalesce 
rebasing setup 	backward predecessor 
tracking buf branch 	runs avail 
name name 	coalesced run 
name force attr 	inserted 
head sha 	later predecessor 
remote data tracking 	dirty dirty 
branch query 	pages run 
upstream branch upstream 	dirty caller 
missing upstream 	claims dirtied 
advice create branch 	well 
branch existing 	already dirty 
remote find tracking 	allocated caller 
free free 	doesn claim 
setup rebase skip 	cleaned mark 
prefix strcmp 	pages unallocated 
warning strbuf addf 	chunk 
git config 	map insert 
gently strbuf 	runs avail 
reset strbuf addf 	coalescing complete 
git config 	deallocate chunk 
gently strbuf reset 	completely unused 
strbuf addf 	okay 
git config gently 	dirty page 
strbuf release 	processing even 
strbuf release error 	chunk deallocated 
advise strbuf 	since spare 
addf git config 	waiting possible 
strbuf release 	chunk 
strbuf addstr free 	deallocation dirty 
strbuf release 	processing allows 
strbuf check branch 	old spare 
die exists 	fully deallocated 
die strlen resolve 	thus decreasing 
bare repository 	chances 
strcmp die memset 	spuriously crossing 
remote find 	dirty page 
tracking remote 	purging threshold 
unlink git path 	update chunk 
cherry pick 	map arena 
head unlink git 	run 
path revert 	dalloc treat 
head unlink git 	leading run 
path merge 	separately allocated 
head unlink git 	last element 
path merge 	run first 
unlink git path 	single 
merge msg 	page runs 
unlink git path 	update chunk 
merge mode 	map arena 
unlink git path 	run dalloc 
squash msg 	treat trailing 
find shared symref 	run 
skip prefix 	separately allocated 
die called branched 	last element 
orig tries 	run first 
infer settings 	single page 
branch remote merge 	runs look 
config branching 	usable 
existing branch unique 	run existing 
completion good 	runs space 
real branch builtin 	available allocate 
git branch 	run initialize 
copyright kristian gsberg 	run internals 
krh redhat 	arena 
git branch junio 	run alloc 
hamano plain 	small failed 
remote local current 	another may 
upstream checks 	made sufficient 
whether merge bases 	memory available 
branch head 	one 
branch branch builds 	dropped bin 
upon contains 	search one 
branch means branch 	time fill 
already merged 	bin runcur 
safely head 	call arena 
branch safety valve 	run 
fully redefined 	reg alloc 
check upstream otherwise 	another updated 
head result 	runcur one 
merge bases without 	ran without 
following code 	bin arena 
transition period gentle 	bin 
reminder order 	nonfull run 
subsequent messages translators 	arena run 
make sure 	alloc small 
match head detached 	may allocated 
head detached 	run may 
status ahead behind 	pulled 
vcs svn 	run bin 
drop obj pool 	run therefore 
listing remote 	make assumptions 
branches remote 	run previously 
branches remotes prefix 	used arena 
need account 	bin 
width sorting parameter 	lower run 
given sorting 	must called 
refname would give 	region deallocated 
alphabetically sorted 	run oom 
head beginning followed 	tbin avail 
local branches 	isn 
refs heads remote 	yet filled 
tacking branches 	first element 
refs remotes bad 	successful allocations 
name could 	must moved 
attempt rename used 	tbin avail 
allow created 	bailing 
accident command like 	insert low 
git branch 	regions used 
currentbranch currentbranch cannot 	first large 
cause worktree 	allocation compute 
become inconsistent 	uniformly distributed 
head allow need 	offset 
pass logmsg 	within first 
head didn really 	page multiple 
move git 	cacheline size 
branch local also 	pages cachelines 
shows head 	handles large 
detached create branch 	allocations 
takes care 	require page 
setting tracking info 	alignment cause 
making sure 	oom small 
upstream correct show 	alignment doesn 
instructions user 	require special 
gave one branch 	run 
doesn exist 	placement large 
locally name remote 	alignment doesn 
tracking branch 	require special 
builtin branch usage 	run placement 
head head 	however cached 
sha branch 	pointer 
use color branch 	may random 
colors output 	offset run 
colopts slot slot 	bit manipulation 
name slot 	retrieve dissociate 
branch color kind 	run bin 
name rev 	block 
head rev reference 	conditional necessary 
rev reference 	run contains 
name reference name 	one region 
free merged 	never gets 
branch upstream sha 	inserted non 
branchname refname 	full 
sha head rev 	runs make 
kinds force 	sure bin 
rev branchname buf 	runcur non 
argc argv 	refers lowest 
force kinds quiet 	non full 
head rev 	run 
sha name 	okay runcur 
fmt ret remote 	rather proactively 
branch bname 	keeping pointing 
target flags stat 	lowest non 
branch name 	full run 
show upstream branch 	runcur 
upstream fancy 	arena ptr 
upstream gone added 	small binind 
decoration item 	extra sanity 
filter refname stat 	checking shrink 
sub commit 	run make 
desc state item 	trailing 
maxwidth filter 	pages available 
remote prefix current 	allocations extend 
color name 	run next 
prefix desc free 	run available 
utf compensation 	sufficiently large 
refs remote 	split 
bonus max desc 	following run 
filter sorting 	merge first 
maxwidth remote prefix 	part existing 
oldname newname 	allocation zero 
force logmsg newsection 	trailing bytes 
recovery clobber 	original 
head edit description 	allocation last 
branch name 	page since 
buf name argc 	indeterminate state 
argv prefix 	mark extended 
list edit description 	run dirty 
unset upstream 	either 
upstream filter sorting 	portion run 
tail options 	dirty allocation 
branch name branch 	rather pedantic 
branch branch 	actually sequence 
buf branch remote 	events could 
tracking buf 	cause 
strcasecmp strcasecmp 	resulting run 
strcasecmp strcasecmp strcasecmp 	passed arena 
strcasecmp starts 	run dalloc 
git column config 	dirty argument 
strcmp git 	dirty flag 
config colorbool skip 	consistency 
prefix parse 	would really 
branch color slot 	matter resize 
config error 	large allocation 
nonbool color parse 	order avoid 
git color 	copying always 
config branch branch 	fail 
upstream resolve 	growing following 
refdup lookup commit 	run already 
reference merge 	use current 
bases merge bases 	size compatible 
warning warning 	maximal fill 
free lookup commit 	shrinking 
reference error 	order avoid 
branch merged 	race avoid 
error strbuf addf 	moving allocation 
git config 	size left 
rename section warning 	reallocation would 
strbuf release 	require 
die lookup commit 	move avoid 
reference die 	moving allocation 
strbuf branchname strcmp 	size oldsize 
error free 	different enough 
mkpathdup resolve error 	need move 
check branch 	fall 
commit sha error 	back allocating 
find unique 	space copying 
abbrev branch config 	junk zero 
free branch 	filling already 
stat tracking info 	done ipalloc 
shorten unambiguous 	arena 
want color strbuf 	malloc allocate 
addf branch 	arena arena 
color branch 	lstats arena 
color strbuf addstr 	hstats contiguously 
strbuf addf 	mainly way 
strbuf addf strbuf 	clean 
addf strbuf 	alloc nondeterministic 
addf strbuf addf 	seed address 
strbuf addf 	arena reduces 
strbuf addf strbuf 	likelihood lockstep 
addf strbuf 	non uniform 
release strbuf addch 	cache 
free parse 	index utilization 
commit commit easy 	among identical 
fill tracking 	concurrent processes 
info strbuf addf 	cost test 
find unique 	repeatability debug 
abbrev strbuf release 	builds 
strbuf release 	instead use 
memset status 	deterministic seed 
state strbuf addf 	initialize bins 
strbuf addf 	calculate bin 
strbuf addf strbuf 	info run 
addf strbuf 	size 
addstr free free 	meets following 
free strbuf 	constraints bin 
detach skip prefix 	info run 
strcmp skip 	size arena 
prefix head description 	maxrun bin 
strbuf addf 	info 
strlen utf strwidth 	nregs run 
strbuf addf 	maxregs bin 
branch color branch 	info nregs 
color strbuf 	bin info 
addf branch color 	reg offset 
branch color 	also 
skip prefix strbuf 	calculated since 
addf verbose 	settings interdependent 
info column 	determine redzone 
active list append 	size minimum 
strbuf release 	alignment minimum 
strbuf release free 	redzone 
skip prefix 	size padding 
skip prefix utf 	end run 
strwidth memset 	needed align 
verify format filter 	regions padding 
refs calc 	allows redzone 
maxwidth strlen sorting 	half 
sort format 	minimum alignment 
print item clear 	without padding 
die strbuf 	redzone would 
check branch exists 	twice large 
die strcmp 	order maintain 
validate branchname strbuf 	alignment 
addf rename 	compute run 
die strbuf release 	size ideal 
warning strcmp 	conditions redzones 
create symref 	limit run 
die strbuf addf 	size redzones 
strbuf release 	require 
strbuf addf strbuf 	enough padding 
release git 	even single 
config rename section 	region fit 
die strbuf 	within number 
release strbuf release 	pages would 
read branch 	normally 
desc strbuf addch 	dedicated run 
strbuf commented 	size increase 
addf write file 	run size 
gently git 	least one 
path strbuf release 	region fits 
error strerror 	make 
strbuf reset launch 	sure run 
editor git 	fit within 
path strbuf release 	arena chunk 
strbuf stripspace 	copy settings 
strbuf addf 	compute header 
git config strbuf 	size 
release strbuf 	large enough 
release memset strcmp 	contain page 
usage options 	map page 
git config resolve 	map biased 
refdup die 	omit entries 
strcmp skip prefix 	header 
die parse 	iteration necessary 
options usage options 	compute map 
finalize colopts 	bias compute 
explicitly enable column 	safe header 
die die 	size map 
branches print list 	bias 
print columns 	values include 
list clear die 	enough space 
die strbuf 	unbiased page 
addf exists strbuf 	map refine 
release error 	map bias 
error strbuf 	omit 
release edit branch 	header pages 
description die 	page map 
rename branch rename 	resulting map 
branch die 	bias may 
branch die strcmp 	one small 
die die 	refine 
exists die create 	map bias 
branch branch 	result result 
die strcmp die 	always correct 
die branch 	small chunk 
merge config die 	sizes possible 
strbuf addf 	fewer 
git config multivar 	non header 
strbuf reset 	pages available 
strbuf addf git 	necessary serve 
config multivar 	size classes 
strbuf release 	chunksize arena.h 
branch strcmp die 	binind 
die die 	nfree bitmap 
strbuf addf exists 	bits prof 
strbuf release 	tctx pun 
exists create branch 	prof tctx 
usage options 	run node 
called branched orig 	map 
tries infer 	bits reg 
settings branch remote 	size redzone 
merge config 	size reg 
branching existing branch 	interval run 
unique completion 	size nregs 
good real branch 	bitmap 
builtin git 	info reg 
branch copyright kristian 	offset runcur 
gsberg krh 	runs stats 
redhat git branch 	ind nthreads 
junio hamano 	stats prof 
plain remote 	accumbytes 
local current upstream 	offset state 
checks whether 	dss prec 
merge bases branch 	spare dirty 
head branch 	mult purging 
branch builds upon 	nactive ndirty 
contains branch 	runs 
means branch already 	avail runs 
merged safely 	dirty chunks 
head branch safety 	cache huge 
valve fully 	mtx chunks 
redefined check upstream 	szad cached 
otherwise head 	chunks 
result merge bases 	cached chunks 
without following 	szad retained 
code transition period 	chunks retained 
gentle reminder 	chunks mtx 
order subsequent messages 	node cache 
translators make 	mtx 
sure match 	chunk hooks 
head detached head 	bins large 
detached status 	pad opt 
ahead behind vcs 	dirty mult 
svn drop 	arena bin 
obj pool listing 	info 
remote branches 	map bias 
remote branches remotes 	map misc 
prefix need 	offset arena 
account width sorting 	maxrun large 
parameter given 	maxclass nlclasses 
sorting refname would 	nhclasses 
give alphabetically 	arena node 
sorted head beginning 	cache arena 
followed local 	node cache 
branches refs heads 	arena arena 
remote tacking 	node arena 
branches refs remotes 	usize 
bad name 	alignment zero 
could attempt 	arena chunk 
rename used allow 	usize arena 
created accident 	chunk oldsize 
command like git 	usize arena 
branch currentbranch 	chunk 
currentbranch cannot cause 	oldsize usize 
worktree become 	arena chunk 
inconsistent head allow 	oldsize usize 
need pass 	zero arena 
logmsg head didn 	arena dirty 
really move 	mult 
git branch local 	arena arena 
also shows 	arena tbin 
head detached create 	binind prof 
branch takes 	accumbytes ptr 
care setting tracking 	bin info 
info making 	zero 
sure upstream 	arena redzone 
correct show instructions 	corruption arena 
user gave 	dalloc junk 
one branch doesn 	small ptr 
exist locally 	bin info 
name remote tracking 	ptr 
branch branch.c 	usize arena 
spec src remote 	size zero 
matches remote 	arena size 
priv tracking origin 	zero tsd 
tracking advice 	arena 
flag local origin 	usize alignment 
remote shortname 	zero tcache 
key rebasing setup 	ptr size 
tracking buf 	arena chunk 
branch name name 	ptr bitselm 
name force 	arena 
attr head sha 	chunk ptr 
remote data 	pageind bitselm 
tracking branch 	arena chunk 
query upstream branch 	ptr pageind 
upstream missing 	arena dalloc 
upstream advice create 	junk 
branch branch 	large ptr 
existing remote find 	usize arena 
tracking free 	chunk ptr 
free setup rebase 	arena chunk 
skip prefix 	ptr arena 
strcmp warning strbuf 	ralloc 
addf git 	junk large 
config gently strbuf 	ptr oldsize 
reset strbuf 	size extra 
addf git config 	zero tsd 
gently strbuf 	arena ptr 
reset strbuf addf 	oldsize 
git config 	size alignment 
gently strbuf release 	zero tcache 
strbuf release 	arena arena 
error advise 	dss prec 
strbuf addf git 	dirty mult 
config strbuf 	arena 
release strbuf addstr 	dss dirty 
free strbuf 	mult nactive 
release strbuf check 	ndirty astats 
branch die 	bstats lstats 
exists die strlen 	hstats ind 
resolve bare 	arena 
repository strcmp die 	arena arena 
memset remote 	chunk pageind 
find tracking remote 	chunk pageind 
unlink git 	miscelm miscelm 
path cherry pick 	run chunk 
head unlink 	pageind 
git path revert 	mapbitsp chunk 
head unlink 	pageind mapbits 
git path merge 	chunk pageind 
head unlink 	chunk pageind 
git path 	chunk pageind 
merge unlink git 	chunk 
path merge 	pageind chunk 
msg unlink git 	pageind chunk 
path merge 	pageind chunk 
mode unlink git 	pageind chunk 
path squash 	pageind chunk 
msg find shared 	pageind 
symref skip 	mapbitsp mapbits 
prefix die called 	size chunk 
branched orig 	pageind size 
tries infer settings 	flags chunk 
branch remote 	pageind size 
merge config branching 	chunk 
existing branch 	pageind flags 
unique completion good 	chunk pageind 
real branch 	size flags 
builtin git 	chunk pageind 
branch copyright kristian 	binind chunk 
gsberg krh 	pageind 
redhat git branch 	runind binind 
junio hamano 	flags arena 
plain remote local 	size arena 
current upstream 	size arena 
checks whether merge 	arena accumbytes 
bases branch 	arena 
head branch branch 	accumbytes arena 
builds upon 	accumbytes ptr 
contains branch means 	mapbits arena 
branch already 	bin run 
merged safely head 	bin info 
branch safety 	ptr 
valve fully redefined 	ptr ptr 
check upstream 	usize tctx 
otherwise head result 	ptr usize 
merge bases 	old ptr 
without following 	old tctx 
code transition period 	tsd 
gentle reminder 	arena size 
order subsequent messages 	zero tcache 
translators make 	ptr ptr 
sure match head 	demote tsd 
detached head 	ptr tcache 
detached status ahead 	tsd 
behind vcs 	ptr size 
svn drop obj 	tcache chunk 
pool listing 	pageind chunk 
remote branches remote 	pageind miscelm 
branches remotes 	chunk pageind 
prefix need account 	miscelm 
width sorting 	chunk pageind 
parameter given sorting 	miscelm run 
refname would 	miscelm chunk 
give alphabetically sorted 	pageind mapbitsp 
head beginning 	chunk pageind 
followed local 	mapbits 
branches refs heads 	size chunk 
remote tacking 	pageind mapbits 
branches refs remotes 	chunk pageind 
bad name 	mapbits chunk 
could attempt rename 	pageind mapbits 
used allow 	chunk 
created accident command 	pageind mapbits 
like git 	binind chunk 
branch currentbranch currentbranch 	pageind mapbits 
cannot cause 	chunk pageind 
worktree become inconsistent 	mapbits chunk 
head allow 	pageind 
need pass logmsg 	mapbits chunk 
head didn 	pageind mapbits 
really move git 	chunk pageind 
branch local 	mapbits mapbitsp 
also shows head 	mapbits size 
detached create 	mapbits 
branch takes 	chunk pageind 
care setting tracking 	size flags 
info making 	mapbitsp chunk 
sure upstream correct 	pageind size 
show instructions 	mapbitsp mapbits 
user gave one 	chunk 
branch doesn 	pageind flags 
exist locally name 	mapbitsp chunk 
remote tracking 	pageind size 
branch builtin branch 	flags mapbitsp 
usage head 	chunk pageind 
head sha branch 	binind 
use color 	mapbitsp mapbits 
branch colors output 	chunk pageind 
colopts slot 	runind binind 
slot name slot 	flags mapbitsp 
branch color 	arena size 
kind name rev 	arena 
head rev 	size arena 
reference rev 	arena accumbytes 
reference name reference 	arena accumbytes 
name free 	arena accumbytes 
merged branch upstream 	ret ptr 
sha branchname 	mapbits 
refname sha head 	binind chunk 
rev kinds 	arena pageind 
force rev branchname 	actual mapbits 
buf argc 	rpages ind 
argv force kinds 	run bin 
quiet head 	run 
rev sha name 	binind actual 
fmt ret 	binind bin 
remote branch bname 	info miscelm 
target flags 	rpages arena 
stat branch name 	bin binind 
show upstream 	run 
branch upstream 	bin info 
fancy upstream gone 	ptr shift 
added decoration 	diff regind 
item filter refname 	interval miscelm 
stat sub 	rpages interval 
commit desc state 	invs 
item maxwidth 	ptr ret 
filter remote prefix 	chunk pageind 
current color 	mapbits elm 
name prefix desc 	ptr usize 
free utf 	tctx chunk 
compensation refs remote 	pageind 
bonus max 	elm ptr 
desc filter sorting 	usize old 
maxwidth remote 	ptr old 
prefix oldname newname 	tctx chunk 
force logmsg 	pageind elm 
newsection recovery clobber 	tsd 
head edit 	arena size 
description branch 	zero tcache 
name buf name 	ptr chunk 
argc argv 	ptr demote 
prefix list edit 	ret chunk 
description unset 	pageind 
upstream upstream filter 	binind tsd 
sorting tail 	ptr tcache 
options branch name 	chunk pageind 
branch branch 	mapbits binind 
branch buf branch 	size tsd 
remote tracking 	ptr 
buf strcasecmp strcasecmp 	size tcache 
strcasecmp strcasecmp 	chunk pageind 
strcasecmp strcasecmp starts 	binind pageind 
git column 	chunk addr 
config strcmp git 	chunk addr 
config colorbool 	arena 
skip prefix parse 	miscelm pageind 
branch color 	offsetof arena 
slot config 	miscelm pageind 
error nonbool color 	arena miscelm 
parse git 	pageind offsetof 
color config branch 	arena 
branch upstream 	miscelm pageind 
resolve refdup lookup 	arena miscelm 
commit reference 	pageind arena 
merge bases merge 	bitselm arena 
bases warning 	mapbitsp read 
warning free lookup 	arena 
commit reference 	mapbitsp arena 
error branch merged 	mapbits arena 
error strbuf 	mapbits size 
addf git config 	decode arena 
rename section 	mapbits arena 
warning strbuf release 	mapbits 
die lookup 	size decode 
commit reference die 	arena mapbits 
strbuf branchname 	arena mapbits 
strcmp error 	arena mapbits 
free mkpathdup resolve 	arena mapbits 
error check 	arena 
branch commit sha 	mapbits arena 
error find 	mapbits arena 
unique abbrev branch 	mapbits arena 
config free 	mapbitsp arena 
branch stat tracking 	mapbitsp write 
info shorten 	arena 
unambiguous want color 	mapbits size 
strbuf addf 	encode arena 
branch color branch 	mapbitsp arena 
color strbuf 	mapbitsp read 
addstr strbuf addf 	arena mapbitsp 
strbuf addf 	write 
strbuf addf strbuf 	arena mapbits 
addf strbuf 	size encode 
addf strbuf 	arena mapbitsp 
addf strbuf addf 	arena mapbitsp 
strbuf addf 	write arena 
strbuf release strbuf 	mapbitsp 
addch free 	arena mapbitsp 
parse commit commit 	write arena 
easy fill 	mapbits size 
tracking info strbuf 	encode arena 
addf find 	mapbitsp arena 
unique abbrev strbuf 	mapbitsp 
release strbuf 	read arena 
release memset status 	mapbits large 
state strbuf 	size arena 
addf strbuf addf 	mapbitsp write 
strbuf addf 	arena mapbitsp 
strbuf addf strbuf 	arena 
addstr free 	mapbitsp write 
free free strbuf 	atomic atomic 
detach skip 	sub atomic 
prefix strcmp 	read cassert 
skip prefix head 	cassert likely 
description strbuf 	arena 
addf strlen utf 	prof accum 
strwidth strbuf 	impl cassert 
addf branch color 	likely malloc 
branch color 	mutex arena 
strbuf addf branch 	prof accum 
color branch 	impl 
color skip prefix 	malloc mutex 
strbuf addf 	unlock chunk 
verbose info column 	addr extent 
active list 	node arena 
append strbuf release 	arena mapbits 
strbuf release 	arena 
free skip prefix 	mapbits large 
skip prefix 	arena mapbits 
utf strwidth memset 	allocated arena 
verify format 	mapbits small 
filter refs 	runind arena 
calc maxwidth strlen 	miscelm 
sorting sort 	arena miscelm 
format print item 	rpages arena 
clear die 	run miscelm 
strbuf check branch 	arena miscelm 
exists die 	rpages jemalloc 
strcmp validate branchname 	ffs 
strbuf addf 	likely cassert 
rename die strbuf 	chunk addr 
release warning 	likely arena 
strcmp create symref 	mapbits likely 
die strbuf 	arena miscelm 
addf strbuf release 	atomic 
strbuf addf 	read huge 
strbuf release git 	prof tctx 
config rename 	cassert chunk 
section die strbuf 	addr likely 
release strbuf 	arena mapbits 
release read 	allocated 
branch desc strbuf 	unlikely arena 
addch strbuf 	mapbits large 
commented addf write 	arena miscelm 
file gently 	atomic write 
git path strbuf 	arena mapbits 
release error 	large 
strerror strbuf reset 	huge prof 
launch editor 	tctx cassert 
git path strbuf 	unlikely chunk 
release strbuf 	addr likely 
stripspace strbuf addf 	arena mapbits 
git config 	allocated 
strbuf release strbuf 	arena mapbits 
release memset 	large arena 
strcmp usage options 	miscelm atomic 
git config 	write huge 
resolve refdup 	prof tctx 
die strcmp skip 	reset 
prefix die 	arena choose 
parse options usage 	unlikely likely 
options finalize 	likely tcache 
colopts explicitly enable 	alloc small 
column die 	arena malloc 
die branches print 	small 
list print 	likely likely 
columns list clear 	tcache alloc 
die die 	large arena 
strbuf addf exists 	malloc large 
strbuf release 	huge malloc 
error error strbuf 	chunk 
release edit 	addr likely 
branch description die 	extent node 
rename branch 	arena huge 
rename branch die 	aalloc chunk 
branch die 	addr likely 
strcmp die 	arena 
die exists die 	mapbits allocated 
create branch 	arena mapbits 
branch die strcmp 	binind unlikely 
die die 	arena mapbits 
branch merge config 	large arena 
die strbuf 	mapbits 
addf git config 	large size 
multivar strbuf 	arena mapbits 
reset strbuf addf 	dirty arena 
git config 	mapbits dirty 
multivar strbuf release 	arena mapbits 
branch strcmp 	large 
die die die 	arena ptr 
strbuf addf 	small binind 
exists strbuf release 	arena mapbits 
exists create 	index size 
branch usage options 	huge salloc 
called branched 	chunk 
orig tries 	addr likely 
infer settings branch 	arena mapbits 
remote merge 	arena mapbits 
config branching existing 	allocated likely 
branch unique 	likely arena 
completion good real 	ptr 
branch builtin 	small binind 
git branch copyright 	tcache dalloc 
kristian gsberg 	small arena 
krh redhat git 	dalloc small 
branch junio 	extent node 
hamano plain remote 	arena 
local current 	arena mapbits 
upstream checks whether 	large size 
merge bases 	likely tcache 
branch head branch 	dalloc large 
branch builds 	arena dalloc 
upon contains branch 	large 
means branch 	extent node 
already merged 	arena huge 
safely head branch 	dalloc chunk 
safety valve 	addr likely 
fully redefined check 	arena mapbits 
upstream otherwise 	allocated 
head result merge 	arena mapbits 
bases without 	large arena 
following code transition 	mapbits large 
period gentle 	size arena 
reminder order subsequent 	salloc likely 
messages translators 	likely 
make sure match 	size index 
head detached 	tcache dalloc 
head detached status 	small arena 
ahead behind 	dalloc small 
vcs svn drop 	extent node 
obj pool 	arena 
listing remote branches 	likely tcache 
remote branches 	dalloc large 
remotes prefix 	arena dalloc 
need account width 	large extent 
sorting parameter 	node arena 
given sorting refname 	huge 
would give 	dalloc maximum 
alphabetically sorted head 	number regions 
beginning followed 	one run 
local branches refs 	minimum redzone 
heads remote 	size redzones 
tacking branches refs 	may 
remotes bad 	larger necessary 
name could attempt 	preserve region 
rename used 	alignment minimum 
allow created accident 	ratio active 
command like 	dirty pages 
git branch currentbranch 	per 
currentbranch cannot 	arena computed 
cause worktree 	nactive dirty 
become inconsistent head 	mult ndirty 
allow need 	supposing dirty 
pass logmsg head 	mult less 
didn really 	times 
move git branch 	many active 
local also 	pages dirty 
shows head detached 	pages jemalloc 
create branch 	types index 
takes care setting 	bin run 
tracking info 	associated 
making sure upstream 	number free 
correct show 	regions run 
instructions user gave 	per region 
one branch 	allocated deallocated 
doesn exist locally 	bitmap element 
name remote 	chunk 
tracking branch branch.h 	map corresponds 
create branch 	one page 
name force 	within chunk 
attr flag local 	run address 
origin remote 	size various 
strbuf branch name 	flags 
branch functions 	stored together 
acting information branches 	bit layout 
creates branch 	looks like 
head branch currently 	assuming bit 
name branch 	system nnnnn 
name start name 	nnndumla 
name existing 	unallocated run 
branch branch start 	address first 
force enables 	last pages 
overwriting existing non 	unset pages 
head branch 	small 
reflog creates reflog 	run page 
branch track 	offset large 
causes branch configured 	run page 
merge remote 	count first 
branch start 	page unset 
name tracking branch 	trailing 
validates requested 	pages binind 
branch may created 	small size 
returning interpreted 	binind invalid 
force indicates whether 	large size 
non head 	dirty unzeroed 
branches may overwritten 	decommitted 
non zero 	large allocated 
indicates force parameter 	following example 
non zero 	bit patterns 
branch already exists 	three types 
contrary attr 	runs run 
caller interested verifying 	page 
update named 	offset run 
branch point potentially 	size binind 
different commit 	size large 
merely asking change 	objects binind 
attribute named 	invalid care 
branch tracking 	dumla 
upstream needswork needs 	bit dumla 
split two 	bit unset 
separate functions longer 	unallocated clean 
run sanity 	ssssssss ssssssss 
information state working 	sss dum 
current branch 	xxxxxxxx 
merge head configure 	xxxxxxxx xxxxxxxx 
local branch 	xxx uxxx 
local downstream branch 	ssssssss ssssssss 
remote remote 	sss unallocated 
origin used git 	dirty ssssssss 
branch upstream 	ssssssss 
returns success read 	sss xxxxxxxx 
branch description 	xxxxxxxx xxxxxxxx 
check branch main 	xxxxxxxx ssssssss 
worktree linked 	ssssssss sss 
worktree die 	small pppppppp 
message describing checkout 	pppppppp 
location bswap.h 	pppnnnnn nnnd 
val val result 	pppppppp pppppppp 
result builtin 	pppnnnnn nnn 
constant swab builtin 	pppppppp pppppppp 
constant bswap 	pppnnnnn nnnd 
builtin constant bswap 	large 
git bswap 	ssssssss ssssssss 
git bswap make 	sss xxxxxxxx 
sure always 	xxxxxxxx xxxxxxxx 
sane definition ntohl 	xxxxxxxx large 
htonl libraries 	sampled size 
define function call 	large 
perform shifting 	minclass ssssssss 
bringing significant overhead 	ssssssss sssnnnnn 
simple operation 	nnn xxxxxxxx 
version compiler ought 	xxxxxxxx xxxxxxxx 
optimize properly 	xxxxxxxx large 
constant values 	sampled 
performance might improved 	size large 
cpu architecture 	minclass ssssssss 
bit loads fast 	ssssssss sss 
ntohl available 	xxxxxxxx xxxxxxxx 
otherwise fall back 	xxxxxxxx xxxxxxxx 
loads shifts 	arena 
portable faster architectures 	chunk map 
memory alignment 	misc corresponds 
issues builtin-fetch--tool.c buf 	one page 
show action 	within chunk 
refname sha oldval 	like arena 
msg rla 	chunk 
name head note 	map bits 
verbose force 	two separate 
sha old sha 	arrays stored 
oldh newh 	within chunk 
current updated msg 	header order 
head remote 	improve 
remote name 	cache locality 
remote nick local 	linkage run 
name merge 	trees two 
verbose force commit 	disjoint uses 
remote len 	arena runs 
note len sha 	avail 
note kind 	arena run 
keep signo remote 	conceptually uses 
name refs 	linkage use 
force merge len 	non full 
next single 	runs rather 
force merge local 	directly 
part retlen 	embedding linkage 
remote remote nick 	linkage list 
refs verbose 	dirty runs 
force buffer err 	profile counters 
len local 	used large 
name single force 	runs 
merge len 	small region 
reflist next 	run metadata 
next colon remote 	jemalloc arena 
result numrefs 	structs arena 
refs matchlen replacelen 	chunk header 
found one 	pointer 
remote lref colon 	arena owns 
tail next 	chunk stored 
eol sha namelen 	within node 
sha rref 	field whole 
remote result err 	used chunks 
pass line 	rtree 
name namelen shown 	support ivsalloc 
next rreflen 	core debugging 
lrr argc argv 	map pages 
prefix verbose 	within chunk 
force sopt arg 	keeps track 
result filename 	free 
result filename reflist 	large small 
remote result 	first map 
reflist strbuf 	bias entries 
read die errno 	omitted since 
strbuf detach 	chunk header 
getenv snprintf warning 	need 
update sha 	tracked map 
hex die sha 	omission saves 
info die 	header page 
show sha strncmp 	common chunk 
show update 	sizes dynamically 
env hashcmp show 	sized 
strncmp show 	read information 
update env lookup 	associated element 
commit reference 	arena bins 
lookup commit reference 	stored separately 
strcpy find 	partly reduce 
unique abbrev strcpy 	memory 
find unique 	usage one 
abbrev merge 	copy rather 
bases update env 	one per 
update env 	arena mainly 
sha error lookup 	avoid cacheline 
commit reference 	sharing 
gently strcmp strncmp 	run following 
strncmp strncmp 	layout pad 
strlen strncmp sprintf 	redzone reg 
sprintf sprintf 	offset region 
sha hex update 	redzone redzone 
local unlink 	region 
keep sigchain pop 	reg interval 
strlen strchr 	redzone redzone 
strncmp strlen xmemdupz 	region nregs 
sigchain push 	redzone alignment 
common atexit fgets 	pad reg 
isspace strlen 	interval 
strcmp die strcmp 	least minimum 
strcmp directory 	alignment reg 
strlen strlen 	size preserves 
xmalloc sprintf find 	alignment constraint 
local name 	depends alignment 
append fetch head 	pad 
isspace isspace 	either redzone 
isspace isspace strchr 	size present 
putchar strchr 	needed align 
strlen isspace strchr 	reg offset 
strlen memcmp 	size regions 
sha hex isspace 	run 
strncmp putchar 	bin size 
isspace strchrnul xcalloc 	redzone size 
isspace strchrnul 	interval regions 
memcmp error free 	reg size 
strcmp strcmp 	redzone size 
strcmp error strcmp 	total 
error git 	size run 
path fetch head 	bin size 
fopen error 	total number 
strerror append 	regions run 
fetch head fclose 	bin size 
strcmp error 	metadata 
git path fetch 	used manipulate 
head fopen 	bitmaps runs 
error strerror fetch 	associated bin 
store fclose 	offset first 
strcmp error strcmp 	region run 
stdin parse 	bin 
reflist strcmp error 	size operations 
strcmp stdin 	runcur runs 
pick rref strcmp 	stats require 
error strcmp 	locked run 
stdin expand refs 	allocation deallocation 
wildcard error 	arena 
storing glob glob 	may acquired 
lref colon 	holding one 
remote hierarchy name 	bin locks 
colon tail 	vise versa 
local next 	current run 
eol name identical 	used 
lref colon 	service allocations 
yes match pass 	bin size 
counts allocates 	non full 
pass fills builtin.h 	runs used 
git usage 	looking existing 
git info shortlog 	run 
len fmt 	runcur longer 
merge msg opts 	usable choose 
path mode 	non full 
sha sha valid 	run lowest 
buf buf 	memory policy 
size argc argv 	tends 
prefix argc 	keep objects 
argv prefix argc 	packed well 
argv prefix 	also help 
argc argv 	reduce number 
prefix argc argv 	almost empty 
prefix argc 	chunks 
argv prefix argc 	bin statistics 
argv prefix 	arena index 
argc argv prefix 	within arenas 
argc argv 	number threads 
prefix argc argv 	currently assigned 
prefix argc 	arena 
argv prefix argc 	field arenas 
argv prefix 	three classes 
argc argv prefix 	arena operations 
argc argv 	locking perspective 
prefix argc argv 	assignment modifies 
prefix argc 	nthreads 
argv prefix argc 	arenas bin 
argv prefix 	related operations 
argc argv prefix 	bin locks 
argc argv 	chunk run 
prefix argc 	related operations 
argv prefix argc 	mutex 
argv prefix 	list tcaches 
argc argv prefix 	extant threads 
argc argv 	associated arena 
prefix argc argv 	stats merged 
prefix argc 	incrementally exit 
argv prefix argc 	opt 
argv prefix 	stats print 
argc argv prefix 	enabled prng 
argc argv 	state cache 
prefix argc argv 	index randomization 
prefix argc 	large allocation 
argv prefix argc 	pointers 
argv prefix 	order avoid 
argc argv prefix 	rapid chunk 
argc argv 	allocation deallocation 
prefix argc argv 	arena oscillates 
prefix argc 	right cusp 
argv prefix 	needing 
argc argv prefix 	chunk cache 
argc argv 	recently freed 
prefix argc argv 	chunk spare 
prefix argc 	left arena 
argv prefix argc 	chunk trees 
argv prefix 	deleted 
argc argv prefix 	one spare 
argc argv 	chunk per 
prefix argc argv 	arena rather 
prefix argc 	one spare 
argv prefix argc 	total order 
argv prefix 	avoid 
argc argv prefix 	interactions multiple 
argc argv 	threads could 
prefix argc argv 	make single 
prefix argc 	spare inadequate 
argv prefix argc 	minimum ratio 
argv prefix 	log 
argc argv 	nactive ndirty 
prefix argc argv 	currently executing 
prefix argc 	arena purge 
argv prefix argc 	number pages 
argv prefix 	active runs 
argc argv prefix 	huge 
argc argv 	regions current 
prefix argc argv 	count pages 
prefix argc 	within unused 
argv prefix argc 	runs potentially 
argv prefix 	dirty madvise 
argc argv prefix 	madv 
argc argv 	dontneed called 
prefix argc argv 	tracking institute 
prefix argc 	limit much 
argv prefix argc 	dirty unused 
argv prefix 	memory mapped 
argc argv 	arena 
prefix argc argv 	size address 
prefix argc 	ordered arena 
argv prefix argc 	available runs 
argv prefix 	used first 
argc argv prefix 	best fit 
argc argv 	run 
prefix argc argv 	allocation unused 
prefix argc 	dirty memory 
argv prefix argc 	arena manages 
argv prefix 	dirty memory 
argc argv prefix 	conceptually tracked 
argc argv 	arbitrarily 
prefix argc argv 	interleaved lru 
prefix argc 	dirty runs 
argv prefix argc 	cached chunks 
argv prefix 	list linkage 
argc argv prefix 	actually semi 
argc argv 	duplicated 
prefix argc 	order avoid 
argv prefix argc 	extra arena 
argv prefix 	chunk map 
argc argv prefix 	misc space 
argc argv 	overhead lru 
prefix argc argv 	mru 
prefix argc 	arena chunk 
argv prefix argc 	chunks cache 
argv prefix 	node run 
argc argv prefix 	run runs 
argc argv 	dirty extant 
prefix argc argv 	huge 
prefix argc 	allocations synchronizes 
argv prefix argc 	huge allocation 
argv prefix 	update deallocation 
argc argv prefix 	trees chunks 
argc argv 	previously allocated 
prefix argc argv 	trees 
prefix argc 	differ node 
argv prefix 	ordering used 
argc argv prefix 	allocating chunks 
argc argv 	attempt use 
prefix argc argv 	address space 
prefix argc 	depending 
argv prefix argc 	function different 
argv prefix 	orderings needed 
argc argv prefix 	two trees 
argc argv 	contents cache 
prefix argc argv 	nodes allocated 
prefix argc 	via 
argv prefix argc 	alloc user 
argv prefix 	configurable chunk 
argc argv prefix 	hook functions 
argc argv 	bins used 
prefix argc argv 	store trees 
prefix argc 	free 
argv prefix argc 	regions jemalloc 
argv prefix 	arena structs 
argc argv 	jemalloc structs 
prefix argc argv 	number arena 
prefix bulk-checkin.c 	chunk header 
pack compression level 	pages 
pack tmp 	max run 
name offset pack 	size arenas 
idx opts 	max large 
written alloc written 	size number 
written state 	large size 
oid packname state 	classes 
sha stream 	number huge 
pack state flags 	size classes 
deflate pack 	jemalloc externs 
index bulk checkin 	jemalloc arena 
close unlink 	freeing pointer 
sha close sha 	lower 
close fixup 	region zero 
pack header footer 	cause assertion 
close strbuf 	failure avoid 
addf directory 	division variable 
finish tmp packfile 	divisor possible 
free free 	actual 
memset strbuf release 	division reduce 
reprepare packed 	allocator throughput 
git sha file 	rescale factor 
hashcmp create 	powers numerator 
tmp packfile reset 	denominator divisor 
pack idx 	power 
option write pack 	divide number 
header die 	power two 
errno finish bulk 	multiply right 
checkin copyright 	shift positions 
google inc make 	becomes interval 
objects wrote 	invs 
available may already 	size inv 
exist repository 	shift omit 
might want 	first three 
keep list sorted 	elements never 
need keep 	divide powers 
read contents size 	two 
bytes streaming 	handled tctx 
packfile state updating 	must always 
hash ctx 	initialized large 
signal failure returning 	runs surrounding 
negative resulting 	conditional logic 
pack would exceed 	equivalent 
pack size 	checking whether 
limit first pack 	ptr refers 
caller discard 	large run 
wrote current pack 	initialize tcache 
truncating opening 	checking size 
one caller call 	order 
rewinding input 	avoid infinite 
already hashed pointer 	recursion tcache 
kept untouched 	initialization size 
caller make 	allocation pointed 
sure hash called 	ptr large 
way caller 	allocation 
checkpoint hash status 	common demote 
calling ask 	function callers 
call pack would 	end looking 
bust size 	binind determine 
limit lazily create 	ptr small 
backing packfile 	allocation 
state pretend going 	small allocation 
write one 	possibly promoted 
note idx non 	large small 
writing writing 	allocation make 
current pack make 	sure use 
big need 	promoted 
truncate start pack 	size request 
write bulk-checkin.h 	size small 
index bulk checkin 	allocation jemalloc 
copyright google 	arena jemalloc 
inc bundle.c 	inlines asciilogo.h 
bundle signature sha 	ascii 
name list 	logo copyright 
header report path 	salvatore sanfilippo 
buf status 	antirez gmail 
sha prereq path 	dot rights 
header path 	reserved redistribution 
quiet header argc 	use 
argv header 	source binary 
verbose revs argv 	forms without 
refs commit 	modification permitted 
req message header 	provided following 
argc argv 	conditions met 
tag revs size 	redistributions 
line lineend 	source code 
date result bundle 	must retain 
revs pack 	copyright notice 
objects bundle revs 	list conditions 
argc argv 	following disclaimer 
rls buf 	redistributions 
rls fout sha 	binary form 
bundle revs 	must reproduce 
count oid display 	copyright notice 
flag one 	list conditions 
obj header path 	following 
argc argv 	disclaimer documentation 
bundle bundle stdout 	materials provided 
count revs 	distribution neither 
header bundle flags 	name redis 
argv index 	names contributors 
pack alloc grow 	may 
hashcpy xstrdup 	used endorse 
strbuf getwholeline strcmp 	promote products 
error strbuf 	derived software 
getwholeline strbuf strbuf 	without specific 
rtrim sha 	prior written 
hex isspace 	permission 
error list list 	software provided 
close strbuf 	copyright holders 
release open error 	contributors express 
parse bundle 	implied warranties 
header open memset 	including limited 
parse bundle 	implied 
header close strcmp 	warranties merchantability 
sha hex 	fitness particular 
init revisions parse 	purpose disclaimed 
pending error 	shall copyright 
error sha hex 	owner contributors 
setup revisions 	liable 
prepare revision walk 	direct indirect 
die revision 	incidental special 
error error oid 	exemplary consequential 
hex clear 	damages including 
commit marks free 	limited procurement 
list refs 	substitute 
list refs 	goods services 
list refs read 	loss use 
sha file 	data profits 
memmem memchr memchr 	business interruption 
strtoul free 	however caused 
argv pushl start 	theory 
command error 	liability whether 
write die write 	contract strict 
die oid 	liability tort 
hex write die 	including negligence 
close finish 	otherwise arising 
command error argv 	way 
pushl argv 	use software 
push start command 	even advised 
xfdopen strbuf 	possibility damage 
getwholeline write die 	async.c cmd 
sha hex 	len key 
parse die pending 	privdata 
sha hex 	src dup 
parse die 	privdata key 
strbuf release fclose 	key privdata 
finish command 	key privdata 
error dwim strlen 	val callback 
read full 	dict 
tag date range 	port port 
warning oidcmp 	source addr 
lookup commit reference 	path list 
parse die 	source list 
pending write die 	target reply 
oid hex 	reply 
write die write 	dstcb callbacks 
die strlen 	pvariant stype 
write die free 	sname reply 
write die 	status done 
strcmp hold file 	start str 
update dup 	len 
die errno write 	privdata cmd 
die strlen 	len pvariant 
init revisions 	hasnext cstr 
compute write prerequisites 	astr clen 
setup revisions 	alen sname 
error duplicates write 	privdata 
bundle refs 	format cmd 
die write pack 	len status 
data commit 	privdata format 
file die errno 	status privdata 
verify bundle 	argc argv 
run command error 	argvlen 
bundle header 	cmd len 
begins signature bundle 	status dict 
header ends 	gen hash 
empty line tip 	function sdslen 
lines name 	malloc memcpy 
refname prerequisites name 	sdslen 
optionally followed 	sdslen memcmp 
subject line 	sdsfree free 
remember update flag 	realloc dict 
allocation fast 	create dict 
check prereqs missing 	create redis 
line line 	connect 
verbose errors write 	non block 
pack data 	redis initialize 
bundle close write 	redis free 
bundle refs 	redis copy 
tips already parsed 	error redis 
revs pending 	connect 
side effect may 	bind non 
manipulate revs 	block redis 
pending include additional 	initialize redis 
necessary objects 	copy error 
like tags returns 	redis connect 
number refs 	unix 
written negative error 	non block 
make sure 	redis initialize 
refs wrote 	redis free 
correct max count 	redis copy 
limiting options 	error write 
could prevented tips 	malloc 
getting output 	memcpy memcpy 
non commit objects 	free redis 
tags blobs 	shift callback 
issue affected extra 	redis run 
constraints run 	callback redis 
git bundle create 	shift 
bndl name 	callback redis 
positive commit referenced 	run callback 
tag tag 	dict iterator 
positive end range 	dict next 
expressed terms 	redis run 
tag range need 	callback 
include name 	dict entry 
independent pack objects 	val dict 
input tag 	release iterator 
included output 	dict release 
otherwise would end 	dict iterator 
triggering empty 	dict 
bundle error end 	next redis 
header write 	run callback 
pack data close 	dict entry 
passed commit 	val dict 
file also close 	release iterator 
lockfile make 	dict 
copy file descriptor 	release cleanup 
avoid trying 	disconnect disconnect 
close twice write 	redis free 
signature init 	redis free 
revs list objects 	redis copy 
pack objects 	error 
later write prerequisites 	redis shift 
write pack 	callback redis 
basic handler bundle 	free redis 
files connect 	disconnect tolower 
repositories via 	sdsnewlen dict 
sneakernet invocation must 	find 
include action 	memcpy dict 
function create bundle 	entry val 
provide information 	strcasecmp dict 
existing bundle supporting 	sdsfree redis 
fetch pull 	shift callback 
remote builtin bundle 	redis 
usage argc 	reply sdslen 
argv prefix header 	redis disconnect 
cmd bundle 	redis push 
file bundle buffer 	callback redis 
usage snprintf 	shift callback 
memset strcmp read 	snprintf 
bundle header 	free redis 
strcmp close usage 	disconnect redis 
verify bundle 	subscribe callback 
strcmp close list 	redis run 
bundle refs 	callback free 
strcmp usage 	redis 
die create bundle 	free free 
strcmp die 	redis disconnect 
unbundle list bundle 	redis check 
refs usage 	socket error 
bundle header begins 	connect redis 
signature bundle 	disconnect 
header ends empty 	connect redis 
line tip 	handle connect 
lines name refname 	redis buffer 
prerequisites name 	read redis 
optionally followed subject 	disconnect read 
line remember 	redis 
update flag allocation 	process callbacks 
fast check 	redis handle 
prereqs missing line 	connect redis 
line verbose 	buffer write 
errors write 	redis disconnect 
pack data bundle 	write 
close write 	del write 
bundle refs tips 	read strchr 
already parsed 	strtol strchr 
revs pending side 	next argument 
effect may 	tolower strncasecmp 
manipulate revs pending 	next 
include additional 	argument sdsnewlen 
necessary objects like 	dict replace 
tags returns 	dict replace 
number refs written 	strncasecmp strncasecmp 
negative error 	redis push 
make sure refs 	callback 
wrote correct 	redis push 
max count limiting 	callback redis 
options could 	push callback 
prevented tips getting 	redis append 
output non 	command write 
commit objects 	redisv 
tags blobs issue 	format command 
affected extra 	redis command 
constraints run git 	free start 
bundle create 	redisv command 
bndl name positive 	end redis 
commit referenced 	format 
tag tag positive 	command argv 
end range 	redis command 
expressed terms tag 	free copyright 
range need 	salvatore sanfilippo 
include name independent 	antirez gmail 
pack objects 	dot 
input tag included 	copyright pieter 
output otherwise 	noordhuis pcnoordhuis 
would end triggering 	gmail dot 
empty bundle 	rights reserved 
error end header 	redistribution use 
write pack 	source 
data close 	binary forms 
passed commit file 	without modification 
also close 	permitted provided 
lockfile make copy 	following conditions 
file descriptor 	met redistributions 
avoid trying close 	source 
twice write 	code must 
signature init revs 	retain copyright 
list objects 	notice list 
pack objects later 	conditions following 
write prerequisites 	disclaimer redistributions 
write pack basic 	binary 
handler bundle 	form must 
files connect repositories 	reproduce copyright 
via sneakernet 	notice list 
invocation must include 	conditions following 
action function 	disclaimer documentation 
create bundle provide 	materials 
information existing 	provided distribution 
bundle supporting 	neither name 
fetch pull remote 	redis names 
bundle.c bundle 	contributors may 
signature sha name 	used endorse 
list header 	promote 
report path buf 	products derived 
status sha 	software without 
prereq path header 	specific prior 
path quiet 	written permission 
header argc argv 	software provided 
header verbose 	copyright 
revs argv refs 	holders contributors 
commit req 	express implied 
message header argc 	warranties including 
argv tag 	limited implied 
revs size line 	warranties merchantability 
lineend date 	fitness 
result bundle 	particular purpose 
revs pack objects 	disclaimed shall 
bundle revs 	copyright owner 
argc argv rls 	contributors liable 
buf rls 	direct indirect 
fout sha bundle 	incidental 
revs count 	special exemplary 
oid display flag 	consequential damages 
one obj 	including limited 
header path argc 	procurement substitute 
argv bundle 	goods services 
bundle stdout count 	loss 
revs header 	use data 
bundle flags argv 	profits business 
index pack 	interruption however 
alloc grow hashcpy 	caused theory 
xstrdup strbuf 	liability whether 
getwholeline strcmp error 	contract 
strbuf getwholeline 	strict liability 
strbuf strbuf 	tort including 
rtrim sha hex 	negligence otherwise 
isspace error 	arising way 
list list close 	use software 
strbuf release 	even 
open error parse 	advised possibility 
bundle header 	damage forward 
open memset parse 	declaration function 
bundle header 	hiredis functions 
close strcmp sha 	managing dictionary 
hex init 	callbacks 
revisions parse pending 	pub sub 
error error 	regular connect 
sha hex setup 	functions always 
revisions prepare 	flag redis 
revision walk die 	connected api 
revision error 	want 
error oid hex 	wait first 
clear commit 	write received 
marks free 	setting flag 
list refs list 	reset want 
refs list 	error field 
refs read sha 	accessible 
file memmem 	directly instead 
memchr memchr strtoul 	requiring indirection 
free argv 	redis context 
pushl start command 	common way 
error write 	detect established 
die write die 	connection 
oid hex 	wait first 
write die close 	write fired 
finish command 	assumes related 
error argv pushl 	library functions 
argv push 	already helper 
start command xfdopen 	functions 
strbuf getwholeline 	push shift 
write die sha 	callbacks copy 
hex parse 	callback stack 
die pending 	heap store 
sha hex parse 	callback list 
die strbuf 	copy 
release fclose finish 	callback heap 
command error 	stack helper 
dwim strlen read 	function free 
full tag 	context execute 
date range warning 	pending callbacks 
oidcmp lookup 	reply 
commit reference parse 	execute callbacks 
die pending 	invalid commands 
write die oid 	run subscription 
hex write 	callbacks callbacks 
die write die 	reply signal 
strlen write 	lib 
die free write 	clean execute 
die strcmp 	disconnect callback 
hold file 	redis free 
update dup die 	initiated destroying 
errno write 	context status 
die strlen init 	always 
revisions compute 	redis cleanup 
write prerequisites setup 	self free 
revisions error 	context function 
duplicates write bundle 	called callback 
refs die 	control needs 
write pack data 	returned 
commit file 	redis process 
die errno verify 	callbacks actual 
bundle run 	free ing 
command error bundle 	flag context 
header begins 	picked redis 
signature bundle header 	process 
ends empty 	callbacks otherwise 
line tip lines 	context immediately 
name refname 	free helper 
prerequisites name 	function make 
optionally followed subject 	disconnect happen 
line remember 	clean 
update flag allocation 	make sure 
fast check 	error accessible 
prereqs missing line 	clean disconnects 
line verbose 	pending callbacks 
errors write pack 	disconnection caused 
data bundle 	error 
close write bundle 	make sure 
refs tips 	pending callbacks 
already parsed revs 	cannot call 
pending side 	commands non 
effect may manipulate 	clean disconnects 
revs pending 	redis 
include additional necessary 	free execute 
objects like 	pending callbacks 
tags returns number 	reply tries 
refs written 	clean disconnect 
negative error 	redis meaning 
make sure refs 	stops 
wrote correct 	commands issued 
max count limiting 	tries flush 
options could 	output buffer 
prevented tips getting 	execute callbacks 
output non 	remaining replies 
commit objects tags 	function 
blobs issue 	called callback 
affected extra constraints 	might replies 
run git 	safely defer 
bundle create bndl 	disconnecting redis 
name positive 	process callbacks 
commit referenced tag 	otherwise 
tag positive 	disconnect immediately 
end range expressed 	pending callbacks 
terms tag 	custom reply 
range need include 	functions supported 
name independent 	pub sub 
pack objects 	fail 
input tag included 	hard used 
output otherwise 	locate right 
would end triggering 	callback unsubscribe 
empty bundle 	message last 
error end header 	unsubscribe message 
write pack 	revert 
data close passed 	non subscribe 
commit file 	mode shift 
also close lockfile 	callback invalid 
make copy 	commands connection 
file descriptor avoid 	disconnected replies 
trying close 	cue 
twice write signature 	really disconnect 
init revs 	monitor mode 
list objects pack 	repush callback 
objects later 	connection disconnected 
write prerequisites write 	simply stop 
pack basic 	trying 
handler bundle 	replies wait 
files connect repositories 	next loop 
via sneakernet 	tick even 
invocation must include 	context subscribed 
action function 	pending regular 
create bundle provide 	callbacks 
information existing 	reply pub 
bundle supporting fetch 	sub messages 
pull remote 	arrive spontaneous 
builtin bundle usage 	reply subscribed 
argc argv 	context error 
prefix header cmd 	reply 
bundle file 	sent connection 
bundle buffer usage 	exceeds maximum 
snprintf memset 	number allowed 
strcmp read bundle 	connections server 
header strcmp 	side seen 
close usage 	error 
verify bundle strcmp 	instead regular 
close list 	reply server 
bundle refs strcmp 	closes connection 
usage die 	sending prevent 
create bundle strcmp 	error overwritten 
die unbundle 	eof 
list bundle refs 	error connection 
usage bundle 	closed see 
header begins signature 	issue another 
bundle header 	possibility server 
ends empty line 	loading dataset 
tip lines 	also 
name refname prerequisites 	want close 
name optionally 	connection user 
followed subject line 	wait server 
remember update 	ready take 
flag allocation fast 	request 
check prereqs 	regular callbacks 
missing line 	errors context 
line verbose errors 	must subscribed 
write pack 	monitoring proceed 
data bundle close 	free ing 
write bundle 	redis 
refs tips already 	free called 
parsed revs 	callback reply 
pending side effect 	either callback 
may manipulate 	callbacks begin 
revs pending include 	either way 
additional necessary 	abort 
objects like tags 	error simply 
returns number 	ignore client 
refs written negative 	doesn know 
error make 	server spit 
sure refs wrote 	wire disconnect 
correct max 	error 
count limiting options 	reading reply 
could prevented 	helper function 
tips getting 	detect socket 
output non commit 	status first 
objects tags 	time read 
blobs issue affected 	write 
extra constraints 	fires connecting 
run git bundle 	succesful connect 
create bndl 	callback called 
name positive commit 	redis err 
referenced tag 	status context 
tag positive end 	free 
range expressed 	later connect 
terms tag range 	still progress 
need include 	mark context 
name independent pack 	connected function 
objects input 	called socket 
tag included output 	readable 
otherwise would 	processes replies 
end triggering empty 	read executes 
bundle error 	callbacks abort 
end header 	connect successful 
write pack data 	later context 
close passed 	still 
commit file also 	connected always 
close lockfile 	schedule reads 
make copy file 	abort connect 
descriptor avoid 	successful later 
trying close twice 	context still 
write signature 	connected 
init revs list 	writing done 
objects pack 	stop writing 
objects later write 	otherwise always 
prerequisites write 	schedule reads 
pack basic handler 	writes sets 
bundle files 	pointer 
connect repositories via 	first argument 
sneakernet invocation 	length starting 
must include 	returns number 
action function create 	bytes skip 
bundle provide 	following argument 
information existing bundle 	helper 
supporting fetch 	function redis 
pull remote bundle.h 	command family 
alloc sha 	functions writes 
name prerequisites references 	formatted command 
path quiet 	output buffer 
path header header 	registers 
path argc 	provided callback 
argv header verbose 	function context 
header bundle 	accept commands 
flags header argc 	connection closed 
argv cache-tree.c 	setup callback 
one onelen two 	find 
twolen path 	command appended 
pathlen mdl cmp 	every channel 
path pathlen 	pattern list 
create pos 	subscription callbacks 
path pathlen path 	useful call 
slash namelen 	unsubscribe 
pos istate path 	context subscribed 
cache entries 	one channels 
flags funny silent 	patterns unsubscribe 
name next 	response every 
name len dst 	channel pattern 
src cache 	unsubscribed 
entries baselen skip 	receive message 
count flags 	means append 
buffer missing dryrun 	callback function 
repair invalidate 	command monitor 
sub path slash 	flag push 
pathlen sublen 	callback 
subcnt subskip sub 	likely result 
path slash 	error reply 
pathlen entlen sha 	needs received 
mode expected 	passed callback 
missing sha 	always schedule 
istate flags cache 	write 
entries skip 	write buffer 
buffer path pathlen 	non empty 
prev root 	async.h port 
buffer size buf 	port source 
size subtree 	addr path 
sub subtree name 	privdata 
buffer size 	format privdata 
path slash sub 	format privdata 
sha index 	argc argv 
state index path 	argvlen copyright 
flags prefix 	salvatore sanfilippo 
entries valid newfd 	antirez 
file subtree 	gmail dot 
sha flags prefix 	copyright pieter 
desc entry 	noordhuis pcnoordhuis 
cnt sub subtree 	gmail dot 
istate root 	rights reserved 
info parent 	redistribution 
root ent info 	use source 
flags xcalloc 	binary forms 
cache free free 	without modification 
free free 	permitted provided 
memcmp subtree name 	following conditions 
cmp subtree 	met 
pos alloc grow 	redistributions source 
flex alloc 	code must 
mem memmove strlen 	retain copyright 
find subtree 	notice list 
strchrnul subtree pos 	conditions following 
cache free 	disclaimer 
free memmove find 	redistributions binary 
subtree invalidate 	form must 
path invalidate path 	reproduce copyright 
stage sha 	notice list 
hex strlen 	conditions following 
strlen strncmp cache 	disclaimer 
free free 	documentation materials 
sha file cache 	provided distribution 
fully valid 	neither name 
sha file namelen 	redis names 
memcmp strchr 	contributors may 
find subtree cache 	used 
update one 	endorse promote 
die discard unused 	products derived 
subtrees strbuf 	software without 
init namelen memcmp 	specific prior 
strchr find 	written permission 
subtree die sha 	software 
file strbuf 	provided copyright 
release error sha 	holders contributors 
hex intent 	express implied 
strbuf grow strbuf 	warranties including 
addf strbuf 	limited implied 
hash sha 	warranties 
file sha file 	merchantability fitness 
hashcpy hash 	particular purpose 
sha file write 	disclaimed shall 
sha file 	copyright owner 
strbuf release strbuf 	contributors liable 
release sha 	direct 
hex verify cache 	indirect incidental 
update one 	special exemplary 
strbuf grow strbuf 	consequential damages 
strbuf addf 	including limited 
sha hex strbuf 	procurement substitute 
subtree name 	goods 
cmp die write 	services loss 
one write 	use data 
one cache strtol 	profits business 
strtol hashcpy 	interruption however 
sha hex xcalloc 	caused theory 
read one 	liability 
cache sub 	whether contract 
die cache free 	strict liability 
read one 	tort including 
strchrnul find subtree 	negligence otherwise 
xcalloc hold 	arising way 
file update read 	use 
index cache 	software even 
free cache cache 	advised possibility 
fully valid 	damage need 
cache update write 	forward declaration 
locked index 	redis context 
cache find hashcpy 	dictionary 
hashcpy rollback 	header included 
file write index 	reply callback 
index file 	prototype container 
hashcpy init desc 	simple singly 
entry isdir 	linked list 
lookup parse cache 	list 
sub cache 	callbacks either 
prime cache 	regular replies 
rec cache free 	pub sub 
cache prime 	connection callback 
cache rec find 	prototypes context 
cache traversal 	connection 
cache find find 	redis hold 
cache traversal 	regular context 
cache find hashcmp 	realloc setup 
cache cache 	error flags 
update invalidate self 	used directly 
find invalidate 	used 
invalidate self exists 	hiredis library 
subtree subtree 	data hooks 
pos move one 	hooks called 
place entries 	library expects 
subtree pos verify 	start reading 
merged also 	writing 
verify cache path 	functions idempotent 
path file 	called either 
time point 	connection terminated 
know cache stage 	due error 
entries path 	per user 
file always comes 	request 
path way 	status accordingly 
cache sorted also 	redis redis 
path appear 	err called 
means conflicting one 	first write 
would immediately 	received regular 
follow first scan 	command 
subtrees update 	callbacks subscription 
start marking existing 	callbacks functions 
subtrees ones 	proxy hiredis 
unmarked result find 	handle read 
subtrees update 	write events 
end level bbb 	command 
slash path 	functions context 
baselen bbb 	write command 
sublen used next 	output buffer 
loop write 	provided callback 
level end level 	atomic.c test 
entries removed 	skip 
index written disk 	test body 
skip remain 	test body 
consistent future disk 	test body 
index intent 	test body 
entries exist disk 	test body 
index part 	test 
generated trees invalidate 	atomic.c test 
root force 	skip test 
cache users read 	body test 
elsewhere one 	body test 
cache entry consists 	body test 
following path 	body 
nul terminated entry 	test body 
count subtree 	test atomic.h 
sha missing 	success success 
invalid subtree cache 	atomic fetch 
entries subtrees 	atomic fetch 
skip name make 	sub 
sure name 	atomic compare 
exists heuristic directories 	exchange strong 
often want 	atomic store 
extend immediately hence 	atomic fetchadd 
read subtree 	atomic fetchadd 
whole path slash 	atomic 
name subtree 	cmpset atomic 
look free memory 	store rel 
becomes part 	atomic atomic 
linked list parsed 	atomic compare 
atexit able 	swap atomic 
write fine interested 	cas 
updating cache 	atomic read 
part next caller 	interlocked exchange 
ends old 	interlocked exchange 
index unupdated 	interlocked compare 
cache part misses 	exchange interlocked 
work performance 	exchange 
penalty big deal 	sync fetch 
find cache 	sync sub 
corresponds current level 	fetch sync 
without exploding 	compare swap 
full path textual 	sync test 
form root 	atomic 
cache given root 	fetch atomic 
current level 	fetch sub 
info root level 	atomic compare 
info prev 	exchange strong 
root otherwise find 	atomic store 
cache corresponds 	atomic 
one level find 	fetchadd atomic 
cache-tree.h cache 	fetchadd atomic 
count namelen used 	cmpset atomic 
name entry 	store rel 
count sha 	atomic atomic 
subtree subtree alloc 	atomic 
cache index 	compare swap 
state cache strbuf 	atomic cas 
root buffer 	atomic read 
size cache index 	interlocked exchange 
state sha 	interlocked exchange 
index state index 	interlocked 
path flags 	compare exchange 
prefix sha flags 	interlocked exchange 
prefix index 	sync fetch 
state cache ent 	sync sub 
info internally 	fetch sync 
used update one 	compare 
negative means 	swap sync 
invalid bitmasks write 	test atomic 
cache flags 	atomic atomic 
error codes 	atomic atomic 
cache.h flush level 	cas atomic 
level level 	cas 
flush hash hdr 	atomic write 
signature hdr 	atomic write 
version hdr entries 	atomic atomic 
sec nsec 	atomic atomic 
ctime mtime dev 	atomic cas 
ino uid 	atomic 
gid size ent 	cas atomic 
stat data 	write atomic 
mode flags namelen 	write atomic 
index sha 	atomic atomic 
name dst src 	atomic atomic 
state stage 	cas 
mode mode trust 	atomic cas 
executable bit 	atomic write 
symlinks mode mode 	atomic write 
cache version 	jemalloc types 
cache cache 	jemalloc structs 
alloc cache changed 	jemalloc 
resolve undo 	externs arithmetic 
cache split index 	functions arithmetic 
timestamp name 	result atomic 
hash dir hash 	operation atomic 
sha untracked 	operation prior 
index istate istate 	mutation 
istate bare 	following functions 
repository cfg git 	must redundantly 
work cfg 	compute result 
path gitdir gitdir 	returned functions 
namespaced path 	normally inlined 
path path error 	extra 
code suspect 	operations optimized 
prefix pathspec prefix 	away values 
len path 	aren used 
prefix len remaining 	callers atomic 
path prefix 	read atomic 
len path 	atomic 
prefix name prefix 	sub atomic 
name diagnose 	cas atomic 
misspelt rev prefix 	write bit 
name prefix 	operations outputs 
path git dir 	inputs outputs 
real git 	inputs 
dir dir flags 	outputs inputs 
index state 	clobbers implied 
index state pathspec 	xchgq outputs 
istate path 	inputs clobbers 
must exist index 	atomic fetchadd 
state path 	doesn 
index state index 	exist ever 
state index 	use function 
state flags index 	systems atomic 
state index 	fetchadd documented 
state path istate 	atomic api 
name namelen 	expose 
istate name 	atomic exchange 
istate name namelen 	bit operations 
igncase index 	outputs inputs 
state name namelen 	outputs inputs 
index state 	outputs inputs 
option index state 	implied 
pos name 	xchgl outputs 
index state pos 	inputs clobbers 
istate index 	documented atomic 
state path index 	api expose 
state path 	atomic exchange 
stat flags index 	pointer 
state path 	operations size 
flags mode sha 	operations operations 
path stage 	jemalloc inlines 
refresh options index 	base.c mtx 
state index 	avail szad 
state index 	nodes 
state cache entry 	allocated resident 
stat index 	mapped node 
state cache entry 	node minsize 
stat index 	node csize 
sha path flags 	nsize addr 
istate index 	size 
state flags pathspec 	ret csize 
seen header 	usize node 
msg index state 	key allocated 
file file 	resident mapped 
trust executable bit 	jemalloc valgrind 
trust ctime 	make 
check stat quote 	mem undefined 
path fully 	jemalloc valgrind 
symlinks minimum abbrev 	make mem 
abbrev ignore 	undefined node 
unchanged prefer symlink 	alloc cacheline 
refs log 	ceiling 
updates warn 	chunk ceiling 
ambiguous refs warn 	chunk alloc 
refname ambiguity 	node dalloc 
shared repository apply 	page ceiling 
whitespace apply 	extent node 
ignorewhitespace git attributes 	init 
file zlib 	cacheline ceiling 
compression level core 	extent node 
compression level 	init malloc 
core compression seen 	mutex extent 
packed git 	szad nsearch 
window size packed 	extent 
git limit 	szad chunk 
delta cache limit 	alloc extent 
big file 	node addr 
threshold pack size 	extent node 
limit cfg 	size extent 
check replace refs 	node 
git replace 	addr extent 
fsync files 	node size 
core preload index 	extent node 
core apply 	size extent 
sparse checkout precomposed 	szad insert 
unicode protect 	node 
hfs protect ntfs 	dalloc page 
git env 	ceiling page 
git index env 	ceiling jemalloc 
git graft 	valgrind make 
env git common 	mem defined 
dir env 	malloc 
paranoia comment line 	mutex unlock 
comment line 	malloc mutex 
notes name grafts 	malloc mutex 
replace parents 	unlock malloc 
repository format version 	mutex init 
repository format 	extent 
precious objects attribute 	szad malloc 
attribute attribute 	mutex prefork 
attribute attribute 	malloc mutex 
attribute attribute attribute 	postfork parent 
attribute sha 	malloc 
sha sha sha 	mutex postfork 
len hex 	child data 
sha len sha 	mtx must 
oid sha 	held mtx 
sha oid oid 	must held 
sha oid 	mtx 
sha dst sha 	must held 
src dst 	allocate enough 
src hash oid 	space also 
sha path 	carve node 
path suffix len 	necessary alloc 
pattern suffix 	guarantees 
len mode pattern 	demand zeroed 
mode path 	memory order 
path path path 	make multi 
strict path 	page sparse 
path path 	data structures 
path prefix prefix 	radix 
dst src 	nodes efficient 
prefix len dst 	respect physical 
src path 	memory usage 
prefixes path suffix 	round size 
path name 	nearest multiple 
filename read sha 	cacheline 
file extended 	size chance 
lookup replace sha 	cache line 
sha flag 	sharing use 
buf len type 	existing space 
sha buf 	allocate space 
len type sha 	one 
buf len 	page resident 
type sha flags 	every page 
pretend sha 	boundary crossed 
file sha 	allocation base.h 
mtime name sha 	size allocated 
size stream 	resident 
map mapsize buffer 	mapped jemalloc 
bufsiz hdr 	types jemalloc 
sizep check packed 	structs jemalloc 
crc sha 	externs jemalloc 
buf size type 	inlines bio.c 
tmpfile filename 	bio 
sha sha flags 	threads bio 
sha oid 	mutex bio 
sha sha sha 	condvar bio 
type hexval 	jobs bio 
table path mode 	pending time 
symlink path 	arg 
str sha str 	arg arg 
sha str 	arg attr 
sha str sha 	stacksize arg 
str sha 	type arg 
str sha 	arg arg 
name prefix str 	job 
flags sha 	arg job 
orc prefix hex 	type sigset 
sha hex 	type val 
sha sha sha 	err pthread 
oid str 	mutex init 
len strbuf str 	pthread 
sha name 	cond init 
len mode name 	list create 
len mode 	pthread attr 
name len mode 	init pthread 
name len 	attr getstacksize 
mode name len 	pthread 
name len 	attr setstacksize 
name len stage 	pthread create 
name len 	server log 
stage sha required 	exit zmalloc 
type size 	time pthread 
sha ret 	mutex 
peel type path 	list node 
fmt path 	tail pthread 
fmt pager program 	cond signal 
pager use 	pthread mutex 
color cmd child 	unlock server 
process pager 	log 
editor program askpass 	pthread setcancelstate 
program excludes 	pthread setcanceltype 
file dst line 	pthread mutex 
linelen buf 	sigemptyset sigaddset 
data bytes prog 	pthread sigmask 
prefix pathspec 	server 
flags diff refresh 	log strerror 
index whitespace 	list length 
rule cfg line 	pthread cond 
len rule 	wait list 
line len rule 	first pthread 
stream reset 	mutex 
strbuf line 	unlock close 
len rule name 	aof fsync 
prefix cmdline 	server panic 
argv cmdline errno 	zfree pthread 
repository prefix 	mutex list 
startup info strategy 	del 
xopts xopts 	node pthread 
common head arg 	mutex pthread 
remotes overwrite 	mutex unlock 
ignore file argv 	pthread cancel 
path millisec 	pthread server 
dir share memcpy 	log 
offsetof offsetof 	strerror server 
islnk isdir isgitlink 	log background 
permissions isreg 	service redis 
islnk isreg isreg 	file operations 
create mode 	need perform 
create mode 	background 
ntohl isreg isdir 	currently single 
isgitlink islnk 	operation background 
isreg permissions islnk 	close system 
isdir hashcmp 	call needed 
hashcmp hashcmp memcpy 	process last 
hashcpy memset 	owner 
hashclr hashcmp dir 	reference file 
sep dos 	closing means 
drive prefix lookup 	unlinking deletion 
replace lookup 	file slow 
replace sha file 	blocking server 
flags platform 	future 
underlying implementation sha 	either implementing 
could open 	things need 
ssl blk sha 	libeio however 
apple common 	probably term 
crypto etc note 	uses file 
including sha 	may 
header may 	want put 
already defined platform 	redis specific 
sha ctx 	background tasks 
implementations like block 	instance impossible 
sha ppc 	need non 
sha list open 	blocking 
ssl compatible 	flushdb flushall 
sha implementations length 	implementation design 
bytes hex 	design trivial 
digits name sha 	structure representing 
unknown mode 	job perform 
impossible combination ififo 	different 
ifchr directory 	job queue 
link link another 	every job 
git directory 	type every 
normally valid mode 	wait jobs 
also happens 	queue process 
ifdir iflnk mode 	every 
bits also 	job sequentially 
used internally 	jobs type 
computations must overlap 	guaranteed processed 
valid modes 	least recently 
must emitted outside 	inserted recently 
world appear 	inserted 
disk network words 	older jobs 
temporary fields 	processed first 
internally use stay 	currently way 
house approach 	creator job 
valid standard fits 	notified completion 
bits git 	operation 
codebase mode assumed 	added needed 
least bits 	copyright salvatore 
used internally diff 	sanfilippo antirez 
intensive research 	gmail dot 
course many years 	rights reserved 
shown port 	redistribution 
totally unused anything 	use source 
search port 	binary forms 
match documents 	without modification 
www google puts 	permitted provided 
port properly 	following conditions 
assigned git use 	met 
iana git 	redistributions source 
assigned git tcp 	code must 
git pack 	retain copyright 
transfer service git 	notice list 
udp git 	conditions following 
pack transfer service 	disclaimer 
linus torvalds 	redistributions binary 
torvalds osdl point 	form must 
contact september 	reproduce copyright 
see http www 	notice list 
iana assignments 	conditions following 
port numbers basic 	disclaimer 
data structures 	documentation materials 
directory cache 	provided distribution 
dirc cache time 	neither name 
low bits 	redis names 
time doesn matter 	contributors may 
overflows check 	used 
equality bits save 	endorse promote 
link extension 	products derived 
range ffff fff 	software without 
flags divided 	specific prior 
two parts memory 	written permission 
flags disk 	software 
ones flags extended 	provided copyright 
flags saved 	holders contributors 
disk want save 	express implied 
flag extended 	warranties including 
flags memory flags 	limited implied 
work directory 	warranties 
used temporarily mark 	merchantability fitness 
paths matched 	particular purpose 
pathspecs extended 	disclaimed shall 
disk flags extended 	copyright owner 
future extension 	contributors liable 
safeguard avoid saving 	direct 
wrong flags 	indirect incidental 
extended won saved 	special exemplary 
semantic known 	consequential damages 
bits ffff saved 	including limited 
flags already 	procurement substitute 
bits currently memory 	goods 
flags forward 	services loss 
structure decls copy 	use data 
sha stat 	profits business 
state cache entry 	interruption however 
one another 	caused theory 
never change name 	liability 
hash state 	whether contract 
copy hash chain 	strict liability 
name restore 	tort including 
hash state 	negligence otherwise 
unclassified changes name 	arising way 
hashing future 	use 
expansion check local 	software even 
repo env 	advised possibility 
list environment variable 	damage following 
expected contain 	used hold 
indicating whether treat 	number pending 
git dir 	jobs 
foo git git 	every type 
git work 	allows export 
given expected users 	bio pending 
make use 	jobs type 
use internally communicate 	api useful 
sub processes 	main 
bare repo defaults 	wants perform 
repository local 	operation may 
git environment variables 	involve objects 
cleared git 	shared background 
spawns sub 	main wait 
process runs inside 	longer 
another repository 	jobs type 
terminated makes easy 	executed performing 
pass env 	sensible operation 
parameter run command 	data also 
invocation simple 	useful reporting 
walk given path 	structure 
git directory 	represents background 
note looks directory 	job used 
want know 	locally file 
whether foo git 	api expose 
repository must 	internals time 
feed path foo 	job 
given path 	created job 
root git repository 	specific arguments 
submodule bare 	pointers need 
repositories creating bare 	pass three 
repository foo 	arguments pass 
git calling 	pointer 
git repository foo 	structure alike 
run read 	make sure 
errors err side 	enough stack 
saying yes 	perform things 
usually consider sub 	main initialize 
repos precious 	background 
would prefer err 	system spawning 
side disrupting 	initialization state 
deleting realloc buffer 	vars objects 
pointed variable 	stack size 
hold least entries 	may small 
number entries 	system 
currently allocated alloc 	world full 
standard growing 	solaris fixes 
factor alloc macro 	ready spawn 
use expression 	threads use 
side effect 	single argument 
alloc initialize use 	function 
cache information 	accepts order 
testting replace file 	pass job 
directory skip 	responsible check 
conflict checks append 	type within 
read replace 	right interval 
existing ones invalidate 	make 
cache stat 	killable time 
comparison even valid 	bio kill 
check contents 	threads work 
report dirty racily 	reliably block 
clean entries 	sigalrm sure 
stat comparison even 	main 
skip worktree 	receive watchdog 
ignore non existent 	signal loop 
files stat 	always starts 
update enable stat 	hold pop 
refresh record 	job queue 
data use 	possible 
check whether file 	unlock background 
might changed 	system know 
consistent file changed 	stand alone 
since filled 	job structure 
differences combination mtime 	process process 
changed ctime 	job 
changed owner changed 	accordingly type 
inode changed 	reiterating loop 
data changed ignore 	longer jobs 
valid allow 	process block 
unmerged quiet ignore 	pthread cond 
non existent 	wait 
ignore submodules user 	number pending 
friendly output 	jobs specified 
needs update environment 	type kill 
bits configuration 	running bio 
mechanism replace refs 	threads unclean 
need run 	way 
variable initialized 	function used 
unless replace used 	critical stop 
git replace 	threads reason 
objects commands want 	currently redis 
replace references 	crash instance 
active optimization also 	sigsegv 
replace references 	order perform 
sought none include 	fast memory 
broken refs 	check without 
iterations generally choke 	threads messing 
dangerous operations 	memory bio.h 
rather letting silently 	type 
proceed without 	arg arg 
taking broken account 	arg type 
character begins 	type num 
commented line user 	type copyright 
editable file 	salvatore sanfilippo 
subject stripspace git 	antirez 
repo version 	gmail dot 
version write 	rights reserved 
read variant highest 	redistribution use 
number know 	source binary 
handle statically allocated 	forms without 
filename either 	modification 
generically mkpath repository 	permitted provided 
directory git 	following conditions 
path submodule repository 	met redistributions 
directory git 	source code 
path submodule cases 	must retain 
note result 	copyright 
may overwritten another 	notice list 
call functions 	conditions following 
consider safer dup 	disclaimer redistributions 
strbuf formats 	binary form 
cases versions already 	must reproduce 
removed define 	copyright 
memoized git 	notice list 
path like git 	conditions following 
path func 	disclaimer documentation 
git path foo 	materials provided 
foo use 	distribution neither 
one ones name 	name 
file local 	redis names 
database would used 	contributors may 
store loose 	used endorse 
specified sha pointer 	promote products 
statically allocated 	derived software 
buffer overwritten time 	without 
function called 	specific prior 
name local packfile 	written permission 
specified sha 	software provided 
name pointer memory 	copyright holders 
overwritten time 	contributors express 
function called name 	implied 
local pack 	warranties including 
index file 	limited implied 
specified sha name 	warranties merchantability 
pointer memory 	fitness particular 
overwritten time function 	purpose disclaimed 
called abbreviated 	shall 
sha unique within 	copyright owner 
repository database 	contributors liable 
result least len 	direct indirect 
characters nul 	incidental special 
terminated non version 	exemplary consequential 
returns buffer 	damages 
overwritten subsequent calls 	including limited 
variant writes 	procurement substitute 
buffer supplied caller 	goods services 
must least 	loss use 
git sha hexsz 	data profits 
bytes number 	business 
bytes written excluding 	interruption however 
nul terminator 	caused theory 
note version 	liability whether 
avoids buffer fully 	contract strict 
reentrant calls 	liability tort 
non reentrant git 	including 
code permissions 	negligence otherwise 
passing mode arguments 	arising way 
open note 	use software 
note note perm 	even advised 
umask old 	possibility damage 
perm old perm 	exported 
everybody enumerations 	api background 
must changed old 	job opcodes 
repositories core 	deferred close 
sharedrepository written numeric 	syscall deferred 
format therefore 	aof fsync 
values preserved compatibility 	bitmap.c 
reasons create 	binfo nbits 
directory containing named 	count binfo 
path care 	nbits binfo 
somewhat safe 	bitmap binfo 
races one scld 	extra count 
error values 	bitmap 
indicate success failure 	bits groups 
scld vanished 	bitmap bits 
indicates one ancestor 	groups bitmap 
directories path 	info init 
existed one point 	bitmap info 
function call 	ngroups 
suddenly vanished probably 	memset compute 
another process 	number groups 
pruned directory working 	necessary store 
robust kind 	nbits bits 
race callers might 	progressively work 
want invoking 	upward 
function returns scld 	levels reaching 
vanished newly 	level requires 
allocated evaluation 	one bits 
xdg config home 	actually inverted 
git filename 	regard external 
xdg config home 	bitmap 
non empty 	bitmap starts 
otherwise home config 	bits trailing 
git filename 	unused bits 
upon error replacement 	note uses 
function declared 	bit correspond 
benefit lookup replace 	first 
please call 	logical bit 
directly sha replaced 	extra bits 
replacement name 	significant bits 
replaced recursively necessary 	last iteratively 
either sha 	bits 
pointer permanently allocated 	starting beginning 
replacement suppressed 	iteratively unset 
always sha read 	bits starting 
unpack sha 	end verify 
file memory 	bitmap sfu 
write memory sha 	reaches 
file flag 	unset bits 
enable extra checks 	iteratively bits 
accessing packed 	starting beginning 
objects iff named 	verify bitmap 
sha whether 	sfu looks 
local alternate database 	past 
whether packed 	prev size 
loose function respect 	size binfo 
replace references 	bitmap binfo 
quick flag check 	bitmap binfo 
pack directory 	bitmap binfo 
cannot find means 	bitmap 
may give 	bitmap size 
negative answer another 	bitmap info 
process simultaneously 	init malloc 
repacking iff alternate 	bitmap info 
database loose 	ngroups bitmap 
specified name 	init 
function respect replace 	bitmap free 
references convert 	bitmap info 
hex sha representation 	init malloc 
symlink path 	bitmap info 
used entry follow 	ngroups bitmap 
symlinks symlinks 	init 
point outside repository 	bitmap bitmap 
read sha 	full free 
hexadecimal format characters 	bitmap info 
starting hex 	init malloc 
write result sha 	bitmap info 
binary form 	ngroups 
success reading stops 	bitmap init 
nul encountered 	bitmap bitmap 
input safe pass 	full bitmap 
function arbitrary 	unset bitmap 
terminated convert binary 	bitmap full 
sha hex 	free 
equivalent variant 	bitmap info 
reentrant writes nul 	init malloc 
terminated output 	bitmap info 
buffer must least 	ngroups bitmap 
git sha 	init bitmap 
hexsz bytes returns 	sfu 
pointer convenience 	bitmap full 
non variant returns 	bitmap unset 
buffer uses 	bitmap sfu 
ring buffers making 	bitmap unset 
safe make 	bitmap bitmap 
multiple calls single 	bitmap 
statement like 	sfu bitmap 
sha hex one 	unset bitmap 
sha hex 	sfu bitmap 
two buffer result 	full free 
buffer sha 	test compute 
hex convenience helper 	number 
passing constant 	groups necessary 
type like 	store nbits 
show date date 	bits progressively 
mode normal 	work upward 
signals success time 	levels reaching 
part result 	level 
may input lacks 	requires one 
timestamp zone 	bits actually 
like show date 	inverted regard 
pull timestamp 	external bitmap 
parameters ident split 	bitmap starts 
also sanity 	bits 
check values produce 	trailing unused 
well known 	bits note 
sentinel date appear 	uses bit 
bogus compare 	correspond first 
split idents equality 	logical bit 
strict ordering 	extra 
note compare 	bits significant 
ident part line 	bits last 
ignoring timestamp 	iteratively bits 
two fields must 	starting beginning 
choose one 	iteratively unset 
primary key currently 	bits 
arbitrarily pick 	starting end 
email something like 	verify bitmap 
git objects 	sfu reaches 
pack xxxxx pack 	unset bits 
hook report 	iteratively bits 
invalid files pack 	starting 
directory mmap 	beginning verify 
index file specified 	bitmap sfu 
packfile already 	looks past 
mmapped success munmap 	bitmap.c binfo 
index file 	nbits count 
specified packfile currently 	binfo 
mmapped make 	nbits binfo 
sure pointer 	bitmap binfo 
access mmap index 	extra count 
file within 	bitmap bits 
bounds provide least 	groups bitmap 
bytes data 	bits 
note necessary variable 	groups bitmap 
length segments 	info init 
file like bit 	bitmap info 
extended offset 	ngroups memset 
table compare size 	compute number 
length parts 	groups 
open file sha 	necessary store 
nth within 	nbits bits 
specified packfile open 	progressively work 
index already 	upward levels 
open points sha 	reaching level 
within mmapped 	requires 
index error offset 	one bits 
nth within 	actually inverted 
specified packfile 	regard external 
index must already 	bitmap bitmap 
opened named 	starts bits 
sha present specified 	trailing 
packfile offset 	unused bits 
within packfile otherwise 	note uses 
iterate files 	bit correspond 
loose parts directory 	first logical 
path triggering 	bit extra 
following callbacks loose 	bits 
called loose 	significant bits 
find loose cruft 	last iteratively 
called files 	bits starting 
appear loose objects 	beginning iteratively 
note look 	unset bits 
loose directories objects 	starting 
report objects 	end verify 
foobar cruft loose 	bitmap sfu 
subdir called 	reaches unset 
top level 	bits iteratively 
hashed subdirectory directory 	bits starting 
objdir called 	beginning 
objects directory processed 	verify bitmap 
callback ignored 	sfu looks 
callbacks returning non 	past prev 
zero end 	size size 
iteration buf variant 	binfo bitmap 
path strbuf 	binfo 
also used scratch 	bitmap binfo 
buffer restored 	bitmap binfo 
original contents function 	bitmap bitmap 
returns iterate 	size bitmap 
loose packed objects 	info init 
local repository 	malloc 
alternates repositories unless 	bitmap info 
local flag 	ngroups bitmap 
request response 	init bitmap 
nothing expose cached 	free bitmap 
nothing expose 	info init 
loose dumb servers 	malloc 
support git 	bitmap info 
config parse key 	ngroups bitmap 
returns negated 	init bitmap 
git config gently 	bitmap full 
git config 	free bitmap 
multivar gently match 	info 
parse config 	init malloc 
key form section 	bitmap info 
subsection key 	ngroups bitmap 
gets handed config 	init bitmap 
caller provides 	bitmap full 
section match otherwise 	bitmap 
subsection key 	unset bitmap 
parameters filled function 	bitmap full 
subsection missing 	free bitmap 
contents list 	info init 
ordered according position 	malloc bitmap 
config files 	info 
order parsing files 	ngroups bitmap 
key pair 	init bitmap 
last position git 	sfu bitmap 
config last 	full bitmap 
item list hack 	unset bitmap 
test programs 	sfu 
like test dump 	bitmap unset 
untracked cache 	bitmap bitmap 
ensure modify untracked 	bitmap sfu 
cache reading 	bitmap unset 
use otherwise helper 	bitmap sfu 
functions pager 	bitmap 
alloc pkt line 	full free 
success addition 	test compute 
file failed files 	number groups 
ignore errors 	necessary store 
specified flags 	nbits bits 
diff match trees 	progressively 
whitespace rules 	work upward 
used diff apply 	levels reaching 
last two 	level requires 
digits tab width 	one bits 
files takes 	actually inverted 
negative returned split 	regard 
cmdline git 	external bitmap 
merge encapsulate concept 	bitmap starts 
whether file 	bits trailing 
changed since last 	unused bits 
uses criteria 	note uses 
similar used index 	bit 
returns path 	correspond first 
regular file symlink 	logical bit 
regular file 	extra bits 
matches saved stat 	significant bits 
validity otherwise 	last iteratively 
missing inaccessible 	bits 
file considered match 	starting beginning 
initialized previous 	iteratively unset 
update found inaccessible 	bits starting 
file update 	end verify 
stat validity file 	bitmap sfu 
opened descriptor 	reaches 
file missing inaccessible 	unset bits 
regular file 	iteratively bits 
future calls stat 	starting beginning 
validity check 	verify bitmap 
match iff one 	sfu looks 
conditions continues 	past 
create directory share 	bitmap.h offset 
nonzero adjust 	nbits nlevels 
permissions according shared 	levels binfo 
repository setting 	nbits binfo 
use directories 	nbits bitmap 
git dir use 	binfo 
working directories 	bitmap binfo 
cache cat-file.c enabled 	bitmap binfo 
follow symlinks 	bit bitmap 
print contents buffer 	binfo bit 
output objects 	bitmap binfo 
format opt exp 	bitmap 
type obj 	binfo bit 
name unknown type 	bitmap binfo 
sha buf 	rgoff bitmap 
size obj context 	binfo bit 
flags args 	goff bitmap 
blob sha buffer 	binfo 
target sha 	bit goff 
size disk size 	bitmap binfo 
rest delta 	bit bitmap 
sha mark query 	binfo bit 
split whitespace 	goff propagate 
info atom 	bitmap 
slen alen atom 	bitmap bitmap 
len vdata 	full jemalloc 
data start data 	ffsl jemalloc 
end opt 	ffsl bitmap 
data len opt 	bitmap bitmap 
data sha 	maximum 
size contents obj 	bitmap bit 
name opt 	count bitmap 
data buf obj 	maxbits number 
name opt 	bits per 
data ctx flags 	number groups 
opt expand 	required 
sha vdata data 	store given 
sha path 	number bits 
data sha pack 	number groups 
pos data 	required particular 
opt buf data 	level given 
save warning 	number 
retval cat 	bits assuming 
file usage opt 	number levels 
arg unset 	number groups 
argc argv prefix 	required given 
opt obj 	number bits 
name batch unknown 	maximum 
type options 	number groups 
sha context die 	required support 
sha info 	bitmap maxbits 
extended die strbuf 	maximum number 
release sha 	levels possible 
info extended die 	jemalloc 
sha file 	types offset 
die textconv sha 	level groups 
info die 	within groups 
cmd stream blob 	logical number 
read sha 	bits bitmap 
file die type 	stored 
sha info 	bottom level 
read sha 	number levels 
file skip prefix 	necessary nbits 
sha hex 	first nlevels 
die sha hex 	elements used 
free hashcpy 	levels 
sha info stream 	ordered bottom 
blob read 	top bottom 
reference die die 	level stored 
write die 	levels jemalloc 
strlen memcmp atom 	structs jemalloc 
strbuf addstr 	externs 
sha hex atom 	bitmap full 
strbuf addstr 	iff root 
atom strbuf addf 	propagate state 
atom strbuf 	transitions sfu 
addf atom strbuf 	first unset 
addstr atom 	propagate 
strbuf addstr sha 	state transitions 
hex die 	jemalloc inlines 
strchr die 	bitops.c offset 
expand atom fwrite 	loffset err 
die errno 	count bits 
write die fflush 	bitsinbyte 
stream blob 	aux aux 
die sha hex 	aux aux 
read sha 	aux aux 
file die sha 	aux count 
hex die 	bit skipval 
sha hex die 	one 
sha hex 	pos err 
batch write free 	bitoffset bit 
sha info 	byteval bitval 
extended sha hex 	llbuf bitoffset 
fflush strbuf 	bit bitval 
expand strbuf addch 	opname 
batch write 	targetkey numkeys 
strbuf release 	objects src 
print die batch 	len maxlen 
write sha 	minlen res 
context strlen strlen 	output lres 
strlen die 	start 
fflush fflush batch 	end strlen 
write hashcpy 	llbuf bytes 
batch write sha 	bit start 
append sha 	end strlen 
append memset strbuf 	llbuf end 
expand loose 	given 
packed sha unique 	bytes pos 
sha clear 	reply reply 
strbuf getline strpbrk 	error server 
strchr batch 	panic bit 
one strbuf release 	offset argument 
userdiff config 	reply 
git config strcmp 	reply error 
git config 	lookup key 
parse options 	write create 
usage options usage 	sdsnewlen check 
options usage 	type unshare 
options usage options 	sdsgrowzero 
batch objects 	signal modified 
die cat one 	key notify 
file git 	keyspace reply 
information manager hell 	bit offset 
copyright linus 	argument lookup 
torvalds custom pretty 	key 
print otherwise 	read reply 
spit data attempted 	check type 
dereference tag 	sds encoded 
blob failed may 	sdslen reply 
dereference mechanisms 	strcasecmp strcasecmp 
code aware fall 	strcasecmp 
back usual 	strcasecmp reply 
mark query expand 	reply error 
anything rather 	zmalloc zmalloc 
mark info 	zmalloc lookup 
items wish query 	key read 
whether split 	check 
input whitespace feeding 	type decr 
sha decided 	count zfree 
mark query phase 	zfree zfree 
whether rest 	decoded sdslen 
token format mark 	sdsnewlen memcpy 
query run 	memcpy 
info passed sha 	decr count 
info extended 	zfree zfree 
point data elements 	zfree create 
retrieve response 	key notify 
expand special mark 	keyspace decr 
query flag 	count 
prime info handed 	signal modified 
sha info 	key notify 
extended printing always 	keyspace reply 
fill type 	lookup key 
since want 	read reply 
decide whether stream 	check 
going call 	type sdslen 
sha potentially large 	reply reply 
number objects 	reply reply 
large cases actual 	reply redis 
sha cost 	popcount reply 
check one also 	reply 
warn ends 	error lookup 
dwarfing actual cost 	key read 
lookups work 	reply check 
around turning warning 	type sdslen 
split first 	reply reply 
whitespace tying beginning 	reply 
saving remainder 	reply redis 
data rest check-attr.c 	bitpos reply 
attrs cached 	reply bit 
attrs stdin 	operations copyright 
paths check attr 	salvatore sanfilippo 
usage nul 	antirez 
term line check 	gmail dot 
attr options 	rights reserved 
cnt check file 	redistribution use 
prefix cnt 	source binary 
check file full 	forms without 
path prefix 	modification 
cnt check buf 	permitted provided 
unquoted getline 	following conditions 
msg argc argv 	met redistributions 
prefix check 	source code 
cnt doubledash filei 	must retain 
name attr 	copyright 
attr attr unset 	notice list 
git attr 	conditions following 
name quote style 	disclaimer redistributions 
git attr 	binary form 
name prefix 	must reproduce 
path strlen git 	copyright 
check attr 	notice list 
die output attr 	conditions following 
git attrs 	disclaimer documentation 
die output attr 	materials provided 
free free 	distribution neither 
getline strbuf reset 	name 
unquote style 	redis names 
die strbuf swap 	contributors may 
check attr 	used endorse 
maybe flush die 	promote products 
strbuf release 	derived software 
strbuf release error 	without 
usage options 	specific prior 
bare repository setup 	written permission 
work git 	software provided 
config parse options 	copyright holders 
read cache 	contributors express 
die git 	implied 
attr direction strcmp 	warranties including 
error usage 	limited implied 
error usage error 	warranties merchantability 
usage error 	fitness particular 
usage error usage 	purpose 
xcalloc git 	disclaimed shall 
attr error check 	copyright owner 
attr stdin 	contributors liable 
paths check attr 	direct indirect 
maybe flush 	incidental special 
die path attrname 	exemplary 
attrvalue process 	consequential damages 
attribute arguments treat 	including limited 
arguments attribute 	procurement substitute 
names treat exactly 	goods services 
one argument 	loss use 
attribute name check 	data 
file argument 	profits business 
check-ignore.c quiet 	interruption however 
verbose stdin paths 	caused theory 
show non 	liability whether 
matching index check 	contract strict 
ignore usage 	liability 
nul term line 	tort including 
check ignore 	negligence otherwise 
options path exclude 	arising way 
bang slash 	use software 
dir prefix argc 	even advised 
argv full 	possibility 
path seen exclude 	damage helpers 
pathspec dir 	low level 
prefix buf unquoted 	bit functions 
pathspec getline 	helper function 
num ignored argc 	used getbit 
argv prefix 	setbit 
num ignored 	parses bit 
dir write name 	offset argument 
quoted quote 	making sure 
style quote style 	error returned 
fputc parse 	negative overflows 
pathspec find pathspecs 	redis 
matching index 	limit limit 
last exclude matching 	offset bytes 
output exclude 	count number 
free getline strbuf 	bits binary 
reset unquote 	pointed count 
style die strbuf 	bytes 
swap check 	implementation function 
ignore maybe flush 	required work 
die strbuf 	input length 
release strbuf release 	count initial 
git config 	bytes aligned 
parse options die 	bit 
die die 	count bits 
die die 	bytes time 
die read cache 	count remaining 
die memset 	bytes position 
setup standard excludes 	first bit 
check ignore 	one 
stdin paths check 	bit zero 
ignore maybe 	bit bitmap 
flush die clear 	starting count 
directory check 	bytes function 
ignore needs paths 	guaranteed bit 
magic beyond 	since 
really irrelevant look 	zero bit 
pathspecs matching 	found returns 
entries index since 	count assuming 
ignored order 	zero padded 
consistent git status 	right however 
git etc 	bit 
read cache necessary 	possible single 
watch submodules 	bit bitmap 
check-mailmap.c use 	special returned 
stdin check mailmap 	position bit 
usage check 	caller process 
mailmap options mailmap 	whole 
contact name 	words first 
mail namelen maillen 	seeking first 
ident argc 	word ones 
argv prefix mailmap 	zeros respectively 
buf split 	lookig zeros 
ident line strlen 	ones 
die map 	much faster 
user git config 	large contiguous 
parse options 	blocks bits 
die read mailmap 	compared vanilla 
check mailmap 	bit per 
maybe flush die 	bit 
strbuf getline 	processing note 
check mailmap maybe 	start address 
flush die 	aligned consume 
strbuf release 	aligned skip 
clear mailmap check-racy.c 	initial bits 
dirty clean 	aligned 
racy read cache 	skip bits 
lstat error 	full word 
strerror match stat 	step load 
match stat 	bytes word 
check-ref-format.c builtin check 	considering first 
format usage 	significant 
refname ret prev 	basically consider 
arg nongit 	written big 
argc argv prefix 	endian since 
normalize flags 	consider bits 
refname xmallocz strlen 	left right 
setup git 	first 
directory gently strbuf 	bit position 
check branch 	zero note 
die strcmp usage 	loading designed 
strcmp check 	work even 
format branch 	bytes left 
strcmp strcmp strcmp 	count 
strcmp strcmp 	less full 
usage usage collapse 	word pad 
slashes check 	zero right 
refname format git 	special bits 
information manager 	zero looking 
hell copy refname 	one 
leading slashes 	signal single 
removed runs adjacent 	whole happen 
slashes replaced 	looking right 
single slashes function 	zero padded 
similar normalize 	last word 
path copy stripped 	left 
meet check 	scan bit 
format simpler needs 	bit first 
checkout-index.c nul 	thing need 
term line 	single significant 
checkout stage tempfile 	position know 
topath state 	size 
name prefix name 	use simple 
prefix namelen 	trick bits 
pos name checkout 	bits msb 
errs prefix 	bits msb 
prefix length errs 	reached point 
last builtin 	bug 
checkout index usage 	algorithm since 
file opt 	match handled 
arg unset argc 	special avoid 
argv prefix 	warnings bits 
newfd read stdin 	related commands 
prefix length 	getbit 
index opt builtin 	setbit bitcount 
checkout index 	bitop setbit 
options arg buf 	key offset 
unquoted getline 	bitvalue bits 
putchar fputs 	cleared current 
putchar fputs putchar 	values 
write name 	update bit 
quoted relative strlen 	original getbit 
cache name 	key offset 
pos namelen memcmp 	bitop name 
stage stage 	target key 
checkout entry stage 	src 
write tempfile 	key src 
record fputc stage 	key src 
stage namelen 	key src 
memcmp namelen namelen 	key source 
memcmp namelen 	objects source 
write tempfile record 	pointers 
checkout entry 	length src 
stage write tempfile 	max len 
record exit 	min len 
strcmp die strcmp 	among input 
usage options 	keys resulting 
git config 	parse 
strlen read cache 	operation name 
die parse 	sanity check 
options strlen hold 	accepts single 
locked index 	key argument 
die die prefix 	lookup keys 
path checkout 	store 
file free die 	pointers objects 
getline strbuf 	handle non 
reset unquote style 	existing keys 
die strbuf 	empty error 
swap prefix path 	one keys 
checkout file 	compute 
free strbuf release 	bit operation 
strbuf release 	least one 
checkout write locked 	empty fast 
index die 	path far 
check files current 	data input 
cache directory 	bitmaps 
copyright linus 	take fast 
torvalds checkout stage 	path performs 
already done 	much better 
error reporting exit 	vanilla algorithm 
code die 	note sds 
prefix specified want 	pointer 
update cache 	always aligned 
check named files 	boundary different 
first checkout.c 	branches per 
checkout usage patch 	different operations 
mode quiet 	speed sorry 
merge force force 	next 
detach writeout 	process previous 
stage overwrite ignore 	loop store 
ignore skipworktree 	computed target 
ignore worktrees show 	key output 
progress branch 	length bytes 
branch force 	bitcount 
orphan branch branch 	key start 
log diff 	end lookup 
options branch exists 	check type 
prefix pathspec 	non existing 
source old changed 	keys pointer 
sha pathname 	stack 
mode stage context 	allocated integer 
len pos 	encoded parse 
old pathspec pos 	start end 
stage pos 	range convert 
stages pos seen 	negative indexes 
name stage 	whole 
pos state pos 	syntax error 
state path 	precondition end 
ancestor status sha 	end strlen 
result buf 	condition zero 
threeway mode stage 	returned start 
opts revision 	end 
pos state 	bitpos key 
matched rev flag 	bit start 
head errs 	end parse 
file head opts 	bit argument 
rev msg 	understand looking 
commit worktree writeout 	clear 
error opts 	bits key 
desc name path 	exist point 
commit checkout 	view infinite 
branch buf opts 	bits user 
old writeout 	looking fist 
error ret file 	clear 
trees topts 	bit user 
result work branch 	looking first 
opts old 	bit pointer 
msg old desc 	stack allocated 
reflog msg 	integer encoded 
ret refname err 	parse 
refname oid 	start end 
flags data 	range convert 
commit commit revs 	negative indexes 
last lost 	whole syntax 
old revs refs 	error empty 
opts ret 	ranges 
old path free 	start end 
rev flag 	empty range 
writeout error opts 	contain looking 
src dst 	clear bits 
dst sha unique 	user specified 
remote data 	exact 
query name sha 	range start 
data src 	end consider 
argc argv dwim 	right range 
local branch 	zero padded 
opts rev source 	end given 
branch argcount 	redis 
branch rev arg 	bitpos returns 
dash dash 	first bit 
pos dash 	outside range 
dash recover dwim 	caller mean 
remote opts 	specified range 
status branch opts 	single 
sha flag 	bit adjust 
head rev flag 	bytes skipped 
argc argv 	blocked.c timeout 
prefix opts conflict 	unit tval 
style dwim 	btype reply 
local branch options 	reply 
argv rev 	error mstime 
dwim buf run 	list length 
hook sha 	list first 
hex sha hex 	server list 
isdir strlen 	del node 
xcalloc cache entry 	sdslen 
size hashcpy 	process input 
memcpy memcpy 	buffer unblock 
create flags create 	client waiting 
mode cache 	data unblock 
name pos hashcmp 	client waiting 
free cache 	replicas 
entry read recursive 	server panic 
strcmp strcmp 	list node 
stage error error 	tail reply 
strcmp stage 	reply replication 
error strcmp stage 	count acks 
checkout entry 	offset 
error error memset 	server panic 
stage strcmp 	list rewind 
hashcpy create mode 	list next 
sha sha 	list node 
error read mmblob 	reply sds 
read mmblob 	sdsnew 
read mmblob merge 	unblock client 
free free 	blocked support 
free free 	blocking operations 
error write sha 	like blpop 
file die 	wait copyright 
make cache entry 	salvatore 
die checkout 	sanfilippo antirez 
entry die die 	gmail dot 
die die 	rights reserved 
die die die 	redistribution use 
run interactive 	source binary 
xcalloc hold locked 	forms 
index read 	without modification 
cache preload error 	permitted provided 
read xcalloc 	following conditions 
skip worktree path 	met redistributions 
match report 	source code 
path error free 	must 
free unmerge 	retain copyright 
marked index stage 	notice list 
warning check 	conditions following 
stage check 	disclaimer redistributions 
stages error skip 	binary form 
name memset 	must 
stage checkout entry 	reproduce copyright 
checkout stage 	notice list 
checkout merged skip 	conditions following 
name write 	disclaimer documentation 
locked index die 	materials provided 
read full 	distribution 
lookup commit reference 	neither name 
gently post 	redis names 
checkout hook init 	contributors may 
revisions diff 	used endorse 
setup done pending 	promote products 
run diff 	derived 
index parse commit 	software without 
commit easy 	specific prior 
find unique abbrev 	written permission 
strbuf release 	software provided 
memset parse 	copyright holders 
init desc unpack 	contributors 
trees strbuf 	express implied 
branchname strcmp xstrdup 	warranties including 
strbuf splice 	limited implied 
strbuf detach xcalloc 	warranties merchantability 
hold locked 	fitness particular 
index read cache 	purpose 
preload error 	disclaimed shall 
resolve undo clear 	copyright owner 
reset memset 	contributors liable 
setup unpack trees 	direct indirect 
porcelain refresh 	incidental special 
cache unmerged cache 	exemplary 
error cache 	consequential damages 
unborn xcalloc setup 	including limited 
standard excludes 	procurement substitute 
parse indirect init 	goods services 
desc parse 	loss use 
indirect init 	data 
desc unpack trees 	profits business 
files cache 	interruption however 
init merge options 	caused theory 
write memory 	liability whether 
reset merge trees 	contract strict 
reset cache 	liability 
cache fully valid 	tort including 
cache update 	negligence otherwise 
write locked index 	arising way 
die show 	use software 
local changes branch 	even advised 
format tracking 	possibility 
info fputs strbuf 	damage api 
release mkpathdup 	timeout reply 
safe create reflog 	utility function 
free strbuf 	parse timeout 
release strbuf 	argument since 
release create branch 	blocking 
setup branch 	operations usually 
path oid hex 	require timeout 
getenv strbuf 	block client 
addf strbuf insert 	client blocked 
strlen strcmp 	flag client 
update detach advice 	specified 
describe detached 	block type 
head create symref 	btype filed 
die strcmp 	one blocked 
exists reflog exists 	macros unblock 
reflog branch 	client unblocks 
state strbuf release 	client 
strcmp report 	following calls 
tracking pending sha 	btype specific 
strbuf addstr 	function cleanup 
strbuf addstr find 	state unblocks 
unique abbrev 	client unsetting 
strbuf addch 	client 
parse commit commit 	blocked flag 
easy strbuf 	puts client 
addch revision describe 	list unblocked 
one orphan 	clients processed 
describe one orphan 	asap sleep 
strbuf addf 	loop 
strbuf release find 	callback query 
unique abbrev 	buffer process 
init revisions setup 	also required 
revisions pending 	otherwise readable 
oid hex pending 	fired already 
sha prepare 	read 
revision walk die 	pending commands 
suggest reattach 	also client 
describe detached head 	unblocked flag 
clear commit 	remember client 
marks free memset 	unblocked clients 
resolve refdup 	list 
lookup commit 	process unblocked 
reference gently skip 	clients called 
prefix die 	inside sleep 
parse commit die 	function process 
merge working 	query buffer 
free orphaned commit 	unblocked 
warning update 	clients clients 
refs post checkout 	blocked clients 
hook free 	queue reply 
strcmp handle ignore 	blocked client 
submodules arg 	timed called 
starts parse submodule 	cron 
config option 	function client 
git xmerge config 	blocked reaches 
memset remote 	specified timeout 
find tracking sha 	timeout timeout 
free free 	processed usually 
snprintf remote free 	needs 
strcmp die 	send reply 
strcmp sha 	client implementing 
check filename wildcard 	type blocking 
unique tracking 	opeation implementation 
name die setup 	modify unblock 
branch path 	client 
check refname format 	reply blocked 
read hashcpy 	client timed 
lookup commit reference 	order handle 
gently parse 	btype specific 
indirect parse commit 	behavior 
die die 	two functions 
verify non filename 	blocking operation 
die strbuf 	waits certain 
addf create symref 	keys change 
strbuf release 	state cluster 
die die die 	redirect 
die die 	blocked client 
die die 	needed function 
die resolve refdup 	also updated 
strcmp die 	timeout store 
free read full 	timeout timeout 
sha unborn 	always 
branch branches memset 	stored milliseconds 
memset gitmodules 	time timeout 
config git config 	expire however 
parse options 	parsing performed 
isatty git xmerge 	according unit 
config die 	seconds 
strcmp die skip 	milliseconds note 
prefix skip 	timeout zero 
prefix strchr die 	usually point 
parse branchname 	view commands 
arg parse pathspec 	api means 
die die 	timeout 
die die validate 	stored timeout 
branchname strbuf 	zero block 
release checkout 	client specific 
paths checkout branch 	operation type 
checking index 	client blocked 
commit exists entry 	flag 
current index 	client query 
old entry place 	buffer longer 
whether uptodate 	processed accumulated 
checkout entry right 	processed client 
thing update 	unblocked function 
index given info 	called 
args expanding 	sleep function 
wildcards exit non 	loop order 
zero code 	process pending 
skip needswork create 	input buffer 
conflicts merges 	clients unblocked 
merge renormalize needswork 	blocking 
absolutely reason 	operation process 
write blob create 	remaining data 
phony cache 	input buffer 
entry leak 	unless client 
hack primarily write 	blocked actually 
entry machinery 	process 
massages contents work 	input buffer 
format writes 	checks client 
allows cache entry 	blocked proceed 
code write 	things may 
entry needs refactored 	change code 
allow feed 	conceptually 
buffer size mode 	correct way 
instead cache 	unblock client 
entry refactoring would 	calling right 
help merge 	function depending 
recursive well also 	kind operation 
writes merge 	client 
result database even 	blocking clear 
may contain 	flags put 
conflicts make sure 	client unblocked 
pathspecs participated 	list process 
locating paths 	commands query 
git checkout ish 	buffer 
path entry 	asap client 
original index working 	may already 
matter pathspec 	unblocked list 
matched entry anything 	previous blocking 
entry either 	operation back 
entry came ish 	list 
checking paths 	multiple times 
checking index comes 	function gets 
ish already 	called blocked 
know matches pathspec 	client timed 
could stamp 	order send 
matched update still 	reply 
need matched 	kind mass 
read recursive eventually 	unblock clients 
entry interesting 	something changed 
cannot fill 	instance makes 
matched yet avoid 	blocking longer 
calling match 	safe 
pathspec entries opts 	example clients 
source checkout 	blocked list 
path recreate conflicted 	operations instance 
state unmerged 	turns master 
paths committed check 	slave function 
think want 	called 
full paths even 	master turns 
subdirectory nevertheless 	slave semantics 
index right importantly 	send unblocked 
made best 	error client 
efforts update paths 	disconnecting time 
work cannot 	btalloc.c 
revert name used 	size bits 
full name 	btalloc btalloc.h 
real branch named 	size bits 
commit branch 	btalloc provides 
detached already 	mechanism allocating 
checkout way merge 	via 
branch unpack 	permuted backtraces 
couldn trivial merge 	intentionally sabotage 
either give 	tail call 
real merge depending 	optimization btalloc 
whether merge 	btalloc chunk.c 
flag used without 	opt 
old commit 	dss opt 
two unpack already 	chunk curchunks 
tried failed 	highchunks chunks 
real merge update 	rtree chunksize 
index fully 	chunksize mask 
write index merge 	chunk 
branch current 	npages addr 
old branch reset 	size alignment 
index working 	zero commit 
branch leaving working 	arena ind 
merged version 	chunk size 
skipping unmerged 	committed 
entries index needswork 	arena ind 
carrying local 	chunk size 
changes branches different 	offset length 
end line 	arena ind 
normalization clean smudge 	chunk size 
rules pain 	offset 
plumb option renormalize 	length arena 
nothing longer 	ind chunk 
branch branches singular 	size offset 
version plural 	length arena 
version give ngettext 	ind chunk 
count singular 	size 
version plural version 	size size 
give ngettext 	committed arena 
count commit tip 	ind chunk 
detached head 	size chunk 
reachable last chance 	size committed 
user without 	arena 
resorting reflog 	ind chunk 
git checkout paths 	hooks arena 
must valid 	chunk hooks 
everything must path 	chunks szad 
git checkout 	chunks cache 
paths everything must 	chunk 
paths git 	size zeroed 
checkout something something 	committed arena 
commit branch 	arena chunk 
detach head special 	hooks arena 
something missing 	chunk hooks 
means head omit 	old 
one side 	chunk hooks 
unique merge names 	arena chunk 
merge something 	hooks locked 
commit either present 	uninitialized hooks 
something path 	arena chunk 
given tracking branch 	hooks 
whose name 	arena chunk 
something one 	hooks chunk 
one remote hand 	node size 
fork local 	nadd cur 
something remote tracking 	high chunk 
branch otherwise 	node 
present treat like 	err size 
otherwise reference 	nsub arena 
treat like path 	chunks szad 
treat like 	chunks size 
fail git checkout 	key arena 
something paths 	chunk 
first argument must 	hooks chunks 
ambiguous reference 	szad chunks 
treat like path 	cache addr 
treat like 	size alignment 
fail either something 	zero commit 
commit attempt 	dalloc 
use invalid 	node ret 
likely error need 	node alloc 
find create 	size leadsize 
branch accept git 	trailsize zeroed 
checkout foo 	committed key 
git checkout foo 	arena 
candidates dwim 	addr size 
dwi mmed create 	alignment zero 
local branch 	commit dss 
end anymore eat 	prec ret 
argument existing 	chunk hooks 
branch commit want 	size 
complain common 	ret zero 
git checkout branch 	commit arena 
even happen 	chunk hooks 
file called branch 	addr size 
would extremely 	alignment zero 
annoying implied branch 	dalloc 
contain branch 	node ret 
branch force 	commit arena 
orphan branch tell 	ind arena 
one orphan 	addr size 
used track without 	alignment zero 
orphan dwim 	commit 
extract branch name 	arena ind 
command line 	ret arena 
arguments left pathspecs 	arena chunk 
handle git 	hooks addr 
checkout paths git 	size alignment 
checkout paths 	zero 
git checkout something 	commit ret 
paths including 	arena chunk 
last branch syntax 	hooks chunks 
dwim ery 	szad chunks 
names remote branches 	cache chunk 
erroring invalid 	size 
ambiguous cases give 	zeroed committed 
helpful suggestion 	unzeroed node 
branch argc 	prev key 
caught later clean.c 	arena chunk 
force interactive 	hooks chunk 
del list colopts 	size 
builtin clean 	committed arena 
usage msg msg 	chunk hooks 
would msg 	chunk size 
skip git dir 	zeroed committed 
msg would 	chunk size 
skip git dir 	committed 
msg warn 	arena ind 
failed clean use 	arena chunk 
color clean 	hooks chunk 
colors header prompt 	size committed 
flags hotkey 	chunk size 
title selected stuff 	offset 
slot name 	length arena 
slot clean color 	ind chunk 
clean print 	size offset 
color opt 	length arena 
arg unset exclude 	ind arena 
list path 	chunk 
prefix force flag 	offset length 
dry run 	chunk size 
quiet dir gone 	offset length 
dir quoted 	arena ind 
len dels list 	arena chunk 
item buf 	hooks 
qname copts menu 	chunk size 
list local 	offset length 
colopts copts singleton 	chunk size 
stuff chosen 	size size 
menu list menu 	committed arena 
menu item 	ind 
list item highlighted 	chunk size 
choice menu 	chunk size 
stuff menu 	committed arena 
item list item 	ind nelms 
len found 	info malloc 
menu stuff single 	mutex 
input chosen 	chunk hooks 
choice list ptr 	locked malloc 
choose top 	mutex unlock 
range number opts 	malloc mutex 
stuff choice 	atomic copy 
chosen result eof 	hook 
dir confirm 	atomic copy 
ignore list item 	hook atomic 
dtype menu 	copy hook 
opts menu stuff 	atomic copy 
items chosen 	hook atomic 
confirm buf item 	copy 
qname eof 	hook atomic 
menu opts menu 	copy hook 
stuff menus 	atomic copy 
chosen ret 	hook malloc 
argc argv prefix 	mutex unlock 
res ignored 	memcmp 
gone flags abs 	chunk hooks 
path dir 	locked chunk 
pathspec buf exclude 	hooks chunk 
list item 	hooks assure 
qname options ent 	initialized impl 
matches rel 	chunk 
strcasecmp strcasecmp strcasecmp 	hooks assure 
strcasecmp strcasecmp 	initialized impl 
strcasecmp starts git 	extent node 
column config 	addr rtree 
strcmp git config 	extent node 
colorbool skip 	size 
prefix parse clean 	atomic atomic 
color slot 	read atomic 
config error nonbool 	cas atomic 
color parse 	read prof 
strcmp git 	gdump unlocked 
config git color 	prof 
config list 	gdump rtree 
append nonbare repository 	extent node 
dir quote 	size atomic 
path relative opendir 	read atomic 
rmdir quote 	sub chunk 
path relative warning 	ceiling 
strbuf complete 	extent node 
readdir dot dotdot 	init extent 
strbuf setlen 	szad nsearch 
strbuf addstr lstat 	chunk ceiling 
isdir dirs 	malloc mutex 
quote path relative 	chunk 
list append 	hooks assure 
unlink quote path 	initialized locked 
relative list 	extent node 
append quote path 	init extent 
relative warning 	search chunk 
closedir strbuf 	first 
setlen rmdir quote 	best fit 
path relative 	extent node 
warning list clear 	size malloc 
quote path 	mutex unlock 
relative list append 	alignment ceiling 
memset print 	extent 
columns strbuf release 	node addr 
list clear 	extent node 
memset print columns 	addr extent 
clean print 	node size 
color clean print 	extent node 
color die 	size 
strbuf addf strbuf 	extent node 
addstr clean 	addr extent 
color strbuf addch 	node zeroed 
strbuf addstr 	extent node 
clean color 	committed split 
strbuf addch list 	extent 
append strbuf 	node addr 
reset strbuf addf 	extent node 
list append 	size malloc 
strbuf reset pretty 	mutex unlock 
print menus 	extent szad 
strbuf release list 	extent 
clear strlen 	arena chunk 
die strncasecmp strncasecmp 	cache maybe 
strbuf split 	extent node 
max strbuf split 	size extent 
max strbuf 	szad insert 
trim strbuf isdigit 	extent 
atoi atoi 	insert arena 
strchr atoi strchr 	chunk cache 
strcmp find 	maybe insert 
unique clean print 	split arena 
color clean 	node dalloc 
print color 	malloc 
strbuf list free 	mutex unlock 
alloc clean 	chunk record 
color clean color 	arena node 
print highlight 	alloc malloc 
menu stuff clean 	mutex unlock 
color clean 	chunk 
color strbuf getline 	record extent 
strbuf trim 	node init 
strcmp prompt help 	uintptr extent 
cmd parse 	szad insert 
choice xmalloc xcalloc 	extent insert 
free strbuf 	arena 
release pretty print 	chunk cache 
dels clean 	maybe insert 
print color clean 	commit malloc 
print color 	mutex unlock 
strbuf getline strbuf 	chunk record 
trim putchar 	malloc 
memset exclude 	mutex unlock 
list strbuf split 	arena node 
max strbuf 	dalloc memset 
trim exclude excluded 	jemalloc valgrind 
list empty 	make mem 
items clean print 	defined 
color clean 	chunk recycle 
print color strbuf 	chunk alloc 
list free 	dss chunk 
clear directory strbuf 	alloc mmap 
release list 	chunk alloc 
choose list empty 	dss 
items free 	chunk alloc 
quote path relative 	mmap jemalloc 
strbuf getline 	valgrind make 
strbuf trim putchar 	mem undefined 
strncasecmp list 	chunk recycle 
empty items strbuf 	jemalloc 
release strbuf 	valgrind make 
release list 	mem undefined 
clear clean print 	arena tsd 
color clean 	fetch chunk 
print color clean 	arena chunk 
print color 	alloc 
clean print color 	core jemalloc 
pretty print 	valgrind make 
dels list choose 	mem undefined 
free clean 	chunk hooks 
print color clean 	assure initialized 
print color 	alloc 
quit cmd free 	jemalloc valgrind 
git config 	make mem 
parse options memset 	undefined jemalloc 
die die 	valgrind make 
die read cache 	mem noaccess 
die setup 	malloc 
standard excludes exclude 	mutex chunk 
list exclude 	hooks assure 
parse pathspec 	initialized locked 
fill directory cache 	extent node 
name dir 	init extent 
path match lstat 	nsearch 
die errno 	extent node 
isdir relative path 	addr extent 
list append 	node addr 
interactive main loop 	extent node 
strbuf addstr 	committed merge 
strbuf addstr lstat 	extent 
isdir dirs 	node addr 
quote path relative 	extent node 
unlink quote 	size extent 
path relative warning 	szad arena 
quote path 	chunk cache 
relative strbuf reset 	maybe 
strbuf release 	extent node 
strbuf release 	addr extent 
list clear list 	node size 
clear git 	extent node 
clean builtin command 	size extent 
copyright shawn 	node 
bohrer git clean 	zeroed extent 
pavel roskin 	node zeroed 
unset plain prompt 	extent szad 
header help 	insert arena 
error honors color 	chunk cache 
interactive config 	maybe 
variables also applied 	insert arena 
git interactive 	node alloc 
git stash inspect 	chunk purge 
color config 	wrapper extent 
variable others empty 	node init 
dir could 	extent 
removed even unreadble 	insert extent 
fall thru 	szad insert 
path stat 	arena chunk 
fails non directory 	cache maybe 
still exists 	insert 
always enable column 	extent prev 
display consult 	extent node 
column layout strategy 	addr extent 
stuff display 	node size 
menu stuff number 	extent node 
prefix hotkey 	committed 
highlight hotkey matching 	merge extent 
parse user 	node addr 
input choice menu 	extent node 
menu stuff 	size extent 
input single choice 	szad extent 
numbered item 	arena 
foo item menu 	chunk cache 
title empty 	maybe extent 
nothing multiple choice 	szad arena 
single item 	chunk cache 
range items 	maybe extent 
multiple ranges foo 	node 
item menu 	addr extent 
title unselect specified 	node addr 
items choose 	extent node 
items empty finish 	size extent 
selecting parse 	node size 
result saved chosen 	extent 
number total 	node size 
selections input begins 	extent node 
unchoose range 	zeroed extent 
specified like implement 	node zeroed 
git interactive 	extent node 
compatible borrowed git 	zeroed 
interactive perl 	extent szad 
integers free allocated 	insert arena 
memory ends 	chunk cache 
eof user pressed 	maybe insert 
ctrl eof 	arena node 
selection returned 	dalloc 
chosen uninitialized chosen 	malloc mutex 
initialized print 	unlock chunk 
highlight menu stuff 	addr chunk 
help prompt 	record arena 
multiple choice menu 	maybe purge 
press enter 	chunk 
empty back recalculate 	addr chunk 
back menu 	hooks assure 
directly selections quit 	initialized dalloc 
filter pattern 	decommit purge 
mode press enter 	chunk record 
ctrl selected 	chunk 
item end chosen 	dss chunk 
chosen eof 	dalloc mmap 
won ctrl stop 	chunk hooks 
removing files 	assure initialized 
translators make 	dalloc jemalloc 
sure keep might 	valgrind 
removed part 	make mem 
earlier recursive directory 	noaccess pages 
removal lstat 	commit pages 
could fail enoent 	decommit chunk 
clone.c builtin 	addr pages 
clone usage option 	purge 
checkout option 	chunk purge 
bare option mirror 	arena chunk 
option single 	arena chunk 
branch option hardlinks 	hooks assure 
option shared 	initialized purge 
option recursive option 	chunk 
option depth 	dss chunk 
option origin option 	dss alloc 
branch real 	system info 
git dir option 	jemalloc ffs 
upload pack 	chunk dss 
option verbosity 	boot 
option progress option 	rtree chunk 
config option 	dss prefork 
reference option dissociate 	chunk dss 
builtin clone 	postfork parent 
options argv submodule 	chunk dss 
path bundle 	postfork 
suffix bundle suffix 	child data 
baselen signature 	used exclusively 
dst len repo 	gdump triggering 
bundle path 	various chunk 
raw canon repo 	related settings 
bundle bare 	chunksize 
start ptr len 	function prototypes 
dir prev 	functions referenced 
space dir end 	prior definition 
item data 	copy field 
git repo alternate 	atomically impossible 
git git 	readers 
src dst 	see partially 
src repo line 	updated pointers 
abs path 	places readers 
src dest src 	need one 
repo src 	hook function 
baselen buf src 	pointer 
len dest 	therefore need 
len dir src 	copy entirety 
repo dest 	arena chunk 
repo alt src 	hooks stale 
dest junk 	reads affect 
work junk git 	correctness 
dir junk 	perform unlocked 
repo msg signo 	reads refresh 
refs branch 	cur may 
head refs refspec 	decreased since 
head local 	lost highchunks 
refs tail remote 	update 
head local 	race first 
refs err 	best fit 
refs msg data 	chunk selection 
sha refs 	lowest chunk 
mapped refs remote 	best fits 
head points 	cached 
branch top msg 	chunks use 
transport check 	node linkage 
connectivity head remote 	embedded headers 
msg head 	dalloc node 
sha head file 	addr non 
opts err 	operating 
key data config 	specific chunk 
src prefix 	beware size 
head points remote 	wrap around 
head points 	split lead 
branch top key 	node insert 
head argv 	leading 
alternates argc 	space smaller 
argv prefix local 	chunk split 
buf repo 	trail insert 
name repo work 	trailing space 
git dir 	smaller chunk 
path dir dest 	caller 
exists refs 	specifies zero 
remote head remote 	still possible 
head points 	receive zeroed 
head points mapped 	memory zero 
refs reflog 	toggled arena 
msg transport src 	chunk 
prefix remote 	alloc takes 
complete refs fetch 	advantage avoid 
refspec fetch 	demanding zeroed 
pattern size strbuf 	chunks taking 
setlen strbuf 	advantage returned 
addstr stat isdir 	retained 
git directory 	primary dss 
isreg open 	mmap requesting 
read full close 	address implemented 
strncmp read 	chunk alloc 
gitfile size strbuf 	mmap call 
setlen strbuf 	addr 
addstr stat isreg 	secondary dss 
strbuf addstr 	strategies allocation 
repo path xstrdup 	failed directly 
absolute path 	call chunk 
strbuf release strlen 	alloc mmap 
strstr dir 	rather 
sep dir sep 	chunk alloc 
isspace dir 	core critical 
sep strncmp dir 	chunk alloc 
sep memchr 	untouched demand 
memchr isdigit dir 	zeroed memory 
sep strip 	dodge 
suffix mem die 	tsd order 
xstrfmt xstrndup 	avoid bootstrapping 
isspace strlen 	issues arena 
dir sep xstrdup 	allocating behalf 
real path 	must initialized 
read gitfile read 	already 
gitfile mkpath 	coalesce forward 
free xstrdup directory 	coalesce chunk 
mkpath mkpathdup 	following address 
free directory mkpath 	range change 
common dir 	position within 
die die access 	chunks 
mkpath die 	insert chunks 
access mkpath die 	szad coalescing 
strbuf addf 	forward failed 
alternates file strbuf 	insert node 
release free 	node allocation 
list fopen strbuf 	failed 
getline absolute 	exceedingly unlikely 
path alternates file 	failure leak 
mkpathdup normalize 	chunk making 
path copy 	sure pages 
alternates file free 	already purged 
strbuf release 	memory 
fclose opendir die 	leak coalesce 
errno mkdir 	backward coalesce 
die errno stat 	chunk previous 
die errno 	address range 
isdir die strbuf 	change position 
addch strbuf 	within 
addch readdir strbuf 	chunks insert 
setlen strbuf 	node chunks 
addstr strbuf setlen 	szad deallocate 
strbuf addstr 	decommit purge 
stat warning isdir 	fails verify 
copy link 	actual 
directory strcmp copy 	page size 
alternates unlink 	equal integral 
die errno link 	multiple configured 
die errno 	page size 
copy file 	configure chunksize 
time die errno 	match 
closedir strbuf 	granularity usually 
addf alternates file 	pages map 
strbuf release 	always take 
common dir common 	fast path 
dir strbuf 	variables according 
addstr strbuf addstr 	opt 
copy link 	chunk install 
directory strbuf release 	custom chunk 
strbuf release 	hooks large 
warning strbuf addstr 	size classes 
dir recursively 	huge size 
strbuf reset strbuf 	classes 
addstr dir 	test dalloc 
recursively strbuf reset 	decommit purge 
junk sigchain 	cascade test 
pop strbuf 	decommit commit 
addstr strbuf addstr 	observe split 
find name 	merge 
strbuf release strbuf 	test purge 
addstr strbuf 	chunk huge 
addstr find name 	allocations least 
strbuf release 	four size 
copy find name 	classes per 
guess remote 	doubling 
head copy find 	successful xallocx 
remote branch 	size huge 
warning fetch map 	size huge 
fetch map 	guaranteed trailing 
fetch map fetch 	purgeable memory 
map transaction 	test 
begin die transaction 	decommit large 
create die 	allocations make 
initial transaction commit 	sure non 
die strbuf 	huge allocation 
release transaction 	succeeds restore 
free starts ends 	chunk 
file update 	hooks malloc 
hashcpy check everything 	conf orig 
connected transport 	hooks old 
die write remote 	hooks dalloc 
refs write 	decommit alloc 
followtags strbuf addstr 	dalloc 
strbuf addstr 	commit decommit 
create symref die 	purge split 
strbuf release 	merge addr 
skip prefix create 	size alignment 
symref die 	zero commit 
update install branch 	arena 
config lookup 	ind chunk 
commit reference update 	size committed 
update resolve 	arena ind 
refdup warning strcmp 	chunk size 
detach advice 	offset length 
sha hex 	arena 
starts die free 	ind err 
setup work 	chunk size 
xcalloc hold locked 	offset length 
index memset 	arena ind 
parse indirect parse 	err chunk 
init desc 	size 
unpack trees die 	offset length 
write locked 	arena ind 
index die run 	chunk size 
hook sha 	size size 
hex sha hex 	committed arena 
run command 	ind 
opt git config 	chunk size 
multivar gently 	chunk size 
git config parse 	committed arena 
parameter die 	ind old 
starts strbuf addf 	size size 
strbuf addf 	large 
skip prefix 	large huge 
die strbuf addf 	huge huge 
strbuf addf 	hooks xallocx 
strbuf addf git 	success xallocx 
config multivar 	success xallocx 
strbuf reset strbuf 	success 
addf git 	trace hook 
config strbuf reset 	alloc trace 
strbuf release 	hook dalloc 
strbuf release git 	trace hook 
pathdup access 	commit trace 
run command opt 	hook 
die unlink 	decommit trace 
die errno free 	hook purge 
packet trace 	trace hook 
identity parse options 	split trace 
usage msg 	hook merge 
opt usage 	mallctl 
msg opt die 	ptr ptr 
die repo 	ptr ptr 
path xstrdup absolute 	ptr ptr 
path strchr 	ptr mallctl 
die atoi die 	mallctl mallctl 
xstrdup guess 	mallctl 
dir name strip 	mallctl mallocx 
trailing slashes 	ptr xallocx 
stat empty dir 	mallctl dallocx 
die strbuf 	mallocx ptr 
addf getenv stat 	xallocx mallctl 
die xstrdup 	xallocx 
mkpathdup atexit sigchain 	dallocx mallocx 
push common 	ptr xallocx 
safe create leading 	dallocx mallocx 
directories die 	ptr mallctl 
errno mkdir die 	xallocx mallctl 
errno git 	xallocx 
work safe 	dallocx mallocx 
create leading directories 	ptr dallocx 
die git 	mallctl mallctl 
dir init init 	ptr ptr 
write config 	ptr ptr 
git config strbuf 	ptr 
addstr git 	ptr ptr 
config strbuf addf 	test data 
strbuf addf 	used exclusively 
strbuf addf git 	gdump triggering 
config strbuf 	various chunk 
reset setup reference 	related 
parse fetch 	settings chunksize 
refspec strbuf reset 	function prototypes 
remote transport 	functions referenced 
transport verbosity repo 	prior definition 
path warning 	copy field 
access mkpath warning 	atomically 
warning die 	impossible readers 
transport option 	see partially 
transport option transport 	updated pointers 
option transport 	places readers 
option transport remote 	need one 
refs wanted 	hook 
peer refs oid 	function pointer 
transport fetch 	therefore need 
refs find name 	copy entirety 
guess remote 	arena chunk 
head find remote 	hooks stale 
branch die 	reads 
die warning install 	affect correctness 
branch config 	perform unlocked 
write refspec config 	reads refresh 
clone local 	cur may 
transport fetch refs 	decreased since 
update remote 	lost 
refs update head 	highchunks update 
transport unlock 	race first 
pack transport 	best fit 
disconnect close packs 	chunk selection 
dissociate references 	lowest chunk 
checkout strbuf release 	best 
strbuf release 	fits cached 
strbuf release strbuf 	chunks use 
release free 	node linkage 
builtin git clone 	embedded headers 
copyright kristian 	dalloc node 
gsberg krh redhat 	addr 
daniel barkalow 	non operating 
barkalow iabervon git 	specific chunk 
commit junio 	beware size 
hamano linus torvalds 	wrap around 
clone repository 	split lead 
different directory yet 	node 
exist overall 	insert leading 
fixm respect 	space smaller 
environment git objects 	chunk split 
implementation notes 	trail insert 
dropping use separate 	trailing space 
remote separate 	smaller 
remote compatibility gitfile 	chunk caller 
skip scheme 	specifies zero 
skip authentication data 	still possible 
stripping happen 	receive zeroed 
greedily strip last 	memory zero 
inside host 	toggled 
part strip trailing 	arena chunk 
spaces slashes 	alloc takes 
git strip trailing 	advantage avoid 
port number 	demanding zeroed 
got hostname dir 	chunks taking 
separator colon 	advantage 
check required strip 	returned retained 
uri like 	primary dss 
foo bar 	mmap requesting 
git result dir 	address implemented 
guessed due 	chunk alloc 
backwards compatibility find 	mmap 
last component 	call addr 
remain backwards compatible 	secondary dss 
also regard 	strategies allocation 
colons path separators 	failed directly 
cloning repository 	call chunk 
foo bar git 	alloc 
would result 	mmap rather 
directory bar guessed 	chunk alloc 
strip bundle 	core critical 
git replace sequences 	chunk alloc 
control characters 	untouched demand 
whitespace one ascii 	zeroed 
space leading 	memory dodge 
trailing spaces strip 	tsd order 
leading whitespace 	avoid bootstrapping 
beware read 	issues arena 
gitfile real path 	allocating behalf 
mkpath buffer 	must 
read source objects 	initialized already 
info alternates 	coalesce forward 
file copy entries 	coalesce chunk 
corresponding file 	following address 
destination repository alternates 	range change 
file src 	position 
dst path objects 	within chunks 
info alternates 	insert chunks 
instead copying bit 	szad coalescing 
bit original 	forward failed 
need append existing 	insert node 
one already 	node 
created entry via 	allocation failed 
clone lost 	exceedingly unlikely 
also turn entries 	failure leak 
paths relative 	chunk making 
original absolute 	sure pages 
used repository files 	already 
cannot copied 	purged memory 
bit bit fall 	leak coalesce 
proceed removal 	backward coalesce 
branch tag pull 	chunk previous 
requested tag 	address range 
explicitly skip anything 	change 
missing peer 	position within 
actually going write 	chunks insert 
returning notes 	node chunks 
end list caller 	szad deallocate 
local branch 	decommit 
link branch specifies 	purge fails 
non branch 	verify actual 
tags detach head 	page size 
know remote 	equal integral 
head points non 	multiple configured 
branch head 	page 
points branch 	size configure 
know one detach 	chunksize match 
head cases 	granularity usually 
need work checkout 	pages map 
otherwise next 	always take 
git fetch simply 	fast 
fetch head 	path variables 
without updating remote 	according opt 
tracking branch 	chunk install 
want configure remote 	custom chunk 
need strict 	hooks large 
transport option validate 	size 
transport remote 	classes huge 
refs may refs 	size classes 
sha mapped 	test dalloc 
refs see transport 	decommit purge 
refs list 	cascade test 
comment need 	decommit 
fetch early remote 	commit observe 
head code 	split merge 
relies normal clones 	test purge 
transport remote 	chunk huge 
refs reliable delay 	allocations least 
cloning remote 	four 
head check color.c 	size classes 
git use 	per doubling 
color color stdout 	successful xallocx 
tty column 	size huge 
colors ansi column 	size huge 
colors ansi 	guaranteed 
max red green 	trailing purgeable 
blue word 	memory test 
len match val 	decommit large 
name len 	allocations make 
color names end 	sure non 
val name 	huge 
len attr 	allocation succeeds 
values attr names 	restore chunk 
str dst 	hooks chunk.c 
dst color bytes 	opt dss 
len type 	opt chunk 
len dst ptr 	curchunks 
len end 	highchunks chunks 
attr word val 	rtree chunksize 
wordlen sep 	chunksize mask 
bit term want 	chunk npages 
color color 	addr size 
fmt args trail 	alignment 
color fmt 	zero commit 
args color fmt 	arena ind 
args size 	chunk size 
strncasecmp hexval hexval 	committed arena 
match word 	ind chunk 
hex color hex 	size 
color hex 	offset length 
color size 	arena ind 
match word strtol 	chunk size 
size strncasecmp 	offset length 
color parse mem 	arena ind 
strlen xsnprintf 	chunk 
die xsnprintf xsnprintf 	size offset 
strncasecmp xsnprintf 	length arena 
isspace isspace parse 	ind chunk 
color parse 	size size 
attr color empty 	size committed 
color empty 	arena 
xsnprintf color empty 	ind chunk 
color output 	size chunk 
color empty color 	size committed 
output error 	arena ind 
strcasecmp strcasecmp strcasecmp 	chunk hooks 
git config 	arena 
isatty pager use 	chunk hooks 
getenv strcmp 	chunks szad 
check color 	chunks cache 
strcmp git config 	chunk size 
colorbool git 	zeroed committed 
color config git 	arena 
config vfprintf 	arena chunk 
start color vfprintf 	hooks arena 
end start 	chunk hooks 
color vfprintf end 	old chunk 
strcmp list 	hooks arena 
available column colors 	chunk 
ignore reset 	hooks locked 
end giving size 	uninitialized hooks 
individual foreground 	arena chunk 
background color basic 	hooks arena 
ansi colors 	chunk hooks 
numeric ansi color 	chunk 
modes bit 	node size 
rgb color 	nadd cur 
values word buffer 	high chunk 
length len 	node err 
match nul terminated 	size nsub 
match exactly 	arena 
positions must match 	chunks szad 
ansi color 	chunks size 
codes first special 	key arena 
word normal 	chunk hooks 
bit rgb pick 	chunks szad 
human readable 	chunks 
color names color 	cache addr 
mode number 	size alignment 
allow normal negative 	zero commit 
numbers bogus 	dalloc node 
fall error rewrite 	ret node 
low numbers 	alloc 
portable standard colors 	size leadsize 
write ansi 	trailsize zeroed 
color codes 	committed key 
already ansi escape 	arena addr 
code enough 	size alignment 
space fit color 	zero 
attr foreground 	commit dss 
colors range background 	prec ret 
colors range 	chunk hooks 
missing turn colorization 	size ret 
normal truth 	zero commit 
defaults color.h column 	arena 
colors ansi 	chunk hooks 
column colors ansi 	addr size 
max color 	alignment zero 
stdout tty dst 	dalloc node 
color bytes 	ret commit 
dst len dst 	arena 
color fmt 	ind arena 
color fmt color 	addr size 
color num 	alignment zero 
attrs nul 	commit arena 
xxm maximum length 	ind ret 
ansi color 	arena 
sequence would generate 	arena chunk 
leading esc 	hooks addr 
attr color color 	size alignment 
terminating nul 	zero commit 
overcounts attr use 	ret arena 
one semicolon 	chunk 
close enough important 	hooks chunks 
due way 	szad chunks 
color codes emulated 	cache chunk 
windows write 	size zeroed 
fputs particular use 	committed unzeroed 
puts write 	node 
special meaning color 	prev key 
selected first 	arena chunk 
three chosen match 	hooks chunk 
common usage 	size committed 
code returned 	arena chunk 
git config colorbool 	hooks 
returned config 	chunk size 
colorbool converted want 	zeroed committed 
color either 	chunk size 
list colors use 	committed arena 
commit graphs 	ind arena 
show branch output 	chunk 
generally color 	hooks chunk 
code lazily figure 	size committed 
provides mechanism 	chunk size 
callers autodetection use 	offset length 
first one 	arena ind 
need color config 	chunk 
second convenience 	size offset 
going change git 	length arena 
config color 	ind arena 
buffer must 	chunk offset 
color maxlen bytes 	length chunk 
raw color 	size 
bytes useful initializing 	offset length 
color variables 	arena ind 
color column.c list 	arena chunk 
colopts opts 	hooks chunk 
rows cols len 	size offset 
width colopts 	length 
len str len 	chunk size 
data width 	size size 
data data total 	committed arena 
width cols 	ind chunk 
rows list indent 	size chunk 
data initial 	size 
width empty cell 	committed arena 
len newline 	ind nelms 
list colopts opts 	info malloc 
data initial 	mutex chunk 
width empty 	hooks locked 
cell list colopts 	malloc 
opts nopts 	mutex unlock 
colopts stdout tty 	malloc mutex 
name mask 	atomic copy 
arg len colopts 	hook atomic 
opts name 	copy hook 
len arg str 	atomic 
colopts sep 	copy hook 
len key colopts 	atomic copy 
command colopts 	hook atomic 
opt arg unset 	copy hook 
colopts column 	atomic copy 
process colopts opts 	hook 
argv strbuf 	atomic copy 
addstr strstr strspn 	hook malloc 
strbuf utf 	mutex unlock 
strwidth strbuf release 	memcmp chunk 
strlen div 	hooks locked 
round linear 	chunk 
linear realloc div 	hooks chunk 
round realloc 	hooks assure 
compute column width 	initialized impl 
strlen compute 	chunk hooks 
column width linear 	assure initialized 
col layout 	impl 
memset alloc item 	extent node 
length layout 	addr rtree 
shrink columns xmallocz 	extent node 
memset display 	size atomic 
cell free free 	atomic read 
free memset 	atomic 
term columns column 	cas atomic 
active display 	read prof 
plain col layout 	gdump unlocked 
display plain 	prof gdump 
display table die 	rtree extent 
col layout 	node 
isatty size 	size atomic 
strncmp strlen strncmp 	read atomic 
error strcspn 	sub chunk 
parse option strspn 	ceiling extent 
config error 	node init 
nonbool parse config 	extent 
error skip 	szad nsearch 
prefix strcmp column 	chunk ceiling 
config strcmp 	malloc mutex 
column config parse 	chunk hooks 
config child 	assure initialized 
process init argv 	locked 
push argv 	extent node 
pushf argv pushf 	init extent 
argv pushf 	search chunk 
argv pushf fflush 	first best 
dup start 	fit extent 
command dup close 	node 
dup close 	size malloc 
fflush close 	mutex unlock 
finish command dup 	alignment ceiling 
close cell 	extent node 
length index longest 	addr extent 
row column 	node 
length letters ansi 	addr extent 
escapes stripped 	node size 
len func calculate 	extent node 
cell width 	size extent 
rows cols table 	node addr 
equal cells 	extent 
given table width 	node zeroed 
many spaces 	extent node 
cells shrink columns 	committed split 
shortening one 	extent node 
row time adding 	addr extent 
columns along 	node 
way hopefully 	size malloc 
longest cell moved 	mutex unlock 
next column 	extent szad 
column shrunk space 	extent arena 
columns process 	chunk cache 
ends whole thing 	maybe 
longer fits 	extent node 
data total width 	size extent 
display without 	szad insert 
layout enabled print 	extent insert 
cell stdout 	arena chunk 
necessary leading traling 	cache 
space empty 	maybe insert 
cell initial width 	split arena 
chars real 	node dalloc 
column narrower increase 	malloc mutex 
len bit 	unlock chunk 
fill less space 	record 
display col 	arena node 
column col 	alloc malloc 
row none always 	mutex unlock 
never specified 	chunk record 
setting layout implies 	extent node 
always current 	init 
col enable mask 	uintptr extent 
disregarded means 	szad insert 
column pass column 	extent insert 
row become 	arena chunk 
always column never 	cache maybe 
column always 	insert 
unless arg states 	commit malloc 
otherwise one 	mutex unlock 
special must first 	chunk record 
one builtin 	malloc mutex 
column usage colopts 	unlock arena 
argc argv 	node 
prefix list copts 	dalloc memset 
real command 	jemalloc valgrind 
options git 	make mem 
column config starts 	defined chunk 
git config 	recycle chunk 
git config memset 	alloc 
term columns 	dss chunk 
parse options usage 	alloc mmap 
options strcmp 	chunk alloc 
die finalize colopts 	dss chunk 
strbuf getline 	alloc mmap 
list append print 	jemalloc 
columns cell 	valgrind make 
length index longest 	mem undefined 
row column 	chunk recycle 
length letters ansi 	jemalloc valgrind 
escapes stripped 	make mem 
len func calculate 	undefined 
cell width 	arena tsd 
rows cols table 	fetch chunk 
equal cells 	arena chunk 
given table 	alloc core 
width many spaces 	jemalloc valgrind 
cells shrink 	make 
columns shortening one 	mem undefined 
row time 	chunk hooks 
adding columns along 	assure initialized 
way hopefully 	alloc jemalloc 
longest cell moved 	valgrind make 
next column 	mem 
column shrunk space 	undefined jemalloc 
columns process 	valgrind make 
ends whole thing 	mem noaccess 
longer fits 	malloc mutex 
data total width 	chunk hooks 
display without 	assure 
layout enabled print 	initialized locked 
cell stdout 	extent node 
necessary leading 	init extent 
traling space empty 	nsearch extent 
cell initial 	node addr 
width chars real 	extent 
column narrower 	node addr 
increase len bit 	extent node 
fill less 	committed merge 
space display col 	extent node 
column col 	addr extent 
row none always 	node 
never specified 	size extent 
setting layout implies 	szad arena 
always current 	chunk cache 
col enable mask 	maybe extent 
disregarded means 	node addr 
column pass column 	extent 
row become 	node size 
always column never 	extent node 
column always 	size extent 
unless arg 	node zeroed 
states otherwise one 	extent node 
special must 	zeroed 
first one column.c 	extent szad 
list colopts 	insert arena 
opts rows cols 	chunk cache 
len width 	maybe insert 
colopts len str 	arena node 
len data 	alloc 
width data data 	chunk purge 
total width 	wrapper extent 
cols rows list 	node init 
indent data 	extent insert 
initial width empty 	extent szad 
cell len 	insert 
newline list colopts 	arena chunk 
opts data 	cache maybe 
initial width empty 	insert extent 
cell list 	prev extent 
colopts opts 	node addr 
nopts colopts stdout 	extent 
tty name 	node size 
mask arg len 	extent node 
colopts opts 	committed merge 
name len arg 	extent node 
str colopts 	addr extent 
sep len key 	node 
colopts command 	size extent 
colopts opt arg 	szad extent 
unset colopts 	arena chunk 
column process colopts 	cache maybe 
opts argv 	extent szad 
strbuf addstr strstr 	arena 
strspn strbuf 	chunk cache 
utf strwidth strbuf 	maybe extent 
release strlen 	node addr 
div round linear 	extent node 
linear realloc 	addr extent 
div round 	node 
realloc compute column 	size extent 
width strlen 	node size 
compute column width 	extent node 
linear col 	size extent 
layout memset alloc 	node zeroed 
item length 	extent 
layout shrink columns 	node zeroed 
xmallocz memset 	extent node 
display cell free 	zeroed extent 
free free 	szad insert 
memset term columns 	arena chunk 
column active 	cache 
display plain col 	maybe insert 
layout display 	arena node 
plain display table 	dalloc malloc 
die col 	mutex unlock 
layout isatty 	chunk addr 
size strncmp strlen 	chunk 
strncmp error 	record arena 
strcspn parse option 	maybe purge 
strspn config 	chunk addr 
error nonbool parse 	chunk hooks 
config error 	assure initialized 
skip prefix strcmp 	dalloc 
column config 	decommit purge 
strcmp column config 	chunk record 
parse config 	chunk dss 
child process init 	chunk dalloc 
argv push 	mmap chunk 
argv pushf argv 	hooks 
pushf argv 	assure initialized 
pushf argv pushf 	dalloc jemalloc 
fflush dup 	valgrind make 
start command dup 	mem noaccess 
close dup 	pages 
close fflush 	commit pages 
close finish command 	decommit chunk 
dup close 	addr pages 
cell length index 	purge chunk 
longest row 	purge arena 
column length letters 	chunk 
ansi escapes 	arena chunk 
stripped len func 	hooks assure 
calculate cell 	initialized purge 
width rows cols 	chunk dss 
table equal 	chunk dss 
cells given table 	alloc 
width many 	system info 
spaces cells shrink 	jemalloc ffs 
columns shortening 	chunk dss 
one row time 	boot rtree 
adding columns 	chunk dss 
along way hopefully 	prefork 
longest cell 	chunk dss 
moved next 	postfork parent 
column column shrunk 	chunk dss 
space columns 	postfork child 
process ends whole 	data used 
thing longer 	exclusively 
fits data total 	gdump triggering 
width display 	various chunk 
without layout enabled 	related settings 
print cell 	chunksize function 
stdout necessary leading 	prototypes functions 
traling space 	referenced 
empty cell initial 	prior definition 
width chars 	copy field 
real column narrower 	atomically impossible 
increase len 	readers see 
bit fill less 	partially updated 
space display 	pointers 
col column col 	places readers 
row none 	need one 
always never 	hook function 
specified setting layout 	pointer therefore 
implies always 	need copy 
current col enable 	entirety 
mask disregarded 	arena chunk 
means column pass 	hooks stale 
column row 	reads affect 
become always column 	correctness perform 
never column 	unlocked reads 
always unless arg 	refresh 
states otherwise 	cur may 
one special must 	decreased since 
first one 	lost highchunks 
builtin column usage 	update race 
colopts argc 	first best 
argv prefix list 	fit 
copts real 	chunk selection 
command options git 	lowest chunk 
column config 	best fits 
starts git 	cached chunks 
config git config 	use node 
memset term 	linkage 
columns parse options 	embedded headers 
usage options 	dalloc node 
strcmp die finalize 	addr non 
colopts strbuf 	operating specific 
getline list append 	chunk beware 
print columns 	size 
cell length index 	wrap around 
longest row 	split lead 
column length letters 	node insert 
ansi escapes 	leading space 
stripped len func 	smaller chunk 
calculate cell 	split 
width rows cols 	trail insert 
table equal 	trailing space 
cells given 	smaller chunk 
table width many 	caller specifies 
spaces cells 	zero still 
shrink columns shortening 	possible 
one row 	receive zeroed 
time adding columns 	memory zero 
along way 	toggled arena 
hopefully longest cell 	chunk alloc 
moved next 	takes advantage 
column column shrunk 	avoid 
space columns 	demanding zeroed 
process ends whole 	chunks taking 
thing longer 	advantage returned 
fits data total 	retained primary 
width display 	dss mmap 
without layout enabled 	requesting 
print cell 	address implemented 
stdout necessary leading 	chunk alloc 
traling space 	mmap call 
empty cell 	addr secondary 
initial width chars 	dss strategies 
real column 	allocation 
narrower increase len 	failed directly 
bit fill 	call chunk 
less space display 	alloc mmap 
col column 	rather chunk 
col row none 	alloc core 
always never 	critical 
specified setting layout 	chunk alloc 
implies always 	untouched demand 
current col enable 	zeroed memory 
mask disregarded 	dodge tsd 
means column pass 	order avoid 
column row 	bootstrapping 
become always column 	issues arena 
never column 	allocating behalf 
always unless arg 	must initialized 
states otherwise 	already coalesce 
one special 	forward coalesce 
must first one 	chunk 
column.h width 	following address 
padding indent option 	range change 
command colopts 	position within 
colopts stdout tty 	chunks insert 
colopts list 	chunks szad 
colopts opts colopts 	coalescing 
column options 	forward failed 
always never column 	insert node 
given cmdline 	node allocation 
shrink columns possible 	failed exceedingly 
making space 	unlikely failure 
columns must zero 	leak 
fill columns 	chunk making 
rows fill rows 	sure pages 
columns one 	already purged 
column combine-diff.c one 	memory leak 
two curr 	coalesce backward 
num parent 	coalesce 
tail cmp len 	chunk previous 
path next 	address range 
prev len parent 	change position 
map line 	within chunks 
lost head lost 	insert node 
tail len 	chunks 
lost lenlost plost 	szad deallocate 
bol len 	decommit purge 
flag lno line 	fails verify 
len line 	actual page 
len flags lenbase 	size equal 
lennew parent 	integral 
flags lcs baseend 	multiple configured 
newend origbaselen 	page size 
lline lline oid 	configure chunksize 
mode size 	match granularity 
textconv path 	usually pages 
blob sline line 	map 
len lline 	always take 
mask lno nmask 	fast path 
num parent 	variables according 
sline lost bucket 	opt chunk 
state line 	install custom 
len state parent 	chunk 
mode result 	hooks large 
file sline cnt 	size classes 
num parent 	huge size 
result deleted textconv 	classes test 
path flags 	dalloc decommit 
lno lno nmask 	purge 
xpp xecfg 	cascade test 
parent file state 	decommit commit 
context combine 	observe split 
marker sline mask 	merge test 
sline mask 	purge chunk 
hunk begin 	huge 
sline mark cnt 	allocations least 
look uninteresting 	four size 
sline cnt num 	classes per 
parent mask 	doubling successful 
mark pre sline 	xallocx size 
cnt num 	huge 
parent dense mask 	size huge 
mark interesting 	guaranteed trailing 
hunk begin hunk 	purgeable memory 
end diff 	test decommit 
contin diff sline 	large allocations 
context bol 	make 
line len reset 	sure non 
saw eol 	huge allocation 
sline line prefix 	succeeds restore 
cnt num 	chunk hooks 
parent use color 	malloc conf 
result deleted 	orig 
mark pre 	hooks old 
lno frag func 	hooks dalloc 
old context 	decommit alloc 
reset hunk end 	dalloc commit 
rlines hunk 	decommit purge 
comment context comment 	split 
end mask 	merge addr 
sline cnt lno 	size alignment 
imask jmask 	zero commit 
head prefix path 	arena ind 
line prefix 	chunk size 
meta reset buf 	committed 
elem num 	arena ind 
parent dense rev 	chunk size 
line prefix 	offset length 
mode differs show 	arena ind 
file header 	err chunk 
opt abbrev prefix 	size 
prefix meta 	offset length 
reset abb 	arena ind 
added deleted elem 	err chunk 
num parent 	size offset 
dense working file 	length arena 
rev opt 	ind 
result size cnt 	chunk size 
lno result 	size size 
deleted result sline 	committed arena 
mode differs 	ind chunk 
show hunks result 	size chunk 
file userdiff 	size 
textconv binary line 	committed arena 
prefix buf 	ind old 
oid len done 	size size 
file buf 	large large 
buf size tmp 	huge huge 
num parent 	huge 
rev opt 	hooks xallocx 
line termination inter 	success xallocx 
name termination 	success xallocx 
line prefix num 	success trace 
parent dense 	hook alloc 
rev opt pair 	trace 
num parent 	hook dalloc 
pair pool opt 	trace hook 
paths num 	commit trace 
parent num paths 	hook decommit 
obj path 	trace hook 
sha parents opt 	purge 
paths num 	trace hook 
parent output format 	split trace 
orderfile stat 	hook merge 
opt sha parents 	mallctl ptr 
opt nparent 	ptr ptr 
parents sha paths 	ptr 
head sha 	ptr ptr 
parents dense 	ptr mallctl 
rev opt diffopts 	mallctl mallctl 
paths num 	mallctl mallctl 
paths needsep show 	mallocx ptr 
log first 	xallocx 
num parent need 	mallctl dallocx 
pathscan stat 	mallocx ptr 
opt tmp commit 	xallocx mallctl 
dense rev 	xallocx dallocx 
parent parents isdir 	mallocx ptr 
isdir strcmp 	xallocx 
name compare strlen 	dallocx mallocx 
strlen diff 	ptr mallctl 
unmodified pair strlen 	xallocx mallctl 
xmalloc combine 	xallocx dallocx 
diff path size 	mallocx ptr 
memcpy memset 	dallocx 
hashcpy hashcpy compare 	mallctl mallctl 
paths free 	ptr ptr 
hashcpy xdl 	ptr ptr 
isspace xdl isspace 	ptr ptr 
memcmp xdl 	ptr test 
isspace xdl isspace 	data 
xdl isspace 	used exclusively 
xdl isspace xdl 	gdump triggering 
isspace xdl 	various chunk 
isspace xdl isspace 	related settings 
xdl isspace 	chunksize function 
xcalloc xcalloc free 	prototypes 
free free 	functions referenced 
free free isgitlink 	prior definition 
xmalloc snprintf 	copy field 
oid hex oid 	atomically impossible 
xcalloc alloc 	readers see 
filespec fill filespec 	partially 
fill textconv 	updated pointers 
free filespec read 	places readers 
sha file 	need one 
die oid 	hook function 
hex flex alloc 	pointer therefore 
mem memcmp 	need 
parse hunk header 	copy entirety 
xcalloc append 	arena chunk 
lost grab blob 	hooks stale 
memset memset 	reads affect 
memset xdi diff 	correctness perform 
outf die 	unlocked 
oid hex free 	reads refresh 
coalesce lines 	cur may 
find next find 	decreased since 
next find 	lost highchunks 
next adjust hunk 	update race 
tail interesting 	first 
give context adjust 	best fit 
hunk tail 	chunk selection 
give context isalpha 	lowest chunk 
strlen diff 	best fits 
color diff 	cached chunks 
color diff color 	use 
diff color 	node linkage 
diff color diff 	embedded headers 
color hunk 	dalloc node 
comment line putchar 	addr non 
show parent 	operating specific 
lno putchar isspace 	chunk 
putchar putchar 	beware size 
putchar show line 	wrap around 
eol fputs 	split lead 
fputs fputs putchar 	node insert 
putchar show 	leading space 
line eol strbuf 	smaller 
reset strbuf 	chunk split 
addstr strbuf addstr 	trail insert 
strbuf addstr 	trailing space 
quote two 	smaller chunk 
style strbuf addstr 	caller specifies 
puts diff 	zero 
opt tst diff 	still possible 
color opt 	receive zeroed 
diff color opt 	memory zero 
show log 	toggled arena 
dump quoted path 	chunk alloc 
find unique 	takes 
abbrev find unique 	advantage avoid 
abbrev dump 	demanding zeroed 
quoted path dump 	chunks taking 
quoted path 	advantage returned 
dump quoted path 	retained primary 
dump quoted 	dss 
path diff line 	mmap requesting 
prefix userdiff 	address implemented 
find path userdiff 	chunk alloc 
find name 	mmap call 
diff opt 	addr secondary 
tst userdiff textconv 	dss 
grab blob 	strategies allocation 
lstat islnk strbuf 	failed directly 
readlink error 	call chunk 
strerror strbuf detach 	alloc mmap 
canon mode 	rather chunk 
isdir resolve gitlink 	alloc 
grab blob 	core critical 
grab blob alloc 	chunk alloc 
filespec fill 	untouched demand 
filespec fill textconv 	zeroed memory 
free filespec 	dodge tsd 
open xsize canon 	order 
mode islnk 	avoid bootstrapping 
canon mode xmallocz 	issues arena 
read full 	allocating behalf 
die errno die 	must initialized 
convert git 	already coalesce 
free strbuf 	forward 
detach xcalloc close 	coalesce chunk 
buffer binary 	following address 
grab blob buffer 	range change 
binary free 	position within 
show combined header 	chunks insert 
free xcalloc 	chunks 
xcalloc mult oidcmp 	szad coalescing 
reuse combine 	forward failed 
diff combine diff 	insert node 
make hunks 	node allocation 
show combined header 	failed exceedingly 
dump sline 	unlikely 
free free free 	failure leak 
free diff 	chunk making 
line prefix show 	sure pages 
log putchar 	already purged 
diff unique abbrev 	memory leak 
diff unique 	coalesce 
abbrev putchar 	backward coalesce 
putchar write name 	chunk previous 
quoted show 	address range 
raw diff show 	change position 
patch diff 	within chunks 
free free xmalloc 	insert 
xcalloc hashcpy 	node chunks 
oid hashcpy oid 	szad deallocate 
xcalloc combined 	decommit purge 
pair format callback 	fails verify 
free combined 	actual page 
pair free diff 	size 
sha diffcore 	equal integral 
std intersect paths 	multiple configured 
diffcore order 	page size 
diff flush alloc 	configure chunksize 
strbuf init 	match granularity 
diff paths 	usually 
strbuf release free 	pages map 
show log 	always take 
commit format empty 	fast path 
diff line 	variables according 
prefix copy pathspec 	opt chunk 
diff opt 	install 
diff opt clr 	custom chunk 
diff opt 	hooks large 
tst find paths 	size classes 
find paths 	huge size 
multitree diff sha 	classes test 
diffcore std 	dalloc 
diffcore order diff 	decommit purge 
flush alloc 	cascade test 
order objects free 	decommit commit 
show raw 	observe split 
diff handle combined 	merge test 
callback diff 	purge 
line prefix 	chunk huge 
show patch diff 	allocations least 
free free 	four size 
pathspec saved parents 	classes per 
sha append 	doubling successful 
diff combined sha 	xallocx 
clear paths 	size huge 
curr linked list 	size huge 
queue sorted 	guaranteed trailing 
order path queue 	purgeable memory 
drop queue 	test decommit 
path skip lines 	large 
lost parent 	allocations make 
lines lost current 	sure non 
parent coalescing 	huge allocation 
lines surviving merge 	succeeds restore 
result accumulated 	chunk hooks 
coalesced lost lines 	chunk.h 
bit parent 	opt chunk 
line change 	opt dss 
bit used interesting 	chunks rtree 
lines including 	chunksize chunksize 
context bit used 	mask chunk 
show deletion 	npages 
consume remaining spaces 	chunk hooks 
matched full 	arena arena 
line line coalesce 	chunk hooks 
lines finding 	chunk node 
lcs coalesce lines 	chunk 
finding lcs 	node size 
create table run 	arena chunk 
programming compute 	hooks addr 
lcs reverse read 	size alignment 
direction structure 	zero dalloc 
match assign parent 	node 
flag consume 	arena chunk 
baseend newend consume 	hooks addr 
baseend insert 	size alignment 
newend lline 	zero commit 
consume newend point 	arena chunk 
baseend newend 	hooks 
point end lists 	chunk size 
lline list 	committed arena 
update newend lline 	chunk hooks 
list deleted 	chunk size 
blob removed lines 	zeroed committed 
would come 	arena 
line result lost 	chunk hooks 
buckets hang 	chunk size 
line removed lines 	committed arena 
note correct 	chunk offset 
even hunk removes 	length arena 
first line 	chunk 
file hunk yet 	hooks chunk 
result deleted 	size offset 
assign line numbers 	length chunk 
parent sline 	dependent ptr 
lno lno 	dependent rtree 
records first line 	size 
number counting 	alignment memory 
parent hunk display 	chunks allocated 
started showing 	memory system 
sline lno possibly 	chunk address 
showing lost 	allocation address 
lines attached first 	chunk 
coalesce lines 	offset address 
many lines would 	smallest chunk 
sline advance 	multiple jemalloc 
lno means parent 	types jemalloc 
means parent 	structs chunksize 
trailer parents lost 	jemalloc 
lines added 	externs jemalloc 
parent interesting points 	inlines chunk 
first uninteresting 	dssc dss 
line last 	prec names 
line hunk interesting 	dss prec 
deletion interesting 	dss 
purpose giving trailing 	mtx dss 
context lines 	dss prev 
output line unmodified 	dss max 
sline gives 	increment ret 
one extra context 	dss prec 
line examined 	arena 
look find next 	addr size 
interesting uninteresting 	alignment zero 
line interesting mean 	commit ret 
interesting marked 	cpad dss 
give context function 	next gap 
includes context 	size 
lines interesting interesting 	cpad size 
function surrounded 	incr chunk 
interesting ones two 	hooks chunk 
groups interesting 	ret sbrk 
lines may 	implemented malloc 
gap uninteresting lines 	mutex 
connect groups 	malloc mutex 
give bit context 	unlock malloc 
first start 	mutex malloc 
interesting function says 	mutex unlock 
mark mark 	cassert malloc 
paint context lines 	mutex 
mark interesting 	chunk dss 
would still say 	sbrk chunk 
context lines 	addr offset 
treated interesting end 	alignment ceiling 
paint lines 	malloc mutex 
first interesting line 	unlock 
know included 	chunk dss 
next uninteresting one 	sbrk malloc 
start rest 	mutex unlock 
interesting lookahead context 	chunk dalloc 
lines interesting 	wrapper jemalloc 
paint interesting 	valgrind 
gap small first 	make mem 
uninteresting line 	undefined memset 
overlap beyond within 	pages decommit 
context lines 	malloc mutex 
paint trailing edge 	unlock cassert 
bit look 	malloc 
hunk changes one 	mutex malloc 
parent changes 	mutex unlock 
one parent mark 	cassert malloc 
uninteresting interesting 	mutex init 
hunks look beyond 	chunk dss 
end see 	sbrk 
interesting line hunk 	malloc mutex 
within context 	prefork malloc 
span lookahead hunk 	mutex postfork 
end interesting 	parent malloc 
really interesting check 	mutex postfork 
two versions 	child 
result matches 	data current 
one look line 	dss precedence 
records lines 	used creating 
added parents line 	arenas protects 
appears result 	sbrk calls 
line records parents 	avoids 
line removed 	malloc races 
line appear result 	among threads 
check parents 	though protect 
result difference lines 	races threads 
lines different 	call sbrk 
parents result differences 	directly 
means two 	address dss 
versions even two 	current end 
versions result 	dss dss 
match parents considered 	exhausted current 
interesting would 	upper limit 
line passing 	dss 
two versions test 	addresses sbrk 
would appear 	uses increment 
parents parents changes 	argument take 
others lost 	care interpret 
line parents hunk 	huge allocation 
interesting result 	request 
deleted pointing last 	negative increment 
hunk even 	loop necessary 
running unified lines 	recover races 
hunk needs 	threads dss 
processed loop order 	something malloc 
show deletion 	avoid 
recorded lost head 	unnecessary system 
however want 	call current 
show resulting line 	end dss 
blank context 	make sure 
markers compensate sline 	earlier condition 
hang lost 	still 
lines front 	holds calculate 
already examined parent 	much padding 
know parent 	necessary chunk 
parent reuse combined 	align end 
result parent 	dss compute 
parent overall size 	much 
file sline 	chunk aligned 
cnt say added 	pad space 
nobody survived 	necessary satisfy 
lines read result 	alignment space 
merge first 	recycled later 
used diff read 	use 
working symlinks 	wrap around 
work symlink parents 	success chunk 
symlinks fake 	dssh dss 
symlink apply filters 	prec names 
autocrlf incomplete 	dss prec 
line even lno 	arena 
cnt valid 	addr size 
end line 	alignment zero 
number deletion hunk 	commit chunk 
end many 	jemalloc types 
colons parents show 	jemalloc structs 
modes show 	jemalloc 
sha result elem 	externs jemalloc 
working parents 	inlines chunk 
typically multiple stages 	mmapc size 
merge diff 	alignment zero 
files state head 	commit ret 
index diff 	alloc 
index combine diff 	size pages 
path expresses 	leadsize size 
parents lhs merge 	alignment zero 
result synthesize 	commit ret 
diff filepair entries 	offset chunk 
one side 	size 
entry two side 	pages map 
future might 	alignment ceiling 
want data 	pages trim 
combine diff path 	pages decommit 
fill fields 	pages map 
ignoring notably size 	alignment 
currently nobody 	addr offset 
uses suffice find 	pages unmap 
paths every 	chunk alloc 
parent touches tell 	mmap slow 
diff emit 	pages decommit 
paths sorted order 	pages 
wrt paths 	unmap beware 
show stat first 	size wrap 
parent even 	around ideally 
combined diff showing 	would way 
diff show 	specify alignment 
requested order find 	mmap 
paths everybody 	like net 
touches assuming 	bsd absence 
diff run without 	feature work 
rename copy 	hard efficiently 
detection etc comparing 	create aligned 
trees simultaneously 	mappings 
faster fake list 	reliable slow 
head worker 	method create 
non nothing parents 	mapping sized 
find paths 	trim excess 
everybody touches note 	however always 
diffcore transformations 	results 
bound diff filespec 	one two 
logic comparing 	calls pages 
two entries apply 	unmap optimistically 
directly combine 	mapping precisely 
diff transformations requested 	right amount 
launch path 	falling 
scanning works significantly 	back slow 
slower compared 	method expectation 
simultaneous trees 	optimistic approach 
one scan find 	works time 
paths multitree 	chunk mmaph 
todo filters could 	size 
ported work 	alignment zero 
combine diff paths 	commit chunk 
functionality skips 	size jemalloc 
paths theory could 	types jemalloc 
end multitree 	structs jemalloc 
path scanning note 	externs 
please keep 	jemalloc inlines 
semantically sync diffcore 	ckh.c tsd 
std note 	ckh tsd 
also handles stat 	ckh ckh 
computes diff 	bucket key 
sha parent job 	cell 
specifically parent 	ckh key 
show stat first 	hashes bucket 
parent even 	cell ckh 
combined diff 	bucket key 
find number surviving 	data cell 
paths order 	offset 
paths according diffcore 	ckh argbucket 
order clean 	argkey argdata 
things commit-slab.h define 	key data 
commit slab 	tkey tdata 
slabname elemtype creates 	cell hashes 
boilerplate code 	bucket 
define slabname used 	tbucket ckh 
associate piece 	argkey argdata 
data elemtype commits 	hashes bucket 
functions use 	key data 
including header file 	ckh tab 
define commit 	count 
slab indegee call 	nins key 
following functions 	data tsd 
indegree indegree commit 	ckh ret 
function locates 	tab ttab 
data associated 	curcells prevbuckets 
given commit indegree 	usize 
slab returns 	tsd ckh 
pointer location store 	tab ttab 
data allocated 	curcells usize 
necessary indegree peek 	prevbuckets tsd 
indegree commit 	ckh minitems 
function similar indegree 	hash 
call indegree 	keycomp ret 
made commit init 	mincells usize 
indegree indegree 	mincells tsd 
init indegree stride 	ckh ckh 
indegree initializes 	ckh tabind 
indegree slab associates 	key 
integers commit 	data ncells 
stride specifies big 	tsd ckh 
slab initialized 	key data 
variant without stride 	ret tsd 
associates commit 	ckh searchkey 
one integer 	key 
clear indegree indegree 	data cell 
empties slab 	ckh searchkey 
slab reused stride 	key data 
without calling 	cell key 
init indegree reconfigured 	hash key 
different stride 	hash 
calling init indegree 	keycomp hash 
stride call 	ckh bucket 
function slab falls 	search ckh 
scope avoid 	bucket search 
leaking memory allocate 	prng prng 
allowing malloc 	hash 
overhead note seemingly 	ckh bucket 
redundant second 	insert hash 
declaration required allow 	ckh bucket 
terminating semicolon 	insert ckh 
makes instantiations 	bucket insert 
look like function 	ckh 
declarations expansion 	evict reloc 
define commit slab 	insert ckh 
indegree ends 	insert ipallocztm 
stat indegreerealloc would 	ckh rebuild 
otherwise syntax 	idalloctm tcache 
error according least 	idalloctm 
iso hard 	tcache ipallocztm 
gcc silently parses 	ckh rebuild 
statically initialize 	idalloctm tcache 
commit slab named 	idalloctm tcache 
note evaluates 	ipallocztm malloc 
stride multiple times 	idalloctm 
example indegree 	tcache memset 
indegrees commit slab 	ckh search 
init indegrees 	ckh insert 
commit slab commit-tree.c 	ckh grow 
commit usage 	ckh isearch 
sign commit 	ckh 
parent parents oid 	shrink ckh 
parents status 	isearch hash 
argc argv prefix 	strlen strcmp 
got parents 	hash implementation 
sha commit sha 	cuckoo hashing 
buffer arg 	indicates 
sha error oid 	hash bucket 
hex commit 	contains cells 
list insert git 	indicates two 
gpg config 	hash functions 
strcmp git config 	employed original 
git config 	cuckoo 
git config strcmp 	hashing algorithm 
usage strcmp 	described pagh 
usage sha commit 	rodler cuckoo 
die sha 	hashing journal 
type parent lookup 	algorithms generalization 
commit skip 	cuckoo 
prefix strcmp 	hashing discussed 
strcmp usage strbuf 	erlingsson manasse 
addch strbuf 	sherry cool 
addstr strbuf complete 	practical alternative 
line strcmp 	traditional hash 
usage strbuf addch 	tables 
strcmp open 	proceedings workshop 
die errno strbuf 	distributed data 
read die 	structures wdas 
errno close die 	santa clara 
errno strbuf 	january implementation 
complete line sha 	uses 
die die 	precisely two 
strbuf read die 	hash functions 
errno commit 	fewest work 
strbuf release sha 	supporting multiple 
hex strbuf 	hashes implementation 
release git information 	burden 
manager hell 	reproduction figure 
copyright linus 	erlingsson shows 
torvalds commit.c buf 	approximate expected 
len save 	maximum load 
commit buffer commit 	factors various 
type sha 	configurations 
quiet obj sha 	cells bucket 
sha name 	hashes number 
sha obj name 	cells per 
oid commit 	bucket chosen 
buf tail dateptr 	bucket fits 
commit graft 	one 
commit graft alloc 	cache line 
commit graft 	bit systems 
index table commit 	use cuckoo 
graft table 	hashing respectively 
sha graft ignore 	function prototypes 
dups pos 	non 
buf len 	functions search 
graft entry size 	bucket key 
graft file 	cell number 
buf graft commit 	found size 
graft prepared 	max otherwise 
graft file sha 	search 
pos data 	table key 
ret sha pos 	cell number 
buffer size 	found size 
buffer slab commit 	max otherwise 
buffer size 	search primary 
commit sizep commit 	bucket 
sizep ret 	search secondary 
size commit buffer 	bucket cycle 
commit commit 	cells bucket 
sizep ret item 	starting random 
buffer size 	position randomness 
tail bufptr parent 	avoids 
pptr graft 	worst search 
entry len 	overhead buckets 
parent entry len 	fill space 
parent parent 	available bucket 
item quiet missing 	randomly evict 
buffer size 	item 
ret item commit 	find alternate 
buffer subject 	location item 
eol item list 	iteratively repeat 
list list 	eviction relocation 
head list item 	procedure either 
list date 	success 
date next list 	detection eviction 
list mark 	relocation bucket 
ret parents commit 	cycle choose 
plist commit 	random item 
mark parents commit 	within bucket 
mark list 	evict 
commit mark mark 	critical correct 
commit stack 	function without 
top item 	eventually evicting 
author date commit 	items within 
buffer ident 	bucket iteration 
ident line ident 	would 
len date 	possible stuck 
end date data 	infinite loop 
author date 	item hashes 
date date unused 	indicated bucket 
sort topological 	swap cell 
order flags queue 	key 
commit one 	data key 
twos queue result 	data evict 
commit parents 	find alternate 
flags one twos 	bucket evicted 
list result 	item may 
commit ret end 	tbucket 
bases cnt 	bucket still 
work redundant filled 	item hashes 
index filled 	indicate bucket 
common one 	however guaranteed 
twos cleanup list 	eventually escape 
rslt result 	bucket 
cnt one twos 	iteration assuming 
one twos 	pseudo random 
one two commit 	item selection 
commit commit 	randomness would 
reference reference bases 	make infinite 
commit reference 	looping 
heads tail num 	remote possibility 
head gpg 	reason never 
sig header gpg 	trapped forever 
sig header 	two cases 
len buf keyid 	bucket 
sig inspos 	argbucket quickly 
copypos bol eol 	detect eviction 
len commit 	cycle terminate 
payload signature 	item evicted 
size buffer signature 	bucket another 
saw signature 	means 
line tail sig 	least one 
next buf 	item bucket 
line tail signature 	hashes indicate 
sig start 	distinct buckets 
sig end next 	check cycle 
parent tail 	insert 
desc mergetag buf 	primary bucket 
size len 	insert secondary 
commit sigc payload 	bucket find 
signature ret 	place item 
parents tail parent 	via iterative 
buffer extra 	eviction 
commit exclude extra 	relocation rebuild 
size buffer 	hash table 
commit data extra 	scratch inserting 
free field 	items old 
len field 	table possible 
len exclude xlen 	though 
buffer size 	unlikely given 
exclude line next 	well behaved 
eof eob 	hashes table 
buf extra next 	doubled order 
msg msg 	create usable 
len parents ret 	table 
author sign 	swap table 
commit tail result 	rebuilding failed 
buf len 	back partially 
offset max codepoint 	rebuilt table 
bytes bad 	possible though 
offset codepoint min 	unlikely 
val max 	given well 
val buf pos 	behaved hashes 
bad replace 	table rebuild 
commit utf warn 	fail oom 
msg msg 	error isn 
len parents 	worth 
ret author sign 	propagating since 
commit extra 	doesn prevent 
result encoding utf 	future operations 
buffer parent 	proceeding swap 
name obj commit 	table rebuilding 
oid desc 	failed 
commit next list 	back partially 
format cur 	rebuilt table 
format last format 	doesn really 
msg key 	matter find 
len key len 	minimum power 
line eol 	large 
boc bol old 	enough fit 
conflicts block 	minitems entries 
next line deref 	cuckoo hashing 
tag parse 	expected maximum 
type lookup commit 	load factor 
reference gently 	least 
lookup commit 	conservative load 
reference die hashcmp 	factor typically 
warning sha 	allow mincells 
hex lookup create 	items fit 
alloc commit 	without ever 
node type sha 	growing 
committish lookup 	table nothing 
commit reference parse 	necessary halve 
commit memcmp 	table less 
memcmp strtoul sha 	full ignore 
pos commit 	error due 
graft pos free 	oom 
free alloc 	insert search 
grow memmove isspace 	tsd ckh 
xmalloc mult 	tsd ckh 
oid hex sha 	strs missing 
hex error 	tsd ckh 
free fopen strbuf 	seen 
getwholeline read 	tabind tsd 
graft line 	fetch ckh 
commit graft error 	ckh ckh 
fclose strbuf 	ckh tsd 
release graft file 	fetch ckh 
read graft 	ckh 
file repository shallow 	count ckh 
prepare commit 	count ckh 
graft commit graft 	insert ckh 
pos commit 	count ckh 
graft pos memmove 	count ckh 
define commit 	search 
slab commit slab 	ptr ptr 
init buffer 	ckh search 
slab buffer slab 	ckh ptr 
peek cached 	ptr ckh 
commit buffer read 	count ckh 
sha file 	count 
die oid 	ckh tsd 
hex die oid 	fetch ckh 
hex buffer 	mallocx ptr 
slab peek free 	ckh insert 
buffer slab 	ckh search 
peek free buffer 	ptr 
slab peek 	ptr ckh 
memcmp error oid 	count ckh 
hex sha 	count ckh 
hex error oid 	search ckh 
hex lookup 	ptr ptr 
lookup commit graft 	ckh 
memcmp sha 	search ckh 
hex error oid 	memset ckh 
hex lookup 	iter ptr 
commit commit list 	ckh search 
insert lookup 	ckh ptr 
commit commit list 	ptr 
insert parse 	ckh search 
commit date 	ckh dallocx 
read sha file 	ckh count 
error oid 	ckh count 
hex free error 	ckh test 
oid hex 	implementation 
parse commit buffer 	cuckoo hashing 
commit buffer 	indicates hash 
free parse commit 	bucket contains 
die oid 	cells indicates 
hex xmalloc commit 	two hash 
list append 	functions 
pop commit commit 	employed original 
list insert 	cuckoo hashing 
llist mergesort pop 	algorithm described 
commit parse 	pagh rodler 
commit commit list 	cuckoo hashing 
insert date 	journal 
commit list insert 	algorithms generalization 
commit list 	cuckoo hashing 
insert clear 	discussed erlingsson 
commit marks pop 	manasse sherry 
commit clear 	cool practical 
commit marks many 	alternative 
lookup commit 	traditional hash 
reference gently clear 	tables proceedings 
commit marks 	workshop distributed 
free define commit 	data structures 
slab commit 	wdas santa 
buffer find commit 	clara 
header split 	january implementation 
ident line strtoul 	uses precisely 
author date 	two hash 
slab unuse commit 	functions fewest 
buffer author 	work supporting 
date slab author 	multiple 
date slab 	hashes implementation 
commit list append 	burden reproduction 
prio queue 	figure erlingsson 
put prio 	shows approximate 
queue put queue 	expected maximum 
nonstale prio 	load 
queue commit list 	factors various 
insert date 	configurations cells 
parse commit prio 	bucket hashes 
queue put 	number cells 
clear prio queue 	per bucket 
commit list 	chosen 
insert parse commit 	bucket fits 
parse commit 	one cache 
paint common pop 	line bit 
commit commit 	systems use 
list insert date 	cuckoo hashing 
commit list 	respectively 
insert merge bases 	function prototypes 
xcalloc xcalloc 	non functions 
alloc parse 	search bucket 
commit paint common 	key cell 
clear commit 	number found 
marks clear commit 	size 
marks free 	max otherwise 
commit list memcpy 	search table 
free free 	key cell 
free merge bases 	number found 
many clear 	size max 
commit marks clear 	otherwise 
commit marks 	search primary 
many commit list 	bucket search 
count xcalloc 	secondary bucket 
free commit list 	cycle cells 
clear commit 	bucket starting 
marks clear commit 	random 
marks many 	position randomness 
redundant commit list 	avoids worst 
insert date 	search overhead 
free merge 	buckets fill 
bases many merge 	space available 
bases many 	bucket 
merge bases many 	randomly evict 
merge bases 	item find 
parse commit parse 	alternate location 
commit paint 	item iteratively 
common clear commit 	repeat eviction 
marks clear 	relocation 
commit marks many 	procedure either 
free commit 	success detection 
list merge bases 	eviction relocation 
many xcalloc 	bucket cycle 
redundant commit list 	choose random 
insert strstr 	item 
signing key sign 	within bucket 
buffer strbuf 	evict critical 
release strchrnul strbuf 	correct function 
insert strbuf 	without eventually 
insert strbuf 	evicting items 
insert strbuf release 	within 
commit buffer 	bucket iteration 
memchr starts strbuf 	would possible 
strbuf unuse 	stuck infinite 
commit buffer memchr 	loop item 
starts strbuf 	hashes indicated 
merge remote read 	bucket 
sha file 	swap cell 
parse signature xcalloc 	key data 
xstrdup free 	key data 
parse commit check 	evict find 
signature strbuf 	alternate bucket 
release strbuf release 	evicted 
handle tag 	item may 
strbuf addstr strbuf 	tbucket bucket 
lines strbuf 	still item 
addch commit buffer 	hashes indicate 
read commit 	bucket however 
extra header 	guaranteed 
lines unuse commit 	eventually escape 
buffer read 	bucket iteration 
commit extra headers 	assuming pseudo 
strcmp free 	random item 
commit extra headers 	selection randomness 
memcmp memcmp 	would 
memcmp memcmp memcmp 	make infinite 
strlen memcmp 	looping remote 
memchr strbuf strbuf 	possibility reason 
detach strbuf 	never trapped 
reset strchr standard 	forever two 
header field 	cases 
excluded header field 	bucket argbucket 
xcalloc xmemdupz 	quickly detect 
strbuf strbuf detach 	eviction cycle 
free free 	terminate item 
free append 	evicted bucket 
merge tag headers 	another 
commit extended 	means least 
free commit extra 	one item 
headers find 	bucket hashes 
invalid utf strbuf 	indicate distinct 
strbuf insert 	buckets check 
sha type memchr 	cycle 
error encoding 	insert primary 
utf strbuf init 	bucket insert 
strbuf addf 	secondary bucket 
sha hex pop 	find place 
commit strbuf 	item via 
addf oid hex 	iterative 
git author 	eviction relocation 
info strbuf addf 	rebuild hash 
strbuf addf 	table scratch 
git committer info 	inserting items 
strbuf addf 	old table 
extra header 	possible 
strbuf addch strbuf 	though unlikely 
verify utf 	given well 
sign commit write 	behaved hashes 
sha file 	table doubled 
strbuf release sha 	order create 
parse peel 	usable 
type xmalloc strdup 	table swap 
xmalloc oid 	table rebuilding 
hex strlen strchrnul 	failed back 
strncmp memchr 	partially rebuilt 
starts nada nada 	table possible 
nada dateptr 	though 
buf buf strtoul 	unlikely given 
stop buf 	well behaved 
format commit parent 	hashes table 
parent format 	rebuild fail 
commit parent parent 	oom error 
make sure 	isn 
shallows read 	worth propagating 
hex sha clone 	since doesn 
shallow parent 	prevent future 
must traverse real 	operations proceeding 
parents even 	swap table 
unhide nothing topological 	rebuilding 
sort support 	failed back 
count number children 	partially rebuilt 
emitted record 	table doesn 
author date commit 	really matter 
author line 	find minimum 
malformed author line 	power 
malformed date 	large enough 
newer commits larger 	fit minitems 
date first 	entries cuckoo 
newer commits larger 	hashing expected 
date first 	maximum load 
performs place topological 	factor 
sort list 	least conservative 
supplied rev 	load factor 
sort graph order 	typically allow 
mark clear 	mincells items 
indegree also record 	fit without 
author dates 	ever 
needed update indegree 	growing table 
find tips 	nothing necessary 
tips nodes reachable 	halve table 
node list 	less full 
tips serve starting 	ignore error 
work queue 	due 
unfortunate initial tips 	oom insert 
need shown 	search ckh.c 
order given revision 	tsd ckh 
traversal machinery 	tsd ckh 
longer need commit 	ckh bucket 
list parents 	key 
enqueued emission children 	cell ckh 
emitted thereby 	key hashes 
guaranteeing topological 	bucket cell 
order children commit 	ckh bucket 
already emitted 	key data 
emit merge stuff 	cell 
remember update 	offset ckh 
flag allocation input 	argbucket argkey 
commits one 	argdata key 
twos must parsed 	data tkey 
mark parents 	tdata cell 
found merge stale 	hashes 
mark even 	bucket tbucket 
result clean commit 	ckh argkey 
may ancestor 	argdata hashes 
another commit move 	bucket key 
commit end 	data ckh 
number commits independent 	tab 
collect result 	count nins 
one commit 	key data 
descendant one elements 	tsd ckh 
commit list 	ret tab 
commit ancestor one 	ttab curcells 
references commit 	prevbuckets 
ancestor reachable reference 	usize tsd 
uniquify find 	ckh tab 
end header dump 	ttab curcells 
whole remainder 	usize prevbuckets 
buffer dump whole 	tsd ckh 
remainder buffer 	minitems 
could verify signature 	hash keycomp 
either omit 	ret mincells 
tag validate integrator 	usize mincells 
may key 	tsd ckh 
signer tag merging 	ckh ckh 
later auditor 	tabind 
may auditing run 	key data 
verify buffer 	ncells tsd 
verify buffer 	ckh key 
buf len buf 	data ret 
len size 	tsd ckh 
len warn warning 	searchkey 
tag unverified 	key data 
merge tag continuation 	cell ckh 
simple ascii 	searchkey key 
worries count many 	data cell 
high bits 	key hash 
many bytes sequence 	key 
must bytes 	hash keycomp 
longer sequences result 	hash ckh 
codepoints beyond 	bucket search 
ffff guaranteed never 	ckh bucket 
exist many 	search prng 
bytes place encoded 	prng 
bits bottom 	hash ckh 
compute valid range 	bucket insert 
verify good 	hash ckh 
continuation bytes 	bucket insert 
reject codepoints range 	ckh bucket 
sequence length 	insert 
surrogates utf cannot 	ckh evict 
encoded utf 	reloc insert 
fffe ffff guaranteed 	ckh insert 
non characters 	ipallocztm ckh 
anything range fdd 	rebuild idalloctm 
fdef verifies 	tcache 
buffer proper utf 	idalloctm tcache 
format isn 	ipallocztm ckh 
assumes non utf 	rebuild idalloctm 
characters latin 	tcache idalloctm 
conversion know must 	tcache ipallocztm 
range commitencoding 	malloc 
utf avoid reallocs 	idalloctm tcache 
headers note 	memset ckh 
ordering means exact 	search ckh 
merged different 	insert ckh 
order parents 	grow ckh 
different changeset even 	isearch 
everything stays 	ckh shrink 
person date information 	ckh isearch 
comment check 	hash strlen 
encoding append commit 	strcmp hash 
end commit 	implementation cuckoo 
list next starts 	hashing 
pointing variable 	indicates hash 
holds head empty 	bucket contains 
commit list 	cells indicates 
updated point next 	two hash 
field last 	functions employed 
item list commits 	original 
appended usage 	cuckoo hashing 
example commit list 	algorithm described 
list commit 	pagh rodler 
list next 	cuckoo hashing 
list next commit 	journal algorithms 
list append 	generalization 
next next commit 	cuckoo hashing 
list append 	discussed erlingsson 
next commit list 	manasse sherry 
count list 	cool practical 
list inspect determine 	alternative traditional 
end log 	hash 
message order find 	tables proceedings 
put line 	workshop distributed 
ignored trailing comment 	data structures 
lines blank 	wdas santa 
lines also traditional 	clara january 
conflicts block 	implementation 
commented use git 	uses precisely 
commit amend 	two hash 
existing commit forgot 	functions fewest 
returns number 	work supporting 
bytes tail 	multiple hashes 
ignore fed second 	implementation 
parameter append 	burden reproduction 
signoff first run 	figure erlingsson 
comments otherwise 	shows approximate 
continuing pathname conflicts 	expected maximum 
block previous 	load 
trailing comment builtin 	factors various 
git commit 	configurations cells 
copyright kristian gsberg 	bucket hashes 
krh redhat 	number cells 
git commit junio 	per bucket 
hamano linus 	chosen 
torvalds real index 	bucket fits 
used commits 	one cache 
message variables commit 	line bit 
names take 	systems use 
commit message authorship 	cuckoo hashing 
unspecified commit 	respectively 
message cleanup 	function prototypes 
mode lines beginning 	non functions 
shell comments 	search bucket 
leading trailing whitespaces 	key cell 
empty lines 	number found 
containing whitespaces editor 	size 
used whitespaces 	max otherwise 
message specified explicitly 	search table 
must come 	key cell 
git config nothing 	number found 
nothing take 	size max 
paths index named 	otherwise 
typically head 	search primary 
paths match given 	bucket search 
pattern list 	secondary bucket 
better valid pointer 	cycle cells 
fake one 	bucket starting 
skip worktree already 	random 
reported error 	position randomness 
finish dying 	avoids worst 
refresh flags contains 	search overhead 
refresh quiet 	buckets fill 
errors unmerged entries 	space available 
non non 	bucket 
commit real index 	randomly evict 
update index 	item find 
necessary write index 	alternate location 
real index 	item iteratively 
still locked name 	repeat eviction 
locked index 	relocation 
file caller run 	procedure either 
hooks locked 	success detection 
real index goes 	eviction relocation 
well commit 	bucket cycle 
real index failure 	choose random 
rollback real 	item 
index commit 	within bucket 
name real index 	evict critical 
file caller 	correct function 
run hooks real 	without eventually 
index create 	evicting items 
commit index still 	within 
need refresh 	bucket iteration 
index commit find 	would possible 
affected paths 	stuck infinite 
real index file 	loop item 
update index 	hashes indicated 
given paths write 	bucket 
index real 	swap cell 
index still locked 	key data 
index file 	key data 
reset index head 	evict find 
update index 	alternate bucket 
way write index 	evicted 
index file 	item may 
name index 	tbucket bucket 
file still locked 	still item 
caller run 	hashes indicate 
hooks locked index 	bucket however 
create commit 	guaranteed 
goes well commit 	eventually escape 
real index 	bucket iteration 
failure rollback real 	assuming pseudo 
index either 	random item 
rollback index checks 	selection randomness 
barfs author 	would 
badly specified insert 	make infinite 
proper subject 	looping remote 
line commit message 	possibility reason 
options content 	never trapped 
remaining cases modify 	forever two 
message argument 	cases 
prepare commit msg 	bucket argbucket 
hook squash 	quickly detect 
commit used 	eviction cycle 
commit subject possibly 	terminate item 
hijacking commit 	evicted bucket 
log options reset 	another 
hook args 	means least 
tell real story 	one item 
ignore status 	bucket hashes 
display comment prefix 	indicate distinct 
need comments 	buckets check 
commit editmsg hints 	cycle 
counter productive 	insert primary 
commit already started 	bucket insert 
checks committer 	secondary bucket 
ident explicitly given 	find place 
cleanup space 	item via 
never fail come 	iterative 
fmt ident 	eviction relocation 
may fail sane 	rebuild hash 
ident test 	table scratch 
know name 	inserting items 
mail pointers least 	old table 
valid enough 	possible 
tests printing unless 	though unlikely 
user explicitly 	given well 
request submodule ignore 	behaved hashes 
mode passing 	table doubled 
command line option 	order create 
ignore changed 	usable 
submodule sha comparing 	table swap 
index parent 	table rebuilding 
matter configured otherwise 	failed back 
won commit 	partially rebuilt 
submodules manually staged 	table possible 
would really 	though 
confusing reject attempt 	unlikely given 
record non 	well behaved 
merge empty commit 	hashes table 
without allow 	rebuild fail 
empty cherry 	oom error 
pick may empty 	isn 
due conflict 	worth propagating 
resolution user okay 	since doesn 
read index 	prevent future 
pre commit hook 	operations proceeding 
could updated 	swap table 
write must invoke 	rebuilding 
editor invoke 	failed back 
run status check 	partially rebuilt 
rest whitespace 	table doesn 
find message strbuf 	really matter 
contains whitespace 	find minimum 
lines see user 	power 
edited message 	large enough 
editor left intact 	fit minitems 
already initialized 	entries cuckoo 
enumerate needs 	hashing expected 
propagated porcelain effect 	maximum load 
unspecified sanity 	factor 
check options oldsha 	least conservative 
newsha nul 	load factor 
hook know editor 	typically allow 
launched end 	mincells items 
commit message options 	fit without 
end commit 	ever 
contents options ignore 	growing table 
status everything 	nothing necessary 
writing commit includes 	halve table 
running hooks 	less full 
writing trees interacting 	ignore error 
user determine 	due 
parents commit message 	oom insert 
truncate message 	search tsd 
diff amending current 	ckh tsd 
head builtin 	ckh strs 
commit usage 	missing tsd 
builtin status usage 	ckh 
ident advice 	seen tabind 
noconfig ident advice 	tsd fetch 
config empty 	ckh ckh 
amend advice empty 	ckh ckh 
cherry pick 	tsd fetch 
advice empty cherry 	ckh 
pick advice 	ckh count 
single empty cherry 	ckh count 
pick advice 	ckh insert 
multi use message 	ckh count 
buffer commit 	ckh count 
editmsg index logfile 	ckh 
force author 	search ptr 
file author message 	ptr ckh 
author message 	search ckh 
buffer edit message 	ptr ptr 
use message 	ckh count 
fixup message 	ckh 
squash message also 	count ckh 
interactive patch 	tsd fetch 
interactive amend signoff 	ckh mallocx 
edit flag 	ptr ckh 
quiet verbose verify 	insert ckh 
allow empty 	search 
dry run renew 	ptr ptr 
authorship post 	ckh count 
rewrite allow empty 	ckh count 
message untracked 	ckh search 
files arg force 	ckh ptr 
date ignore 	ptr 
submodule arg sign 	ckh search 
commit cleanup 	ckh memset 
arg sequencer use 	ckh iter 
include status 	ptr ckh 
show ignored status 	search ckh 
option include 	ptr 
assumed message 	ptr ckh 
opt arg unset 	search ckh 
buf err 	dallocx ckh 
list prefix pattern 	count ckh 
ret max 	count ckh 
prefix item list 	test 
current head 	implementation cuckoo 
opts refresh flags 	hashing indicates 
argc argv 	hash bucket 
prefix current head 	contains cells 
status pathspec 	indicates two 
refresh flags ret 	hash 
old index 	functions employed 
env index file 	original cuckoo 
prefix nowarn 	hashing algorithm 
sha current head 	described pagh 
buf hack 	rodler cuckoo 
buf errors 	hashing 
buf val author 	journal algorithms 
ident name 	generalization cuckoo 
email date author 	hashing discussed 
ident len 	erlingsson manasse 
date buf ident 	sherry cool 
date buf 	practical 
candidates candidate index 	alternative traditional 
file prefix 	hash tables 
current head author 	proceedings workshop 
ident statbuf 	distributed data 
committer ident commitable 	structures wdas 
hook arg 	santa 
hook arg clean 	clara january 
message contents 	implementation uses 
old display comment 	precisely two 
prefix ctx 	hash functions 
buffer ctx commit 	fewest work 
ident shown 	supporting 
saved color 	multiple hashes 
setting sha parent 	implementation burden 
diff flags 	reproduction figure 
index env start 	erlingsson shows 
eol tmpl 	approximate expected 
start name revs 	maximum 
commit buf 	load factors 
mailmap ctx name 	various configurations 
enc commit 	cells bucket 
show branch use 	hashes number 
deferred config 	cells per 
argc argv options 	bucket 
usage prefix 	chosen bucket 
current head argc 	fits one 
argv prefix 	cache line 
current head commitable 	bit systems 
index file 	use cuckoo 
slot slot name 	hashing 
slot argc 	respectively function 
argv prefix 	prototypes non 
sha builtin status 	functions search 
options user 	bucket key 
config xdg config 	cell number 
config exists 	found 
prefix sha initial 	size max 
commit rev 	otherwise search 
commit format junk 	table key 
sha head 	cell number 
pctx author ident 	found size 
committer ident 	max 
date status oldsha 	otherwise search 
newsha buf 	primary bucket 
proc argv code 	search secondary 
editor used 	bucket cycle 
index file name 	cells bucket 
hook env 	starting 
index args ret 	random position 
argc argv 	randomness avoids 
prefix builtin 	worst search 
commit options author 	overhead buckets 
ident index 	fill space 
file reflog msg 	available 
sha pptr 	bucket randomly 
statbuf current head 	evict item 
extra transaction 	find alternate 
err allow fast 	location item 
forward parent 	iteratively repeat 
saved errno exclude 	eviction 
gpgsig tail 	relocation procedure 
cfg strbuf setlen 	either success 
strbuf addch 	detection eviction 
strbuf addstr strbuf 	relocation bucket 
complete line 	cycle choose 
file exists git 	random 
path merge 	item within 
head file 	bucket evict 
exists git path 	critical correct 
cherry pick 	function without 
head file exists 	eventually evicting 
git path 	items 
status prepare gitmodules 	within bucket 
config git 	iteration would 
config determine whence 	possible stuck 
rollback file 	infinite loop 
rollback file rollback 	item hashes 
file commit 	indicated 
file commit file 	bucket swap 
rollback file 	cell key 
xcalloc common prefix 	data key 
overlay cache 	data evict 
free path match 	find alternate 
list insert 	bucket 
skip worktree report 	evicted item 
path error 	may tbucket 
free lstat 	bucket still 
cache die file 	item hashes 
cache discard 	indicate bucket 
cache memset parse 	however 
indirect die 	guaranteed eventually 
parse init desc 	escape bucket 
unpack trees 	iteration assuming 
exit refresh cache 	pseudo random 
die resolve 	item selection 
conflict parse pathspec 	randomness 
read cache 	would make 
preload die hold 	infinite looping 
locked index 	remote possibility 
refresh cache die 	reason never 
write locked 	trapped forever 
index die getenv 	two 
setenv file 	cases bucket 
path interactive die 	argbucket quickly 
setenv unsetenv 	detect eviction 
discard cache 	cycle terminate 
read cache file 	item evicted 
path update 	bucket 
main cache reopen 	another means 
file die 	least one 
write locked index 	item bucket 
die warning 	hashes indicate 
file path hold 	distinct buckets 
locked index 	check 
files cache refresh 	cycle insert 
cache die 	primary bucket 
update main cache 	insert secondary 
write locked 	bucket find 
index die file 	place item 
path hold 	via 
locked index refresh 	iterative eviction 
cache die 	relocation rebuild 
cache fully valid 	hash table 
update main 	scratch inserting 
cache write 	items old 
locked index die 	table 
rollback file 	possible though 
index file die 	unlikely given 
die list 	well behaved 
init list paths 	hashes table 
exit discard 	doubled order 
cache read cache 	create 
die hold 	usable table 
locked index files 	swap table 
refresh cache 	rebuilding failed 
update main cache 	back partially 
write locked 	rebuilt table 
index die hold 	possible 
file update 	though unlikely 
git path getpid 	given well 
create index 	behaved hashes 
files refresh cache 	table rebuild 
write locked 	fail oom 
index die 	error 
discard cache file 	isn worth 
path read 	propagating since 
cache sha status 	doesn prevent 
collect shortstatus 	future operations 
print porcelain print 	proceeding swap 
die status 	table 
print split ident 	rebuilding failed 
line die 	back partially 
strbuf addch strbuf 	rebuilt table 
addf setenv 	doesn really 
strbuf release strbuf 	matter find 
addch parse 	minimum 
date approxidate careful 	power large 
strbuf addf 	enough fit 
free xstrdup getenv 	minitems entries 
xstrdup getenv 	cuckoo hashing 
xstrdup getenv 	expected maximum 
find commit header 	load 
die split 	factor least 
ident line die 	conservative load 
ident xmemdupz 	factor typically 
ident xmemdupz strbuf 	allow mincells 
addch strbuf 	items fit 
strbuf addch strbuf 	without 
ident strbuf 	ever growing 
detach split ident 	table nothing 
line strlen 	necessary halve 
die ident xmemdupz 	table less 
ident xmemdupz 	full ignore 
parse force date 	error 
die ident 	due oom 
strbuf detach strbuf 	insert search 
addstr fmt 	ckh.h key 
ident split ident 	data ngrows 
export one 	nshrinks nshrinkfails 
export one 	ninserts 
export one free 	nrelocs prng 
free free 	state count 
memchr strchr strchr 	minbuckets curbuckets 
die determine 	hash keycomp 
author info run 	tab tsd 
commit hook 	ckh 
strcmp strbuf addstr 	minitems hash 
lookup commit 	keycomp tsd 
reference name die 	ckh ckh 
commit output 	ckh tabind 
encoding format commit 	key data 
message strbuf 	tsd 
addbuf strcmp isatty 	ckh key 
strbuf read 	data tsd 
die errno strbuf 	ckh searchkey 
read file 	key data 
die errno strstr 	ckh seachkey 
strbuf addstr 	key 
lookup commit 	data key 
reference name die 	hash key 
commit output 	hash typedefs 
encoding format commit 	allow easy 
message stat 	function pointer 
git path merge 	passing 
msg strbuf 	maintain counters 
read file git 	used idea 
path merge 	performance define 
msg die errno 	ckh count 
stat git 	print counter 
path squash msg 	values 
strbuf read 	ckh requires 
file git path 	ckh count 
squash msg 	define ckh 
die errno strbuf 	verbose ckh 
read file 	bucket 
die errno fopen 	cells cells 
writing git 	hash table 
path die 	bucket fit 
errno git path 	one bucket 
strbuf stripspace 	per cache 
append signoff ignore 	line 
non trailer 	jemalloc types 
fwrite die errno 	hash table 
adjust comment 	cell counters 
line strbuf release 	used idea 
strbuf addstr 	performance used 
git committer info 	pseudo 
status cut 	random number 
line status git 	generation total 
path status 	number items 
status cut line 	minimum current 
status status 	number hash 
split ident split 	table 
ident ident 	buckets ckh 
cmp status 	bucket cells 
author date interesting 	cells per 
status show 	bucket hash 
ident date date 	comparison functions 
mode committer 	hash 
ident sufficiently given 	table curbuckets 
status status 	buckets jemalloc 
run status read 	structs jemalloc 
cache die 	externs jemalloc 
sha strcmp index 	inlines cluster.c 
differs strbuf 	nodename 
release fclose merge 	flags node 
run status 	privdata mask 
fputs fputs fputs 	privdata mask 
fputs discard 	link type 
cache read cache 	nodename node 
update main 	request 
cache error run 	slot filter 
commit hook 	name master 
git path 	slave slot 
snprintf launch editor 	slot node 
git path 	slot max 
exit run commit 	slaves 
hook git 	bitmap pos 
path memchr strlen 	flags link 
starts isspace 	node delnode 
rest empty strbuf 	flags filename 
read file 	line maxline 
strbuf stripspace skip 	argc 
prefix strbuf 	argv master 
release rest empty 	start stop 
init revisions 	slot direction 
strbuf addf setup 	fsync content 
revisions read 	size fsync 
mailmap prepare revision 	filename 
walk die 	saveconf hard 
revision strbuf release 	node oldname 
format commit 	node link 
message clear 	link privdata 
mailmap strbuf detach 	mask cport 
die strcmp 	cfd 
strcmp strcmp die 	max cip 
lookup commit 	link key 
reference name die 	keylen nodename 
commit output 	flags node 
encoding logmsg reencode 	failing sender 
die parse 	node 
options finalize deferred 	maxtime node 
config strchr 	sender node 
find author nickname 	master slave 
die die 	remaining slaves 
die die die 	master slave 
die die 	okslaves 
die read commit 	nodename node 
message read 	retval delnode 
commit message die 	node name 
die strcmp 	node newname 
strcmp strcmp 	retval max 
strcmp strcmp die 	node 
handle untracked 	max epoch 
files arg die 	sender expire 
prepare index 	node nodeid 
run status rollback 	retval node 
index files 	failures needed 
strcasecmp strcasecmp strcasecmp 	quorum 
strcasecmp strcasecmp 	node port 
strcasecmp strcasecmp strcasecmp 	node port 
starts git 	norm hdr 
column config strcmp 	link count 
git config 	sender flags 
strcmp git config 	node 
strcmp git 	buf link 
config strcmp strcmp 	node link 
git config 	port sender 
colorbool strcmp 	sender config 
git config skip 	epoch slots 
prefix skip 	curmaster 
prefix parse status 	newmaster dirty 
slot config 	slots dirty 
error nonbool color 	slots count 
parse strcmp 	link hdr 
git config strcmp 	totlen type 
config error 	flags 
nonbool strcmp strcmp 	sender config 
strcmp error 	epoch sender 
git diff config 	count explen 
strcmp usage 	explen explen 
options status init 	explen explen 
config parse 	node 
options finalize colopts 	master sender 
finalize deferred 	master dirty 
config handle untracked 	slots failing 
files arg 	channel message 
parse pathspec 	channel len 
read cache preload 	message 
refresh index 	len reported 
hold locked index 	config epoch 
sha status 	link privdata 
collect update index 	mask link 
able shortstatus 	nwritten privdata 
print porcelain print 	mask 
die status 	buf nread 
print expand user 	hdr link 
path xdg 	readlen rcvbuflen 
config home file 	link msg 
exists file 	msglen buf 
exists free free 	len 
lookup commit 	node hdr 
die parse commit 	type totlen 
die strbuf 	offset master 
addstr format commit 	link type 
message format 	buf hdr 
commit message 	gossipcount 
strbuf cmp strbuf 	wanted totlen 
addstr strbuf 	freshnodes maxiterations 
addbuf percentquote author 	gossip target 
date interesting 	node local 
format commit message 	slave link 
strbuf addstr 	channel 
strbuf addbuf percentquote 	message buf 
strbuf release 	payload hdr 
committer ident sufficiently 	totlen channel 
given strbuf 	len message 
addstr strbuf addbuf 	len nodename 
percentquote strbuf 	buf 
addch strbuf addstr 	hdr link 
ident advice 	node buf 
strbuf release strbuf 	hdr channel 
release init 	message buf 
revisions setup revisions 	hdr totlen 
commit format 	node 
diff setup 	buf hdr 
done resolve strcmp 	totlen node 
skip prefix 	buf hdr 
log commit log 	totlen node 
commit strbuf 	request master 
release strcmp git 	request 
config pathname 	current epoch 
strcmp git config 	request config 
strcmp git 	epoch claimed 
config strcmp git 	slots force 
config git 	ack myoffset 
gpg config git 	rank 
status config 	master reason 
find hook start 	msg lastlog 
command snprintf 	time nolog 
sha hex sha 	fail time 
hex sigchain 	oldmaster data 
push write full 	age 
close sigchain 	auth age 
pop finish 	needed quorum 
command snprintf start 	manual failover 
run hook 	auth timeout 
end strcmp usage 	auth retry 
options status 	time 
init config sha 	newrank added 
lookup commit 	delay max 
die parse commit 	slaves okslaves 
die parse 	candidate node 
validate options dry 	orphaned update 
run commit 	state 
prepare index prepare 	orphaned masters 
commit rollback 	max slaves 
index files getenv 	slaves min 
commit list 	pong node 
insert commit list 	iteration handshake 
insert fopen 	timeout 
git path 	node old 
merge head die 	ping sent 
errno git 	link node 
path merge head 	delay okslaves 
strbuf getline 	fsync flags 
merge parent die 	bitmap 
commit list 	pos bit 
insert fclose strbuf 	bitmap pos 
release stat 	bit bitmap 
git path merge 	pos bit 
mode strbuf 	slot old 
read file git 	slot 
path merge 	old slot 
mode die errno 	slot slot 
strcmp reduce 	node state 
heads commit list 	reachable masters 
insert strbuf 	among minority 
reset strbuf read 	time 
file git 	first call 
path rollback 	time node 
index files die 	needed quorum 
strerror status 	rejoin delay 
truncate message cut 	update config 
line strbuf 	flag 
stripspace untouched rollback 	name redis 
index files 	node flags 
exit message empty 	table flags 
rollback index 	size nodeflag 
files exit read 	node start 
commit extra 	bit 
headers append merge 	filter node 
tag headers 	slot num 
commit extended rollback 	masters slot 
index files 	replylen node 
die strbuf release 	start bit 
free commit 	nested 
extra headers strchr 	elements nested 
strbuf setlen 	replylen port 
strbuf addch 	slot slots 
strbuf insert strlen 	del retval 
strbuf insert 	slot retval 
strlen transaction begin 	reply 
transaction update 	statestr slots 
transaction commit rollback 	fail myepoch 
index files 	info retval 
die transaction free 	key slot 
unlink git 	maxkeys slot 
path cherry pick 	numkeys 
head unlink 	keys takeover 
git path revert 	epoch hard 
head unlink 	payload buf 
git path merge 	crc len 
head unlink 	footer rdbver 
git path merge 	crc 
msg unlink 	dumpobj payload 
git path merge 	ttl payload 
mode unlink 	type replace 
git path 	obj host 
squash msg commit 	port timeout 
index files 	name 
die rerere run 	host port 
commit hook 	name copy 
index file init 	replace timeout 
copy notes 	dbid ttl 
rewrite copy note 	expireat newargv 
rewrite finish 	cmd 
copy notes rewrite 	payload may 
run rewrite 	retry write 
hook print summary 	error first 
strbuf release 	key num 
nada nada nada 	keys buf 
dateptr buf 	towrite 
buf strtoul stop 	nwritten buf 
buf format 	buf error 
commit parent 	target socket 
parent format commit 	error del 
parent parent 	idx cmd 
make sure shallows 	argv 
read hex 	argc hashslot 
sha clone shallow 	error code 
parent must 	firstkey multiple 
traverse real parents 	keys missing 
even unhide 	keys mcmd 
nothing topological sort 	margv 
support count 	margc keyindex 
number children emitted 	numkeys thiskey 
record author 	thisslot hashslot 
date commit author 	error code 
line malformed 	key slot 
author line malformed 	node 
date newer 	fopen server 
commits larger date 	log strerror 
first newer 	exit fstat 
commits larger 	fileno fclose 
date first performs 	zmalloc fgets 
place topological 	sdssplitargs 
sort list supplied 	strcasecmp strcasecmp 
rev sort 	strtoull strcasecmp 
graph order mark 	strtoull server 
clear indegree 	log sdsfreesplitres 
also record author 	cluster lookup 
dates needed 	node 
update indegree find 	create cluster 
tips tips 	node cluster 
nodes reachable node 	node strrchr 
list tips 	memcpy strlen 
serve starting work 	atoi strchr 
queue unfortunate 	strcasecmp 
initial tips need 	server strcasecmp 
shown order 	strcasecmp strcasecmp 
given revision traversal 	strcasecmp mstime 
machinery longer 	strcasecmp strcasecmp 
need commit 	strcasecmp server 
list parents enqueued 	panic 
emission children 	cluster lookup 
emitted thereby guaranteeing 	node create 
topological order 	cluster node 
children commit already 	cluster node 
emitted emit 	cluster node 
merge stuff remember 	slave 
update flag 	atoi mstime 
allocation input commits 	atoi mstime 
one twos 	strtoull strchr 
must parsed mark 	server atoi 
parents found 	cluster lookup 
merge stale mark 	node 
even result 	create cluster 
clean commit may 	node cluster 
ancestor another 	node strchr 
commit move commit 	atoi atoi 
end number 	atoi cluster 
commits independent 	slot 
collect result one 	sdsfreesplitres zfree 
commit descendant 	fclose server 
one elements commit 	log cluster 
list commit 	max epoch 
ancestor one references 	cluster max 
commit ancestor 	epoch 
reachable reference uniquify 	server log 
find end 	zfree fclose 
header dump whole 	exit cluster 
remainder buffer 	gen nodes 
dump whole remainder 	description sdscatprintf 
buffer could 	sdslen 
verify signature either 	open fstat 
omit tag 	sdsgrowzero memset 
validate integrator may 	write sdslen 
key signer 	sdslen fsync 
tag merging 	sdslen ftruncate 
later auditor may 	close 
auditing run 	sdsfree close 
verify buffer verify 	sdsfree cluster 
buffer buf 	save config 
len buf len 	server log 
size len 	exit open 
warn warning tag 	server 
unverified merge 	log strerror 
tag continuation simple 	flock server 
ascii worries 	log server 
count many high 	log strerror 
bits many 	close zmalloc 
bytes sequence must 	dict 
bytes longer 	create dict 
sequences result codepoints 	create memset 
beyond ffff 	cluster close 
guaranteed never exist 	slots cluster 
many bytes 	config exit 
place encoded 	cluster 
bits bottom compute 	load config 
valid range 	create cluster 
verify good continuation 	node server 
bytes reject 	log cluster 
codepoints range sequence 	node cluster 
length surrogates 	save 
utf cannot encoded 	config die 
utf fffe 	server log 
ffff guaranteed non 	exit listen 
characters anything 	port exit 
range fdd fdef 	create file 
verifies buffer 	server 
proper utf format 	panic zsl 
isn assumes 	create reset 
non utf characters 	manual failover 
latin conversion 	node slave 
know must range 	cluster node 
commitencoding utf 	master 
avoid reallocs 	replication unset 
headers note ordering 	master empty 
means exact 	cluster close 
merged different order 	slots reset 
parents different 	manual failover 
changeset even everything 	cluster 
stays person 	del slot 
date information comment 	dict safe 
check encoding 	iterator dict 
append commit end 	next dict 
commit list 	val cluster 
next starts pointing 	del 
variable holds 	node dict 
head empty commit 	release iterator 
list updated 	server log 
point next field 	sdsnewlen dict 
last item 	sdsfree random 
list commits appended 	hex 
usage example 	chars cluster 
commit list 	node server 
list commit list 	log cluster 
next list 	sleep zmalloc 
next commit list 	mstime sdsempty 
append next 	sdsempty 
next commit list 	file file 
append next 	sdsfree sdsfree 
commit list count 	close zfree 
list list 	unused unused 
inspect determine end 	unused anet 
log message 	tcp 
order find put 	accept server 
line ignored 	log anet 
trailing comment lines 	non block 
blank lines 	anet enable 
also traditional conflicts 	tcp delay 
block commented 	server 
use git commit 	log create 
amend existing 	cluster link 
commit forgot 	create file 
returns number bytes 	crc crc 
tail ignore 	crc zmalloc 
fed second parameter 	memcpy 
append signoff 	random hex 
first run comments 	chars mstime 
otherwise continuing 	memset memset 
pathname conflicts block 	list create 
previous trailing 	list free 
comment builtin git 	method 
commit copyright 	list rewind 
kristian gsberg krh 	list next 
redhat git 	mstime zmalloc 
commit junio hamano 	mstime list 
linus torvalds 	node tail 
real index used 	mstime 
commits message 	list rewind 
variables commit 	list next 
names take commit 	list del 
message authorship 	node list 
unspecified commit message 	rewind 
cleanup mode 	list next 
lines beginning shell 	list del 
comments leading 	node cluster 
trailing whitespaces empty 	node cleanup 
lines containing 	failure reports 
whitespaces editor used 	cluster 
whitespaces message 	node cleanup 
specified explicitly must 	failure reports 
come git 	list length 
config nothing nothing 	memmove zrealloc 
take paths 	node failed 
index named typically 	node 
head paths 	slave cluster 
match given pattern 	node slave 
list better 	sdsnewlen server 
valid pointer 	dict sdsfree 
fake one skip 	free cluster 
worktree already 	link 
reported error finish 	list release 
dying refresh 	zfree zfree 
flags contains refresh 	dict sdsnewlen 
quiet errors 	cluster del 
unmerged entries non 	slot dict 
non commit 	safe 
real index update 	iterator dict 
index necessary 	next dict 
write index real 	val cluster 
index still 	node del 
locked name locked 	failure report 
index file 	dict 
caller run hooks 	release iterator 
locked real 	free cluster 
index goes well 	node sdsnewlen 
commit real 	dict find 
index failure 	sdsfree dict 
rollback real index 	val 
commit name 	sdsnewlen server 
real index file 	log dict 
caller run 	sdsfree server 
hooks real index 	memcpy cluster 
create commit 	node dict 
index still need 	safe 
refresh index 	iterator dict 
commit find affected 	next dict 
paths real 	val dict 
index file update 	release iterator 
index given 	cluster max 
paths write index 	epoch 
real index 	cluster sleep 
still locked index 	server log 
file reset 	node master 
index head update 	node master 
index way 	memcmp cluster 
write index 	save 
index file name 	config die 
index file 	server log 
still locked caller 	dict safe 
run hooks 	iterator dict 
locked index create 	next dict 
commit goes 	integer 
well commit real 	val dict 
index failure 	dict key 
rollback real index 	dict release 
either rollback 	iterator sdsnewlen 
index checks barfs 	cluster blacklist 
author badly 	cleanup 
specified insert proper 	dict sdsdup 
subject line 	dict find 
commit message options 	dict integer 
content remaining 	val time 
cases modify 	sdsfree sdsnewlen 
message argument prepare 	cluster 
commit msg 	blacklist cleanup 
hook squash commit 	dict find 
used commit 	sdsfree node 
subject possibly hijacking 	timed node 
commit log 	failed cluster 
options reset hook 	node 
args tell 	failure reports 
real story ignore 	count node 
status display 	master server 
comment prefix need 	log mstime 
comments commit 	node master 
editmsg hints counter 	cluster 
productive commit 	send fail 
already started checks 	cluster sleep 
committer ident 	mstime server 
explicitly given cleanup 	node failed 
space never 	node slave 
fail come 	server 
fmt ident may 	log node 
fail sane 	slave cluster 
ident test know 	sleep node 
name mail 	master server 
pointers least valid 	log cluster 
enough tests 	sleep 
printing unless user 	dict safe 
explicitly request 	iterator dict 
submodule ignore mode 	next dict 
passing command 	val node 
line option ignore 	handshake strcasecmp 
changed submodule 	dict 
sha comparing index 	release iterator 
parent matter 	inet pton 
configured otherwise won 	inet pton 
commit submodules 	memset inet 
manually staged would 	ntop inet 
really confusing 	ntop 
reject attempt 	cluster handshake 
record non merge 	progress create 
empty commit 	cluster node 
without allow empty 	memcpy cluster 
cherry pick 	node ntohs 
may empty due 	cluster 
conflict resolution 	lookup node 
user okay read 	ntohs represent 
index pre 	cluster node 
commit hook could 	flags sdsempty 
updated write 	server log 
must invoke editor 	ntohs 
invoke run 	sdsfree cluster 
status check rest 	lookup node 
whitespace find 	node master 
message strbuf contains 	cluster node 
whitespace lines 	failure report 
see user edited 	server 
message editor 	log mark 
left intact 	node failing 
already initialized enumerate 	needed cluster 
needs propagated 	node del 
porcelain effect unspecified 	failure report 
sanity check 	server 
options oldsha newsha 	log strcasecmp 
nul hook 	ntohs free 
know editor launched 	cluster link 
end commit 	memcpy ntohs 
message options end 	cluster blacklist 
commit contents 	exists 
options ignore status 	cluster start 
everything writing 	handshake ntohs 
commit includes running 	anet peer 
hooks writing 	node strcmp 
trees interacting user 	memcpy free 
determine parents 	cluster 
commit message 	link server 
truncate message diff 	log node 
amending current 	slave replication 
head commit.c buf 	master node 
len save 	master cluster 
commit buffer commit 	node 
type sha 	slave cluster 
quiet obj sha 	sleep node 
sha name 	master server 
sha obj name 	log bitmap 
oid commit 	test bit 
buf tail dateptr 	count 
commit graft 	keys slot 
commit graft alloc 	cluster del 
commit graft 	slot cluster 
index table commit 	slot cluster 
graft table 	sleep server 
sha graft ignore 	log 
dups pos 	cluster master 
buf len 	cluster sleep 
graft entry size 	del keys 
graft file 	slot ntohl 
buf graft commit 	ntohs server 
graft prepared 	log 
graft file sha 	sdslen ntohs 
pos data 	ntohs ntohs 
ret sha pos 	ntohl ntohl 
buffer size 	cluster lookup 
buffer slab commit 	node node 
buffer size 	handshake 
commit sizep commit 	ntohu ntohu 
sizep ret 	cluster sleep 
size commit buffer 	ntohu mstime 
commit commit 	node slave 
sizep ret item 	server log 
buffer size 	server 
tail bufptr parent 	log anet 
pptr graft 	sock name 
entry len 	strcmp memcpy 
parent entry len 	server log 
parent parent 	cluster sleep 
item quiet missing 	create 
buffer size 	cluster node 
ret item commit 	node ntohs 
buffer subject 	cluster node 
eol item list 	cluster sleep 
list list 	cluster process 
head list item 	gossip 
list date 	section cluster 
date next list 	send ping 
list mark 	server log 
ret parents commit 	node handshake 
plist commit 	server log 
mark parents commit 	node 
mark list 	update address 
commit mark mark 	needed ntohs 
commit stack 	cluster sleep 
top item 	cluster del 
author date commit 	node cluster 
buffer ident 	rename 
ident line ident 	node server 
len date 	log cluster 
end date data 	sleep memcmp 
author date 	server log 
date date unused 	mstime free 
sort topological 	cluster 
order flags queue 	link cluster 
commit one 	sleep node 
twos queue result 	handshake node 
commit parents 	update address 
flags one twos 	needed ntohs 
list result 	cluster 
commit ret end 	sleep mstime 
bases cnt 	node timed 
work redundant filled 	cluster sleep 
index filled 	node failed 
common one 	clear node 
twos cleanup list 	failure 
rslt result 	needed memcmp 
cnt one twos 	cluster node 
one twos 	master cluster 
one two commit 	lookup node 
commit commit 	node master 
reference reference bases 	cluster 
commit reference 	del node 
heads tail num 	slots cluster 
head gpg 	sleep cluster 
sig header gpg 	node slave 
sig header 	cluster node 
len buf keyid 	slave 
sig inspos 	cluster sleep 
copypos bol eol 	node master 
len commit 	memcmp node 
payload signature 	master cluster 
size buffer signature 	update slots 
saw signature 	config 
line tail sig 	bitmap test 
next buf 	bit server 
line tail signature 	log cluster 
sig start 	send update 
sig end next 	node master 
parent tail 	node 
desc mergetag buf 	master cluster 
size len 	handle config 
commit sigc payload 	epoch collision 
signature ret 	cluster process 
parents tail parent 	gossip section 
buffer extra 	cluster 
commit exclude extra 	lookup node 
size buffer 	server log 
commit data extra 	mstime cluster 
free field 	sleep server 
len field 	log dict 
len exclude xlen 	size 
buffer size 	list length 
exclude line next 	ntohl ntohl 
eof eob 	create create 
buf extra next 	pubsub publish 
msg msg 	message decr 
len parents ret 	count 
author sign 	decr count 
commit tail result 	cluster send 
buf len 	failover auth 
offset max codepoint 	needed node 
bytes bad 	master cluster 
offset codepoint min 	sleep 
val max 	reset manual 
val buf pos 	failover mstime 
bad replace 	pause clients 
commit utf warn 	mstime server 
msg msg 	log ntohu 
len parents 	cluster 
ret author sign 	lookup node 
commit extra 	node slave 
result encoding utf 	cluster node 
buffer parent 	master cluster 
name obj commit 	sleep cluster 
oid desc 	update 
commit next list 	slots config 
format cur 	server log 
format last format 	free cluster 
msg key 	link unused 
len key len 	unused write 
line eol 	sdslen 
boc bol old 	server log 
conflicts block 	strerror handle 
next line deref 	link error 
tag parse 	sdsrange sdslen 
type lookup commit 	file unused 
reference gently 	unused 
lookup commit 	sdslen memcmp 
reference die hashcmp 	ntohl server 
warning sha 	log handle 
hex lookup create 	link error 
alloc commit 	ntohl read 
node type sha 	server 
committish lookup 	log strerror 
commit reference parse 	handle link 
commit memcmp 	error sdscatlen 
memcmp strtoul sha 	ntohl cluster 
pos commit 	process packet 
graft pos free 	sdsfree 
free alloc 	sdsempty sdslen 
grow memmove isspace 	create file 
xmalloc mult 	sdscatlen dict 
oid hex sha 	safe iterator 
hex error 	dict next 
free fopen 	dict 
strbuf getwholeline read 	val cluster 
graft line 	send message 
commit graft error 	dict release 
fclose strbuf 	iterator node 
release graft file 	slave memset 
read graft 	htons 
file repository shallow 	htons memcpy 
prepare commit 	memcpy memset 
graft commit graft 	memcpy htons 
pos commit 	htons htonu 
graft pos memmove 	htonu node 
define commit 	slave 
slab commit slab 	replication slave 
init buffer 	offset htonu 
slab buffer slab 	node master 
peek cached 	htonl dict 
commit buffer read 	size floor 
sha file 	dict 
die oid 	size zcalloc 
hex die oid 	mstime cluster 
hex buffer 	build message 
slab peek free 	hdr dict 
buffer slab 	random key 
peek free buffer 	dict 
slab peek 	val memcmp 
memcmp error oid 	memcpy htonl 
hex sha 	htonl memcpy 
hex error oid 	htons htons 
hex lookup 	htons htonl 
lookup commit graft 	cluster 
memcmp sha 	send message 
hex error oid 	zfree dict 
hex lookup 	safe iterator 
commit commit list 	dict next 
insert lookup 	dict val 
commit commit list 	node 
insert parse 	handshake node 
commit date 	slave cluster 
read sha file 	send ping 
error oid 	dict release 
hex free error 	iterator decoded 
oid hex 	decoded 
parse commit buffer 	sdslen sdslen 
commit buffer 	cluster build 
free parse commit 	message hdr 
die oid 	htonl htonl 
hex xmalloc commit 	htonl zmalloc 
list append 	memcpy 
pop commit commit 	memcpy sdslen 
list insert 	memcpy sdslen 
llist mergesort pop 	sdslen cluster 
commit parse 	send message 
commit commit list 	cluster broadcast 
insert date 	message 
commit list insert 	decr count 
commit list 	decr count 
insert clear 	zfree cluster 
commit marks pop 	build message 
commit clear 	hdr memcpy 
commit marks many 	cluster 
lookup commit 	broadcast message 
reference gently clear 	ntohl cluster 
commit marks 	build message 
free define commit 	hdr memcpy 
slab commit 	htonu memcpy 
buffer find commit 	cluster 
header split 	send message 
ident line strtoul 	ntohl cluster 
author date 	send publish 
slab unuse commit 	cluster build 
buffer author 	message hdr 
date slab author 	htonl 
date slab 	cluster broadcast 
commit list 	message cluster 
append prio queue 	build message 
put prio 	hdr htonl 
queue put queue 	cluster send 
nonstale prio 	message 
queue commit list 	cluster build 
insert date 	message hdr 
parse commit prio 	htonl cluster 
queue put 	send message 
clear prio queue 	ntohu ntohu 
commit list 	node 
insert parse commit 	slave server 
parse commit 	log server 
paint common pop 	log node 
commit commit 	master node 
list insert date 	failed node 
commit list 	master 
insert merge bases 	server log 
xcalloc xcalloc 	server log 
alloc parse 	node failed 
commit paint common 	server log 
clear commit 	mstime server 
marks clear commit 	log 
marks free 	mstime bitmap 
commit list memcpy 	test bit 
free free 	server log 
free merge bases 	cluster send 
many clear 	failover auth 
commit marks clear 	mstime 
commit marks 	server log 
many commit list 	server node 
count xcalloc 	slave replication 
free commit list 	slave offset 
clear commit 	time node 
marks clear commit 	failed 
marks many 	mstime time 
redundant commit list 	server log 
insert date 	node master 
free merge 	cluster node 
bases many merge 	master replication 
bases many 	unset 
merge bases many 	master cluster 
merge bases 	node slot 
parse commit parse 	bit cluster 
commit paint 	del slot 
common clear commit 	cluster slot 
marks clear 	cluster 
commit marks many 	update state 
free commit 	cluster save 
list merge bases 	config die 
many xcalloc 	cluster broadcast 
redundant commit list 	pong 
insert strstr 	reset manual 
signing key sign 	failover mstime 
buffer strbuf 	node master 
release strchrnul strbuf 	node failed 
insert strbuf 	mstime mstime 
insert strbuf 	cluster 
insert strbuf release 	log cant 
commit buffer 	failover mstime 
memchr starts strbuf 	random cluster 
strbuf unuse 	slave rank 
commit buffer memchr 	mstime server 
starts strbuf 	log 
merge remote read 	mstime replication 
sha file 	slave offset 
parse signature xcalloc 	cluster broadcast 
xstrdup free 	pong cluster 
parse commit check 	slave rank 
signature strbuf 	server 
release strbuf release 	log mstime 
handle tag 	cluster log 
strbuf addstr strbuf 	cant failover 
lines strbuf 	cluster log 
addch commit buffer 	cant failover 
read commit 	server 
extra header 	log cluster 
lines unuse commit 	request failover 
buffer read 	auth cluster 
commit extra headers 	sleep server 
strcmp free 	log server 
commit extra headers 	log 
memcmp memcmp 	cluster failover 
memcmp memcmp memcmp 	replace master 
strlen memcmp 	cluster log 
memchr strbuf strbuf 	cant failover 
detach strbuf 	node failed 
reset strchr standard 	node 
header field 	timed dict 
excluded header field 	safe iterator 
xcalloc xmemdupz 	dict next 
strbuf strbuf detach 	dict val 
free free 	node slave 
free append 	node 
merge tag headers 	failed node 
commit extended 	master cluster 
free commit extra 	count non 
headers find 	failing slaves 
invalid utf strbuf 	mstime memcmp 
strbuf insert 	dict 
sha type memchr 	release iterator 
error encoding 	mstime server 
utf strbuf init 	log cluster 
strbuf addf 	master clients 
sha hex pop 	paused clients 
commit strbuf 	paused 
addf oid hex 	mstime server 
git author 	log reset 
info strbuf addf 	manual failover 
strbuf addf 	replication slave 
git committer info 	offset server 
strbuf addf 	log 
extra header 	dict safe 
strbuf addch strbuf 	iterator dict 
verify utf 	next dict 
sign commit write 	val node 
sha file 	handshake cluster 
strbuf release sha 	del 
parse peel 	node anet 
type xmalloc strdup 	tcp non 
xmalloc oid 	block bind 
hex strlen strchrnul 	connect mstime 
strncmp memchr 	server log 
starts nada nada 	create 
nada dateptr 	cluster link 
buf buf strtoul 	create file 
stop buf 	cluster send 
format commit parent 	ping server 
parent format 	log dict 
commit parent parent 	release 
make sure 	iterator dict 
shallows read 	random key 
hex sha clone 	dict val 
shallow parent 	server log 
must traverse real 	cluster send 
parents even 	ping 
unhide nothing topological 	dict safe 
sort support 	iterator dict 
count number children 	next dict 
emitted record 	val mstime 
author date commit 	node slave 
author line 	node 
malformed author line 	master node 
malformed date 	failed cluster 
newer commits larger 	count non 
date first 	failing slaves 
newer commits larger 	node slave 
date first 	free 
performs place topological 	cluster link 
sort list 	cluster send 
supplied rev 	ping node 
sort graph order 	master cluster 
mark clear 	send ping 
indegree also record 	server 
author dates 	log dict 
needed update indegree 	release iterator 
find tips 	node slave 
tips nodes reachable 	node addr 
node list 	replication master 
tips serve starting 	manual 
work queue 	failover check 
unfortunate initial tips 	timeout node 
need shown 	slave cluster 
order given revision 	handle manual 
traversal machinery 	failover cluster 
longer need commit 	handle 
list parents 	slave failover 
enqueued emission 	cluster handle 
children emitted thereby 	slave migration 
guaranteeing topological 	cluster update 
order children commit 	state cluster 
already emitted 	handle 
emit merge stuff 	slave failover 
remember update 	cluster update 
flag allocation input 	state cluster 
commits one 	save config 
twos must parsed 	die bitmap 
mark parents 	test 
found merge stale 	bit bitmap 
mark even 	bit bitmap 
result clean commit 	test bit 
may ancestor 	bitmap clear 
another commit move 	bit bitmap 
commit end 	test 
number commits independent 	bit cluster 
collect result 	node slot 
one commit 	bit server 
descendant one elements 	cluster node 
commit list 	clear slot 
commit ancestor one 	bit 
references commit 	cluster node 
ancestor reachable reference 	slot bit 
uniquify find 	cluster del 
end header dump 	slot memset 
whole remainder 	memset mstime 
buffer dump whole 	node 
remainder buffer 	master mstime 
could verify signature 	dict safe 
either omit 	iterator dict 
tag validate integrator 	next dict 
may key 	val node 
signer tag merging 	master 
later auditor 	dict release 
may auditing run 	iterator mstime 
verify buffer 	node master 
verify buffer 	mstime server 
buf len buf 	log node 
len size 	slave 
len warn warning 	dict size 
tag unverified 	count keys 
merge tag continuation 	slot server 
simple ascii 	log cluster 
worries count many 	slot server 
high bits 	log 
many bytes sequence 	cluster save 
must bytes 	config die 
longer sequences result 	server server 
codepoints beyond 	node master 
ffff guaranteed never 	cluster close 
exist many 	slots 
bytes place encoded 	cluster node 
bits bottom 	slave cluster 
compute valid range 	node slave 
verify good 	replication master 
continuation bytes 	reset manual 
reject codepoints range 	failover 
sequence length 	sdscat sdscat 
surrogates utf cannot 	sds incr 
encoded utf 	len sdscatprintf 
fffe ffff guaranteed 	sdsempty represent 
non characters 	cluster node 
anything range fdd 	flags 
fdef verifies 	sdscatprintf sdscatlen 
buffer proper utf 	sdscatprintf cluster 
format isn 	node slot 
assumes non utf 	bit sdscatprintf 
characters latin 	sdscatprintf sdscatprintf 
conversion know must 	sdscatprintf 
range commitencoding 	sdsempty dict 
utf avoid reallocs 	safe iterator 
headers note 	dict next 
ordering means 	dict val 
exact merged different 	cluster gen 
order parents 	node 
different changeset even 	description sdscatsds 
everything stays 	sdsfree sdscatlen 
person date information 	dict release 
comment check 	iterator reply 
encoding append commit 	error deferred 
end commit 	multi 
list next starts 	bulk length 
pointing variable 	dict safe 
holds head empty 	iterator dict 
commit list 	next dict 
updated point next 	val node 
field last 	master 
item list commits 	cluster node 
appended usage 	slot bit 
example commit list 	deferred multi 
list commit 	bulk length 
list next 	reply reply 
list next commit 	reply 
list append 	reply reply 
next next commit 	multi bulk 
list append 	len reply 
next commit list 	bulk reply 
count list 	reply bulk 
list inspect determine 	buffer 
end log 	node failed 
message order find 	reply multi 
put line 	bulk len 
ignored trailing comment 	reply bulk 
lines blank 	reply reply 
lines also traditional 	bulk 
conflicts block 	buffer deferred 
commented use git 	multi bulk 
commit amend 	length dict 
existing commit forgot 	release iterator 
returns number 	deferred multi 
bytes tail 	bulk 
ignore fed second 	length reply 
parameter append 	error strcasecmp 
signoff first run 	reply error 
comments otherwise 	format cluster 
continuing pathname conflicts 	start handshake 
block previous 	reply 
trailing comment builtin 	error format 
git commit 	reply strcasecmp 
copyright kristian gsberg 	cluster gen 
krh redhat 	nodes description 
git commit junio 	create reply 
hamano linus 	bulk 
torvalds real index 	decr count 
used commits 	strcasecmp reply 
message variables commit 	bulk buffer 
names take 	strcasecmp cluster 
commit message authorship 	reply multi 
unspecified commit 	bulk 
message cleanup 	slots strcasecmp 
mode lines beginning 	dict size 
shell comments 	reply error 
leading trailing whitespaces 	cluster del 
empty lines 	node slots 
containing whitespaces editor 	cluster 
used whitespaces 	sleep reply 
message specified explicitly 	strcasecmp strcasecmp 
must come 	zmalloc strcasecmp 
git config nothing 	memset slot 
nothing take 	reply zfree 
paths index named 	reply 
typically head 	error format 
paths match given 	zfree reply 
pattern list 	error format 
better valid pointer 	zfree reply 
fake one 	error format 
skip worktree already 	zfree 
reported error 	cluster del 
finish dying 	slot cluster 
refresh flags contains 	slot server 
refresh quiet 	info zfree 
errors unmerged entries 	cluster sleep 
non non 	reply 
commit real index 	strcasecmp node 
update index 	slave reply 
necessary write index 	error slot 
real index 	reply strcasecmp 
still locked name 	reply error 
locked index 	format 
file caller run 	cluster lookup 
hooks locked 	node reply 
real index goes 	error format 
well commit 	strcasecmp reply 
real index failure 	error format 
rollback real 	cluster 
index commit 	lookup node 
name real index 	reply error 
file caller 	format strcasecmp 
run hooks real 	strcasecmp cluster 
index create 	lookup node 
commit index still 	reply 
need refresh 	error format 
index commit find 	count keys 
affected paths 	slot reply 
real index file 	error format 
update index 	count keys 
given paths write 	slot 
index real 	cluster bump 
index still locked 	config epoch 
index file 	without consensus 
reset index head 	server log 
update index 	cluster del 
way write index 	slot 
index file 	cluster slot 
name index 	reply error 
file still locked 	cluster sleep 
caller run 	reply strcasecmp 
hooks locked index 	cluster bump 
create commit 	config 
goes well commit 	epoch without 
real index 	consensus sdscatprintf 
failure rollback real 	sdsempty reply 
index either 	sds strcasecmp 
rollback index checks 	node failed 
barfs author 	node 
badly specified insert 	timed node 
proper subject 	slave sdscatprintf 
line commit message 	sdsempty dict 
options content 	size reply 
remaining cases modify 	sds sdscatprintf 
message argument 	sdsempty 
prepare commit msg 	sdslen reply 
hook squash 	sds reply 
commit used 	strcasecmp cluster 
commit subject possibly 	save config 
hijacking commit 	reply reply 
log options reset 	error 
hook args 	format strerror 
tell real story 	strcasecmp reply 
ignore status 	key hash 
display comment prefix 	slot sdslen 
need comments 	strcasecmp reply 
commit editmsg hints 	reply 
counter productive 	error reply 
commit already started 	count keys 
checks committer 	slot strcasecmp 
ident explicitly given 	reply reply 
cleanup space 	reply error 
never fail come 	zmalloc 
fmt ident 	keys slot 
may fail sane 	reply multi 
ident test 	bulk len 
know name 	reply bulk 
mail pointers least 	zfree strcasecmp 
valid enough 	cluster 
tests printing unless 	lookup node 
user explicitly 	reply error 
request submodule ignore 	format reply 
mode passing 	error node 
command line option 	slave reply 
ignore changed 	error 
submodule sha comparing 	cluster blacklist 
index parent 	node cluster 
matter configured otherwise 	del node 
won commit 	cluster sleep 
submodules manually staged 	reply strcasecmp 
would really 	cluster 
confusing reject attempt 	lookup node 
record non 	reply error 
merge empty 	format reply 
commit without allow 	error node 
empty cherry 	slave reply 
pick may empty 	error 
due conflict 	node master 
resolution user okay 	dict size 
read index 	reply error 
pre commit hook 	cluster master 
could updated 	cluster sleep 
write must invoke 	reply 
editor invoke 	strcasecmp cluster 
run status check 	lookup node 
rest whitespace 	reply error 
find message strbuf 	format node 
contains whitespace 	slave reply 
lines see user 	error 
edited message 	reply multi 
editor left intact 	bulk len 
already initialized 	cluster gen 
enumerate needs 	node description 
propagated porcelain effect 	reply bulk 
unspecified sanity 	sdsfree 
check options oldsha 	strcasecmp cluster 
newsha nul 	lookup node 
hook know editor 	reply error 
launched end 	format reply 
commit message options 	cluster node 
end commit 	failure 
contents options ignore 	reports count 
status everything 	strcasecmp strcasecmp 
writing commit includes 	strcasecmp reply 
running hooks 	node master 
writing trees interacting 	reply error 
user determine 	reply 
parents commit message 	error node 
truncate message 	failed reply 
diff amending current 	error reset 
head builtin 	manual failover 
commit usage 	mstime server 
builtin status usage 	log 
ident advice 	cluster bump 
noconfig ident advice 	config epoch 
config empty 	without consensus 
amend advice empty 	cluster failover 
cherry pick 	replace master 
advice empty cherry 	server 
pick advice 	log server 
single empty cherry 	log cluster 
pick advice 	send start 
multi use message 	reply strcasecmp 
buffer commit 	reply reply 
editmsg index logfile 	error 
force author 	format dict 
file author message 	size reply 
author message 	error reply 
buffer edit message 	error server 
use message 	log cluster 
fixup message 	sleep 
squash message also 	reply strcasecmp 
interactive patch 	strcasecmp strcasecmp 
interactive amend signoff 	reply node 
edit flag 	master dict 
quiet verbose verify 	size reply 
allow empty 	error 
dry run renew 	cluster reset 
authorship post 	reply reply 
rewrite allow empty 	error rio 
message untracked 	init buffer 
files arg force 	sdsempty server 
date ignore 	rdb 
submodule arg sign 	save type 
commit cleanup 	server rdb 
arg sequencer use 	save sdscatlen 
include status 	crc sdslen 
show ignored 	memrev ifbe 
status option include 	sdscatlen 
assumed message 	crc memrev 
opt arg unset 	ifbe memcmp 
buf err 	lookup key 
list prefix pattern 	read reply 
ret max 	create 
prefix item list 	dump payload 
current head 	create reply 
opts refresh flags 	bulk decr 
argc argv 	count strcasecmp 
prefix current head 	reply lookup 
status pathspec 	key 
refresh flags ret 	write reply 
old index 	reply reply 
env index file 	error verify 
prefix nowarn 	dump payload 
sha current head 	sdslen reply 
buf hack 	error 
buf errors 	rio init 
buf val author 	buffer rdb 
ident name 	load type 
email date author 	rdb load 
ident len 	reply error 
date buf ident 	expire 
date buf 	mstime signal 
candidates candidate index 	modified key 
file prefix 	reply sdsempty 
current head author 	sdscatlen sdslen 
ident statbuf 	sdscatlen sdscatlen 
committer ident commitable 	sdslen 
hook arg 	dict fetch 
hook arg clean 	sdsfree dict 
message contents 	size dict 
old display comment 	random key 
prefix ctx 	dict val 
buffer ctx commit 	close 
ident shown 	zfree dict 
saved color 	dict key 
setting sha parent 	anet tcp 
diff flags 	non block 
index env start 	connect atoi 
eol tmpl 	sdsfree 
start name revs 	reply error 
commit buf 	format anet 
mailmap ctx name 	enable tcp 
enc commit 	delay wait 
show branch use 	sdsfree reply 
deferred config 	sds 
argc argv options 	sdsnew close 
usage prefix 	zmalloc dict 
current head argc 	sdsempty sdscatlen 
argv prefix 	sdslen sdscatlen 
current head commitable 	sdscatlen sdslen 
index file 	dict 
slot slot name 	fetch sdsfree 
slot argc 	close zfree 
argv prefix 	dict sdsfree 
sha builtin status 	dict safe 
options user 	iterator dict 
config xdg config 	next 
config exists 	dict val 
prefix sha initial 	close zfree 
commit rev 	dict dict 
commit format junk 	key dict 
sha head 	release iterator 
pctx author ident 	strcasecmp 
committer ident 	strcasecmp strcasecmp 
date status oldsha 	sdslen reply 
newsha buf 	error reply 
proc argv code 	reply reply 
editor used 	zrealloc zrealloc 
index file name 	lookup 
hook env 	key read 
index args ret 	zfree zfree 
argc argv 	reply sds 
prefix builtin 	sdsnew migrate 
commit options author 	socket zfree 
ident index 	zfree 
file reflog msg 	rio init 
sha pptr 	buffer sdsempty 
statbuf current head 	server info 
extra transaction 	rio write 
err allow fast 	bulk count 
forward parent 	server 
saved errno exclude 	info rio 
gpgsig tail 	write bulk 
cfg strbuf setlen 	server info 
strbuf addch 	rio write 
strbuf addstr strbuf 	bulk expire 
complete line 	mstime 
file exists git 	server info 
path merge 	rio write 
head file 	bulk count 
exists git path 	server info 
cherry pick 	rio write 
head file exists 	bulk 
git path 	server info 
status prepare gitmodules 	rio write 
config git 	bulk server 
config determine whence 	info sds 
rollback file 	encoded server 
rollback file rollback 	info 
file commit 	rio write 
file commit file 	bulk sdslen 
rollback file 	server info 
xcalloc common prefix 	rio write 
overlay cache 	bulk create 
free path match 	dump 
list insert 	payload server 
skip worktree report 	info rio 
path error 	write bulk 
free lstat 	sdslen sdsfree 
cache die file 	server info 
cache discard 	rio 
cache memset parse 	write bulk 
indirect die 	sdslen sync 
parse init desc 	write sync 
unpack trees 	read line 
exit refresh cache 	zmalloc sync 
die resolve 	read 
conflict parse pathspec 	line reply 
read cache 	error format 
preload die hold 	signal modified 
locked index 	key incr 
refresh cache die 	count create 
write locked 	replace 
index die getenv 	client command 
setenv file 	vector zfree 
path interactive die 	reply sdsfree 
setenv unsetenv 	zfree zfree 
discard cache 	zfree migrate 
read cache file 	close 
path update 	socket sdsfree 
main cache reopen 	migrate close 
file die 	socket zfree 
write locked index 	zfree zfree 
die warning 	reply sds 
file path hold 	sdscatprintf 
locked index 	sdsempty reply 
files cache refresh 	error reply 
cache die 	reply error 
update main cache 	reply reply 
write locked 	keys command 
index die file 	key 
path hold 	hash slot 
locked index refresh 	sdslen keys 
cache die 	free result 
cache fully valid 	equal objects 
update main 	keys free 
cache write 	result 
locked index die 	lookup key 
rollback file 	read keys 
index file die 	free result 
die list 	node slave 
init list paths 	reply sds 
exit discard 	sdsnew 
cache read cache 	reply sds 
die hold 	sdsnew reply 
locked index files 	sds sdsnew 
refresh cache 	reply sds 
update main cache 	sdsnew reply 
write locked 	sds 
index die hold 	sdscatprintf sdsempty 
file update 	server panic 
git path getpid 	cluster redirect 
create index 	client dict 
files refresh 	iterator dict 
cache write locked 	next 
index die 	dict key 
discard cache file 	key hash 
path read 	slot sdslen 
cache sha status 	cluster redirect 
collect shortstatus 	client cluster 
print porcelain print 	redirect 
die status 	client dict 
print split ident 	release iterator 
line die 	redis cluster 
strbuf addch strbuf 	implementation copyright 
addf setenv 	salvatore sanfilippo 
strbuf release strbuf 	antirez 
addch parse 	gmail dot 
date approxidate careful 	rights reserved 
strbuf addf 	redistribution use 
free xstrdup getenv 	source binary 
xstrdup getenv 	forms without 
xstrdup getenv 	modification 
find commit header 	permitted provided 
die split 	following conditions 
ident line die 	met redistributions 
ident xmemdupz 	source code 
ident xmemdupz strbuf 	must retain 
addch strbuf 	copyright 
strbuf addch strbuf 	notice list 
ident strbuf 	conditions following 
detach split ident 	disclaimer redistributions 
line strlen 	binary form 
die ident xmemdupz 	must reproduce 
ident xmemdupz 	copyright 
parse force date 	notice list 
die ident 	conditions following 
strbuf detach strbuf 	disclaimer documentation 
addstr fmt 	materials provided 
ident split ident 	distribution neither 
export one 	name 
export one 	redis names 
export one free 	contributors may 
free free 	used endorse 
memchr strchr strchr 	promote products 
die determine 	derived software 
author info run 	without 
commit hook 	specific prior 
strcmp strbuf addstr 	written permission 
lookup commit 	software provided 
reference name die 	copyright holders 
commit output 	contributors express 
encoding format commit 	implied 
message strbuf 	warranties including 
addbuf strcmp isatty 	limited implied 
strbuf read 	warranties merchantability 
die errno strbuf 	fitness particular 
read file 	purpose disclaimed 
die errno strstr 	shall 
strbuf addstr 	copyright owner 
lookup commit 	contributors liable 
reference name die 	direct indirect 
commit output 	incidental special 
encoding format commit 	exemplary consequential 
message stat 	damages 
git path merge 	including limited 
msg strbuf 	procurement substitute 
read file git 	goods services 
path merge 	loss use 
msg die errno 	data profits 
stat git 	business 
path squash msg 	interruption however 
strbuf read 	caused theory 
file git path 	liability whether 
squash msg 	contract strict 
die errno strbuf 	liability tort 
read file 	including 
die errno 	negligence otherwise 
fopen writing git 	arising way 
path die 	use software 
errno git path 	even advised 
strbuf stripspace 	possibility damage 
append signoff ignore 	reference 
non trailer 	handy make 
fwrite die errno 	code clear 
adjust comment 	always points 
line strbuf release 	server cluster 
strbuf addstr 	cluster node 
git committer info 	represents 
status cut 	node initialization 
line status git 	load cluster 
path status 	config filename 
status cut line 	file exist 
status status 	zero length 
split ident split 	may 
ident ident 	happen nodes 
cmp status 	conf file 
author date interesting 	create zero 
status show 	length one 
ident date date 	sake locking 
mode committer 	already 
ident sufficiently given 	exist err 
status status 	returned configuration 
run status read 	loaded file 
cache die 	returned check 
sha strcmp index 	file zero 
differs strbuf 	length 
release fclose merge 	err signal 
run status 	write config 
fputs fputs fputs 	parse file 
fputs discard 	note single 
cache read cache 	lines cluster 
update main 	config 
cache error run 	file really 
commit hook 	include hash 
git path 	slots node 
snprintf launch editor 	means worst 
git path 	possible half 
exit run commit 	redis 
hook git 	slots present 
path memchr strlen 	single line 
starts isspace 	possibly importing 
rest empty strbuf 	migrating state 
read file 	together node 
strbuf stripspace skip 	sender 
prefix strbuf 	receiver simplify 
release rest empty 	allocate cluster 
init revisions 	slots bytes 
strbuf addf setup 	per line 
revisions read 	skip blank 
mailmap prepare revision 	lines 
walk die 	created either 
revision strbuf release 	users manually 
format commit 	editing nodes 
message clear 	conf config 
mailmap strbuf detach 	writing process 
die strcmp 	stopped 
strcmp strcmp die 	truncate call 
lookup commit 	split line 
reference name die 	arguments processing 
commit output 	handle special 
encoding logmsg reencode 	vars line 
die parse 	pretend 
options finalize deferred 	last line 
config strchr 	even actually 
find author nickname 	generated redis 
die die 	regular config 
die die die 	lines least 
die die 	eight 
die read commit 	fields create 
message read 	node exist 
commit message die 	address port 
die strcmp 	parse flags 
strcmp strcmp 	nothing master 
strcmp strcmp die 	master 
handle untracked 	populate master 
files arg die 	slave list 
prepare index 	ping sent 
run status rollback 	pong received 
index files 	timestamps config 
strcasecmp strcasecmp strcasecmp 	epoch 
strcasecmp strcasecmp 	node populate 
strcasecmp strcasecmp strcasecmp 	hash slots 
starts git 	served instance 
column config strcmp 	handle migrating 
git config 	importing slots 
strcmp git config 	either 
strcmp git 	config sanity 
config strcmp strcmp 	check something 
git config 	never happen 
colorbool strcmp 	current epoch 
git config skip 	smaller max 
prefix skip 	epoch 
prefix parse status 	found nodes 
slot config 	configuration however 
error nonbool color 	handle form 
parse strcmp 	protection manual 
git config strcmp 	editing critical 
config error 	files 
nonbool strcmp strcmp 	cluster node 
strcmp error 	configuration exactly 
git diff config 	cluster nodes 
strcmp usage 	output function 
options status init 	writes node 
config parse 	config 
options finalize colopts 	returns error 
finalize deferred 	returned note 
config handle untracked 	need write 
files arg 	file atomic 
parse pathspec 	way point 
read cache preload 	view 
refresh index 	posix filesystem 
hold locked index 	semantics server 
sha status 	stopped crashes 
collect update index 	write end 
able shortstatus 	either old 
print porcelain print 	file 
die status 	one since 
print expand user 	full payload 
path xdg 	write available 
config home file 	use single 
exists file 	write write 
exists free free 	whole 
lookup commit 	file pre 
die parse commit 	existing file 
die strbuf 	bigger pad 
addstr format commit 	payload newlines 
message format 	anyway ignored 
commit message 	truncate 
strbuf cmp strbuf 	file afterward 
addstr strbuf 	nodes description 
addbuf percentquote author 	concatenate vars 
date interesting 	directive save 
format commit message 	current epoch 
strbuf addstr 	last 
strbuf addbuf percentquote 	vote epoch 
strbuf release 	pad payload 
committer ident sufficiently 	existing file 
given strbuf 	length greater 
addstr strbuf addbuf 	truncate file 
percentquote strbuf 	needed 
addch strbuf addstr 	padding garbage 
ident advice 	ftruncate failing 
strbuf release strbuf 	critical error 
release init 	cluster config 
revisions setup revisions 	flock leaks 
commit format 	file 
diff setup 	descritor used 
done resolve strcmp 	acquire file 
skip prefix 	locked forever 
log commit log 	works always 
commit strbuf 	update nodes 
release strcmp git 	conf 
config pathname 	version place 
strcmp git config 	reopening file 
strcmp git 	writing place 
config strcmp git 	later adjusting 
config git 	length ftruncate 
gpg config git 	success 
status config 	returned otherwise 
find hook start 	error logged 
command snprintf 	function returns 
sha hex sha 	err signal 
hex sigchain 	acquired flock 
push write 	exist 
full close sigchain 	solaris fcntl 
pop finish 	solution won 
command snprintf start 	help constantly 
run hook 	open file 
end strcmp usage 	release locks 
options status 	anyway 
init config sha 	need open 
lookup commit 	file way 
die parse commit 	created exist 
die parse 	otherwise race 
validate options dry 	condition processes 
run commit 	acquired 
prepare index prepare 	leak closing 
commit rollback 	retain file 
index files getenv 	process exists 
commit list 	sun cluster 
insert commit list 	config file 
insert fopen 	make 
git path 	sure every 
merge head die 	node uses 
errno git 	nodes conf 
path merge head 	load create 
strbuf getline 	nodes configuration 
merge parent die 	configuration 
commit list 	found use 
insert fclose strbuf 	random name 
release stat 	provided create 
git path merge 	cluster node 
mode strbuf 	function 
read file git 	need listening 
path merge 	tcp port 
mode die errno 	cluster messaging 
strcmp reduce 	needs port 
heads commit list 	sanity check 
insert strbuf 	handshake 
reset strbuf read 	port check 
file git 	triggered late 
path rollback 	stop trying 
index files die 	use high 
strerror status 	cluster port 
truncate message cut 	number 
line strbuf 	slots keys 
stripspace untouched rollback 	map sorted 
index files 	init port 
exit message empty 	listening port 
rollback index 	need discover 
files exit read 	address 
commit extra 	via meet 
headers append merge 	messages reset 
tag headers 	node performing 
commit extended rollback 	soft hard 
index files 	reset nodes 
die strbuf release 	forget 
free commit 	assigned open 
extra headers strchr 	slots released 
strbuf setlen 	node slave 
strbuf addch 	turns master 
strbuf insert strlen 	hard reset 
strbuf insert 	node 
strlen transaction begin 	generated hard 
transaction update 	reset current 
transaction commit rollback 	epoch config 
index files 	epoch configuration 
die transaction free 	saved cluster 
unlink git 	state 
path cherry pick 	updated node 
head unlink 	slave whole 
git path revert 	data flushed 
head unlink 	away turn 
git path merge 	master close 
head unlink 	slots 
git path merge 	reset manual 
msg unlink 	failover state 
git path 	unassign slots 
merge mode unlink 	forget nodes 
git path 	hard reset 
squash msg commit 	epochs 
index files 	change node 
die rerere run 	change node 
commit hook 	need old 
index file init 	name nodes 
copy notes 	table change 
rewrite copy note 	back 
rewrite finish 	name make 
copy notes rewrite 	sure persist 
run rewrite 	config update 
hook print summary 	state cluster 
strbuf release 	communication link 
nada nada nada 	free 
dateptr buf 	cluster link 
buf strtoul stop 	free associated 
buf format 	node course 
commit parent 	function make 
parent format commit 	sure original 
parent parent 	node 
make sure shallows 	associated link 
read hex 	link field 
sha clone shallow 	server starting 
parent must 	accept cluster 
traverse real parents 	connections update 
even unhide 	messages 
nothing topological sort 	may interact 
support count 	database content 
number children emitted 	use non 
record author 	blocking cluster 
date commit author 	messages create 
line malformed 	link 
author line malformed 	use handle 
date newer 	connection gets 
commits larger date 	passed readable 
first newer 	handler data 
commits larger 	available initiallly 
date first performs 	link 
place topological 	node pointer 
sort list supplied 	know node 
rev sort 	right node 
graph order mark 	references know 
clear indegree 	node identity 
also record author 	key 
dates needed 	space handling 
update indegree find 	hash slots 
tips tips 	hash slot 
nodes reachable node 	given key 
list tips 	obtained least 
serve starting work 	significant 
queue unfortunate 	bits crc 
initial tips need 	key however 
shown order 	key contains 
given revision traversal 	pattern part 
machinery longer 	hashed may 
need commit 	useful 
list parents enqueued 	future force 
emission children 	certain keys 
emitted thereby guaranteeing 	node assuming 
topological order 	resharding progress 
children commit already 	start end 
emitted emit 	indexes 
merge stuff remember 	hash whole 
update flag 	key found 
allocation input commits 	check corresponding 
one twos 	nothing betweeen 
must parsed mark 	hash whole 
parents found 	key 
merge stale mark 	right hash 
even result 	middle cluster 
clean commit may 	node api 
ancestor another 	create cluster 
commit move commit 	node specified 
end number 	flags 
commits independent 	nodename considered 
collect result one 	first handshake 
commit descendant 	random node 
one elements commit 	name assigned 
list commit 	node later 
ancestor one references 	receive 
commit ancestor 	first pong 
reachable reference uniquify 	node created 
find end 	returned user 
header dump whole 	automatically added 
remainder buffer 	nodes hash 
dump whole remainder 	table 
buffer could 	function called 
verify signature either 	every time 
omit tag 	failure report 
validate integrator may 	node side 
key signer 	effect populate 
tag merging 	fail 
later auditor may 	reports list 
auditing run 	update timestamp 
verify buffer verify 	existing report 
buffer buf 	failing node 
len buf len 	failure state 
size len 	according 
warn warning tag 	sender node 
unverified merge 	function returns 
tag continuation simple 	updates timestamp 
ascii worries 	existing failure 
count many high 	report sender 
bits many 	returned 
bytes sequence must 	failure report 
bytes longer 	created failure 
sequences result codepoints 	report sender 
beyond ffff 	already exists 
guaranteed never exist 	update timestamp 
many bytes 	otherwise 
place encoded 	create report 
bits bottom compute 	failure reports 
valid range 	old old 
verify good continuation 	means reasonably 
bytes reject 	older node 
codepoints range sequence 	timeout 
length surrogates 	note anyway 
utf cannot encoded 	node flagged 
utf fffe 	fail need 
ffff guaranteed non 	local pfail 
characters anything 	state least 
range fdd fdef 	older 
verifies buffer 	node timeout 
proper utf format 	trust number 
isn assumes 	failure reports 
non utf characters 	nodes failing 
latin conversion 	report node 
know must range 	previously 
commitencoding utf 	considered failing 
avoid reallocs 	sender function 
headers note ordering 	called node 
means exact 	informs via 
merged different order 	gossip node 
parents different 	point 
changeset even everything 	view fail 
stays person 	pfail flags 
date information comment 	note function 
check encoding 	called relatively 
append commit end 	often gets 
commit list 	called 
next starts pointing 	even nodes 
variable holds 	failing however 
head empty commit 	cluster fine 
list updated 	failure reports 
point next field 	list empty 
last item 	function 
list commits appended 	runs constant 
usage example 	time function 
commit list 	returns failure 
list commit list 	report found 
next list 	removed otherwise 
next commit list 	returned 
append next 	search failure 
next commit list 	report sender 
append next 	failure report 
commit list count 	sender failure 
list list 	report number 
inspect determine end 	external 
log message 	nodes believe 
order find put 	node failing 
line ignored 	including node 
trailing comment lines 	may pfail 
blank lines 	fail state 
also traditional conflicts 	node 
block commented 	well already 
use git 	slave low 
commit amend existing 	level cleanup 
commit forgot 	node structure 
returns number bytes 	called cluster 
tail ignore 	del 
fed second parameter 	node node 
append signoff 	associated slaves 
first run comments 	slaves slaveof 
otherwise continuing 	fields unknown 
pathname conflicts block 	node list 
previous trailing 	slaves 
comment builtin git 	master unlink 
commit copyright 	nodes release 
kristian gsberg krh 	link associated 
redhat git 	data structures 
commit junio hamano 	node nodes 
linus torvalds 	hash 
real index used 	table node 
commits message 	cluster functio 
variables commit 	performs high 
names take commit 	level cleanup 
message authorship 	calling free 
unspecified commit message 	cluster 
cleanup mode 	node low 
lines beginning shell 	level cleanup 
comments leading 	following mark 
trailing whitespaces empty 	slots handled 
lines containing 	unassigned failure 
whitespaces editor used 	reports 
whitespaces message 	sent node 
specified explicitly must 	referenced nodes 
come git 	free node 
config nothing nothing 	free cluster 
take paths 	node turn 
index named typically 	hash 
head paths 	table list 
match given pattern 	slaves master 
list better 	slave node 
valid pointer 	mark slots 
fake one skip 	unassigned failure 
worktree already 	reports 
reported error finish 	free node 
dying refresh 	unlinking cluster 
flags contains refresh 	node lookup 
quiet errors 	name used 
unmerged entries non 	handshake connect 
non commit 	given 
real index update 	port result 
index necessary 	cluster meet 
write index real 	node name 
index still 	yet pick 
locked name locked 	random one 
index file 	fix 
caller run hooks 	receive pong 
locked real 	request function 
index goes well 	cluster config 
commit real 	epoch handling 
index failure 	greatest config 
rollback real index 	epoch 
commit name 	found cluster 
real index file 	current epoch 
caller run 	greater node 
hooks real index 	config epoch 
create commit 	node epoch 
index still need 	zero 
refresh index 	already greatest 
commit find affected 	across cluster 
paths real 	pov local 
index file update 	configuration function 
index given 	generate config 
paths write index 	epoch 
real index 	incrementing current 
still locked index 	epoch assign 
file reset 	epoch node 
index head 	without consensus 
update index way 	persist configuration 
write index 	disk 
index file name 	sending packets 
index file 	configuration config 
still locked caller 	epoch generated 
run hooks 	assigend returned 
locked index create 	otherwise err 
commit goes 	returned 
well commit real 	since node 
index failure 	already greatest 
rollback real index 	configuration around 
either rollback 	operation performed 
index checks barfs 	important note 
author badly 	function 
specified insert proper 	violates principle 
subject line 	config epochs 
commit message options 	generated consensus 
content remaining 	unique across 
cases modify 	cluster however 
message argument prepare 	redis 
commit msg 	cluster uses 
hook squash commit 	generated config 
used commit 	epochs two 
subject possibly hijacking 	cases slots 
commit log 	closed importing 
options reset hook 	otherwise 
args tell 	resharding would 
real story ignore 	expansive cluster 
status display 	failover called 
comment prefix need 	options force 
comments commit 	slave failover 
editmsg hints counter 	master 
productive commit 	even master 
already started checks 	majority able 
committer ident 	create configuration 
explicitly given cleanup 	epoch redis 
space never 	cluster explode 
fail come 	function 
fmt ident may 	even collision 
fail sane 	node another 
ident test know 	node generating 
name mail 	configuration epoch 
pointers least valid 	unilaterally config 
enough tests 	epoch 
printing unless user 	conflict resolution 
explicitly request 	algorithm eventually 
submodule ignore mode 	move colliding 
passing command 	nodes different 
line option ignore 	config epochs 
changed submodule 	however 
sha comparing index 	function may 
parent matter 	violate last 
configured otherwise won 	failover wins 
commit submodules 	rule used 
manually staged would 	care function 
really confusing 	called 
reject attempt 	node master 
record non merge 	receive another 
empty commit 	master configuration 
without allow empty 	epoch equal 
cherry pick 	configuration epoch 
may empty due 	background 
conflict resolution 	possible different 
user okay read 	slaves config 
index pre 	epoch failover 
commit hook could 	election slaves 
updated write 	need voted 
must invoke editor 	majority 
invoke run 	however perform 
status check rest 	manual resharding 
whitespace find 	cluster node 
message strbuf contains 	assign configuration 
whitespace lines 	epoch without 
see user edited 	ask 
message editor 	agreement usually 
left intact 	resharding happens 
already initialized enumerate 	cluster working 
needs propagated 	well supervised 
porcelain effect unspecified 	sysadmin however 
sanity check 	possible 
options oldsha newsha 	failover happen 
nul hook 	exactly node 
know editor launched 	resharding slot 
end commit 	assigns configuration 
message options end 	epoch able 
commit contents 	propagate 
options ignore status 	technically possible 
everything writing 	condition two 
commit includes running 	nodes end 
hooks writing 	configuration epoch 
trees interacting user 	another possibility 
determine parents 	bugs 
commit message 	implementation causing 
truncate message diff 	happen moreover 
amending current 	cluster created 
head commit.h item 	nodes start 
next index 	config epoch 
date parents save 	collision 
commit buffer 	resolution code 
commit type next 	allows nodes 
type name 	automatically end 
name decoration obj 	different config 
sha sha 	epoch startup 
sha quiet name 	automatically 
sha name 	cases want 
item buffer size 	mechanism resolves 
item quiet 	issue automatically 
missing item item 	safeguard configuration 
commit buffer 	epoch masters 
size commit size 	serving 
commit size 	different slots 
commit buffer 	harmful nodes 
commit commit sizep 	end serving 
commit buffer 	slots reason 
subject item list 	manual errors 
commit next 	software 
item list list 	bugs without 
list list 	proper failover 
abbrev subject subject 	procedure general 
preserve subject 	want system 
date mode need 	eventually always 
bit cte 	ends 
notes message reflog 	different masters 
info output 	different configuration 
encoding mailmap color 	epochs whatever 
ident body 	happened since 
headers text commit 	nothign worse 
commit encoding 	split 
output encoding arg 	brain condition 
rev info 	distributed system 
msg line 	behavior function 
separator fmt commit 	gets called 
format empty 	happens node 
heads next key 	lexicographically 
len parents 	smaller node 
tail msg msg 	compared node 
len parents 	conflicting epoch 
ret author sign 	sender node 
commit msg 	assign greatest 
msg len parents 	configuration 
ret author 	epoch currently 
sign commit commit 	detected among 
extra header 	nodes plus 
commit extra msg 	means even 
key len 	multiple nodes 
commit data obj 	colliding 
name name 	node greatest 
commit message signature 	node never 
buf list 	moves forward 
format cur 	eventually nodes 
format last commit 	end 
sigc unused 	different configuration 
editor used index 	epoch prerequisites 
file name 	nodes config 
parse commit gently 	epoch masters 
decorate name 	act colliding 
used commits look 	node 
named sha 	smaller node 
dereference tag necessary 	next available 
commit sha 	best node 
dereference commit use 	knowledge cluster 
name report 	nodes blacklist 
error die associate 	nodes 
buffer commit 	blacklist way 
ownership memory handed 	ensure given 
commit must 	node given 
free able 	node readded 
cached buffer associated 	time elapsed 
commit returns 	time 
none resulting memory 	specified seconds 
freed commit 	cluster blacklist 
contents either cache 	ttl useful 
reading disk 	want node 
resulting memory modified 	cluster completely 
must given 	cluster 
unuse commit buffer 	forget called 
caller done 	also puts 
tell commit subsytem 	node blacklist 
done particular 	even receive 
commit buffer commit 	gossip messages 
buffer input 	nodes 
respectively earlier call 	still remember 
commit buffer 	node want 
buffer may may 	time currently 
freed call 	cluster blacklist 
callers access 	ttl minute 
memory afterwards free 	means 
cached buffer 	redis trib 
associated commit disassociate 	seconds send 
cached buffer 	cluster forget 
commit free buffer 	messages nodes 
none returned 	cluster without 
find beginning length 	dealing 
commit subject 	problem nodes 
shallow copy input 	adding back 
list commit 	node nodes 
formats callers tweak 	already sent 
change behavior 	forget command 
functions fields manipulated 	data 
internally functions 	structure used 
counted callers revision 	hash table 
circularly uses 	sds representing 
cmit fmt removes 	node key 
first commit 	time node 
list sorted 	minute 
date adds parents 	node exists 
performs place 	operations always 
topological sort list 	expired entries 
supplied invariant 	black list 
resulting list reachable 	operation problem 
ord ord 	since 
sort order specifies 	exists operations 
rev sort 	called infrequently 
graph order show 	hash table 
commit single 	supposed contain 
parent chain together 	little elements 
rev sort 	max 
commit date show 	however without 
eligible commits 	cleanup uptimes 
committer date order 	automated node 
shallow commit 	removal procedures 
used flags call 	entries could 
longer matter 	accumulate 
largest positive 	cleanup blacklist 
number bit integer 	node black 
contain receive 	list key 
pack search commit 	added duplicate 
contents given 	sds representation 
msg header key 	key 
returns pointer 	next lookup 
start header contents 	free end 
length header 	non zero 
first newline returned 	specified node 
via len 	exists blacklist 
note headers like 	need 
mergetag may 	pass sds 
multi line caller 	pointer bytes 
responsibility parse 	work cluster 
find end log 	messages exchange 
message right 	ping pong 
place trailer 	gossip 
named could tag 	function checks 
given name 	given node 
command line merge 	marked fail 
find commit 	happens following 
storing merge remote 	conditions met 
desc field 	received 
allow callers tell 	enough failure 
told merge 	reports master 
tag check signature 	nodes via 
given commit 	gossip enough 
result check stored 	means majority 
sig check 	masters 
result good signature 	signaled node 
good signature 	recently believe 
untrusted signer bad 	node pfail 
signature signature 	state failure 
may allocate memory 	detected also 
sig gpg 	inform 
output sig 	whole cluster 
gpg status sig 	trying force 
signer sig 	every node 
key commit config.c 	fail flag 
prev file 	node note 
buf len pos 	form 
origin type 	agreement used 
name path die 	weak collect 
error linenr 	majority masters 
eof conf zlib 	state time 
compression seen 	even force 
config conf conf 	agreement 
conf conf 	propagating fail 
conf conf include 	message partitions 
depth advice 	may reach 
path inc ret 	every node 
buf expanded 	however either 
slash data inc 	reach 
ret text 	majority eventually 
env old 	fail state 
text data pair 	propagate cluster 
data env 	majority slave 
envw argv alloc 	promotion authorized 
space data 	fail 
name ret name 	flag cleared 
name data 	time reach 
comment baselen bomptr 	already fai 
end val 	ling also 
ret max end 	count voter 
val uval 	master 
factor ret max 	weak agreement 
end val 	masters mark 
oldval ret tmp 	node failing 
ret tmp 	broadcast failing 
ret tmp name 	node name 
reason name 	everybody 
ret name ret 	forcing reachable 
name ret 	nodes flag 
name name 	node fail 
name discard dest 	function called 
dest abbrev 	node marked 
level level pgsz 	fail 
dummy top 	able reach 
data ret origin 	checks conditions 
type name 	undo fail 
path data top 	state slaves 
data filename 	always clear 
data ret origin 	fail 
type name 	flag contact 
buf len data 	node master 
top name 	fail state 
sha data buf 	old enough 
size ret 	yet serving 
name data sha 	slots 
system wide 	point view 
def val data 	failed apparently 
repo config 	one going 
found xdg 	fix slots 
config user config 	clear fail 
data config 	flag 
source respect includes 	already node 
repo config 	handshake state 
ret inc data 	matching specified 
data index 	address port 
values entry list 	number function 
info data 	used 
key found entry 	order avoid 
normalized key 	adding handshake 
ret key item 	node address 
info unused 	multiple times 
entry iter key 	start handshake 
filename key 	specified 
values key key 	address one 
dest key 	already progress 
dest key 	returns non 
dest key dest 	zero handshake 
key dest 	actually started 
key dest key 	error 
dest key 	zero returned 
dest key key 	errno one 
key dest 	following values 
ret key dest 	eagain already 
key dest 	handshake progress 
key dest key 	address 
dest key 	einval port 
dest key dest 	valid sanity 
key dest 	check port 
ret val key 	sanity check 
filename linenr 	norm normalized 
git die config 	representation 
baselen key 	node address 
match regex multi 	node random 
replace offset 	address first 
offset alloc 	argument create 
seen key key 	cluster node 
section len 	everything 
filename key dot 	handshake process 
success key 	gossip section 
success length quote 	ping pong 
contents size 	packets note 
offset found bracket 	function assumes 
bracket offset 	packet 
offset config filename 	already sanity 
key config 	caller content 
filename key key 	gossip section 
key key 	length update 
store key baselen 	state accordingly 
quiet dot 	gossip 
baselen last dot 	sections already 
key store 	know node 
key baselen key 	handle failure 
config filename 	reports sender 
key regex 	master already 
multi replace ret 	know 
filename buf 	node reachable 
contents contents copy 	see different 
begin copy 	address gossip 
end line config 	section node 
filename key 	talk node 
regex multi replace 	update 
key regex 	address disconnect 
multi replace key 	old link 
regex multi 	attempt connect 
replace buf name 	address noaddr 
dot name 	state start 
config filename old 	handshake 
name name 	process port 
filename buf buf 	pairs note 
config file 	require sender 
length output offset 	gossip message 
old name 	well known 
name section 	node 
subsection subsection len 	cluster otherwise 
key section 	risk joining 
len dot getc 	another cluster 
unlocked ungetc 	next node 
ftell die config 	conversion buf 
error nonbool 	supposed 
expand user path 	least bytes 
error absolute 	update node 
path error find 	address address 
last dir 	extracted link 
sep strbuf strbuf 	specified port 
addstr access 	also 
die die git 	disconnect node 
config file 	link connect 
strbuf release free 	address port 
strcmp handle 	pair already 
path include 	correct operation 
getenv strbuf addstr 	performed 
strbuf addch 	function returns 
quote buf setenv 	node address 
strbuf release 	still otherwise 
strbuf split str 	returned proceed 
error strbuf 	link sender 
setlen strbuf trim 	link 
strbuf list 	function designed 
free error strbuf 	see node 
tolower strbuf 	link consistent 
list free strbuf 	symmetric link 
list free 	used receive 
getenv xstrdup dequote 	pin 
argv free 	node side 
error git config 	effect function 
parse parameter 	never frees 
free free free 	passed link 
free fgetc 	safe call 
fgetc ungetc 	packet 
strbuf reset next 	processing port 
isspace strbuf 	different update 
addch next strbuf 	check master 
addch strbuf 	change replication 
addch isalnum next 	target well 
iskeychar strbuf 	reconfigure 
addch tolower next 	specified node 
parse isspace 	master function 
next strbuf addch 	called node 
next next 	believed slave 
strbuf addch next 	acting master 
next isspace 	order 
extended iskeychar strbuf 	update state 
addch tolower 	node update 
next isspace strbuf 	config state 
reset strbuf 	function called 
addch isalpha strbuf 	receive master 
setlen strbuf 	configuration 
addch tolower 	via ping 
die error strcasecmp 	pong update 
strcasecmp strcasecmp 	packet receive 
strtoimax parse unit 	node config 
factor labs 	epoch node 
labs strtoumax parse 	slots 
unit factor 	claimed config 
git parse maximum 	epoch rebind 
type git 	slots newer 
parse maximum type 	configuration compared 
git parse 	local configuration 
maximum type die 	needed 
die git 	turn ourself 
parse die bad 	replica node 
number git 	see function 
parse die bad 	comments info 
number git 	sender node 
parse die bad 	received 
number strcasecmp 	configuration update 
strcasecmp strcasecmp 	sometimes actually 
strcasecmp strcasecmp strcasecmp 	sender information 
git parse 	like receive 
maybe git parse 	info via 
git parse 	update 
maybe git config 	packet dirty 
git config 	slots list 
config error nonbool 	list slots 
xstrdup config 	lose ownership 
error nonbool expand 	still keys 
user path 	inside 
die strcmp git 	usually happens 
config strcmp 	failover manual 
git config strcmp 	cluster reconfiguration 
strcasecmp strcasecmp 	operated admin 
strcmp git config 	update message 
strcmp git 	able 
config strcmp 	demote master 
git config strcmp 	slave resync 
git config 	master updating 
pathname strcmp git 	whole key 
config strcmp 	space need 
git config strcmp 	keys 
git config 	slots lost 
strcmp git config 	ownership curmaster 
strcmp git 	node node 
config strcmp git 	node replicates 
config strcmp 	slave loop 
git config die 	interested 
strcmp git 	check slots 
config die strcmp 	taken away 
getpagesize git 	curmaster slot 
config strcmp git 	already bound 
config strcmp 	sender message 
git config strcmp 	slot 
git config 	importing state 
strcmp strcasecmp 	modified manually 
error git config 	via redis 
strcmp strcasecmp 	trib example 
git config strcmp 	resharding progress 
strcasecmp strcasecmp 	migrating 
strcasecmp error strcmp 	side slot 
xstrdup strcmp 	already closed 
git config strcmp 	advertising config 
git config 	still want 
strcmp config error 	slot closed 
nonbool strcasecmp 	manually 
error strcmp git 	rebind slot 
config strcmp 	node claiming 
git config pathname 	slot unassigned 
strcmp config 	node claims 
error nonbool parse 	greater config 
whitespace rule 	epoch 
strcmp git config 	currently importing 
strcmp git 	slot slot 
config strcmp 	mine still 
strcmp strcmp die 	contains keys 
strcmp git 	mark dirty 
config strcmp git 	slot 
config strcmp 	least one 
git config strcmp 	slot reassigned 
git config 	node another 
strcmp git config 	node greater 
strcmp git 	config epoch 
config strcmp strcasecmp 	possible 
git config 	master left 
strcmp config error 	without slots 
nonbool strcmp 	means failed 
strcmp strcmp strcmp 	turn replica 
error strcmp 	master slave 
config error nonbool 	master 
strcmp strcmp 	left without 
strcmp strcmp strcmp 	slots need 
strcmp error 	replicate slots 
error strcmp 	owner received 
git config pathname 	update message 
strcmp git 	removed 
config starts git 	ownership certain 
core config 	slots still 
starts git ident 	keys still 
config starts 	serving slots 
git config starts 	master node 
git branch 	demoted 
config starts git 	slave order 
push config 	maintain consistent 
starts git mailmap 	state keys 
config starts 	slots need 
git advice config 	keys slots 
strcmp strcmp 	lost 
git config strcmp 	function called 
git config 	packet process 
strbuf init strbuf 	starting node 
init git 	rcvbuf releasing 
parse source 	buffer caller 
strbuf release strbuf 	function 
release config 	handle higher 
config file fopen 	level stuff 
flockfile config 	processing packet 
file funlockfile fclose 	modifying cluster 
config read 	state needed 
sha file error 	function 
free error 	returns link 
git config mem 	still valid 
free sha 	packet processed 
error git config 	otherwise link 
blob sha 	freed since 
system path getenv 	packet 
git config 	processing lead 
getenv git parse 	inconsistency error 
die git 	instance pong 
env xdg 	received wrong 
config home expand 	sender perform 
user path 	sanity 
git config system 	checks least 
access die 	signature version 
git etc gitconfig 	totlen count 
git config 	handle messages 
file git etc 	different 
gitconfig access 	versions expected 
die git config 	length packet 
file access 	check sender 
die git config 	known node 
file access 	update curret 
die git config 	epoch 
file git 	see newer 
config parameters die 	epoch cluster 
free free 	update sender 
git config stdin 	config epoch 
git config 	publishing newer 
file git 	one 
config blob git 	update replication 
pathdup git 	offset info 
config early free 	node slave 
git config 	performing manual 
options die git 	failover master 
die config 	sent 
linenr git config 	offset already 
check init 	paused populate 
configset iter git 	state initial 
config parse 	processing ping 
key hashmap entry 	meet requests 
init strhash 	replying 
hashmap free xmalloc 	pong use 
configset find 	incoming meet 
element xmalloc hashmap 	messages order 
entry init 	address since 
strhash xstrdup list 	cluster nodes 
init hashmap 	send 
list append 	meet messagses 
nodup xstrdup alloc 	handshakes cluster 
grow strintern 	joins later 
strcmp hashmap init 	changed address 
hashmap iter 	nodes use 
init hashmap iter 	official 
next free 	address connect 
list clear hashmap 	obtaining address 
free free 	socket simple 
configset git config 	way discover 
file git 	update address 
configset multi configset 	cluster 
find element 	without hardcoded 
git configset git 	config however 
config git 	address update 
configset git configset 	address even 
git config 	normal ping 
git configset git 	packet 
config git 	wrong meet 
configset git 	later node 
config git configset 	msg type 
git config 	meet stage 
git configset git 	node right 
config maybe 	flags 
git configset git 	slaveof pointer 
config pathname 	forth details 
git configset init 	resolved receive 
git config 	pon node 
raw git configset 	meet packet 
clear git 	unknown 
config check init 	node still 
git configset 	process gossip 
git config check 	section since 
init git 	trust sender 
configset multi git 	message type 
config check 	anyway 
init git 	reply pong 
configset git die 	ping pong 
config git 	meet process 
config check init 	config information 
git config 	already node 
git config check 	change 
init git 	port node 
configset git config 	one free 
check init 	node already 
git configset git 	cause link 
config check 	freed well 
init git configset 	first 
git config 	thing replacing 
check init git 	random name 
configset git 	right node 
config check init 	name handshake 
git configset 	stage reply 
maybe git config 	non 
check init 	matching node 
git configset 	disconnect node 
pathname git die 	associated address 
config git 	update node 
config maybe git 	address changed 
config strcasecmp 	update 
error die die 	info node 
strcmp regexec 	pfail condition 
matches warning alloc 	reversed without 
grow ftell 	external help 
strrchr memcmp alloc 	momentary turn 
grow ftell 	fail 
matches alloc grow 	state fail 
ftell strrchr 	condition also 
strncmp alloc grow 	reversible specific 
ftell error 	conditions detected 
memchr strbuf addf 	clear node 
strbuf addch 	failure 
strbuf addch strbuf 	needed check 
addstr strbuf 	role slave 
addf write 	master master 
full strbuf release 	slave node 
strlen strbuf 	master node 
addf strbuf addstr 	slave 
strbuf addstr 	master turned 
strbuf addch strbuf 	slave reconfigure 
addch strbuf 	node update 
addf write full 	config state 
strbuf release 	master node 
git config multivar 	changed 
file gently 	slave update 
git config multivar 	config update 
file git 	info served 
config multivar gently 	slots note 
git config 	must happen 
multivar strrchr error 	update 
error xmallocz 	master slave 
strlen iskeychar isalpha 	state cluster 
error tolower 	node master 
error free 	flag many 
git config parse 	checks needed 
key git 	served 
config parse key 	slots instance 
git config 	claims different 
parse key git 	compared slots 
pathdup xcalloc 	check asap 
hold file update 	avoid computational 
error strerror 	expansive 
free open free 	checks later 
error strerror 	sender master 
store write section 	slave sender 
store write 	claimed slots 
pair xmalloc regcomp 	match view 
error free 	sender 
alloc grow git 	message master 
config file 	detected slots 
error free 	claims changed 
regfree free free 	scan slots 
regfree free 	see need 
fstat xsize xmmap 	update 
gently isdir 	configuration also 
error strerror close 	check reverse 
chmod file 	condition sender 
path error file 	claims serve 
path strerror 	slots know 
find beginning line 	served 
write full 	master greater 
write str full 	config epoch 
store write 	happens inform 
section store write 	sender useful 
pair write 	sometimes partition 
full munmap commit 	heals 
file error 	reappearing master 
strerror git config 	may last 
clear rollback 	one claim 
file free 	given hash 
munmap close write 	slots configuration 
error file 	instances 
path git config 	know deprecated 
multivar file 	example master 
gently die git 	slave slots 
config multivar 	partitioned away 
file gently git 	gets promoted 
config multivar 	partitioned 
file isspace isspace 	away returns 
isspace isspace 	available usually 
isalnum section name 	would ping 
error git 	publishing served 
pathdup xcalloc hold 	slots config 
file update 	epoch 
error fopen fstat 	partition inform 
fileno chmod 	configuration nodes 
file path error 	updated table 
file path 	must way 
strerror fgets 	stop act 
isspace section name 	master 
match strlen 	failover conditions 
store write section 	win election 
write error 	todo instead 
file path strlen 	exiting loop 
strlen write 	send every 
full write error 	update 
file path 	packet nodes 
fclose commit file 	owner sender 
error strerror 	slots config 
free git config 	epoch collides 
rename section 	sender fix 
file error strlen 	problem 
starts strrchr 	info gossip 
git information manager 	section bother 
hell copyright 	creating useless 
linus torvalds copyright 	objects pub 
johannes schindelin 	sub subscribers 
config contains 	know 
key pairs usual 	node know 
config config 	node consider 
files repo specific 	vote sender 
git config 	master serving 
user wide gitconfig 	non zero 
xdg config 	number 
file etc gitconfig 	slots current 
use absolute 	epoch greater 
path interpret relative 	equal epoch 
paths including 	node started 
config file pass 	election maybe 
along values 	reached 
including include directives 	quorum flag 
makes possible 	make sure 
query information includes 	check asap 
dequote write 	message acceptable 
dos like systems 	master sender 
characters escape 	one 
reject unknown 	slaves manual 
escape sequences full 	failover requested 
name already 	slaves initialize 
consumed need linenr 	state accordingly 
point line 	node update 
parsed call accurate 	know 
line number 	sender know 
error messages require 	reported node 
format extension 	nothing current 
feff order mark 	config node 
utf file 	slave master 
beginning skip utf 	update 
encoded bom 	node config 
present sane editors 	epoch check 
won put 	bitmap served 
windows notepad happily 	slots update 
tolerate bom 	config accordingly 
bom file 	function 
beginning cool reset 	called detect 
prior determining 	link node 
stem truncate name 	lost node 
back section 	longer connected 
header stem prior 	cluster cron 
grabbing suffix 	detect 
part name needs 	connection connected 
better name 	instead node 
must multiple pagesize 	temporary node 
config variables 	used accept 
documentation config txt 	query completely 
config variables 	free 
documentation config txt 	node error 
config variables 	send data 
documentation config txt 	handled trivial 
deprecated config 	send buffer 
variables documentation config 	gets consumed 
txt config 	write 
variables documentation 	optimize speed 
config txt config 	much low 
variables documentation 	traffic channel 
config txt source 	read data 
specific fields 	read first 
die error name 	field 
callbacks fgetc 	header first 
ungetc ftell top 	check full 
need initialized 	length packet 
calling function push 	whole packet 
config file 	memory function 
parsing state stack 	call 
pop config 	function process 
file parsing state 	packet forth 
stack parse 	read data 
environment variable various 	read first 
possible spellings 	obtain first 
missing use def 	bytes 
parse environment 	full message 
variable possibly 	length read 
unit suffix missing 	full message 
use val 	perform sanity 
error found nothing 	check message 
found least 	signature 
one item specific 	length data 
filename use 	ready error 
otherwise follow regular 	read data 
lookup sequence 	recast pointer 
git config options 	buffer total 
normally returns 	length 
positive values errors 	obtained process 
fatal non 	packet link 
fatal potential errors 	longer valid 
guarded statements 	put stuff 
entered error possible 	send buffer 
ever encounter 	guaranteed 
non fatal error 	function never 
means something 	side effect 
went really 	link invalidated 
wrong stop immediately 	safe call 
key may 	function handlers 
come user normalize 	stuff 
querying entries 	link later 
hashmap since keys 	send message 
fed git 	nodes part 
config callback mechanism 	cluster connected 
already normalized 	link guaranteed 
simply without munging 	function 
values read 	never side 
git config parameters 	effect node 
follows last 	link invalidated 
one wins semantic 	safe call 
multiple matches 	function handlers 
queried key files 	stuff 
configset returned 	node links 
last list 	later build 
key hack test 	message header 
programs like 	hdr must 
test dump untracked 	point buffer 
cache find 	least 
stuff git config 	cluster msg 
always matches 	bytes node 
never matches looking 	master send 
store key 	slots bitmap 
section section part 	config epoch 
baselen found 	node 
key section would 	slave send 
want know 	master information 
key section looking 	instead node 
already know 	flagged slave 
section hold store 	receiver knows 
key increment 	really 
matches match made 	charge slots 
sure desired 	current epoch 
section fallthru 	config epochs 
error code failed 	replication offset 
rename check 	message flags 
see needs surrounded 	compute 
pair note 	message length 
problematic characters always 	certain messages 
backslash quoted 	messages caller 
check losing leading 	ping pong 
trailing follow 	meet fixing 
beginning comment characters 	totlen 
configuration parser 	field caller 
auxiliary function sanity 	send ping 
check split 	pong packet 
key section variable 	specified node 
name returns 	making sure 
success invalid character 	enough 
key section 	gossip informations 
name key store 	number gossip 
key pointer 	sections added 
hold copy 	far number 
key lowercase section 	gossip sections 
variable name 	want 
baselen pointer hold 	append possible 
length section 	total packet 
subsection part since 	length freshnodes 
key actually 	max number 
contains section name 	nodes hope 
real key 	append 
name separated dot 	nodes available 
know dot 	minus two 
validate key lower 	ourself node 
matching extended 	sending message 
basename untouched unset 	however practically 
config regex 	may 
disregard key pairs 	less valid 
match regex 	nodes since 
config regex none 	nodes handshake 
match existing 	state disconnected 
values one 	considered many 
multi replace nothing 	gossip 
one matching 	sections want 
key replaced matching 	number nodes 
key values 	anyway least 
regardless many removed 	masters entries 
pair written 	consider node 
returns success function 	timeout 
locks config 	exchange node 
file creating git 	least packets 
config parses 	ping worst 
config store aux 	node timeout 
validator find 	time also 
position key pair 	receive 
replace unset 	two pings 
must found exactly 	host total 
config file 	packets node 
mmap part 	timeout falure 
match written file 	reports validity 
changed part 	time 
rest config file 	single pfail 
removed file 	node expect 
rename parse key 	receive following 
returns negative 	number failure 
flip sign feed 	reports specified 
exit serves 	window 
purpose addition locking 	time prob 
contents git 	gossip entries 
config written git 	per packet 
config exist 	total packets 
yet write minimal 	prob probability 
version invalid 	featured 
config file nothing 	single gossip 
unset error 	entry num 
store offset contain 	nodes entries 
end offset 	total packets 
last match 	num masters 
remain match found 	masters 
side effect 	num nodes 
make sure transform 	num masters 
valid existing 	always majority 
config file nothing 	specifically number 
unset many 	nodes account 
matches error write 	many 
first part 	masters failing 
config write pair 	time since 
means unset 	non voting 
write rest config 	slaves lower 
committed roll 	probability entry 
back note since 	feature 
lockfile keeps 	node number 
linked list created 	entires per 
file structures 	packet total 
isn safe free 	nodes compute 
better hanging 	maxium totlen 
around invalidate 	allocate 
config cache nothing 	buffer fix 
nothing match 	totlen later 
find right length 	according number 
offset gobbling 	gossip sections 
whitespace well nothing 	really able 
empty section 	put 
names bogus dot 	inside packet 
must alphanumeric 	note cluster 
dash first dot 	build message 
anything goes 	hdr expects 
stop checking name 	buffer always 
section removed 	least 
instead config file 	cluster msg 
means nothing 	populate header 
rename error nothing 	populate gossip 
section wrote 	fields include 
section newline skip 	node 
old section 	whole packet 
length content 	header already 
means declaration put 	gossip nodes 
next line 	give bias 
indent tab call 	fail pfail 
report error 	nodes 
variable means start 	gossip section 
section find 	include nodes 
key know yet 	handshake state 
subsection must 	nodes noaddr 
parse backwards end 	flag disconnected 
since subsection 	nodes 
may dots subsection 	configured slots 
use fwrite 	tecnically correct 
buf contain end 	saves cpu 
show key 	check already 
name back delimiter 	added node 
needswork naive 	ready 
pattern lowercasing obviously 	send fix 
work complex 	totlen fiend 
patterns like 	queue message 
foo bar perhaps 	output buffer 
deprecate altogether 	send pong 
someday normalization type 	packet 
path path 	every connected 
like foobar prefer 	node handshake 
store foobar 	state valid 
config file expand 	link redis 
retrieving none 	cluster pongs 
found config unknown 	used 
home gitconfig 	failure detection 
exists know write 	also carry 
xdg location 	important configuration 
error even xdg 	information broadcasting 
config home 	pong useful 
points sane location 	something 
builtin config 	changes configuration 
usage key 	want make 
key regexp regexp 	cluster aware 
show keys 	asap instance 
omit values use 	slave promotion 
key regexp 	target 
match delim key 	argument specifies 
delim term 	receiving instances 
use config use 	defines cluster 
system config 	broadcast known 
use local config 	instances cluster 
given config 	broadcast 
source actions types 	local slaves 
color slot 	slaves master 
colorbool slot end 	slaves ring 
respect includes 	send publish 
show origin builtin 	message link 
config options 	message 
argc min max 	broadcasted whole 
buf term 	cluster use 
key buf 	local buffer 
items alloc buf 	possible send 
key key 	fail message 
values key regex 	nodes 
ret values 	able contact 
buf key color 	fail message 
found color 	sent detect 
slot colorbool slot 	node failing 
parsed color 	cluster node 
def color colorbool 	pfail 
found diff 	also receive 
color found color 	gossip confirmation 
found print 	node state 
values item matched 	cluster node 
url section 	fail ask 
tail item config 	nodes 
values matched 	asap send 
buf buf argc 	update message 
argv prefix 	specified link 
nongit user 	carrying specified 
config xdg config 	node slots 
config file 	configuration 
content ret ret 	node name 
ret error 	slots bitmap 
usage options strbuf 	config epoch 
addstr current 	info included 
config origin type 	cluster pub 
strbuf addch 	sub 
strbuf addstr current 	support little 
config name 	propagating publish 
quote style current 	messages across 
config name 	whole cluster 
strbuf addch show 	future smarter 
config origin 	avoiding 
fwrite strbuf release 	propagating messages 
show config 	hosts without 
origin strbuf addstr 	receives given 
strbuf addch 	channel slave 
strbuf addf 	node specific 
git config strbuf 	functions 
addstr git 	function sends 
config git config 	failove auth 
strbuf addstr 	request message 
strbuf addf git 	every node 
config pathname 	order see 
strbuf addstr free 	quorum 
strbuf addstr 	slave instance 
strbuf setlen strbuf 	failover failing 
addch strcmp 	master note 
regexec regexec alloc 	send failover 
grow strbuf 	request everybody 
init format config 	master 
xstrdup strlen 	slave nodes 
tolower tolower xmalloc 	masters supposed 
regcomp error 	reply query 
free git 	manual failover 
config parse key 	clustermsg flag 
xmalloc regcomp 	forceack 
error free git 	bit header 
config options 	communicate nodes 
fwrite strbuf release 	receiving message 
free free 	authorized failover 
regfree free regfree 	even master 
free xstrdup 	working 
xstrfmt git config 	send failover 
xstrdup git 	auth ack 
config git config 	message specified 
xstrfmt xstrdup 	node send 
die strcmp config 	mfstart message 
error nonbool 	specified 
color parse git 	node vote 
config options 	node asking 
color parse die 	vote conditions 
fputs strcmp 	master serving 
git config 	least slot 
colorbool strcmp git 	right 
config colorbool 	vote cluster 
strcmp git config 	size redis 
colorbool git 	cluster number 
config options strcmp 	masters serving 
want color 	least one 
die die die 	slot 
list insert 	quorum cluster 
xmalloc strbuf init 	size request 
strbuf reset 	epoch must 
strbuf addstr url 	current epoch 
normalize die 	note impossible 
xstrdup tolower strchr 	actually 
git config 	greater since 
options format config 	current epoch 
fwrite strbuf 	updated side 
release strbuf release 	effect receiving 
list clear 	request request 
list clear 	epoch 
free free strbuf 	greater already 
addf ident 	voted epoch 
name ident email 	asap node 
strbuf detach 	must slave 
getenv parse options 	master master 
error usage 	non 
options strcmp expand 	failing request 
user path 	flagged clustermsg 
xdg config home 	flag forceack 
die access 	manual failover 
warn access warn 	voted slave 
git etc 	master 
gitconfig git pathdup 	two times 
absolute path 	node timeout 
xstrdup prefix filename 	strictly needed 
strlen multi 	correctness algorithm 
bits error usage 	makes linear 
options error 	slave 
usage options 	requesting vote 
multi bits error 	must config 
usage options 	epoch claimed 
usage options error 	slots one 
usage options 	masters currently 
error usage options 	serving 
check argc 	slots current 
git config options 	configuration reached 
die errno 	point found 
die check argc 	slot current 
die die 	slots served 
die git config 	master 
xstrdup git 	greater config 
path open user 	epoch one 
config write 	claimed slave 
str full free 	requesting vote 
close die 	refuse vote 
errno launch editor 	slave 
free check 	vote slave 
write check 	function returns 
argc normalize git 	rank instance 
config file 	slave context 
gently error check 	master slaves 
write check 	ring 
argc normalize git 	rank slave 
config multivar 	given number 
file gently check 	slaves master 
write check 	better replication 
argc normalize git 	offset compared 
config multivar 	local 
file gently check 	one better 
write check 	means greater 
argc normalize git 	claim data 
config multivar 	slave rank 
file gently check 	one greatest 
argc check 	date 
argc check 	replication offset 
argc check argc 	forth note 
urlmatch check 	rank computed 
write check argc 	multiple slaves 
git config 	may rank 
multivar file gently 	offset 
git config 	slave rank 
file gently check 	used delay 
write check 	start election 
argc git config 	order voted 
multivar file 	replace failing 
gently check write 	master 
check argc 	slaves better 
git config rename 	replication offsets 
section file 	likely win 
die check write 	never called 
check argc 	slaves without 
git config rename 	master 
section file 	function called 
die check 	cluster handle 
argc color check 	slave failover 
argc git 	order slave 
config colorbool git 	log able 
information manager 	failover 
hell copyright linus 	sometimes conditions 
torvalds copyright 	since failover 
johannes schindelin config 	function called 
contains key 	log things 
pairs usual config 	continuously function 
config files 	works 
repo specific git 	logging given 
config user 	conditions reason 
wide gitconfig xdg 	failover initiated 
config file 	changed reasons 
etc gitconfig use 	also include 
absolute path 	none 
interpret relative paths 	reason reset 
including config 	state slave 
file pass 	finds master 
along values including 	fine fail 
include directives 	flag also 
makes possible query 	log 
information includes 	emitted master 
dequote write dos 	still reason 
like systems 	failing still 
characters escape reject 	cluster cant 
unknown escape 	failover relog 
sequences full name 	period 
already consumed 	seconds elapsed 
need linenr point 	function logs 
line parsed 	slave five 
call accurate line 	seconds node 
number error 	timeout way 
messages require format 	nothing 
extension feff 	logged failover 
order mark utf 	starts reasonable 
file beginning 	time function 
skip utf 	called reason 
encoded bom present 	slave failover 
sane editors 	one 
won put windows 	integer macros 
notepad happily 	cluster cant 
tolerate bom bom 	failover function 
file beginning 	guaranteed called 
cool reset prior 	slave log 
determining stem 	reason 
truncate name back 	time also 
section header 	emit log 
stem prior grabbing 	master failed 
suffix part 	ago goal 
name needs better 	function log 
name must 	slaves 
multiple pagesize config 	stalled condition 
variables documentation 	time function 
config txt 	part automatic 
config variables documentation 	manual failovers 
config txt 	slave grabs 
config variables documentation 	master 
config txt 	hash slots 
deprecated config variables 	propagates configuration 
documentation config 	note caller 
txt config variables 	sure node 
documentation config 	got configuration 
txt config variables 	epoch 
documentation config 	already turn 
txt source specific 	node master 
fields die 	claim slots 
error name callbacks 	assigned master 
fgetc ungetc 	update state 
ftell top need 	save 
initialized calling 	config pong 
function push config 	nodes update 
file parsing 	state accordingly 
state stack 	detect switched 
pop config file 	master role 
parsing state 	manual 
stack parse environment 	failover progress 
variable various 	clear state 
possible spellings missing 	function called 
use def 	slave node 
parse environment variable 	master serving 
possibly unit 	non 
suffix missing use 	zero amount 
val error 	hash slots 
found nothing found 	fail state 
least one 	gaol function 
item specific filename 	check able 
use otherwise 	perform 
follow regular lookup 	failover data 
sequence git 	updated elected 
config options normally 	masters perform 
returns positive 	failover informing 
values errors 	nodes compute 
fatal non fatal 	failover 
potential errors 	timeout max 
guarded statements entered 	time send 
error possible 	votes wait 
ever encounter non 	replies failover 
fatal error 	retry time 
means something went 	time 
really wrong 	wait trying 
stop immediately key 	voted timeout 
may come 	min node 
user normalize querying 	timeout milliseconds 
entries hashmap 	retry two 
since keys fed 	times 
git config 	timeout pre 
callback mechanism already 	conditions run 
normalized simply 	function must 
without munging values 	met automatic 
read git 	manual failover 
config parameters 	slave 
follows last one 	master flagged 
wins semantic 	fail manual 
multiple matches queried 	failover serving 
key files 	slots reasons 
configset returned last 	failover reason 
list key 	returning 
hack test programs 	without failing 
like test 	none data 
dump untracked cache 	age number 
find stuff 	seconds disconnected 
git config always 	master node 
matches never 	timeout 
matches looking store 	data age 
key section 	fine disconnected 
section part baselen 	master least 
found key 	time flagged 
section would 	fail baseline 
want know key 	check 
section looking 	data recent 
already know section 	enough according 
hold store 	slave validity 
key increment matches 	factor configured 
match made 	user check 
sure desired section 	bypassed 
fallthru error 	manual failovers 
code failed rename 	previous failover 
check see 	attempt timedout 
needs surrounded pair 	retry time 
note problematic 	elapsed setup 
characters always backslash 	one 
quoted check 	delay milliseconds 
losing leading trailing 	fail msg 
follow beginning 	propagate random 
comment characters configuration 	delay milliseconds 
parser auxiliary 	another delay 
function sanity 	proportional 
check split key 	slave rank 
section variable 	specifically second 
name returns success 	rank way 
invalid character 	slaves probably 
key section name 	less updated 
key store 	replication 
key pointer hold 	offset penalized 
copy key 	however manual 
lowercase section variable 	failover delay 
name baselen 	needed scheduled 
pointer hold length 	election broadcast 
section subsection 	offset 
part since key 	slaves updated 
actually contains 	offsets offset 
section name real 	better possible 
key name 	received updated 
separated dot know 	offsets slaves 
dot validate 	master 
key lower 	since computed 
matching extended basename 	election delay 
untouched unset 	update delay 
config regex disregard 	rank changed 
key pairs 	performed manual 
match regex config 	failover 
regex none 	asap still 
match existing values 	start election 
one multi 	asap election 
replace nothing one 	old valid 
matching key 	ask votes 
replaced matching key 	needed 
values regardless 	wait replies 
many removed pair 	check reached 
written returns 	quorum quorum 
success function locks 	failover master 
config file 	update config 
creating git config 	epoch 
parses config 	epoch election 
store aux 	take responsability 
validator find position 	cluster slots 
key pair 	cluster slave 
replace unset must 	migration slave 
found exactly 	migration 
config file mmap 	process allows 
part match 	slave master 
written file changed 	already covered 
part rest 	least another 
config file removed 	slave migrate 
file rename 	master 
parse key returns 	orpaned left 
negative flip 	working slaves 
sign feed exit 	function responsible 
serves purpose 	decide replica 
addition locking contents 	migrated different 
git config 	orphaned 
written git config 	master called 
exist yet 	cluster cron 
write minimal 	function slave 
version invalid config 	node detected 
file nothing 	least one 
unset error store 	orphaned 
offset contain 	master cluster 
end offset last 	slave one 
match remain 	masters greatest 
match found side 	number slaves 
effect make 	checks 
sure transform valid 	performed caller 
existing config 	since requires 
file nothing unset 	iterate nodes 
many matches 	anyway spend 
error write first 	time cluster 
part config 	handle 
write pair means 	slave migration 
unset write 	definitely needed 
rest config 	fuction called 
committed roll back 	pre computed 
note since 	max slaves 
lockfile keeps linked 	max 
list created 	number working 
file structures isn 	fail state 
safe free 	slaves single 
better hanging around 	master additional 
invalidate config 	conditions migration 
cache nothing nothing 	examined 
match find 	inside function 
right length offset 	step migrate 
gobbling whitespace 	cluster state 
well nothing empty 	step migrate 
section names 	master left 
bogus dot must 	least 
alphanumeric dash 	migration barrier 
first dot anything 	slaves migration 
goes stop 	step idenitfy 
checking name 	candidate migration 
section removed instead 	check among 
config file 	masters 
means nothing rename 	greatest number 
error nothing 	slaves one 
section wrote section 	smallest node 
newline skip 	candidate slave 
old section length 	note means 
content means 	eventually 
declaration put next 	replica migration 
line indent 	occurr since 
tab call report 	slaves reachable 
error variable 	always fail 
means start section 	flag cleared 
find key 	eventually 
know yet subsection 	must candidate 
must parse 	time mean 
backwards end since 	race conditions 
subsection may 	possible two 
dots subsection 	slaves migrating 
use fwrite buf 	time 
contain end 	unlikely happen 
show key name 	harmless happens 
back delimiter 	want migrate 
needswork naive pattern 	master working 
lowercasing obviously 	orphaned used 
work complex patterns 	slaves 
like foo 	failed master 
bar perhaps deprecate 	slaves migrate 
altogether someday 	flag way 
normalization type path 	migrate instances 
path like 	supposed replicas 
foobar prefer store 	check 
foobar config 	number working 
file expand retrieving 	slaves track 
none found 	starting time 
config unknown home 	orphaned condition 
gitconfig exists 	master check 
know write 	slave 
xdg location error 	candidate migration 
even xdg 	attached master 
config home points 	maximum number 
sane location 	slaves smallest 
config.c prev file 	node step 
buf len 	perform 
pos origin type 	migration target 
name path 	candidate master 
die error linenr 	continuously orphaned 
eof conf 	couple seconds 
zlib compression seen 	failovers give 
config conf 	time 
conf conf conf 	natural slaves 
conf conf 	instance advertise 
include depth advice 	old master 
path inc 	one cluster 
ret buf 	manual failover 
expanded slash data 	important 
inc ret 	steps performed 
text env old 	slaves manual 
text data 	failover user 
pair data env 	send cluster 
envw argv 	failover command 
alloc space data 	failover 
name ret 	state initialized 
name name data 	setting end 
comment baselen 	millisecond unix 
bomptr end val 	time abort 
ret max 	attempt slave 
end val uval 	sends 
factor ret 	mfstart message 
max end val 	master requesting 
oldval ret 	pause clients 
tmp ret tmp 	two times 
ret tmp 	manual failover 
name reason 	timeout 
name ret name 	cluster timeout 
ret name 	master paused 
ret name name 	manual failover 
name discard 	also starts 
dest dest abbrev 	flag packets 
level level 	clustermsg 
pgsz dummy top 	flag paused 
data ret 	slave waits 
origin type name 	master send 
path data 	replication offset 
top data filename 	flagged paused 
data ret 	slave 
origin type name 	received offset 
buf len 	master offset 
data top name 	matches start 
sha data 	cluster handle 
buf size ret 	slave failover 
name data 	perform 
sha system 	failover usually 
wide def val 	difference vote 
data repo 	request modified 
config found xdg 	force masters 
config user 	vote slave 
config data config 	working 
source respect 	master point 
includes repo config 	view master 
ret inc 	things simpler 
data data index 	pause clients 
values entry 	packet received 
list info data 	master 
key found 	sets end 
entry normalized key 	well sender 
ret key 	slave time 
item info unused 	limit manual 
entry iter 	failover master 
key filename key 	send 
values key 	pin often 
key dest 	slave flagged 
key dest key 	paused flag 
dest key 	slave master 
dest key dest 	offset receiving 
key dest 	packet 
key dest key 	master flag 
dest key 	gaol manual 
key key dest 	failover perform 
ret key 	fast failover 
dest key dest 	without data 
key dest 	loss 
key dest key 	due asynchronous 
dest key 	master slave 
dest key dest 	replication reset 
ret val 	manual failover 
key filename linenr 	state works 
git die 	masters 
config baselen 	slavesa state 
key match regex 	manual failover 
multi replace 	cleared function 
offset offset alloc 	used initialize 
seen key 	manual failover 
key section len 	state 
filename key 	startup abort 
dot success key 	manual failover 
success length 	progress use 
quote contents size 	side effect 
offset found 	function manual 
bracket bracket offset 	failover 
offset config 	progress manual 
filename key config 	failover timed 
filename key 	abort function 
key key key 	called cluster 
store key 	cron function 
baselen quiet dot 	order 
baselen last 	forward manual 
dot key 	failover state 
store key baselen 	machine asap 
key config 	manual failover 
filename key regex 	progress start 
multi replace 	non 
ret filename buf 	zero failover 
contents contents 	already triggered 
copy begin copy 	next steps 
end line 	performed cluster 
config filename key 	handle slave 
regex multi 	failover 
replace key regex 	wait offset 
multi replace 	replication offset 
key regex multi 	matches master 
replace buf 	replication offset 
name dot name 	announced clients 
config filename 	paused 
old name name 	start failover 
filename buf 	cluster cron 
buf config 	job executed 
file length output 	times every 
offset old 	second many 
name name section 	masters 
subsection subsection 	without slaves 
len key section 	max number 
len dot 	slaves single 
getc unlocked ungetc 	master number 
ftell die 	slaves master 
config error nonbool 	slave 
expand user 	number times 
path error absolute 	function called 
path error 	far handshake 
find last dir 	timeout time 
sep strbuf 	handshake node 
strbuf addstr access 	turned 
die die 	normal node 
git config file 	removed nodes 
strbuf release 	usually node 
free strcmp 	timeout node 
handle path include 	timeout small 
getenv strbuf 	use 
addstr strbuf addch 	second check 
quote buf 	disconnected nodes 
setenv strbuf release 	establish connection 
strbuf split 	node handshake 
str error strbuf 	state limited 
setlen strbuf 	lifespan 
trim strbuf list 	equal configured 
free error 	node timeout 
strbuf tolower strbuf 	got synchronous 
list free 	error connect 
strbuf list free 	cluster send 
getenv xstrdup 	ping 
dequote argv free 	chance called 
error git 	node ping 
config parse parameter 	sent zero 
free free 	failure detection 
free free 	work claim 
fgetc fgetc ungetc 	actually 
strbuf reset 	sent ping 
next isspace strbuf 	really sent 
addch next 	soon link 
strbuf addch strbuf 	obtained queue 
addch isalnum 	ping connection 
next iskeychar strbuf 	asap 
addch tolower 	crucial avoid 
next parse isspace 	positives failure 
next strbuf 	detection node 
addch next next 	flagged meet 
strbuf addch 	send meet 
next next isspace 	message 
extended iskeychar 	instead ping 
strbuf addch tolower 	one force 
next isspace 	receiver node 
strbuf reset 	table active 
strbuf addch isalpha 	ping link 
strbuf setlen 	disconnected 
strbuf addch tolower 	want restore 
die error 	ping time 
strcasecmp strcasecmp strcasecmp 	otherwise replaced 
strtoimax parse 	cluster send 
unit factor labs 	ping call 
labs strtoumax 	clear 
parse unit factor 	flag first 
git parse 	packet sent 
maximum type git 	never receive 
parse maximum 	pong never 
type git parse 	send packets 
maximum type 	node 
die die git 	instead pong 
parse die 	received longer 
bad number git 	meet handshake 
parse die 	status want 
bad number 	send normal 
git parse die 	ping 
bad number 	packets ping 
strcasecmp strcasecmp strcasecmp 	random node 
strcasecmp strcasecmp 	time every 
strcasecmp git parse 	iterations usually 
maybe git 	ping one 
parse git parse 	random 
maybe git 	node every 
config git config 	second check 
config error 	random nodes 
nonbool xstrdup config 	ping one 
error nonbool 	oldest pong 
expand user path 	received 
die strcmp 	time ping 
git config strcmp 	nodes disconnected 
git config 	ping currently 
strcmp strcasecmp strcasecmp 	active iterate 
strcmp git 	nodes check 
config strcmp 	need 
git config strcmp 	flag something 
git config 	failing loop 
strcmp git config 	also responsible 
pathname strcmp 	check orphaned 
git config strcmp 	masters masters 
git config 	without 
strcmp git config 	non failing 
strcmp git 	slaves count 
config strcmp git 	max number 
config strcmp 	non failing 
git config strcmp 	slaves single 
git config 	master 
die strcmp git 	count number 
config die 	slaves master 
strcmp getpagesize git 	slave use 
config strcmp 	updated time 
git config strcmp 	every iteration 
git config 	orphaned 
strcmp git 	master check 
config strcmp strcasecmp 	useful current 
error git 	instance slave 
config strcmp strcasecmp 	may migrate 
git config 	another master 
strcmp strcasecmp strcasecmp 	master 
strcasecmp error 	orphaned serving 
strcmp xstrdup strcmp 	non zero 
git config 	number slots 
strcmp git config 	working slaves 
strcmp config 	used least 
error nonbool strcasecmp 	one 
error strcmp 	slave failed 
git config strcmp 	master used 
git config 	slaves waiting 
pathname strcmp config 	pong half 
error nonbool 	cluster timeout 
parse whitespace 	reconnect 
rule strcmp git 	link maybe 
config strcmp 	connection issue 
git config strcmp 	even node 
strcmp strcmp 	alive connected 
die strcmp git 	already reconnected 
config strcmp 	already 
git config strcmp 	sent ping 
git config 	still waiting 
strcmp git config 	pong waiting 
strcmp git 	pong timeout 
config strcmp git 	disconnect link 
config strcmp 	reconnected 
strcasecmp git config 	automatically currently 
strcmp config 	active ping 
error nonbool strcmp 	instance received 
strcmp strcmp 	pong older 
strcmp error strcmp 	half cluster 
config error 	timeout 
nonbool strcmp 	send ping 
strcmp strcmp strcmp 	ensure nodes 
strcmp strcmp 	pinged without 
error error strcmp 	big delay 
git config 	master one 
pathname strcmp git 	slaves 
config starts 	requested manual 
git core config 	failover ping 
starts git 	continuously check 
ident config starts 	active ping 
git config 	instance compute 
starts git branch 	delay 
config starts 	pong note 
git push config 	already received 
starts git 	pong node 
mailmap config starts 	ping sent 
git advice 	zero reach 
config strcmp strcmp 	code 
git config 	timeout reached 
strcmp git 	node possibly 
config strbuf init 	failing already 
strbuf init 	state slave 
git parse source 	node replication 
strbuf release 	still 
strbuf release config 	turned enable 
config file 	know address 
fopen flockfile config 	master appears 
file funlockfile 	abourt manual 
fclose config read 	failover timeout 
sha file 	reached 
error free error 	orphaned slaves 
git config 	slave among 
mem free sha 	masters max 
error git 	number non 
config blob sha 	failing slaves 
system path 	consider 
getenv git config 	migrating orphaned 
getenv git 	masters note 
parse die 	make sense 
git env xdg 	migration master 
config home 	least two 
expand user path 	working 
git config 	slaves function 
system access die 	called handler 
git etc 	returns sleep 
gitconfig git config 	events useful 
file git 	perform operations 
etc gitconfig access 	must 
die git 	done asap 
config file access 	reaction events 
die git 	fired safe 
config file access 	perform inside 
die git 	handlers perform 
config file git 	potentially 
config parameters 	expansive tasks 
die free 	need single 
free git config 	time replying 
stdin git 	clients handle 
config file git 	failover needed 
config blob 	likely 
git pathdup git 	already quorum 
config early 	masters order 
free git config 	react fast 
options die 	update cluster 
git die config 	state save 
linenr git 	config 
config check init 	possibly fsync 
configset iter 	reset flags 
git config parse 	strictly needed 
key hashmap 	since every 
entry init strhash 	single function 
hashmap free 	called 
xmalloc configset find 	flags able 
element xmalloc 	clear flag 
hashmap entry 	slots management 
init strhash xstrdup 	test bit 
list init 	pos bitmap 
hashmap list append 	bit 
nodup xstrdup 	otherwise bit 
alloc grow strintern 	position pos 
strcmp hashmap 	bitmap clear 
init hashmap iter 	bit position 
init hashmap 	pos bitmap 
iter next free 	slot 
list clear 	bit old 
hashmap free free 	clear slot 
configset git 	bit old 
config file git 	slot bit 
configset multi 	cluster 
configset find element 	node structure 
git configset 	specified slot 
git config git 	list slots 
configset git 	node serve 
configset git 	operation ended 
config git configset 	success 
git config 	slot already 
git configset git 	assigned another 
config git 	instance considered 
configset git config 	error err 
git configset 	returned specified 
git config maybe 	slot 
git configset 	marking unassigned 
git config pathname 	returns slot 
git configset 	assigned otherwise 
init git config 	slot already 
raw git 	unassigned err 
configset clear git 	returned 
config check 	slots associated 
init git configset 	specified node 
git config 	number deleted 
check init git 	slots returned 
configset multi 	clear migrating 
git config 	importing 
check init git 	state slots 
configset git 	useful initialization 
die config git 	turning master 
config check 	slave cluster 
init git config 	state evaluation 
git config 	function 
check init git 	following defines 
configset git 	used evaluation 
config check init 	function heuristics 
git configset 	actaully main 
git config check 	point rejoin 
init git 	writable 
configset git config 	delay orders 
check init 	magnitude larger 
git configset git 	network latency 
config check 	master node 
init git configset 	wait time 
maybe git 	turning 
config check 	state since 
init git configset 	good idea 
pathname git 	rejoin cluster 
die config git 	writable master 
config maybe 	reboot without 
git config strcasecmp 	giving 
error die 	cluster chance 
die strcmp regexec 	reconfigure node 
matches warning 	note delay 
alloc grow ftell 	calculated starting 
strrchr memcmp 	first call 
alloc grow ftell 	function 
matches alloc 	since server 
grow ftell strrchr 	start order 
strncmp alloc 	count loading 
grow ftell error 	time start 
memchr strbuf 	assuming state 
addf strbuf 	turn 
addch strbuf addch 	fail right 
strbuf addstr 	conditions check 
strbuf addf write 	slots covered 
full strbuf 	compute cluster 
release strlen strbuf 	size number 
addf strbuf 	master 
addstr strbuf addstr 	nodes serving 
strbuf addch 	least single 
strbuf addch strbuf 	slot time 
addf write 	count number 
full strbuf release 	reachable masters 
git config 	least 
multivar file gently 	one slot 
git config 	minority partition 
multivar file git 	change cluster 
config multivar 	state fail 
gently git config 	log state 
multivar strrchr 	change 
error error 	instance master 
xmallocz strlen iskeychar 	partitioned away 
isalpha error 	minority accept 
tolower error free 	queries time 
git config 	partition heals 
parse key git 	make 
config parse 	sure enough 
key git config 	time receive 
parse key 	configuration update 
git pathdup xcalloc 	change state 
hold file 	log function 
update error strerror 	called 
free open 	node startup 
free error strerror 	order verify 
store write 	data loaded 
section store write 	disk agreement 
pair xmalloc 	cluster configuration 
regcomp error free 	find 
alloc grow 	keys hash 
git config 	slots responsibility 
file error free 	following happens 
regfree free 	node charge 
free regfree free 	according current 
fstat xsize 	cluster 
xmmap gently isdir 	configuration slots 
error strerror 	node according 
close chmod file 	config nodes 
path error 	already charge 
file path strerror 	lots slots 
find beginning 	importing 
line write full 	point view 
write str 	order justify 
full store write 	slots order 
section store 	make redis 
write pair write 	trib aware 
full munmap 	issue 
commit file error 	fix find 
strerror git 	data different 
config clear 	err signal 
rollback file free 	caller quit 
munmap close 	server error 
write error file 	message 
path git 	take actions 
config multivar file 	function always 
gently die 	returns even 
git config multivar 	correct error 
file gently 	described however 
git config multivar 	data 
file isspace 	found different 
isspace isspace isspace 	err returned 
isalnum section 	function also 
name error git 	uses logging 
pathdup xcalloc 	facility order 
hold file update 	warn 
error fopen 	user desynchronizations 
fstat fileno 	data memory 
chmod file path 	cluster configuration 
error file 	node slave 
path strerror fgets 	perform check 
isspace section 	completely 
name match strlen 	depend replication 
store write 	stream make 
section write error 	sure keys 
file path 	check slots 
strlen strlen write 	see populated 
full write 	memory 
error file path 	corresponding entry 
fclose commit 	cluster table 
file error strerror 	otherwise fix 
free git 	table keys 
config rename section 	slot check 
file error 	assigned 
strlen starts strrchr 	slot importing 
git information 	cases check 
manager hell 	next slot 
copyright linus torvalds 	configuration makes 
copyright johannes 	sense data 
schindelin config contains 	cluster 
key pairs 	config agree 
usual config config 	slot populated 
files repo 	even importing 
specific git config 	assigned slot 
user wide 	fix condition 
gitconfig xdg config 	slot 
file etc 	unassigned take 
gitconfig use absolute 	responsibility slave 
path interpret 	nodes handling 
relative paths including 	specified node 
config file 	master node 
pass along values 	node 
including include 	currently master 
directives makes possible 	turned slave 
query information 	nodes representation 
includes dequote 	functions concatenate 
write dos like 	comma separated 
systems characters 	list 
escape reject unknown 	node flags 
escape sequences 	given sds 
full name already 	trailing comma 
consumed need 	generate csv 
linenr point line 	alike representation 
parsed call 	specified 
accurate line number 	cluster node 
error messages 	see cluster 
require format extension 	gen nodes 
feff order 	description top 
mark utf file 	comment information 
beginning skip 	function 
utf encoded bom 	returns representation 
present sane 	sds node 
editors won put 	coordinates flags 
windows notepad 	slave latency 
happily tolerate 	pov node 
bom bom file 	config 
beginning cool 	epoch link 
reset prior determining 	status slots 
stem truncate 	served instance 
name back section 	node also 
header stem 	dump info 
prior grabbing suffix 	slots 
part name 	migrating instances 
needs better name 	importing instances 
must multiple 	generate csv 
pagesize config variables 	alike representation 
documentation config 	nodes aware 
txt config variables 	including 
documentation config 	node sds 
txt config variables 	containing representation 
documentation config 	caller free 
txt deprecated 	nodes matching 
config variables documentation 	least one 
config txt 	node 
config variables documentation 	flags specified 
config txt 	filter excluded 
config variables documentation 	output zero 
config txt 	filter include 
source specific fields 	known nodes 
die error 	representation 
name callbacks fgetc 	including nodes 
ungetc ftell 	handshake state 
top need initialized 	representation obtained 
calling function 	function used 
push config file 	output cluster 
parsing state 	nodes 
stack pop config 	function format 
file parsing 	cluster configuration 
state stack parse 	file nodes 
environment variable 	conf given 
various possible 	node cluster 
spellings missing use 	command 
def parse 	format start 
environment variable possibly 	slot end 
unit suffix 	slot master 
missing use val 	master port 
error found 	node replica 
nothing found least 	replica 
one item 	port node 
specific filename use 	continued done 
otherwise follow 	skip slaves 
regular lookup sequence 	iterated producing 
git config 	output master 
options normally returns 	masters 
positive values 	serving slot 
errors fatal non 	slots master 
fatal potential 	addr slot 
errors guarded statements 	exists output 
entered error 	map list 
possible ever 	create 
encounter non fatal 	output map 
error means 	slot one 
something went really 	slot low 
wrong stop 	high low 
immediately key may 	high first 
come user 	node 
normalize querying entries 	reply position 
hashmap since 	always master 
keys fed git 	remaining nodes 
config callback 	reply replicas 
mechanism already normalized 	slot range 
simply without 	loop 
munging values read 	copy pasted 
git config 	cluster gen 
parameters follows last 	node description 
one wins 	modifications per 
semantic multiple matches 	slot node 
queried key 	aggregation 
files configset 	cluster nodes 
returned last list 	cluster myid 
key hack 	cluster slots 
test programs like 	cluster flushslots 
test dump 	cluster addslots 
untracked cache find 	slot 
stuff git 	slot cluster 
config always matches 	delslots slot 
never matches 	slot check 
looking store key 	arguments parseable 
section section 	slots already 
part baselen found 	busy 
key section 	slot importing 
would want know 	clear state 
key section 	real owner 
looking already know 	slot setslot 
section hold 	migrating node 
store key increment 	setslot 
matches match 	importing node 
made sure 	setslot stable 
desired section fallthru 	setslot node 
error code 	node cluster 
failed rename check 	setslot slot 
see needs 	stable 
surrounded pair note 	cluster setslot 
problematic characters 	slot node 
always backslash quoted 	node hash 
check losing 	slot served 
leading trailing follow 	make sure 
beginning comment 	longer 
characters configuration parser 	local keys 
auxiliary function 	hash slot 
sanity check split 	slot migrating 
key section 	status keys 
variable name returns 	assigning slot 
success invalid 	another 
character key 	node clear 
section name key 	migratig status 
store key 	node importing 
pointer hold copy 	slot assigning 
key lowercase 	slot also 
section variable name 	clears 
baselen pointer 	importing status 
hold length section 	slot manually 
subsection part 	migrated node 
since key actually 	config epoch 
contains section 	epoch version 
name real key 	propagated 
name separated 	cluster note 
dot know dot 	ever results 
validate key 	collision another 
lower matching extended 	node getting 
basename untouched 	config epoch 
unset config regex 	example 
disregard key 	failover happens 
pairs match 	time close 
regex config regex 	slot config 
none match 	epoch collision 
existing values one 	resolution fix 
multi replace 	assigning 
nothing one matching 	different epoch 
key replaced 	node cluster 
matching key values 	bumpepoch cluster 
regardless many 	info cluster 
removed pair written 	keyslot key 
returns success 	cluster 
function locks config 	countkeysinslot slot 
file creating 	cluster getkeysinslot 
git config parses 	slot count 
config store 	cluster forget 
aux validator find 	node cluster 
position key 	replicate 
pair replace unset 	node lookup 
must found 	specified node 
exactly config 	table replicate 
file mmap part 	replicate slave 
match written 	instance currently 
file changed part 	master 
rest config 	assigned slots 
file removed file 	keys accept 
rename parse 	replicate node 
key returns negative 	slaves another 
flip sign 	master without 
feed exit serves 	issues 
purpose addition 	master cluster 
locking contents git 	slaves node 
config written 	lookup specified 
git config exist 	node table 
yet write 	cluster count 
minimal version invalid 	failure 
config file 	reports node 
nothing unset error 	cluster failover 
store offset 	force takeover 
contain end 	takeover also 
offset last match 	implies force 
remain match 	check 
found side effect 	preconditions takeover 
make sure 	perform initial 
transform valid existing 	check generates 
config file 	configuration epoch 
nothing unset many 	node without 
matches error 	consensus 
write first part 	claims master 
config write 	slots broadcast 
pair means unset 	configuration forced 
write rest 	failover need 
config committed roll 	talk master 
back note 	agree 
since lockfile keeps 	offset failover 
linked list 	taking without 
created file 	coordination cluster 
structures isn safe 	config epoch 
free better 	epoch user 
hanging around invalidate 	allowed 
config cache 	config epoch 
nothing nothing match 	node totally 
find right 	fresh config 
length offset gobbling 	epoch known 
whitespace well 	node forth 
nothing empty section 	happens 
names bogus 	cluster creation 
dot must alphanumeric 	time start 
dash first 	cluster every 
dot anything goes 	node different 
stop checking 	node without 
name section removed 	rely 
instead config 	conflicts resolution 
file means nothing 	system slow 
rename error 	big cluster 
nothing section 	created need 
wrote section newline 	fsync config 
skip old 	since 
section length content 	unlucky failure 
means declaration 	persist config 
put next line 	conflict resolution 
indent tab 	code assign 
call report error 	unique config 
variable means 	node 
start section find 	cluster reset 
key know 	soft hard 
yet subsection must 	parse soft 
parse backwards 	hard argument 
end since subsection 	soft slaves 
may dots 	reset 
subsection use fwrite 	containing data 
buf contain 	master nodes 
end show key 	must empty 
name back 	dump restore 
delimiter needswork 	migrate commands 
naive pattern lowercasing 	generates 
obviously work 	dump format 
complex patterns like 	representation adding 
foo bar 	stream pointed 
perhaps deprecate altogether 	rio function 
someday normalization 	fail serialize 
type path path 	rdb 
like foobar 	like format 
prefer store foobar 	consist type 
config file 	followed serialized 
expand retrieving none 	understood restore 
found config 	write footer 
unknown home gitconfig 	looks 
exists know 	like rdb 
write xdg location 	payload bytes 
error even 	rdb version 
xdg config home 	bytes crc 
points sane 	rdb version 
location builtin 	crc 
config usage key 	little endian 
key regexp 	rdb version 
regexp show keys 	crc verify 
omit values 	rdb version 
use key regexp 	dump 
match delim 	payload matches 
key delim term 	one redis 
use config 	instance checksum 
use system config 	dump payload 
use local 	looks valid 
config given config 	returned 
source actions 	otherwise err 
types color slot 	returned least 
colorbool slot 	bytes rdb 
end respect includes 	version crc 
show origin 	present verify 
builtin config 	rdb 
options argc min 	version verify 
max buf 	crc dump 
term key buf 	keyname dump 
items alloc 	actually used 
buf key key 	redis cluster 
values key 	obvious 
regex ret values 	complement restore 
buf key 	useful different 
color found color 	applications check 
slot colorbool 	key create 
slot parsed color 	dump encoded 
def color 	representation 
colorbool found diff 	transfer client 
color found 	restore key 
color found print 	ttl serialized 
values item 	replace parse 
matched url section 	additional options 
tail item 	make 
config values 	sure key 
matched buf buf 	already exist 
argc argv 	check ttl 
prefix nongit user 	makes sense 
config xdg 	verify rdb 
config config file 	version 
content ret 	data checksum 
ret ret error 	old key 
usage options 	needed create 
strbuf addstr current 	key ttl 
config origin 	migrate socket 
type strbuf addch 	cache 
strbuf addstr 	implementation take 
current config name 	map host 
quote style 	tcp socket 
current config name 	used connect 
strbuf addch 	instance recent 
show config origin 	time 
fwrite strbuf 	sockets closed 
release show 	max number 
config origin strbuf 	cache reached 
addstr strbuf 	also server 
addch strbuf addf 	cron around 
git config 	seconds 
strbuf addstr git 	max num 
config git 	items cache 
config strbuf addstr 	close cached 
strbuf addf 	sockets sec 
git config pathname 	migrate cached 
strbuf addstr 	socket 
free strbuf addstr 	containing tcp 
strbuf setlen 	socket connected 
strbuf addch strcmp 	target instance 
regexec regexec 	possibly returning 
alloc grow strbuf 	cached one 
init format 	function 
config xstrdup strlen 	responsible sending 
tolower tolower 	errors client 
xmalloc regcomp 	connection established 
error free git 	returned otherwise 
config parse 	success socket 
key xmalloc regcomp 	returned 
error free 	caller attempt 
git config options 	free usage 
fwrite strbuf 	caller detects 
release free free 	error socket 
regfree free 	migrate close 
regfree free xstrdup 	socket 
xstrfmt git 	called connection 
config xstrdup git 	created scratch 
config git 	next time 
config xstrfmt xstrdup 	check already 
die strcmp 	cached socket 
config error nonbool 	port 
color parse 	pair cached 
git config options 	socket create 
color parse 	one many 
die fputs 	items drop 
strcmp git config 	one random 
colorbool strcmp 	create 
git config colorbool 	socket check 
strcmp git 	connects within 
config colorbool git 	specified timeout 
config options 	cache caller 
strcmp want color 	free migrate 
die die 	cached 
die list insert 	connection migrate 
xmalloc strbuf 	host port 
init strbuf reset 	key dbid 
strbuf addstr 	timeout copy 
url normalize die 	replace multiple 
xstrdup tolower 	keys 
strchr git config 	form migrate 
options format 	host port 
config fwrite 	dbid timeout 
strbuf release strbuf 	copy replace 
release list 	keys key 
clear list clear 	key 
free free 	key objects 
strbuf addf ident 	migrate key 
name ident 	names used 
email strbuf detach 	rewrite command 
getenv parse 	del keys 
options error usage 	support 
options strcmp 	keys option 
expand user path 	need following 
xdg config 	additional state 
home die access 	argument index 
warn access 	first key 
warn git etc 	migrate 
gitconfig git 	key argument 
pathdup absolute path 	initialization parse 
xstrdup prefix 	additional options 
filename strlen 	remaining args 
multi bits error 	keys sanity 
usage options 	check 
error usage options 	check keys 
multi bits 	least one 
error usage options 	key migrate 
usage options 	otherwise keys 
error usage options 	missing reply 
error usage 	nokey 
options check argc 	signal caller 
git config 	nothing migrate 
options die errno 	error since 
die check 	often due 
argc die die 	normal condition 
die git 	like 
config xstrdup git 	key expiring 
path open 	meantime connect 
user config write 	error sent 
str full 	client migrate 
free close 	socket send 
die errno launch 	command 
editor free 	current already 
check write check 	selected emit 
argc normalize 	create restore 
git config file 	payload generate 
gently error 	protocol call 
check write check 	command 
argc normalize 	emit payload 
git config multivar 	argument serialized 
file gently 	dump format 
check write check 	replace option 
argc normalize 	restore command 
git config multivar 	specified 
file gently 	migrate option 
check write check 	transfer query 
argc normalize 	node chunks 
git config multivar 	reply restore 
file gently 	reply read 
check argc 	reply 
check argc check 	needed read 
argc check 	restore replies 
argc urlmatch check 	index key 
write check 	argument replicated 
argc git config 	del error 
multivar file 	last 
gently git config 	dbid longer 
file gently 	valid copy 
check write check 	option local 
argc git 	key signal 
config multivar file 	change populate 
gently check 	argument 
write check argc 	vector replace 
git config 	old one 
rename section file 	socket error 
die check 	want retry 
write check 	rewriting command 
argc git config 	vector 
rename section 	retry sure 
file die check 	nothing processed 
argc color 	failed read 
check argc git 	first reply 
config colorbool 	test retry 
git information manager 	guaranteed 
hell copyright 	tested conditions 
linus torvalds copyright 	translate migrate 
johannes schindelin 	del replication 
config contains key 	aof note 
pairs usual 	following call 
config config files 	takes 
repo specific 	ownership newargv 
git config user 	key transfer 
wide gitconfig 	acknowledged need 
xdg config file 	rewrite del 
etc gitconfig 	make safe 
use absolute 	call 
path interpret relative 	zfree future 
paths including 	socket error 
config file pass 	happened want 
along values 	retry signal 
including include directives 	problem client 
makes possible 	already 
query information includes 	queued different 
dequote write 	error reported 
dos like systems 	destination server 
characters escape 	success update 
reject unknown escape 	last dbid 
sequences full 	migrate 
name already consumed 	cached socket 
need linenr 	avoid next 
point line parsed 	time target 
call accurate 	reply error 
line number error 	already sent 
messages require 	loop 
format extension 	curretly selected 
feff order mark 	socket force 
utf file 	next time 
beginning skip utf 	socket errors 
encoded bom 	close cached 
present sane editors 	socket 
won put 	common cached 
windows notepad happily 	socket closed 
tolerate bom 	reopening works 
bom file beginning 	shame notify 
cool reset 	error caller 
prior determining stem 	cleanup 
truncate name 	want perform 
back section header 	retry retry 
stem prior 	note closing 
grabbing suffix part 	migrate socket 
name needs 	also force 
better name must 	next 
multiple pagesize 	time reallocated 
config variables 	retry retry 
documentation config txt 	timeout never 
config variables 	attempted retry 
documentation config txt 	code jumping 
config variables 	may 
documentation config txt 	retry zero 
deprecated config 	cleanup want 
variables documentation config 	retry attempted 
txt config 	cluster functions 
variables documentation config 	related serving 
txt config 	redirecting 
variables documentation config 	clients asking 
txt source 	command required 
specific fields die 	ask redirection 
error name 	client issue 
callbacks fgetc ungetc 	asking actually 
ftell top 	send 
need initialized 	command target 
calling function push 	instance see 
config file 	redis cluster 
parsing state stack 	specification information 
pop config 	command used 
file parsing state 	clients 
stack parse 	enter read 
environment variable various 	mode mode 
possible spellings 	slaves redirect 
missing use def 	clients clients 
parse environment 	access read 
variable possibly unit 	commands 
suffix missing 	keys served 
use val error 	slave master 
found nothing 	readwrite command 
found least one 	clears command 
item specific 	state pointer 
filename use otherwise 	cluster 
follow regular 	node able 
lookup sequence 	serve command 
git config options 	function succeed 
normally returns 	command target 
positive values errors 	either single 
fatal non 	key 
fatal potential errors 	even multiple 
guarded statements 	times like 
entered error possible 	lpoprpush mylist 
ever encounter 	mylist multiple 
non fatal error 	keys hash 
means something 	slot 
went really wrong 	slot stable 
stop immediately 	resharding progress 
key may come 	success function 
user normalize 	returns node 
querying entries hashmap 	able serve 
since keys 	request 
fed git config 	node redirection 
callback mechanism 	must perfomed 
already normalized 	kind redirection 
simply without munging 	specified setting 
values read 	integer passed 
git config parameters 	reference 
follows last 	error code 
one wins semantic 	cluster redir 
multiple matches 	ask cluster 
queried key files 	redir moved 
configset returned 	node error 
last list key 	code 
hack test 	cluster redir 
programs like test 	none command 
dump untracked 	fails returned 
cache find stuff 	reason failure 
git config 	provided via 
always matches never 	error 
matches looking 	code cluster 
store key section 	redir cross 
section part 	slot request 
baselen found 	contains multiple 
key section would 	keys belong 
want know 	hash 
key section looking 	slot cluster 
already know 	redir unstable 
section hold store 	request contains 
key increment 	multiple keys 
matches match made 	belonging slot 
sure desired 	slot 
section fallthru error 	stable migration 
code failed 	importing state 
rename check see 	likely resharding 
needs surrounded 	progress cluster 
pair note problematic 	redir unbound 
characters always 	request 
backslash quoted check 	addresses slot 
losing leading 	bound node 
trailing follow beginning 	cluster state 
comment characters 	already fragile 
configuration parser 	rely update 
auxiliary function sanity 	state 
check split 	also handle 
key section variable 	error code 
name returns 	optimistically handle 
success invalid character 	cases exec 
key section 	commands common 
name key store 	code 
key pointer 	path everything 
hold copy key 	client multi 
lowercase section 	flag exec 
variable name baselen 	going error 
pointer hold 	order single 
length section subsection 	codepath 
part since 	create fake 
key actually contains 	multi state 
section name 	structure client 
real key 	multi exec 
name separated dot 	state way 
know dot 	single 
validate key lower 	codepath check 
matching extended 	keys hash 
basename untouched unset 	slot obtain 
config regex 	slot node 
disregard key pairs 	associated first 
match regex 	key 
config regex none 	see check 
match existing 	slot node 
values one multi 	error slot 
replace nothing 	served cluster 
one matching key 	state however 
replaced matching 	state 
key values regardless 	yet updated 
many removed 	trapped earlier 
pair written returns 	process command 
success function 	report error 
locks config 	client migrating 
file creating git 	importing 
config parses 	slot need 
config store aux 	check keys 
validator find 	request way 
position key pair 	safely serve 
replace unset 	request otherwise 
must found exactly 	tryagain 
config file 	error importing 
mmap part match 	migrating state 
written file 	increment counter 
changed part rest 	every missing 
config file 	key first 
removed file rename 	key 
parse key 	make sure 
returns negative flip 	exactly key 
sign feed 	first saw 
exit serves purpose 	error multiple 
addition locking 	keys different 
contents git 	slots 
config written git 	flag request 
config exist 	one multiple 
yet write minimal 	different keys 
version invalid 	migarting improrting 
config file nothing 	slot count 
unset error 	keys 
store offset contain 	key command 
end offset 	serve request 
last match remain 	without redirections 
match found 	errors hashslot 
side effect make 	reference migrate 
sure transform 	always 
valid existing config 	works context 
file nothing 	local node 
unset many matches 	slot open 
error write 	migrating importing 
first part config 	state need 
write pair 	able 
means unset 	freely move 
write rest config 	keys among 
committed roll 	instances keys 
back note since 	migrating slot 
lockfile keeps 	send ask 
linked list created 	redirection 
file structures 	receiving slot 
isn safe free 	client correctly 
better hanging 	flagged request 
around invalidate config 	asking serve 
cache nothing 	request however 
nothing match find 	request 
right length 	involves multiple 
offset gobbling whitespace 	keys option 
well nothing 	send tryagain 
empty section names 	error handle 
bogus dot 	read client 
must alphanumeric 	reading 
dash first dot 	slave node 
anything goes 	slave request 
stop checking name 	hash slot 
section removed 	master serving 
instead config file 	reply without 
means nothing 	redirection 
rename error nothing 	right node 
section wrote 	however node 
section newline skip 	error code 
old section 	moved since 
length content means 	need issue 
declaration put 	rediretion 
next line indent 	send client 
tab call 	right redirection 
report error variable 	code according 
means start 	error code 
section find key 	one 
know yet 	cluster redir 
subsection must 	macros cluster 
parse backwards end 	redir ask 
since subsection 	cluster redir 
may dots subsection 	moved error 
use fwrite 	codes 
buf contain end 	used node 
show key 	node want 
name back delimiter 	mention redirection 
needswork naive 	moreover hashslot 
pattern lowercasing obviously 	hash slot 
work complex 	caused 
patterns like foo 	redirection request 
bar perhaps 	spawns mutliple 
deprecate altogether someday 	keys slot 
normalization type 	slot stable 
path path like 	currently migration 
foobar prefer 	progress 
store foobar config 	function called 
file expand 	function processing 
retrieving none 	clients incrementally 
found config unknown 	detect timeouts 
home gitconfig 	order handle 
exists know write 	following 
xdg location 	client blocks 
error even xdg 	blpop similar 
config home 	blocking operation 
points sane location 	master migrates 
connect.c server 	hash slot 
capabilities name flags 	elsewhere 
flags got 	turns slave 
least one head 	client may 
symref val 	remain blocked 
len sym target 	forever max 
item symref 	timeout time 
feature list len 	waiting 
val item 	key change 
src buf src 	never happen 
len list 	client found 
flags extra 	blocked hash 
shallow points orig 	slot node 
list got 	longer 
least one head 	handles client 
old oid 	sent redirection 
name len name 	error function 
len buffer 	returns otherwise 
arg feature list 	returned operation 
feature lenp 	performed 
len found feature 	cluster unblock 
list feature 	client right 
feature len feature 	error send 
url colon 	error unblock 
slash prot name 	client slot 
hoststart removebrackets 	unassigned 
host end start 	emitting cluster 
host port 	error slot 
colon end 	handled node 
portnr sockfd addr 	imported cluster.h 
host flags 	gossip msg 
error message sockfd 	nodecfg 
port hints 	cmd argv 
gai cnt host 	argc hashslot 
flags error 	ask hashslot 
message sockfd port 	error code 
nport cnt 	redis cluster 
host flags sockfd 	data 
git proxy 	structures defines 
command pos matchlen 	exported api 
hostlen rhost 	everything looks 
name rhost len 	cluster work 
host host 	sha hex 
port proxy host 	length 
end port 	cluster port 
fork url prog 	baseport port 
flags hostandport 	incr following 
path conn 	defines amount 
cmd target host 	time sometimes 
ssh tortoiseplink 	expressed 
ssh host port 	multiplicators node 
ssh dup 	timeout ending 
conn conn code 	mult slave 
skip prefix 	max data 
check refname format 	age factor 
starts starts 	fail 
check die die 	report validity 
xmemdupz strchr 	undo fail 
check refname format 	master back 
check refname 	additional time 
format list append 	seconds milliseconds 
free parse 	manual 
feature parse one 	failover master 
symref info 	pause manual 
list sort list 	failover mult 
lookup xstrdup 	delay slave 
list clear 	migration redirection 
packet read die 	errors 
initial contact 	returned node 
skip prefix die 	query node 
strlen skip 	serve request 
prefix oid hex 	crossslot request 
die die 	tryagain redirection 
sha append oid 	required 
hex die 	ask redirection 
strlen free xstrdup 	required moved 
strcmp sha 	redirection required 
append check alloc 	clusterdown state 
oidcpy annotate 	clusterdown unbound 
refs symref info 	slot 
strlen strstr 	cluster link 
isspace isspace strcspn 	encapsulates everything 
parse feature 	needed talk 
parse feature server 	remote node 
feature strchr 	link creation 
strchr dos 	time 
drive prefix strcmp 	tcp socket 
strcmp strcmp 	file descriptor 
strcmp die strstr 	packet send 
strchr memmove 	buffer packet 
host end strchr 	reception buffer 
strtol setsockopt 	node 
strerror getnameinfo xsnprintf 	related link 
str host 	cluster node 
port memset getaddrinfo 	flags macros 
die gai 	node master 
strerror socket connect 	node slave 
strbuf addf 	failure 
name strerror close 	need acknowledge 
name freeaddrinfo 	node believed 
die enable keepalive 	malfunctioning node 
strbuf release 	still exchange 
str host port 	first ping 
gethostbyname die 	know 
hstrerror strtoul 	address node 
getservbyname die memset 	send meet 
htons memcpy 	message node 
socket connect strbuf 	master elegible 
addf inet 	replica migration 
ntoa strerror close 	reasons 
inet ntoa 	slave able 
die enable keepalive 	failover seconds 
git tcp 	structure represent 
connect sock dup 	elements node 
strcmp strlen 	fail reports 
config error nonbool 	node 
strstr strlen 	reporting failure 
strlen strncmp memcmp 	condition time 
xmemdupz git 	last report 
config getenv git 	node node 
config str 	creation time 
host port 	node 
xmalloc child process 	name hex 
init argv 	sha size 
push argv push 	cluster node 
argv push 	last config 
start command die 	epoch observed 
strchr strtol 	node 
protocol url local 	slots handled 
ssh host 	node number 
end dos drive 	slots handled 
prefix strchr 	node number 
die xstrdup xstrdup 	slave nodes 
free signal 	master 
parse connect url 	pointers slave 
prot name 	nodes pointer 
getenv xstrdup xstrdup 	master node 
transport check 	note may 
allowed git use 	even node 
proxy git 	slave 
proxy connect 	master node 
git tcp connect 	tables unix 
packet write 	time sent 
free xmalloc child 	latest ping 
process init 	unix time 
strbuf addstr strbuf 	received 
addch quote 	pong unix 
buf transport check 	time fail 
allowed host 	flag last 
port port prot 	time voted 
name free 	slave master 
free free getenv 	unix 
getenv xstrdup 	time received 
basename strcasecmp strcasecmp 	offset node 
strcasecmp strcasecmp 	starting time 
free argv push 	orphaned master 
argv push 	condition last 
argv push argv 	known 
push argv 	repl offset 
push argv 	node latest 
push argv push 	known address 
transport check 	node latest 
allowed argv push 	known port 
start command 	node 
die strbuf release 	tcp link 
free free 	node list 
git connection socket 	nodes signaling 
finish command 	failing node 
free normal means 	cluster cluster 
want magic 	fail 
fake tag refs 	num master 
heads means 	nodes least 
want regular branch 	one slot 
heads tags 	hash table 
means want tags 	name cluster 
type bits 	node 
clear means anything 	structures nodes 
symref symref 	seconds following 
head refs 	fields used 
heads master symref 	take slave 
something symref 	state elections 
bogus pair read 	time 
refs end 	previous next 
feature thin pack 	election number 
feature agent 	votes received 
git otherwise matched 	far already 
substring another 	asked votes 
feature keep looking 	slave 
deprecated use 	rank current 
deprecated use jump 	auth request 
returns connected 	epoch current 
socket die ipv 	election slave 
returns connected 	currently able 
socket die numeric 	failover 
ipv core 	see cant 
matches www 	failover macros 
kernel well gitproxy 	manual failover 
netcatter kernel 	state common 
gitproxy netcatter sample 	manual failover 
gitproxy netcatter 	time 
matches everybody core 	limit unixtime 
gitproxy none 	zero progress 
kernel read proxy 	manual failover 
stdout write 	state master 
proxy stdin extract 	slave performing 
protocol relevant 	manual 
parts specified connection 	failover manual 
url caller 	failover state 
must free returned 	slave master 
destructive transforms 	offset slave 
protocol code unwrapping 	needs start 
host port 	zero 
file pwd may 	stil received 
file projects 	non zero 
repo terminate 	signal manual 
hostname point path 	failover start 
url like 	requesting masters 
ssh host user 	vote 
repo need 	followign fields 
terminate host path 	used masters 
starts returns 	take state 
dummy child process 	elections epoch 
transport protocol 	last vote 
need fork child 	granted 
process done 	things cluster 
finish connection finish 	sleep num 
connect returned 	msg sent 
function safe call 	via cluster 
finish connect 	bus num 
support former returns 	msg 
connect successful 	rcvd via 
dies errors hopefully 	cluster bus 
changed libification 	cluster state 
effort connection 	todo sleep 
failed without cannot 	flags redis 
rely waitpid 	cluster 
tell happened children 	messages header 
host information 	note ping 
connect unless user 	pong meet 
overridden environment 	messages actually 
underlying connection commands 	exact kind 
die cannot 	packet 
connect separate original 	pong reply 
protocol components 	ping exact 
prog path extended 	format ping 
host header 	meet special 
nul note headers 	ping forces 
cause older 	receiver 
git daemon servers 	sender node 
crash repo 	already list 
local variables environment 	ping pong 
git ssh 	reply ping 
shell version 	meet message 
git ssh command 	mark 
must remain 	node xxx 
historical compatibility tty 	failing pub 
open ssh 	sub publish 
read child stdout 	propagation may 
write child 	failover yes 
stdin connect.h url 	vote 
prog flags 	another node 
conn conn feature 	slots configuration 
features feature 	pause clients 
feature len ret 	manual failover 
url connected.c 	initially know 
quiet data quiet 	name 
data transport 	find connect 
shallow file rev 	first node 
list argv 	getsockname function 
commit sha 	use address 
pack len idx 	next messages 
file quiet 	address 
data transport quiet 	last time 
data shallow 	seen port 
file check everything 	last time 
connected transport 	seen node 
strip suffix strbuf 	flags copy 
strbuf addstr 	room 
packed git strbuf 	future improvements 
release start 	reclare bulk 
command error sigchain 	data bulk 
push find 	data since 
pack entry one 	structure nested 
memcpy sha 	bytes 
hex write full 	removed count 
error strerror 	message length 
close error strerror 	computation config 
sigchain pop 	epoch specified 
finish command 	instance name 
check everything connected 	slots 
real check 	owner slots 
everything connected real 	bitmap ping 
feed commits 	meet pong 
want verify command 	cluster msg 
git rev 	data gossip 
list objects stdin 	structures 
error means 	fail publish 
everything reachable commits 	update cluster 
locally exists 	bus protocol 
connected existing refs 	version siganture 
note validate 	cmb redis 
individual objects returns 	cluster 
everything connected 	message bus 
non zero otherwise 	total length 
index pack 	message protocol 
already dangling pointers 	version currently 
pack pack 	bytes used 
self contained 	message 
updated pack sure 	type used 
good sending 	kind messages 
rev list verification 	epoch accordingly 
connected.h quiet 	sending node 
data quiet data 	config epoch 
shallow file 	master 
quiet data transport 	last epoch 
take callback 	advertised master 
data next name 	slave master 
buffer called 	replication offset 
returning name last 	node master 
signal eof 	processed 
otherwise make sure 	replication offset 
store commits 	node slave 
necessary connect ancestry 	name sender 
chain existing 	node bytes 
refs trees blobs 	reserved future 
commits use 	usage 
non zero 	sender tcp 
otherwise missing objects 	port sender 
connected convert-objects.c 	node flags 
old sha sha 	cluster state 
converted convert 	pov sender 
convert sha sha 	message 
pos sha 	flags clustermsg 
high next cmp 	flag message 
buffer entry 	flags better 
buffer sha entry 	specify packet 
mode newmode 	content used 
buffer size baselen 	provide 
result sha 	information node 
newlen used len 	state master 
path sha 	paused manual 
mode slash origpath 	failover give 
buffer size 	ack auth 
result sha orig 	request 
buffer orig 	even master 
size len 	api exported 
buf buffer formats 	outside cluster 
timezones fmt 	cluster config.c 
next dst buf 	maxmemory policy 
size line 	syslog 
next date len 	facility loglevel 
datelen buffer 	supervised mode 
size result sha 	aof fsync 
newlen buffer 	client buffer 
size result sha 	limits defaults 
orig buffer 	name 
orig size sha 	val val 
entry buffer 	name seconds 
data size argc 	changes config 
argv sha 	err totlines 
entry xcalloc hashcpy 	slaveof linenum 
memmove die 	lines 
hashcmp insert 	argv argc 
convert entry hashcpy 	addresses seconds 
sha hex 	changes logfp 
die convert entry 	size yes 
memcpy sha 	cmd retval 
hex isreg xmalloc 	copy 
strlen strchr 	hard soft 
strtoul die convert 	soft seconds 
mode memcmp 	flags filename 
strchr sprintf hashcpy 	options config 
sprintf write 	buf err 
subdirectory write sha 	orig 
file free 	enable vlen 
strlen convert binary 	eptr val 
sha die 	seconds changes 
write subdirectory isspace 	vlen val 
memset strptime 	hard soft 
mktime isspace memcmp 	soft 
strlen strlen 	seconds flags 
mktime strchr 	replylen pattern 
strchr die memcpy 	buf matches 
isdigit memcpy 	buf buf 
strchr strchr sprintf 	buf buf 
parse oldstyle 	buf 
date xmalloc memcpy 	flagsobj aux 
memcmp memcpy 	key privdata 
convert date line 	key key 
convert date 	privdata val 
line memcpy write 	privdata val 
sha file 	state 
free memcmp die 	option line 
convert ascii 	dict type 
sha memcmp convert 	option dict 
ascii sha 	type option 
convert date lookup 	line rewritten 
entry read 	numlines 
sha file die 	lines tail 
sha hex 	state line 
xmalloc memcpy 	state option 
write sha file 	linenum state 
convert convert 	option 
commit die sha 	opt path 
hex free 	state buf 
free setup git 	linenum argc 
directory usage 	argv line 
sha die convert 	aux state 
entry sha 	option 
hex ever two 	line force 
timezones bad 	linenum buf 
old format already 	len bytes 
format hacky 	state option 
hacky one sparse 	defvalue buf 
old style 	force 
commits date fake 	line state 
committer date 	option defvalue 
sha parent sha 	force line 
author xyz 	state option 
xyz date 	defvalue force 
committer xyz xyz 	line 
date rest 	state option 
hex sha convert.c 	defvalue force 
nul lonecr 	line state 
lonelf crlf printable 	option defvalue 
nonprintable buf 	force line 
size stats size 	state 
stats data 	option defval 
size stats ret 	line name 
data size 	force state 
convert stats path 	force option 
ret data 	line state 
path ret check 	line 
safe crlf 	state cwd 
path data crlf 	state option 
git crlf 	line state 
worktree src 	force option 
size cmd path 	line flags 
data child 	state 
process write err 	option force 
status argv 	line hard 
cmd path dict 	soft state 
path src 	force line 
len dst cmd 	addresses option 
ret nbuf 	state 
name next smudge 	content empty 
clean required 	state state 
key name namelen 	option linenum 
drv size 	configfile content 
cnt path src 	retval padding 
len buf 	content 
ident dst dollar 	padded path 
path src 	state newcontent 
len buf ident 	retval strcasecmp 
sha dollar 	config name 
spc cnt 	config name 
check drv check 	unknown 
drv ident 	strcasecmp strcasecmp 
conv attr name 	zrealloc zfree 
path ccheck 	sdssplitlen strlen 
path path convert 	sdstrim sdssplitargs 
git convert 	sdsfreesplitres sdstolower 
git filter path 	strcasecmp 
src len 	atoi strcasecmp 
dst normalizing ret 	atoi strcasecmp 
filter filter 	yesnotoi strcasecmp 
required path src 	atoi strcasecmp 
len dst 	atoi strcasecmp 
path src len 	zstrdup 
dst ret 	strcasecmp zstrdup 
filter free vtbl 	strcasecmp strtol 
filter input 	strcasecmp atoi 
isize output osize 	atoi append 
count filter 	server save 
vtbl filter 	strcasecmp 
singleton filter filter 	reset server 
held filter 	save strcasecmp 
input isize output 	chdir server 
osize count 	log strerror 
crlf filter crlf 	exit strcasecmp 
vtbl crlf 	config 
filter one two 	strcasecmp zfree 
buf end 	zstrdup fopen 
ptr filter input 	sdscatprintf sdsempty 
isize output 	strerror fclose 
osize cas filled 	strcasecmp yesnotoi 
feed remaining 	strcasecmp 
fed filter cas 	zfree zstrdup 
cascade vtbl 	strcasecmp config 
one two cascade 	strcasecmp atoi 
filter left 	strcasecmp load 
state ident str 	server config 
ident output 	strcasecmp 
osize drain 	atoi strcasecmp 
filter input isize 	memtoll strcasecmp 
output osize 	config strcasecmp 
ident head filter 	atoi strcasecmp 
ident ident 	sdsnew atoi 
vtbl sha ident 	strcasecmp 
path sha 	atoi strcasecmp 
filter filter filter 	atoi strcasecmp 
input isize 	yesnotoi strcasecmp 
output osize memset 	yesnotoi strcasecmp 
gather stats 	atoi strcasecmp 
convert binary gather 	memtoll 
convert stats 	resize replication 
read blob data 	backlog strcasecmp 
cache gather 	atoi strcasecmp 
convert stats ascii 	zfree zstrdup 
free strbuf 	strcasecmp yesnotoi 
read file 	strcasecmp 
gather convert stats 	yesnotoi strcasecmp 
ascii strbuf 	yesnotoi strcasecmp 
release read blob 	yesnotoi strcasecmp 
data cache 	yesnotoi strcasecmp 
memchr free quote 	yesnotoi strcasecmp 
buf strbuf 	atoi 
expand strbuf release 	strcasecmp yesnotoi 
start command 	strcasecmp path 
error sigchain push 	name zfree 
write full 	zstrdup strcasecmp 
copy close error 	yesnotoi strcasecmp 
sigchain pop 	config 
finish command error 	strcasecmp atoi 
strbuf release 	strcasecmp memtoll 
memset fflush start 	strcasecmp yesnotoi 
strbuf read 	strcasecmp yesnotoi 
error close error 	strcasecmp strlen 
finish error 	zstrdup 
strbuf swap 	strcasecmp zfree 
strbuf release parse 	zstrdup strcasecmp 
config key 	path name 
strncmp xcalloc xmemdupz 	zfree zstrdup 
strcmp git 	strcasecmp memtoll 
config strcmp git 	strcasecmp 
config strcmp 	memtoll strcasecmp 
git config memcmp 	strcasecmp strcasecmp 
count ident 	atoi strcasecmp 
strbuf avail strbuf 	atoi strcasecmp 
grow memchr 	memtoll strcasecmp 
memmove memcmp memchr 	memtoll 
memchr memcpy 	strcasecmp memtoll 
memmove strbuf setlen 	strcasecmp memtoll 
count ident 	strcasecmp lookup 
strbuf detach hash 	command dict 
sha file 	server sdslen 
strbuf grow memchr 	sdsdup 
strbuf memcmp 	dict sdsfree 
memchr memchr 	strcasecmp yesnotoi 
memchr strbuf addstr 	strcasecmp zfree 
strbuf sha 	zstrdup strcasecmp 
hex strbuf addstr 	yesnotoi strcasecmp 
strbuf free 	strtoll 
attr attr attr 	strcasecmp atoi 
unset strcmp 	strcasecmp atoi 
attr git attr 	strcasecmp strtoll 
git config 	strcasecmp strtoll 
git check attr 	strcasecmp strtoll 
git path 	strcasecmp 
check crlf git 	strtoll strcasecmp 
path check 	client type 
crlf git path 	name memtoll 
check ident 	memtoll atoi 
git path check 	strcasecmp yesnotoi 
convert text 	strcasecmp 
eol crlf convert 	atoi strcasecmp 
attrs apply 	atoi strcasecmp 
filter convert 	atoi strcasecmp 
attrs convert attrs 	keyspace events 
ident worktree 	flags strcasecmp 
crlf worktree apply 	config 
filter die 	strcasecmp sentinel 
convert working convert 	handle configuration 
working convert 	sdsfreesplitres sdsfreesplitres 
git memmove free 	exit sdsempty 
xcalloc stream 	fopen server 
filter stream filter 	log 
stream filter 	exit fgets 
free stream filter 	sdscat fclose 
free stream 	sdscat sdscat 
filter free stream 	load server 
filter stream 	config sdsfree 
filter xmalloc skip 	server 
prefix isspace 	info sds 
memcpy strbuf strbuf 	encoded server 
ident drain 	info sds 
ident drain 	encoded path 
strbuf addch foreign 	name reply 
ident strbuf 	error 
setlen strbuf addstr 	zfree zstrdup 
strbuf strbuf 	sdslen zfree 
addch strbuf addch 	zstrdup zfree 
strbuf addstr 	zstrdup adjust 
strbuf addch strbuf 	open files 
release free 	limit 
xmalloc xsnprintf sha 	reply error 
hex strbuf 	format size 
init convert attrs 	resize size 
ident filter 	reply error 
cascade filter output 	yesnotoi stop 
eol cascade 	append 
filter crlf filter 	start append 
free filter 	reply error 
convert convert 	sdssplitlen sdslen 
file checking checking 	sdsfreesplitres strtoll 
use pathname 	sdsfreesplitres reset 
decide whether wants 	server 
interesting conversions 	save strtoll 
automatic gzip unzip 	strtoll append 
general format 	server save 
conversions etc etc 	sdsfreesplitres chdir 
automatic crlf 	reply error 
translation text attribute 	format 
crlf option 	strerror sdssplitlen 
stat bits bin 	sdslen sdsfreesplitres 
txt bits 	client type 
unset nul crlf 	name sdsfreesplitres 
counts approximations 	memtoll sdsfreesplitres 
del esc fall 	client 
file ends 	type name 
eof count eof 	strtoll strtoll 
non printable 	strtoll sdsfreesplitres 
heuristics diff 	keyspace events 
mmfile binary treat 	flags refresh 
files bare 	good 
binary fall crl 	slaves count 
would restored 	refresh good 
checkout check crl 	slaves count 
safe crlf 	enable watchdog 
fail crl would 	disable watchdog 
added checkout 	zmalloc 
check naked safe 	used memory 
crlf fail 	server log 
dry run source 	free memory 
buffer nothing 	needed resize 
analyze must would 	replication backlog 
convert file 	reply 
index convert safer 	error format 
autocrlf handling 	reply reply 
optimization crlf nothing 	error format 
convert regardless 	deferred multi 
point source 	bulk length 
analysis done sure 	server 
would convert 	info sds 
dry run mode 	encoded config 
give answer 	field config 
grow place guessed 	field config 
already know 	field config 
rejected file lone 	field 
strip without 	config field 
looking follow naked 	config field 
nothing convert 	config numerical 
regardless crlf line 	field config 
endings touch 	numerical field 
safer autocrlf handling 	config 
faking place 	numerical field 
editing spawn cmd 	config numerical 
feed buffer 	field config 
contents stdin apply 	numerical field 
substitution cmd 	config numerical 
quote path 	field 
preserve spaces etc 	config numerical 
expand quoted 	field config 
path create pipeline 	numerical field 
command filter 	config numerical 
buffer contents child 	field config 
cmd error 	numerical 
already reported external 	field config 
conversion drivers 	numerical field 
configured filter name 	config numerical 
variable filter 	field config 
name smudge filter 	numerical field 
name clean 	config 
specifies command line 	numerical field 
command line 	config numerical 
command line interpolated 	field config 
way scan 	numerical field 
closing dollar 	config numerical 
sign discard grow 	field 
place line 	config numerical 
next dollar faking 	field config 
place editing 	numerical field 
step run next 	config numerical 
step looks 	field config 
like bit like 	numerical 
xxx step 	field config 
skip xxxxx possible 	numerical field 
expanded crept 	config numerical 
way repository cope 	field config 
stripping expansion 	numerical field 
probably good idea 	config 
since cause 	numerical field 
changes checkout won 	config numerical 
away stash 	field config 
keep git style 	numerical field 
ids incomplete 	config numerical 
keyword quit 	field 
loop line next 	config numerical 
dollar spaces 	field config 
unexpected places probably 	numerical field 
versioning system 	config numerical 
keep wasn xxxx 	field config 
step substitute 	numerical 
attr says attr 	field config 
use core 	numerical field 
autocrlf apply filter 	config numerical 
filter required 	field config 
succeed must die 	numerical field 
filter fails 	config 
original data filtering 	field config 
available supported 	field config 
yet supported yet 	field config 
crlf conversion 	field config 
skipped normalizing unless 	field config 
smudge filter 	field 
filter might 	config field 
expect crl streaming 	config field 
conversion support 	config field 
keep states nothing 	config field 
instances shared 	config field 
crlf filter may 	config 
holding onto 	field config 
see followed would 	field config 
need main 	field config 
loop otherwise emit 	field config 
output stream 	field config 
told drain previous 	field 
round saw 	config field 
followed emit processing 	config field 
current character 	stringmatch reply 
may consumed last 	bulk reply 
output slot 	bulk stringmatch 
need loop hold 	getcwd 
current character 	reply bulk 
returning increment 	reply bulk 
cascade filter input 	stringmatch sdsempty 
one buf 	sdscatprintf sdscatlen 
two output already 	reply bulk 
something feed 	reply 
two feed one 	bulk sdsfree 
upstream emit 	stringmatch sdsempty 
buffer know drained 	sdscatprintf client 
one completely 	type name 
tell two drain 	sdscatlen reply 
nothing give 	bulk 
completely drained two 	reply bulk 
ident filter 	sdsfree stringmatch 
drain upon eof 	snprintf reply 
fallthru skipping 	bulk reply 
keeping foreign ident 	bulk stringmatch 
appropriately constructed 	reply 
filter path 	bulk snprintf 
contents cannot filtered 	reply bulk 
without reading 	stringmatch create 
whole thing core 	keyspace events 
note would 	flags reply 
crazy crlf smuge 	bulk 
clean ident 	reply bulk 
large binary blob 	decr count 
would want 	stringmatch sdsjoin 
slurp memory convert.h 	reply bulk 
path path 	reply bulk 
path convert git 	sdsfree 
path src 	deferred multi 
len dst path 	bulk length 
src len 	zrealloc dict 
dst path convert 	fetch list 
git filter 	create dict 
path path stream 	sdsdup 
filter stream 	list node 
filter stream 	tail sdsnew 
filter input isize 	dict sdsfree 
output osize 	fopen zmalloc 
convert git copyright 	dict create 
google inc 	dict 
returns dst used 	create fgets 
precondition would 	sdstrim sdsnew 
convert git filter 	strcmp rewrite 
path streaming 	config append 
conversion support opaque 	line sdssplitargs 
use much 	sdsnew 
input isize fill 	sdscatsds sdsfree 
output osize 	rewrite config 
update isize osize 	append line 
indicate much 	sdstolower rewrite 
buffer space consumed 	config append 
filled success 	line 
non zero error 	rewrite config 
filters may 	line number 
need buffer 	option sdsfreesplitres 
input look ahead 	fclose sdsnew 
inside decide 	dict fetch 
output may consume 	rewrite 
zero bytes 	config mark 
input still produce 	processed sdsfree 
output feeding 	sdsfree list 
input pass input 	first list 
keep calling 	del node 
function filters know 	list 
input coming 	length dict 
time produce remaining 	sdsfree rewrite 
output buffered 	config append 
input convert copy.c 	line sdsnew 
ifd ofd 	rewrite config 
buffer len dst 	append 
src times 	line sdsfree 
dst src mode 	snprintf snprintf 
fdi fdo 	snprintf snprintf 
status dst 	rewrite config 
src mode status 	format memory 
xread write 	sdscatprintf 
full stat utime 	sdsempty rewrite 
open open 	config rewrite 
close copy error 	line sdscatprintf 
strerror error 	sdsempty rewrite 
strerror close close 	config rewrite 
error strerror 	line 
adjust shared perm 	rewrite config 
copy file 	mark processed 
copy times count-objects.c 	strcmp sdsnew 
garbage size 	sdscatlen sdscatrepr 
garbage verbose loose 	strlen rewrite 
packed packed 	config 
loose loose size 	rewrite line 
seen bits 	sdscatprintf sdsempty 
seen bits path 	rewrite config 
desc path 	rewrite line 
sha path 	sdscatprintf sdsempty 
data basename path 	rewrite 
data count 	config rewrite 
objects usage argc 	line config 
argv prefix 	name unknown 
human readable opts 	sdscatprintf sdsempty 
num pack 	rewrite config 
size pack loose 	rewrite 
buf pack 	line config 
buf garbage buf 	name unknown 
buf bits 	sdscatprintf sdsempty 
msg stat warning 	rewrite config 
report garbage 	rewrite 
lstat isreg loose 	line sdscatprintf 
garbage disk 	sdsempty rewrite 
bytes sha pack 	config rewrite 
loose garbage 	line rewrite 
parse options 	config mark 
usage options report 	processed 
linked checkout 	getcwd rewrite 
garbage loose file 	config mark 
objdir directory 	processed rewrite 
prepare packed git 	config option 
open pack 	rewrite config 
index strbuf humanise 	mark 
bytes strbuf 	processed sdscatprintf 
humanise bytes strbuf 	sdsempty rewrite 
humanise bytes 	config rewrite 
strbuf addf strbuf 	line keyspace 
addf strbuf 	events flags 
addf strbuf release 	sdsnew 
strbuf release 	sdscatlen sdscatrepr 
strbuf release strbuf 	sdslen sdsfree 
humanise bytes 	rewrite config 
strbuf addf strbuf 	rewrite line 
release builtin 	rewrite config 
git count 	format 
objects copyright junio 	memory rewrite 
hamano take 	config format 
arguments flags credential-cache--daemon.c 	memory sdscatprintf 
socket file 	sdsempty client 
item expiration entries 	type name 
entries entries 	rewrite 
alloc timeout wait 	config rewrite 
entry next 	line rewrite 
action timeout item 	config mark 
action timeout 	processed sdsjoin 
pfd wakeup client 	sdsnew sdscatlen 
client socket 	sdscatsds 
path debug permissions 	sdsfree rewrite 
advice path 	config rewrite 
path copy dir 	line sdsempty 
argc argv 	sdslen sdscatsds 
socket path ignore 	sdscatlen sdsfreesplitres 
sighup usage 	dict 
debug options 	release dict 
alloc grow memcpy 	release zfree 
memset time 	dict iterator 
credential match lookup 	dict next 
credential time 	dict val 
credential clear memcpy 	dict 
strbuf getline 	key dict 
skip prefix error 	find server 
strbuf addstr 	log list 
strbuf getline skip 	length list 
prefix error 	first sdsfree 
atoi credential read 	sdsempty 
read request 	list del 
strcmp lookup credential 	node dict 
strcmp exit 	release iterator 
strcmp credential strcmp 	open sdslen 
warning warning 	fstat close 
credential cache credential 	sdsdup 
warning credential 	sdsgrowzero memset 
clear strbuf 	write strlen 
release check expirations 	ftruncate sdsfree 
poll die 	close rewrite 
errno accept warning 	config read 
strerror dup 	old 
warning strerror close 	file rewrite 
xfdopen xfdopen 	config yes 
serve one client 	option rewrite 
fclose fclose 	config option 
unix stream listen 	rewrite config 
die errno 	numerical 
fclose freopen die 	option rewrite 
errno serve 	config numerical 
cache loop close 	option rewrite 
xstrdup dirname 	config bind 
stat die safe 	option rewrite 
create leading 	config 
directories die 	option rewrite 
errno mkdir die 	config octal 
errno chdir 	option rewrite 
free git config 	config numerical 
parse options 	option rewrite 
usage options absolute 	config 
path die 	numerical option 
init socket directory 	rewrite config 
tempfile signal 	option rewrite 
serve cache tempfile 	config option 
take ownership 	rewrite config 
pointers initially give 	yes 
client seconds 	option rewrite 
actually contact store 	config option 
credential decide 	rewrite config 
point keeping daemon 	syslogfacility option 
around stick 	rewrite config 
around seconds credential 	save 
shows removed 	option rewrite 
failed one 	config numerical 
soon correct one 	option rewrite 
ignore error 	config yes 
nothing must sure 	option rewrite 
create directory 	config 
correct mode chmod 	yes option 
fact otherwise 	rewrite config 
race condition somebody 	yes option 
chdir sleep 	rewrite config 
open socket actually 	option rewrite 
care cwd 	config 
chdir friendly daemon 	dir option 
avoid tying 	rewrite config 
original cwd fails 	slaveof option 
without benefit 	rewrite config 
credential-cache.c socket got 	option rewrite 
data socket 	config 
daemon argv buf 	yes option 
socket action 	rewrite config 
timeout flags 	yes option 
buf argc argv 	rewrite config 
socket path 	numerical option 
timeout usage options 	rewrite 
unix stream 	config numerical 
connect write full 	option rewrite 
die errno 	config bytes 
shutdown read full 	option rewrite 
die errno 	config bytes 
write die start 	option 
command die 	rewrite config 
errno read full 	yes option 
die errno 	rewrite config 
memcmp die close 	yes option 
strbuf addf 	rewrite config 
strbuf addf strbuf 	numerical 
read die 	option rewrite 
errno send request 	config numerical 
die errno 	option rewrite 
spawn daemon 	config numerical 
send request die 	option rewrite 
errno strbuf 	config 
release parse options 	numerical option 
usage options 	rewrite config 
expand user path 	option rewrite 
die strcmp 	config numerical 
cache strcmp strcmp 	option rewrite 
cache strcmp 	config 
cache ignore unknown 	bytes option 
operation credential-store.c 	rewrite config 
credential match line 	option rewrite 
entry found 	config numerical 
credential buf extra 	option rewrite 
buf fns 	config 
fns fns argc 	yes option 
argv usage 	rewrite config 
fns file 	option rewrite 
options fopen die 	config option 
errno strbuf 	rewrite config 
getline credential url 	yes 
credential match 	option rewrite 
match credential clear 	config numerical 
strbuf release 	option rewrite 
fclose strbuf addch 	config bytes 
write die 	option rewrite 
file hold file 	config 
update die 	numerical option 
errno print line 	rewrite config 
parse credential 	yes option 
file commit file 	rewrite config 
die errno 	option rewrite 
strbuf addf strbuf 	config 
addstr urlencode 	yes option 
strbuf addch strbuf 	rewrite config 
addstr urlencode 	numerical option 
strbuf addch 	rewrite config 
strbuf addstr urlencode 	numerical option 
strbuf addch 	rewrite 
strbuf addstr urlencode 	config numerical 
rewrite credential 	option rewrite 
file strbuf release 	config numerical 
access store 	option rewrite 
credential file store 	config numerical 
credential file 	option 
access rewrite credential 	rewrite config 
file parse 	numerical option 
credential file umask 	rewrite config 
parse options 	notifykeyspaceevents option 
usage options list 	rewrite config 
append expand 	numerical 
user path list 	option rewrite 
append nodup 	config numerical 
xdg config home 	option rewrite 
list append 	config numerical 
nodup die 	option rewrite 
credential read die 	config 
strcmp lookup 	numerical option 
credential strcmp credential 	rewrite config 
strcmp store 	numerical option 
credential list clear 	rewrite config 
sanity check 	numerical option 
storing actually sensible 	rewrite 
particular make 	config numerical 
url without protocol 	option rewrite 
field without 	config numerical 
either host pathname 	option rewrite 
depending scheme 	config yes 
primary key without 	option 
username password 	rewrite config 
actually storing credential 	yes option 
write credential 	rewrite config 
filename specified fns 	clientoutputbufferlimit option 
items thus 	rewrite config 
creating sanity 	numerical 
check actually something 	option rewrite 
match input 	config yes 
restrictive pattern technically 	option rewrite 
blank credential 	config yes 
means erase everything 	option rewrite 
easy accidentally 	config 
send since equivalent 	option rewrite 
empty input 	config sentinel 
explicitly disallow require 	option rewrite 
pattern actual 	config orphaned 
content match found 	rewrite config 
credential ignore 	content 
unknown operation credential.c 	state rewrite 
want data 	config overwrite 
key dot want 	file sdsfree 
url matched 	rewrite config 
flags desc prompt 	release state 
line key 	strcasecmp 
key cmd 	config command 
want output helper 	strcasecmp config 
argv helper 	command strcasecmp 
operation cmd url 	reset server 
colon slash 	stats reset 
host proto end 	command 
memset free 	table stats 
free free free 	reply strcasecmp 
free list 	reply error 
clear credential init 	rewrite config 
check check 	server log 
check check skip 	strerror 
prefix config 	reply error 
error nonbool strrchr 	format strerror 
xmemdupz credential 	server log 
url credential match 	reply reply 
credential clear 	error reply 
free strcmp 	error 
list append strcmp 	format configuration 
xstrdup strcmp 	file parsing 
git config strcmp 	config commands 
strcmp git 	implementation copyright 
config proto http 	salvatore sanfilippo 
free strbuf 	antirez 
addf strbuf addf 	gmail dot 
strbuf addstr 	rights reserved 
strbuf addf credential 	redistribution use 
describe strbuf 	source binary 
addf strbuf addf 	forms without 
git prompt 	modification 
strbuf release strbuf 	permitted provided 
release xstrdup 	following conditions 
credential ask one 	met redistributions 
credential ask 	source code 
one strbuf getline 	must retain 
strchr warning 	copyright 
strbuf release 	notice list 
strcmp free xstrdup 	conditions following 
strcmp free 	disclaimer redistributions 
xstrdup strcmp free 	binary form 
xstrdup strcmp 	must reproduce 
free xstrdup strcmp 	copyright 
free xstrdup 	notice list 
strcmp credential url 	conditions following 
strcmp git 	disclaimer documentation 
config strbuf release 	materials provided 
credential write 	distribution neither 
item credential write 	name 
item credential 	redis names 
write item credential 	contributors may 
write item 	used endorse 
credential write item 	promote products 
start command 	derived software 
xfdopen credential write 	without 
fclose xfdopen 	specific prior 
credential read 	written permission 
fclose finish command 	software provided 
finish command 	copyright holders 
strbuf addstr absolute 	contributors express 
path strbuf 	implied 
addstr strbuf addf 	warranties including 
strbuf addf 	limited implied 
run credential helper 	warranties merchantability 
strcmp strbuf 	fitness particular 
release credential apply 	purpose disclaimed 
config credential 	shall 
die credential getpass 	copyright owner 
die credential 	contributors liable 
apply config credential 	direct indirect 
credential apply 	incidental special 
config credential free 	exemplary consequential 
free credential 	damages 
clear strstr strchr 	including limited 
strchr strchrnul 	procurement substitute 
url decode 	goods services 
mem url decode 	loss use 
mem url 	data profits 
decode mem xmemdupz 	business 
url decode 	interruption however 
mem url decode 	caused theory 
strlen ignore 	liability whether 
lines know mean 	contract strict 
future proofs 	liability tort 
later versions git 	including 
learn lines 	negligence otherwise 
helpers updated match 	arising way 
match one 	use software 
proto host proto 	even advised 
user host 	possibility damage 
proto user pass 	config 
host trim 	file name 
leading trailing 	maps output 
slashes path usage 	buffer limits 
msg argc 	presets normal 
argv prefix usage 	slave pubsub 
credential read 	access 
die strcmp credential 	functions name 
fill credential 	match min 
write strcmp credential 	returned name 
approve strcmp 	match found 
credential reject usage 	returned wrapper 
ignore lines 	config 
know mean future 	name returning 
proofs later 	unknown insetad 
versions git learn 	match used 
lines helpers 	info generation 
updated match match 	config file 
one proto 	parsing 
host proto user 	skip comments 
host proto 	blank lines 
user pass 	split arguments 
host trim leading 	skip line 
trailing slashes 	resulting command 
path credential.c want 	vector 
data key 	empty execute 
dot want url 	config directives 
matched flags 	test able 
desc prompt line 	open file 
key key 	server able 
cmd want output 	abort 
helper argv 	problem later 
helper operation cmd 	dead option 
url colon 	dead option 
slash host proto 	target command 
end memset 	name empty 
free free free 	command 
free free 	table otherwise 
list clear credential 	command different 
init check 	name argc 
check check 	handled main 
check skip prefix 	need enter 
config error 	sentinel 
nonbool strrchr xmemdupz 	mode asap 
credential url 	sanity checks 
credential match credential 	load server 
clear free 	configuration specified 
strcmp list append 	filename function 
strcmp xstrdup 	appends 
strcmp git config 	additional configuration 
strcmp strcmp 	directives stored 
git config proto 	options config 
http free 	file loading 
strbuf addf strbuf 	filename options 
addf strbuf 	considered 
addstr strbuf addf 	empty way 
credential describe 	load server 
strbuf addf strbuf 	config used 
addf git 	load file 
prompt strbuf 	load load 
release strbuf release 	file 
xstrdup credential 	content append 
ask one credential 	additional options 
ask one 	config implementation 
strbuf getline strchr 	starts config 
warning strbuf 	macros chain 
release strcmp free 	special 
xstrdup strcmp 	fields handled 
free xstrdup strcmp 	general macros 
free xstrdup 	check capable 
strcmp free xstrdup 	supporting many 
strcmp free 	perform sanity 
xstrdup strcmp credential 	check 
url strcmp 	setting config 
git config strbuf 	even number 
release credential 	args seconds 
write item 	changes config 
credential write item 	need multiple 
credential write 	hard 
item credential write 	soft soft 
item credential 	seconds sanity 
write item start 	check single 
command xfdopen 	arguments either 
credential write fclose 	refuse whole 
xfdopen credential 	configuration 
read fclose finish 	accept even 
command finish 	single error 
command strbuf addstr 	single client 
absolute path 	present config 
strbuf addstr strbuf 	fields config 
addf strbuf 	field 
addf run credential 	name numerical 
helper strcmp 	fields config 
strbuf release credential 	numerical field 
apply config 	name min 
credential die 	max cast 
credential getpass die 	hint 
credential apply 	user accept 
config credential credential 	values range 
apply config 	cap reasonable 
credential free free 	values memory 
credential clear 	fields config 
strstr strchr strchr 	memory 
strchrnul url 	field name 
decode mem url 	enumeration fields 
decode mem 	config field 
url decode mem 	name everyhing 
xmemdupz url 	error success 
decode mem url 	options 
decode strlen 	bad format 
ignore lines know 	errors config 
mean future 	implementation values 
proofs later versions 	numerical values 
git learn 	yes 
lines helpers 	values values 
updated match match 	everything handle 
one proto 	macros follows 
host proto user 	config rewrite 
host proto 	implementation use 
user pass host 	following 
trim leading 	dictionary type 
trailing slashes path 	store configuration 
usage msg 	option mentioned 
argc argv prefix 	old configuration 
usage credential 	file like 
read die strcmp 	maxmemory 
credential fill 	list line 
credential write strcmp 	numbers first 
credential approve 	line zero 
strcmp credential reject 	sentinel config 
usage ignore 	rewriting implemented 
lines know mean 	inside 
future proofs 	sentinel rewrite 
later versions 	config sentinel 
git learn lines 	option hash 
helpers updated 	function key 
match match one 	dup val 
proto host 	dup 
proto user host 	key compare 
proto user 	key destructor 
pass host trim 	val destructor 
leading trailing 	hash function 
slashes path credential.h 	key dup 
helpers username 	val 
password protocol host 	dup key 
path credential 	compare key 
credential credential credential 	destructor val 
credential credential 	destructor config 
credential credential url 	rewrite state 
want credential 	option 
csum-file.c buf count 	list config 
check buffer 	file lines 
ret ret 	map dictionary 
offset result flags 	already processed 
discard cnt 	options number 
buf count offset 	lines 
left data 	current config 
name name sink 	current lines 
check name 	sds already 
checkpoint checkpoint offset 	added directives 
read full 	present original 
die errno die 	config 
memcmp die 	file append 
xwrite display throughput 	line current 
die die 	configuration state 
errno git sha 	populate option 
update flush 	list line 
sha flush git 	numbers 
sha hashcpy 	map specified 
flush fsync 	option processed 
die close die 	options useful 
errno read 	unused lines 
full die errno 	processed options 
die close 	blanked 
die errno free 	config file 
crc memcpy 	options rewrite 
git sha update 	process understand 
flush sha 	remain untouched 
throughput open die 	read old 
errno open 	file 
die errno sha 	split lines 
xmalloc git 	populate newly 
sha init sha 	created config 
flush ftruncate 	rewrite state 
lseek crc csum 	caller impossible 
file copyright 	read 
linus torvalds simple 	old file 
file write 	returned old 
infrastructure writing 	file exist 
sha summed files 	empty state 
useful write 	returned read 
file want able 	old 
verify hasn 	file line 
messed afterwards write 	line populate 
checksum close 	state zero 
process full buffer 	init handle 
directly without 	comments empty 
copy sha flush 	lines 
called checkpoint 	comment split 
csum-file.h check offset 	arguments apparently 
ctx total 	line unparsable 
name crc crc 	reason instance 
buffer offset 	may unbalanced 
ctx sha file 	quotes 
sha file 	load comment 
checkpoint sha file 	want lowercase 
sha file 	config directives 
checkpoint name 	populate state 
name name sha 	according content 
file sha 	line 
file sha file 	append line 
sha file 	populate option 
data data sha 	line numbers 
write htonl 	map rewrite 
sha write sha 	specified configuration 
file checkpoint 	option 
sha close flags 	line progressively 
ctype.c sane 	uses lines 
ctype tolower trans 	file already 
tbl sane 	used configuration 
locale independent ascii 	option old 
ctype surprises 	version 
works chars non 	file removing 
alnum nothing 	line map 
range insensitive kwset 	options line 
daemon.c log 	numbers lines 
syslog verbose 	associated given 
reuseaddr informative errors 	configuration 
daemon usage 	option force 
paths strict paths 	non zero 
export trees 	line appended 
path interpolated path 	configuration file 
path relaxed 	usually force 
user path timeout 	option 
init timeout 	must rewritten 
hostname canon hostname 	even present 
address tcp 	previously first 
port priority err 	time line 
buf err 	appended configuration 
err err directory 	file 
hostinfo placeholder 	comment added 
ctx context directory 	show starting 
rpath interp 	point config 
path path 	file generated 
dir namlen restlen 	config rewrite 
slash expanded 	line 
path context pathlen 	either used 
len name 	freed caller 
config name enabled 	need free 
overridable dir 	way option 
msg access hook 	used previously 
service dir 	forced 
path child buf 	use still 
argv arg 	lines old 
eol seen errors 	configuration file 
dir service 	reuse option 
path enabled line 	replace line 
argv cld 	one 
timeout buf argv 	append line 
argv argv 	write bytes 
daemon service name 	way parsable 
ena name 	inside redis 
ena hostport 	conf possible 
host port end 	uses 
extra args 	notation rewrite 
buflen val vallen 	simple option 
end host 	name bytes 
port hints gai 	configuration option 
addrbuf sin 	rewrite yes 
addr hent addrbuf 	option 
line pktlen 	rewrite option 
len port arg 	options need 
max connections 	present configuration 
live children next 	file next 
cld address 	reboot force 
cld addr addrlen 	zero 
newborn cradle 	rewrite numerical 
blanket next status 	range option 
pid cradle 	rewrite octal 
blanket dead cld 	option rewrite 
argv incoming 	enumeration option 
addr addrlen 	takes 
cld buf sin 	usually state 
addr buf 	option name 
sin addr signo 	addition enumeration 
sockfd list 	option rewrite 
alloc family sin 	syslog facility 
len listen 	option 
addr listen port 	rewrite save 
socklist socknum 	option note 
pbuf hints gai 	save parameters 
flags sockfd 	current config 
listen addr listen 	line save 
port socklist 	detected 
sin sockfd flags 	orphaned deleted 
listen addr 	resulting rdb 
listen port socklist 	persistence expected 
socknum socklist 	mark save 
pfd sai sai 	processed server 
sslen incoming 	saveparamslen 
cred user 	zero rewrite 
name name pass 	dir option 
gid cred 	always absolute 
user name name 	paths rewrite 
listen addr 	error rewrite 
listen port cred 	slaveof 
socklist argc 	option master 
argv listen port 	want slaveof 
listen addr 	config options 
inetd mode name 	file removed 
detach cred 	note cluster 
arg end lookup 	instance 
hostname lookup 	want slaveof 
hostname vsnprintf syslog 	directive inside 
getpid vfprintf 	redis conf 
fputc fflush start 	rewrite notify 
logreport end 	keyspace events 
start logreport 	option 
end logreport exit 	rewrite client 
strbuf addbuf 	output buffer 
strbuf addstr canon 	limit option 
hostname strbuf 	rewrite bind 
addstr address strbuf 	option nothing 
addbuf strbuf 	rewrite 
addstr daemon avoid 	bind addresses 
logerror logerror 	rewrite bind 
strlen strchr loginfo 	addr addr 
snprintf logerror 	addr glue 
strbuf expand strlcpy 	together configuration 
strbuf release 	lines 
loginfo logerror snprintf 	current configuration 
enter repo 	rewrite state 
enter repo logerror 	single stripping 
strlen strlen 	multiple empty 
memcmp logerror packet 	lines every 
write canon 	cluster 
hostname address 	empty lines 
start command logerror 	turned single 
strbuf read 	empty line 
logerror strbuf reset 	free configuration 
close logerror 	rewrite state 
finish command strbuf 	end 
release strbuf 	rewrite process 
ltrim strbuf addstr 	state contains 
strchr daemon 	remaining map 
error strbuf release 	option name 
loginfo logerror 	lines original 
daemon error path 	config 
daemon error 	file lines 
access logerror daemon 	used rewrite 
error strbuf 	process removed 
addf git config 	function rewrite 
strbuf release 	config rewrite 
logerror daemon error 	line 
run access 	lines orphaned 
hook signal 	replaced empty 
fdopen logerror close 	lines function 
strbuf getline 	iterating option 
logerror strbuf setlen 	names blanking 
strbuf release 	lines 
fclose start command 	still associated 
close close 	blank lines 
copy log finish 	options rewrite 
command snprintf 	process understand 
run service command 	function overwrites 
run service 	old 
command run service 	configuration file 
command size 	content old 
strcmp die size 	file length 
strcmp die 	obtained content 
strchr die die 	smaller padding 
strrchr strbuf 	added 
addch strbuf setlen 	single write 
sanitize client 	call used 
strbuf tolower 	replace content 
strncasecmp strlen parse 	file later 
host port 	file truncated 
sanitize client canonicalize 	length 
client die 	content way 
memset getaddrinfo inet 	sure file 
ntop strbuf 	left consistent 
addstr sanitize client 	state even 
strbuf addbuf 	process stopped 
freeaddrinfo gethostbyname memset 	four 
htons memcpy 	operations function 
inet ntop sanitize 	returns success 
client strbuf 	otherwise returned 
addstr memset strbuf 	errno accordingly 
init strbuf 	open old 
init strbuf init 	file 
strbuf init 	create one 
strbuf release strbuf 	exist size 
release strbuf 	errno open 
release strbuf 	errno fstat 
release getenv hostinfo 	pad content 
init loginfo 	least 
alarm packet read 	match old 
alarm strlen 	file size 
loginfo parse host 	old file 
arg size 	bigger pad 
skip prefix skip 	content newline 
prefix run 	plus 
service hostinfo clear 	many chars 
hostinfo clear 	required write 
logerror memcmp memcmp 	content single 
xcalloc memcpy 	write truncate 
memcpy addrcmp addrcmp 	file right 
kill waitpid 	length 
loginfo child process 	used padding 
clear free 	non critical 
kill child 	error rewrite 
sleep check dead 	configuration file 
children close 	path configuration 
logerror inet ntop 	file 
argv pushf 	already exists 
argv pushf ntohs 	best retain 
inet ntop 	comments overall 
argv pushf argv 	structure configuration 
pushf ntohs 	parameters unless 
dup start command 	already 
logerror child 	explicitly included 
signal setsockopt inet 	old configuration 
ntop inet 	file rewritten 
ntop xsnprintf xsnprintf 	error returned 
memset getaddrinfo 	errno accordingly 
logerror gai strerror 	otherwise 
socket logerror 	step read 
close setsockopt reuse 	old config 
addr logerror 	rewrite state 
strerror close 	step rewrite 
bind logerror str 	every single 
strerror close 	option 
listen logerror str 	replacing appending 
strerror close 	inside rewrite 
fcntl fcntl alloc 	state rewrite 
grow freeaddrinfo 	sentinel config 
memset htons inet 	sentinel mode 
pton htonl 	step 
socket reuse addr 	orphaned lines 
logerror strerror 	old file 
close bind logerror 	lines used 
str strerror 	config option 
close listen logerror 	longer used 
str strerror 	like 
close fcntl fcntl 	multiple save 
alloc grow 	options duplicated 
setup named sock 	options step 
setup named 	generate configuration 
sock logerror 	file modified 
xcalloc signal check 	state 
dead children 	write original 
poll logerror strerror 	file config 
sleep accept 	command entry 
die errno handle 	point config.h 
die initgroups 	argc argv 
setgid setuid die 	fmt 
getpwnam die 	copyright salvatore 
getgrnam die socksetup 	sanfilippo antirez 
die drop 	gmail dot 
privileges loginfo service 	rights reserved 
loop git 	redistribution use 
setup gettext git 	source 
extract argv 	binary forms 
path skip prefix 	without modification 
list append 	permitted provided 
xstrdup tolower skip 	following conditions 
prefix strtoul 	met redistributions 
strcmp strcmp 	source 
strcmp strcmp strcmp 	code must 
skip prefix 	retain copyright 
skip prefix atoi 	notice list 
skip prefix 	conditions following 
atoi skip prefix 	disclaimer redistributions 
atoi strcmp 	binary 
skip prefix strcmp 	form must 
skip prefix 	reproduce copyright 
strcmp strcmp skip 	notice list 
prefix skip 	conditions following 
prefix strcmp skip 	disclaimer documentation 
prefix skip 	materials 
prefix skip prefix 	provided distribution 
enable service 	neither name 
skip prefix enable 	redis names 
service skip 	contributors may 
prefix make 	used endorse 
service overridable skip 	promote 
prefix make 	products derived 
service overridable strcmp 	software without 
strcmp strcmp 	specific prior 
usage openlog die 	written permission 
routine setvbuf 	software provided 
die die die 	copyright 
prepare credentials 	holders contributors 
die directory die 	express implied 
freopen die 	warranties including 
errno execute daemonize 	limited implied 
die sanitize 	warranties merchantability 
stdfds write file 	fitness 
getpid argv 	particular purpose 
push argv push 	disclaimed shall 
argv push 	copyright owner 
serve nothing list 	contributors liable 
acceptable pathname 	direct indirect 
prefixes git 	incidental 
daemon export required 	special exemplary 
take paths 	consequential damages 
relative one non 	including limited 
defined user 	procurement substitute 
notation allowed inserted 	goods services 
user request 	loss 
git host alice 	use data 
frotz would 	profits business 
home alice pub 	interruption however 
git frotz 	caused theory 
user path pub 	liability whether 
git timeout 	contract 
initial timeout since 	strict liability 
stderr buffered 	tort including 
mode logging different 	negligence otherwise 
processes overlap 	arising way 
unless overflow rather 	use software 
big buffers 	even 
got either 	advised possibility 
alice alice foo 	damage define 
rewrite alice 	redis fstat 
alice foo allow 	fstat fstat 
absolute allow 	test proc 
absolute fail path 	filesystem 
relaxed enabled 	test task 
without prefixing path 	info test 
validation done 	backtrace msg 
paths enter repo 	nosignal test 
appends optional 	polling api 
git git git 	define 
friends use 	aof fsync 
getcwd pub symlink 	fdatasync linux 
mnt pub 	fsync rest 
whitelist pub say 	define rdb 
mnt pub 	fsync range 
say pub backwards 	sync 
compatible fallthrough 	file range 
deny security 	linux otherwise 
cheap want readable 	use plain 
head usable 	fsync call 
objects directory git 	check use 
daemon export 	setproctitle 
flag says side 	bsd systems 
path uses 	support provide 
enter repo whitelist 	implementation linux 
checking need 	osx ordering 
make sure repository 	detection 
exported optionally 	likely define 
hook choose deny 	order least 
access repository 	significant first 
depending phase moon 	vax significant 
ignore sigterm 	first ibm 
good client timeout 	net 
sanitize client 	lsb first 
inserted filesystem 	word msw 
path specifically disallow 	first pdp 
slashes runs 	linux bsd 
trailing leading dots 	order sometimes 
means client 	including 
cannot escape path 	specific header 
via traversal 	defines endianess 
like sanitize client 	end order 
also perform 	order redis 
canonicalization make life 	code uses 
easier admin 	define 
read host supplied 	everything without 
client connection 	underscores must 
split host port 	determine correct 
colon next 	bit order 
one locate canonical 	compiler next 
hostname address 	line 
note directory probably 	intentional error 
context sensitive 	force compiles 
might depend 	bomb fix 
actual service performed 	macros crc16.c 
gets called 	crc tab 
number connections grows 	buf 
past max 	len counter 
connections kill newest 	crc copyright 
connection duplicate 	georges menie 
child give time 	www menie 
die otherwise 	copyright salvatore 
empty handler systemcalls 	sanfilippo 
interrupted upon 	adapted redis 
signal receipt sys 	coding style 
needs handler 	rights reserved 
rearmed note error 	redistribution use 
fatal fatal 	source binary 
fatal ipv well 	forms 
host better 	without modification 
address nothing unlimited 	permitted provided 
avoid splitting 	following conditions 
message middle 	met redistributions 
prepare argv serving 	source code 
processes git 	must 
daemon date.c mdays 	retain copyright 
year month 	notice list 
day month names 	conditions following 
weekday names 	disclaimer redistributions 
time minutes time 	binary form 
time local 	must 
offset eastwest time 	reproduce copyright 
timebuf diff 	notice list 
totalmonths years months 	conditions following 
date mode 	disclaimer documentation 
type time mode 	materials provided 
timebuf sign 	distribution 
name offset dst 	neither name 
date str 	university california 
date date offset 	berkeley names 
match match 	contributors may 
match year 	used endorse 
month day check 	promote 
specified num 	products derived 
date end refuse 	software without 
future num 	specific prior 
num date offset 	written permission 
gmt end 	software provided 
num time match 	regents 
minutes hours 	contributors express 
date offp end 	implied warranties 
hour min 	including limited 
offset date offset 	implied warranties 
buf sign 	merchantability fitness 
date timestamp offset 	particular 
end stamp 	purpose disclaimed 
ofs date timestamp 	shall regents 
offset gmt 	contributors liable 
dummy timestamp dummy 	direct indirect 
offset match 	incidental special 
temp time 	exemplary 
date timestamp errors 	consequential damages 
date result 	including limited 
timestamp offset offset 	procurement substitute 
sec num 	goods services 
num hour num 	loss use 
num num 	data 
num hour num 	profits business 
hour num 	interruption however 
name number name 	caused theory 
type length 	liability whether 
date num touched 	contract strict 
end match 	liability 
len len len 	tort including 
match diff 	negligence otherwise 
date num end 	arising way 
number match 	use software 
num number 	even advised 
date error ret 	possibility 
number touched 	damage crc 
time sec date 	implementation according 
timestamp offset 	ccitt standards 
errors date error 	note antirez 
ret timestamp 	actually xmodem 
offset dummy sys 	crc 
time gmtime 	algorithm following 
localtime time strbuf 	parameters name 
addstr strbuf 	xmodem also 
addf strbuf addf 	known zmodem 
strbuf addf 	crc acorn 
strbuf addf strbuf 	width 
addf strbuf 	bit poly 
addf strbuf addf 	actually initialization 
strbuf addf 	reflect input 
strbuf release strbuf 	reflect output 
addf strbuf 	crc xor 
addf local 	constant 
tzoffset strbuf reset 	output crc 
strbuf addf 	output crc64.c 
strbuf reset gettimeofday 	crc tab 
show date 	crc argc 
relative time time 	argv unused 
strbuf reset 	unused 
strbuf addf strbuf 	crc redis 
addf abs 	uses crc 
strbuf addf strbuf 	variant jones 
addf strbuf 	coefficients init 
addftime strbuf addf 	specification crc 
toupper toupper 	variant 
isalnum isalpha match 	follows name 
match size 	crc jones 
match strlen match 	width bites 
match skip 	poly xad 
alpha time strtol 	reflected xor 
isdigit strtol 	xffffffffffffffff 
time gmtime 	reflected xor 
date date date 	check copyright 
date date 	salvatore sanfilippo 
strtoul nodate gmtime 	antirez gmail 
isdigit match 	dot rights 
multi number isdigit 	reserved 
strtoul strtoul 	redistribution use 
strbuf addf strtoul 	source binary 
strtol memset 	forms without 
match header date 	modification permitted 
isalpha match 	provided following 
alpha isdigit match 	conditions 
digit isdigit 	met redistributions 
match time mktime 	source code 
strcmp strcmp 	must retain 
strcmp strcmp approxidate 	copyright notice 
careful parse 	list conditions 
date basic date 	following 
skip prefix 	disclaimer redistributions 
skip prefix 	binary form 
skip prefix skip 	must reproduce 
prefix skip 	copyright notice 
prefix skip prefix 	list conditions 
skip prefix 	following 
skip prefix skip 	disclaimer documentation 
prefix skip 	materials provided 
prefix die strcmp 	distribution neither 
parse date 	name redis 
type skip prefix 	names contributors 
skip prefix 	may 
die xstrdup die 	used endorse 
time time 	promote products 
localtime date mktime 	derived software 
localtime update 	without specific 
update date yesterday 	prior written 
date time 	permission 
date time 	software provided 
date time localtime 	copyright holders 
isalpha match 	contributors express 
strlen match strlen 	implied warranties 
match match 	including limited 
strlen match update 	implied 
match update 	warranties merchantability 
match update match 	fitness particular 
update strtoul 	purpose disclaimed 
isdigit match multi 	shall copyright 
number localtime 	owner contributors 
isdigit pending number 	liable 
approxidate digit 	direct indirect 
isalpha approxidate alpha 	incidental special 
pending number 	exemplary consequential 
update parse date 	damages including 
basic approxidate 	limited procurement 
str parse date 	substitute 
basic gettimeofday 	goods services 
approxidate str 	loss use 
git information manager 	data profits 
hell copyright 	business interruption 
linus torvalds like 	however caused 
mktime without 	theory 
normalization wday yday 	liability whether 
algo works 	contract strict 
bounds thing passed 	liability tort 
strange parse 	including negligence 
thing means passed 	otherwise arising 
integer even 	way 
though means sixty 	use software 
minutes effect 	even advised 
back time local 	possibility damage 
timezone minutes 	test main 
turn minutes turn 	crc64.h crc 
hours deal 	argc 
number days say 	argv ctl.c 
weeks past 	ctl mtx 
weeks say 	ctl initialized 
months past months 	ctl epoch 
give years 	ctl stats 
months years translators 	node 
years otherwise 	node index 
years centuries probably 	children node 
overkill check 	astats astats 
note doesn summer 	cstats arena 
time conversion 	sstats astats 
world always summer 	arena 
things probably 	name nodesp 
bit ways international 	mibp depthp 
date line 	arena ind 
west nome central 	tcache node 
alaska hawaii 	prof node 
standard hawaii daylight 	node 
yukon standard 	config node 
yukon daylight pacific 	opt node 
standard pacific 	tcache node 
daylight mountain 	arena node 
standard mountain daylight 	arena node 
central standard 	arena 
central daylight eastern 	node arenas 
standard eastern 	bin node 
daylight atlantic standard 	arenas bin 
atlantic daylight 	node arenas 
west africa greenwich 	bin node 
mean universal 	arenas 
coordinated zulu utc 	lrun node 
western european 	arenas lrun 
british summer central 	node arenas 
european middle 	lrun node 
european middle european 	arenas hchunk 
winter middle 	node 
european summer central 	arenas hchunk 
european summer 	node arenas 
middle european 	hchunk node 
summer french winter 	arenas node 
french summer 	prof node 
eastern europe ussr 	stats 
zone eastern 	arenas metadata 
european daylight west 	node stats 
australian standard 	arenas small 
west australian daylight 	node stats 
china coast 	arenas large 
ussr zone japan 	node 
standard ussr 	stats arenas 
zone eastern australian 	huge node 
standard eastern 	stats arenas 
australian daylight guam 	bins node 
standard ussr 	stats arenas 
zone zealand zealand 	bins 
standard zealand 	node stats 
daylight international date 	arenas bins 
line east 	node stats 
parse month 	arenas lruns 
weekday timezone name 	node stats 
bogus like 	arenas 
summer use name 	lruns node 
offset anything 	stats arenas 
better bad crap 	lruns node 
commit time 	stats arenas 
author time make 	hchunks node 
sense specify 	stats 
timestamp way future 	arenas hchunks 
make sure 	node stats 
later ten days 	arenas hchunks 
time date 	node stats 
yyyy yyyy eastern 	arenas node 
european friends 	stats 
say norm giving 	arenas node 
precedence form 	stats arenas 
separator european funny 	node stats 
funny european 	node root 
filled part 	node root 
time date yet 	node 
binary see 	astats astats 
sign bit values 	cstats arena 
seen digit 	sstats astats 
time year date 	arena astats 
seconds since 	sstats astats 
trigger numbers digits 	tstats 
want rule 	tsd refreshed 
numbers like yyyymmdd 	initialized allocated 
date check 	resident mapped 
special formats num 	ret name 
num num 	nodesp mibp 
none special formats 	depthp 
guess number 	ret elm 
meant use number 	tdot dot 
digits make 	elen node 
educated guess four 	pnode child 
digit year 	index inode 
timezone ignore 	name 
lots numerals took 	oldp oldlenp 
care digit 	newp newlen 
years days months 	ret depth 
must one 	nodes mib 
two digits note 	node name 
give precedence 	mibp 
day month month 	miblenp ret 
year numbers 	mib miblen 
range always mday 	oldp oldlenp 
unless already 	newp newlen 
mday iow apr 	ret node 
parses april 	inode 
two digit year 	mib miblen 
hhmm random 	oldp oldlenp 
crap random crap 	newp newlen 
otherwise parsed 	ret newval 
accept random crap 	mib miblen 
even though 	oldp 
places offset 	oldlenp newp 
larger hours pacific 	newlen ret 
kiritimati utc 	tsd oldarena 
something wrong hour 	newind oldind 
part much 	newarena tcache 
larger might also 	mib 
want check 	miblen oldp 
minutes divisible something 	oldlenp newp 
offset kathmandu 	newlen ret 
nepal utc parse 	oldval mib 
like ancient 	miblen oldp 
timestamp near epoch 	oldlenp 
appears part 	newp newlen 
strptime crap doesn 	ret mib 
way require 	miblen oldp 
rfc english day 	oldlenp newp 
month names 	newlen ret 
doesn work 	tsd 
correctly success stop 	oldname mib 
end newline 	miblen oldp 
bad crap use 	oldlenp newp 
mktime uses 	newlen ret 
local timezone gmtime 	oldval mib 
match digit 	miblen 
may clobbered success 	oldp oldlenp 
take usually 	newp newlen 
translates current timestamp 	ret tsd 
user really 	tcache ind 
means expire everything 	mib miblen 
done past 	oldp 
definition reflogs record 	oldlenp newp 
past nothing 	newlen ret 
future kept historical 	tsd tcache 
relative time 	ind mib 
update days ago 	miblen oldp 
haven time 	oldlenp 
yet need 	newp newlen 
current time fill 	ret tsd 
date fields 	tcache ind 
needed fill date 	arena ind 
fields needed 	tsd refreshed 
accept zero padding 	mib 
small numbers 	miblen oldp 
dec never dec 	oldlenp newp 
pending number 	newlen ret 
end see one 	mib miblen 
month day 	oldp oldlenp 
dec screw number 	newp 
overflowed bad 	newlen ret 
also going feed 	dss arena 
result system 	ind dss 
functions expect time 	prec old 
often make 	dss prec 
sure fit time 	match 
well decorate.c 	arena mib 
obj decoration 	miblen oldp 
size hash old 	oldlenp newp 
old size 	newlen ret 
old hash decoration 	arena ind 
obj decoration 	arena 
obj sha hash 	oldval mib 
hash obj 	miblen oldp 
xcalloc insert decoration 	oldlenp newp 
free grow 	newlen ret 
decoration insert decoration 	arena ind 
hash obj 	arena 
decorate decorate git 	old chunk 
arbitrary data 	hooks chunk 
decoration pointer old 	hooks old 
one lookup 	chunk hooks 
decoration pointer nothing 	mib miblen 
lookup decorate.h 	ret 
decoration name size 	mib miblen 
hash obj 	oldp oldlenp 
decoration obj 	newp newlen 
delta.h buf bufsize 	ret narenas 
index index 	mib miblen 
index buf bufsize 	oldp 
delta size 	oldlenp newp 
max delta size 	newlen ret 
src buf 	nread mib 
src bufsize trg 	miblen oldp 
buf trg 	oldlenp newp 
bufsize delta size 	newlen 
max delta 	ret oldval 
size index delta 	mib miblen 
src buf 	mib miblen 
src size delta 	mib miblen 
buf delta 	mib miblen 
size dst size 	oldp 
datap top 	oldlenp newp 
data cmd 	newlen ret 
size create delta 	narenas mib 
index create 	miblen oldp 
delta free delta 	oldlenp newp 
index opaque 	newlen 
delta index create 	ret oldval 
delta index 	mib miblen 
compute index data 	oldp oldlenp 
given buffer 	newp newlen 
returns pointer delta 	ret oldval 
index passed 	mib 
subsequent create delta 	miblen oldp 
calls free 	oldlenp newp 
delta index pointer 	newlen ret 
returned failure 	filename mib 
given buffer must 	miblen oldp 
freed altered 	oldlenp 
free delta index 	newp newlen 
called returned 	ret oldval 
pointer must 	mib miblen 
freed free delta 	oldp oldlenp 
index free 	newp 
delta index free 	newlen ret 
index created 	sample tsd 
create delta index 	mib miblen 
given pointer 	mib miblen 
must create delta 	mib miblen 
index returned 	mib 
delta index returns 	miblen ret 
memory usage 	ctl named 
delta index given 	node malloc 
pointer must 	malloc memset 
create delta index 	memset memset 
returned create 	memset 
delta create delta 	arena stats 
given index 	merge index 
given buffer function 	size ctl 
may called 	arena clear 
multiple times 	ctl arena 
different buffers delta 	stats 
index pointer 	amerge ctl 
max delta size 	arena stats 
non zero 	smerge arena 
resulting delta larger 	init malloc 
max delta 	memcpy memset 
size returned success 	ctl 
non pointer 	arena init 
buffer delta data 	dalloc memcpy 
returned delta 	memcpy memcpy 
size updated size 	dalloc variable 
returned buffer 	ctl arena 
must freed caller 	clear 
diff delta 	tsd fetch 
create delta source 	arena arena 
buffer target 	arena nbound 
buffer max delta 	ctl arena 
size non 	refresh stats 
zero resulting 	malloc 
delta larger max 	mutex narenas 
delta size 	total malloc 
returned success non 	memset ctl 
pointer buffer 	arena init 
delta data returned 	dalloc dalloc 
delta size 	dalloc 
updated size returned 	ctl refresh 
buffer must 	malloc mutex 
freed caller patch 	unlock strchr 
delta recreate 	strchr size 
target buffer given 	ctl named 
source buffer 	node 
delta data success 	ctl named 
non pointer 	children strlen 
target buffer returned 	strncmp malloc 
trg bufsize 	strtoumax ctl 
updated size 	indexed node 
failure pointer returned 	index 
returned buffer 	strchr strchr 
must freed caller 	size ctl 
smallest possible 	init ctl 
delta size bytes 	lookup ctl 
must called 	named node 
twice delta data 	ctl 
buffer first 	ctl init 
expected source buffer 	ctl lookup 
size target 	ctl init 
buffer size describe.c 	ctl named 
describe usage 	node ctl 
debug tags longformat 	named 
first parent 	children ctl 
abbrev max candidates 	indexed node 
names pattern 	index ctl 
always dirty diff 	malloc mutex 
index args 	init malloc 
entry peeled 	mutex 
tag sha path 	prefork malloc 
prio names 	mutex postfork 
peeled peeled prio 	parent malloc 
sha tag 	mutex postfork 
path peeled prio 	child malloc 
sha tag 	mutex 
path oid flag 	write ctl 
data tag 	refresh read 
peeled annotated prio 	malloc mutex 
name depth 	unlock tsd 
found order flag 	fetch arena 
within list 	choose 
best seen commits 	malloc mutex 
parents depth 	write read 
sha arg last 	arena arena 
one sha 	migrate tsd 
cmit gave list 	tcache tcache 
matches cur 	arena 
match seen 	reassociate malloc 
commits unannotated cnt 	mutex unlock 
iter parents 	tcache enabled 
oid argc argv 	tcache enabled 
prefix contains 	read writeonly 
options args index 	tcache 
hashcmp hashmap 	flush read 
hash sha hash 	xor write 
lookup tag 	tsd fetch 
parse tag lookup 	prof name 
tag parse 	prof name 
tag find commit 	read 
name replace 	prof active 
name xmalloc hashcpy 	prof active 
hashmap entry 	read tsd 
init sha hash 	fetch malloc 
hashmap hashcpy 	mutex tcaches 
free xstrdup starts 	create 
wildmatch peel 	read malloc 
oidcmp oidcpy 	mutex unlock 
known names pop 	tsd fetch 
commit parse 	writeonly write 
commit commit list 	tcaches flush 
insert date 	tsd 
lookup tag parse 	fetch writeonly 
tag die 	write tcaches 
die strcmp warning 	destroy variable 
find unique 	tsd fetch 
abbrev sha die 	arena arena 
lookup commit 	arena 
reference die find 	purge arena 
commit name 	purge writeonly 
display name show 	malloc mutex 
suffix die 	arena purge 
oid hex hashmap 	malloc mutex 
iter first 	unlock 
hashmap iter next 	malloc mutex 
lookup commit 	write strcmp 
reference gently 	arena tsd 
commit list insert 	fetch arena 
pop commit 	dss prec 
oid hex parse 	arena 
commit commit 	dss prec 
list insert date 	chunk dss 
find unique 	prec chunk 
abbrev die oid 	dss prec 
hex die 	read malloc 
oid hex qsort 	mutex 
commit list 	unlock arena 
insert date finish 	tsd fetch 
depth computation 	arena dirty 
free commit list 	mult read 
oid hex 	arena dirty 
display name show 	mult 
suffix clear 	malloc mutex 
commit marks 	narenas total 
git config parse 	arena tsd 
options die 	fetch write 
argv init argv 	chunk hooks 
pushl argv 	read 
push argv push 	chunk hooks 
argv pushf 	read malloc 
argv pushv argv 	mutex unlock 
push cmd 	malloc mutex 
name rev hashmap 	malloc mutex 
init rawref 	unlock 
die read cache 	malloc mutex 
preload refresh 	read malloc 
index hold locked 	mutex unlock 
index update 	malloc mutex 
index able cmd 	malloc mutex 
diff index 	unlock 
size describe die 	arena dirty 
describe display 	mult read 
lots verbose 	arena dirty 
info valid used 	mult malloc 
allow lightweight 	mutex ctl 
tags unspecified diff 	grow 
index command 	read malloc 
arguments check working 	mutex unlock 
dirty annotated 	prof active 
tag tag head 	init prof 
multiple annotated 	active init 
tags point commit 	read 
one keep 	prof active 
upon tagger date 	prof active 
reject anything 	read writeonly 
outside refs tags 	write prof 
unless accept 	mdump prof 
tags match pattern 	gdump 
given annotated 	prof gdump 
use annotated tags 	read writeonly 
tags fall 	write tsd 
back lightweight 	fetch prof 
ones even without 	reset malloc 
tags still 	mutex 
remember lightweight ones 	malloc mutex 
give hints 	unlock data 
error message allows 	ctl mtx 
refs used 	protects following 
exact match existing 	ctl stats 
diff-delta.c ptr 	helpers 
val entry next 	named indexed 
memsize src 	nodes function 
buf src size 	prototypes non 
hash mask 	functions mallctl 
hash buf bufsize 	maximum depth 
hsize hmask 	handles 
entries prev val 	indexed nodes 
hash count 	since currently 
data buffer index 	external ones 
entry hash 	merge sum 
packed entry 	stats well 
packed hash mem 	merge 
memsize val 	sum stats 
acc keep index 	well initialize 
index index 	arena allocate 
trg buf trg 	extended arena 
size delta 	stats initialize 
size max size 	astats 
outpos outsize 	element swap 
moff msize val 	merged stats 
inscnt data 	location clear 
top data top 	sum stats 
entry src 	since merged 
size left tmp 	ctl 
malloc memset 	arena refresh 
calloc free free 	allocate space 
malloc free 	one extra 
free free 	arena stats 
malloc realloc free 	element contains 
free diff 	summed 
delta generate delta 	stats across 
two buffers 	arenas initialize 
code greatly inspired 	stats structures 
parts lib 	regardless whether 
diff davide libenzi 	ever used 
http www 	lazy 
xmailserver xdiff lib 	initialization would 
html rewritten 	allow errors 
git nicolas pitre 	cause inconsistent 
nico fluxnic 	state viewable 
net code free 	application equivalent 
software redistribute 	strchrnul 
modify terms gnu 	children named 
general license 	children indexed 
version published free 	terminal node 
software foundation 	name contains 
maximum hash 	elements path 
entry list hash 	complete 
bucket determine 	lookup successful 
index hash size 	update elm 
note indexing 	elements name 
skips first allow 	refers path 
optimizing rabin 	ctl iterate 
polynomial initialization create 	children 
delta current 	named indexed 
delta format encode 	element call 
offsets reference 	ctl function 
buffer bits allocate 	mib ctl 
lookup index 	functions lot 
allocate count hash 	code 
entries populate 	duplication following 
index keep lowest 	macros due 
consecutive identical 	limitations nested 
blocks determine limit 	cpp macros 
number entries 	expanded ctl 
hash bucket 	mtx 
guards pathological data 	acquired assumption 
sets causing 	pertinent data 
really bad hash 	mutate call 
distribution entries 	arena index 
hash bucket would 	range initialize 
bring computing 	arena 
costs corresponding reference 	necessary arena 
target buffer 	tcache associations 
sizes make sure 	ctl mutex 
none hash 	must held 
buckets entries willing 	execution function 
test otherwise 	intentional 
cull entry list 	intentional ctl.h 
uniformly still 	named node 
preserve good repartition 	name nchildren 
across reference 	children size 
buffer exactly hash 	node size 
limit entries 	initialized 
bucket loop 	nthreads dss 
gone exactly hash 	dirty mult 
limit times 	pactive pdirty 
entered left acc 	astats allocated 
first statement 	small nmalloc 
loop contributes hash 	small 
count hash 	ndalloc small 
limit hash limit 	nrequests small 
accumulator inner 	bstats lstats 
loop consequently run 	hstats allocated 
hash count 	active metadata 
hash limit times 	resident 
removing one 	mapped narenas 
element list time 	arenas name 
since acc 	oldp oldlenp 
balances run inner 	newp newlen 
loop body 	name mibp 
left entry 	miblenp 
indeed encounter entry 	mib miblen 
outer loop 	oldp oldlenp 
create packed index 	newp newlen 
form rather 	jemalloc types 
linked lists coalesce 	nchildren terminal 
entries belonging 	node 
one linked list 	aggregate stats 
consecutive entries 	small size 
sentinel indicate length 	classes bin 
last hash 	stats nlclasses 
bucket maximum size 	elements nhclasses 
opcode sequence 	elements 
including initial header 	narenas elements 
plus rabin 	jemalloc structs 
window plus biggest 	jemalloc externs 
copy store 	jemalloc inlines 
reference buffer size 	db.c key 
store target 	key 
buffer size 	key val 
best match far 	key val 
good enough 	key key 
match one back 	reply key 
count slot 	reply key 
make copy currently 	val 
limited pack 	copy retval 
diff-files.c diff files 	key val 
usage argc 	key val 
argv prefix rev 	key key 
result options 	keyobj key 
init revisions gitmodules 	key 
config git 	decoded callback 
config setup revisions 	removed key 
strcmp strcmp 	dbid saved 
strcmp strcmp usage 	dirty count 
usage read 	key pattern 
cache preload perror 	allkeys 
run diff 	numkeys replylen 
files diff 	key keyobj 
result code git 	privdata keys 
information manager 	key val 
hell copyright linus 	sdskey cursor 
torvalds diff 	eptr 
options make sure 	cursor keys 
revision pending 	node nextnode 
parameter rev max 	count pat 
count reasonable 	use pattern 
revision filtering parameters 	privdata maxiterations 
diff files 	pos 
combine merges asked 	vstr vlen 
diff files 	vll kobj 
densify user ask 	filter buf 
diff files 	len kobj 
explicitly diff-index.c diff 	cursor type 
cache usage 	flags 
argc argv prefix 	expire samekey 
rev cached 	src dst 
result arg 	srcid dbid 
init revisions gitmodules 	expire key 
config git 	key kde 
config setup revisions 	key 
strcmp usage 	key argv 
usage setup work 	key basetime 
read cache 	unit param 
preload perror read 	aux output 
cache perror 	expire ttl 
run diff index 	cmd 
diff result 	argv argc 
code diff options 	numkeys last 
make sure 	keys cmd 
one revision pending 	argv argc 
revision filtering 	numkeys result 
parameters diff-lib.c sub 	cmd 
diffopt option 	argv argc 
dirty submodule changed 	numkeys num 
orig flags 	keys cmd 
revs option 	argv argc 
entries diff unmerged 	numkeys num 
stage option 	keys 
oldmode newmode changed 	cmd argv 
dirty submodule 	argc numkeys 
old sha sha 	num keys 
dpath pair 	found store 
mode num compare 	name skip 
stages path 	cmd 
len nce stage 	argv argc 
mode revs 	numkeys num 
prefix sha sha 	first keys 
valid mode 	key hashslot 
dirty submodule sha 	key hashslot 
modep cached 	hashslot 
match missing dirty 	keys count 
submodule diffopt 	range hashslot 
sha mode 	range key 
changed revs cached 	hashslot zsl 
match missing 	range rank 
sha mode dirty 	count 
submodule revs 	dict find 
old report missing 	dict val 
cached match 	lru clock 
missing mode oldmode 	expire needed 
sha dirty 	lookup key 
submodule pathlen idx 	expire 
revs match 	needed lookup 
missing cached pair 	key lookup 
src idx 	key read 
revs revs sha 	reply lookup 
name cached 	key write 
opts revs cached 	reply 
ent sha 	sdsdup dict 
opt revs def 	server info 
diff flags 	signal list 
rev opt 	ready slot 
lstat symlink leading 	key dict 
path namelen 	find 
isdir isgitlink resolve 	server info 
gitlink match 	dict replace 
stat isgitlink diff 	lookup key 
opt tst 	write overwrite 
diffopt flags submodule 	incr count 
config diff 	expire 
opt tst diff 	signal modified 
opt tst 	key dict 
diff opt tst 	find dict 
submodule modified 	random key 
diff opt tst 	dict key 
diff mnemonic 	create 
prefix diff quit 	sdslen dict 
early path 	find expire 
match stage namelen 	needed decr 
xmalloc combine 	count dict 
diff path 	size dict 
size memcpy oidclr 	dict 
memset check 	slot key 
removed mode stat 	del server 
perror strcmp 	decoded create 
stage hashcpy mode 	raw sdslen 
stat show 	decr 
combined diff free 	count overwrite 
free diff 	dict size 
unmerge stage uptodate 	dict empty 
skip worktree 	dict empty 
check removed perror 	slot key 
diff addremove 	flush 
sha match stat 	touch watched 
submodule mode 	key touch 
stat mark uptodate 	watched keys 
diff opt 	flush dict 
tst diff change 	size signal 
sha sha 	flushed 
diffcore std 	dict empty 
diff flush diff 	dict empty 
addremove uptodate 	slot key 
check removed match 	flush reply 
stat submodule 	signal flushed 
mode stat stat 	empty 
data diff 	reply kill 
index show file 	rdb temp 
sha stat 	file rdb 
data diff index 	save expire 
show file 	needed signal 
hashcmp hashcmp namelen 	modified 
xmalloc combine 	key notify 
diff path size 	keyspace reply 
memcpy oidclr 	expire needed 
memset hashcpy hashcpy 	exists reply 
show combined 	reply reply 
diff free 	error 
hashcmp diff opt 	reply error 
tst diff 	reply random 
change sha skip 	key reply 
worktree stage 	reply bulk 
diff unmerge fill 	decr count 
filespec show 	sdslen 
file diff index 	deferred multi 
show file 	bulk length 
show modified path 	dict safe 
match oneway 	iterator dict 
diff diff quit 	next dict 
early parse 	key 
indirect error sha 	stringmatchlen sdslen 
hex memset 	create sdslen 
diff opt tst 	expire needed 
init desc 	reply bulk 
unpack trees diff 	decr count 
cache exit 	dict 
diff mnemonic 	release iterator 
prefix diffcore fix 	deferred multi 
diff index 	bulk length 
diffcore std diff 	dict key 
flush init 	create sdslen 
revisions copy pathspec 	dict 
diff cache 	key incr 
exit init revisions 	count dict 
memset setup 	key incr 
revisions diff opt 	count dict 
diff opt 	val incr 
run diff index 	count 
free diff 	dict key 
opt tst copyright 	incr count 
junio hamano 	create dict 
diff files work 	val server 
entity removed 	panic list 
removed work entity 	node 
compared cache 	tail list 
entry still 	node tail 
exists latter includes 	strtoul isspace 
directory submodule 	reply error 
repository exists submodule 	list create 
submodule negative 	server 
error already gitlink 	strcasecmp reply 
plain directory 	reply strcasecmp 
submodule submodule either 	sdslen reply 
something removed 	list length 
work otherwise directory 	dict scan 
submodule repository 	intset 
means blob turned 	list node 
directory blob 	tail create 
removed file changed 	ziplist index 
submodule commits 	ziplist list 
dirty work changes 	node tail 
detected otherwise 	create 
dirty submodules option 	create ziplist 
caller want 	next server 
know submodule 	panic list 
modified wants know 	first list 
conditions met 	node list 
commits untracked content 	next 
modified content 	node sds 
stage first parent 	encoded stringmatchlen 
stage second 	sdslen server 
diff proper unmerged 	stringmatchlen expire 
stage compensate 	needed decr 
loop update show 	count 
diff found 	list del 
one desired stage 	node list 
valid look 	next node 
workdir file removal 	list node 
diff index 	decr count 
file entry went 	list 
away appeared 	del node 
file index might 	reply multi 
actually different 	bulk len 
working gets 	reply bulk 
mix existing index 	reply multi 
one pathname 	bulk 
entry time index 	len list 
entry may 	length list 
single stage one 	first list 
could also 	node reply 
multiple unmerged entries 	bulk decr 
idx pos 	count 
idx give position 	list del 
number entries 	node list 
index entry examine 	free method 
work backward 	list release 
compatibility wart diff 	parse scan 
index mean 	cursor 
ignore merges match 	reply scan 
missing revision 	command reply 
flag parsing 	dict size 
found revs ignore 	reply lookup 
merges something 	key read 
added something removed 	reply 
show difference 	status reply 
old unpack trees 	strcasecmp strcasecmp 
designed merging 	reply prepare 
different source entries 	shutdown exit 
designed primarily 	reply error 
source trees old 	sdscmp 
index really 	lookup key 
mainly used replaced 	write reply 
result diffing 	reply incr 
index important single 	count expire 
supposed advance 	lookup key 
pos skip already 	write 
processed wrapper 	decr count 
makes readable takes 	reply expire 
care fairly 	signal modified 
complex unpack 	key signal 
trees semantic requirements 	modified key 
including skipping 	notify 
path matching type 	keyspace notify 
conflict cases 	keyspace reply 
etc unpack trees 	rename command 
generates conflict 	rename command 
entry directory index 	reply error 
diff standpoint 	reply 
create file diff-no-index.c 	reply lookup 
path list 	key write 
dir file standard 	reply expire 
input path 	lookup key 
mode buf size 	write reply 
name mode 	expire 
name name mode 	incr count 
buffer buffer 	reply server 
ret len comp 	info dict 
tmp tmp 	find dict 
path dir 	dict find 
file tail path 	server 
replacement isdir 	info dict 
isdir revs argc 	replace raw 
argv prefixlen 	dict key 
paths replacement prefix 	dict integer 
opendir error 	val dict 
readdir dot dotdot 	size 
list insert 	dict find 
closedir strcmp strcasecmp 	server info 
create mode 	dict find 
lstat error strbuf 	dict integer 
read error 	val incr 
strerror strbuf detach 	count 
alloc filespec 	incr count 
fill filespec populate 	feed append 
stdin mode 	file replication 
mode isdir isdir 	feed slaves 
isdir noindex 	decr count 
filespec noindex 	decr 
filespec noindex filespec 	count expire 
noindex filespec 	mstime propagate 
diff queue isdir 	expire notify 
isdir read 	keyspace reply 
directory contents read 	lookup key 
directory contents 	write 
list clear strbuf 	reply mstime 
addstr strbuf 	server info 
complete strbuf addstr 	create rewrite 
strbuf complete 	client command 
strbuf setlen strbuf 	vector decr 
setlen strcmp 	count 
strbuf addstr strbuf 	signal modified 
addstr queue 	key notify 
diff list clear 	keyspace reply 
list clear 	expire reply 
strbuf release 	signal modified 
strbuf release diff 	key 
opt tst 	notify keyspace 
noindex filespec noindex 	expire command 
filespec diff 	mstime expire 
queue strrchr strbuf 	command expire 
addstr strbuf 	command mstime 
addch strbuf addstr 	expire 
directory directory 	command lookup 
append basename append 	key read 
basename diff 	reply expire 
setup strcmp strcmp 	mstime reply 
diff opt 	reply ttl 
parse die strlen 	command 
strcmp xstrdup 	ttl command 
prefix filename fixup 	dict find 
paths diff 	reply expire 
opt diff setup 	reply reply 
done setup 	unused zmalloc 
diff pager 	server 
diff opt queue 	getkeys proc 
diff exit 	keys command 
diff mnemonic prefix 	table zfree 
diffcore std 	unused atoi 
diff flush strbuf 	zmalloc unused 
release exit 	atoi 
diff result code 	zmalloc unused 
diff index 	zmalloc strcasecmp 
support copyright johannes 	strcasecmp unused 
schindelin copyright 	strcasecmp sdslen 
junio hamano standard 	zmalloc key 
input something 	hash 
probably expose many 	slot sdslen 
breakages way 	zsl insert 
index code bolted 	incr count 
onto diff 	key hash 
callchain file created 	slot sdslen 
file deleted 	zsl 
emit file 	zsl free 
entire directory created 	zsl create 
deleted append 	zsl first 
basename dwim diff 	range zsl 
diff diff 	first range 
diff note append 	incr 
basename diff 	count decr 
file becomes diff 	count zsl 
file file 	first range 
diff file file 	zsl rank 
stdin spelled 	zsl last 
path spell code 	range 
index imitates 	zsl rank 
diff changes changes 	copyright salvatore 
error diff-tree.c 	sanfilippo antirez 
log opt sha 	gmail dot 
commit commit 	rights reserved 
line len sha 	redistribution 
pos pptr 	use source 
parent line 	binary forms 
len sha line 	without modification 
len sha 	permitted provided 
obj diff usage 	following conditions 
rev opt 	met 
argc argv prefix 	redistributions source 
sha line 	code must 
opt opt read 	retain copyright 
stdin arg 	notice list 
tmp saved nrl 	conditions following 
saved dcctc 	disclaimer 
sha lookup commit 	redistributions binary 
reference log 	form must 
commit isspace sha 	reproduce copyright 
hex free 	notice list 
commit list sha 	conditions following 
hex lookup 	disclaimer 
commit commit 	documentation materials 
list insert log 	provided distribution 
commit isspace 	neither name 
sha hex error 	redis names 
lookup parse 	contributors may 
oid hex oid 	used 
hex diff 	endorse promote 
sha log diff 	products derived 
flush strlen 	software without 
sha hex parse 	specific prior 
stdin diff 	written permission 
commit stdin diff 	software 
trees error 	provided copyright 
sha hex init 	holders contributors 
revisions gitmodules 	express implied 
config git config 	warranties including 
memset setup 	limited implied 
revisions strcmp usage 	warranties 
usage diff 	merchantability fitness 
commit sha 	particular purpose 
diff sha log 	disclaimed shall 
diff flush 	copyright owner 
fgets sha hex 	contributors liable 
fputs fflush 	direct 
diff stdin diff 	indirect incidental 
result code 	special exemplary 
diff one commits 	consequential damages 
graft fake 	including limited 
parents locally commit 	procurement substitute 
free real 	goods 
parent list diff 	services loss 
two trees 	use data 
diff options note 	profits business 
expect equal 	interruption however 
reverse order objects 	caused theory 
second one 	liability 
marked uninteresting diff.c 	whether contract 
diff detect 	strict liability 
rename diff 	tort including 
rename limit diff 	negligence otherwise 
suppress blank 	arising way 
empty diff use 	use 
color diff 	software even 
context diff word 	advised possibility 
regex cfg 	damage level 
external diff cmd 	api update 
cfg diff 	access time 
order file cfg 	ageing 
diff refresh 	algorithm saving 
index diff mnemonic 	child trigger 
prefix diff 	copy write 
prefix diff stat 	madness key 
graph width 	expired context 
diff dirstat permille 	master 
diff options 	expire needed 
diff algorithm diff 	returns key 
colors options 	exist save 
errmsg copy 	asap however 
ret end permille 	context slave 
options name 	expire 
slot errmsg one 	needed really 
two need 	expire key 
one need two 	returns information 
res external 	logical status 
diff cmd done 	key key 
preparing name 	expiring 
hex mode tempfile 	master order 
color diff 	consistent view 
rule blank eof 	master data 
preimage blank 	however command 
eof postimage lno 	caller master 
preimage lno 	additional 
postimage truncate label 	safety measure 
path diff 	command invoked 
words opt found 	read command 
changesp header 	safely provide 
data size 	consistent behavior 
count seen one 	clients 
one rule 	accessign expired 
ptr size cnt 	values read 
prev eol 	fashion say 
ecbdata rule reset 	key non 
first line 	exisitng notably 
len trailing newline 	covers 
trailing carriage 	slaves used 
nofirst file reset 	scale reads 
line len 	key caller 
ecbdata line len 	increment reference 
emit line 	counter needed 
reset ecbdata line 	program 
len reset 	aborted key 
ecbdata line len 	already exists 
reset ecbdata 	overwrite existing 
line len 	key incrementing 
ecbdata line len 	reference count 
context frag 	caller 
func reset atat 	function modify 
msgbuf len 	expire time 
file count ecb 	existing key 
prefix data 	program aborted 
size endp nneof 	key already 
reset len 	present 
context name name 	high level 
one two 	operation function 
textconv one textconv 	used order 
two name 	key whatever 
tab name tab 	existing count 
metainfo fraginfo 	incremented 
reset name prefix 	clients watc 
prefix data 	hing destination 
one data two 	key notified 
size one 	expire time 
size two 	key reset 
ecbdata line prefix 	key 
text alloc 	made persistent 
begin end orig 	random key 
orig alloc 	form redis 
line len buffer 	keys returned 
prefix suffix 	function makes 
color old ctx 	sure 
newline diff 	keys already 
words styles minus 	expired search 
plus current 	another key 
plus last minus 	expired key 
opt word 	associated expiration 
regex style newline 	entry 
count buf 	deleting entry 
line prefix print 	expires dict 
diff words 	free sds 
priv line len 	key shared 
diff words 	main dictionary 
style minus 	prepare 
first minus len 	stored key 
plus first 	modified destructively 
plus len minus 	implement commands 
begin minus 	like setbit 
end plus begin 	append usually 
plus end 	ready 
opt line prefix 	modified unless 
buffer word 	one two 
regex begin end 	conditions shared 
match buffer 	refcount want 
word regex alloc 	affect users 
diff words 	encoding 
xpp xecfg minus 	raw found 
plus style 	one conditions 
opt line prefix 	function unshared 
ecbdata one 	encoded copy 
one ecbdata orig 	stored key 
opts one 	specified 
two ecbdata 	otherwise returned 
diff color opt 	usage caller 
msgbuf ecb 	already obtained 
line len allot 	looking key 
line ecbdata 	usage pattern 
priv line len 	looks 
ecbdata meta 	like lookup 
context reset line 	key write 
prefix name 	key check 
tab name tab 	type obj 
old name 	unshare key 
pfx length sfx 	point 
length pfx 	caller ready 
adjust slash len 	modify example 
len midlen 	sdscat call 
midlen qlen qlen 	append data 
alloc name 	anything 
name print 	hooks key 
name added deleted 	space changes 
diffstat name 	every time 
name priv line 	key database 
len diffstat 	modified function 
mime boundary leader 	signal 
width max 	modified key 
change file prefix 	called every 
name len 	time flushed 
file cnt reset 	function signal 
file pname 	flush called 
buf files insertions 	type 
deletions ret 	agnostic commands 
data options len 	operating key 
del dels 	space normally 
max len count 	rdb save 
width name 	reset dirty 
width graph width 	want 
bin width 	otherwise flushall 
reset del 	replicated put 
line prefix extra 	aof exists 
shown file 	key key 
change prefix file 	key number 
name added 	keys 
deleted name len 	existing callback 
slash total 	used scan 
file added deleted 	command order 
data options 	collect elements 
total files added 	returned dictionary 
deleted data 	iterator 
options file name 	list parse 
changed files 	scan cursor 
alloc permille cumulative 	stored cursor 
opt dir 	valid store 
changed baselen dir 	integer cursor 
sources line 	returns 
prefix namelen slash 	otherwise err 
newbaselen permille 	send error 
options changed 	client use 
dir name copied 	strtoul need 
added damage 	cover whole 
content changed data 	cursor 
options changed 	space command 
dir file damage 	scan hscan 
diffstat filename 	sscan commands 
lineno conflict marker 	passed must 
size rule 	hash otherwise 
status line marker 	command 
size len 	operate dictionary 
firstchar cnt priv 	associated current 
line len 	database function 
data marker size 	assumes first 
reset err 	argument client 
line prefix bad 	arguments 
plus data 	vector key 
size result size 	skips iterating 
bound deflated 	order parse 
stream file 	options hash 
one two prefix 	function returns 
delta deflated 	field 
data orig size 	every element 
delta size 	hash must 
deflate size data 	iterate keys 
size free 	names type 
bytes line file 	must sorted 
one two 	hash 
prefix one one 	first option 
options one 	argument previous 
name name one 	one cursor 
two xfrm 	skip key 
msg must show 	argument needed 
header complete 	step 
rewrite lbl one 	parse options 
two meta 	pattern always 
reset prefix 	matches exactly 
prefix textconv one 	equivalent disabling 
textconv two 	step iterate 
header line prefix 	collection 
del diffopts 	note encoded 
xpp xecfg ecbdata 	ziplist intset 
name name 	representation hash 
one two diffstat 	table sure 
data contents 	also composed 
complete rewrite xpp 	small 
xecfg name 	number elements 
name attr path 	avoid taking 
one two 	state everything 
data xpp xecfg 	inside single 
ecbdata blank 	call setting 
eof err path 	cursor 
spec spec 	zero signal 
spec sha sha 	end iteration 
valid mode 	handle hash 
name sha 	table key 
want file pos 	type key 
len size 	type 
buf dirty flags 	max number 
size err 	iterations ten 
buf size path 	times specified 
temp blob 	count hash 
size sha mode 	table pathological 
buf path 	state 
dup name one 	sparsely populated 
temp argv 	avoid block 
name temp pgm 	much time 
name one 	cost returning 
two xfrm msg 	elements pass 
complete rewrite 	two 
argv env msg 	pointers callback 
name one 	list elements 
two must show 	containing dictionary 
header use 	possible fetch 
color reset 	data type 
line prefix abbrev 	dependent 
pgm name 	way step 
attr path one 	filter elements 
two msg 	filter element 
xfrm msg complete 	match pattern 
rewrite must 	filter element 
show header drv 	expired 
one prefix 	key element 
length namep otherp 	associted needed 
pgm msg 	hash sorted 
one two name 	flat list 
attr path 	key elements 
diffstat name name 	element 
attr path 	filtered skip 
options options count 	filtered match 
arg arg 	keys step 
arg val len 	reply client 
end end 	scan command 
opt opt 	completely 
argv optarg arg 	relies scan 
opt argv 	command shutdown 
optarg arg options 	called server 
arg end 	loading dataset 
width name width 	memory need 
graph width 	make 
count argcount options 	sure attempt 
errmsg options 	performed save 
diff status letters 	dataset shutdown 
filter bit 	otherwise could 
status opt optarg 	overwrite current 
opt optch 	half 
bit negate fmt 	read data 
arg token 	also sentinel 
rest opt arg 	mode clear 
orig arg 	save flag 
val options prefix 	force nosave 
arg optarg 	source 
argcount path 	dest key 
offending path num 	operation performed 
scale dot 	key exists 
opt opt opt 	however still 
cmd diff 	error unexisting 
queued diff queue 	key 
queue one 	overwrite old 
two sha len 	key creating 
abblen abbrev 	one name 
hex opt line 	obtain source 
termination inter 	target pointers 
name termination name 	back 
name name 	source user 
name two diffstat 	moving target 
one msg 	source probably 
opt fmt name 	error check 
name file 	element exists 
newdelete file 	reference 
show name line 	zero key 
prefix file 	already exists 
renamecopy line prefix 	target key 
names opt 	moved free 
file line prefix 	entry source 
ctx patchlen 	expires 
line len dst 	api expire 
priv line 	may removed 
len data len 	corresponding entry 
options sha 	main dict 
ctx data buffer 	otherwise key 
xpp xecfg 	never 
len len options 	freed reuse 
sha result 	sds main 
rename limit warning 	dict expire 
degrade warning 	dict expire 
rename limit advice 	time specified 
varname needed 	key 
degraded options 	expire associated 
output format separator 	key key 
dirstat line 	non expire 
diffstat options options 	asap entry 
outq found 	found expire 
one two diffopt 	dict 
outq name 	means also 
name options options 	present main 
opt status 	dict safety 
result opt path 	check propagate 
options ignored 	expires slaves 
orig flags options 	aof 
addremove mode 	file key 
sha sha valid 	expires master 
concatpath dirty 	del operation 
submodule one two 	key sent 
options old 	slaves aof 
mode mode old 	file 
sha sha 	enabled way 
old sha 	key expiry 
valid sha valid 	centralized one 
concatpath old 	place since 
dirty submodule dirty 	aof master 
submodule one 	slave 
two tmp tmp 	link guarantee 
options path 	operation ordering 
pair one two 	everything consistent 
pgm spec 	even allow 
outsize temp argv 	write operations 
arg child 	expiring 
buf err driver 	keys expire 
outbuf size 	key expire 
opt strcasecmp strcasecmp 	anything loading 
strcasecmp strcasecmp 	done later 
strcasecmp strcasecmp strcasecmp 	context lua 
strcasecmp strcasecmp 	script 
xstrdup list split 	claim time 
place strcmp 	blocked lua 
diff opt 	script started 
clr diff opt 	way key 
clr strcmp 	expire first 
diff opt diff 	time 
opt clr 	accessed middle 
strcmp diff opt 	script execution 
clr diff 	making propagation 
opt strcmp diff 	slaves aof 
opt clr 	consistent see 
strcmp diff opt 	issue 
isdigit strtoul 	github information 
isdigit isdigit strbuf 	running context 
addf strbuf 	slave asap 
addf list clear 	slave key 
free strcmp 	expiration controlled 
diff opt strcmp 	master 
diff opt 	send synthesized 
clr strcasecmp 	del operations 
strcasecmp git config 	expired keys 
strcasecmp strcasecmp 	still right 
strcasecmp strcasecmp strcasecmp 	information caller 
strcmp strcmp 	think 
git config colorbool 	key still 
strcmp git 	valid think 
config strcmp git 	key expired 
config rename 	time key 
strcmp git config 	expired key 
strcmp git 	expires 
config strcmp git 	commands command 
config strcmp 	implementation expire 
git config strcmp 	pexpire expireat 
git config 	pexpireat commad 
strcmp git config 	second argument 
strcmp git 	may 
config pathname strcmp 	relative absolute 
handle ignore 	basetime argument 
submodules arg 	used signal 
strcmp parse submodule 	time either 
warning strcmp 	variants command 
parse algorithm git 	current 
color config 	time relative 
git diff basic 	expires unit 
config strcmp 	either unit 
git config userdiff 	seconds unit 
config skip 	milliseconds used 
prefix skip prefix 	argv 
parse diff 	parameter basetime 
color slot config 	always specified 
error nonbool 	milliseconds unix 
color parse strcmp 	time milliseconds 
strcmp git 	key expire 
config strcmp parse 	key 
dirstat warning 	zero expire 
strbuf release starts 	negative ttl 
parse submodule 	expireat timestamp 
config option 	past never 
git config quote 	executed del 
style quote 	load 
style strbuf addch 	aof context 
quote style 	slave instance 
quote style strbuf 	instead take 
addch strbuf 	branch statement 
addstr strbuf addstr 	setting expire 
strbuf detach 	possibly 
getenv diff file 	past wait 
valid diff 	del master 
populate filespec diff 	replicate aof 
file valid 	del key 
diff populate filespec 	exist key 
blank line 	exists 
count trailing blank 	expire actual 
count trailing 	ttl otherwise 
blank count lines 	api key 
count lines 	arguments commands 
fputs diff 	use keys 
line prefix fputs 	position 
fputc fwrite 	given command 
fputs fputc fputc 	table firstkey 
emit line 	lastkey step 
blank line emit 	arguments keys 
line emit 	command passed 
line emit line 	via 
diff color 	argc argv 
diff color diff 	command returns 
color diff 	positions key 
color memcmp memmem 	arguments inside 
emit line 	actual heap 
strbuf addstr strbuf 	allocated 
strbuf addstr 	integers length 
strbuf addstr strbuf 	returned reference 
strbuf addstr 	numkeys cmd 
strbuf addstr 	must point 
strbuf strbuf addstr 	corresponding entry 
strbuf emit 	redis 
line strbuf release 	command table 
size die 	according command 
size tempfile active 	name argv 
tempfile diff 	function uses 
color memchr emit 	command table 
del line 	command 
emit line diff 	specific helper 
color putc 	function required 
emit line strlen 	otherwise calls 
diff color 	command specific 
diff color diff 	function free 
color diff 	result 
line prefix diff 	keys command 
opt tst 	helper function 
strchr strchr strbuf 	extract keys 
reset strbuf 	following commands 
reset quote 	zunionstore destkey 
two style quote 	num 
two style 	keys key 
fill textconv fill 	key key 
textconv memset 	options zinterstore 
want color whitespace 	destkey num 
rule check 	keys key 
blank eof count 	key 
lines count 	key options 
lines print line 	sanity check 
count print 	key command 
line count emit 	going reply 
rewrite lines 	syntax error 
emit rewrite lines 	keys 
free free 	inter store 
alloc grow memcpy 	come two 
memchr fputs 	places argv 
fputs fputs fwrite 	storage key 
fputs fputs 	argv keys 
fputs parse 	intersect 
hunk header diff 	key positions 
line prefix 	argv keys 
color words output 	argv key 
graph prefix 	position storage 
fputs diff words 	key target 
write helper 	total 
fputs diff words 	keys inter 
write helper 	keys storage 
diff words write 	key helper 
helper regexec 	function extract 
memchr isspace isspace 	keys following 
alloc grow 	commands 
find word boundaries 	eval script 
alloc grow 	num keys 
alloc grow memcpy 	key key 
diff line 	key stuff 
prefix fputs diff 	evalsha script 
words write 	num 
helper memset 	keys key 
memset diff words 	key key 
fill diff 	stuff sanity 
words fill xdi 	check key 
diff outf 	command going 
die free free 	reply 
color words 	syntax error 
output graph prefix 	key positions 
fputs diff 	argv keys 
words write helper 	helper function 
diff words 	extract keys 
show isreg userdiff 	sort 
find path 	command sort 
userdiff find name 	sort key 
diff filespec 	store store 
load driver xmalloc 	key first 
memcpy xcalloc 	argument sort 
userdiff word regex 	always 
userdiff word 	key however 
regex xmalloc 	list options 
regcomp die size 	follow sql 
want color 	alike style 
diff color opt 	parse minimum 
diff color 	order 
opt diff color 	correctly identify 
opt diff 	keys store 
words flush free 	option alloc 
free free 	places worst 
free free regfree 	sort key 
free free 	always 
output prefix truncate 	present search 
utf width 	store option 
strchr strtol strchr 	consider options 
strtol diff 	arguments find 
color diff color 	unknown option 
diff color 	name 
diff line 	scan next 
prefix strbuf reset 	however options 
strchr strchr 	arguments provide 
diff words flush 	list order 
sane truncate 	skip right 
line find lno 	number 
emit hunk 	args end 
header putc emit 	elements note 
line fputs 	increment num 
diff words append 	loop sure 
diff words 	process last 
append starts diff 	store 
words flush 	option multiple 
emit line fputs 	ones provided 
emit line 	behavior sort 
emit line emit 	store key 
del line 	obvious form 
emit context line 	check 
emit line 	extended one 
diff color 	keys option 
strlen strlen quote 	slot key 
style quote 	api used 
style quote style 	redis cluster 
strbuf addstr 	order 
quote style strbuf 	obtain fast 
detach strbuf 	way key 
grow strbuf strbuf 	belongs specified 
addch strbuf 	hash slot 
strbuf addstr strbuf 	useful 
strbuf addch 	rehashing cluster 
strbuf strbuf detach 	keys specified 
xcalloc alloc 	hash slot 
grow xstrdup xstrdup 	number removed 
xstrdup putc 	items returned 
quote style strbuf 	next 
detach strbuf 	item freeing 
release pprint rename 	protect freeing 
strbuf addf 	find first 
strbuf addf 	element range 
strbuf addf strbuf 	use rank 
addch fputs 	first 
strbuf release diff 	element determine 
line prefix 	preliminary count 
diff color opt 	find last 
diff color 	element range 
opt diff color 	use rank 
opt fill 	last 
print name strlen 	element determine 
width width 	actual count 
term columns width 	debug.c digest 
width strlen 	ptr len 
strchr show name 	ctx hash 
putc show 	digest 
name scale linear 	digest ptr 
scale linear 	len ctx 
scale linear show 	digest digest 
name show 	buf aux 
graph show 	key keyobj 
graph print stat 	expiretime 
summary diff 	entry eleobj 
line prefix print 	ele eledigest 
stat summary 	eptr sptr 
diff line prefix 	vstr vlen 
fill print 	vll score 
name write name 	eleobj 
quoted fputs 	score obj 
putc putc write 	eledigest result 
name quoted 	str info 
write name quoted 	delay flags 
diff line 	ptr val 
prefix strlen memcmp 	strenc 
strchr gather 	extra nextra 
dirstat strcmp diff 	remaining used 
opt tst 	avg compressed 
hashcmp diff 	node val 
opt tst diff 	key keys 
file valid 	key 
diff file valid 	val buf 
diff populate 	digest dtime 
filespec diff populate 	utime errstr 
filespec diffcore 	sizes dbid 
count changes diff 	stats buf 
free filespec 	info 
data diff free 	estr file 
filespec data 	line buf 
diff file valid 	arg repr 
diff populate 	estr file 
filespec diff free 	line msg 
filespec data 	file 
diff file valid 	line addr 
diff populate 	val log 
filespec diff free 	stdout log 
filespec data 	stdout trace 
alloc grow 	msg msg 
qsort gather dirstat 	client 
diff opt 	decoded val 
tst alloc grow 	key line 
qsort gather 	logbuf start 
dirstat free free 	addr end 
free free 	addr size 
free isspace diff 	start 
color diff 	vect size 
color diff color 	vect start 
diff line 	end errors 
prefix conflict marker 	sig info 
check whitespace 	secret eip 
error free emit 	infostring 
line check 	clients act 
emit strchr strtol 	level descr 
die git 	len buf 
deflate init git 	charset sig 
deflate bound 	info secret 
xmalloc git 	period 
deflate git deflate 	period min 
end deflate 	period act 
diff delta deflate 	act sha 
free free 	init sha 
free encode fputs 	update sha 
fputc free 	decoded 
emit binary diff 	xor digest 
body emit 	sdslen decr 
binary diff body 	count xor 
diff filespec 	digest sha 
load driver diff 	init sha 
file valid 	update 
diff populate filespec 	sha decoded 
buffer binary 	mix digest 
diff filespec load 	sdslen decr 
driver diff 	count memset 
file valid diff 	dict size 
filespec load 	dict 
driver userdiff 	iterator htonl 
textconv diff color 	mix digest 
opt diff 	dict next 
color opt diff 	memset dict 
line prefix 	key create 
diff opt tst 	sdslen 
isgitlink isgitlink 	mix digest 
diff color opt 	sdslen dict 
diff color 	val htonl 
opt show submodule 	mix digest 
summary diff 	expire mix 
opt tst textconv 	digest 
textconv diff 	list type 
mnemonic prefix diff 	init iterator 
opt tst 	list type 
diff file valid 	next list 
diff file 	type mix 
valid quote 	digest 
two quote two 	decr count 
diff file 	list type 
valid diff file 	release iterator 
valid strbuf 	type init 
addf strbuf addf 	iterator type 
strbuf addstr 	next 
strbuf addf strbuf 	xor digest 
addstr strbuf 	decr count 
addf strbuf addf 	type release 
strbuf addstr 	iterator ziplist 
diff filespec binary 	index server 
diff filespec 	ziplist 
binary strbuf reset 	next server 
emit rewrite 	server ziplist 
diff strbuf reset 	zzl score 
diff opt 	memset mix 
tst diff filespec 	digest mix 
binary diff 	digest 
filespec binary 	strlen snprintf 
isreg isreg diff 	mix digest 
opt tst 	strlen xor 
hashcmp fill mmfile 	digest zzl 
fill mmfile 	next dict 
die memcmp strbuf 	iterator 
reset diff 	dict next 
opt tst emit 	dict key 
binary diff 	dict val 
getenv strbuf reset 	snprintf memset 
fill textconv 	mix digest 
fill textconv diff 	mix 
funcname pattern 	digest strlen 
diff funcname pattern 	xor digest 
memset memset 	dict release 
memset want color 	iterator server 
whitespace rule 	panic hash 
check blank eof 	type 
diff opt 	init iterator 
tst xdiff 	hash type 
find func skip 	next memset 
prefix strtoul 	hash type 
skip prefix strtoul 	current mix 
init diff 	digest 
words data xdi 	decr count 
diff outf 	hash type 
die free diff 	current mix 
words data 	digest decr 
free free xdiff 	count xor 
clear find 	digest 
func strbuf release 	hash type 
diff free 	release iterator 
filespec data diff 	server panic 
free filespec 	xor digest 
data free free 	xor digest 
diff pair 	decr 
unmerged diffstat hashcmp 	count dict 
diff filespec 	release iterator 
binary diff 	sdscat strcasecmp 
filespec binary diff 	strcasecmp strcasecmp 
filespec size 	reply strcasecmp 
diff filespec size 	restart 
diff populate 	server reply 
filespec diff populate 	error strcasecmp 
filespec count 	zmalloc zfree 
lines count lines 	reply strcasecmp 
fill mmfile 	encoding server 
fill mmfile die 	info 
memset memset 	strcasecmp rdb 
xdi diff outf 	save reply 
die diff 	empty rdb 
free filespec data 	load reply 
diff free 	error server 
filespec data memset 	log 
whitespace rule 	reply strcasecmp 
merge marker size 	flush append 
fill mmfile 	file empty 
fill mmfile 	load append 
die diff filespec 	file reply 
binary memset 	server 
memset xdi diff 	log reply 
outf die 	strcasecmp dict 
check blank eof 	find reply 
whitespace error 	dict val 
diff free filespec 	str encoding 
data diff 	snprintf 
free filespec data 	snprintf snprintf 
diff opt 	snprintf snprintf 
flexptr alloc str 	reply status 
diff free 	format rdb 
filespec data free 	saved len 
canon mode 	estimate 
hashcpy sha pack 	idle time 
strlen cache 	strcasecmp dict 
name pos 	find reply 
hashcmp isreg skip 	dict val 
worktree uptodate 	dict key 
lstat match stat 	sds 
strbuf addf 	encoded reply 
sha hex strbuf 	error reply 
release strbuf 	status format 
detach diff file 	sdslen sdsavail 
valid die 	sdslen sdsavail 
isdir isgitlink diff 	strcasecmp 
populate gitlink 	reply dict 
reuse worktree file 	expand snprintf 
lstat xsize 	create strlen 
islnk strbuf readlink 	lookup key 
strbuf detach 	write decr 
open xmmap close 	count 
convert git 	snprintf create 
munmap strbuf detach 	strlen decr 
sha info 	count reply 
die sha 	strcasecmp sdsempty 
hex read sha 	compute dataset 
file die 	digest 
sha hex free 	sdscatprintf reply 
munmap diff 	status sdsfree 
free filespec blob 	strcasecmp strtod 
free xstrdup 	nanosleep reply 
basename strbuf addstr 	strcasecmp atoi 
strbuf addstr 	reply 
mks tempfile strlen 	strcasecmp atoi 
die errno 	reply strcasecmp 
convert working write 	sdsnewlen sdscatsds 
full die 	sdsmapchars sdscatlen 
errno close tempfile 	reply sds 
tempfile path 	strcasecmp 
sha hex xsnprintf 	sdsempty sdscatprintf 
strbuf release 	sdscatprintf sdscatprintf 
strbuf release free 	sdscatprintf sdscatprintf 
claim diff 	sdscatprintf sdscatprintf 
tempfile diff 	sdscatprintf reply 
file valid xsnprintf 	bulk 
xsnprintf isgitlink 	sds strcasecmp 
reuse worktree file 	sdsempty reply 
lstat die 	reply error 
errno islnk strbuf 	sdscatprintf dict 
readlink die 	stats sdscat 
errno prep temp 	sdscatprintf 
blob strbuf 	dict stats 
release sha hex 	sdscat reply 
sha hex 	bulk sds 
xsnprintf diff populate 	strcasecmp strcasecmp 
filespec die 	sdsempty malloc 
prep temp blob 	stats 
prepare temp 	print reply 
file argv push 	bulk sds 
argv push 	reply error 
argv push argv 	format reply 
push argv 	error format 
push external 	reply 
diff name external 	error format 
diff name 	bug report 
external diff name 	start server 
argv push 	log server 
argv push argv 	log server 
pushf argv 	log 
pushf run command 	bug report 
opt env 	start server 
die tempfile argv 	log server 
clear argv 	log server 
clear diff color 	log server 
diff color 	log 
diff line prefix 	sds encoded 
strbuf init 	snprintf server 
strbuf addf similarity 	log server 
index strbuf 	log server 
addf quote 	log server 
style strbuf addf 	log 
quote style 	sds encoded 
strbuf addf strbuf 	server log 
addf similarity 	sdslen sdslen 
index strbuf addf 	sdscatrepr sdsempty 
quote style 	sdslen server 
strbuf addf quote 	log 
style strbuf 	sdsfree server 
addf strbuf addf 	log list 
similarity index 	type length 
hashcmp diff opt 	server log 
tst diff 	type size 
opt tst fill 	server 
mmfile diff 	log hash 
filespec binary fill 	type length 
mmfile diff 	server log 
filespec binary strbuf 	zset length 
addf find 	server log 
unique abbrev 	bug 
strbuf addstr find 	report start 
unique abbrev 	server log 
strbuf addf strbuf 	server log 
addf diff 	debug info 
opt tst userdiff 	server print 
find path 	client 
fill metainfo want 	info server 
color run 	print server 
external diff builtin 	bug report 
diff diff 	start server 
file valid hashcpy 	log server 
lstat die 	log 
errno index path 	server log 
die hashclr 	server log 
external diff strcmp 	server log 
strip prefix 	server log 
diff opt tst 	raw server 
diff pair 	log 
unmerged run 	server log 
diff cmd diff 	server log 
fill sha 	server log 
info diff fill 	log stack 
sha info 	content server 
diff file valid 	log 
diff file 	log stack 
valid alloc filespec 	content server 
run diff 	log log 
cmd free strbuf 	stack content 
release alloc 	server log 
filespec run diff 	log 
cmd free 	stack content 
run diff cmd 	server log 
strbuf release 	open close 
diff pair unmerged 	backtrace mcontext 
builtin diffstat 	eip write 
strcmp strip prefix 	strlen 
diff fill 	mcontext eip 
sha info 	backtrace symbols 
diff fill sha 	write strlen 
info builtin 	backtrace symbols 
diffstat diff pair 	close direct 
unmerged strcmp 	log 
strip prefix diff 	filedes server 
fill sha 	log raw 
info diff fill 	cat client 
sha info 	info sdsempty 
builtin checkdiff memcpy 	server log 
diff opt 	sdsfree 
die diff xdl 	decoded server 
tst diff 	log decr 
xdl tst diff 	count decoded 
xdl tst 	dict find 
diff opt diff 	dict val 
opt clr 	server 
diff opt 	log server 
tst diff opt 	log debug 
tst strlen 	info decr 
diff opt diff 	count open 
opt diff 	direct log 
opt read cache 	filedes 
diff opt 	fopen fgets 
tst diff opt 	strchr strchr 
diff opt 	strstr strstr 
tst die isdigit 	strstr strstr 
strtoul strchrnul 	strstr strtoul 
strncmp isdigit strtoul 	strtoul 
die skip 	snprintf write 
prefix skip prefix 	strlen write 
die skip 	memtest preserving 
prefix die skip 	test write 
prefix strtoul 	write fclose 
die strtoul skip 	close 
prefix strtoul 	direct log 
die strtoul 	filedes mcontext 
skip prefix strtoul 	eip unused 
die strtoul 	bug report 
skip prefix strtoul 	start server 
die strtoul 	log 
strtoul strtoul strtoul 	server log 
parse dirstat 	server log 
die strbuf release 	server log 
parse submodule 	server log 
die prepare filter 	raw log 
bits size 	stack 
toupper skip prefix 	trace server 
parse one 	log raw 
token parse one 	gen redis 
token parse 	info sdscatprintf 
one token parse 	dict hash 
one token 	function 
parse one token 	seed server 
parse one 	log raw 
token error 	server log 
strcmp strcmp strcmp 	raw clients 
opt arg 	info server 
enable patch output 	log 
strcmp strcmp 	raw sdsfree 
enable patch output 	sdsfree log 
strcmp strcmp 	current client 
strcmp strcmp parse 	log registers 
dirstat opt 	server log 
skip prefix parse 	raw 
dirstat opt 	bio kill 
skip prefix parse 	threads memtest 
dirstat opt 	test linux 
strcmp parse dirstat 	anonymous maps 
opt strcmp 	server log 
parse dirstat opt 	raw 
skip prefix 	server log 
parse dirstat opt 	raw server 
parse dirstat 	log raw 
opt strcmp 	unlink sigemptyset 
strcmp strcmp enable 	sigaction kill 
patch output 	getpid 
strcmp strcmp strcmp 	server log 
strcmp starts 	server log 
stat opt starts 	raw server 
starts strcmp 	log raw 
diff scoreopt parse 	unused unused 
error starts 	server 
starts strcmp diff 	log handler 
scoreopt parse 	log stack 
error strcmp strcmp 	trace server 
starts starts 	log handler 
strcmp diff opt 	server 
diff scoreopt 	log handler 
parse error strcmp 	setitimer sigemptyset 
strcmp diff 	sigaction watchdog 
opt strcmp diff 	schedule signal 
opt clr 	watchdog schedule 
strcmp diff 	signal 
opt skip prefix 	sigemptyset sigaction 
diff opt 	copyright salvatore 
strcmp diff xdl 	sanfilippo antirez 
strcmp diff 	gmail dot 
xdl clr strcmp 	rights reserved 
strcmp diff 	redistribution 
xdl strcmp strcmp 	use source 
diff xdl 	binary forms 
strcmp diff xdl 	without modification 
strcmp diff 	permitted provided 
xdl strcmp diff 	following conditions 
alg strcmp 	met 
diff alg parse 	redistributions source 
opt parse 	code must 
algorithm error diff 	retain copyright 
xdl clr 	notice list 
strcmp enable 	conditions following 
patch output diff 	disclaimer 
opt strcmp 	redistributions binary 
diff opt strcmp 	form must 
strcmp diff 	reproduce copyright 
opt strcmp diff 	notice list 
opt strcmp 	conditions following 
diff opt strcmp 	disclaimer 
diff opt 	documentation materials 
strcmp diff opt 	provided distribution 
clr diff 	neither name 
opt clr strcmp 	redis names 
skip prefix 	contributors may 
git config colorbool 	used 
error strcmp 	endorse promote 
strcmp skip prefix 	products derived 
strcmp skip 	software without 
prefix strcmp strcmp 	specific prior 
strcmp strcmp 	written permission 
die parse 	software 
opt strcmp diff 	provided copyright 
opt strcmp 	holders contributors 
diff opt strcmp 	express implied 
diff opt 	warranties including 
strcmp diff opt 	limited implied 
clr strcmp 	warranties 
diff opt strcmp 	merchantability fitness 
diff opt 	particular purpose 
clr strcmp diff 	disclaimed shall 
opt handle 	copyright owner 
ignore submodules arg 	contributors liable 
skip prefix 	direct 
diff opt handle 	indirect incidental 
ignore submodules 	special exemplary 
arg strcmp diff 	consequential damages 
opt skip 	including limited 
prefix parse submodule 	procurement substitute 
opt skip 	goods 
prefix parse 	services loss 
error highlight strcmp 	use data 
opt strtoul 	profits business 
opt opt strcmp 	interruption however 
strcmp opt 	caused theory 
prefix filename strlen 	liability 
xstrdup parse 	whether contract 
opt parse diff 	strict liability 
filter opt 	tort including 
die strcmp skip 	negligence otherwise 
prefix strtoul 	arising way 
parse opt parse 	use 
opt strcmp 	software even 
opt arg strcmp 	advised possibility 
diff opt 	damage sha 
strcmp diff opt 	used debug 
strcmp diff 	digest backtrace 
opt clr parse 	debugging 
opt prefix 	compute sha 
filename strlen 	len bytes 
fopen die errno 	sha xored 
skip prefix 	pointed digest 
skip prefix skip 	since xor 
prefix parse 	commutative 
rename score parse 	operation used 
rename score 	order digests 
alloc grow xcalloc 	relative unordered 
diff free 	elements digest 
filespec free filespec 	digest function 
free sha 	instead 
hex find unique 	computing sha 
abbrev strlen 	xoring digest 
xsnprintf xsnprintf sha 	also perform 
hex diff 	digest digest 
line prefix diff 	replace old 
unique abbrev 	one 
diff unique 	digest digest 
abbrev similarity index 	sha digest 
strip prefix 	xor sha 
write name quoted 	data function 
write name 	used every 
quoted strip prefix 	time 
write name 	want preserve 
quoted diff pair 	order digest 
unmerged diff 	different digest 
file valid diff 	also note 
file valid 	mixdigest foo 
diff pair mode 	followed 
changed strcmp 	mixdigest bar 
hashcmp diff unmodified 	lead different 
pair diff 	digest compared 
file valid isdir 	obar compute 
diff file 	dataset digest 
valid isdir run 	since 
diff diff 	keys sets 
unmodified pair 	elements hashes 
diff file valid 	elements ordered 
isdir diff 	use trick 
file valid isdir 	every aggregate 
run diffstat 	digest 
diff unmodified pair 	xor digests 
diff file 	elements way 
valid isdir diff 	order change 
file valid 	result list 
isdir run checkdiff 	instead use 
diff unmodified 	feedback 
pair diff file 	entering output 
valid sha 	digest input 
hex diff debug 	order ensure 
filespec diff 	different ordered 
debug filespec diff 	list result 
debug filepair 	different 
diff debug queue 	digest start 
diff pair 	clean result 
unmerged diff 	hash dataset 
file valid diff 	moved different 
file valid 	lead different 
diff pair type 	digest 
changed diff 	iterate writing 
pair rename strcmp 	every entry 
hashcmp sha 	key val 
error diff debug 	digest save 
queue die 	key associated 
diff flush checkdiff 	key 
diff flush 	expire mix 
raw strip prefix 	xor key 
write name 	val digest 
quoted write name 	digest result 
quoted write 	actually sds 
name quoted pprint 	cast 
rename similarity 	trigger memory 
index free show 	prevent aof 
mode change 	replication number 
diff line 	quicklist nodes 
prefix fputs show 	average quicklist 
file mode 	fill 
name fputs show 	factor quicklist 
file mode 	fill level 
name fputs show 	max ziplist 
rename copy 	size compressed 
fputs show rename 	total uncompressed 
copy write 	size 
name quoted similarity 	newlines errors 
index show 	crash handling 
mode change isspace 	osx osx 
starts space 	linux linux 
git sha update 	linux linux 
git sha 	osx 
init memset memset 	osx amd 
memset error 	osx linux 
diff unmodified 	linux linux 
pair diff file 	amd file 
valid isdir 	descriptor write 
diff file valid 	directly 
isdir diff 	redis log 
pair unmerged diff 	write syscall 
fill sha 	used critical 
info diff fill 	sections code 
sha info 	rest redis 
fill mmfile fill 	trusted 
mmfile error 	example memory 
space strlen space 	test api 
strlen snprintf 	call requires 
snprintf snprintf git 	raw close 
sha update 	close direct 
diff filespec binary 	log 
diff filespec 	filedes used 
binary git sha 	close close 
update sha 	direct log 
hex git 	filedes returns 
sha update sha 	logs stack 
hex xdi 	trace 
diff outf error 	backtrace call 
git sha 	function designed 
diff patch diff 	called signal 
free filepair 	handlers safely 
free diff queue 	log anything 
clear warning 	generate 
warning warning check 	stack trace 
pair status 	avoid warning 
flush one pair 	avoid warning 
diff opt 	write symbols 
tst memset check 	log file 
pair status 	cleanup 
diff flush stat 	log information 
show numstat 	current client 
show stats show 	client currently 
shortstats show 	served redis 
dirstat line 	may redis 
free diffstat info 	serving 
show dirstat 	client right 
summary empty diff 	check first 
summary diff 	argument usually 
opt tst diff 	key found 
opt tst 	inside selected 
fclose fopen die 	print 
errno check 	info associated 
pair status diff 	non destructive 
flush patch 	memory test 
diff line prefix 	executed segfauls 
fputs check 	nothing nothing 
pair status diff 	nothing 
flush patch 	nothing note 
format callback diff 	important close 
free filepair 	file descriptor 
free diff queue 	closing may 
clear fclose 	result unmapping 
diff opt 	memory 
tst diff opt 	region testing 
diff opt 	log stack 
clr filter bit 	trace log 
tst filter 	info client 
bit tst filter 	list log 
bit tst 	current 
diff queue clear 	client log 
filter bit 	dump processor 
tst match filter 	registers test 
diff free 	memory free 
filepair match filter 	messages call 
diff diff 	free 
free filepair free 	possibly corrupted 
isgitlink diff 	memory make 
populate filespec diff 	sure exit 
populate filespec 	right signal 
memcmp diff file 	end instance 
valid diff 	core 
file valid 	dumped enabled 
diff populate filespec 	backtrace logging 
diff populate 	functions debugging 
filespec diff filespec 	software watchdog 
identical diff 	schedule sigalrm 
queue clear diff 	delivery 
filespec check 	specified period 
stat unmatch diff 	milliseconds timer 
diff opt 	already scheduled 
tst diff free 	function schedule 
filepair free 	specified time 
strcmp qsort diffcore 	period 
skip stat 	current timer 
unmatch diffcore diffcore 	disabled stop 
rename diffcore 	timer period 
merge broken diffcore 	automatically restart 
pickaxe diffcore 	enable software 
order diff 	watchdog 
resolve rename copy 	specified period 
diffcore apply 	milliseconds watchdog 
filter diff opt 	actually disabled 
tst diff 	setup signal 
opt diff opt 	handler configured 
clr diff 	period 
warn rename limit 	smaller twice 
diff opt 	timer period 
tst diff opt 	software watchdog 
tst diff 	work reliably 
opt tst diff 	fix needed 
opt tst 	adjust 
diff opt tst 	current timer 
diff opt 	disable software 
tst diff opt 	watchdog already 
tst diffopt 	disabled stop 
flags submodule config 	current timer 
diff opt 	signal 
tst isgitlink 	handler sig 
submodule ignored diff 	ign also 
opt tst 	pending signals 
strncmp alloc filespec 	queue dict.c 
alloc filespec 	size key 
fill filespec fill 	type 
filespec diff 	priv data 
queue diff opt 	ptr buf 
tst diff 	len hash 
opt isgitlink isgitlink 	type priv 
submodule ignored 	data ptr 
diff opt tst 	type 
strncmp alloc 	priv data 
filespec alloc filespec 	ptr size 
fill filespec 	next key 
fill filespec diff 	val index 
queue diff 	entry key 
opt tst diff 	val 
opt tst 	entry auxentry 
diff filespec 	key prevde 
check stat unmatch 	next key 
diff opt 	iter iter 
strncmp alloc filespec 	iter size 
alloc filespec 	key 
diff queue prepare 	malloc dict 
temp file 	init dict 
start command tempfile 	reset dict 
strbuf read 	next power 
error close finish 	dict init 
command strbuf 	calloc 
release tempfile tempfile 	dict hash 
strbuf detach 	key free 
diff file valid 	dict key 
diff populate 	index malloc 
filespec die die 	dict hash 
notes cache 	key 
run textconv die 	dict hash 
notes cache 	val dict 
put notes 	dict find 
cache write diff 	dict hash 
opt tst 	val dict 
check pager config 	free 
setup pager 	entry val 
copyright junio hamano 	dict hash 
context metainfo 	key dict 
fraginfo old commit 	compare hash 
whitespace funcinfo 	keys dict 
use first digit 	free 
ignore digits 	entry key 
nothing give layer 	dict free 
defaults core 	entry val 
level commands git 	free dict 
diff files 	free entry 
never affected setting 	key 
diff renames 	dict free 
user happens 	entry val 
configuration file like 	free free 
gnu diff 	dict reset 
suppress blank empty 	dict clear 
option backwards 	free 
compatibility keep track 	dict hash 
files used 	key dict 
diffing sometimes entry 	compare hash 
refers temporary 	keys malloc 
file sometimes existing 	free dict 
file sometimes 	expand 
dev filename external 	dict expand 
diff read 	dict expand 
entry currently use 	needed dict 
diff tempfile 	hash key 
instance refers temporary 	dict compare 
file tempfile 	hash 
used manage lifetime 	keys hash 
trailing newline 	table implementation 
matter like 	file memory 
fill mmfile size 	hash tables 
avoid retrieving 	insert del 
blob pointing end 	replace 
incomplete line 	find random 
skip last blank 	element operations 
line eof 	hash tables 
paint well emit 	resize needed 
prefix rest 	tables power 
hunk header must 	two 
begin old 	size used 
always least bytes 	collisions handled 
skip hunk 	chaining see 
header fraginfo color 	source code 
trailing blank 	information copyright 
func header filled 	salvatore 
setup code 	sanfilippo antirez 
color enabled color 	gmail dot 
words algorithm 	rights reserved 
described collect 	redistribution use 
minus plus lines 	source binary 
diff hunk 	forms 
divided minus lines 	without modification 
plus lines 	permitted provided 
minus lines plus 	following conditions 
lines words 	met redistributions 
place two mmfile 	source code 
one word 	must 
line use xdiff 	retain copyright 
run diff 	notice list 
two mmfile words 	conditions following 
level diff 	disclaimer redistributions 
common parts file 	binary form 
output plus 	must 
side text diff 	reproduce copyright 
words current 	notice list 
plus used trace 	conditions following 
current position 	disclaimer documentation 
plus file 	materials provided 
printed diff words 	distribution 
last minus 	neither name 
used trace last 	redis names 
minus word 	contributors may 
printed graph work 	used endorse 
color words 	promote products 
need output graph 	derived 
prefix line 	software without 
color words output 	specific prior 
generally two 	written permission 
conditions output prefix 	software provided 
diff words 	copyright holders 
last minus diff 	contributors 
words current 	express implied 
plus diff words 	warranties including 
plus text 	limited implied 
ptr plus 	warranties merchantability 
text must start 	fitness particular 
line minus 	purpose 
word printed graph 	disclaimed shall 
prefix must 	copyright owner 
printed diff words 	contributors liable 
current plus 	direct indirect 
diff words plus 	incidental special 
text ptr 	exemplary 
diff words current 	consequential damages 
plus graph 	including limited 
prefix must printed 	procurement substitute 
following posix 	goods services 
requires first decremented 	loss use 
one len 	data 
function starts looking 	profits business 
begin returns 	interruption however 
iff word found 	caused theory 
find next 	liability whether 
word find 	contract strict 
end word function 	liability 
splits words 	tort including 
buffer text stores 	negligence otherwise 
list newline 	arising way 
separator saves offsets 	use software 
original words 	even 
buffer orig fake 	advised possibility 
empty word 	damage prototypes 
store original boundaries 	hash functions 
store one 	hash function 
word executes word 	popular one 
diff accumulated 	bernstein 
buffers special removal 	tested best 
hunk header 	hash api 
parsed need context 	implementation reset 
color words 	hashtable already 
mode show word 	initialized init 
diff words 	note 
accumulated buffer 	function called 
use already loaded 	destroy create 
driver fallback 	hash table 
settings truncated middle 	initialize hash 
cannot happen 	table expand 
cannot happen eat 	create 
newline eof 	hashtable hashtable 
marker saw line 	size invalid 
nothing without 	smaller number 
diff words flush 	elements already 
defer processing 	inside hashtable 
end preimage lines 	copy 
may come 	elements old 
skip prefix character 	table note 
diff suppress 	old hash 
blank empty may 	table empty 
none incomplete 	size zero 
line end find 	dict 
common prefix 	expand creates 
find common 	hash table 
suffix common prefix 	hash entry 
must end 	slot element 
slash loop run 	index pass 
prefix see 	next 
slash common prefix 	element remap 
cannot would 	hashtable old 
underrun input pfx 	element target 
mid mid 	hash table 
sfx pfx pfx 	index element 
sfx pfx 	element 
sfx sfx name 	already exists 
name make 	allocates memory 
sure least one 	stores key 
printed change 	hash entry 
path easiest way 	fields element 
scale linearly 	discarding 
alloted width one 	old key 
column shorter 	already exists 
result binary 	key added 
diff caller may 	scratch already 
want print 	element key 
files changed insertions 	dict 
deletions omitting 	replace performed 
insertions deletions probably 	update operation 
less confusing 	element key 
skip files changed 	exists dict 
nothing added 	suceed already 
removed lines bug 	exists 
git find 	entry free 
longest filename max 	old one 
number changes 	free old 
shown room one 	one note 
unmerged characters 	important order 
bin xxx yyy 	may 
bytes display 	exactly previous 
change counts 	one context 
aligned bin stop 	think reference 
scanning data 	counting want 
files width stat 	increment decrement 
width term 	free 
columns columns total 	reverse search 
want maximum 	element unlink 
min max len 	element list 
stat name 	found destroy 
width name part 	entire hash 
want maximum 	table 
min max change 	free elements 
stat graph 	free table 
width part also 	allocated cache 
need width 	structure initialize 
max change nnnn 	table never 
one empty 	fails 
column end altogether 	clear release 
width max 	hash table 
change enough 	need save 
space use smaller 	next iterator 
stat name 	user may 
width width filename 	entry 
rest constant 	returning functions 
elements graph part 	expand hash 
stat graph 	table needed 
width graph part 	hash table 
gives filename 	empty expand 
constant parts graph 	intial 
standard terminal 	size table 
size words stat 	full dobule 
width limits 	size hash 
maximum width stat 	table capability 
name width 	power two 
fixes maximum width 	returns 
filename also 	index free 
used divide available 	slot populated 
columns aren 	hash entry 
enough binary 	given key 
files displayed bin 	key already 
xxx yyy 	exists 
bytes instead change 	returned expand 
count graph 	hashtable needed 
part treated similarly 	compute key 
graph part 	hash search 
scaled total width 	slot already 
small accommodate 	contain 
guaranteed minimum width 	given key 
filename part 	hash tables 
separators message message 	implementation file 
overflow making 	memory hash 
line longer maximum 	tables insert 
width guarantee 	del 
graph part filename 	replace find 
part first 	random element 
assign sizes wanted 	operations hash 
ignoring available 	tables resize 
width strlen 	needed tables 
bin xxx yyy 	power 
bytes bin 	two size 
width part starting 	used collisions 
xxx fit 	handled chaining 
graph width adjust 	see source 
adjustable widths 	code information 
exceed maximum width 	copyright 
name width 	salvatore sanfilippo 
width name area 	antirez gmail 
graph width 	dot rights 
width graph area 	reserved redistribution 
max change 	use source 
used scale graph 	binary 
properly scale 	forms without 
filename scale width 	modification permitted 
due sanity 	provided following 
check count 	conditions met 
bytes report dirstat 	redistributions source 
top level 	code 
cases everything came 	must retain 
single directory 	copyright notice 
directory sources sha 	list conditions 
changed pre 	following disclaimer 
post content identical 	redistributions binary 
therefore skip 	form 
looking file contents 	must reproduce 
altogether dirstat 	copyright notice 
file mode really 	list conditions 
need look 	following disclaimer 
actual file contents 	documentation materials 
fact sha 	provided 
changed enough file 	distribution neither 
list results 	name redis 
file contributing equal 	names contributors 
damage original 	may used 
minus copied 	endorse promote 
removed material added 	products 
material damages 	derived software 
made preimage resulting 	without specific 
damage zero 	prior written 
know diffcore count 	permission software 
changes considers 	provided copyright 
two entries identical 	holders 
since content 	contributors express 
changed know must 	implied warranties 
kind change 	including limited 
force entries damage 	implied warranties 
happen even 	merchantability fitness 
many files everything 	particular 
renames show 	purpose disclaimed 
directories changes binary 	shall copyright 
files counts 	owner contributors 
bytes lines must 	liable direct 
find way 	indirect incidental 
normalize binary 	special 
bytes textual lines 	exemplary consequential 
following heuristic 	damages including 
assumes bytes per 	limited procurement 
line stupid 	substitute goods 
ugly cheap happen 	services loss 
even many 	use 
files everything renames 	data profits 
show directories 	business interruption 
changes line thru 	however caused 
line marker 	theory liability 
size firstchar nothing 	whether contract 
could deflated 	strict 
delta could deflated 	liability tort 
two whichever 	including negligence 
smaller emit data 	otherwise arising 
encoded never 	way use 
use non valid 	software even 
filename anywhere 	advised 
possible dev 	possibility damage 
run diff different 	dict enable 
kind objects 	resize dict 
quite common confusing 	disable resize 
crazy xdl 	make possible 
interfaces crazy xdl 	enable 
interfaces codepaths 	disable resizing 
check sides checking 	hash table 
old side 	needed important 
deliberate checking newly 	redis use 
introduced changes 	copy write 
side text check 	want 
introduces crazy 	move much 
xdl interfaces least 	memory around 
one context 	child performing 
line report errors 	saving operations 
given name 	note even 
sha pair 	dict 
index tells file 	resize resizes 
work contents 	prevented hash 
prepare temp file 	table still 
inflate extract 	allowed grow 
read cache benchmark 	ratio number 
previous version 	elements 
always reads cache 	buckets dict 
shows makes 	force resize 
things worse diff 	ratio prototypes 
comparing two 	hash functions 
linux kernel trees 	thomas wang 
already work 	bit 
diff comparisons deal 	mix function 
small number 	murmur hash 
files reading cache 	austin appleby 
expensive large 	note code 
project cost outweighs 	makes assumptions 
savings inflating 	machine 
temporary file 	behaves read 
practically code helps 	address without 
used diff 	crashing limitations 
cache cached read 	work incrementally 
cache calling 	produce results 
want avoid working 	little 
directory caller 	endian big 
doesn need data 	endian machines 
normal file 	mixing constants 
system rather slow 	generated offline 
stat open 	really magic 
mmap close syscalls 	happen 
contained pack 	work well 
file pack probably 	initialize hash 
already open 	random mix 
faster obtain data 	bytes time 
working directory 	hash handle 
loose objects however 	last 
would tend 	bytes input 
slower need 	mixes hash 
individually opened inflated 	ensure last 
sha looking 	bytes well 
unreusable regular file 	incorporated insensitive 
marked unchanged 	hash 
guarantee work matches 	function djb 
looking matches 	hash hash 
file work reuse 	api implementation 
looking work 	reset hash 
rename detection pickaxe 	table already 
operation may 	initialized 
need grab data 	init note 
blob file 	function called 
core comparison diff 	destroy create 
filespec data 	hash table 
size fields purpose 	initialize hash 
demote fail 	table 
warn allow inspecting 	resize table 
situation instead 	minimal size 
refusing convert 	contains elements 
working format canonical 	invariant used 
git format 	buckets ratio 
generate xxxxxx basename 	near 
ext entry 	expand create 
produces file entry 	hash table 
produces file 	hash table 
borrow file work 	size invalid 
even though 	smaller number 
may sometimes borrow 	elements 
contents work 	already inside 
always want one 	hash table 
mode mode 	rehashing table 
trustworthy even one 	size useful 
sha valid 	allocate hash 
diff file valid 	table 
one external 	initialize pointers 
diff command takes 	first initialization 
diff cmd 	really rehashing 
name infile 	first hash 
infile sha infile 	table accept 
mode infile 	keys 
infile sha infile 	prepare second 
mode rename 	hash table 
fallthru use colors 	incremental rehashing 
header intended 	performs steps 
external diff driver 	incremental rehashing 
strip prefix 	returns 
molest dev absolute 	still keys 
paths filepair 	move old 
changes file symlink 	hash table 
needs split 	otherwise returned 
deletion creation unmerged 	note rehashing 
unmerged pathchange 	step 
left time say 	consists moving 
changes checking 	bucket may 
changed paths 	one key 
ignore whitespace options 	use chaining 
force look 	old hash 
inside contents cases 	table 
always need 	however since 
recursive drop caller 	part hash 
supplied recursive 	table may 
bits formats also 	composed empty 
pickaxe would 	spaces guaranteed 
work well say 	function 
recursive patches 	rehash even 
generated submodules diffed 	single bucket 
work must 	since visit 
dirtiness shown output 	max empty 
read cache 	buckets total 
die even fails 	otherwise 
safe also 	amount work 
smudge active cache 	would unbound 
active fails 	function may 
worry cleaning 	block time 
either full make 	max number 
sense show 	empty 
first hit happened 	buckets visit 
found make 	note rehashidx 
sense exit code 	overflow sure 
either stuck 	elements used 
form option separate 	move keys 
form option 	bucket 
important checks error 	old hash 
cases caller 	index hash 
knows dirstat related 	table check 
option given 	already rehashed 
command line allow 	whole table 
say function 	rehash 
negation input haven 	rehash amount 
initialized filter 	time milliseconds 
field another diff 	milliseconds function 
filter start 	performs step 
full bits 	rehashing safe 
aon output format 	iterators 
options stat 	bound hash 
stat width stat 	table iterators 
name width 	middle rehashing 
stat count renames 	mess two 
options xdiff 	hash tables 
options clear previous 	otherwise 
settings flags 	element missed 
options misc options 	duplicated function 
always end 	called common 
user says num 	lookup update 
divided scale 	operations dictionary 
say internally max 	hash 
score num 	table automatically 
scale convert form 	migrates actively 
arguments form 	used element 
versions option expect 	target hash 
different find 	table low 
unique abbrev 	level 
stuffs result dots 	function adds 
alignment function 	entry instead 
written stricter necessary 	setting returns 
support currently 	dict entry 
implemented transformers idea 	structure user 
transformers produce 	make 
diff filepairs way 	sure fill 
want filter 	field wishes 
clean producing output 	function also 
unmerged interesting 	directly exposed 
deletion addition mode 	user api 
type change 	called 
rename interesting valid 	mainly order 
point path 	store non 
dealing change change 	pointers inside 
look file 	hash example 
filesystem diffs 	entry dict 
patch format useful 	raw 
stat diffs 	dict mykey 
nothing check diffs 	entry dict 
undecided point 	integer val 
dealing pair whose 	entry values 
sides valid 	key already 
type either place 	exists 
edit rename 	returned key 
copy edit rename 	added hash 
might connected 	entry returned 
broken pair causing 	manipulated caller 
pathnames rename 	index element 
modification otherwise see 	element 
source used 	already exists 
multiple renames decrement 	allocate memory 
count call 	store entry 
copy change entry 	insert element 
happen anymore 	top assumption 
prepare broken 	database 
callers ignore line 	system likely 
numbers computing 	recently added 
sha patch returns 	entries accessed 
upon success 	frequently hash 
writes result sha 	entry fields 
order raw 	element 
stat summary patch 	discarding old 
name name 	key already 
status checkdiff bits 	exists key 
clear run 	added scratch 
diff flush patch 	already element 
exit status 	key 
setting options file 	dict replace 
dev safe 	performed update 
aren supposed produce 	operation element 
output anyway 	key exists 
attach patch instead 	dict suceed 
report content 	already 
level differences 	exists entry 
changes diff addremove 	free old 
diff change 	one note 
bit diff contents 	important order 
effect otherwise 	may exactly 
clear whole queue 	previous 
copying empty 	one context 
outq end function 	think reference 
first clear 	counting want 
current entries queue 	increment decrement 
matching ones 	free reverse 
check whether two 	dict 
filespecs mode 	replace raw 
size identical entries 	simply version 
come stat 	dict raw 
info dirtiness always 	always returns 
sides iow 	hash 
create one side 	entry specified 
name unknown 	key even 
mode size 	key already 
keep ones match 	exists added 
criteria real 	entry already 
differences point file 	existing 
known modified 	key returned 
mode size name 	see dict 
one side 	raw information 
unknown need inspect 	search element 
identical contents 	table unlink 
caller subtract skip 	element 
stat unmatch 	list found 
determine many paths 	destroy entire 
dirty due 	dictionary free 
stat info mismatch 	elements free 
note please 	table allocated 
keep following sync 	cache 
diff combined 	structure initialize 
see follow 	table never 
renames diff see 	fails clear 
follow renames 	release hash 
diff shall changes 	table table 
submodule ignored 	fingerprint 
submodule changes configured 	bit number 
ignored separately 	represents state 
path configuration overridden 	dictionary given 
command line 	time dict 
may look odd 	properties xored 
preparation feeding 	together 
unchanged files produce 	iterator initialized 
diffs copy 	dict fingerprint 
detection would need 	check fingerprint 
entries diff 	iterator released 
core prefixed something 	two fingerprints 
like haven 	different 
decided make difference 	means user 
feeding old 	iterator performed 
diff change 	forbidden operations 
also effect output 	dictionary iterating 
happens pruned 	hash integers 
merged rename copy 	summing 
pairs appropriate 	every successive 
ignore errors might 	integer integer 
repository could 	hashing previous 
save changes flush 	sum basically 
end would 	result hash 
need extra call 	hash 
diffing done 	hash way 
since generating cache 	integers different 
entry slow 	order likely 
path anyway extra 	hash different 
overhead probably 	number hashing 
isn big deal 	step 
user asked 	use tomas 
exit code either 	wang bit 
want quiet 	integer hash 
exit code 	hash hash 
definitely bother pager 	hash hash 
former generate 	hash 
output since still 	need save 
properly report 	next iterator 
exit code even 	user may 
pager run 	entry returning 
could run pager 	random entry 
exit code 	hash 
since done historically 	table useful 
easy find 	implement randomized 
people oneline advising 	algorithms sure 
git diff 	elements indexes 
exit code hooks 	rehashidx found 
scripts builtin 	non 
git diff copyright 	empty bucket 
junio hamano 	linked list 
blob file working 	need random 
make sure 	element list 
one revision 	sane way 
pending revision filtering 	counting 
parameters saw 	elements random 
two trees ent 	index function 
ent ent 	samples dictionary 
uninteresting swap diff 	keys random 
combine merges 	locations guarantee 
asked diff densify 	keys 
user wants 	specified count 
dense one explicitly 	guarantee non 
asked rely 	duplicated elements 
could ish rev 	however make 
pending objects 	effort things 
list also could 	returned 
blobs pathspecs 	pointers hash 
cache files diff 	table entries 
files compare 	stored des 
two random blobs 	points dict 
must zero 	entry pointers 
compare blob 	must 
working file cache 	room least 
diff index 	count elements 
cached diff compare 	argument pass 
two filesystem 	function tell 
entities aka index 	many random 
cases errors 	elements 
asked index explicitly 	need function 
treat git 	returns number 
diff least one 	items stored 
path outside 	des may 
repo command would 	less count 
executed outside 	hash 
git repository behaves 	table less 
way git 	count elements 
diff index acts 	inside enough 
colourful diff 	elements found 
replacement index 	reasonable amount 
two paths possible 	steps 
user intended 	note function 
inside repository operation 	suitable need 
give usage 	good distribution 
message non repository 	returned items 
usage exit 	need sample 
index diff run 	given 
exit otherwise 	number continuous 
usual git diff 	elements run 
scale real 	kind algorithm 
terminal size respect 	produce statistics 
stat graph 	however function 
width config external 	much 
textconv used 	faster dict 
cached pending head 	random key 
hand eek 	producing elements 
arguments look reasonable 	hash table 
diff least 	tables rehashing 
one merge 	work 
ent objects merge 	proportional count 
ent objects 	pick random 
ents ent objects 	point inside 
ents show 	larger table 
diff note pick 	continuous empty 
one merge 	entries 
random one sha 	far invariant 
name mode 	dict rehashing 
builtin diff usage 	indexes already 
opt old 	visited rehashing 
mode mode old 	populated buckets 
sha sha 	skip 
old sha valid 	indexes idx 
sha valid 	moreover currently 
old name name 	range second 
one two 	table elements 
tmp tmp tmp 	tables current 
revs argc 	rehashing 
argv blob 	index jump 
path revs argc 	possible happens 
argv blob 	going big 
mode revs argc 	small table 
argv cached 	range table 
arg revs argc 	count 
argv ent 	contiguous empty 
ent swap revs 	buckets jump 
argc argv 	locations reach 
ent ents parents 	count minimum 
file revs 	collect elements 
argc argv options 	buckets 
argc argv 	found non 
prefix rev ent 	empty iterating 
paths blob 	function reverse 
index result arg 	bits algorithm 
entry obj 	http graphics 
name flags sha 	stanford 
sha hashcmp 	edu seander 
diff opt 	bithacks html 
tst strncmp strncmp 	reverse parallel 
alloc filespec 	bit size 
alloc filespec fill 	must power 
filespec fill 	dict 
filespec diff queue 	scan used 
usage guard 	iterate elements 
pathspec lstat die 	dictionary iterating 
errno isreg 	works following 
islnk die diff 	way initially 
mnemonic prefix 	call 
canon mode stuff 	function cursor 
change canon 	function performs 
mode diffcore std 	one step 
diff flush 	iteration returns 
canon mode usage 	cursor must 
stuff change 	use 
diffcore std 	next call 
diff flush strcmp 	returned cursor 
strcmp usage 	iteration complete 
usage setup work 	function guarantees 
read cache 	elements present 
preload perror read 	dictionary 
cache perror 	returned start 
run diff index 	end iteration 
usage diff 	however possible 
sha log diff 	elements returned 
flush usage 	multiple times 
sha append diff 	every 
combined sha 	element returned 
clear xcalloc hold 	callback argument 
locked index 	called privdata 
discard cache read 	first argument 
cache refresh 	dictionary entry 
cache update index 	second 
able strcmp 	argument works 
strcmp strcmp 	iteration algorithm 
strcmp strcmp usage 	designed pieter 
error setup 	noordhuis main 
work read cache 	idea increment 
preload perror 	cursor 
run diff files 	starting higher 
strcmp strcmp 	order bits 
setup git directory 	instead incrementing 
gently path 	cursor normally 
inside repo path 	bits cursor 
inside repo 	reversed 
gitmodules config git 	cursor incremented 
config init 	bits reversed 
revisions usagef diff 	strategy needed 
index diff 	hash table 
opt diff opt 	may resized 
die setup 	iteration 
revisions diff setup 	calls dict 
done diff 	hash tables 
opt setup 	always power 
diff pager strcmp 	two size 
strcmp strcmp 	use chaining 
head pending lookup 	position 
pending parse 	element given 
deref tag die 	table given 
die hashcpy 	computing bitwise 
die builtin diff 	hash key 
files usage 	size size 
builtin diff usage 	always 
builtin diff 	mask equivalent 
blobs usage usage 	taking rest 
builtin diff 	division hash 
index builtin diff 	key size 
builtin diff 	example current 
builtin diff combined 	hash 
diff result 	table size 
code refresh index 	mask binary 
quietly copyright 	position key 
junio hamano 	hash table 
context metainfo fraginfo 	always last 
old commit 	four 
whitespace funcinfo use 	bits hash 
first digit 	output forth 
ignore digits nothing 	happens table 
give layer 	changes size 
defaults core level 	hash table 
commands git 	grows 
diff files never 	elements anywhere 
affected setting 	one multiple 
diff renames user 	old bucket 
happens configuration 	example say 
file like gnu 	already iterated 
diff suppress 	bit 
blank empty option 	cursor mask 
backwards compatibility 	hash table 
keep track 	size hash 
files used diffing 	table resized 
sometimes entry 	elements mask 
refers temporary file 	buckets 
sometimes existing 	obtain substituting 
file sometimes dev 	either targeted 
filename external 	keys already 
diff read entry 	visited scanning 
currently use 	bucket smaller 
diff tempfile instance 	hash 
refers temporary 	table iterating 
file tempfile used 	higher bits 
manage lifetime 	first inverted 
trailing newline matter 	counter cursor 
like fill 	need restart 
mmfile size avoid 	table 
retrieving blob 	size gets 
pointing end incomplete 	bigger iterating 
line skip 	cursors without 
last blank 	end also 
line eof paint 	without combination 
well emit 	bits 
prefix rest hunk 	already explored 
header must 	similarly table 
begin old always 	size shrinks 
least bytes 	time example 
skip hunk header 	going combination 
fraginfo color 	lower 
trailing blank func 	three bits 
header filled 	mask size 
setup code color 	already completely 
enabled color 	explored would 
words algorithm described 	visited sure 
collect minus 	tried 
plus lines diff 	example variations 
hunk divided 	higher bit 
minus lines plus 	need test 
lines minus 	wait two 
lines plus 	tables rehashing 
lines words place 	yes 
two mmfile 	always iterate 
one word line 	smaller table 
use xdiff 	first test 
run diff two 	expansions current 
mmfile words 	cursor larger 
level diff common 	table 
parts file 	example current 
output plus side 	cursor also 
text diff 	larger table 
words current plus 	size also 
used trace 	test inside 
current position plus 	larger 
file printed 	table reduces 
diff words last 	problem back 
minus used 	one table 
trace last minus 	larger one 
word printed 	exists expansion 
graph work 	smaller 
color words need 	one limitations 
output graph 	iterator completely 
prefix line color 	stateless huge 
words output 	advantage including 
generally two conditions 	additional memory 
output prefix 	used 
diff words last 	disadvantages resulting 
minus diff 	design possible 
words current plus 	elements however 
diff words 	usually easy 
plus text ptr 	deal application 
plus text 	level 
must start line 	iterator must 
minus word 	multiple elements 
printed graph prefix 	per call 
must printed 	needs always 
diff words current 	keys chained 
plus diff 	given 
words plus 	bucket expansions 
text ptr diff 	sure miss 
words current 	keys moving 
plus graph prefix 	rehashing reverse 
must printed 	cursor somewhat 
following posix requires 	hard 
first decremented 	understand first 
one len function 	comment supposed 
starts looking 	help emit 
begin returns iff 	entries cursor 
word found 	make sure 
find next word 	smaller 
find end 	bigger table 
word function splits 	emit entries 
words buffer 	cursor iterate 
text stores list 	indices larger 
newline separator 	table expansion 
saves offsets 	index 
original words buffer 	pointed cursor 
orig fake 	smaller table 
empty word store 	emit entries 
original boundaries 	cursor increment 
store one word 	bits covered 
executes word 	smaller 
diff accumulated buffers 	mask bits 
special removal 	covered mask 
hunk header parsed 	difference non 
need context 	zero unmasked 
color words mode 	bits incrementing 
show word 	reversed 
diff words accumulated 	cursor operates 
buffer use 	masked bits 
already loaded driver 	smaller table 
fallback settings 	increment reverse 
truncated middle cannot 	cursor functions 
happen cannot 	expand 
happen eat 	hash table 
newline eof marker 	needed incremental 
saw line 	rehashing already 
nothing without diff 	progress hash 
words flush 	table empty 
defer processing end 	expand 
preimage lines 	initial size 
may come skip 	reached ratio 
prefix character 	allowed resize 
diff suppress blank 	hash table 
empty may 	setting avoid 
none incomplete line 	ratio 
end find 	elements buckets 
common prefix find 	safe threshold 
common suffix 	resize doubling 
common prefix must 	number buckets 
end slash 	hash table 
loop run prefix 	capability 
see slash 	power two 
common prefix 	returns index 
cannot would underrun 	free slot 
input pfx 	populated hash 
mid mid sfx 	entry given 
pfx pfx 	key 
sfx pfx sfx 	key already 
sfx name 	exists returned 
name make sure 	note process 
least one 	rehashing hash 
printed change path 	table index 
easiest way 	always 
scale linearly alloted 	returned context 
width one 	second hash 
column shorter result 	table expand 
binary diff 	hash table 
caller may want 	needed compute 
print files 	key 
changed insertions deletions 	hash search 
omitting insertions 	slot already 
deletions probably 	contain given 
less confusing skip 	key debugging 
files changed 	compute stats 
nothing added removed 	hash 
lines bug 	entry slot 
git find longest 	generate human 
filename max 	readable stats 
number changes shown 	unlike snprintf 
room one 	teturn number 
unmerged characters bin 	characters 
xxx yyy 	actually written 
bytes display change 	make sure 
counts aligned 	term end 
bin stop scanning 	dict resize 
data files 	dict force 
width stat width 	resize 
term columns 	ratio size 
columns total 	key type 
want maximum min 	priv data 
max len 	ptr key 
stat name width 	dict 
name part 	hash function 
want maximum min 	seed seed 
max change 	key len 
stat graph width 	seed data 
part also 	buf len 
need width max 	hash 
change nnnn 	type priv 
one empty column 	data ptr 
end altogether 	type priv 
width max change 	data ptr 
enough space 	minimal size 
use smaller stat 	realsize 
name width 	empty visits 
width filename rest 	nextde start 
constant elements 	rehashes key 
graph part 	val entry 
stat graph width 	key index 
graph part 	entry 
gives filename constant 	key val 
parts graph 	entry auxentry 
standard terminal size 	key entry 
words stat 	key nofree 
width limits maximum 	idx prev 
width stat 	table 
name width fixes 	key key 
maximum width 	callback next 
filename also used 	key idx 
divide available 	table key 
columns aren enough 	integers hash 
binary files 	iter 
displayed bin xxx 	iter iter 
yyy bytes 	orighe listlen 
instead change count 	listele des 
graph part 	count tables 
treated similarly 	maxsizemask maxsteps 
graph part scaled 	emptylen 
total width 	mask privdata 
small accommodate guaranteed 	size key 
minimum width 	idx table 
filename part separators 	callback buf 
message message 	bufsize tableid 
overflow making line 	chainlen 
longer maximum 	maxchainlen totchainlen 
width guarantee graph 	clvector buf 
part filename 	bufsize orig 
part first assign 	buf orig 
sizes wanted 	bufsize tolower 
ignoring available width 	zmalloc 
strlen bin 	dict init 
xxx yyy bytes 	dict reset 
bin width 	dict reset 
part starting xxx 	dict rehashing 
fit graph 	dict expand 
width adjust 	dict 
adjustable widths exceed 	next power 
maximum width 	dict rehashing 
name width width 	zcalloc dict 
name area 	rehashing dict 
graph width width 	hash key 
graph area 	zfree 
max change used 	dict reset 
scale graph 	gettimeofday time 
properly scale filename 	milliseconds dict 
scale width 	rehash time 
due sanity check 	milliseconds dict 
count bytes 	rehash 
report dirstat top 	dict raw 
level cases 	dict val 
everything came single 	dict rehashing 
directory directory 	dict rehash 
sources sha 	step dict 
changed pre post 	key 
content identical 	index dict 
therefore skip looking 	rehashing zmalloc 
file contents 	dict key 
altogether dirstat file 	dict dict 
mode really 	find dict 
need look actual 	val 
file contents 	dict free 
fact sha changed 	val dict 
enough file 	find dict 
list results file 	raw dict 
contributing equal 	rehashing dict 
damage original minus 	rehash 
copied removed 	step dict 
material added material 	hash key 
damages made 	dict compare 
preimage resulting damage 	keys dict 
zero know 	free key 
diffcore count 	dict 
changes considers two 	free val 
entries identical 	zfree dict 
since content changed 	rehashing dict 
know must 	dict callback 
kind change force 	dict free 
entries damage 	key 
happen even many 	dict free 
files everything 	val zfree 
renames show directories 	zfree dict 
changes binary 	reset dict 
files counts bytes 	clear dict 
lines must 	clear 
find way normalize 	zfree dict 
binary bytes 	rehashing dict 
textual lines following 	rehash step 
heuristic assumes 	dict hash 
bytes per line 	key dict 
stupid ugly 	compare 
cheap happen 	keys dict 
even many files 	rehashing dict 
everything renames 	find dict 
show directories changes 	val zmalloc 
line thru 	dict iterator 
line marker size 	dict 
firstchar nothing 	fingerprint dict 
could deflated delta 	rehashing dict 
could deflated 	fingerprint zfree 
two whichever smaller 	dict size 
emit data 	dict rehashing 
encoded never use 	dict 
non valid 	rehash step 
filename anywhere possible 	dict rehashing 
dev run 	random random 
diff different kind 	random dict 
objects quite 	size dict 
common confusing crazy 	size 
xdl interfaces 	dict rehashing 
crazy xdl 	dict rehash 
interfaces codepaths check 	step dict 
sides checking 	rehashing random 
old side deliberate 	random dict 
checking newly 	size 
introduced changes side 	dict rehashing 
text check 	rev rev 
introduces crazy xdl 	dict rehashing 
interfaces least 	dict expand 
one context line 	dict expand 
report errors 	dict 
given name sha 	expand needed 
pair index 	dict hash 
tells file work 	key dict 
contents prepare 	compare keys 
temp file inflate 	dict rehashing 
extract read 	dict 
cache benchmark previous 	clear dict 
version always 	clear snprintf 
reads cache 	snprintf snprintf 
shows makes things 	strlen dict 
worse diff 	stats dict 
comparing two linux 	rehashing 
kernel trees 	dict stats 
already work diff 	hash table 
comparisons deal 	implementation file 
small number files 	memory hash 
reading cache 	tables insert 
expensive large project 	del 
cost outweighs 	replace find 
savings inflating temporary 	random element 
file practically 	operations hash 
code helps used 	tables resize 
diff cache 	needed tables 
cached read cache 	power 
calling want 	two size 
avoid working 	used collisions 
directory caller doesn 	handled chaining 
need data 	see source 
normal file system 	code information 
rather slow 	copyright 
stat open mmap 	salvatore sanfilippo 
close syscalls 	antirez gmail 
contained pack file 	dot rights 
pack probably 	reserved redistribution 
already open faster 	use source 
obtain data 	binary 
working directory loose 	forms without 
objects however 	modification permitted 
would tend slower 	provided following 
need individually 	conditions met 
opened inflated sha 	redistributions source 
looking unreusable 	code 
regular file marked 	must retain 
unchanged guarantee 	copyright notice 
work matches 	list conditions 
looking matches file 	following disclaimer 
work reuse 	redistributions binary 
looking work rename 	form 
detection pickaxe 	must reproduce 
operation may need 	copyright notice 
grab data 	list conditions 
blob file core 	following disclaimer 
comparison diff 	documentation materials 
filespec data size 	provided 
fields purpose 	distribution neither 
demote fail warn 	name redis 
allow inspecting 	names contributors 
situation instead refusing 	may used 
convert working 	endorse promote 
format canonical git 	products 
format generate 	derived software 
xxxxxx basename ext 	without specific 
entry produces 	prior written 
file entry 	permission software 
produces file borrow 	provided copyright 
file work 	holders 
even though may 	contributors express 
sometimes borrow 	implied warranties 
contents work always 	including limited 
want one 	implied warranties 
mode mode trustworthy 	merchantability fitness 
even one 	particular 
sha valid diff 	purpose disclaimed 
file valid 	shall copyright 
one external diff 	owner contributors 
command takes 	liable direct 
diff cmd name 	indirect incidental 
infile infile 	special 
sha infile mode 	exemplary consequential 
infile infile 	damages including 
sha infile mode 	limited procurement 
rename fallthru 	substitute goods 
use colors 	services loss 
header intended external 	use 
diff driver 	data profits 
strip prefix molest 	business interruption 
dev absolute 	however caused 
paths filepair changes 	theory liability 
file symlink 	whether contract 
needs split deletion 	strict 
creation unmerged 	liability tort 
unmerged pathchange left 	including negligence 
time say 	otherwise arising 
changes checking changed 	way use 
paths ignore 	software even 
whitespace options force 	advised 
look inside 	possibility damage 
contents cases always 	prototypes hash 
need recursive 	functions hash 
drop caller 	function popular 
supplied recursive bits 	one bernstein 
formats also 	tested 
pickaxe would work 	best hash 
well say 	api implementation 
recursive patches generated 	reset hashtable 
submodules diffed 	already initialized 
work must dirtiness 	init note 
shown output 	function 
read cache die 	called destroy 
even fails 	create hash 
safe also smudge 	table initialize 
active cache 	hash table 
active fails worry 	expand create 
cleaning either 	hashtable 
full make sense 	hashtable size 
show first 	invalid smaller 
hit happened found 	number elements 
make sense 	already inside 
exit code 	hashtable copy 
either stuck form 	elements 
option separate 	old table 
form option important 	note old 
checks error 	hash table 
cases caller knows 	empty size 
dirstat related 	zero dict 
option given command 	expand 
line allow 	creates hash 
say function negation 	table hash 
input haven 	entry slot 
initialized filter field 	element index 
another diff 	pass next 
filter start full 	element 
bits aon 	remap hashtable 
output format options 	old element 
stat stat 	target hash 
width stat name 	table index 
width stat 	element element 
count renames 	already 
options xdiff options 	exists allocates 
clear previous 	memory stores 
settings flags options 	key hash 
misc options 	entry fields 
always end user 	element discarding 
says num 	old 
divided scale say 	key already 
internally max 	exists key 
score num scale 	added scratch 
convert form 	already element 
arguments form versions 	key dict 
option expect 	replace 
different find unique 	performed update 
abbrev stuffs 	operation element 
result dots alignment 	key exists 
function written 	dict suceed 
stricter necessary support 	already exists 
currently implemented 	entry 
transformers idea 	free old 
transformers produce diff 	one free 
filepairs way 	old one 
want filter clean 	note important 
producing output 	order may 
unmerged interesting deletion 	exactly 
addition mode 	previous one 
type change rename 	context think 
interesting valid 	reference counting 
point path dealing 	want increment 
change change 	decrement free 
look file filesystem 	reverse 
diffs patch 	search element 
format useful stat 	unlink element 
diffs nothing 	list found 
check diffs undecided 	destroy entire 
point dealing 	hash table 
pair whose 	free 
sides valid type 	elements free 
either place 	table allocated 
edit rename copy 	cache structure 
edit rename 	initialize table 
might connected broken 	never fails 
pair causing 	clear 
pathnames rename modification 	release hash 
otherwise see 	table need 
source used multiple 	save next 
renames decrement 	iterator user 
count call copy 	may entry 
change entry 	returning 
happen anymore prepare 	functions expand 
broken callers 	hash table 
ignore line numbers 	needed hash 
computing sha 	table empty 
patch returns upon 	expand intial 
success writes 	size 
result sha 	table full 
order raw stat 	dobule size 
summary patch 	hash table 
name name status 	capability power 
checkdiff bits 	two returns 
clear run diff 	index 
flush patch 	free slot 
exit status setting 	populated hash 
options file 	entry given 
dev safe aren 	key key 
supposed produce 	already exists 
output anyway attach 	returned 
patch instead 	expand hashtable 
report content level 	needed compute 
differences changes 	key hash 
diff addremove diff 	search slot 
change bit 	already contain 
diff contents effect 	given 
otherwise clear 	key hash 
whole queue 	tables implementation 
copying empty outq 	file memory 
end function 	hash tables 
first clear current 	insert del 
entries queue 	replace 
matching ones check 	find random 
whether two 	element operations 
filespecs mode size 	hash tables 
identical entries 	resize needed 
come stat info 	tables power 
dirtiness always 	two 
sides iow create 	size used 
one side 	collisions handled 
name unknown mode 	chaining see 
size keep 	source code 
ones match criteria 	information copyright 
real differences 	salvatore 
point file known 	sanfilippo antirez 
modified mode 	gmail dot 
size name 	rights reserved 
one side unknown 	redistribution use 
need inspect 	source binary 
identical contents caller 	forms 
subtract skip 	without modification 
stat unmatch determine 	permitted provided 
many paths 	following conditions 
dirty due stat 	met redistributions 
info mismatch 	source code 
note please keep 	must 
following sync 	retain copyright 
diff combined see 	notice list 
follow renames 	conditions following 
diff see follow 	disclaimer redistributions 
renames diff 	binary form 
shall changes submodule 	must 
ignored submodule 	reproduce copyright 
changes configured ignored 	notice list 
separately path 	conditions following 
configuration overridden 	disclaimer documentation 
command line may 	materials provided 
look odd 	distribution 
preparation feeding unchanged 	neither name 
files produce 	redis names 
diffs copy detection 	contributors may 
would need 	used endorse 
entries diff core 	promote products 
prefixed something 	derived 
like haven decided 	software without 
make difference 	specific prior 
feeding old diff 	written permission 
change also 	software provided 
effect output happens 	copyright holders 
pruned merged 	contributors 
rename copy pairs 	express implied 
appropriate ignore 	warranties including 
errors might 	limited implied 
repository could save 	warranties merchantability 
changes flush 	fitness particular 
end would need 	purpose 
extra call 	disclaimed shall 
diffing done since 	copyright owner 
generating cache 	contributors liable 
entry slow path 	direct indirect 
anyway extra 	incidental special 
overhead probably isn 	exemplary 
big deal 	consequential damages 
user asked exit 	including limited 
code either 	procurement substitute 
want quiet exit 	goods services 
code definitely 	loss use 
bother pager former 	data 
generate output 	profits business 
since still properly 	interruption however 
report exit 	caused theory 
code even 	liability whether 
pager run could 	contract strict 
run pager 	liability 
exit code since 	tort including 
done historically 	negligence otherwise 
easy find people 	arising way 
oneline advising 	use software 
git diff exit 	even advised 
code hooks 	possibility 
scripts builtin git 	damage dict 
diff copyright 	enable resize 
junio hamano blob 	dict disable 
file working 	resize make 
make sure one 	possible 
revision pending 	enable disable 
revision filtering parameters 	resizing hash 
saw two 	table needed 
trees ent ent 	important redis 
ent uninteresting 	use copy 
swap diff 	write 
combine merges asked 	want move 
diff densify 	much memory 
user wants dense 	around child 
one explicitly 	performing saving 
asked rely could 	operations note 
ish rev 	even 
pending objects list 	dict resize 
also could 	resizes prevented 
blobs pathspecs cache 	hash table 
files diff 	still allowed 
files compare two 	grow ratio 
random blobs 	number 
must zero compare 	elements buckets 
blob working 	dict force 
file cache diff 	resize ratio 
index cached 	prototypes hash 
diff compare two 	functions thomas 
filesystem entities 	wang 
aka index 	bit mix 
cases errors asked 	function murmur 
index explicitly 	hash austin 
treat git diff 	appleby note 
least one 	code makes 
path outside repo 	assumptions 
command would 	machine behaves 
executed outside git 	read address 
repository behaves 	without crashing 
way git diff 	limitations work 
index acts 	incrementally produce 
colourful diff replacement 	results 
index two 	little endian 
paths possible user 	big endian 
intended inside 	machines mixing 
repository operation give 	constants generated 
usage message 	offline really 
non repository 	magic 
usage exit index 	happen work 
diff run 	well initialize 
exit otherwise usual 	hash random 
git diff 	mix bytes 
scale real terminal 	time hash 
size respect 	handle 
stat graph width 	last bytes 
config external 	input mixes 
textconv used cached 	hash ensure 
pending head 	last bytes 
hand eek arguments 	well incorporated 
look reasonable 	insensitive 
diff least one 	hash function 
merge ent 	djb hash 
objects merge ent 	hash api 
objects ents 	implementation reset 
ent objects ents 	hash table 
show diff 	already 
note pick 	initialized init 
one merge random 	note function 
one diff.c 	called destroy 
diff detect rename 	create hash 
diff rename 	table initialize 
limit diff suppress 	hash 
blank empty 	table resize 
diff use color 	table minimal 
diff context 	size contains 
diff word regex 	elements invariant 
cfg external 	used buckets 
diff cmd cfg 	ratio 
diff order 	near expand 
file cfg diff 	create hash 
refresh index 	table hash 
diff mnemonic prefix 	table size 
diff prefix 	invalid smaller 
diff stat graph 	number 
width diff 	elements already 
dirstat permille 	inside hash 
diff options diff 	table rehashing 
algorithm diff 	table size 
colors options errmsg 	useful allocate 
copy ret 	hash 
end permille options 	table initialize 
name slot 	pointers first 
errmsg one two 	initialization really 
need one 	rehashing first 
need two res 	hash table 
external diff 	accept 
cmd done preparing 	keys prepare 
name hex 	second hash 
mode tempfile color 	table incremental 
diff rule 	rehashing performs 
blank eof preimage 	steps incremental 
blank eof 	rehashing 
postimage lno preimage 	returns still 
lno postimage 	keys move 
truncate label 	old hash 
path diff words 	table otherwise 
opt found 	returned note 
changesp header data 	rehashing 
size count 	step consists 
seen one one 	moving bucket 
rule ptr 	may one 
size cnt prev 	key use 
eol ecbdata 	chaining old 
rule reset first 	hash 
line len 	table however 
trailing newline trailing 	since part 
carriage nofirst 	hash table 
file reset line 	may composed 
len ecbdata 	empty spaces 
line len emit 	guaranteed 
line reset 	function rehash 
ecbdata line 	even single 
len reset ecbdata 	bucket since 
line len 	visit max 
reset ecbdata line 	empty buckets 
len ecbdata 	total 
line len context 	otherwise amount 
frag func 	work would 
reset atat msgbuf 	unbound function 
len file 	may block 
count ecb prefix 	time max 
data size 	number 
endp nneof reset 	empty buckets 
len context 	visit note 
name name one 	rehashidx overflow 
two textconv 	sure elements 
one textconv two 	used move 
name tab 	keys 
name tab metainfo 	bucket old 
fraginfo reset 	hash index 
name prefix 	hash table 
prefix data one 	check already 
data two 	rehashed whole 
size one size 	table 
two ecbdata 	rehash rehash 
line prefix text 	amount time 
alloc begin 	milliseconds milliseconds 
end orig orig 	function performs 
alloc line 	step rehashing 
len buffer prefix 	safe 
suffix color 	iterators bound 
old ctx newline 	hash table 
diff words 	iterators middle 
styles minus plus 	rehashing mess 
current plus 	two hash 
last minus opt 	tables 
word regex 	otherwise element 
style newline count 	missed duplicated 
buf line 	function called 
prefix print 	common lookup 
diff words priv 	update operations 
line len 	dictionary 
diff words style 	hash table 
minus first 	automatically migrates 
minus len plus 	actively used 
first plus 	element target 
len minus begin 	hash table 
minus end 	low 
plus begin plus 	level function 
end opt 	adds entry 
line prefix buffer 	instead setting 
word regex 	returns dict 
begin end match 	entry structure 
buffer word 	user 
regex alloc diff 	make sure 
words xpp 	fill field 
xecfg minus plus 	wishes function 
style opt 	also directly 
line prefix 	exposed user 
ecbdata one one 	api 
ecbdata orig 	called mainly 
opts one two 	order store 
ecbdata diff 	non pointers 
color opt msgbuf 	inside hash 
ecb line 	example entry 
len allot line 	dict 
ecbdata priv 	raw dict 
line len ecbdata 	mykey entry 
meta context 	dict integer 
reset line prefix 	val entry 
name tab 	values key 
name tab old 	already 
name pfx 	exists returned 
length sfx length 	key added 
pfx adjust 	hash entry 
slash len len 	returned manipulated 
midlen midlen 	caller index 
qlen qlen 	element 
alloc name name 	element already 
print name 	exists allocate 
added deleted diffstat 	memory store 
name name 	entry insert 
priv line len 	element top 
diffstat mime 	assumption 
boundary leader width 	database system 
max change 	likely recently 
file prefix name 	added entries 
len file 	accessed frequently 
cnt reset file 	hash entry 
pname buf 	fields 
files insertions deletions 	element discarding 
ret data 	old key 
options len del 	already exists 
dels max 	key added 
len count 	scratch already 
width name width 	element 
graph width 	key dict 
bin width reset 	replace performed 
del line 	update operation 
prefix extra shown 	element key 
file change 	exists dict 
prefix file name 	suceed 
added deleted 	already exists 
name len slash 	entry free 
total file 	old one 
added deleted data 	note important 
options total 	order may 
files added deleted 	exactly 
data options 	previous one 
file name changed 	context think 
files alloc 	reference counting 
permille cumulative opt 	want increment 
dir changed 	decrement free 
baselen dir 	reverse 
sources line prefix 	dict replace 
namelen slash 	raw simply 
newbaselen permille options 	version dict 
changed dir 	raw always 
name copied added 	returns hash 
damage content 	entry 
changed data options 	specified key 
changed dir 	even key 
file damage diffstat 	already exists 
filename lineno 	added entry 
conflict marker size 	already existing 
rule status 	key 
line marker size 	returned see 
len firstchar 	dict raw 
cnt priv line 	information search 
len data 	element table 
marker size reset 	unlink element 
err line 	list 
prefix bad 	found destroy 
plus data size 	entire dictionary 
result size 	free elements 
bound deflated stream 	free table 
file one 	allocated cache 
two prefix delta 	structure 
deflated data 	initialize table 
orig size delta 	never fails 
size deflate 	clear release 
size data size 	hash table 
free bytes 	table fingerprint 
line file one 	bit 
two prefix 	number represents 
one one options 	state dictionary 
one name 	given time 
name one two 	dict properties 
xfrm msg 	xored together 
must show header 	iterator 
complete rewrite 	initialized dict 
lbl one 	fingerprint check 
two meta reset 	fingerprint iterator 
prefix prefix 	released two 
textconv one textconv 	fingerprints different 
two header 	means 
line prefix del 	user iterator 
diffopts xpp 	performed forbidden 
xecfg ecbdata name 	operations dictionary 
name one 	iterating hash 
two diffstat data 	integers summing 
contents complete 	every 
rewrite xpp xecfg 	successive integer 
name name 	integer hashing 
attr path one 	previous sum 
two data 	basically result 
xpp xecfg ecbdata 	hash hash 
blank eof 	hash 
err path 	way integers 
spec spec spec 	different order 
sha sha 	likely hash 
valid mode name 	different number 
sha want 	hashing step 
file pos len 	use 
size buf 	tomas wang 
dirty flags size 	bit integer 
err buf 	hash hash 
size path temp 	hash hash 
blob size 	hash hash 
sha mode buf 	need 
path dup 	save next 
name one temp 	iterator user 
argv name 	may entry 
temp pgm name 	returning random 
one two 	entry hash 
xfrm msg complete 	table 
rewrite argv 	useful implement 
env msg 	randomized algorithms 
name one two 	sure elements 
must show 	indexes rehashidx 
header use color 	found non 
reset line 	empty 
prefix abbrev pgm 	bucket linked 
name attr 	list need 
path one two 	random element 
msg xfrm 	list sane 
msg complete rewrite 	way counting 
must show 	elements 
header drv one 	random index 
prefix length 	function samples 
namep otherp pgm 	dictionary keys 
msg one 	random locations 
two name attr 	guarantee keys 
path diffstat 	specified 
name name attr 	count guarantee 
path options 	non duplicated 
options count 	elements however 
arg arg arg 	make effort 
val len 	things returned 
end end opt 	pointers 
opt argv 	hash table 
optarg arg opt 	entries stored 
argv optarg 	des points 
arg options arg 	dict entry 
end width 	pointers must 
name width graph 	room 
width count 	least count 
argcount options errmsg 	elements argument 
options diff 	pass function 
status letters filter 	tell many 
bit status 	random elements 
opt optarg opt 	need 
optch bit 	function returns 
negate fmt arg 	number items 
token rest 	stored des 
opt arg 	may less 
orig arg val 	count hash 
options prefix 	table 
arg optarg argcount 	less count 
path offending 	elements inside 
path num scale 	enough elements 
dot opt 	found reasonable 
opt opt cmd 	amount steps 
diff queued 	note 
diff queue queue 	function suitable 
one two 	need good 
sha len abblen 	distribution returned 
abbrev hex 	items need 
opt line termination 	sample given 
inter name 	number 
termination name name 	continuous elements 
name name 	run kind 
two diffstat 	algorithm produce 
one msg opt 	statistics however 
fmt name 	function much 
name file newdelete 	faster 
file show 	dict random 
name line prefix 	key producing 
file renamecopy 	elements hash 
line prefix names 	table tables 
opt file 	rehashing work 
line prefix ctx 	proportional 
patchlen line 	count pick 
len dst priv 	random point 
line len 	inside larger 
data len options 	table continuous 
sha ctx 	empty entries 
data buffer xpp 	far 
xecfg len 	invariant dict 
len options sha 	rehashing indexes 
result rename 	already visited 
limit warning 	rehashing populated 
degrade warning rename 	buckets skip 
limit advice 	indexes 
varname needed degraded 	idx moreover 
options output 	currently range 
format separator dirstat 	second table 
line diffstat 	elements tables 
options options outq 	current rehashing 
found one 	index 
two diffopt outq 	jump possible 
name name 	happens going 
options options opt 	big small 
status result 	table range 
opt path options 	table count 
ignored orig 	contiguous 
flags options addremove 	empty buckets 
mode sha 	jump locations 
sha valid concatpath 	reach count 
dirty submodule 	minimum collect 
one two 	elements buckets 
options old mode 	found 
mode old 	non empty 
sha sha old 	iterating function 
sha valid 	reverse bits 
sha valid concatpath 	algorithm http 
old dirty 	graphics stanford 
submodule dirty submodule 	edu 
one two 	seander bithacks 
tmp tmp options 	html reverse 
path pair 	parallel bit 
one two pgm 	size must 
spec outsize 	power dict 
temp argv arg 	scan 
child buf 	used iterate 
err driver outbuf 	elements dictionary 
size opt 	iterating works 
strcasecmp strcasecmp strcasecmp 	following way 
strcasecmp strcasecmp 	initially call 
strcasecmp strcasecmp 	function 
strcasecmp strcasecmp xstrdup 	cursor function 
list split 	performs one 
place strcmp diff 	step iteration 
opt clr 	returns cursor 
diff opt clr 	must use 
strcmp diff 	next 
opt diff opt 	call returned 
clr strcmp 	cursor iteration 
diff opt clr 	complete function 
diff opt 	guarantees elements 
strcmp diff opt 	present dictionary 
clr strcmp 	returned 
diff opt isdigit 	start end 
strtoul isdigit 	iteration however 
isdigit strbuf addf 	possible elements 
strbuf addf 	returned multiple 
list clear free 	times 
strcmp diff 	every element 
opt strcmp 	returned callback 
diff opt clr 	argument called 
strcasecmp strcasecmp 	privdata first 
git config strcasecmp 	argument dictionary 
strcasecmp strcasecmp 	entry 
strcasecmp strcasecmp strcmp 	second argument 
strcmp git 	works iteration 
config colorbool strcmp 	algorithm designed 
git config 	pieter noordhuis 
strcmp git config 	main idea 
rename strcmp 	increment 
git config strcmp 	cursor starting 
git config 	higher order 
strcmp git config 	bits instead 
strcmp git 	incrementing cursor 
config strcmp git 	normally bits 
config strcmp 	cursor 
git config 	reversed cursor 
strcmp git config 	incremented bits 
pathname strcmp 	reversed strategy 
handle ignore submodules 	needed hash 
arg strcmp 	table may 
parse submodule warning 	resized 
strcmp parse 	iteration calls 
algorithm git color 	dict hash 
config git 	tables always 
diff basic config 	power two 
strcmp git 	size use 
config userdiff config 	chaining 
skip prefix 	position element 
skip prefix parse 	given table 
diff color 	given computing 
slot config error 	bitwise hash 
nonbool color 	key size 
parse strcmp strcmp 	size 
git config 	always mask 
strcmp parse 	equivalent taking 
dirstat warning strbuf 	rest division 
release starts 	hash key 
parse submodule config 	size example 
option git 	current 
config quote style 	hash table 
quote style 	size mask 
strbuf addch quote 	binary position 
style quote 	key hash 
style strbuf addch 	table always 
strbuf addstr 	last 
strbuf addstr strbuf 	four bits 
detach getenv 	hash output 
diff file valid 	forth happens 
diff populate 	table changes 
filespec diff file 	size hash 
valid diff 	table 
populate filespec blank 	grows elements 
line count 	anywhere one 
trailing blank 	multiple old 
count trailing blank 	bucket example 
count lines 	say already 
count lines fputs 	iterated 
diff line 	bit cursor 
prefix fputs fputc 	mask hash 
fwrite fputs 	table size 
fputc fputc emit 	hash table 
line blank 	resized elements 
line emit line 	mask 
emit line 	buckets obtain 
emit line diff 	substituting either 
color diff 	targeted keys 
color diff color 	already visited 
diff color 	scanning bucket 
memcmp memmem emit 	smaller 
line strbuf 	hash table 
addstr strbuf strbuf 	iterating higher 
addstr strbuf 	bits first 
addstr strbuf 	inverted counter 
strbuf addstr strbuf 	cursor need 
addstr strbuf 	restart 
strbuf addstr strbuf 	table size 
emit line 	gets bigger 
strbuf release size 	iterating cursors 
die size 	without end 
tempfile active tempfile 	also without 
diff color 	combination 
memchr emit del 	bits already 
line emit 	explored similarly 
line diff color 	table size 
putc emit 	shrinks time 
line strlen diff 	example going 
color diff 	combination 
color diff color 	lower three 
diff line 	bits mask 
prefix diff 	size already 
opt tst strchr 	completely explored 
strchr strbuf 	would visited 
reset strbuf reset 	sure 
quote two 	tried example 
style quote two 	variations higher 
style fill 	bit need 
textconv fill textconv 	test wait 
memset want 	two tables 
color whitespace rule 	rehashing 
check blank 	yes always 
eof count lines 	iterate smaller 
count lines 	table first 
print line count 	test expansions 
print line 	current cursor 
count emit rewrite 	larger 
lines emit 	table example 
rewrite lines free 	current cursor 
free alloc 	also larger 
grow memcpy 	table size 
memchr fputs fputs 	also test 
fputs fwrite 	inside 
fputs fputs fputs 	larger table 
parse hunk 	reduces problem 
header diff line 	back one 
prefix color 	table larger 
words output graph 	one exists 
prefix fputs 	expansion 
diff words write 	smaller one 
helper fputs 	limitations iterator 
diff words write 	completely stateless 
helper diff 	huge advantage 
words write helper 	including additional 
regexec memchr 	memory 
isspace isspace alloc 	used disadvantages 
grow find 	resulting design 
word boundaries alloc 	possible elements 
grow alloc 	however usually 
grow memcpy 	easy deal 
diff line prefix 	application 
fputs diff 	level iterator 
words write helper 	must multiple 
memset memset 	elements per 
diff words fill 	call needs 
diff words 	always keys 
fill xdi diff 	chained 
outf die 	given bucket 
free free color 	expansions sure 
words output 	miss keys 
graph prefix fputs 	moving rehashing 
diff words 	reverse cursor 
write helper diff 	somewhat 
words show 	hard understand 
isreg userdiff find 	first comment 
path userdiff 	supposed help 
find name diff 	emit entries 
filespec load 	cursor make 
driver xmalloc 	sure 
memcpy xcalloc userdiff 	smaller bigger 
word regex 	table emit 
userdiff word regex 	entries cursor 
xmalloc regcomp 	iterate indices 
die size want 	larger table 
color diff 	expansion 
color opt diff 	index pointed 
color opt 	cursor smaller 
diff color opt 	table emit 
diff words 	entries cursor 
flush free free 	increment bits 
free free 	covered 
free regfree free 	smaller mask 
free output 	bits covered 
prefix truncate utf 	mask difference 
width strchr 	non zero 
strtol strchr 	unmasked bits 
strtol diff color 	incrementing 
diff color 	reversed cursor 
diff color diff 	operates masked 
line prefix 	bits smaller 
strbuf reset strchr 	table increment 
strchr diff 	reverse cursor 
words flush sane 	functions 
truncate line 	expand hash 
find lno emit 	table needed 
hunk header 	incremental rehashing 
putc emit line 	already progress 
fputs diff 	hash table 
words append diff 	empty 
words append 	expand initial 
starts diff words 	size reached 
flush emit 	ratio allowed 
line fputs emit 	resize hash 
line emit 	table setting 
line emit 	avoid 
del line emit 	ratio elements 
context line 	buckets safe 
emit line diff 	threshold resize 
color strlen 	doubling number 
strlen quote style 	buckets hash 
quote style 	table 
quote style strbuf 	capability power 
addstr quote 	two returns 
style strbuf detach 	index free 
strbuf grow 	slot populated 
strbuf strbuf addch 	hash entry 
strbuf strbuf 	given 
addstr strbuf strbuf 	key key 
addch strbuf 	already exists 
strbuf detach xcalloc 	returned note 
alloc grow 	process rehashing 
xstrdup xstrdup xstrdup 	hash table 
putc quote 	index 
style strbuf 	always returned 
detach strbuf release 	context second 
pprint rename 	hash table 
strbuf addf strbuf 	expand hash 
addf strbuf 	table needed 
addf strbuf addch 	compute 
fputs strbuf 	key hash 
release diff line 	search slot 
prefix diff 	already contain 
color opt diff 	given key 
color opt 	debugging compute 
diff color opt 	stats 
fill print 	hash entry 
name strlen width 	slot generate 
width term 	human readable 
columns width width 	stats unlike 
strlen strchr 	snprintf teturn 
show name putc 	number 
show name 	characters actually 
scale linear 	written make 
scale linear scale 	sure term 
linear show 	end dict.c 
name show graph 	size key 
show graph 	type 
print stat summary 	priv data 
diff line 	ptr buf 
prefix print stat 	len hash 
summary diff 	type priv 
line prefix fill 	data ptr 
print name 	type 
write name quoted 	priv data 
fputs putc 	ptr size 
putc write name 	next key 
quoted write 	val index 
name quoted diff 	entry key 
line prefix 	val 
strlen memcmp strchr 	entry auxentry 
gather dirstat 	key prevde 
strcmp diff 	next key 
opt tst hashcmp 	iter iter 
diff opt 	iter size 
tst diff file 	key 
valid diff 	malloc dict 
file valid diff 	init dict 
populate filespec 	reset dict 
diff populate filespec 	next power 
diffcore count 	dict init 
changes diff free 	calloc 
filespec data 	dict hash 
diff free filespec 	key free 
data diff 	dict key 
file valid diff 	index malloc 
populate filespec 	dict hash 
diff free filespec 	key 
data diff 	dict hash 
file valid 	val dict 
diff populate filespec 	dict find 
diff free 	dict hash 
filespec data alloc 	val dict 
grow qsort 	free 
gather dirstat diff 	entry val 
opt tst 	dict hash 
alloc grow qsort 	key dict 
gather dirstat 	compare hash 
free free free 	keys dict 
free free 	free 
isspace diff color 	entry key 
diff color 	dict free 
diff color diff 	entry val 
line prefix 	free dict 
conflict marker check 	free entry 
whitespace error 	key 
free emit line 	dict free 
check emit 	entry val 
strchr strtol 	free free 
die git deflate 	dict reset 
init git 	dict clear 
deflate bound xmalloc 	free 
git deflate 	dict hash 
git deflate end 	key dict 
deflate diff 	compare hash 
delta deflate free 	keys malloc 
free free 	free dict 
encode fputs fputc 	expand 
free emit 	dict expand 
binary diff body 	dict expand 
emit binary 	needed dict 
diff body diff 	hash key 
filespec load 	dict compare 
driver diff file 	hash 
valid diff 	keys hash 
populate filespec buffer 	table implementation 
binary diff 	file memory 
filespec load 	hash tables 
driver diff file 	insert del 
valid diff 	replace 
filespec load driver 	find random 
userdiff textconv 	element operations 
diff color opt 	hash tables 
diff color 	resize needed 
opt diff line 	tables power 
prefix diff 	two 
opt tst isgitlink 	size used 
isgitlink diff 	collisions handled 
color opt diff 	chaining see 
color opt 	source code 
show submodule summary 	information copyright 
diff opt 	salvatore 
tst textconv textconv 	sanfilippo antirez 
diff mnemonic 	gmail dot 
prefix diff opt 	rights reserved 
tst diff 	redistribution use 
file valid 	source binary 
diff file valid 	forms 
quote two 	without modification 
quote two diff 	permitted provided 
file valid 	following conditions 
diff file valid 	met redistributions 
strbuf addf 	source code 
strbuf addf strbuf 	must 
addstr strbuf 	retain copyright 
addf strbuf addstr 	notice list 
strbuf addf 	conditions following 
strbuf addf strbuf 	disclaimer redistributions 
addstr diff 	binary form 
filespec binary diff 	must 
filespec binary 	reproduce copyright 
strbuf reset emit 	notice list 
rewrite diff 	conditions following 
strbuf reset 	disclaimer documentation 
diff opt tst 	materials provided 
diff filespec 	distribution 
binary diff filespec 	neither name 
binary isreg 	redis names 
isreg diff opt 	contributors may 
tst hashcmp 	used endorse 
fill mmfile fill 	promote products 
mmfile die 	derived 
memcmp strbuf reset 	software without 
diff opt 	specific prior 
tst emit binary 	written permission 
diff getenv 	software provided 
strbuf reset fill 	copyright holders 
textconv fill 	contributors 
textconv diff funcname 	express implied 
pattern diff 	warranties including 
funcname pattern memset 	limited implied 
memset memset 	warranties merchantability 
want color 	fitness particular 
whitespace rule check 	purpose 
blank eof 	disclaimed shall 
diff opt tst 	copyright owner 
xdiff find 	contributors liable 
func skip prefix 	direct indirect 
strtoul skip 	incidental special 
prefix strtoul init 	exemplary 
diff words 	consequential damages 
data xdi diff 	including limited 
outf die 	procurement substitute 
free diff words 	goods services 
data free 	loss use 
free xdiff clear 	data 
find func 	profits business 
strbuf release diff 	interruption however 
free filespec 	caused theory 
data diff free 	liability whether 
filespec data 	contract strict 
free free 	liability 
diff pair unmerged 	tort including 
diffstat hashcmp 	negligence otherwise 
diff filespec binary 	arising way 
diff filespec 	use software 
binary diff filespec 	even advised 
size diff 	possibility 
filespec size diff 	damage prototypes 
populate filespec 	hash functions 
diff populate filespec 	hash function 
count lines 	popular one 
count lines fill 	bernstein tested 
mmfile fill 	best 
mmfile die memset 	hash api 
memset xdi 	implementation reset 
diff outf die 	hashtable already 
diff free 	initialized init 
filespec data diff 	note function 
free filespec 	called 
data memset 	destroy create 
whitespace rule merge 	hash table 
marker size 	initialize hash 
fill mmfile fill 	table expand 
mmfile die 	create hashtable 
diff filespec binary 	hashtable 
memset memset 	size invalid 
xdi diff outf 	smaller number 
die check 	elements already 
blank eof whitespace 	inside hashtable 
error diff 	copy elements 
free filespec data 	old 
diff free 	table note 
filespec data diff 	old hash 
opt flexptr 	table empty 
alloc str diff 	size zero 
free filespec 	dict expand 
data free 	creates 
canon mode hashcpy 	hash table 
sha pack 	hash entry 
strlen cache name 	slot element 
pos hashcmp 	index pass 
isreg skip worktree 	next element 
uptodate lstat 	remap 
match stat strbuf 	hashtable old 
addf sha 	element target 
hex strbuf release 	hash table 
strbuf detach 	index element 
diff file valid 	element already 
die isdir 	exists 
isgitlink diff populate 	allocates memory 
gitlink reuse 	stores key 
worktree file lstat 	hash entry 
xsize islnk 	fields element 
strbuf readlink strbuf 	discarding old 
detach open 	key 
xmmap close 	already exists 
convert git munmap 	key added 
strbuf detach 	scratch already 
sha info die 	element key 
sha hex 	dict replace 
read sha file 	performed 
die sha 	update operation 
hex free munmap 	element key 
diff free 	exists dict 
filespec blob free 	suceed already 
xstrdup basename 	exists 
strbuf addstr strbuf 	entry free 
addstr mks 	old one 
tempfile strlen die 	free old 
errno convert 	one note 
working write full 	important order 
die errno 	may 
close tempfile tempfile 	exactly previous 
path sha 	one context 
hex xsnprintf 	think reference 
strbuf release strbuf 	counting want 
release free 	increment decrement 
claim diff tempfile 	free 
diff file 	reverse search 
valid xsnprintf xsnprintf 	element unlink 
isgitlink reuse 	element list 
worktree file lstat 	found destroy 
die errno 	entire hash 
islnk strbuf readlink 	table 
die errno 	free elements 
prep temp blob 	free table 
strbuf release 	allocated cache 
sha hex sha 	structure initialize 
hex xsnprintf 	table never 
diff populate filespec 	fails 
die prep 	clear release 
temp blob prepare 	hash table 
temp file 	need save 
argv push 	next iterator 
argv push argv 	user may 
push argv 	entry 
push argv push 	returning functions 
external diff 	expand hash 
name external diff 	table needed 
name external 	hash table 
diff name argv 	empty expand 
push argv 	intial 
push argv pushf 	size table 
argv pushf 	full dobule 
run command opt 	size hash 
env die 	table capability 
tempfile argv clear 	power two 
argv clear 	returns 
diff color diff 	index free 
color diff 	slot populated 
line prefix strbuf 	hash entry 
init strbuf 	given key 
addf similarity 	key already 
index strbuf addf 	exists 
quote style 	returned expand 
strbuf addf quote 	hashtable needed 
style strbuf 	compute key 
addf strbuf addf 	hash search 
similarity index 	slot already 
strbuf addf quote 	contain 
style strbuf 	given key 
addf quote style 	hash tables 
strbuf addf 	implementation file 
strbuf addf similarity 	memory hash 
index hashcmp 	tables insert 
diff opt tst 	del 
diff opt 	replace find 
tst fill mmfile 	random element 
diff filespec 	operations hash 
binary fill 	tables resize 
mmfile diff filespec 	needed tables 
binary strbuf 	power 
addf find unique 	two size 
abbrev strbuf 	used collisions 
addstr find unique 	handled chaining 
abbrev strbuf 	see source 
addf strbuf addf 	code information 
diff opt 	copyright 
tst userdiff find 	salvatore sanfilippo 
path fill 	antirez gmail 
metainfo want color 	dot rights 
run external 	reserved redistribution 
diff builtin diff 	use source 
diff file 	binary 
valid hashcpy lstat 	forms without 
die errno 	modification permitted 
index path die 	provided following 
hashclr external 	conditions met 
diff strcmp 	redistributions source 
strip prefix diff 	code 
opt tst 	must retain 
diff pair unmerged 	copyright notice 
run diff 	list conditions 
cmd diff fill 	following disclaimer 
sha info 	redistributions binary 
diff fill sha 	form 
info diff 	must reproduce 
file valid diff 	copyright notice 
file valid 	list conditions 
alloc filespec run 	following disclaimer 
diff cmd 	documentation materials 
free strbuf release 	provided 
alloc filespec 	distribution neither 
run diff cmd 	name redis 
free run 	names contributors 
diff cmd strbuf 	may used 
release diff 	endorse promote 
pair unmerged 	products 
builtin diffstat strcmp 	derived software 
strip prefix 	without specific 
diff fill sha 	prior written 
info diff 	permission software 
fill sha info 	provided copyright 
builtin diffstat 	holders 
diff pair unmerged 	contributors express 
strcmp strip 	implied warranties 
prefix diff fill 	including limited 
sha info 	implied warranties 
diff fill sha 	merchantability fitness 
info builtin 	particular 
checkdiff memcpy diff 	purpose disclaimed 
opt die 	shall copyright 
diff xdl tst 	owner contributors 
diff xdl 	liable direct 
tst diff xdl 	indirect incidental 
tst diff 	special 
opt diff 	exemplary consequential 
opt clr diff 	damages including 
opt tst 	limited procurement 
diff opt tst 	substitute goods 
strlen diff 	services loss 
opt diff opt 	use 
diff opt 	data profits 
read cache diff 	business interruption 
opt tst 	however caused 
diff opt diff 	theory liability 
opt tst 	whether contract 
die isdigit strtoul 	strict 
strchrnul strncmp 	liability tort 
isdigit strtoul die 	including negligence 
skip prefix 	otherwise arising 
skip prefix die 	way use 
skip prefix 	software even 
die skip 	advised 
prefix strtoul die 	possibility damage 
strtoul skip 	dict enable 
prefix strtoul die 	resize dict 
strtoul skip 	disable resize 
prefix strtoul die 	make possible 
strtoul skip 	enable 
prefix strtoul die 	disable resizing 
strtoul strtoul 	hash table 
strtoul strtoul parse 	needed important 
dirstat die 	redis use 
strbuf release parse 	copy write 
submodule die 	want 
prepare filter bits 	move much 
size toupper 	memory around 
skip prefix parse 	child performing 
one token 	saving operations 
parse one token 	note even 
parse one 	dict 
token parse 	resize resizes 
one token parse 	prevented hash 
one token 	table still 
parse one token 	allowed grow 
error strcmp 	ratio number 
strcmp strcmp opt 	elements 
arg enable 	buckets dict 
patch output strcmp 	force resize 
strcmp enable 	ratio prototypes 
patch output strcmp 	hash functions 
strcmp strcmp 	thomas wang 
strcmp parse dirstat 	bit 
opt skip 	mix function 
prefix parse dirstat 	murmur hash 
opt skip 	austin appleby 
prefix parse dirstat 	note code 
opt strcmp 	makes assumptions 
parse dirstat opt 	machine 
strcmp parse 	behaves read 
dirstat opt 	address without 
skip prefix parse 	crashing limitations 
dirstat opt 	work incrementally 
parse dirstat opt 	produce results 
strcmp strcmp 	little 
strcmp enable patch 	endian big 
output strcmp 	endian machines 
strcmp strcmp strcmp 	mixing constants 
starts stat 	generated offline 
opt starts starts 	really magic 
strcmp diff 	happen 
scoreopt parse error 	work well 
starts starts 	initialize hash 
strcmp diff scoreopt 	random mix 
parse error 	bytes time 
strcmp strcmp starts 	hash handle 
starts strcmp 	last 
diff opt diff 	bytes input 
scoreopt parse 	mixes hash 
error strcmp 	ensure last 
strcmp diff opt 	bytes well 
strcmp diff 	incorporated insensitive 
opt clr strcmp 	hash 
diff opt 	function djb 
skip prefix diff 	hash hash 
opt strcmp 	api implementation 
diff xdl strcmp 	reset hash 
diff xdl 	table already 
clr strcmp strcmp 	initialized 
diff xdl 	init note 
strcmp strcmp diff 	function called 
xdl strcmp 	destroy create 
diff xdl strcmp 	hash table 
diff xdl 	initialize hash 
strcmp diff alg 	table 
strcmp diff 	resize table 
alg parse 	minimal size 
opt parse algorithm 	contains elements 
error diff 	invariant used 
xdl clr strcmp 	buckets ratio 
enable patch 	near 
output diff opt 	expand create 
strcmp diff 	hash table 
opt strcmp strcmp 	hash table 
diff opt 	size invalid 
strcmp diff opt 	smaller number 
strcmp diff 	elements 
opt strcmp diff 	already inside 
opt strcmp 	hash table 
diff opt clr 	rehashing table 
diff opt 	size useful 
clr strcmp skip 	allocate hash 
prefix git 	table 
config colorbool error 	initialize pointers 
strcmp strcmp 	first initialization 
skip prefix 	really rehashing 
strcmp skip prefix 	first hash 
strcmp strcmp 	table accept 
strcmp strcmp die 	keys 
parse opt 	prepare second 
strcmp diff opt 	hash table 
strcmp diff 	incremental rehashing 
opt strcmp diff 	performs steps 
opt strcmp 	incremental rehashing 
diff opt clr 	returns 
strcmp diff 	still keys 
opt strcmp diff 	move old 
opt clr 	hash table 
strcmp diff opt 	otherwise returned 
handle ignore 	note rehashing 
submodules arg skip 	step 
prefix diff 	consists moving 
opt handle ignore 	bucket may 
submodules arg 	one key 
strcmp diff 	use chaining 
opt skip prefix 	old hash 
parse submodule 	table 
opt skip prefix 	however since 
parse error 	part hash 
highlight strcmp opt 	table may 
strtoul opt 	composed empty 
opt strcmp strcmp 	spaces guaranteed 
opt prefix 	function 
filename strlen xstrdup 	rehash even 
parse opt 	single bucket 
parse diff filter 	since visit 
opt die 	max empty 
strcmp skip prefix 	buckets total 
strtoul parse 	otherwise 
opt parse opt 	amount work 
strcmp opt 	would unbound 
arg strcmp diff 	function may 
opt strcmp 	block time 
diff opt 	max number 
strcmp diff opt 	empty 
clr parse 	buckets visit 
opt prefix filename 	note rehashidx 
strlen fopen 	overflow sure 
die errno skip 	elements used 
prefix skip 	move keys 
prefix skip prefix 	bucket 
parse rename 	old hash 
score parse rename 	index hash 
score alloc 	table check 
grow xcalloc diff 	already rehashed 
free filespec 	whole table 
free filespec free 	rehash 
sha hex 	rehash amount 
find unique abbrev 	time milliseconds 
strlen xsnprintf 	milliseconds function 
xsnprintf sha hex 	performs step 
diff line 	rehashing safe 
prefix diff 	iterators 
unique abbrev diff 	bound hash 
unique abbrev 	table iterators 
similarity index strip 	middle rehashing 
prefix write 	mess two 
name quoted write 	hash tables 
name quoted 	otherwise 
strip prefix write 	element missed 
name quoted 	duplicated function 
diff pair unmerged 	called common 
diff file 	lookup update 
valid diff file 	operations dictionary 
valid diff 	hash 
pair mode changed 	table automatically 
strcmp hashcmp 	migrates actively 
diff unmodified pair 	used element 
diff file 	target hash 
valid isdir 	table low 
diff file valid 	level 
isdir run 	function adds 
diff diff unmodified 	entry instead 
pair diff 	setting returns 
file valid isdir 	dict entry 
diff file 	structure user 
valid isdir run 	make 
diffstat diff 	sure fill 
unmodified pair diff 	field wishes 
file valid 	function also 
isdir diff file 	directly exposed 
valid isdir 	user api 
run checkdiff diff 	called 
unmodified pair 	mainly order 
diff file valid 	store non 
sha hex 	pointers inside 
diff debug filespec 	hash example 
diff debug 	entry dict 
filespec diff 	raw 
debug filepair diff 	dict mykey 
debug queue 	entry dict 
diff pair unmerged 	integer val 
diff file 	entry values 
valid diff file 	key already 
valid diff 	exists 
pair type changed 	returned key 
diff pair 	added hash 
rename strcmp hashcmp 	entry returned 
sha error 	manipulated caller 
diff debug queue 	index element 
die diff 	element 
flush checkdiff diff 	already exists 
flush raw 	allocate memory 
strip prefix write 	store entry 
name quoted 	insert element 
write name quoted 	top assumption 
write name 	database 
quoted pprint 	system likely 
rename similarity index 	recently added 
free show 	entries accessed 
mode change diff 	frequently hash 
line prefix 	entry fields 
fputs show file 	element 
mode name 	discarding old 
fputs show file 	key already 
mode name 	exists key 
fputs show rename 	added scratch 
copy fputs 	already element 
show rename copy 	key 
write name 	dict replace 
quoted similarity index 	performed update 
show mode 	operation element 
change isspace starts 	key exists 
space git 	dict suceed 
sha update git 	already 
sha init 	exists entry 
memset memset 	free old 
memset error diff 	one note 
unmodified pair 	important order 
diff file valid 	may exactly 
isdir diff 	previous 
file valid isdir 	one context 
diff pair 	think reference 
unmerged diff fill 	counting want 
sha info 	increment decrement 
diff fill sha 	free reverse 
info fill 	dict 
mmfile fill mmfile 	replace raw 
error space 	simply version 
strlen space strlen 	dict raw 
snprintf snprintf 	always returns 
snprintf git sha 	hash entry 
update diff 	specified 
filespec binary 	key even 
diff filespec binary 	key already 
git sha 	exists added 
update sha hex 	entry already 
git sha 	existing key 
update sha hex 	returned 
xdi diff 	see dict 
outf error git 	raw information 
sha diff 	search element 
patch diff free 	table unlink 
filepair free 	element list 
diff queue clear 	found 
warning warning 	destroy entire 
warning check pair 	dictionary free 
status flush 	elements free 
one pair diff 	table allocated 
opt tst 	cache structure 
memset check pair 	initialize 
status diff 	table never 
flush stat 	fails clear 
show numstat show 	release hash 
stats show 	table table 
shortstats show dirstat 	fingerprint bit 
line free 	number 
diffstat info show 	represents state 
dirstat summary 	dictionary given 
empty diff summary 	time dict 
diff opt 	properties xored 
tst diff opt 	together iterator 
tst fclose 	initialized 
fopen die errno 	dict fingerprint 
check pair 	check fingerprint 
status diff flush 	iterator released 
patch diff 	two fingerprints 
line prefix fputs 	different means 
check pair 	user 
status diff flush 	iterator performed 
patch format 	forbidden operations 
callback diff 	dictionary iterating 
free filepair free 	hash integers 
diff queue 	summing every 
clear fclose diff 	successive 
opt tst 	integer integer 
diff opt diff 	hashing previous 
opt clr 	sum basically 
filter bit tst 	result hash 
filter bit 	hash hash 
tst filter bit 	way 
tst diff 	integers different 
queue clear filter 	order likely 
bit tst 	hash different 
match filter diff 	number hashing 
free filepair 	step use 
match filter diff 	tomas 
diff free 	wang bit 
filepair free isgitlink 	integer hash 
diff populate 	hash hash 
filespec diff 	hash hash 
populate filespec memcmp 	hash 
diff file 	need save 
valid diff file 	next iterator 
valid diff 	user may 
populate filespec diff 	entry returning 
populate filespec 	random entry 
diff filespec identical 	hash 
diff queue 	table useful 
clear diff filespec 	implement randomized 
check stat 	algorithms sure 
unmatch diff diff 	elements indexes 
opt tst 	rehashidx found 
diff free filepair 	non 
free strcmp 	empty bucket 
qsort diffcore skip 	linked list 
stat unmatch 	need random 
diffcore diffcore rename 	element list 
diffcore merge 	sane way 
broken diffcore 	counting 
pickaxe diffcore order 	elements random 
diff resolve 	index function 
rename copy diffcore 	samples dictionary 
apply filter 	keys random 
diff opt tst 	locations guarantee 
diff opt 	keys 
diff opt clr 	specified count 
diff warn 	guarantee non 
rename limit diff 	duplicated elements 
opt tst 	however make 
diff opt tst 	effort things 
diff opt 	returned 
tst diff opt 	pointers hash 
tst diff 	table entries 
opt tst diff 	stored des 
opt tst 	points dict 
diff opt 	entry pointers 
tst diffopt flags 	must 
submodule config 	room least 
diff opt tst 	count elements 
isgitlink submodule 	argument pass 
ignored diff opt 	function tell 
tst strncmp 	many random 
alloc filespec alloc 	elements 
filespec fill 	need function 
filespec fill filespec 	returns number 
diff queue 	items stored 
diff opt tst 	des may 
diff opt 	less count 
isgitlink isgitlink submodule 	hash 
ignored diff 	table less 
opt tst strncmp 	count elements 
alloc filespec 	inside enough 
alloc filespec fill 	elements found 
filespec fill 	reasonable amount 
filespec diff 	steps 
queue diff opt 	note function 
tst diff 	suitable need 
opt tst diff 	good distribution 
filespec check 	returned items 
stat unmatch diff 	need sample 
opt strncmp 	given 
alloc filespec alloc 	number continuous 
filespec diff 	elements run 
queue prepare temp 	kind algorithm 
file start 	produce statistics 
command tempfile strbuf 	however function 
read error 	much 
close finish command 	faster dict 
strbuf release 	random key 
tempfile tempfile strbuf 	producing elements 
detach diff 	hash table 
file valid diff 	tables rehashing 
populate filespec 	work 
die die 	proportional count 
notes cache run 	pick random 
textconv die 	point inside 
notes cache put 	larger table 
notes cache 	continuous empty 
write diff opt 	entries 
tst check 	far invariant 
pager config setup 	dict rehashing 
pager copyright 	indexes already 
junio hamano context 	visited rehashing 
metainfo fraginfo 	populated buckets 
old commit whitespace 	skip 
funcinfo use 	indexes idx 
first digit ignore 	moreover currently 
digits nothing 	range second 
give layer defaults 	table elements 
core level 	tables current 
commands git diff 	rehashing 
files never 	index jump 
affected setting 	possible happens 
diff renames user 	going big 
happens configuration 	small table 
file like gnu 	range table 
diff suppress 	count 
blank empty option 	contiguous empty 
backwards compatibility 	buckets jump 
keep track files 	locations reach 
used diffing 	count minimum 
sometimes entry refers 	collect elements 
temporary file 	buckets 
sometimes existing file 	found non 
sometimes dev 	empty iterating 
filename external diff 	function reverse 
read entry 	bits algorithm 
currently use diff 	http graphics 
tempfile instance 	stanford 
refers temporary 	edu seander 
file tempfile used 	bithacks html 
manage lifetime 	reverse parallel 
trailing newline matter 	bit size 
like fill 	must power 
mmfile size avoid 	dict 
retrieving blob 	scan used 
pointing end incomplete 	iterate elements 
line skip 	dictionary iterating 
last blank line 	works following 
eof paint 	way initially 
well emit prefix 	call 
rest hunk 	function cursor 
header must begin 	function performs 
old always 	one step 
least bytes skip 	iteration returns 
hunk header 	cursor must 
fraginfo color trailing 	use 
blank func 	next call 
header filled 	returned cursor 
setup code color 	iteration complete 
enabled color 	function guarantees 
words algorithm described 	elements present 
collect minus 	dictionary 
plus lines diff 	returned start 
hunk divided 	end iteration 
minus lines plus 	however possible 
lines minus 	elements returned 
lines plus lines 	multiple times 
words place 	every 
two mmfile one 	element returned 
word line 	callback argument 
use xdiff run 	called privdata 
diff two 	first argument 
mmfile words level 	dictionary entry 
diff common 	second 
parts file output 	argument works 
plus side 	iteration algorithm 
text diff 	designed pieter 
words current plus 	noordhuis main 
used trace 	idea increment 
current position plus 	cursor 
file printed 	starting higher 
diff words last 	order bits 
minus used 	instead incrementing 
trace last minus 	cursor normally 
word printed 	bits cursor 
graph work color 	reversed 
words need 	cursor incremented 
output graph prefix 	bits reversed 
line color 	strategy needed 
words output generally 	hash table 
two conditions 	may resized 
output prefix diff 	iteration 
words last 	calls dict 
minus diff words 	hash tables 
current plus 	always power 
diff words 	two size 
plus text ptr 	use chaining 
plus text 	position 
must start line 	element given 
minus word 	table given 
printed graph prefix 	computing bitwise 
must printed 	hash key 
diff words current 	size size 
plus diff 	always 
words plus text 	mask equivalent 
ptr diff 	taking rest 
words current plus 	division hash 
graph prefix 	key size 
must printed following 	example current 
posix requires 	hash 
first decremented one 	table size 
len function 	mask binary 
starts looking 	position key 
begin returns iff 	hash table 
word found 	always last 
find next word 	four 
find end 	bits hash 
word function splits 	output forth 
words buffer 	happens table 
text stores list 	changes size 
newline separator 	hash table 
saves offsets original 	grows 
words buffer 	elements anywhere 
orig fake empty 	one multiple 
word store 	old bucket 
original boundaries store 	example say 
one word 	already iterated 
executes word diff 	bit 
accumulated buffers 	cursor mask 
special removal hunk 	hash table 
header parsed 	size hash 
need context 	table resized 
color words mode 	elements mask 
show word 	buckets 
diff words accumulated 	obtain substituting 
buffer use 	either targeted 
already loaded driver 	keys already 
fallback settings 	visited scanning 
truncated middle cannot 	bucket smaller 
happen cannot 	hash 
happen eat newline 	table iterating 
eof marker 	higher bits 
saw line nothing 	first inverted 
without diff 	counter cursor 
words flush defer 	need restart 
processing end 	table 
preimage lines may 	size gets 
come skip 	bigger iterating 
prefix character diff 	cursors without 
suppress blank 	end also 
empty may 	without combination 
none incomplete line 	bits 
end find 	already explored 
common prefix find 	similarly table 
common suffix 	size shrinks 
common prefix must 	time example 
end slash 	going combination 
loop run prefix 	lower 
see slash 	three bits 
common prefix cannot 	mask size 
would underrun 	already completely 
input pfx mid 	explored would 
mid sfx 	visited sure 
pfx pfx sfx 	tried 
pfx sfx 	example variations 
sfx name name 	higher bit 
make sure 	need test 
least one printed 	wait two 
change path 	tables rehashing 
easiest way 	yes 
scale linearly alloted 	always iterate 
width one 	smaller table 
column shorter result 	first test 
binary diff 	expansions current 
caller may want 	cursor larger 
print files 	table 
changed insertions deletions 	example current 
omitting insertions 	cursor also 
deletions probably less 	larger table 
confusing skip 	size also 
files changed nothing 	test inside 
added removed 	larger 
lines bug git 	table reduces 
find longest 	problem back 
filename max number 	one table 
changes shown 	larger one 
room one unmerged 	exists expansion 
characters bin 	smaller 
xxx yyy 	one limitations 
bytes display change 	iterator completely 
counts aligned 	stateless huge 
bin stop scanning 	advantage including 
data files 	additional memory 
width stat width 	used 
term columns 	disadvantages resulting 
columns total want 	design possible 
maximum min 	elements however 
max len stat 	usually easy 
name width 	deal application 
name part want 	level 
maximum min 	iterator must 
max change stat 	multiple elements 
graph width 	per call 
part also need 	needs always 
width max 	keys chained 
change nnnn 	given 
one empty column 	bucket expansions 
end altogether 	sure miss 
width max change 	keys moving 
enough space 	rehashing reverse 
use smaller stat 	cursor somewhat 
name width 	hard 
width filename rest 	understand first 
constant elements 	comment supposed 
graph part stat 	help emit 
graph width 	entries cursor 
graph part gives 	make sure 
filename constant 	smaller 
parts graph standard 	bigger table 
terminal size 	emit entries 
words stat width 	cursor iterate 
limits maximum 	indices larger 
width stat name 	table expansion 
width fixes 	index 
maximum width 	pointed cursor 
filename also used 	smaller table 
divide available 	emit entries 
columns aren enough 	cursor increment 
binary files 	bits covered 
displayed bin xxx 	smaller 
yyy bytes 	mask bits 
instead change count 	covered mask 
graph part 	difference non 
treated similarly graph 	zero unmasked 
part scaled 	bits incrementing 
total width small 	reversed 
accommodate guaranteed 	cursor operates 
minimum width filename 	masked bits 
part separators 	smaller table 
message message overflow 	increment reverse 
making line 	cursor functions 
longer maximum width 	expand 
guarantee graph 	hash table 
part filename 	needed incremental 
part first assign 	rehashing already 
sizes wanted 	progress hash 
ignoring available width 	table empty 
strlen bin 	expand 
xxx yyy bytes 	initial size 
bin width 	reached ratio 
part starting xxx 	allowed resize 
fit graph 	hash table 
width adjust adjustable 	setting avoid 
widths exceed 	ratio 
maximum width name 	elements buckets 
width width 	safe threshold 
name area graph 	resize doubling 
width width 	number buckets 
graph area max 	hash table 
change used 	capability 
scale graph properly 	power two 
scale filename 	returns index 
scale width 	free slot 
due sanity check 	populated hash 
count bytes 	entry given 
report dirstat top 	key 
level cases 	key already 
everything came single 	exists returned 
directory directory 	note process 
sources sha changed 	rehashing hash 
pre post 	table index 
content identical therefore 	always 
skip looking 	returned context 
file contents altogether 	second hash 
dirstat file 	table expand 
mode really need 	hash table 
look actual 	needed compute 
file contents fact 	key 
sha changed 	hash search 
enough file 	slot already 
list results file 	contain given 
contributing equal 	key debugging 
damage original minus 	compute stats 
copied removed 	hash 
material added material 	entry slot 
damages made 	generate human 
preimage resulting damage 	readable stats 
zero know 	unlike snprintf 
diffcore count changes 	teturn number 
considers two 	characters 
entries identical since 	actually written 
content changed 	make sure 
know must kind 	term end 
change force 	dict resize 
entries damage happen 	dict force 
even many 	resize 
files everything renames 	ratio size 
show directories 	key type 
changes binary 	priv data 
files counts bytes 	ptr key 
lines must 	dict hash 
find way normalize 	function 
binary bytes 	seed seed 
textual lines following 	key len 
heuristic assumes 	seed data 
bytes per line 	buf len 
stupid ugly 	hash type 
cheap happen even 	priv 
many files 	data ptr 
everything renames show 	type priv 
directories changes 	data ptr 
line thru line 	minimal size 
marker size 	realsize empty 
firstchar nothing could 	visits 
deflated delta 	nextde start 
could deflated two 	rehashes key 
whichever smaller 	val entry 
emit data 	key index 
encoded never use 	entry key 
non valid 	val 
filename anywhere possible 	entry auxentry 
dev run 	key entry 
diff different kind 	key nofree 
objects quite 	idx prev 
common confusing crazy 	table key 
xdl interfaces 	key 
crazy xdl interfaces 	callback next 
codepaths check 	key idx 
sides checking old 	table key 
side deliberate 	integers hash 
checking newly introduced 	iter iter 
changes side 	iter 
text check introduces 	orighe listlen 
crazy xdl 	listele des 
interfaces least one 	count tables 
context line 	maxsizemask maxsteps 
report errors 	emptylen mask 
given name sha 	privdata 
pair index 	size key 
tells file work 	idx table 
contents prepare 	callback buf 
temp file inflate 	bufsize tableid 
extract read 	chainlen maxchainlen 
cache benchmark previous 	totchainlen 
version always 	clvector buf 
reads cache shows 	bufsize orig 
makes things 	buf orig 
worse diff comparing 	bufsize tolower 
two linux 	zmalloc dict 
kernel trees already 	init 
work diff 	dict reset 
comparisons deal small 	dict reset 
number files 	dict rehashing 
reading cache 	dict expand 
expensive large project 	dict next 
cost outweighs 	power 
savings inflating temporary 	dict rehashing 
file practically 	zcalloc dict 
code helps used 	rehashing dict 
diff cache 	hash key 
cached read cache 	zfree 
calling want 	dict reset 
avoid working directory 	gettimeofday time 
caller doesn 	milliseconds dict 
need data normal 	rehash time 
file system 	milliseconds dict 
rather slow stat 	rehash 
open mmap 	dict raw 
close syscalls contained 	dict val 
pack file 	dict rehashing 
pack probably already 	dict rehash 
open faster 	step dict 
obtain data 	key 
working directory loose 	index dict 
objects however 	rehashing zmalloc 
would tend slower 	dict key 
need individually 	dict dict 
opened inflated sha 	find dict 
looking unreusable 	val 
regular file marked 	dict free 
unchanged guarantee 	val dict 
work matches looking 	find dict 
matches file 	raw dict 
work reuse looking 	rehashing dict 
work rename 	rehash 
detection pickaxe operation 	step dict 
may need 	hash key 
grab data blob 	dict compare 
file core 	keys dict 
comparison diff filespec 	free key 
data size 	dict 
fields purpose 	free val 
demote fail warn 	zfree dict 
allow inspecting 	rehashing dict 
situation instead refusing 	dict callback 
convert working 	dict free 
format canonical git 	key 
format generate 	dict free 
xxxxxx basename ext 	val zfree 
entry produces 	zfree dict 
file entry produces 	reset dict 
file borrow 	clear dict 
file work even 	clear 
though may 	zfree dict 
sometimes borrow contents 	rehashing dict 
work always 	rehash step 
want one mode 	dict hash 
mode trustworthy 	key dict 
even one sha 	compare 
valid diff 	keys dict 
file valid 	rehashing dict 
one external diff 	find dict 
command takes 	val zmalloc 
diff cmd name 	dict iterator 
infile infile 	dict 
sha infile mode 	fingerprint dict 
infile infile 	rehashing dict 
sha infile mode 	fingerprint zfree 
rename fallthru 	dict size 
use colors header 	dict rehashing 
intended external 	dict 
diff driver strip 	rehash step 
prefix molest 	dict rehashing 
dev absolute paths 	random random 
filepair changes 	random dict 
file symlink needs 	size dict 
split deletion 	size 
creation unmerged unmerged 	dict rehashing 
pathchange left 	dict rehash 
time say 	step dict 
changes checking changed 	rehashing random 
paths ignore 	random dict 
whitespace options force 	size 
look inside 	dict rehashing 
contents cases always 	rev rev 
need recursive 	dict rehashing 
drop caller supplied 	dict expand 
recursive bits 	dict expand 
formats also pickaxe 	dict 
would work 	expand needed 
well say recursive 	dict hash 
patches generated 	key dict 
submodules diffed work 	compare keys 
must dirtiness 	dict rehashing 
shown output read 	dict 
cache die 	clear dict 
even fails 	clear snprintf 
safe also smudge 	snprintf snprintf 
active cache 	strlen dict 
active fails worry 	stats dict 
cleaning either 	rehashing 
full make sense 	dict stats 
show first 	hash table 
hit happened found 	implementation file 
make sense 	memory hash 
exit code either 	tables insert 
stuck form 	del 
option separate form 	replace find 
option important 	random element 
checks error cases 	operations hash 
caller knows 	tables resize 
dirstat related option 	needed tables 
given command 	power 
line allow say 	two size 
function negation 	used collisions 
input haven 	handled chaining 
initialized filter field 	see source 
another diff 	code information 
filter start full 	copyright 
bits aon 	salvatore sanfilippo 
output format options 	antirez gmail 
stat stat 	dot rights 
width stat name 	reserved redistribution 
width stat 	use source 
count renames options 	binary 
xdiff options 	forms without 
clear previous settings 	modification permitted 
flags options 	provided following 
misc options always 	conditions met 
end user 	redistributions source 
says num divided 	code 
scale say 	must retain 
internally max score 	copyright notice 
num scale 	list conditions 
convert form 	following disclaimer 
arguments form versions 	redistributions binary 
option expect 	form 
different find unique 	must reproduce 
abbrev stuffs 	copyright notice 
result dots alignment 	list conditions 
function written 	following disclaimer 
stricter necessary support 	documentation materials 
currently implemented 	provided 
transformers idea transformers 	distribution neither 
produce diff 	name redis 
filepairs way want 	names contributors 
filter clean 	may used 
producing output unmerged 	endorse promote 
interesting deletion 	products 
addition mode type 	derived software 
change rename 	without specific 
interesting valid point 	prior written 
path dealing 	permission software 
change change 	provided copyright 
look file filesystem 	holders 
diffs patch 	contributors express 
format useful stat 	implied warranties 
diffs nothing 	including limited 
check diffs undecided 	implied warranties 
point dealing 	merchantability fitness 
pair whose sides 	particular 
valid type 	purpose disclaimed 
either place edit 	shall copyright 
rename copy 	owner contributors 
edit rename might 	liable direct 
connected broken 	indirect incidental 
pair causing pathnames 	special 
rename modification 	exemplary consequential 
otherwise see source 	damages including 
used multiple 	limited procurement 
renames decrement 	substitute goods 
count call copy 	services loss 
change entry 	use 
happen anymore prepare 	data profits 
broken callers 	business interruption 
ignore line numbers 	however caused 
computing sha 	theory liability 
patch returns upon 	whether contract 
success writes 	strict 
result sha order 	liability tort 
raw stat 	including negligence 
summary patch name 	otherwise arising 
name status 	way use 
checkdiff bits clear 	software even 
run diff 	advised 
flush patch exit 	possibility damage 
status setting 	prototypes hash 
options file dev 	functions hash 
safe aren 	function popular 
supposed produce 	one bernstein 
output anyway attach 	tested 
patch instead 	best hash 
report content level 	api implementation 
differences changes 	reset hashtable 
diff addremove diff 	already initialized 
change bit 	init note 
diff contents effect 	function 
otherwise clear 	called destroy 
whole queue copying 	create hash 
empty outq 	table initialize 
end function first 	hash table 
clear current 	expand create 
entries queue matching 	hashtable 
ones check 	hashtable size 
whether two filespecs 	invalid smaller 
mode size 	number elements 
identical entries come 	already inside 
stat info 	hashtable copy 
dirtiness always 	elements 
sides iow create 	old table 
one side 	note old 
name unknown mode 	hash table 
size keep 	empty size 
ones match criteria 	zero dict 
real differences 	expand 
point file known 	creates hash 
modified mode 	table hash 
size name one 	entry slot 
side unknown 	element index 
need inspect identical 	pass next 
contents caller 	element 
subtract skip stat 	remap hashtable 
unmatch determine 	old element 
many paths dirty 	target hash 
due stat 	table index 
info mismatch note 	element element 
please keep 	already 
following sync 	exists allocates 
diff combined see 	memory stores 
follow renames 	key hash 
diff see follow 	entry fields 
renames diff 	element discarding 
shall changes submodule 	old 
ignored submodule 	key already 
changes configured ignored 	exists key 
separately path 	added scratch 
configuration overridden command 	already element 
line may 	key dict 
look odd preparation 	replace 
feeding unchanged 	performed update 
files produce diffs 	operation element 
copy detection 	key exists 
would need entries 	dict suceed 
diff core 	already exists 
prefixed something 	entry 
like haven decided 	free old 
make difference 	one free 
feeding old diff 	old one 
change also 	note important 
effect output happens 	order may 
pruned merged 	exactly 
rename copy pairs 	previous one 
appropriate ignore 	context think 
errors might repository 	reference counting 
could save 	want increment 
changes flush end 	decrement free 
would need 	reverse 
extra call diffing 	search element 
done since 	unlink element 
generating cache entry 	list found 
slow path 	destroy entire 
anyway extra overhead 	hash table 
probably isn 	free 
big deal 	elements free 
user asked exit 	table allocated 
code either 	cache structure 
want quiet exit 	initialize table 
code definitely 	never fails 
bother pager former 	clear 
generate output 	release hash 
since still properly 	table need 
report exit 	save next 
code even pager 	iterator user 
run could 	may entry 
run pager exit 	returning 
code since 	functions expand 
done historically easy 	hash table 
find people 	needed hash 
oneline advising git 	table empty 
diff exit 	expand intial 
code hooks scripts 	size 
builtin git 	table full 
diff copyright 	dobule size 
junio hamano blob 	hash table 
file working 	capability power 
make sure one 	two returns 
revision pending 	index 
revision filtering parameters 	free slot 
saw two 	populated hash 
trees ent ent 	entry given 
ent uninteresting 	key key 
swap diff combine 	already exists 
merges asked 	returned 
diff densify user 	expand hashtable 
wants dense 	needed compute 
one explicitly asked 	key hash 
rely could 	search slot 
ish rev pending 	already contain 
objects list 	given 
also could blobs 	key hash 
pathspecs cache 	tables implementation 
files diff 	file memory 
files compare two 	hash tables 
random blobs 	insert del 
must zero compare 	replace 
blob working 	find random 
file cache diff 	element operations 
index cached 	hash tables 
diff compare two 	resize needed 
filesystem entities 	tables power 
aka index cases 	two 
errors asked 	size used 
index explicitly treat 	collisions handled 
git diff 	chaining see 
least one path 	source code 
outside repo 	information copyright 
command would executed 	salvatore 
outside git 	sanfilippo antirez 
repository behaves way 	gmail dot 
git diff 	rights reserved 
index acts 	redistribution use 
colourful diff replacement 	source binary 
index two 	forms 
paths possible user 	without modification 
intended inside 	permitted provided 
repository operation give 	following conditions 
usage message 	met redistributions 
non repository usage 	source code 
exit index 	must 
diff run exit 	retain copyright 
otherwise usual 	notice list 
git diff scale 	conditions following 
real terminal 	disclaimer redistributions 
size respect stat 	binary form 
graph width 	must 
config external textconv 	reproduce copyright 
used cached 	notice list 
pending head 	conditions following 
hand eek arguments 	disclaimer documentation 
look reasonable 	materials provided 
diff least one 	distribution 
merge ent 	neither name 
objects merge ent 	redis names 
objects ents 	contributors may 
ent objects ents 	used endorse 
show diff 	promote products 
note pick one 	derived 
merge random 	software without 
one sha name 	specific prior 
mode builtin 	written permission 
diff usage opt 	software provided 
old mode 	copyright holders 
mode old sha 	contributors 
sha old 	express implied 
sha valid sha 	warranties including 
valid old 	limited implied 
name name 	warranties merchantability 
one two tmp 	fitness particular 
tmp tmp 	purpose 
revs argc argv 	disclaimed shall 
blob path 	copyright owner 
revs argc argv 	contributors liable 
blob mode 	direct indirect 
revs argc argv 	incidental special 
cached arg 	exemplary 
revs argc argv 	consequential damages 
ent ent 	including limited 
swap revs argc 	procurement substitute 
argv ent 	goods services 
ents parents file 	loss use 
revs argc 	data 
argv options argc 	profits business 
argv prefix 	interruption however 
rev ent paths 	caused theory 
blob index 	liability whether 
result arg 	contract strict 
entry obj name 	liability 
flags sha 	tort including 
sha hashcmp diff 	negligence otherwise 
opt tst 	arising way 
strncmp strncmp alloc 	use software 
filespec alloc 	even advised 
filespec fill filespec 	possibility 
fill filespec 	damage dict 
diff queue usage 	enable resize 
guard pathspec 	dict disable 
lstat die errno 	resize make 
isreg islnk 	possible enable 
die diff mnemonic 	disable 
prefix canon 	resizing hash 
mode stuff change 	table needed 
canon mode 	important redis 
diffcore std diff 	use copy 
flush canon 	write want 
mode usage 	move 
stuff change diffcore 	much memory 
std diff 	around child 
flush strcmp strcmp 	performing saving 
usage usage 	operations note 
setup work read 	even dict 
cache preload 	resize 
perror read cache 	resizes prevented 
perror run 	hash table 
diff index usage 	still allowed 
diff sha 	grow ratio 
log diff flush 	number elements 
usage sha 	buckets 
append diff combined 	dict force 
sha clear 	resize ratio 
xcalloc hold locked 	prototypes hash 
index discard 	functions thomas 
cache read 	wang bit 
cache refresh cache 	mix 
update index 	function murmur 
able strcmp strcmp 	hash austin 
strcmp strcmp 	appleby note 
strcmp usage error 	code makes 
setup work 	assumptions machine 
read cache preload 	behaves 
perror run 	read address 
diff files strcmp 	without crashing 
strcmp setup 	limitations work 
git directory gently 	incrementally produce 
path inside 	results little 
repo path inside 	endian 
repo gitmodules 	big endian 
config git config 	machines mixing 
init revisions 	constants generated 
usagef diff index 	offline really 
diff opt 	magic happen 
diff opt 	work 
die setup revisions 	well initialize 
diff setup 	hash random 
done diff opt 	mix bytes 
setup diff 	time hash 
pager strcmp strcmp 	handle last 
strcmp head 	bytes 
pending lookup pending 	input mixes 
parse deref 	hash ensure 
tag die die 	last bytes 
hashcpy die 	well incorporated 
builtin diff files 	insensitive hash 
usage builtin 	function 
diff usage builtin 	djb hash 
diff blobs 	hash api 
usage usage builtin 	implementation reset 
diff index 	hash table 
builtin diff builtin 	already 
diff builtin 	initialized init 
diff combined 	note function 
diff result code 	called destroy 
refresh index 	create hash 
quietly copyright junio 	table initialize 
hamano context 	hash 
metainfo fraginfo old 	table resize 
commit whitespace 	table minimal 
funcinfo use first 	size contains 
digit ignore 	elements invariant 
digits nothing give 	used buckets 
layer defaults 	ratio 
core level commands 	near expand 
git diff 	create hash 
files never affected 	table hash 
setting diff 	table size 
renames user happens 	invalid smaller 
configuration file 	number 
like gnu diff 	elements already 
suppress blank 	inside hash 
empty option 	table rehashing 
backwards compatibility keep 	table size 
track files 	useful allocate 
used diffing sometimes 	hash 
entry refers 	table initialize 
temporary file sometimes 	pointers first 
existing file 	initialization really 
sometimes dev filename 	rehashing first 
external diff 	hash table 
read entry currently 	accept 
use diff 	keys prepare 
tempfile instance refers 	second hash 
temporary file 	table incremental 
tempfile used manage 	rehashing performs 
lifetime trailing 	steps incremental 
newline matter like 	rehashing 
fill mmfile 	returns still 
size avoid 	keys move 
retrieving blob pointing 	old hash 
end incomplete 	table otherwise 
line skip last 	returned note 
blank line 	rehashing 
eof paint well 	step consists 
emit prefix 	moving bucket 
rest hunk header 	may one 
must begin 	key use 
old always least 	chaining old 
bytes skip 	hash 
hunk header fraginfo 	table however 
color trailing 	since part 
blank func header 	hash table 
filled setup 	may composed 
code color enabled 	empty spaces 
color words 	guaranteed 
algorithm described collect 	function rehash 
minus plus 	even single 
lines diff 	bucket since 
hunk divided minus 	visit max 
lines plus 	empty buckets 
lines minus lines 	total 
plus lines 	otherwise amount 
words place two 	work would 
mmfile one 	unbound function 
word line use 	may block 
xdiff run 	time max 
diff two mmfile 	number 
words level 	empty buckets 
diff common parts 	visit note 
file output 	rehashidx overflow 
plus side text 	sure elements 
diff words 	used move 
current plus used 	keys 
trace current 	bucket old 
position plus file 	hash index 
printed diff 	hash table 
words last 	check already 
minus used trace 	rehashed whole 
last minus 	table 
word printed graph 	rehash rehash 
work color 	amount time 
words need output 	milliseconds milliseconds 
graph prefix 	function performs 
line color words 	step rehashing 
output generally 	safe 
two conditions output 	iterators bound 
prefix diff 	hash table 
words last minus 	iterators middle 
diff words 	rehashing mess 
current plus diff 	two hash 
words plus 	tables 
text ptr plus 	otherwise element 
text must 	missed duplicated 
start line minus 	function called 
word printed 	common lookup 
graph prefix 	update operations 
must printed diff 	dictionary 
words current 	hash table 
plus diff words 	automatically migrates 
plus text 	actively used 
ptr diff words 	element target 
current plus 	hash table 
graph prefix must 	low 
printed following 	level function 
posix requires first 	adds entry 
decremented one 	instead setting 
len function starts 	returns dict 
looking begin 	entry structure 
returns iff word 	user 
found find 	make sure 
next word find 	fill field 
end word 	wishes function 
function splits words 	also directly 
buffer text 	exposed user 
stores list 	api 
newline separator saves 	called mainly 
offsets original 	order store 
words buffer orig 	non pointers 
fake empty 	inside hash 
word store original 	example entry 
boundaries store 	dict 
one word executes 	raw dict 
word diff 	mykey entry 
accumulated buffers special 	dict integer 
removal hunk 	val entry 
header parsed need 	values key 
context color 	already 
words mode show 	exists returned 
word diff 	key added 
words accumulated buffer 	hash entry 
use already 	returned manipulated 
loaded driver 	caller index 
fallback settings truncated 	element 
middle cannot 	element already 
happen cannot happen 	exists allocate 
eat newline 	memory store 
eof marker saw 	entry insert 
line nothing 	element top 
without diff words 	assumption 
flush defer 	database system 
processing end preimage 	likely recently 
lines may 	added entries 
come skip prefix 	accessed frequently 
character diff 	hash entry 
suppress blank empty 	fields 
may none 	element discarding 
incomplete line end 	old key 
find common 	already exists 
prefix find common 	key added 
suffix common 	scratch already 
prefix must 	element 
end slash loop 	key dict 
run prefix 	replace performed 
see slash common 	update operation 
prefix cannot 	element key 
would underrun input 	exists dict 
pfx mid 	suceed 
mid sfx pfx 	already exists 
pfx sfx 	entry free 
pfx sfx sfx 	old one 
name name 	note important 
make sure least 	order may 
one printed 	exactly 
change path easiest 	previous one 
way scale 	context think 
linearly alloted width 	reference counting 
one column 	want increment 
shorter result binary 	decrement free 
diff caller 	reverse 
may want 	dict replace 
print files changed 	raw simply 
insertions deletions 	version dict 
omitting insertions deletions 	raw always 
probably less 	returns hash 
confusing skip files 	entry 
changed nothing 	specified key 
added removed lines 	even key 
bug git 	already exists 
find longest filename 	added entry 
max number 	already existing 
changes shown room 	key 
one unmerged 	returned see 
characters bin xxx 	dict raw 
yyy bytes 	information search 
display change counts 	element table 
aligned bin 	unlink element 
stop scanning data 	list 
files width 	found destroy 
stat width 	entire dictionary 
term columns columns 	free elements 
total want 	free table 
maximum min max 	allocated cache 
len stat 	structure 
name width name 	initialize table 
part want 	never fails 
maximum min max 	clear release 
change stat 	hash table 
graph width part 	table fingerprint 
also need 	bit 
width max change 	number represents 
nnnn one 	state dictionary 
empty column end 	given time 
altogether width 	dict properties 
max change enough 	xored together 
space use 	iterator 
smaller stat 	initialized dict 
name width width 	fingerprint check 
filename rest 	fingerprint iterator 
constant elements graph 	released two 
part stat 	fingerprints different 
graph width graph 	means 
part gives 	user iterator 
filename constant parts 	performed forbidden 
graph standard 	operations dictionary 
terminal size words 	iterating hash 
stat width 	integers summing 
limits maximum width 	every 
stat name 	successive integer 
width fixes maximum 	integer hashing 
width filename 	previous sum 
also used divide 	basically result 
available columns 	hash hash 
aren enough binary 	hash 
files displayed 	way integers 
bin xxx 	different order 
yyy bytes instead 	likely hash 
change count 	different number 
graph part treated 	hashing step 
similarly graph 	use 
part scaled total 	tomas wang 
width small 	bit integer 
accommodate guaranteed minimum 	hash hash 
width filename 	hash hash 
part separators message 	hash hash 
message overflow 	need 
making line longer 	save next 
maximum width 	iterator user 
guarantee graph part 	may entry 
filename part 	returning random 
first assign sizes 	entry hash 
wanted ignoring 	table 
available width strlen 	useful implement 
bin xxx 	randomized algorithms 
yyy bytes 	sure elements 
bin width part 	indexes rehashidx 
starting xxx 	found non 
fit graph width 	empty 
adjust adjustable 	bucket linked 
widths exceed maximum 	list need 
width name 	random element 
width width name 	list sane 
area graph 	way counting 
width width graph 	elements 
area max 	random index 
change used scale 	function samples 
graph properly 	dictionary keys 
scale filename scale 	random locations 
width due 	guarantee keys 
sanity check count 	specified 
bytes report 	count guarantee 
dirstat top level 	non duplicated 
cases everything 	elements however 
came single 	make effort 
directory directory sources 	things returned 
sha changed 	pointers 
pre post content 	hash table 
identical therefore 	entries stored 
skip looking file 	des points 
contents altogether 	dict entry 
dirstat file mode 	pointers must 
really need 	room 
look actual file 	least count 
contents fact 	elements argument 
sha changed enough 	pass function 
file list 	tell many 
results file contributing 	random elements 
equal damage 	need 
original minus copied 	function returns 
removed material 	number items 
added material 	stored des 
damages made preimage 	may less 
resulting damage 	count hash 
zero know diffcore 	table 
count changes 	less count 
considers two entries 	elements inside 
identical since 	enough elements 
content changed know 	found reasonable 
must kind 	amount steps 
change force entries 	note 
damage happen 	function suitable 
even many files 	need good 
everything renames 	distribution returned 
show directories changes 	items need 
binary files 	sample given 
counts bytes lines 	number 
must find 	continuous elements 
way normalize binary 	run kind 
bytes textual 	algorithm produce 
lines following 	statistics however 
heuristic assumes bytes 	function much 
per line 	faster 
stupid ugly cheap 	dict random 
happen even 	key producing 
many files everything 	elements hash 
renames show 	table tables 
directories changes line 	rehashing work 
thru line 	proportional 
marker size firstchar 	count pick 
nothing could 	random point 
deflated delta could 	inside larger 
deflated two 	table continuous 
whichever smaller emit 	empty entries 
data encoded 	far 
never use non 	invariant dict 
valid filename 	rehashing indexes 
anywhere possible dev 	already visited 
run diff 	rehashing populated 
different kind 	buckets skip 
objects quite common 	indexes 
confusing crazy 	idx moreover 
xdl interfaces crazy 	currently range 
xdl interfaces 	second table 
codepaths check sides 	elements tables 
checking old 	current rehashing 
side deliberate checking 	index 
newly introduced 	jump possible 
changes side text 	happens going 
check introduces 	big small 
crazy xdl interfaces 	table range 
least one 	table count 
context line report 	contiguous 
errors given 	empty buckets 
name sha pair 	jump locations 
index tells 	reach count 
file work contents 	minimum collect 
prepare temp 	elements buckets 
file inflate 	found 
extract read cache 	non empty 
benchmark previous 	iterating function 
version always reads 	reverse bits 
cache shows 	algorithm http 
makes things worse 	graphics stanford 
diff comparing 	edu 
two linux kernel 	seander bithacks 
trees already 	html reverse 
work diff comparisons 	parallel bit 
deal small 	size must 
number files reading 	power dict 
cache expensive 	scan 
large project cost 	used iterate 
outweighs savings 	elements dictionary 
inflating temporary file 	iterating works 
practically code 	following way 
helps used diff 	initially call 
cache cached 	function 
read cache 	cursor function 
calling want avoid 	performs one 
working directory 	step iteration 
caller doesn need 	returns cursor 
data normal 	must use 
file system rather 	next 
slow stat 	call returned 
open mmap close 	cursor iteration 
syscalls contained 	complete function 
pack file pack 	guarantees elements 
probably already 	present dictionary 
open faster obtain 	returned 
data working 	start end 
directory loose objects 	iteration however 
however would 	possible elements 
tend slower need 	returned multiple 
individually opened 	times every 
inflated sha 	element 
looking unreusable regular 	returned callback 
file marked 	argument called 
unchanged guarantee work 	privdata first 
matches looking 	argument dictionary 
matches file work 	entry second 
reuse looking 	argument 
work rename detection 	works iteration 
pickaxe operation 	algorithm designed 
may need grab 	pieter noordhuis 
data blob 	main idea 
file core comparison 	increment cursor 
diff filespec 	starting 
data size fields 	higher order 
purpose demote 	bits instead 
fail warn allow 	incrementing cursor 
inspecting situation 	normally bits 
instead refusing convert 	cursor reversed 
working format 	cursor 
canonical git 	incremented bits 
format generate xxxxxx 	reversed strategy 
basename ext 	needed hash 
entry produces file 	table may 
entry produces 	resized iteration 
file borrow file 	calls 
work even 	dict hash 
though may sometimes 	tables always 
borrow contents 	power two 
work always want 	size use 
one mode 	chaining position 
mode trustworthy even 	element 
one sha 	given table 
valid diff file 	given computing 
valid one 	bitwise hash 
external diff command 	key size 
takes diff 	size always 
cmd name infile 	mask 
infile sha 	equivalent taking 
infile mode 	rest division 
infile infile sha 	hash key 
infile mode 	size example 
rename fallthru use 	current hash 
colors header 	table 
intended external diff 	size mask 
driver strip 	binary position 
prefix molest dev 	key hash 
absolute paths 	table always 
filepair changes file 	last four 
symlink needs 	bits 
split deletion creation 	hash output 
unmerged unmerged 	forth happens 
pathchange left time 	table changes 
say changes 	size hash 
checking changed paths 	table grows 
ignore whitespace 	elements 
options force look 	anywhere one 
inside contents 	multiple old 
cases always 	bucket example 
need recursive drop 	say already 
caller supplied 	iterated bit 
recursive bits formats 	cursor 
also pickaxe 	mask hash 
would work well 	table size 
say recursive 	hash table 
patches generated submodules 	resized elements 
diffed work 	mask 
must dirtiness shown 	buckets obtain 
output read 	substituting either 
cache die even 	targeted keys 
fails safe 	already visited 
also smudge active 	scanning bucket 
cache active 	smaller 
fails worry cleaning 	hash table 
either full 	iterating higher 
make sense 	bits first 
show first hit 	inverted counter 
happened found 	cursor need 
make sense exit 	restart 
code either 	table size 
stuck form option 	gets bigger 
separate form 	iterating cursors 
option important checks 	without end 
error cases 	also without 
caller knows dirstat 	combination 
related option 	bits already 
given command line 	explored similarly 
allow say 	table size 
function negation input 	shrinks time 
haven initialized 	example going 
filter field another 	combination 
diff filter 	lower three 
start full bits 	bits mask 
aon output 	size already 
format options 	completely explored 
stat stat width 	would visited 
stat name 	sure 
width stat count 	tried example 
renames options 	variations higher 
xdiff options clear 	bit need 
previous settings 	test wait 
flags options misc 	two tables 
options always 	rehashing 
end user says 	yes always 
num divided 	iterate smaller 
scale say internally 	table first 
max score 	test expansions 
num scale convert 	current cursor 
form arguments 	larger 
form versions option 	table example 
expect different 	current cursor 
find unique abbrev 	also larger 
stuffs result 	table size 
dots alignment 	also test 
function written stricter 	inside 
necessary support 	larger table 
currently implemented transformers 	reduces problem 
idea transformers 	back one 
produce diff filepairs 	table larger 
way want 	one exists 
filter clean producing 	expansion 
output unmerged 	smaller one 
interesting deletion addition 	limitations iterator 
mode type 	completely stateless 
change rename interesting 	huge advantage 
valid point 	including additional 
path dealing change 	memory 
change look 	used disadvantages 
file filesystem diffs 	resulting design 
patch format 	possible elements 
useful stat diffs 	however usually 
nothing check 	easy deal 
diffs undecided 	application 
point dealing pair 	level iterator 
whose sides 	must multiple 
valid type either 	elements per 
place edit 	call needs 
rename copy edit 	always keys 
rename might 	chained 
connected broken pair 	given bucket 
causing pathnames 	expansions sure 
rename modification otherwise 	miss keys 
see source 	moving rehashing 
used multiple renames 	reverse cursor 
decrement count 	somewhat 
call copy change 	hard understand 
entry happen 	first comment 
anymore prepare broken 	supposed help 
callers ignore 	emit entries 
line numbers 	cursor make 
computing sha patch 	sure 
returns upon 	smaller bigger 
success writes result 	table emit 
sha order 	entries cursor 
raw stat summary 	iterate indices 
patch name 	larger table 
name status checkdiff 	expansion 
bits clear 	index pointed 
run diff flush 	cursor smaller 
patch exit 	table emit 
status setting options 	entries cursor 
file dev 	increment bits 
safe aren supposed 	covered 
produce output 	smaller mask 
anyway attach patch 	bits covered 
instead report 	mask difference 
content level differences 	non zero 
changes diff 	unmasked bits 
addremove diff 	incrementing 
change bit diff 	reversed cursor 
contents effect 	operates masked 
otherwise clear whole 	bits smaller 
queue copying 	table increment 
empty outq end 	reverse cursor 
function first 	functions 
clear current entries 	expand hash 
queue matching 	table needed 
ones check whether 	incremental rehashing 
two filespecs 	already progress 
mode size identical 	hash table 
entries come 	empty 
stat info dirtiness 	expand initial 
always sides 	size reached 
iow create one 	ratio allowed 
side name 	resize hash 
unknown mode size 	table setting 
keep ones 	avoid 
match criteria 	ratio elements 
real differences point 	buckets safe 
file known 	threshold resize 
modified mode size 	doubling number 
name one 	buckets hash 
side unknown need 	table 
inspect identical 	capability power 
contents caller subtract 	two returns 
skip stat 	index free 
unmatch determine many 	slot populated 
paths dirty 	hash entry 
due stat info 	given 
mismatch note 	key key 
please keep following 	already exists 
sync diff 	returned note 
combined see follow 	process rehashing 
renames diff 	hash table 
see follow renames 	index 
diff shall 	always returned 
changes submodule 	context second 
ignored submodule changes 	hash table 
configured ignored 	expand hash 
separately path configuration 	table needed 
overridden command 	compute 
line may look 	key hash 
odd preparation 	search slot 
feeding unchanged files 	already contain 
produce diffs 	given key 
copy detection would 	debugging compute 
need entries 	stats 
diff core prefixed 	hash entry 
something like 	slot generate 
haven decided make 	human readable 
difference feeding 	stats unlike 
old diff change 	snprintf teturn 
also effect 	number 
output happens pruned 	characters actually 
merged rename 	written make 
copy pairs 	sure term 
appropriate ignore errors 	end dict.h 
might repository 	buf len 
could save changes 	type 
flush end 	priv data 
would need extra 	ptr size 
call diffing 	key val 
done since generating 	key val 
cache entry 	key key 
slow path anyway 	iter 
extra overhead 	iter hash 
probably isn big 	table implementation 
deal user 	file memory 
asked exit code 	hash tables 
either want 	insert del 
quiet exit code 	replace 
definitely bother 	find random 
pager former 	element operations 
generate output since 	hash tables 
still properly 	resize needed 
report exit code 	tables power 
even pager 	two 
run could run 	size used 
pager exit 	collisions handled 
code since done 	chaining see 
historically easy 	source code 
find people oneline 	information copyright 
advising git 	salvatore 
diff exit code 	sanfilippo antirez 
hooks scripts 	gmail dot 
builtin git diff 	rights reserved 
copyright junio 	redistribution use 
hamano blob file 	source binary 
working make 	forms 
sure one revision 	without modification 
pending revision 	permitted provided 
filtering parameters 	following conditions 
saw two trees 	met redistributions 
ent ent 	source code 
ent uninteresting swap 	must 
diff combine 	retain copyright 
merges asked diff 	notice list 
densify user 	conditions following 
wants dense one 	disclaimer redistributions 
explicitly asked 	binary form 
rely could ish 	must 
rev pending 	reproduce copyright 
objects list also 	notice list 
could blobs 	conditions following 
pathspecs cache files 	disclaimer documentation 
diff files 	materials provided 
compare two random 	distribution 
blobs must 	neither name 
zero compare blob 	redis names 
working file 	contributors may 
cache diff 	used endorse 
index cached diff 	promote products 
compare two 	derived 
filesystem entities aka 	software without 
index cases 	specific prior 
errors asked index 	written permission 
explicitly treat 	software provided 
git diff least 	copyright holders 
one path 	contributors 
outside repo command 	express implied 
would executed 	warranties including 
outside git repository 	limited implied 
behaves way 	warranties merchantability 
git diff index 	fitness particular 
acts colourful 	purpose 
diff replacement index 	disclaimed shall 
two paths 	copyright owner 
possible user intended 	contributors liable 
inside repository 	direct indirect 
operation give 	incidental special 
usage message non 	exemplary 
repository usage 	consequential damages 
exit index diff 	including limited 
run exit 	procurement substitute 
otherwise usual git 	goods services 
diff scale 	loss use 
real terminal size 	data 
respect stat 	profits business 
graph width config 	interruption however 
external textconv 	caused theory 
used cached pending 	liability whether 
head hand 	contract strict 
eek arguments look 	liability 
reasonable diff 	tort including 
least one merge 	negligence otherwise 
ent objects 	arising way 
merge ent 	use software 
objects ents ent 	even advised 
objects ents 	possibility 
show diff note 	damage unused 
pick one 	arguments generate 
merge random one 	annoying warnings 
diff.h orderfile 	initial size 
pickaxe single follow 	every hash 
prefix prefix 	table 
flags touched flags 	macros api 
filter use 	dict hash 
color context interhunkcontext 	tables implementation 
opt detect 	file memory 
rename irreversible skip 	hash tables 
stat unmatch 	insert 
line termination output 	del replace 
format pickaxe 	find random 
opts rename score 	element operations 
rename limit 	hash tables 
needed rename 	resize needed 
limit degraded show 	tables 
rename progress 	power two 
dirstat permille setup 	size used 
abbrev error 	collisions handled 
highlight prefix prefix 	chaining see 
length stat 	source code 
sep xdl opts 	information 
stat width 	copyright salvatore 
stat name width 	sanfilippo antirez 
stat graph 	gmail dot 
width stat count 	rights reserved 
word regex 	redistribution use 
found changes found 	source 
follow diff 	binary forms 
options file close 	without modification 
file pathspec 	permitted provided 
pathchange change format 	following conditions 
callback format 	met redistributions 
callback data 	source 
output prefix output 	code must 
prefix length 	retain copyright 
output prefix data 	notice list 
diff path 	conditions following 
counter diff color 	disclaimer redistributions 
diff options 	binary 
mime boundary leader 	form must 
sha parent 	reproduce copyright 
sha nparent opt 	notice list 
diff sha 	conditions following 
diff root sha 	disclaimer documentation 
next path 	materials 
mode oid status 	provided distribution 
mode oid 	neither name 
elem num parent 	redis names 
dense rev 	contributors may 
info sha parents 	used endorse 
dense rev 	promote 
commit dense 	products derived 
rev options diff 	software without 
options diff 	specific prior 
options addremove mode 	written permission 
sha sha 	software provided 
valid fullpath dirty 	copyright 
submodule diff 	holders contributors 
options mode mode 	express implied 
sha sha 	warranties including 
sha valid sha 	limited implied 
valid fullpath 	warranties merchantability 
dirty submodule dirty 	fitness 
submodule diff 	particular purpose 
options path opt 	disclaimed shall 
argv optarg 	copyright owner 
diff options diff 	contributors liable 
options diff 	direct indirect 
options diff 	incidental 
options diff options 	special exemplary 
diff options 	consequential damages 
varname needed degraded 	including limited 
revs option 	procurement substitute 
revs cached diff 	goods services 
options diff 	loss 
options diff options 	use data 
rev info 	profits business 
def diff flags 	interruption however 
driver outbuf 	caused theory 
one files insertions 	liability whether 
deletions diff 	contract 
options copyright junio 	strict liability 
hamano output 	tort including 
format know flag 	negligence otherwise 
given give 	arising way 
output format unused 	use software 
diff filter 	even 
bits white 	advised possibility 
space error highlighting 	damage unused 
diffcore diff 	arguments generate 
format patch support 	annoying warnings 
diff recursion 	hash table 
follow hack poor 	structure 
man alternative 	every dictionary 
parse option allow 	two implement 
stuck form 	incremental rehashing 
option separate form 	old table 
option traditional 	rehashing progress 
plumbing counter grep 	rehashidx 
patch diff 	number iterators 
raw status letters 	currently running 
diff raw 	safe safe 
status letters proper 	iterator means 
used diffcore 	call dict 
filter insn specify 	dict 
additional restrictions 	find functions 
report anything 	dictionary even 
removed paths report 	iterating otherwise 
racily clean 	non safe 
paths modified fill 	iterator dict 
contents filespec 	next 
respecting textconv defined 	called iterating 
userdiff driver 	iterator fingerprint 
driver parameter must 	misuse detection 
come previous 	initial size 
call textconv therefore 	every hash 
either textconv 	table 
enabled note memory 	macros api 
ownership resulting 	hash table 
buffer depends whether 	types dict 
driver field 	type priv 
memory belongs filespec 	data ptr 
non outbuf 	size 
points newly allocated 	key val 
buffer freed 	key key 
caller look 	val key 
userdiff driver given 	key key 
filespec textconv 	key key 
enabled otherwise result 	iter 
passed fill 	iter des 
textconv diff diffcore-break.c 	count buf 
src dst 	bufsize key 
score merge score 	len buf 
delta size 	len callback 
max size src 	initval 
copied added 	privdata dict 
src removed score 	type heap 
outq merge 	copy key 
score score one 	dict type 
two outq 	heap dict 
outq isreg isreg 	type 
hashcmp diff 	heap copy 
populate filespec diff 	key hash 
populate filespec 	table implementation 
diffcore count 	file memory 
changes diff queue 	hash tables 
clear diff 	insert 
file valid diff 	del replace 
file valid 	find random 
type type strcmp 	element operations 
alloc filespec 	hash tables 
diff queue alloc 	resize needed 
filespec diff 	tables 
queue diff free 	power two 
filespec blob 	size used 
diff free filespec 	collisions handled 
blob free 	chaining see 
diff free filespec 	source code 
data diff 	information 
free filespec data 	copyright salvatore 
diff free 	sanfilippo antirez 
diff file 	gmail dot 
valid diff file 	rights reserved 
valid die 	redistribution use 
diff file valid 	source 
die diff 	binary forms 
file valid die 	without modification 
diff file 	permitted provided 
valid die diff 	following conditions 
queue diff 	met redistributions 
free filespec data 	source 
diff free 	code must 
filespec data free 	retain copyright 
free diff 	notice list 
queue clear strcmp 	conditions following 
strcmp strcmp 	disclaimer 
merge broken diff 	redistributions binary 
diff free 	form must 
copyright junio hamano 	reproduce copyright 
dst recorded 	notice list 
modification src 	conditions following 
different better recording 	disclaimer 
pair create 	documentation materials 
two criteria used 	provided distribution 
algorithm purposes 	neither name 
helping later rename 	redis names 
copy take 	contributors may 
insert account estimate 	used 
amount edit 	endorse promote 
edit large pair 	products derived 
rename copy 	software without 
pick pieces match 	specific prior 
files hand 	written permission 
would want ignore 	software 
inserts pure 	provided copyright 
complete rewrite detection 	holders contributors 
existing contents 	express implied 
removed file complete 	warranties including 
rewrite sizable 	limited implied 
chunk original 	warranties 
still remains result 	merchantability fitness 
rewrite matter 	particular purpose 
much little material 	disclaimed shall 
added file 	copyright owner 
score broken filepair 	contributors liable 
uses latter 	direct 
definition later clean 	indirect incidental 
stage find 	special exemplary 
pieces broken according 	consequential damages 
latter definition 	including limited 
rename copy runs 	procurement substitute 
merge broken 	goods 
pair score lower 	services loss 
given criteria 	use data 
back together operation 	profits business 
happens according 	interruption however 
former definition minimum 	caused theory 
edit parameter 	liability 
tells amount 	whether contract 
edit required consider 	strict liability 
breaking pair 	tort including 
amount deletion merge 	negligence otherwise 
score want 	arising way 
pair broken deletion 	use 
even types 	software even 
different error caught 	advised possibility 
downstream small 	damage unused 
filepair empty files 	arguments generate 
renamed sanity 	annoying warnings 
compute merge score 	initial 
much removed 	size every 
source material clean 	hash table 
stage merge 	macros api 
surviving pair together 	dict hash 
score less 	tables implementation 
minimum rename 	file 
copy runs extent 	memory hash 
damage counts 	tables insert 
inserts deletes removed 	del replace 
lot without 	find random 
adding material really 	element operations 
rewrite filepair 	hash 
much edit insert 	tables resize 
first considered 	needed tables 
rewrite broken create 	power two 
filepair help 	size used 
breaking file much 	collisions handled 
stuff added 	chaining 
possibly moving contents 	see source 
another file 	code information 
rename copy match 	copyright salvatore 
file score 	sanfilippo antirez 
reuse incoming parameter 	gmail dot 
pair broken 	rights 
according score 	reserved redistribution 
subjected rename copy 	use source 
may survive 	binary forms 
intact due lack 	without modification 
suitable rename 	permitted provided 
copy peer caller 	following 
may calling 	conditions met 
without rename copy 	redistributions source 
happens merge 	code must 
broken pieces back 	retain copyright 
one modification 	notice list 
together pair much 	conditions 
computation take 	following disclaimer 
insert account start 	redistributions binary 
line file 	form must 
lines matter lines 	reproduce copyright 
make line 	notice list 
file lines make 	conditions 
line file 	following disclaimer 
either way 	documentation materials 
rewrite hand lines 	provided distribution 
keeping lines 	neither name 
intact matter lines 	redis names 
make line 	contributors 
file lines make 	may used 
line file 	endorse promote 
either way lot 	products derived 
additions rewrite 	software without 
merge happens latter 	specific prior 
merge score 	written 
would good broken 	permission software 
pair score 	provided copyright 
lower merge score 	holders contributors 
merged back 	express implied 
together see comment 	warranties including 
score merge 	limited 
score diffcore deal 	implied warranties 
place edit 	merchantability fitness 
blobs anything 	particular purpose 
split create score 	disclaimed shall 
pair needs 	copyright owner 
merged back together 	contributors 
survive rename 	liable direct 
copy also want 	indirect incidental 
small files 	special exemplary 
deletion one creation 	consequential damages 
two diff 	including limited 
free filepair reusing 	procurement 
one two 	substitute goods 
broken pairs want 	services loss 
merge must 	use data 
half sanity check 	profits business 
one extra 	interruption however 
user src side 	caused 
broken pair 	theory liability 
used rename 	whether contract 
source paths elsewhere 	strict liability 
increment mark 	tort including 
path stays resulting 	negligence otherwise 
already merged 	arising 
peer peer also 	way use 
survived rename 	software even 
copy merge back 	advised possibility 
together peer 	damage unused 
survived merge peer 	arguments generate 
survive keep 	annoying 
output diffcore-delta.c hashval 	warnings hash 
cnt alloc 	table structure 
log free data 	every dictionary 
orig osz 	two implement 
bucket top hashval 	incremental rehashing 
cnt bucket 	old 
lim one accum 	table rehashing 
accum hashval 	progress rehashidx 
hash buf 	number iterators 
text old src 	currently running 
dst src 	safe safe 
count dst count 	iterator 
delta limit 	means call 
src copied added 	dict dict 
src count 	find functions 
dst count dst 	dictionary even 
cnt src 	iterating otherwise 
cnt xmalloc mult 	non 
initial free 	safe iterator 
memset free spanhash 	dict next 
rehash diff 	called iterating 
filespec binary xmalloc 	iterator fingerprint 
mult initial 	misuse detection 
free memset spanhash 	initial 
qsort hash 	size every 
chars hash chars 	hash table 
free free 	macros api 
idea simple 	hash table 
almost data interested 	types dict 
text sometimes 	dict.h 
deal binary data 	buf len 
cut chunks 	type priv 
delimited sequence whichever 	data ptr 
comes first 	size key 
hash chunks source 	val key 
buffer instances 	val 
destination buffer means 	key key 
difference number 	iter iter 
bytes copied source 	hash table 
destination counts 	implementation file 
everything copied source 	memory hash 
destination destination 	tables 
everything copied destination 	insert del 
added approximation 	replace find 
really waste memory 	random element 
actually storing 	operations hash 
sequence hash 	tables resize 
somewhere around hashbuckets 	needed 
count occurrences 	tables power 
wild guess initial 	two size 
hash size 	used collisions 
room smaller hash 	handled chaining 
grow unused 	see source 
hole much prime 	code 
rather carefully 	information copyright 
chosen hashbase initial 	salvatore sanfilippo 
free want 	antirez gmail 
keep maximum hashtable 	dot rights 
size current 	reserved redistribution 
maximum hold many 	use 
different values 	source binary 
overflowing hashtable size 	forms without 
count zero 	modification permitted 
compares end ignore 	provided following 
crlf sequence 	conditions met 
text src 	redistributions 
diffcore-order.c order order 	source code 
cnt orderfile 	must retain 
cnt pass map 	copyright notice 
endp path 	list conditions 
orderfile obj path 	following disclaimer 
objs obj 	redistributions 
pair orderfile strbuf 	binary form 
read file 	must reproduce 
die errno strbuf 	copyright notice 
detach xmemdupz 	list conditions 
alloc strbuf reset 	following disclaimer 
strbuf addstr 	documentation 
wildmatch strrchr prepare 	materials provided 
order match 	distribution neither 
order obj path 	name redis 
qsort alloc 	names contributors 
order objects 	may used 
free copyright junio 	endorse 
hamano one 	promote products 
line comment diffcore-pickaxe.c 	derived software 
regexp hit 	without specific 
priv line len 	prior written 
data regmatch 	permission software 
hold one two 	provided 
regexp kws 	copyright holders 
regmatch ecbdata xpp 	contributors express 
xecfg regexp 	implied warranties 
kws cnt data 	including limited 
regmatch flags 	implied warranties 
kwsm offset one 	merchantability 
two regexp 	fitness particular 
kws one contains 	purpose disclaimed 
two contains 	shall copyright 
regexp kws textconv 	owner contributors 
one textconv 	liable direct 
two ret 	indirect 
regexp kws outq 	incidental special 
needle opts 	exemplary consequential 
regex regexp kws 	damages including 
err cflags 	limited procurement 
errbuf regexec regexec 	substitute goods 
regexec memset 	services 
memset xdi diff 	loss use 
outf regexec 	data profits 
kwsexec contains contains 	business interruption 
diff file 	however caused 
valid diff file 	theory liability 
valid diff 	whether 
opt tst textconv 	contract strict 
textconv diff 	liability tort 
unmodified pair fill 	including negligence 
textconv fill 	otherwise arising 
textconv diff file 	way use 
valid diff 	software 
file valid 	even advised 
free free diff 	possibility damage 
free filespec 	unused arguments 
data diff free 	generate annoying 
filespec data 	warnings initial 
diff queue clear 	size 
pickaxe match 	every hash 
diff free filepair 	table macros 
pickaxe match 	api dict 
diff diff free 	hash tables 
filepair free 	implementation file 
diff opt tst 	memory 
regcomp regerror 	hash tables 
regfree die kwsalloc 	insert del 
diff opt 	replace find 
tst kwsincr strlen 	random element 
kwsprep pickaxe 	operations hash 
regfree kwsfree copyright 	tables 
junio hamano 	resize needed 
copyright google 	tables power 
inc needswork way 	two size 
terminate caller 	used collisions 
early yuck line 	handled chaining 
ought sides 	see 
need run textual 	source code 
diff see 	information copyright 
pattern appears added 	salvatore sanfilippo 
deleted lines 	antirez gmail 
classic exact match 	dot rights 
ignore unmerged 	reserved 
unmodified pair know 	redistribution use 
count even 	source binary 
load blobs unless 	forms without 
textconv play 	modification permitted 
two different textconv 	provided following 
filters pair 	conditions 
exact rename 	met redistributions 
different textconv attributes 	source code 
side might 	must retain 
generate different content 	copyright notice 
showing whole 	list conditions 
changeset needle exists 	following 
munge queue 	disclaimer redistributions 
otherwise clear whole 	binary form 
queue copying 	must reproduce 
empty outq end 	copyright notice 
function first 	list conditions 
clear current entries 	following 
queue showing 	disclaimer documentation 
filepairs needle posix 	materials provided 
people surely 	distribution neither 
sick might want 	name redis 
warn care 	names contributors 
diffcore-rename.c two pair 	may 
rename dst 	used endorse 
rename dst 	promote products 
alloc two first 	derived software 
last next 	without specific 
dst cmp two 	prior written 
ofs two 	permission 
first score rename 	software provided 
src rename 	copyright holders 
src alloc first 	contributors express 
last one 	implied warranties 
score next src 	including limited 
cmp src 	implied 
dst dst len 	warranties merchantability 
src dst 	fitness particular 
score name score 	purpose disclaimed 
src dst 	shall copyright 
minimum score max 	owner contributors 
size delta 	liable 
size size src 	direct indirect 
copied added 	incidental special 
delta limit 	exemplary consequential 
score dst index 	damages including 
src index 	limited procurement 
score src dst 	substitute 
entry index 	goods services 
filespec filespec srcs 	loss use 
dst index 	data profits 
options renames target 	business interruption 
best best 	however caused 
score score source 	theory 
table index 	liability whether 
filespec entry options 	contract strict 
renames file 	liability tort 
table worst num 	including negligence 
create options 	otherwise arising 
rename limit num 	way 
src dst 	use software 
cnt minimum score 	even advised 
copies dst 	possibility damage 
options detect 	unused arguments 
rename minimum score 	generate annoying 
outq rename 	warnings 
count skip unmodified 	hash table 
num create 	structure every 
dst cnt progress 	dictionary two 
two one 	implement incremental 
src pair free 	rehashing old 
dst dst 	table 
strcmp find rename 	rehashing progress 
dst find 	rehashidx number 
rename dst alloc 	iterators currently 
grow memmove 	running safe 
alloc filespec fill 	safe iterator 
filespec strcmp 	means 
alloc grow memmove 	call dict 
strlen isreg 	dict find 
isreg diff 	functions dictionary 
populate filespec diff 	even iterating 
populate filespec 	otherwise non 
max size diff 	safe 
populate filespec 	iterator dict 
diff populate filespec 	next called 
size diffcore 	iterating iterator 
count changes die 	fingerprint misuse 
diff queue 	detection initial 
strcmp diff populate 	size 
filespec hash 	every hash 
sha file sha 	table macros 
hash hashmap 	api hash 
hash hash filespec 	table types 
hashmap next 	dict type 
hashcmp isreg isreg 	priv 
basename record 	data ptr 
rename pair xmalloc 	size key 
hashmap entry 	val key 
init hash 	key val 
filespec hashmap hashmap 	key key 
init insert 	key 
file table find 	key key 
identical files 	iter iter 
hashmap free score 	des count 
compare score 	buf bufsize 
compare diff opt 	key len 
tst diff 	buf 
unmodified pair record 	len callback 
rename pair 	initval privdata 
diff file valid 	dict type 
diff file 	heap copy 
valid strcmp diff 	key dict 
opt tst 	type 
empty blob sha 	heap dict 
rename dst 	type heap 
warning diff opt 	copy key 
tst empty 	hash table 
blob sha 	implementation file 
diff pair unmerged 	memory 
diff file 	hash tables 
valid rename src 	insert del 
rename src 	replace find 
find exact renames 	random element 
many rename 	operations hash 
candidates start progress 	tables 
delay xcalloc 	resize needed 
mult diff unmodified 	tables power 
pair estimate 	two size 
similarity basename record 	used collisions 
better diff 	handled chaining 
free filespec blob 	see 
diff free 	source code 
filespec blob display 	information copyright 
progress stop 	salvatore sanfilippo 
progress qsort find 	antirez gmail 
renames find 	dot rights 
renames free 	reserved 
diff queue clear 	redistribution use 
diff pair 	source binary 
unmerged diff diff 	forms without 
file valid 	modification permitted 
diff file valid 	provided 
locate rename 	following conditions 
dst diff diff 	met redistributions 
diff file 	source code 
valid diff file 	must retain 
valid diff 	copyright notice 
pair broken locate 	list 
rename dst 	conditions following 
diff diff unmodified 	disclaimer redistributions 
pair diff 	binary form 
diff free filepair 	must reproduce 
diff debug 	copyright notice 
queue free diff 	list 
debug queue 	conditions following 
free filespec 	disclaimer documentation 
free free copyright 	materials provided 
junio hamano 	distribution neither 
table rename copy 	name redis 
destinations returns 	names 
success found duplicate 	contributors may 
insert make 	used endorse 
first table rename 	promote products 
copy src 	derived software 
files remember score 	without specific 
insert make 	prior 
first index rename 	written permission 
src index 	software provided 
rename dst src 	copyright holders 
points file 	contributors express 
existed original optionally 	implied warranties 
file destination 	including 
dst points 	limited implied 
newly created file 	warranties merchantability 
may quite 	fitness particular 
similar want say 	purpose disclaimed 
src renamed 	shall copyright 
dst src copied 	owner 
dst edit 	contributors liable 
applied dst compare 	direct indirect 
similar representing 	incidental special 
score integer max 	exemplary consequential 
score exact 	damages including 
match considered better 	limited 
match anything 	procurement substitute 
destination even call 	goods services 
function deal 	loss use 
regular files symlink 	data profits 
renames handled 	business interruption 
exact matches words 	however 
edits renaming 	caused theory 
need check 	liability whether 
source destination sizes 	contract strict 
filled comparing 	liability tort 
already cnt data 	including negligence 
filled know 	otherwise 
good avoid checking 	arising way 
size zero 	use software 
possible size really 	even advised 
flag say 	possibility damage 
whether size valid 	unused arguments 
would consider 	generate 
edits change file 	annoying warnings 
size drastically 	initial size 
delta size must 	every hash 
smaller max 	table macros 
score minimum score 	api dict 
max score 	hash 
min src size 	tables implementation 
dst size 	file memory 
note size 	hash tables 
handled already score 	insert del 
computation would 	replace find 
divide zero issue 	random 
similar percentage 	element operations 
material dst source 	hash tables 
happen sort 	resize needed 
rename similarity matrix 	tables power 
score order 	two size 
similar first sink 	used 
unused ones 	collisions handled 
bottom find best 	chaining see 
source match 	source code 
specified destination hash 	information copyright 
collision non 	salvatore sanfilippo 
regular files modes 	antirez 
must match 	gmail dot 
give higher scores 	rights reserved 
sources haven 	redistribution use 
used already 	source binary 
many identical alternatives 	forms without 
pick one 	modification 
find exact renames 	permitted provided 
first first 	following conditions 
round matches date 	met redistributions 
entries second 	source code 
round match cache 	must retain 
dirty entries 	copyright 
well sources hash 	notice list 
table walk 	conditions following 
destinations find best 	disclaimer redistributions 
source match 	binary form 
free hash data 	must reproduce 
structure entries 	copyright 
find worst one 	notice list 
better worst 	conditions following 
one returns 	disclaimer documentation 
limit need disable 	materials provided 
inexact rename 	distribution neither 
detection would limit 	name 
given instead 	redis names 
basically test rename 	contributors may 
matrix growing 	used endorse 
larger rename limit 	promote products 
square matrix 	derived software 
num create num 	without 
src rename 	specific prior 
limit rename limit 	written permission 
handles potential 	software provided 
overflow specially least 	copyright holders 
bit integers 	contributors express 
running would bust 	implied 
limit running 	warranties including 
usable pair already 	limited implied 
done either 	warranties merchantability 
exact fuzzy 	fitness particular 
unmerged interested source 	purpose disclaimed 
broken really 	shall 
want broken means 	copyright owner 
source actually 	contributors liable 
stays increment rename 	direct indirect 
used score 	incidental special 
one indicate user 	exemplary consequential 
increment rename 	damages 
used score one 	including limited 
indicate user 	procurement substitute 
nothing really want 	goods services 
cull candidates 	loss use 
list early cheap 	data profits 
tests order 	business 
avoid deltas want 	interruption however 
exact renames 	caused theory 
calculate many renames 	liability whether 
left source 	contract strict 
files still 	liability tort 
remain options rename 	including 
copies done 	negligence otherwise 
dealt exact match 	arising way 
already run 	use software 
estimate similarity need 	even advised 
text anymore 	possibility damage 
cost matrix sorted 	unused 
least similar 	arguments generate 
pair point found 	annoying warnings 
renames copies 	hash table 
recorded rename dst 	structure every 
original list 	dictionary two 
still creation would 	implement 
output create 	incremental rehashing 
record turned rename 	old table 
copy already 	rehashing progress 
matching rename copy 	rehashidx number 
source record 	iterators currently 
creation deletion 	running 
would output record 	safe safe 
broken counterpart 	iterator means 
broken create remains 	call dict 
output broken 	dict find 
rename dst rename 	functions dictionary 
copy move 	even 
one path existence 	iterating otherwise 
otherwise counterpart 	non safe 
broken create turned 	iterator dict 
rename edit 	next called 
matching create begin 	iterating iterator 
broken counterpart 	fingerprint 
rename copy path 	misuse detection 
remains usual 	initial size 
ones need kept 	every hash 
need keep 	table macros 
unmodified pairs 	api hash 
diffcore.h sha path 	table 
data cnt 	types dict 
data size count 	endianconv.c argc 
rename used 	argv buf 
mode driver diff 	memrev memrev 
filespec diff 	memrev unused 
filespec diff filespec 	unused 
diff filespec 	sprintf memrev 
diff filespec diff 	sprintf memrev 
filespec one 	sprintf memrev 
two score status 	endinconv endian 
diff filepair 	conversions utilities 
diff filepair queue 	functions 
alloc diff 	never called 
queued diff diff 	directly always 
queue diff 	macros defined 
filespec diff filespec 	endianconv way 
diff queue 	define everything 
diff filepair 	non 
diff options diff 	operation arch 
options orderfile 	already little 
obj orig order 	endian redis 
order orderfile 	tries encode 
obj path objs 	everything little 
diff filespec 	endian 
diff filepair diff 	things need 
queue src 	backward compatible 
dst src count 	still big 
dst count 	endian production 
delta limit src 	environments little 
copied added 	endian 
copyright junio hamano 	lot conversions 
header file 	places ziplists 
diff diff transformers 	intsets zipmaps 
diffcore rename 	need endian 
diffcore pickaxe never 	neutral even 
include header 	memory 
anything internally 	since serialied 
use score rely 	rdb files 
capable hold 	directly single 
bits take bmerge 	write without 
score score 	additional steps 
format two scores 	copyright 
passed around 	salvatore sanfilippo 
one high bit 	antirez gmail 
merge low 	dot rights 
bit rename copy 	reserved redistribution 
similarity minimum 	use source 
minimum happen maximum 	binary 
merge happen 	forms without 
file smaller reference 	modification permitted 
count count 	provided following 
rename users file 	conditions met 
mode use 	redistributions source 
sha trust mode 	code 
use name 	must retain 
read filesystem 	copyright notice 
data free data 	list conditions 
munmap submodules 	following disclaimer 
work dirty appear 	redistributions binary 
combined diff 	form 
data considered binary 	must reproduce 
means know 	copyright notice 
yet etc see 	list conditions 
documentation diff 	following disclaimer 
format txt diff 	documentation materials 
status diff 	provided 
low level diffcore 	distribution neither 
order setup 	name redis 
caller setup used 	names contributors 
order objects 	may used 
nothing nothing nothing 	endorse promote 
dir.c len 	products 
path fdir untracked 	derived software 
files dirs 	without specific 
file ucd 	prior written 
path len count 	permission software 
pattern flags 	provided copyright 
item pattern prefix 	holders 
pattern len 	contributors express 
len pattern patternlen 	implied warranties 
stringlen flags 	including limited 
match status pat 	implied warranties 
buf str 	merchantability fitness 
buf use pat 	particular 
use str 	purpose disclaimed 
pathspec max item 	shall copyright 
len pathspec 	owner contributors 
len dir pathspec 	liable direct 
len name 	indirect incidental 
namelen depth max 	special 
depth cpe 	exemplary consequential 
item prefix 	damages including 
name namelen flags 	limited procurement 
match matchlen 	substitute goods 
name namelen prefix 	services loss 
seen flags 	use 
exclude len name 	data profits 
namelen prefix 	business interruption 
seen dir positive 	however caused 
negative flags 	theory liability 
matched pathspec prefix 	whether contract 
num errors 	strict 
found dup match 	liability tort 
len pattern 	including negligence 
patternlen flags nowildcardlen 	otherwise arising 
len baselen 	way use 
srcpos patternlen flags 	software even 
nowildcardlen path 	advised 
size sha stat 	possibility damage 
pos len 	toggle bit 
data buf 	integer pointed 
last space dir 	little endian 
name len 	big endian 
first last cmp 	toggle 
next dir 	bit integer 
dir dir fname 	pointed little 
baselen check 	endian big 
index sha stat 	endian toggle 
lineno size 	bit integer 
buf entry pos 	pointed 
fname baselen 	little endian 
check index dir 	big endian 
type src 	endianconv.h argc 
dir fname sha 	argv see 
stat dir 	endianconv top 
fname basename basenamelen 	comments 
pattern prefix 	information copyright 
patternlen flags pathname 	salvatore sanfilippo 
pathlen baselen 	antirez gmail 
pattern prefix 	dot rights 
patternlen flags name 	reserved redistribution 
namelen pathname 	use 
pathlen basename dtype 	source binary 
exc exclude 	forms without 
prefix pathname pathlen 	modification permitted 
basename dtype 	provided following 
exclude dir pathname 	conditions met 
pathlen basename 	redistributions 
dtype exclude dir 	source code 
baselen stk 	must retain 
untracked current sha 	copyright notice 
stat dir 	list conditions 
pathname dtype pathlen 	following disclaimer 
basename dir 	redistributions 
pathname dtype exclude 	binary form 
pathname len 	must reproduce 
ent dir pathname 	copyright notice 
len dir 	list conditions 
pathname len 	following disclaimer 
endchar path pathlen 	documentation 
simplify match 	materials provided 
len path len 	distribution neither 
simplify path 	name redis 
len pos path 	names contributors 
len dtype 	may used 
dir name dir 	endorse 
untracked path 	promote products 
check cdir dir 	derived software 
untracked path 	without specific 
check cdir cdir 	prior written 
pathspec alloc 	permission software 
simplify match simplify 	provided 
dir path 	copyright holders 
len simplify baselen 	contributors express 
old flags 	implied warranties 
uts istate 	including limited 
istate istate dir 	implied warranties 
len pathspec 	merchantability 
root len dir 	fitness particular 
path len 	purpose disclaimed 
pathspec simplify untracked 	shall copyright 
trace untracked 	owner contributors 
stats subdir dir 	liable direct 
offset dir 	indirect 
cwd path dir 	incidental special 
ret path 	exemplary consequential 
flag kept dir 	damages including 
len kept 	limited procurement 
empty keep toplevel 	substitute goods 
submodule head 	services 
path flag slash 	loss use 
dirs dir 	data profits 
stk prev info 	business interruption 
exclude stat 	however caused 
excludes file 	theory liability 
stat dir flags 	whether 
info exclude 	contract strict 
sha excludes file 	liability tort 
sha exclude 	including negligence 
per dir index 	otherwise arising 
check valid 	way use 
sha valid stat 	software 
sha untracked 	even advised 
stat data intbuf 	possibility damage 
intlen untracked 	variants function 
ouc varbuf varint 	actual convertion 
len len 	target host 
ucd index ucd 	big 
check valid 	endian functions 
sha valid data 	htonu ntohu 
end untracked 	convert specified 
untracked next end 	network ordering 
len pos 	back big 
pos pos 	endian 
sha stat stat 	systems ops 
sha data 	example-ae.c loop 
ouc end ident 	privdata reply 
ident len 	status status 
len ucd dir 	argc argv 
path len 	redis 
rest component len 	disconnect stop 
ret istate 	stop stop 
path istate path 	signal redis 
istate path 	connect create 
strcasecmp strcmp strncasecmp 	loop redis 
strncmp wildmatch 	attach 
strncmp strlen strlen 	redis connect 
strcmp wildmatch 	callback redis 
wildmatch strbuf strbuf 	disconnect callback 
wildmatch strbuf 	redis command 
release strbuf release 	strlen redis 
guard pathspec 	command 
common prefix 	main put 
len xmemdupz common 	loop scope 
prefix len 	explicitly stopped 
read directory strncmp 	disconnect receiving 
strncmp strncmp 	reply leak 
git fnmatch guard 	example-libev.c 
pathspec within 	privdata reply 
depth match pathspec 	status status 
item within 	argc argv 
depth match pathspec 	redis disconnect 
match pathspec 	signal redis 
strcmp error glob 	connect 
special simple 	redis connect 
length strlen simple 	callback redis 
length wildcard 	disconnect callback 
parse exclude pattern 	redis command 
flexptr alloc 	strlen redis 
mem xmalloc 	command 
alloc grow strlen 	loop disconnect 
cache name 	receiving reply 
pos skip worktree 	leak example-libevent.c 
read sha 	privdata reply 
file free xsize 	status status 
memset hashcpy 	argc 
free free free 	argv redis 
memset strncmp 	disconnect signal 
strlen flex alloc 	redis connect 
mem alloc 	redis libevent 
grow memmove invalidate 	attach 
gitignore invalidate 	redis connect 
gitignore open fstat 	callback redis 
warn inaccessible 	disconnect callback 
close read skip 	redis command 
worktree file 	strlen redis 
index free xrealloc 	command 
xsize fill 	dispatch disconnect 
stat data 	receiving reply 
hashcpy close xmallocz 	leak example-libuv.c 
read full 	privdata reply 
free close close 	status status 
match stat 	argc 
data racy cache 	argv loop 
name pos 	redis disconnect 
strlen stage uptodate 	signal loop 
would convert 	redis connect 
git hashcpy hash 	redis libuv 
sha file 	attach 
fill stat data 	redis connect 
skip utf 	callback redis 
bom trim trailing 	disconnect callback 
spaces exclude 	redis command 
excludes alloc grow 	strlen redis 
memset exclude 	command 
list excludes die 	run disconnect 
excludes file 	receiving reply 
strncmp icase 	leak example.c 
strncmp icase fnmatch 	argc argv 
icase mem 	reply hostname 
strncmp icase strncmp 	port 
icase fnmatch 	timeout buf 
icase mem dtype 	atoi redis 
match basename 	connect timeout 
match pathname last 	redis free 
exclude matching 	exit redis 
list last exclude 	command 
matching list 	free reply 
strncmp free clear 	redis command 
exclude list 	free reply 
free strbuf init 	redis command 
strbuf setlen 	free reply 
xcalloc strchr die 	redis 
lookup untracked 	command free 
exclude list strbuf 	reply redis 
last exclude 	command free 
matching lists 	reply redis 
hashclr sha strbuf 	command free 
addbuf strbuf 	reply 
addstr strbuf detach 	redis command 
excludes hashcmp 	free reply 
invalidate gitignore hashcpy 	snprintf redis 
strbuf setlen 	command free 
strlen strrchr prep 	reply redis 
exclude last 	command 
exclude matching lists 	free reply 
last exclude 	redis free 
matching flex alloc 	seconds ping 
mem cache 	server key 
file exists alloc 	key binary 
grow dir 	safe 
entry cache name 	api two 
alloc grow 	incr create 
dir entry isgitlink 	list numbers 
strncmp isgitlink 	check inside 
lookup untracked 	list disconnects 
read directory recursive 	frees 
memcmp memcmp 	context parse 
memcmp cache file 	options multiline 
exists uptodate 	enable multi 
isgitlink cache name 	line editing 
pos strncmp 	completion callback 
uptodate dtype index 	called 
dtype lstat 	every time 
isreg isdir islnk 	user uses 
directory exists 	tab key 
index excluded strbuf 	load history 
addch treat 	file history 
directory strbuf complete 	file 
read directory 	plain text 
recursive dot dotdot 	file entries 
strcmp strbuf 	separated newlines 
setlen strbuf 	load history 
addstr simplify away 	startup main 
dtype treat 	loop 
one path alloc 	typical linenoise 
grow xstrdup 	application call 
stat invalidate directory 	linenoise block 
memset match 	user types 
stat data racy 	something presses 
invalidate directory 	enter 
fill stat data 	typed returned 
invalidate directory 	malloc allocated 
strbuf addch prep 	linenoise user 
exclude strbuf 	needs free 
setlen prep exclude 	something history 
memset valid 	save 
cached dir opendir 	history disk 
readdir closedir 	historylen command 
read cached dir 	change history 
treat path 	len buf 
lookup untracked 	argc argv 
read directory recursive 	line 
untracked dir 	prgname len 
name exclude matches 	linenoise completion 
pathspec dir 	linenoise completion 
ignored dir name 	strcmp linenoise 
untracked close 	multi line 
cached dir strbuf 	strcmp 
release name 	linenoise print 
compare alloc grow 	key codes 
simple length 	exit exit 
free memchr strbuf 	linenoise completion 
setlen strbuf 	callback linenoise 
directory simplify away 	history 
treat one 	load linenoise 
path strbuf release 	linenoise history 
uname die 	linenoise history 
errno strbuf addf 	save strncmp 
git work 	atoi linenoise 
strcmp ident 	history 
strbuf reset strbuf 	max len 
addstr ident 	free seconds 
strbuf addch xcalloc 	ping server 
strbuf init 	key key 
untracked ident untracked 	binary safe 
cache ident 	api 
untracked free untracked 	two incr 
cache untracked 	create list 
cache free untracked 	numbers check 
cache getenv 	inside list 
strcmp ident untracked 	disconnects frees 
warning xmalloc 	context 
memset hashcmp invalidate 	parse options 
gitignore hashcmp 	multiline enable 
invalidate gitignore guard 	multi line 
pathspec symlink 	editing completion 
leading path create 	callback called 
simplify validate 	every 
untracked cache 	time user 
treat leading path 	uses tab 
read directory 	key load 
recursive free simplify 	history file 
qsort qsort 	history file 
trace key init 	plain 
trace key 	text file 
free lstat toupper 	entries separated 
toupper cmp 	newlines load 
icase dir sep 	history startup 
dir sep 	main loop 
dir sep xgetcwd 	typical 
dir inside 	linenoise application 
free opendir readdir 	call linenoise 
dot dotdot 	block user 
closedir resolve gitlink 	types something 
opendir rmdir 	presses enter 
strbuf complete 	typed 
readdir dot dotdot 	returned malloc 
strbuf setlen 	allocated linenoise 
strbuf addstr lstat 	user needs 
isdir dir 	free something 
recurse unlink closedir 	history save 
strbuf setlen 	history 
rmdir dir recurse 	disk historylen 
access warn 	command change 
excludes file git 	history len 
path info 	example.c argc 
exclude access warn 	argv reply 
excludes file 	hostname 
unlink strrchr xstrdup 	port timeout 
rmdir strrchr 	buf atoi 
free free clear 	redis connect 
exclude list 	timeout redis 
free free strbuf 	free exit 
release htonl 	redis 
htonl htonl 	command free 
htonl htonl htonl 	reply redis 
htonl htonl 	command free 
htonl ewah ewah 	reply redis 
stat data 	command free 
disk strbuf sha 	reply 
ewah strbuf 	redis command 
encode varint strbuf 	free reply 
encode varint 	redis command 
strbuf strbuf strlen 	free reply 
strbuf strlen 	redis command 
write one dir 	free 
strlen flex 	reply redis 
alloc mem stat 	command free 
data disk 	reply snprintf 
stat data disk 	redis command 
hashcpy hashcpy 	free reply 
htonl encode varint 	redis 
strbuf strbuf 	command free 
strbuf ouc 	reply redis 
size free encode 	free seconds 
varint strbuf 	ping server 
ewah ewah ewah 	key key 
strbuf init 	binary 
strbuf init strbuf 	safe api 
init write 	two incr 
one dir encode 	create list 
varint strbuf 	numbers check 
strbuf addbuf ewah 	inside list 
serialize strbuf 	disconnects 
ewah serialize strbuf 	frees context 
ewah serialize 	parse options 
strbuf strbuf addbuf 	multiline enable 
strbuf addbuf 	multi line 
strbuf addch ewah 	editing completion 
free ewah 	callback 
free ewah free 	called every 
strbuf release 	time user 
strbuf release 	uses tab 
strbuf release free 	key load 
untracked free 	history file 
free free free 	history 
free untracked 	file plain 
free memset decode 	text file 
varint alloc 	entries separated 
decode varint alloc 	newlines load 
strlen xmalloc 	history startup 
memcpy memcpy strlen 	main 
xstrdup read 	loop typical 
one dir stat 	linenoise application 
data disk 	call linenoise 
hashcpy stat data 	block user 
disk hashcpy 	types something 
decode varint ouc 	presses 
size xcalloc 	enter typed 
strbuf init 	returned malloc 
strbuf load sha 	allocated linenoise 
stat load 	user needs 
sha stat xstrdup 	free something 
ouc size 	history 
strlen decode varint 	save history 
ewah ewah 	disk historylen 
ewah alloc read 	command change 
one dir 	history len 
ewah read mmap 	buf argc 
ewah read 	argv 
mmap ewah read 	line prgname 
mmap ewah 	len linenoise 
bit ewah bit 	completion linenoise 
ewah bit 	completion strcmp 
free ewah free 	linenoise multi 
ewah free 	line 
ewah free free 	strcmp linenoise 
untracked cache 	print key 
strchr lookup 	codes exit 
untracked invalidate one 	exit linenoise 
component invalidate 	completion callback 
one directory invalidate 	linenoise 
one directory 	history load 
invalidate one component 	linenoise linenoise 
strlen untracked 	history linenoise 
cache invalidate path 	history save 
untracked cache 	strncmp atoi 
invalidate path handles 	linenoise 
recursive filename 	history max 
detection exclude files 	len free 
index knowledge 	seconds ping 
etc see documentation 	server key 
technical api 	key binary 
directory listing txt 	safe 
copyright linus 	api two 
torvalds junio hamano 	incr create 
tells read 	list numbers 
directory recursive 	check inside 
file directory treated 	list disconnects 
values ordered 	frees 
significance directory contains 	context parse 
excluded untracked 	options multiline 
files listed untracked 	enable multi 
path untracked 	line editing 
path excluded support 	completion callback 
data structure 	called 
opendir readdir closedir 	every time 
wrappers helper 	user uses 
functions support ignore 	tab key 
flag wildmatch 	load history 
learned fnm pathname 	file history 
mode yet 	file 
icase path treated 	plain text 
pathspec full 	file entries 
wildcard words prefix 	separated newlines 
considered common 	load history 
prefix pathspec 	startup main 
abc foo abc 	loop 
bar running 	typical linenoise 
subdir xyz common 	application call 
prefix still 	linenoise block 
xyz xuz abc 	user types 
non icase 	something presses 
returns copy longest 	enter 
leading path 	typed returned 
common among pathspecs 	malloc allocated 
calculate common 	linenoise user 
prefix pathspec use 	needs free 
optimize directory 	something history 
walk read directory 	save 
prune match 	history disk 
match given name 	historylen command 
match found 	change history 
match leading directory 	len extent.c 
name match 	size ret 
wildcard matches 	qsize 
name match exactly 	qsize addr 
name tells 	addr addr 
returns match name 	addr index 
namelen prefix 	size size 
cut caller normal 	index extent 
call pattern 	quantize 
prefix common prefix 	extent node 
len prune 	size extent 
something fill directory 	quantize extent 
match pathspec 	node size 
prefix may shorter 	extent node 
command prefix 	addr 
match extra files 	extent node 
extras trimmed 	addr extent 
suppose pathspec foo 	node addr 
bar running 	extent node 
subdir xyz 	addr round 
common prefix empty 	nearest 
thanks may 	chunk size 
xyz foo xyz 	actually requested 
foo user 	normal huge 
want xyz foo 	allocation compare 
foo part 	quantized size 
insensitive need filter 	rather 
xyz foo 	size order 
words trust caller 	sort equally 
comparing prefix 	useful extents 
part icase involved 	address generate 
exact comparison 	red black 
normally caller common 	functions 
prefix len 	generate red 
fact exact matching 	black functions 
name prefix 	extent.h arena 
need check part 	addr size 
defensive check 	zeroed committed 
anyway common 	achunk 
prefix len changed 	prof tctx 
caller introduced 	node node 
use common prefix 	node node 
len penalty 	node node 
turns high prefix 	node node 
really maybe 	arena 
change strncmp match 	node addr 
name item 	node size 
prefix prefix match 	node zeroed 
prefix matched 	node committed 
given name list 	node achunk 
pathspecs returns 	node 
nature closest specific 	tctx node 
match name 	arena addr 
pathspecs caller typically 	size zeroed 
calls multiple 	committed node 
times pathspec seen 	node runs 
different name 	dirty 
namelen entries 	chunks dirty 
index interested seeing 	node node 
pathspec matches 	node node 
names calls function 	node node 
mark left 	node node 
seen pathspec element 	node 
indicating closest 	arena node 
type match element 	addr node 
achieved seen 	size node 
remains zero multiple 	zeroed node 
invocations means 	committed node 
nth pathspec match 	achunk 
names could 	node tctx 
indicate user mistyped 	node arena 
nth pathspec 	addr size 
make exclude patterns 	zeroed committed 
optional never 	node node 
report pathspec exclude 	runs 
foo matches 	dirty chunks 
files make 	dirty node 
sure pathspec matched 	extent node 
otherwise error 	arena extent 
caller might fed 	node addr 
identical pathspec 	extent 
twice barf mistake 	node size 
fixme parse 	extent node 
pathspec eliminated duplicate 	zeroed extent 
pathspec match 	node committed 
already length simple 	extent node 
part path 	achunk 
match limiter excluded 	extent node 
trailing slash 	prof tctx 
one allocation instead 	meld meld 
make sure 	jemalloc types 
nowildcardlen exceed real 	extents use 
patternlen frees 	accessor 
memory within 	functions fields 
allocated exclude patterns 	arena extent 
file buffer 	came pointer 
free fallthrough given 	extent node 
subdirectory name 	responsible total 
dir current directory 	region 
search subdir 	size zeroed 
dir create one 	flag used 
exist dir 	chunk recycling 
name trailing slash 	code track 
excluded search 	whether memory 
given file name 	zero 
fname read 	filled physical 
either disk index 	memory committed 
check index 	extent whether 
non zero parse 	explicitly implicitly 
store exclude 	system overcommits 
rules compute sha 	satisfies 
exclude file 	physical memory 
fill stat 	needs demand 
data disk valid 	via soft 
excludes returns 	page faults 
zero valid non 	achunk flag 
zero must 	used 
contain good input 	validate huge 
content change 	allocation lookups 
sha still good 	arena chunks 
used core 	profile counters 
excludesfile git info 	used huge 
exclude lists 	objects 
setup standard excludes 	linkage arena 
called dir 	runs dirty 
untracked assigned function 	chunks cache 
behaves differently 	rings linkage 
dir untracked non 	size address 
see validate 	ordered 
untracked cache matching 	linkage arena 
fooliteral match 	huge node 
fnm pathname 	cache lists 
pattern implicitly front 	linkage address 
baselen count 	ordered 
trailing slash may 	jemalloc structs 
may end 	jemalloc externs 
trailing slash though 	jemalloc inlines 
non wildcard 	fmacros.h copyright 
part longer remaining 	salvatore sanfilippo 
pathname surely 	antirez 
cannot match whole 	gmail dot 
pattern wildcard 	rights reserved 
prefix match need 	redistribution use 
need call 	source binary 
fnmatch scan given 	forms without 
exclude list 	modification 
reverse see whether 	permitted provided 
pathname ignored 	following conditions 
first match last 	met redistributions 
list determines 	source code 
fate returns 	must retain 
exclude list element 	copyright 
matched undecided 	notice list 
undecided undefined scan 	conditions following 
list last 	disclaimer redistributions 
match determine fate 	binary form 
exclude include 	must reproduce 
undecided undecided loads 	copyright 
per directory 	notice list 
exclude list substring 	conditions following 
length baselen 	disclaimer documentation 
pop exclude lists 	materials provided 
excl dirs 	distribution neither 
exclude list originate 	name 
directories prefix 	redis names 
path see strbuf 	contributors may 
detach skip 	used endorse 
traversing sub 	promote products 
directories parent excluded 	derived software 
lazy initialization 	without 
call sites currently 	specific prior 
memset dir 	written permission 
dir use changing 	software provided 
seems lots 	copyright holders 
work little benefit 	contributors express 
read parent 	implied 
directories push abort 	warranties including 
directory excluded 	limited implied 
read per directory 	warranties merchantability 
file know 	fitness particular 
files added directory 	purpose disclaimed 
valid cached 	shall 
dir executed untracked 	copyright owner 
valid gitignore 	contributors liable 
exist exclude sha 	direct indirect 
skip loading 	incidental special 
gitignore would 	exemplary consequential 
result enoent anyway 	damages 
dir basebuf 	including limited 
gets reused traversal 	procurement substitute 
need fname 	goods services 
remain unchanged ensure 	loss use 
src member 	data profits 
exclude correctly back 	business 
references source 	interruption however 
file invocations exclude 	caused theory 
list provide 	liability whether 
stable strbuf detach 	contract strict 
free caller 	liability tort 
needswork untracked cache 	including 
enabled prep 	negligence otherwise 
exclude first called 	arising way 
valid cached 	use software 
dir maybe many 	even advised 
times last 	possibility damage 
exclude matching 	net 
cache used last 	bsd xopen 
exclude matching 	source undefines 
called reading gitignore 	netbsd source 
content waste 	thus hides 
called valid cached 	inet aton 
dir gitignore 	etc 
sha index gitignore 	copyright salvatore 
modified work 	sanfilippo antirez 
could delay reading 	gmail dot 
gitignore content 	rights reserved 
absolutely need last 	redistribution use 
exclude matching 	source 
careful ignore rule 	binary forms 
order though 	without modification 
loads exclude lists 	permitted provided 
directory containing 	following conditions 
pathname scans exclude 	met redistributions 
lists determine 	source 
whether pathname 	code must 
excluded returns exclude 	retain copyright 
list element 	notice list 
matched undecided loads 	conditions following 
exclude lists 	disclaimer redistributions 
directory containing pathname 	binary 
scans exclude 	form must 
lists determine whether 	reproduce copyright 
pathname excluded 	notice list 
returns otherwise use 	conditions following 
alphabetically sorted 	disclaimer documentation 
index look directory 	materials 
name instead 	provided distribution 
use insensitive directory 	neither name 
hash index 	redis names 
sorts alphabetically entry 	contributors may 
name means 	used endorse 
gitlink sorts end 	promote 
directory defined 	products derived 
entry files 	software without 
contains sort end 	specific prior 
find directory 	written permission 
traversing filesystem three 	software provided 
distinct cases 	copyright 
ignore see directory 	holders contributors 
recurse one 	express implied 
choose depends combination 	warranties including 
existing git 	limited implied 
index contents flags 	warranties merchantability 
passed directory 	fitness 
traversal routine already 	particular purpose 
entries index 	disclaimed shall 
directory name always 	copyright owner 
recurse directory 	contributors liable 
see files already 	direct indirect 
directory name 	incidental 
gitlink always 	special exemplary 
see gitlink regardless 	consequential damages 
whether actual 	including limited 
git directory might 	procurement substitute 
subproject didn 	goods services 
index previously sub 	loss 
cases show 	use data 
directories show directory 	profits business 
unless hide 	interruption however 
empty directories also 	caused theory 
need check 	liability whether 
contains untracked ignored 	contract 
files looks 	strict liability 
like git directory 	tort including 
gitlinks treat 	negligence otherwise 
gitlink show directory 	arising way 
otherwise recurse 	use software 
len strip show 	even 
directories inexact 	advised possibility 
early pruning 	damage net 
recursive directory reading 	bsd xopen 
path cannot 	source undefines 
possibly pathspec skip 	netbsd source 
early function 	thus 
tells whether excluded 	hides inet 
path matches 	aton etc 
list interesting pathspecs 	fmacros.h copyright 
whether path 	salvatore sanfilippo 
matched pathspecs could 	antirez gmail 
possibly ignored 	dot 
excluding specified path 	rights reserved 
happen path 	redistribution use 
mentioned explicitly pathspec 	source binary 
path directory 	forms without 
prefix element pathspec 	modification permitted 
nobody actually 	provided 
cares difference lnk 	following conditions 
reg look 	met redistributions 
directory always 	source code 
exclude indexed files 	must retain 
looking directory 	copyright notice 
working three cases 	list 
exists index 	conditions following 
everything inside directory 	disclaimer redistributions 
working needs 	binary form 
index exist index 	must reproduce 
index know 	copyright notice 
stay directory check 	list 
contents index 	conditions following 
know yet directory 	disclaimer documentation 
working killed 	materials provided 
need recurse exist 	distribution neither 
index index 	name redis 
require directory either 	names 
know everything 	contributors may 
inside killed without 	used endorse 
recursing excluded 	promote products 
explicitly want 	derived software 
show ignored files 	without specific 
ignore treat 	prior 
one path calls 	written permission 
treat directory 	software provided 
check result treat 	copyright holders 
directory getting 	contributors express 
bottom verify directories 	implied warranties 
check path 	including 
recurse first run 	limited implied 
directory exists 	warranties merchantability 
index returns index 	fitness particular 
nonexistent sure 	purpose disclaimed 
changes index impact 	shall copyright 
outcome prep 	owner 
exclude called eventually 	contributors liable 
directory called 	direct indirect 
much later 	incidental special 
last exclude matching 	exemplary consequential 
need determine 	damages including 
validity cache path 	limited 
next calls 	procurement substitute 
nearly way prep 	goods services 
exclude designed 	loss use 
hopefully prep exclude 	data profits 
haven invalidated 	business interruption 
entry gone directory 	however 
found untracked 	caused theory 
entries mark valid 	liability whether 
read directory 	contract strict 
currently ignore anything 	liability tort 
directories regular 	including negligence 
files symlinks git 	otherwise 
doesn handle 	arising way 
yet maybe change 	use software 
day also 	even advised 
ignore name 	possibility damage 
git even directory 	net bsd 
likely change 	xopen 
returns significant path 	source undefines 
treatment encountered 	netbsd source 
scan check file 	thus hides 
directory treated 	inet aton 
recurse subdir instructed 	etc copyright 
treat path 	salvatore 
abort early maximum 	sanfilippo antirez 
state reached 	gmail dot 
skip dir part 	rights reserved 
path appropriate 	redistribution use 
result list recurse 	source binary 
finished checking 	forms 
previous git versions 	without modification 
may saved 	permitted provided 
many nul separated 	following conditions 
ident field 	met redistributions 
insane manage 	source code 
many locations take 	must 
care first 	retain copyright 
one strbuf used 	notice list 
contain list 	conditions following 
nul separated save 	disclaimer redistributions 
nul backward 	binary form 
compatibility flags used 	must 
git status 	reproduce copyright 
support git dir 	notice list 
info exclude 	conditions following 
core excludesfile ignore 	disclaimer documentation 
rule files 	materials provided 
additions command line 	distribution 
invalidate cache 	neither name 
condition also catches 	redis names 
running setup 	contributors may 
standard excludes setting 	used endorse 
dir untracked 	promote products 
optimize main 	derived 
use whole git 	software without 
status work 	specific prior 
involved treat leading 	written permission 
path use 	software provided 
cache subset worktree 	copyright holders 
pathspec support 	contributors 
could make matter 	express implied 
even worse 	warranties including 
different flags may 	limited implied 
produce different 	warranties merchantability 
results see treat 	fitness particular 
directory index 	purpose 
nonexistent without flag 	disclaimed shall 
may need 	copyright owner 
also cache git 	contributors liable 
file content 	direct indirect 
resolve gitlink 	incidental special 
call support collecting 	exemplary 
ignore files 	consequential damages 
use gitignore cache 	including limited 
change gitexclude 	procurement substitute 
everything wrong exc 	goods services 
cmdl considered 	loss use 
cache people skip 	data 
cache validate 	profits business 
git dir info 	interruption however 
exclude core 	caused theory 
excludesfile make sure 	liability whether 
directory dropped 	contract strict 
saving phase check 	liability 
create simplify 	tort including 
exclude patterns treated 	negligence otherwise 
like positive 	arising way 
ones create simplify 	use software 
usually exclude 	even advised 
patterns subset 	possibility 
positive ones impacts 	damage net 
create simplify 	bsd xopen 
make sure untracked 	source undefines 
cache code 	netbsd source 
path disabled prep 	thus hides 
exclude given 	inet 
two normalized paths 	aton etc 
trailing slash 	fpconv.c locale 
subdir outside dir 	point buf 
otherwise offset 	lower nptr 
subdir used relative 	endptr localbuf 
path dir 	buf 
hel hel yeah 	endbuf buflen 
dir foo 	fmt precision 
foo foo bar 	str num 
foo descend 	precision buf 
nuke nested git 	fmt len 
work empty 	snprintf 
dir could 	abort valid 
removable even unreadable 	number character 
file disappeared 	strtod strtod 
wanted anyway fall 	buffer size 
thru happy 	malloc abort 
happy path stat 	memcpy 
fails non 	strchr strtod 
directory still exists 	free number 
report uplevel 	format snprintf 
error rmdir directory 	snprintf fpconv 
core excludefile 	update locale 
defaulting xdg home 	fpconv 
git ignore 	floating point 
per repository user 	conversion routines 
preference frees 	copyright mark 
memory within dir 	pulford mark 
allocated exclude 	kyne permission 
lists exclude stack 	hereby 
free dir 	granted free 
number written 	charge person 
untracked cache dir 	obtaining copy 
untracked cache 	software associated 
dir untracked cache 	documentation files 
dir exclude 	software 
sha untracked reset 	deal software 
whenever valid 	without restriction 
clear safety skip 	including without 
non recurse 	limitation rights 
directories safe guard 	use copy 
lists nul 	modify 
exclude per dir 	merge publish 
covered ouc 	distribute sublicense 
normally entry added 	sell copies 
removed directory 	software permit 
invalidating directory enough 	persons software 
need touch 	furnished 
ancestors directory shown 	subject following 
foo bar 	conditions copyright 
git status 	notice permission 
however deleting adding 	notice shall 
entry may 	included copies 
cascading effect say 	substantial 
foo bar 	portions software 
file become untracked 	software provided 
need tell 	without warranty 
untracked cache dir 	kind express 
foo bar 	implied including 
untracked directory bar 	limited 
managed foo 	warranties merchantability 
untracked file similarly 	fitness particular 
foo bar 	purpose noninfringement 
file moves untracked 	shall authors 
tracked last 	copyright holders 
untracked entry entire 	liable 
foo show 	claim damages 
foo instead 	liability whether 
means invalidate past 	action contract 
bar foo 	tort otherwise 
function traverses directories 	arising connection 
root leaf 	software 
chance one cases 	use dealings 
happening invalidate 	software json 
back root otherwise 	uses separator 
invalidate leaf 	strtod sprintf 
may sophisticated way 	libraries locale 
checking show 	support 
directories detect cases 	separator comma 
avoid unnecessary 	fpconv around 
invalidation example checking 	issues translation 
untracked entry 	buffer required 
named bar foo 	lua cjson 
stick something 	assumes 
safe simple dir.h 	locale threads 
len name 	within process 
pattern patternlen 	doesn change 
nowildcardlen baselen flags 	initialisation avoids 
srcpos alloc 	need per 
filebuf src excludes 	storage 
prev baselen 	expensive checks 
exclude ucd alloc 	call theory 
stat sha 	multibyte points 
valid dirs untracked 	possible lua 
stat data 	cjson supports 
untracked alloc dirs 	utf 
dirs alloc 	known locales 
untracked exclude sha 	single points 
name info 	localconv may 
exclude excludes file 	safe crash 
exclude per 	langinfo supported 
dir ident dir 	platforms 
flags root 	use sprintf 
dir created gitignore 	instead locale 
invalidated dir 	change least 
invalidated dir 	lua cjson 
opened alloc ignored 	won crash 
ignored alloc 	failing 
entries ignored exclude 	test might 
per dir 	imply platform 
exclude list exclude 	buggy dtoa 
stack exclude 	implementation wide 
basebuf untracked info 	characters check 
exclude excludes 	valid 
file unmanaged exclude 	number character 
files match 	infinity used 
pathspec pathspec name 	find probable 
namelen prefix 	end number 
seen dir matched 	doesn matter 
pathspec prefix 	invalid 
name namelen depth 	characters counted 
max depth 	strtod find 
dir pathspec dir 	valid number 
path len 	exists risk 
pathspec pathname 	slightly memory 
pathlen basename dtype 	might 
dir pathname 	allocated parse 
len dir name 	error occurs 
dtype dir 	hex digits 
name dtype dir 	exponent infinity 
type src 	calculate size 
fname baselen check 	buffer 
index dir 	required strtod 
fname patternlen flags 	locale conversion 
nowildcardlen baselen 	similar strtod 
srcpos dir dir 	must passed 
subdir dir 	current 
name dir dir 	locale point 
path flag 	character guaranteed 
path count pattern 	called start 
flags item 	valid number 
pattern prefix 	system strtod 
pathspec seen ent 	fine 
pathspec prefix 	point valid 
seen trailing dir 	characters found 
len index 	standard strtod 
state index state 	duplicate number 
index state 	buffer handle 
untracked cache data 	unusually 
untracked istate 	large numbers 
istate match pathspec 	common update 
namelen isdir 	point character 
isgitlink match pathspec 	found fmt 
see documentation 	must point 
technical api directory 	buffer 
listing txt 	least characters 
allows callers last 	create format 
exclude matching 	precision assumes 
etc determine origin 	always least 
matching pattern 	characters available 
counting starts 	target 
line numbers ignore 	buffer pass 
files decrementing 	point character 
patterns cli args 	dot snprintf 
excludes file 	buffer translate 
parsed fresh exclude 	point characters 
list appended 	copy 
relevant exclude list 	target location 
either exc 	translate point 
dirs exc file 	required fpconv.h 
exclude list 	lua cjson 
within exc cmdl 	floating point 
exclude list 	conversion 
also used represent 	routines buffer 
list exclude 	required store 
values passed via 	largest representation 
cli args 	longest printed 
remember pointer exclude 	characters nothing 
file contents 	required 
free origin 	geo.c range 
list path filename 	spec bits 
descriptive contents 	hash argv 
per directory exclude 	zobj member 
files lazily 	score unit 
read demand cached 	argv 
memory one 	conversion distance 
per exclude stack 	meters dbuf 
order avoid 	dlen lon 
opening parsing one 	lat radius 
every time 	score member 
directory traversed exclude 	distance 
stack parent 	zobj min 
directory index exclude 	max lon 
list within 	lat radius 
exc dirs exclude 	range origincount 
list untracked 	member eptr 
cache following inputs 	sptr 
sufficient determine 	vstr vlen 
files directory 	vlong score 
excluded list files 	zsl hash 
directories directory 	min max 
question git dir 	zobj hash 
index dir 	lon 
flags content git 	lat radius 
dir info 	min max 
exclude content core 	zobj lon 
excludesfile content 	lat radius 
lack gitignore parent 	neighbors last 
directories git 	processed 
work check flag 	gpb elements 
read directory 	argc argv 
recursive dir hide 	hash bits 
empty directories 	score val 
first input directory 	type key 
mtime many 	storekey 
filesystems directory 	storedist zobj 
mtime stat data 	args member 
field updated 	conversion withcoords 
files direct subdirs 	sort count 
added removed 	remaining arg 
second one hooked 	georadius 
cache invalidate 	result length 
path whenever file 	returned items 
submodule added 	option length 
removed directory invalidate 	zobj maxelelen 
directory remaining 	znode score 
inputs easy sha 	elelen 
could used 	ele geoalphabet 
verify contents exclude 	zobj score 
sha info 	hash buf 
exclude sha excludes 	idx zobj 
file sha 	score meter 
data dirs good 	zobj 
sha means 	score score 
directory gitignore 	xyxy zmalloc 
dir flags must 	zrealloc sdsfree 
match dir 	zfree zfree 
flags untracked cache 	geohash decode 
ignored statistics 	lat 
exclude info maintain 	wgs reply 
three groups 	reply sds 
exclude pattern lists 	sdscatprintf sdsempty 
exc cmdl 	zset score 
lists patterns explicitly 	decode geohash 
given command 	strcmp 
line exc dirs 	strcmp strcmp 
lists patterns 	strcmp reply 
obtained per directory 	error reply 
ignore files 	extract unit 
exc file lists 	reply snprintf 
patterns fallback 	reply 
ignore files git 	bulk buffer 
info exclude 	decode geohash 
core excludesfile 	geohash distance 
contains multiple exclude 	radius wgs 
lists single 	geo append 
list per source 	zzl 
temporary variables 	first range 
used loading per 	ziplist next 
directory exclude 	zzl score 
lists exclude stack 	zsl lte 
points top 	max ziplist 
exclude stack basebuf 	sdsfromlonglong 
contains full 	sdsnewlen geo 
path current sub 	append within 
directory traversal 	radius sdsfree 
exclude points matching 	zzl next 
exclude directory 	zsl first 
excluded enable untracked 	range 
file cache 	zsl lte 
ordering constants significant 	max sdsfromlonglong 
higher numbered 	sdsdup geo 
match types 	append within 
signifying closer specific 	radius sdsfree 
matches lower 	geohash 
numbered match types 	align bits 
populating seen 	geohash align 
implement matching logic 	bits scores 
dir excluded 	geo hash 
list attr path 	box geo 
matches tries 	points 
path empty directories 	range hashiszero 
along ignores 	members geo 
enoent prefix part 	hash box 
pattern must 	sort asc 
contains wildcards dirent.c 	reply error 
dir handle 	zcalloc 
stat ent fdata 	create raw 
name pattern 	incr count 
fdata len dir 	extract lat 
err dir 	reply decr 
fdata lasterr 	count zfree 
dir xwcstoutf xutftowcs 	geohash 
path dir 	encode wgs 
sep find first 	geohash align 
file last 	bits create 
error err win 	sdsfromlonglong incr 
posix xmalloc 	count replace 
finddata dirent find 	client 
next file 	command vector 
finddata dirent last 	zadd command 
error err 	lookup key 
win posix find 	read reply 
close free 	check type 
includes type find 	extract 
first file 	lat reply 
handle index convert 	lat member 
utf name 	reply error 
utf file 	reply error 
type win find 	extract distance 
data convert 	reply 
name utf check 	strcasecmp strcasecmp 
length max 	strcasecmp strcasecmp 
path append optional 	strcasecmp strcasecmp 
wildcard open 	reply reply 
find handle initialize 	error strcasecmp 
dir structure 	strcasecmp 
copy first dir 	reply reply 
entry errno 	error geohash 
mingw first entry 	areas radius 
dirent already 	wgs geo 
opendir next entry 	create members 
convert win 	neighbors 
find data dirent 	reply geo 
posix says 	free qsort 
shouldn errno readdir 	qsort reply 
find files 	multi bulk 
another error 	len reply 
dirent.h type name 	multi 
dirname dir 	bulk len 
dir file type 	reply bulk 
prevent lstat 	sds reply 
readdir file name 	distance reply 
utf conversion 	reply multi 
dirent editor.c editor 	bulk 
terminal terminal 	len reply 
dumb path buffer 	human reply 
env editor 	human create 
args ret sig 	zset sdslen 
getenv getenv 	create incr 
strcmp getenv getenv 	count 
git editor 	zsl insert 
error strcmp start 	server dict 
command error 	zset convert 
sigchain push sigchain 	ziplist needed 
push finish 	key decr 
command sigchain 	count 
pop sigchain pop 	notify keyspace 
error strbuf 	signal modified 
read file error 	key notify 
strerror entry.c 	keyspace reply 
path path len 	geo free 
state buf 	georadius 
len path dir 	georadius lookup 
origlen path 	key read 
mode size path 	reply check 
tempfile symlink 	type reply 
state path filter 	multi bulk 
state tempfile 	len 
fstat done statbuf 	zset score 
result path 	reply decode 
state tempfile mode 	geohash reply 
ifmt ret 	geohash encode 
fstat done buf 	reply bulk 
size wrote 	buffer 
newsize filter 	lookup key 
path len skiplen 	read reply 
slash state 	check type 
topath path changed 	reply multi 
xmallocz dirs 	bulk len 
path mkdir unlink 	zset 
warn mkdir 	score reply 
die errno free 	decode geohash 
opendir die 	reply reply 
errno readdir dot 	multi bulk 
dotdot strbuf 	len reply 
addch strbuf addstr 	human 
lstat die 	reply human 
errno isdir subtree 	extract unit 
unlink die 	reply reply 
errno strbuf setlen 	lookup key 
closedir rmdir 	read reply 
die errno 	check 
open read sha 	type zset 
file free 	score zset 
xsnprintf mkstemp create 	score reply 
file fstat 	decode geohash 
reliable fstat open 	decode geohash 
output stream 	reply 
blob fstat output 	reply distance 
close unlink 	geohash distance 
stream filter streaming 	copyright matt 
write entry 	stancliff matt 
read blob entry 	genges copyright 
error sha 	salvatore 
hex symlink free 	sanfilippo antirez 
error strerror 	gmail rights 
convert working free 	reserved redistribution 
strbuf detach 	use source 
open output free 	binary forms 
error strerror 	without 
write full 	modification permitted 
fstat output close 	provided following 
free error 	conditions met 
error mkdir error 	redistributions source 
error lstat 	code must 
fill stat cache 	retain 
info dirs 	copyright notice 
path lstat write 	list conditions 
entry strbuf 	following disclaimer 
reset strbuf strbuf 	redistributions binary 
namelen check 	form must 
path match stat 	reproduce 
isdir isgitlink 	copyright notice 
error subtree unlink 	list conditions 
error strerror 	following disclaimer 
create directories write 	documentation materials 
entry checkout 	provided distribution 
index prefix dir 	neither 
dir allowed 	name redis 
symlink existing 	names contributors 
directory state dir 	may used 
len test 	endorse promote 
path components prefix 	products derived 
stat function 	software 
instead lstat function 	without specific 
already directory 	prior written 
mkdir would fail 	permission software 
could already 	provided copyright 
symlink something exists 	holders contributors 
therefore unlink 	express 
one time create 	implied warranties 
directory use 	including limited 
fstat path name 	implied warranties 
convert git 	merchantability fitness 
format working format 	particular purpose 
like lstat 	disclaimed 
refuses follow symlinks 	shall copyright 
path skipping 	owner contributors 
skiplen write 	liable direct 
contents working topath 	indirect incidental 
instead writing 	special exemplary 
working file named 	consequential 
temporary file 	damages including 
created function name 	limited procurement 
returned topath 	substitute goods 
must able hold 	services loss 
least temporary 	use data 
filename length bytes 	profits 
unlink old 	business interruption 
file one right 	however caused 
permissions including 	theory liability 
umask nasty emulate 	whether contract 
hand much 	strict liability 
easier system right 	tort 
thing gitlink 	including negligence 
alone environment.c 	otherwise arising 
trust executable bit 	way use 
trust ctime 	software even 
check stat symlinks 	advised possibility 
abbrev ignore 	damage 
unchanged prefer symlink 	things exported 
refs bare 	zset geo 
repository cfg log 	since part 
updates warn 	redis requires 
ambiguous refs warn 	close zset 
refname ambiguity 	introspection 
paranoia repository format 	file following 
version repository 	commands geoadd 
format precious objects 	coordinates geoset 
git commit 	georadius search 
encoding git log 	radius coordinates 
output encoding 	geoset 
shared repository apply 	georadiusbymember search 
whitespace apply 	radius geoset 
ignorewhitespace git 	member position 
attributes file zlib 	geo implementation 
compression level 	create geo 
core compression level 	points 
core compression 	gets allocated 
seen fsync files 	first geo 
packed git 	append call 
window size packed 	entry pointer 
git limit 	caller populate 
delta cache limit 	data 
big file 	destroy geo 
threshold pager program 	created geo 
pager use 	create helpers 
color editor program 	input argument 
askpass program 	helper take 
excludes file check 	pointer 
replace refs 	latitude arg 
git replace whitespace 	use next 
rule cfg 	arg longitude 
notes name 	parse error 
grafts replace parents 	err returned 
core apply 	otherwise 
sparse checkout merge 	input argument 
log config 	helper decode 
precomposed unicode startup 	lat zset 
info pack 	member score 
size limit cfg 	returns successful 
protect hfs 	decoding 
protect ntfs comment 	otherwise err 
line comment 	returned check 
line core preload 	unit argument 
index ignore 	matches one 
untracked cache config 	known units 
git work 	returns 
cfg work len 	conversion factor 
git dir 	meters need 
git common dir 	divide meters 
git dir 	conversion factor 
git index 	convert right 
file git graft 	unit 
file git 	unit valid 
env git index 	error reported 
env git 	client less 
graft env git 	zero returned 
common dir 	input argument 
env local repo 	helper 
env raw 	extract dinstance 
buf components envvar 	specified two 
git dir 	arguments starting 
path fromenv gitfile 	argv shouldbe 
shallow file 	form number 
replace namespaced git 	unit 
work initialized 	dinstance specified 
work limit pattern 	unit success 
mode name 	conversino populated 
namesz sha path 	coefficient use 
xstrdup strbuf 	order convert 
addstr strbuf 	meters 
split strbuf reset 	unit error 
strcmp strbuf 	less zero 
addf strbuf list 	returned reply 
free check 	much accuracy 
refname format die 	use returning 
strbuf addch 	location 
strbuf detach getenv 	distances meters 
xstrfmt xstrdup 	away nicer 
getenv read gitfile 	meters away 
xstrdup common 	provide digits 
dir strbuf detach 	dot returned 
git path 	decently 
env git path 	accurate even 
env git 	unit kilometer 
path env getenv 	helper function 
getenv xstrdup 	geo points 
expand getenv 	range given 
strlen getenv alternate 	sorted 
shallow file 	score representing 
git work setup 	point another 
git env 	point center 
setup git env 	search radius 
starts git 	appends entry 
real path strcmp 	geo 
die xstrdup 	point specified 
real path setup 	geo point 
git env 	within search 
snprintf directory git 	area returns 
mkstemp mode 	point included 
snprintf directory safe 	reids 
create leading 	err outside 
directories xmkstemp mode 	decode note 
snprintf directory 	geohash distance 
sha hex open 	radius wgs 
safe create 	takes 
leading directories 	arguments reverse 
open setup git 	order longitude 
env setup 	first latitude 
git env setenv 	later append 
error setup 	element query 
git env commit 	redis 
output encoding 	sorted extract 
put git config 	elements min 
variables file 	max appending 
programs link config 	geo point 
parser without 	structures gparray 
link rest git 	command 
particular need 	returns number 
bring libz etc 	elements added 
unless needed 	elements farest 
even might want 	radius specified 
know git 	coordinates included 
directory etc unspecified 	ability 
unspecified see 	function append 
probe utf 	existing points 
pathname composition character 	important good 
begins commented 	performances querying 
line user editable 	radius performed 
file subject 	multiple 
stripspace parallel index 	queries sorted 
stat data 	later need 
preload hack test 	sort via 
programs like 	qsort similarly 
test dump untracked 	need able 
cache ensure 	reject 
modify untracked cache 	points outside 
reading use 	search radius 
otherwise setup git 	area asap 
dir gently 	order allocate 
git config repository 	process points 
local git 	needed 
environment variables see 	minex include 
cache details 	min range 
core bare 	maxex exclude 
see work note 	max range 
works used 	min val 
work added primarily 	max 
support git 	nothing exists 
clone work repository 	starting min 
created meant 	results fell 
flip different work 	range know 
trees umask 	element exists 
job restrictive write 	ziplist 
permission slow 	always succeed 
path mkstemp implementations 	nothing exists 
erase failure 	starting min 
slow path ewah 	results abort 
bitmapc self 	node longer 
size rlw offset 	range 
self self 	compute sorted 
self number 	scores min 
added runlen self 	inclusive max 
number self 	exclusive query 
data current num 	order retrieve 
self buffer 	elements 
number negate literals 	inside specified 
self run 	area hash 
len self word 	two scores 
self dist 	returned reference 
self callback payload 	min max 
pos pointer 	want 
word len self 	compute sorted 
self self 	scores include 
word next parent 	elements inside 
self pointer 	specified geohash 
word literals ewah 	hash many 
ewah rlw 	bits 
rlw literals prey 	specified hash 
predator index 	step step 
negate words 	example hash 
ewah ewah rlw 	binary since 
rlw literals 	score bits 
prey predator index 	want 
ewah ewah 	every element 
rlw rlw literals 	binary min 
prey predator 	score use 
index negate words 	initial hash 
ewah ewah 	left shifted 
rlw rlw literals 	enough 
prey predator 	bit later 
index bitmap pool 	increment bit 
bitmap pool 	prefis see 
size self self 	hash bits 
crc size 	statement prefix 
realloc buffer grow 	align 
buffer push 	bits maximum 
rlw run bit 	excluded search 
rlw size 	everything two 
rlw run 	following scores 
bit rlw words 	represented binary 
rlw run 	included 
bit buffer push 	excluded obtain 
rlw rlw 	members min 
run bit rlw 	max geohash 
running len 	bounding box 
min size rlw 	populate geo 
running len 	geo 
buffer push rlw 	points calling 
rlw run 	geo points 
bit rlw running 	range number 
len buffer 	points added 
push rlw rlw 	search eight 
run bit 	neighbors 
rlw running len 	self geohash 
empty words 	box neighbor 
rlw words buffer 	hashbox matching 
push rlw 	members potential 
rlw words 	result list 
buffer push rlw 	huge 
words rlw 	radius range 
words buffer push 	used adjacent 
rlw words 	neighbors leading 
min size rlw 	duplicated elements 
words buffer 	skip every 
grow memcpy buffer 	range 
push rlw 	one processed 
rlw words rlw 	previously sort 
running len 	comparators qsort 
rlw run bit 	adist bdist 
rlw run 	doubles comparator 
bit rlw run 	returns 
bit rlw 	commands geoadd 
running len rlw 	key lat 
running len 	name lat 
buffer push 	name lat 
rlw rlw running 	name check 
len rlw 	arguments 
run bit rlw 	number sanity 
words rlw 	need odd 
run bit rlw 	number arguments 
run bit 	got far 
rlw running len 	zadd key 
rlw running 	score 
len rlw words 	ele key 
empty word 	create argument 
eword empty word 	vector call 
empty words 	zadd order 
rlw words rlw 	score pairs 
running len 	requested 
rlw running len 	zset score 
eword rlw 	actually encoded 
words rlw words 	version lat 
empty word 	turn coordinates 
rlw run 	score element 
bit rlw running 	call 
len callback 	zadd work 
rlw running len 	georadius key 
rlw words 	radius unit 
callback xmalloc alloc 	withdist withhash 
ewah clear 	withcoord asc 
free free rlw 	desc 
running len 	count count 
rlw words rlw 	store key 
run bit 	storedist key 
eword read rlw 	georadiusbymember key 
read rlw 	member radius 
rlw xor run 	unit 
bit rlw 	options store 
words rlwit init 	storedist look 
rlwit init 	requested zset 
rlwit word size 	find lat 
rlwit word 	use radius 
size rlwit 	search 
discharge ewah empty 	inquiry type 
words rlwit 	extract radius 
discard first words 	units arguments 
min size 	discover populate 
ewah rlwit discard 	optional parameters 
first words 	trap 
rlwit discard first 	options compatible 
words rlwit 	store storedist 
word size rlwit 	count without 
discharge rlwit 	ordering make 
discharge max size 	much sense 
rlwit init 	force 
rlwit init rlwit 	asc ordering 
word size 	count specified 
rlwit word size 	sorting requested 
ewah empty 	neighbor geohash 
words rlwit discard 	boxes radius 
first words 	search 
rlwit discard 	search zset 
first words rlwit 	matching points 
discharge ewah 	matching results 
empty words rlwit 	user gets 
discard first 	empty reply 
words min size 	process 
ewah rlwit 	optional requested 
discard first words 	sorting target 
rlwit discard 	key results 
first words rlwit 	user options 
word size 	self contained 
rlwit discharge empty 	nested 
rlwit discharge 	multibulk replies 
empty max size 	need track 
rlwit init 	many nested 
rlwit init rlwit 	replies multibulk 
word size 	len send 
rlwit word size 	exactly 
ewah empty 	result length 
words rlwit 	result either 
discard first words 	zset members 
rlwit discard 	nested multi 
first words rlwit 	bulk reply 
discharge ewah 	containing 
empty words rlwit 	zset member 
discard first 	additional options 
words min size 	user enabled 
ewah rlwit 	request send 
discard first words 	results back 
rlwit discard 	caller 
first words rlwit 	fix according 
word size 	unit options 
rlwit discharge rlwit 	option length 
discharge empty 	sub result 
max size rlwit 	nested multi 
init rlwit 	bulk 
init rlwit 	account result 
word size rlwit 	target key 
word size 	create sorted 
ewah empty words 	results fix 
rlwit discard 	according unit 
first words rlwit 	refcount 
discard first 	since reference 
words rlwit discharge 	skiplist dict 
ewah empty 	georadius wrapper 
words rlwit discard 	function georadiusbymember 
first words 	wrapper function 
min size ewah 	geohash 
rlwit discard 	key ele 
first words rlwit 	ele ele 
discard first 	returns characters 
words rlwit word 	geohash representation 
size rlwit 	position specified 
discharge rlwit discharge 	elements 
max size 	look requested 
ewah ewah 	zset geohash 
free ewah clear 	elements one 
copyright git 	bulk reply 
hub inc copyright 	missing elements 
daniel lemire 	format 
cliff moon david 	use geocoding 
intosh robert 	bit different 
becho google inc 	standard since 
veronika zenz 	use initial 
program free software 	latitude range 
redistribute modify 	normal 
terms gnu general 	geohashing algorithm 
license published 	uses decode 
free software foundation 	position encode 
either version 	standard ranges 
license option later 	order output 
version program 	valid 
distributed hope useful 	geohash decode 
without warranty 	encode geopos 
without even 	key ele 
implied warranty merchantability 	ele ele 
fitness particular 	returns two 
purpose see gnu 	items 
general license 	arrays representing 
details received copy 	position element 
gnu general 	specified arguments 
license along program 	missing elements 
write free 	returned look 
software foundation inc 	requested 
franklin street 	zset report 
fifth floor boston 	elements one 
usa sanity 	bulk reply 
check check completed 	missing elements 
stream todo 	decode geodist 
zero count optimization 	key 
ewah ioc 	ele ele 
self write write 	unit distance 
self write 	meters otherwise 
fun data 	accordig unit 
dump words per 	points ele 
dump bitsize 	ele 
word count rlw 	one elements 
pos buffer 	missing returned 
words left buf 	check unit 
len self 	extract otherwise 
user data data 	meters look 
len self 	requested 
self map len 	zset scores 
ptr self 	need otherwise 
dump words per 	returned decode 
dump bitsize 	compute distance 
word count rlw 	geo.h structures 
pos buffer 	used 
words left write 	inside geo 
write write 	order represent 
write htonl 	points points 
write fun htonl 	earth geohash.c 
write fun 	xlo ylo 
htonll write fun 	interleaved 
htonll write 	range lat 
fun htonl write 	range range 
fun write 	lat range 
ewah serialize strbuf 	longitude latitude 
ewah serialize 	step hash 
realloc memcpy ntohll 	lat 
ewah clear 	offset offset 
read ntohl read 	longitude latitude 
ntohl realloc 	step hash 
read ntohll read 	longitude latitude 
ntohll read 	step hash 
ntohl copyright git 	range 
hub inc 	lat range 
copyright daniel lemire 	hash area 
cliff moon 	step hash 
david intosh 	sep lat 
robert becho google 	scale scale 
inc veronika 	ilato 
zenz program free 	ilono hash 
software redistribute 	area hash 
modify terms gnu 	area area 
general license 	hash area 
published free software 	hash hash 
foundation either 	hash 
version license option 	hash neighbors 
later version 	rangepiszero rangepiszero 
program distributed hope 	interleave geohash 
useful without 	coord range 
warranty without even 	geohash encode 
implied warranty 	geohash 
merchantability fitness particular 	encode type 
purpose see 	hashiszero rangeiszero 
gnu general license 	rangeiszero deinterleave 
details received 	geohash coord 
copy gnu 	range geohash 
general license along 	decode 
program write 	geohash decode 
free software foundation 	type geohash 
inc franklin 	decode type 
street fifth floor 	geohash decode 
boston usa 	area lat 
bit bit size 	geohash 
map bit 	decode lat 
number compressed bit 	type geohash 
words bit 	move geohash 
position rlw bit 	move geohash 
bit size 	move geohash 
map bit number 	move 
compressed bit 	geohash move 
words bit compressed 	geohash move 
words bit 	geohash move 
position rlw copy 	geohash move 
raw data 	geohash move 
bitmap whole 	geohash 
chunk little endian 	move geohash 
platform perform 	move geohash 
endianness conversion separate 	move geohash 
pass ensure 	move geohash 
loading aligned words 	move geohash 
bit bit 	move 
size map bit 	geohash move 
number compressed 	copyright yinqiwen 
bit words bit 	yinqiwen gmail 
compressed words 	copyright matt 
bit position rlw 	stancliff matt 
ewah rlwc 	genges 
ewah discard max 	copyright salvatore 
negate index 	sanfilippo antirez 
rlw words rlw 	gmail rights 
words rlw 	reserved redistribution 
running len 	use source 
rlw run bit 	binary 
next word 	forms without 
rlwit words rlwit 	modification permitted 
word size 	provided following 
next word rlwit 	conditions met 
words rlwit 	redistributions source 
word size ewah 	code 
empty words 	must retain 
ewah dirty words 	copyright notice 
rlwit discard 	list conditions 
first words rlwit 	following disclaimer 
word size 	redistributions binary 
ewah empty words 	form 
rlwit word 	must reproduce 
size rlwit discard 	copyright notice 
first words 	list conditions 
rlwit word size 	following disclaimer 
copyright git 	documentation materials 
hub inc 	provided 
copyright daniel lemire 	distribution neither 
cliff moon 	name redis 
david intosh robert 	names contributors 
becho google 	may used 
inc veronika zenz 	endorse promote 
program free 	products 
software redistribute modify 	derived software 
terms gnu 	without specific 
general license published 	prior written 
free software 	permission software 
foundation either version 	provided copyright 
license option 	holders 
later version program 	contributors express 
distributed hope 	implied warranties 
useful without warranty 	including limited 
without even 	implied warranties 
implied warranty merchantability 	merchantability fitness 
fitness particular 	particular 
purpose see 	purpose disclaimed 
gnu general license 	shall copyright 
details received 	owner contributors 
copy gnu general 	liable direct 
license along 	indirect incidental 
program write free 	special 
software foundation 	exemplary consequential 
inc franklin street 	damages including 
fifth floor 	limited procurement 
boston usa ewok.h 	substitute goods 
buffer buffer 	services loss 
size alloc size 	use 
bit size 	data profits 
rlw self self 	business interruption 
self self 	however caused 
write fun self 	theory liability 
self self 	whether contract 
strbuf self self 	strict 
map len 	liability tort 
self self 	including negligence 
self callback payload 	otherwise arising 
self buffer 	way use 
buffer size pointer 	software even 
compressed literals 	advised 
parent next ewah 	possibility damage 
ewah ewah 	hashing works 
ewah ewah ewah 	like divide 
ewah ewah 	world buckets 
self number self 	label 
buffer number 	one interleave 
negate self word 	lower bits 
words word 	bits even 
alloc self pos 	positions bits 
self pos 	odd must 
self pos self 	initially 
self self 	less https 
self bitmap ewah 	graphics stanford 
self self 	edu seander 
self self 	bithacks html 
callback data self 	interleave bmn 
copyright git 	reverse 
hub inc copyright 	interleave process 
daniel lemire 	derived http 
cliff moon david 	stackoverflow questions 
intosh robert 	constraints epsg 
becho google inc 	epsg osgeo 
veronika zenz 	geocode 
program free software 	north south 
redistribute modify 	pole check 
terms gnu general 	basic arguments 
license published 	sanity error 
free software foundation 	trying index 
either version 	outside 
license option later 	supported constraints 
version program 	convert point 
distributed hope 	step size 
useful without warranty 	hash lat 
without even 	lat part 
implied warranty merchantability 	deinterleaved 
fitness particular 	hash shift 
purpose see gnu 	part hash 
general license 	divide step 
details received copy 	coordinate multiply 
gnu general 	times scale 
license along program 	min 
write free 	absolute coordinate 
software foundation inc 	geohash.h range 
franklin street 	lat range 
fifth floor boston 	range lat 
usa use 	range longitude 
builtin popcountll gcc 	latitude 
implementation notoriously 	step hash 
slow platforms see 	longitude latitude 
http gcc 	step hash 
gnu bugzilla 	longitude latitude 
show bug cgi 	step hash 
builtin ctzll 	range 
available allocate ewah 	lat range 
compressed bitmap 	hash area 
clear bits bitmap 	hash area 
free resize 	hash area 
memory free memory 	area hash 
bitmap logical 	hash 
bitwise negation place 	hash hash 
bitmap operation 	neighbors copyright 
linear time size 	yinqiwen yinqiwen 
bitmap call 	gmail copyright 
given callback position 	matt stancliff 
every single 	matt 
bit bitmap efficient 	genges copyright 
operation fully 	salvatore sanfilippo 
decompress bitmap given 	antirez gmail 
bit bitmap 	rights reserved 
bit position 	redistribution use 
pos way bitmap 	source 
compressed bit 	binary forms 
cannot unset later 	without modification 
furthermore since 	permitted provided 
bitmap uses streaming 	following conditions 
compression bits 	met redistributions 
incrementally ewah bitmap 	source 
ewah bitmap 	code must 
ewah bitmap ewah 	retain copyright 
bitmap ewah 	notice list 
bitmap failed raised 	conditions following 
initialize iterator 	disclaimer redistributions 
run bitmap uncompressed 	binary 
form iterator 	form must 
stack allocated underlying 	reproduce copyright 
bitmap must 	notice list 
freed iteration ewah 	conditions following 
bitmap bitmap 	disclaimer documentation 
ewah ewah 	materials 
iterator ewah iterator 	provided distribution 
init bitmap 	neither name 
every single word 	redis names 
bitmap uncompressed 	contributors may 
form single words 	used endorse 
bits bit 	promote 
represents actual bit 	products derived 
bitmap word 	software without 
words left direct 	specific prior 
word access 	written permission 
uncompressed old school 	software provided 
bitmap efficiently 	copyright 
compressed ewah bitmap 	holders contributors 
ewok rlwh 	express implied 
word word word 	warranties including 
word word 	limited implied 
word word 	warranties merchantability 
self buffer size 	fitness 
pointer word 	particular purpose 
start word words 	disclaimed shall 
running len 	copyright owner 
word offset running 	contributors liable 
bit bitmap 	direct indirect 
max negate eword 	incidental 
eword rlw 	special exemplary 
running len rlw 	consequential damages 
words copyright 	including limited 
git hub inc 	procurement substitute 
copyright daniel 	goods services 
lemire cliff moon 	loss 
david intosh 	use data 
robert becho google 	profits business 
inc veronika 	interruption however 
zenz program free 	caused theory 
software redistribute 	liability whether 
modify terms 	contract 
gnu general license 	strict liability 
published free 	tort including 
software foundation either 	negligence otherwise 
version license 	arising way 
option later version 	use software 
program distributed 	even 
hope useful without 	advised possibility 
warranty without 	damage bits 
even implied warranty 	limits epsg 
merchantability fitness 	epsg osgeo 
particular purpose see 	success failed 
gnu general 	geohash 
license details received 	geohash helperc 
copy gnu 	deg rad 
general license along 	earth radius 
program write 	meters mercator 
free software foundation 	max mercator 
inc franklin 	min 
street fifth 	ang ang 
floor boston usa 	range meters 
exec cmdc 	lat step 
argv exec path 	longitude latitude 
argv path 	radius meters 
path prefix prefix 	bounds 
argv slash 	lonr latr 
exec path env 	distance min 
path old 	latitude max 
path path argv 	latitude min 
argv nargv 	longitude max 
cmd argc argv 	longitude 
arg param 	difference longitude 
absolute path xstrdup 	longitude latitude 
absolute path 	radius meters 
strip path suffix 	range lat 
strip path 	range radius 
suffix strip path 	hash 
suffix trace 	neighbors area 
strbuf addf 	min lon 
strbuf detach find 	max lon 
last dir 	min lat 
sep xstrndup setenv 	max lat 
getenv system 	bounds 
path strbuf absolute 	steps longitude 
path strbuf 	latitude radius 
addch getenv path 	meters hash 
git exec 	bits lon 
path strbuf addstr 	lat lon 
strbuf addstr 	lat 
setenv strbuf release 	lat lon 
argv push 	lat lon 
argv pushv prepare 	radius distance 
git cmd 	radius distance 
trace argv sane 	deg rad 
execvp trace 	deg 
strerror argv clear 	rad asin 
start arg 	sin cos 
end error 	rad deg 
execv git cmd 	rad deg 
propagate setting 	rad deg 
external programs returns 	rad 
highest priority 	deg geohash 
location look git 	bounding box 
programs execvp 	geohash estimate 
ever fails exec 	steps radius 
cmdh exec 	geohash coord 
path path argv 	range 
argv cmd 	geohash encode 
path terminated git 	geohash neighbors 
exec cmd 	geohash coord 
fast-export.c fast export 	range geohash 
usage progress 	decode gzero 
fake missing tagger 	gzero 
use done 	gzero gzero 
feature data 	gzero gzero 
full extra refs 	gzero gzero 
refspecs refspecs 	gzero gzero 
anonymize opt arg 	gzero gzero 
unset opt 	geohash 
arg unset idnums 	areas radius 
last idnum 	deg rad 
commit parent hash 	deg rad 
orig orig 	deg rad 
len anon anon 	deg rad 
len data 	sin 
map generate orig 	sin asin 
len key 	sqrt cos 
ret path map 	cos geohash 
generate end 	distance geohash 
component len mark 	distance radius 
mark mark 	copyright 
decoration counter size 	yinqiwen yinqiwen 
counter sha 	gmail copyright 
size buf 	matt stancliff 
eaten name name 	matt genges 
len len 	copyright salvatore 
len cmp path 	sanfilippo 
need quote 	antirez gmail 
path len counter 	rights reserved 
path paths 	redistribution use 
anon old len 	source binary 
counter sha 	forms without 
sha len options 	modification 
data ospec 	permitted provided 
spec begin end 	following conditions 
needle bol 	met redistributions 
eol old len 	source code 
counter refname 	must retain 
prefixes refs anon 	copyright 
old counter 	notice list 
idents old len 	conditions following 
counter beg 	disclaimer redistributions 
end buffers 	binary form 
buffer split end 	must reproduce 
header ident 	copyright 
len commit rev 	notice list 
saved output 	conditions following 
format commit buffer 	disclaimer documentation 
author author 	materials provided 
end committer committer 	distribution neither 
end encoding 	name 
message reencoded refname 	redis names 
mark old 	contributors may 
len counter commits 	used endorse 
revs commit 	promote products 
name tag size 	derived software 
buf tagger 	without 
tagger end message 	specific prior 
message size 	written permission 
tagged tagged mark 	software provided 
tags signature 	copyright holders 
full name 	contributors express 
tag info sha 	implied 
commit full 	warranties including 
name commit name 	limited implied 
file mark 	warranties merchantability 
deco input file 	fitness particular 
line mark 	purpose disclaimed 
line end mark 	shall 
end sha 	copyright owner 
commit refspec argc 	contributors liable 
argv prefix 	direct indirect 
revs commits commit 	incidental special 
filename lastimportid 	exemplary consequential 
refspecs list options 	damages 
refspecs str 	including limited 
strcmp strcmp strcmp 	procurement substitute 
strcmp strcmp 	goods services 
strcmp error 	loss use 
strcmp strcmp strcmp 	data profits 
error memcmp 	business 
hashmap init hashmap 	interruption however 
entry init 	caused theory 
memhash hashmap xmalloc 	liability whether 
hashmap entry 	contract strict 
init xstrdup generate 	liability tort 
hashmap put 	including 
strchrnul anonymize mem 	negligence otherwise 
strbuf strbuf 	arising way 
addch decoration mark 	use software 
ptr mark 	even advised 
lookup decoration ptr 	possibility damage 
mark strbuf 	conversion 
addf strbuf detach 	ardb project 
sha lookup 	file started 
anonymize blob lookup 	https github 
blob read 	yinqiwen ardb 
sha file 	blob src 
die sha hex 	geo 
check sha 	geohash helper 
signature die sha 	cpp brief 
hex parse 	usual constant 
buffer die sha 	brief earth 
hex mark 	quatratic mean 
next fwrite die 	radius 
errno sha 	wgs must 
hex show progress 	estimate steps 
free strlen 	encoding decoding 
strlen memcmp quote 	always decode 
style quote 	geo step 
style strchr strbuf 	max 
addf strbuf 	make sure 
detach print path 	range included 
anonymize path 	worst wider 
print path strbuf 	range torwards 
reset xcalloc 	poles note 
put anonymize 	possible 
mem qsort print 	better approximation 
path putchar 	computing distance 
print path putchar 	meridians latitude 
print path 	trick frame 
putchar hashcmp isgitlink 	valid range 
sha hex 	step 
anonymize sha lookup 	equal compare 
mark print 	step compare 
path putchar die 	bits note 
memmem strlen 	lazy accounting 
strlen strlen strchrnul 	coordinates near 
strbuf addf 	poles 
strbuf detach strcmp 	calculate distance 
strbuf reset 	haversin great 
size skip prefix 	circle distance 
strbuf addstr 	formula geohash 
anonymize path xstrfmt 	helperh range 
strbuf addf 	meters 
strbuf detach 	lat longitude 
size strbuf reset 	latitude radius 
strchr die 	meters bounds 
strbuf split ident 	longitude latitude 
line anonymize 	radius meters 
mem strbuf strbuf 	longitude 
addch strbuf 	latitude radius 
strbuf addstr parse 	meters longitude 
commit die 	latitude radius 
commit buffer strstr 	meters hash 
die oid 	lon lat 
hex strchrnul strstr 	lon 
die oid 	lat radius 
hex strchrnul strstr 	distance radius 
find encoding 	distance copyright 
mark parse commit 	yinqiwen yinqiwen 
die diff 	gmail copyright 
sha diff 	matt 
root sha isgitlink 	stancliff matt 
export blob 	genges copyright 
anonymize refname anonymize 	salvatore sanfilippo 
ident line 	antirez gmail 
anonymize ident line 	rights reserved 
mark next 	redistribution 
anonymize commit message 	use source 
encoding utf 	binary forms 
reencode strlen strlen 	without modification 
free unuse 	permitted provided 
commit buffer mark 	following conditions 
log diff 	met 
flush show progress 	redistributions source 
strbuf addf 	code must 
strbuf detach unshown 	retain copyright 
parent handle 	notice list 
commit warning oid 	conditions following 
hex read 	disclaimer 
sha file 	redistributions binary 
die oid hex 	form must 
memmem strlen 	reproduce copyright 
memmem strlen strchrnul 	notice list 
anonymize ident 	conditions following 
line anonymize refname 	disclaimer 
anonymize mem 	documentation materials 
strstr die oid 	provided distribution 
hex warning 	neither name 
oid hex warning 	redis names 
oid hex 	contributors may 
mark die oid 	used 
hex die 	endorse promote 
oid hex die 	products derived 
oid hex 	software without 
mark starts parse 	specific prior 
list append 	written permission 
die dwim strlen 	software 
apply refspecs 	provided copyright 
free commit 	holders contributors 
warning export blob 	express implied 
warning list 	warranties including 
append handle tag 	limited implied 
anonymize refname 	warranties 
mark show progress 	merchantability fitness 
fopen writing 	particular purpose 
die errno ptr 	disclaimed shall 
mark oid 	copyright owner 
hex ferror fclose 	contributors liable 
error fopen 	direct 
die errno fgets 	indirect incidental 
strchr die 	special exemplary 
strtoumax sha hex 	consequential damages 
die sha 	including limited 
info die sha 	procurement substitute 
hex lookup 	goods 
commit die sha 	services loss 
hex error 	use data 
sha hex 	profits business 
mark fclose sha 	interruption however 
hex usage 	caused theory 
options git config 	liability 
init revisions 	whether contract 
parse options setup 	strict liability 
revisions usage 	tort including 
options alloc parse 	negligence otherwise 
fetch refspec 	arising way 
list clear free 	use 
marks tags 	software even 
duplicates prepare revision 	advised possibility 
walk die 	damage geohash 
diff opt revision 	helper hpp 
unshown parent 	hash.c file 
handle commit handle 	code 
tail handle 	part hasher 
tags duplicates handle 	https code 
deletes export 	google smhasher 
marks free 	subject mit 
refspec git fast 	license http 
export builtin 	www 
command copyright johannes 	opensource licenses 
schindelin basically 	mit license 
keep cache repeatedly 	php email 
replace anonymized 	addresses associated 
another actual generation 	source code 
farmed generate 	revision 
function anonymize component 	history belong 
path individually 	austin appleby 
paths share common 	revision history 
root paths 	ranges therefore 
cached via anonymize 	copyright license 
mem repeated 	taken 
lookups since intptr 	copyright austin 
use ideally 	appleby permission 
would want 	hereby granted 
transformation blob data 	free charge 
unreversible would 	person 
still size data 	obtaining copy 
relationship blobs 	software associated 
delta packing behavior 	documentation files 
original first 	software deal 
last requirements probably 	software without 
mutually exclusive 	restriction 
take easy way 	including without 
generate arbitrary 	limitation rights 
content need cache 	use copy 
result anonymize 	modify merge 
mem since already 	publish distribute 
handle blob 	sublicense 
content caching marks 	sell copies 
strcmp sort 	software permit 
want move ename 	persons software 
entries last 	furnished subject 
references file 	following conditions 
appear output renamed 	copyright 
file copied 	notice permission 
renamed commit avoid 	notice shall 
sha handle 	included copies 
files directory first 	substantial portions 
deleted directory 	software software 
changes file symlink 	provided 
fallthrough links 	without warranty 
refer objects another 	kind express 
repositories output 	implied including 
sha verbatim prefixes 	limited warranties 
found intact 	merchantability fitness 
tags remain tags 	particular 
forth also 	purpose noninfringement 
master special since 	shall authors 
reveal anything 	copyright holders 
interesting even bother 	liable claim 
cache commit 	damages liability 
messages unlikely 	whether 
repeated verbatim interesting 	action contract 
strategy anonymize 	tort otherwise 
names email addresses 	arising connection 
keep timestamps 	software use 
intact influence things 	dealings software 
like traversal 	hash 
order revealing skip 	keys form 
committer author 	seed hash 
tagger etc export 	result variant 
referenced blobs 	variant variant 
remember marks trees 	hashbytes key 
fast export 	computed 
output thus way 	expected reached 
output tags 	reached hash 
trees tags tags 	variant bits 
trees etc 	variable variable 
simply omit tags 	memset memset 
handle tags 	memset 
fallthru fallthru 	hash memcpy 
handle tag tagged 	hash memcpy 
filtered due 	hash memcpy 
paths specified ignore 	reached hash 
tag altogether 	memcpy hash 
handle nested tags 	memcpy 
obj tag 	hash memcpy 
nested tags already 	reached reached 
handled updated 	hash variant 
commit lets make 	hash variant 
sure gets 	verify hash 
properly updated eventually 	variant 
create refs 	verify hash 
pointing already seen 	variant verify 
commits commits 	test file 
handle encodings fast-import.c 	code part 
idx next 	hasher https 
next pool 	code 
next free end 	google smhasher 
entries marked 	subject mit 
sets shift data 	license http 
offset depth 	www opensource 
next pool next 	licenses mit 
free end 	license 
space next atom 	php email 
str len 	addresses associated 
str dat name 	source code 
mode sha 	revision history 
entry capacity entry 	belong austin 
count delta 	appleby 
depth entries entry 	revision history 
capacity next 	ranges therefore 
avail table next 	copyright license 
branch active 	taken copyright 
next branch name 	austin appleby 
branch last 	permission 
commit num 	hereby granted 
notes sha next 	free charge 
tag name 	person obtaining 
pack sha next 	copy software 
sha prev 	associated documentation 
next buf max 	files 
depth max 	software deal 
packsize force update 	software without 
pack compression 	restriction including 
level pack compression 	without limitation 
seen alloc 	rights use 
count marks count 	copy 
count type 	modify merge 
duplicate count type 	publish distribute 
delta count 	sublicense sell 
type delta count 	copies software 
attempts type 	permit persons 
count branch count 	software 
branch load 	furnished subject 
count failure 	following conditions 
pack edges show 	copyright notice 
stats argc 	permission notice 
argv mem pool 	shall included 
alloc total 	copies 
allocd mem pool 	substantial portions 
atom table 	software software 
atom cnt atom 	provided without 
table pack 	warranty kind 
idx opts pack 	express implied 
pack file 	including 
pack data packs 	limited warranties 
pack size 	merchantability fitness 
entry alloc blocks 	particular purpose 
table marks 	noninfringement shall 
export marks file 	authors copyright 
marks file 	holders 
marks file stream 	liable claim 
marks file 	damages liability 
ignore missing 	whether action 
relative marks paths 	contract tort 
last blob 	otherwise arising 
entry alloc avail 	connection 
entry avail 	software use 
table avail table 	dealings software 
old max 	hash keys 
active branches cur 	form seed 
active branches 	hash result 
branch table branch 	hash.c 
table active 	file code 
branches first tag 	part hasher 
last tag 	https code 
whenspec command buf 	google smhasher 
unread command 	subject mit 
buf cmd hist 	license 
cmd tail 	http www 
free cmd 	opensource licenses 
save next mark 	mit license 
data seen 	php email 
data command require 	addresses associated 
termination checkpoint 	source 
requested cat blob 	code revision 
rpt mark 	history belong 
err loc rpt 	austin appleby 
err zombie 	revision history 
message signo cnt 	ranges therefore 
sha sha 	copyright 
sha len len 	license taken 
count size 	copyright austin 
len len idnum 	appleby permission 
idnum orig 	hereby granted 
idnum len name 	free charge 
name cnt 	person 
cnt amt tmp 	obtaining copy 
file hdr 	software associated 
pack tmpfile 	documentation files 
idx last curr 	software deal 
index name 	software without 
name keep msg 	restriction 
keep name 	including without 
running cur pack 	limitation rights 
sha idx 	use copy 
name store checkpoint 	modify merge 
len sha 	publish distribute 
mark buf buf 	sublicense 
sha hdrlen 	sell copies 
offset checkpoint status 	software permit 
cnt sizep 	persons software 
str modep mode 	furnished subject 
root sha 	following conditions 
myoe size buf 	copyright 
maxlen root 	notice permission 
del root sha 	notice shall 
mode newtree 	included copies 
root sha 	substantial portions 
mode subtree slash 	software software 
root backup 	provided 
leaf allow root 	without warranty 
slash root 	kind express 
leaf allow root 	implied including 
slash msg 	limited warranties 
transaction old sha 	merchantability fitness 
err old 	particular 
cmit cmit msg 	purpose noninfringement 
name err 	shall authors 
transaction mark saved 	copyright holders 
errno line 	liable claim 
mark end sha 	damages liability 
stdin eof 	whether 
term limit len 	action contract 
res data 	tort otherwise 
term term len 	arising connection 
len length 	software use 
src result 	dealings software 
orig src endp 	hash 
num buf 	keys form 
ltgt name len 	seed hash 
ident last 	result variant 
sha mark buf 	variant variant 
len min 	hashbytes key 
commit num notes 	computed 
fanout hex 	expected reached 
sha fanout path 	reached hash 
orig root 	variant bits 
root hex sha 	variable variable 
hex sha 	memset memset 
len fullpath fullpath 	memset 
len fanout 	hash memcpy 
leaf tmp hex 	hash memcpy 
sha len 	hash memcpy 
tmp fullpath len 	reached hash 
num notes 	memcpy hash 
sha realpath 	memcpy 
root fanout hex 	hash memcpy 
sha path 	reached reached 
endptr mark end 	hash variant 
mark mark 	hash variant 
end endp sha 	verify hash 
mode data 	variant 
endp rename endp 	verify hash 
leaf old 	variant verify 
fanout sha commit 	test file 
sha path 	code part 
data fanout commit 	hasher https 
mark commit 	code 
size buf buf 	google smhasher 
size size 	subject mit 
buf sha idnum 	license http 
size buf 	www opensource 
count idnum 	licenses mit 
size buf arg 	license 
msg author 	php email 
committer merge list 	addresses associated 
merge count 	source code 
prev fanout fanout 	revision history 
next arg 	belong austin 
msg tagger mark 	appleby 
sha arg 	revision history 
buf size sha 	ranges therefore 
line size 	copyright license 
buf output sha 	taken copyright 
sha size 	austin appleby 
buf sha mode 	permission 
sha path 	hereby granted 
line type root 	free charge 
leaf endp 	person obtaining 
path marks stream 	copy software 
ignore missing 	associated documentation 
fmt option 	files 
arg endptr depth 	software deal 
branches marks 	software without 
edges option feature 	restriction including 
stream arg 	without limitation 
feature option indexversion 	rights use 
packsizelimit fast 	copy 
usage argc argv 	modify merge 
duplicate count 	publish distribute 
fputs fputs sha 	sublicense sell 
fputs fputc 	copies software 
sha hex sha 	permit persons 
hex sha 	software 
hex fputs fputc 	furnished subject 
fputc git 	following conditions 
pathdup getpid fopen 	copyright notice 
error strerror 	permission notice 
free getpid getppid 	shall included 
show date 	copies 
time date 	substantial portions 
mode fputc fputs 	software software 
fputs fputc 	provided without 
fputc fputs fputs 	warranty kind 
fputs fputs 	express implied 
fputs fputc fputc 	including 
fputs fputs 	limited warranties 
fputc fputs fputs 	merchantability fitness 
fputc fputs 	particular purpose 
fputs write branch 	noninfringement shall 
report fputc 	authors copyright 
fputs fputs fputs 	holders 
sha hex 	liable claim 
fputc fputs fputc 	damages liability 
fputc fputs 	whether action 
fputs dump marks 	contract tort 
helper fputc 	otherwise arising 
fputs fputs fclose 	connection 
free vsnprintf 	software use 
fputs fputs 	dealings software 
fputc write crash 	hash keys 
report end 	form seed 
packfile unkeep packs 	hash result 
dump marks 	hash.h 
exit memset sigemptyset 	key len 
sigaction xmalloc 	seed key 
alloc objects hashcpy 	len seed 
hashcmp hashcmp 	key len 
xmalloc xmalloc pool 	seed key 
alloc memset 	len 
strlen pool alloc 	seed hash 
memcpy pool 	key len 
calloc pool calloc 	seed data 
die str 	nblocks blocks 
strncmp pool alloc 	tail key 
memcpy str 	len 
strlen strcmp 	seed data 
str strlen lookup 	nblocks blocks 
branch die 	tail key 
check refname format 	len seed 
die pool 	data nblocks 
calloc pool strdup 	blocks 
entries pool 	tail key 
alloc entries release 	len seed 
entry release 	hash hashes 
content content memcpy 	kqu kqu 
release content 	hash block 
alloc release content 	hash 
recursive content 	rotl hash 
entry memcpy sha 	rotl hash 
dup content 	rotl hash 
odb mkstemp flex 	fmix hash 
alloc str 	block hash 
sha htonl htonl 	block 
sha write 	hash block 
realloc alloc 	hash block 
die write idx 	hash rotl 
file free 	hash rotl 
odb pack keep 	hash rotl 
die errno 	hash 
write die strlen 	rotl hash 
close die 	rotl hash 
errno snprintf directory 	rotl hash 
sha hex 	rotl hash 
finalize file die 	rotl hash 
snprintf directory 	rotl 
sha hex finalize 	hash rotl 
file die 	hash rotl 
free snprintf directory 	hash rotl 
sha hex 	hash fmix 
unlink warn clear 	hash fmix 
delta cache 	hash 
close pack windows 	fmix hash 
sha close 	fmix kqu 
fixup pack 	kqu hash 
header footer close 	block hash 
keep pack 	block hash 
create index packed 	rotl 
git strlen 	hash rotl 
die install packed 	hash rotl 
git sha 	hash rotl 
hex sha hex 	hash rotl 
fputc fflush 	hash rotl 
close unlink warn 	hash 
free strbuf 	fmix hash 
release end packfile 	fmix hash 
start packfile 	hash following 
sha file truncate 	hash function 
die errno 	murmur hash 
xmalloc xmalloc cycle 	placed 
packfile sha 	domain austin 
file checkpoint snprintf 	appleby see 
die git 	http code 
sha init 	google smhasher 
git sha update 	details jemalloc 
crc begin 	types 
git deflate init 	jemalloc structs 
encode pack 	jemalloc externs 
header die fread 	implementation body 
feof die 	tail finalization 
git sha update 	body tail 
git deflate 	finalization 
sha write die 	body tail 
git deflate 	finalization api 
end git sha 	jemalloc inlines 
hashcpy insert 	help.h command 
insert mark truncate 	groups name 
pack find 	summary 
sha pack truncate 	since automatically 
pack crc 	generated generate 
end free 	command help 
free close pack 	edit hiredis.c 
windows sha 	type task 
flush unpack entry 	str 
content sha 	len task 
find die sha 	elements task 
hex gfi 	task functions 
unpack entry die 	type reply 
sha hex 	task str 
read sha file 	len 
die sha 	parent buf 
hex entry grow 	task elements 
content mode 	parent task 
die sha hex 	parent task 
atom strlen 	parent type 
hashcpy hashcpy free 	str 
name compare 	len buf 
name compare qsort 	size len 
qsort strbuf 	cbuf sbuf 
reset strbuf 	bytes len 
grow strbuf addf 	pos len 
strbuf sha 	dec 
load store find 	mult len 
isdir mktree 	len cur 
mktree store hashcpy 	prv cur 
release entry 	obj len 
isdir die hashclr 	cur obj 
hashcpy release 	len 
content recursive strchrnul 	bytelen success 
die isdir 	cur obj 
die load strncmp 	elements root 
icase isdir 	cur buf 
hashcmp hashcpy release 	len newbuf 
content recursive 	reply 
isdir hashclr isdir 	len len 
content load 	target format 
content hashclr grow 	cmd pos 
content entry 	curarg newarg 
atom hashclr 	touched newargv 
content content hashcpy 	argc 
hashclr strchrnul 	totlen arg 
load strncmp icase 	size intfmts 
isdir isdir 	format cpy 
load content hashclr 	target format 
memcpy release 	len 
content recursive hashclr 	target argc 
hashclr strchrnul 	argv argvlen 
die load strncmp 	cmd pos 
icase isdir 	len totlen 
load content memcpy 	type str 
sha dup 	len 
content sha read 	port port 
hashclr sha 	port port 
lookup commit reference 	source addr 
gently lookup 	path path 
commit reference gently 	path buf 
error merge 	nread 
bases warning 	done nwritten 
sha hex sha 	reply reply 
hex transaction 	wdone aux 
begin transaction update 	cmd len 
transaction commit 	newbuf cmd 
transaction free error 	len 
strbuf release 	format cmd 
transaction free strbuf 	len format 
release update 	ret argc 
branch transaction begin 	argv argvlen 
error strbuf 	cmd len 
reset strbuf addf 	reply 
transaction update 	format format 
error transaction commit 	reply argc 
error transaction 	argv argvlen 
free strbuf release 	calloc free 
strbuf release 	reply free 
dump marks helper 	free 
sha hex 	free create 
hold file 	reply malloc 
update error strerror 	free reply 
fdopen file 	memcpy create 
rollback file error 	reply calloc 
strerror dump 	free 
marks helper commit 	reply create 
file error 	reply create 
strerror fopen die 	reply free 
errno fgets 	sdsfree strlen 
strchr die strtoumax 	memcpy snprintf 
sha hex 	snprintf 
die find die 	snprintf snprintf 
sha hex 	snprintf snprintf 
insert insert mark 	isprint snprintf 
fclose strbuf 	snprintf chrtos 
detach strbuf getline 	snprintf redis 
starts starts 	reader 
parse argv 	error redis 
free skip prefix 	reader error 
parse mark 	seek newline 
skip prefix parse 	read line 
cat blob 	create integer 
fgetc ungetc skip 	read 
prefix strtoumax 	create redis 
read next command 	reader error 
strbuf reset 	oom move 
skip prefix die 	next task 
skip prefix 	seek newline 
xstrdup strbuf detach 	read 
strbuf getline 	create nil 
die strcmp strbuf 	create redis 
addbuf strbuf 	reader error 
addch free strtoumax 	oom move 
die strbuf 	next task 
fread feof die 	redis 
skip optional 	reader error 
strtoul strtoul 	read line 
strbuf addstr strcspn 	read create 
die die 	nil redis 
strcspn die die 	reader error 
strbuf validate 	oom 
raw date die 	move next 
parse date 	task create 
die strcmp die 	redis reader 
datestamp strbuf 	error oom 
detach parse data 	move next 
store strbuf 	task 
release stream blob 	read bytes 
skip optional 	redis reader 
read next command 	error protocol 
parse mark 	process line 
parse store blob 	item process 
release content 	bulk 
recursive load die 	item process 
memcpy memcpy 	multi bulk 
memcpy sha 	item calloc 
hex construct path 	sdsempty free 
fanout strcmp 	free sdsfree 
content die content 	free 
isdir load 	sdsavail sdsfree 
change note fanout 	sdsempty sdscatlen 
change note 	redis reader 
fanout strtoumax die 	error oom 
parse mark 	sdslen process 
die parse mark 	item 
die mode 	sdsrange sdslen 
die die find 	intlen sdsempty 
mark parse 	realloc bulklen 
mark space hashcpy 	sdslen sdsempty 
skip prefix 	sdscatlen arg 
sha hex die 	strlen 
find die 	sdscatlen arg 
strbuf reset unquote 	arg sdscatlen 
style die 	sdscat isdigit 
isdir hashcmp 	isdigit copy 
content isgitlink die 	strchr arg 
die isdir 	strchr 
die strbuf addstr 	arg strchr 
read next 	arg strchr 
command parse store 	arg strchr 
blob die 	strchr arg 
isdir die content 	end memcpy 
replace content 	sdscatvprintf 
strbuf reset unquote 	end realloc 
style die 	bulklen sdslen 
content strbuf reset 	sdsfree intlen 
unquote style 	malloc sprintf 
die strchr die 	sprintf sdslen 
strbuf die 	memcpy 
strbuf reset unquote 	sdslen sdslen 
style die 	sdsfree free 
memset content 	sdsfree free 
content die content 	sdsfree free 
replace content 	start redisv 
change note fanout 	format 
convert num 	command end 
notes fanout find 	intlen strlen 
mark parse 	bulklen malloc 
mark space hashcpy 	sprintf strlen 
skip prefix 	sprintf memcpy 
sha hex die 	strlen 
find die 	memcpy strerror 
lookup branch sha 	calloc sdsempty 
die hashcpy 	redis reader 
parse mark eol 	create close 
find mark 	sdsfree redis 
die hashcpy sha 	reader 
read reference 	free free 
die free die 	redis free 
strbuf addstr 	redis context 
read next 	init redis 
command parse store 	context connect 
blob die 	tcp 
sha die die 	redis context 
construct path 	init redis 
fanout sha hex 	context connect 
content sha 	tcp redis 
convert num notes 	context init 
fanout construct 	redis 
path fanout sha 	context connect 
hex content 	tcp redis 
release content recursive 	context init 
hashclr hashclr 	redis context 
load die sha 	connect bind 
hex memcmp 	tcp 
sha hex die 	redis context 
sha hex 	init redis 
hashcpy sha hashclr 	context connect 
hashclr read 	unix redis 
reference parse 	context init 
commit free skip 	redis 
prefix hashcpy 	context connect 
lookup branch die 	unix redis 
hashcpy hashcpy 	context init 
hashcpy parse mark 	redis context 
eol find 	connect unix 
mark die hashcmp 	redis 
hashcpy gfi 	context init 
unpack entry parse 	redis context 
commit free 	timeout redis 
parse existing sha 	keep alive 
parse existing 	read redis 
sha die hashcmp 	error 
release content 	redis error 
recursive read next 	redis reader 
command skip 	feed redis 
prefix xmalloc lookup 	error sdslen 
branch hashcpy 	write sdslen 
parse mark 	redis 
eol find mark 	error sdslen 
die hashcpy 	sdsfree sdsempty 
sha read reference 	sdsrange sdslen 
die free 	redis reader 
die read next 	reply redis 
command lookup 	error 
branch branch read 	redis reply 
next command 	reader redis 
parse mark skip 	buffer write 
prefix parse 	redis buffer 
ident read next 	read redis 
command skip 	reply 
prefix parse ident 	reader sdscatlen 
read next 	redis error 
command die parse 	redis append 
data read 	command redisv 
next command 	format command 
parse parse merge 	redis 
unload one 	error redis 
branch load branch 	append command 
convert num 	free free 
notes fanout skip 	start redisv 
prefix file 	append command 
change skip prefix 	end 
file change 	redis format 
skip prefix file 	command argv 
change skip 	redis error 
prefix file change 	redis append 
skip prefix 	command free 
note change strcmp 	free 
file change 	redis reply 
deleteall skip prefix 	redisv append 
parse read 	command redis 
next command convert 	block reply 
num notes 	start redisv 
fanout change 	command 
note fanout store 	end redis 
hashcpy strbuf 	append command 
reset strbuf addf 	argv redis 
sha hex 	block reply 
sha strbuf addf 	copyright salvatore 
sha hex 	sanfilippo 
strbuf addf sha 	antirez gmail 
hex free 	dot copyright 
strbuf addf strbuf 	pieter noordhuis 
addbuf free 	pcnoordhuis gmail 
free store pool 	dot rights 
alloc memset 	reserved 
pool strdup read 	redistribution use 
next command 	source binary 
skip prefix die 	forms without 
lookup branch 	modification permitted 
sha die hashcpy 	provided following 
parse mark 	conditions 
eol find 	met redistributions 
mark hashcpy sha 	source code 
find sha 	must retain 
info die die 	copyright notice 
read next 	list conditions 
command skip prefix 	following 
parse ident 	disclaimer redistributions 
read next command 	binary form 
parse data 	must reproduce 
strbuf reset strbuf 	copyright notice 
addf sha 	list conditions 
hex strbuf addf 	following 
strbuf addch 	disclaimer documentation 
strbuf addbuf free 	materials provided 
store lookup 	distribution neither 
branch hashclr hashclr 	name redis 
hashclr release 	names contributors 
content recursive branch 	may 
read next 	used endorse 
command parse 	promote products 
write full die 	derived software 
errno read 	without specific 
sha file gfi 	prior written 
unpack entry 	permission 
strbuf reset strbuf 	software provided 
addf sha 	copyright holders 
hex cat blob 	contributors express 
write strbuf 	implied warranties 
release free die 	including limited 
sha hex 	implied 
die sha hex 	warranties merchantability 
strbuf reset 	fitness particular 
strbuf addf sha 	purpose disclaimed 
hex cat 	shall copyright 
blob write strbuf 	owner contributors 
release cat 	liable 
blob write cat 	direct indirect 
blob write 	incidental special 
strbuf attach 	exemplary consequential 
free die find 	damages including 
mark parse 	limited procurement 
mark eol die 	substitute 
snprintf sha 	goods services 
hex cat blob 	loss use 
write find 	data profits 
mark parse mark 	business interruption 
eol die 	however caused 
hashcpy sha hex 	theory 
die die 	liability whether 
find cat blob 	contract strict 
die sha 	liability tort 
hex insert die 	including negligence 
gfi unpack 	otherwise arising 
entry read sha 	way 
file die 	use software 
sha hex 	even advised 
strlen sha hex 	possibility damage 
strlen die 	functions build 
strlen sha hex 	reply keep 
strlen die 	mind 
free find find 	function returning 
mark parse 	interpreted oom 
mark space die 	create reply 
hashcpy sha 	free reply 
hex die find 	nothing free 
die dereference 	copy 
isgitlink isdir strbuf 	clear input 
reset strbuf 	buffer errors 
addstr quote style 	reset task 
strbuf addch 	stack error 
strbuf reset strbuf 	find pointer 
addf sha 	position 
hex quote style 	len character 
strbuf addch 	pos followed 
cat blob 	note strchr 
write die parse 	cannot used 
treeish dataref 	doesn allow 
entry hashcpy sha 	search 
load strbuf 	limited length 
reset unquote style 	buffer searched 
die die 	might trailing 
content isdir store 	character found 
print release 	found searching 
content recursive release 	read 
entry cycle 	starting assumption 
packfile dump branches 	terminated ambiguously 
dump tags 	returns unexpected 
dump marks skip 	input happen 
optional fwrite 	skip stack 
fputc fflush skip 	empty 
optional absolute 	reset type 
path xstrdup xstrdup 	next item 
git path 	anything type 
die read 	error status 
marks make fast 	reply root 
path safe 	include 
create leading directories 	nil always 
strcmp strcmp 	created buffer 
strcmp die strtoul 	contains entire 
strchr die 	bulk item 
arg die arg 	include proceed 
make fast 	obj 
path safe create 	created reply 
leading directories 	root error 
arg die fclose 	nested multi 
fopen die 	bulks depth 
errno skip prefix 	modify task 
git parse 	stack 
warning warning skip 	elements reply 
prefix git 	root check 
parse skip prefix 	need read 
option depth 	type could 
skip prefix 	consume process 
option active branches 	typed 
skip prefix 	item avoid 
option export pack 	warning early 
edges starts 	reader erroneous 
starts skip prefix 	state copy 
option date 	provided buffer 
format skip prefix 	destroy 
option marks 	buffer empty 
skip prefix option 	quite large 
marks skip 	buf since 
prefix option export 	free larger 
marks strcmp 	one target 
strcmp strcmp strcmp 	pointer 
strcmp strcmp 	early reader 
strcmp strcmp die 	erroneous state 
parse one 	buffer empty 
feature die 	never reply 
die parse one 	first item 
option die 	process 
git config git 	stack empty 
config git 	process items 
die config git 	reply asap 
config git 	error occurred 
die config git 	discard part 
config git 	buffer 
config strcmp skip 	consumed least 
prefix die 	avoid unnecessary 
parse one option 	calls memmove 
parse one 	sds emit 
feature skip prefix 	reply one 
option cat 	calculate 
blob die usage 	number bytes 
read marks 	needed represent 
git extract argv 	integer helper 
path git 	calculates bulk 
setup gettext 	length given 
strcmp usage setup 	certain 
git directory 	length command 
reset pack idx 	position command 
option git 	current argument 
pack config alloc 	current argument 
objects strbuf 	touched abort 
init xcalloc xcalloc 	target 
xcalloc pool 	build command 
calloc pool alloc 	accordingly protocol 
prepare packed 	curarg put 
git start packfile 	argv overwritten 
die routine 	newarg even 
checkpoint signal read 	touched 
next command 	detect format 
strcmp parse blob 	flags field 
skip prefix 	width precision 
parse skip prefix 	copy list 
parse commit 	consuming arg 
skip prefix 	integer 
parse tag skip 	conversion without 
prefix parse 	modifiers conversion 
reset branch strcmp 	without modifiers 
parse checkpoint 	size gets 
strcmp starts parse 	promoted size 
progress skip 	gets 
prefix parse feature 	promoted size 
skip prefix 	size update 
parse option starts 	current position 
die checkpoint 	note outer 
parse argv feof 	blocks increment 
die end 	twice 
packfile dump branches 	compensate last 
dump tags 	argument needed 
unkeep packs dump 	clear curarg 
marks fclose 	put curargv 
size size pack 	free bytes 
report see 	needed 
documentation git 	hold multi 
fast txt maintained 	bulk count 
documentation format 	build command 
stdin stream stream 	protocol level 
cmd cmd 	need check 
blob commit tag 	cmd 
reset branch 	since last 
checkpoint progress blob 	statement fail 
blob mark 	anyway defensive 
file content file 	possible format 
content data 	command according 
commit commit str 	redis 
mark author 	protocol function 
name email committer 	takes format 
name email 	similar represents 
commit msg commit 	terminated want 
ish merge 	interpolate 
commit ish 	represents binary 
file change commit 	safe need 
msg data 	provide pointer 
quoted path file 	length bytes 
change file 	size examples 
clr file del 	len 
file rnm 	redis format 
file cpy file 	command target 
obm file 	mykey len 
inm file clr 	redis format 
deleteall file 	command target 
del path str 	mykey 
file rnm 	myval myvallen 
path str path 	format command 
str file 	according redis 
cpy path str 	protocol function 
path str 	takes number 
file obm mode 	arguments 
hexsha idnum 	arguments lengths 
path str 	latter strlen 
file inm mode 	used compute 
path str 	argument lengths 
data note obm 	command position 
hexsha idnum 	command 
commit ish note 	calculate number 
inm commit 	bytes needed 
ish data tag 	command build 
tag tag 	command protocol 
str commit ish 	level redis 
tagger name 	err 
email tag msg 	may lack 
tag msg 	description connect 
data reset branch 	redis instance 
reset str 	error field 
commit ish checkpoint 	error returned 
checkpoint progress 	context 
progress note first 	error function 
idnum stream 	reply functions 
subsequent idnums 	given used 
gaps values cause 	read write 
stream parser 	timeout blocking 
reserve space gapped 	socket 
values idnum 	enable connection 
updated future issuing 	keep alive 
mark directive 	use function 
old idnum mark 	handle read 
mark idnum 	descriptor read 
data delimited data 	bytes 
exact data 	socket feed 
note delim may 	reply parser 
must contain 	function called 
data line may 	may use 
contain data 	redis context 
must exactly delim 	read 
delimited data 	reply see 
data delim data 	reply available 
line delim 	early context 
note declen 	seen error 
indicates length binary 	later write 
data bytes 	output 
declen include preceding 	buffer socket 
binary data 	returns redis 
exact data data 	buffer empty 
declen binary 	part buffer 
data note quoted 	succesfully written 
style quoting 	socket 
supporting common escapes 	buffer empty 
nnn nnn 	write operation 
octal note characters 	done given 
must actually 	returns redis 
escaped protect stream 	err error 
formatting otherwise 	occured 
values utf commit 	trying write 
ish str 	sets errstr 
hexsha sha exp 	hold appropriate 
str idnum 	error early 
str sha 	context seen 
exp str sha 	error 
exp tag 	later helper 
str tag path 	function reply 
str path 	reader error 
quoted path mode 	context otherwise 
declen bit 	read pending 
ascii notation bigint 	replies 
integer ascii 	blocking context 
notation binary data 	flush output 
file content 	buffer read 
interpreted raw rfc 	reply write 
raw rfc 	done read 
valid rfc date 	reply 
time ascii 	reply helper 
space character ascii 	function redis 
newline character 	append command 
note colon 	family functions 
must precede numerical 	write formatted 
assigned idnum 	command 
distinguish tag name 	output buffer 
git permit 	family used 
tag idnum bigint 	need call 
path git 	redis reply 
style file path 	retrieve reply 
git name 	replies 
refs heads moz 	pub sub 
gecko experiment 	helper function 
tag git tag 	redis command 
name firefox 	family functions 
sha exp valid 	write formatted 
git sha 	command 
expression hexsha sha 	output buffer 
hexadecimal format 	given context 
note name email 	blocking immediately 
utf however 	read reply 
name must 	reply pointer 
contain email must 	context 
contain following 	non blocking 
name valid git 	reply pointer 
author committer 	used command 
name email valid 	simply appended 
git author 	write buffer 
committer email time 	returns 
since epoch 	reply reply 
seconds ascii notation 	succesfully retrieved 
git style 	returns otherwise 
timezone note comments 	returned blocking 
mark cat 	context error 
blob requests may 	field 
appear anywhere 	context hiredis.h 
input within data 	buf len 
command form 	reply reply 
data command always 	target format 
escapes related 	target format 
input comment 	target 
processing clear starts 	argc argv 
comment must 	argvlen port 
first character line 	port port 
preceded mark 	port source 
mark idnum cat 	addr path 
blob cat 	path 
blob hexsha idnum 	path done 
hexsha idnum 	reply reply 
path str comment 	cmd len 
ascii newline 	format format 
abuse setuid bit 	argc argv 
directories mean 	argvlen 
delta must match 	format format 
avail content 	argc argv 
must match content 	argvlen copyright 
configured limits 	salvatore sanfilippo 
output stats misc 	antirez gmail 
counters memory 	dot 
pools atom 	copyright pieter 
management pack file 	noordhuis pcnoordhuis 
generated table 	gmail dot 
objects written last 	rights reserved 
blob management 	redistribution use 
branch data tag 	source 
data input 	binary forms 
stream parsing signal 	without modification 
handling write 	permitted provided 
output cat blob 	following conditions 
commands windows 	met redistributions 
example round uintmax 	source 
alignment build 	code must 
table packfile core 	retain copyright 
git machinery 	notice list 
print boundary carry 	conditions following 
delta across 	disclaimer redistributions 
packfiles zero 	binary 
nothing determine checkpoint 	form must 
needs current 	reproduce copyright 
pack cannot carry 	notice list 
delta pack 	conditions following 
nothing determine checkpoint 	disclaimer documentation 
zero calls 	materials 
must guarded find 	provided distribution 
find mark 	neither name 
ensure entry passed 	redis names 
written process 	contributors may 
instance unpack entry 	used endorse 
offset avoiding 	promote 
need corresponding idx 	products derived 
file unpacking 	software without 
rule works use 	specific prior 
obj delta 	written permission 
within packfiles created 	software provided 
fast must 	copyright 
usually comes 	holders contributors 
giving unknown sha 	express implied 
find undefined 	warranties including 
mark find mark 	limited implied 
callers must 	warranties merchantability 
test condition use 	fitness 
standard read 	particular purpose 
sha file happens 	disclaimed shall 
pack must 	copyright owner 
max pack usually 	contributors liable 
find mark 	direct indirect 
mark reloaded existing 	incidental 
marks file 	special exemplary 
referencing fast process 	consequential damages 
instance write 	including limited 
packfile callers must 	procurement substitute 
test condition 	goods services 
use read sha 	loss 
file instead 	use data 
stored packfile 	profits business 
writing modified since 	interruption however 
last time 	caused theory 
scanned back read 	liability whether 
previously written 	contract 
old window covered 	strict liability 
pack size 	tort including 
pack size data 	negligence otherwise 
stale valid 	arising way 
closing windows updating 	use software 
packfile length 	even 
ensures read newly 	advised possibility 
written data 	damage size 
offer bytes additional 	list timeval 
end packfile 	error occurs 
core unpacker code 	err flag 
assumes footer 	context 
present file end 	hold type 
must promise 	error occured 
least bytes 	redis err 
within window maps 	means error 
actually create 	use errno 
footer swap need 	variable 
versions sha 	find wrong 
alone avoid modifying 	values errstr 
preimage used 	field hold 
writing parent directory 	description error 
replacing subdir 	read write 
completely different one 	end 
good delta 	file protocol 
besides thrown away 	error memory 
entries needed 	everything connection 
make delta explicitly 	type blocking 
disable deltas 	non blocking 
subtree names file 	least 
subdirectory file 	significant bit 
symlink matching 	flags field 
name parent directory 	redis context 
exists cannot 	connection may 
exist need deleted 	disconnected free 
marks file 	second 
exist zero needswork 	bit flags 
perhaps check 	field context 
reasonable values ensure 	connected api 
space delimiter 	might disconnect 
even name interested 	cleanly flush 
either existing 	output 
note entries entries 	buffer read 
exactly hex 	subsequent replies 
chars path including 	disconnecting flag 
directory separators 	means commands 
directory entries may 	come connection 
contain note 	terminated 
entries hex chars 	replies read 
path also 	flag specific 
path component 	api means 
note entry must 	context clean 
multiple chars 	soon possible 
may note entry 	flag 
subdir containing 	callback executed 
notes note entry 	flag context 
counting mode 	one subscriptions 
rename note entry 	flag monitor 
correct location 	mode active 
rename fullpath realpath 	max 
subdir may 	unused reader 
contain note entries 	buffer seconds 
may reallocated 	reply returned 
current content given 	redis command 
pointer parse 	redis reply 
mark reference idnum 	integer 
bigint first 	type redis 
character endptr complain 	reply integer 
following character 	length used 
expected either 	redis reply 
space end parse 	error redis 
mark reference 	reply 
complain end parse 	number elements 
mark reference 	redis reply 
demanding trailing space 	elements vector 
pointer space 	redis reply 
used data makes 	number elements 
gcc happy 	multibulk 
git track empty 	container index 
non toplevel 	parent holds 
directories accept sha 	user generated 
without checking 	read task 
expected another repository 	parent task 
path subdir 	user 
loading branch traverse 	settable arbitrary 
count real 	field state 
number notes expensive 	protocol parser 
non note 	error flags 
refs means 	error representation 
recently loaded notes 	error 
refs might 	applicable read 
incorrectly num notes 	buffer buffer 
consequently old 	cursor buffer 
fanout might wrong 	length max 
fix traversing 	length unused 
counting number notes 	buffer 
num notes 	index current 
notes truly empty 	read task 
calculation take 	temporary reply 
invoke change note 	pointer api 
fanout counting 	protocol parser 
mode parse notemodify 	backwards 
command dataref 	compatibility removed 
used data makes 	big version 
gcc happy 	bump function 
commit ish nothing 	free reply 
insert ensure 	objects hiredis 
branch active 	returns 
loaded file change 	functions format 
build commit 	command according 
tagger tag payload 	protocol context 
message build 	connection redis 
tag output batch 	error flags 
one cat 	error 
file mark cat 	representation error 
blob cache 	applicable write 
easy pack written 	buffer protocol 
peel one 	reader blocking 
layer mark sha 	context function 
see show 	first 
missing path mode 	checks unconsumed 
type name 	replies returns 
tab path ish 	one otherwise 
path directory 	flushes output 
preparation would 	buffer socket 
sha zero saved 	reads 
save simplicity 	reply non 
read previous mark 	blocking context 
file die 	unconsumed replies 
feature supported die 	write formatted 
feature supported 	command output 
nothing feature ignore 	buffer 
non git 	use functions 
options argv hasn 	blocking mode 
parsed yet 	pipeline commands 
fast exportc first 	write command 
commit done 	output buffer 
postimage report buffer 	use 
postimage initialized 	functions blocking 
path path mode 	mode pipeline 
path mode 	commands issue 
dataref revision author 	command redis 
log timestamp 	blocking context 
note firstnote 	identical 
loglen committish dataref 	calling redis 
gitsvnline revision 	append command 
author log uuid 	followed redis 
url timestamp 	reply function 
local empty revision 	error performing 
rev path 	request 
path line input 	otherwise reply 
header len 	non blocking 
type end len 	context identical 
input old 	calling redis 
data old mode 	append command 
ret preimage 	always 
response data mode 	huge.c ptr 
len input 	node ptr 
response mode dataref 	node ptr 
tab response 	node tsd 
end rev path 	arena size 
mode dataref 	zero 
path mode 	tcache usize 
dataref mode old 	tsd arena 
mode old 	size alignment 
data len input 	zero tcache 
postimage len 	ret usize 
buffer tmpfile init 	node 
buffer fdinit 	zeroed ptr 
die errno buffer 	usize huge 
deinit die 	dalloc junk 
errno putchar putchar 	ptr oldsize 
quote style 	usize min 
putchar fast export 	usize 
modify fast 	max zero 
export truncate quote 	usize usize 
style putchar 	next node 
strlen fwrite fputc 	arena chunk 
snprintf uintmax 	hooks pre 
strlen fwrite quote 	zeroed 
style putchar 	post zeroed 
fflush quote 	sdiff ptr 
style fflush buffer 	oldsize usize 
read line 	node arena 
buffer ferror die 	chunk hooks 
errno die 	cdiff 
buffer ferror die 	pre zeroed 
errno die 	post zeroed 
ends error strstr 	sdiff ptr 
error strtoumax 	oldsize usize 
strlen strlen error 	zero node 
memchr strlen 	arena 
strlen error maximum 	zeroed subchunk 
type error 	zeroed chunk 
error overflows die 	ptr oldsize 
sliding view 	usize min 
init init postimage 	usize max 
buffer tmpfile 	zero 
rewind die 	tsd arena 
fflush response line 	usize alignment 
parse cat 	zero tcache 
response line die 	tsd arena 
check preimage 	ptr oldsize 
overflow strbuf addstr 	usize 
check preimage 	alignment zero 
overflow strlen strlen 	tcache ret 
check preimage 	copysize tsd 
overflow svndiff apply 	ptr tcache 
die overflows 	node arena 
move window die 	ptr 
die buffer 	ptr size 
tmpfile prepare read 	node arena 
die strbuf 	ptr tctx 
release fwrite fputc 	node arena 
die buffer 	ptr tctx 
skip bytes die 	node 
read buffer 	arena ptr 
copy bytes 	chunk lookup 
die read fputc 	extent node 
strlen strlen 	achunk extent 
strlen die die 	node addr 
strlen die 	extent 
strlen memchr die 	node achunk 
strbuf rev 	chunk chunk 
parse response response 	deregister huge 
line active 	palloc unlikely 
commit parse response 	ipallocztm 
response line 	cacheline ceiling 
apply delta buffer 	arena choose 
skip bytes 	unlikely arena 
strlen strlen buffer 	chunk alloc 
copy bytes 	huge idalloctm 
fputc licensed two 	extent 
clause bsd 	node init 
style license see 	huge node 
license details 	arena chunk 
needswork move 	dalloc huge 
fast export init 	idalloctm malloc 
mode must 	mutex 
path old file 	elm tail 
path file 	insert malloc 
read remainder preimage 	mutex unlock 
trailing newline 	unlikely memset 
room newline svn 	unlikely memset 
symlink blobs 	unlikely 
start link missing 	chunk dss 
mode blob 	memset jemalloc 
dataref fast exporth 	huge node 
path path 	extent node 
mode dataref committish 	arena extent 
dataref revision 	node 
author log timestamp 	zeroed unlikely 
note revision 	memset chunk 
author log uuid 	purge wrapper 
url timestamp 	chunk ceiling 
local revision 	malloc mutex 
mode len input 	extent 
data mode 	node size 
old mode old 	extent node 
data len 	size extent 
input rev path 	node zeroed 
mode dataref 	malloc mutex 
path mode dataref 	unlock 
file rev 	arena chunk 
returns errno enoent 	ralloc huge 
fetch-pack.c transfer 	similar unlikely 
unpack limit fetch 	memset unlikely 
unpack limit 	memset huge 
unpack limit prefer 	node 
ofs delta 	extent node 
done fetch fsck 	arena extent 
objects transfer 	node zeroed 
fsck objects 	chunk hooks 
agent supported shallow 	chunk ceiling 
alternate shallow 	chunk 
file marked rev 	ceiling split 
list non 	chunk ceiling 
common revs multi 	chunk ceiling 
ack use 	unlikely huge 
sideband allow unadvertised 	dalloc junk 
request commit 	chunk 
mark refname sha 	purge wrapper 
refname oid 	chunk addr 
flag data refname 	chunk ceiling 
oid flag 	chunk addr 
data commit ancestors 	offset malloc 
dont parse 	mutex 
parents commit mark 	extent node 
parents args 	size extent 
line args buf 	node zeroed 
unused args 	malloc mutex 
count flush 	unlock arena 
limit args result 	chunk 
sha refs 	ralloc huge 
fetching retval sha 	shrink huge 
vain got 	node extent 
got ready req 	node arena 
buf state 	malloc mutex 
len remote remote 	extent 
hex line 	node zeroed 
arg sha ack 	malloc mutex 
commit hex 	unlock arena 
ack complete sha 	chunk ralloc 
commit refname 	huge expand 
oid flag data 	malloc 
args cutoff 	mutex extent 
args refs sought 	node size 
sought newlist 	malloc mutex 
newtail next keep 	unlock unlikely 
cmp sha 	memset chunk 
unused args 	ceiling 
refs sought sought 	memset chunk 
retval cutoff 	ceiling chunk 
commit remote data 	ceiling unlikely 
ret args 	memset chunk 
pack lockfile demux 	ceiling chunk 
keep cmd 	ceiling 
name header pass 	huge ralloc 
header cmd 	move expand 
ret hostname args 	chunk ceiling 
orig sought 	chunk ceiling 
sought pack lockfile 	huge ralloc 
sha agent 	move 
feature agent len 	expand chunk 
setup names 	ceiling chunk 
src dst item 	ceiling chunk 
args sought 	ceiling chunk 
sought status extra 	ceiling huge 
extra args 	ralloc 
conn dest 	move similar 
sought sought shallow 	chunk ceiling 
pack lockfile 	chunk ceiling 
cpy parse commit 	huge ralloc 
prio queue 	move shrink 
put deref tag 	huge 
parse rev 	malloc huge 
list push rev 	palloc huge 
list insert 	ralloc move 
deref tag parse 	huge ralloc 
clear commit 	move helper 
marks rev list 	memcpy 
push parse 	isqalloc huge 
commit mark common 	node extent 
prio queue 	node arena 
parse commit rev 	huge node 
list push 	unset malloc 
mark common packet 	mutex 
read line 	malloc mutex 
starts starts 	unlock huge 
die strcmp skip 	dalloc junk 
prefix sha 	extent node 
hex strstr strstr 	addr extent 
strstr die 	node 
send sideband packet 	size arena 
flush write 	chunk dalloc 
die rev list 	huge extent 
insert die 	node arena 
alternate lookup sha 	extent node 
hex strbuf 	addr 
addstr strbuf addstr 	extent node 
strbuf addstr 	size idalloctm 
strbuf addstr strbuf 	extent node 
addstr strbuf 	arena huge 
addstr strbuf addstr 	node huge 
strbuf addstr 	node 
strbuf addstr 	extent node 
strbuf addf git 	arena malloc 
user agent 	mutex extent 
sanitized packet buf 	node size 
write strbuf 	malloc mutex 
release packet buf 	unlock 
write strbuf 	huge node 
release packet flush 	extent node 
repository shallow 	arena malloc 
write shallow commits 	mutex extent 
packet buf 	node prof 
write packet buf 	tctx 
flush send 	malloc mutex 
request packet read 	unlock huge 
line skip 	node extent 
prefix sha hex 	node arena 
die shallow 	malloc mutex 
skip prefix sha 	extent 
hex die 	node prof 
lookup die 	tctx malloc 
parse die unregister 	mutex unlock 
shallow die 	huge prof 
die send request 	tctx prof 
strbuf setlen 	tctx 
rev packet buf 	size overflow 
write sha 	allocate one 
hex sha hex 	contiguous chunks 
packet buf 	request allocate 
flush send request 	extent node 
strbuf setlen 	track 
next flush consume 	chunk copy 
shallow list 	zero zeroed 
ack sha hex 	pass copy 
lookup commit 	chunk alloc 
die sha hex 	possible make 
sha hex 	correct 
packet buf write 	junk zero 
mark common 	fill decisions 
clear prio 	insert node 
queue packet buf 	huge bother 
write send 	junk filling 
request strbuf release 	chunk 
consume shallow 	isn unmapped 
list ack sha 	increase usize 
hex parse 	incorporate extra 
parse commit list 	nothing fill 
insert mark 	necessary shrinking 
complete oid hex 	update 
pop recent 	size huge 
commit starts check 	allocation update 
refname format 	zeroed fill 
strcmp starts free 	necessary growing 
sha hex 	split excess 
hashcmp copy mark 	chunks 
complete file 	update size 
parse alternate commit 	huge allocation 
list sort 	update zeroed 
date mark 	zap excess 
recent complete commits 	chunks copy 
deref tag 	zero 
lookup rev list 	zeroed chunk 
push mark 	pass copy 
common filter refs 	chunk alloc 
lookup sha 	possible make 
hex sha hex 	correct junk 
sigchain push 	zero 
recv sideband close 	fill decisions 
sigchain pop 	update size 
memset start die 	huge allocation 
read pack 	allocations must 
header die ntohl 	huge avoid 
argv push 	move 
argv push argv 	attempt expand 
push argv 	allocation place 
push argv 	time usize 
push argv push 	min avoid 
gethostname xsnprintf 	moving allocation 
argv pushf getpid 	existing 
argv push 	chunk size 
argv push argv 	accommodates size 
push argv 	attempt shrink 
pushf ntohl ntohl 	allocation place 
argv push 	avoid moving 
start command die 	allocation 
index pack 	usize oldsize 
lockfile close finish 	different enough 
command die 	need use 
finish die strcmp 	different size 
copy list 	fall back 
sort list qsort 	allocating 
repository shallow 	space copying 
server supports die 	huge.h tsd 
server supports 	arena size 
server supports 	zero tcache 
server supports server 	tsd arena 
supports server 	size 
supports server supports 	alignment zero 
server supports 	tcache ptr 
server supports server 	oldsize usize 
supports server 	min usize 
supports server supports 	max zero 
server feature 	tsd 
everything local packet 	arena ptr 
flush find 	oldsize usize 
common warning packet 	alignment zero 
flush setup 	tcache huge 
alternate shallow setup 	dalloc junk 
temporary shallow 	tsd 
pack die git 	ptr tcache 
config git 	ptr ptr 
config git config 	ptr ptr 
git config 	tctx ptr 
git config 	jemalloc types 
git config fetch 	jemalloc 
pack config 	structs jemalloc 
list insert list 	externs jemalloc 
clear unlink 	inlines hyperloglog.c 
warn git path 	magic encoding 
shallow rollback 	notused card 
file commit file 	registers 
sha file 	invalid hll 
sha append setup 	err key 
alternate shallow 	len seed 
commit file sha 	data end 
clear nonexistent 	ele elesize 
shallow sha append 	regp 
assign shallow 	hash bit 
commits refs sha 	index count 
clear sha 	registers ele 
append sha append 	elesize oldcount 
setup alternate 	count index 
shallow commit 	registers 
file sha clear 	ezp reg 
sha clear 	dense hdr 
xcalloc assign shallow 	oldhdr runlen 
commits refs 	regval end 
free sha clear 	ele elesize 
fetch pack 	hdr 
setup duplicates refs 	oldcount count 
packet flush 	sparse end 
die prepare shallow 	prev next 
info fetch 	index first 
pack reprepare packed 	span runlen 
git update 	oplen 
shallow clear shallow 	seq last 
info remember 	len curval 
update flag allocation 	seqlen oldlen 
sending many 	deltalen scanlen 
ack give 	len dense 
traversing history allow 	retval 
specifying sha 	sparse sparselen 
tip allow request 	ezp invalid 
sha reachable 	runlen regval 
possibly hidden function 	registers ezp 
marks rev 	word bytes 
ancestors common cases 	hdr 
desirable mark 	invalid alpha 
ancestors example server 	initialized bias 
yet know 	ele elesize 
common next rev 	hdr max 
send ignoring 	hll hdr 
common send ignore 	val 
ancestors send 	end runlen 
ignore ancestors send 	regval hdr 
also ancestors 	sparselen aux 
sent depth back 	xzero hdr 
duplicate shallow 	hdr retval 
unshallow commands 	hdr 
every time block 	card max 
lines exchanged 	registers invalid 
complete ancestor local 	max hdr 
tell tell 	bitcounters hdr 
ancestors already know 	bytecounters val 
use lookup 	relerr 
interested know reachable 	checkpoint seed 
already scanned 	ele abserr 
make sure parsed 	maxerr cmd 
shallow aren 	hdr val 
stateless rpc need 	end decoded 
retain headers 	runlen 
keep one window 	regval encodingstr 
ahead side 	conv murmur 
wait ack next 	hash hll 
one need 	pat len 
replay next rpc 	hll dense 
request peer 	hll 
knows common 	dense hll 
give error fetch 	dense sdsnewlen 
completely empty 	hll sparse 
repo broken repository 	zero hll 
trash definitely 	sparse zero 
definitely append unmatched 	len 
requests list 	hll sparse 
already may mean 	xzero hll 
sync side 	sparse xzero 
time guess wrong 	len hll 
mark complete 	sparse val 
remote refs common 	len 
refs mark 	hll sparse 
common yet server 	val hll 
told first 	dense sdsfree 
talking upload pack 	sdsfree hll 
subprocess reads 	pat len 
spits band stderr 	sds 
feeds band 	make room 
demux closed 	sdslen hll 
start command cloning 	sparse zero 
unusual common 	hll sparse 
commit already unshallow 	zero len 
remote shallow 	hll 
clone objects repo 	sparse val 
worry accept 	hll sparse 
shallow points exist 	val len 
pack iow 	hll sparse 
repo pack reprepare 	xzero len 
packed git 	hll 
remote also shallow 	sparse xzero 
git shallow 	hll sparse 
may updated refs 	zero hll 
accepted make 	sparse zero 
sure shallow roots 	len hll 
actually reachable 	sparse 
refs remote also 	xzero hll 
shallow check 	sparse xzero 
safe update 	len hll 
without updating git 	sparse val 
shallow copy 	len hll 
refs cmdline growable 	sparse 
list append 	val hll 
refs standard input 	sparse val 
stateless rpc 	hll sparse 
mode use pkt 	val hll 
line read 	sparse xzero 
stdin flush packet 	hll 
read stdin 	sparse zero 
one per line 	hll sparse 
eof heads 	val hll 
pull given consumed 	sparse xzero 
matching remote 	hll sparse 
otherwise git fetch 	zero 
remote would 	hll sparse 
silently succeed 	val hll 
without issuing error 	sparse val 
fetch pack 	hll sparse 
usage sought alloc 	val hll 
name oid 	sparse 
argc argv prefix 	val sdslen 
ret dest 	memmove sds 
sought alloc sought 	incr len 
pack lockfile 	memcpy hll 
pack lockfile ptr 	sparse xzero 
conn args 	hll 
shallow arg line 	sparse zero 
line flags 	hll sparse 
oid hex oidclr 	val hll 
alloc oidcpy 	sparse val 
alloc grow packet 	hll sparse 
trace identity 	val 
memset starts starts 	hll sparse 
strcmp strcmp 	val len 
strcmp strcmp 	hll sparse 
strcmp strcmp strcmp 	val len 
strcmp strcmp 	hll sparse 
strcmp starts strtol 	val 
strcmp strcmp 	memmove sds 
strcmp strcmp strcmp 	incr len 
strcmp usage 	hll invalidate 
usage sought entry 	cache hll 
packet read 	sparse dense 
line sought entry 	hll 
strbuf getline 	dense server 
sought entry strbuf 	hll sparse 
release git 	zero hll 
connect remote heads 	sparse zero 
fetch pack 	len hll 
fflush fflush close 	sparse 
close finish 	xzero hll 
connect error oid 	sparse xzero 
hex remember 	len hll 
update flag 	sparse val 
allocation sending many 	len hll 
ack give 	sparse 
traversing history allow 	val hll 
specifying sha 	dense sum 
tip allow request 	hll sparse 
sha reachable 	sum sdslen 
possibly hidden function 	hll raw 
marks rev 	sum 
ancestors common cases 	server panic 
desirable mark 	log hll 
ancestors example server 	dense hll 
yet know 	sparse hll 
common next rev 	dense 
send ignoring 	hll sparse 
common send ignore 	zero hll 
ancestors send 	sparse zero 
ignore ancestors send 	len hll 
also ancestors 	sparse xzero 
sent depth 	hll 
back duplicate shallow 	sparse xzero 
unshallow commands 	len hll 
every time block 	sparse val 
lines exchanged 	len hll 
complete ancestor local 	sparse val 
tell tell 	sdsnewlen 
ancestors already know 	hll sparse 
use lookup 	xzero server 
interested know reachable 	create memcpy 
already scanned 	check type 
make sure parsed 	len len 
shallow aren 	reply 
stateless rpc need 	sds sdsnew 
retain headers 	lookup key 
keep one window 	write create 
ahead side 	hll hll 
wait ack 	reply unshare 
next one need 	hll 
replay next 	sdslen reply 
rpc request peer 	sds sdsnew 
knows common 	signal modified 
give error fetch 	key notify 
completely empty 	keyspace hll 
repo broken repository 	invalidate 
trash definitely 	cache reply 
definitely append unmatched 	memset lookup 
requests list 	key read 
already may mean 	hll reply 
sync side 	hll merge 
time guess wrong 	reply 
mark complete 	sds sdsnew 
remote refs common 	reply hll 
refs mark 	count lookup 
common yet server 	key write 
told first 	reply hll 
talking upload 	reply 
pack subprocess reads 	unshare hll 
spits band 	valid cache 
stderr feeds band 	hll count 
demux closed 	reply sds 
start command cloning 	sdsnew signal 
unusual common 	modified 
commit already unshallow 	key reply 
remote shallow 	memset lookup 
clone objects repo 	key read 
worry accept 	hll reply 
shallow points exist 	hll merge 
pack iow 	reply 
repo pack reprepare 	sds sdsnew 
packed git 	lookup key 
remote also shallow 	write create 
git shallow 	hll unshare 
may updated refs 	hll sparse 
accepted make 	dense 
sure shallow 	reply sds 
roots actually reachable 	sdsnew hll 
refs remote 	dense hll 
also shallow check 	invalidate cache 
safe update 	signal modified 
without updating git 	key 
shallow copy 	notify keyspace 
refs cmdline growable 	reply sdsnewlen 
list append 	rand hll 
refs standard input 	dense hll 
stateless rpc 	dense reply 
mode use pkt 	error 
line read 	format memset 
stdin flush packet 	create hll 
read stdin 	sqrt rand 
one per line 	rand hll 
eof heads 	dense hll 
pull given consumed 	reply 
matching remote 	error hll 
otherwise git 	count hll 
fetch remote would 	count reply 
silently succeed 	error hll 
without issuing error 	count ceil 
fetch-pack.c transfer 	reply 
unpack limit fetch 	error format 
unpack limit 	reply sdsfree 
unpack limit prefer 	decr count 
ofs delta 	lookup key 
done fetch fsck 	write reply 
objects transfer 	error 
fsck objects agent 	hll reply 
supported shallow 	unshare strcasecmp 
alternate shallow file 	hll sparse 
marked rev 	dense reply 
list non common 	sds sdsnew 
revs multi 	reply 
ack use 	multi bulk 
sideband allow unadvertised 	len hll 
request commit 	dense reply 
mark refname sha 	strcasecmp sdsempty 
refname oid 	reply error 
flag data refname 	hll 
oid flag 	sparse zero 
data commit ancestors 	hll sparse 
dont parse 	zero len 
parents commit mark 	sdscatprintf hll 
parents args 	sparse xzero 
line args buf 	hll 
unused args 	sparse xzero 
count flush limit 	len sdscatprintf 
args result 	hll sparse 
sha refs fetching 	val len 
retval sha 	hll sparse 
vain got got 	val 
ready req 	sdscatprintf sdstrim 
buf state 	reply bulk 
len remote remote 	buffer sdslen 
hex line 	sdsfree strcasecmp 
arg sha ack 	reply status 
commit hex 	strcasecmp 
ack complete sha 	hll sparse 
commit refname 	dense reply 
oid flag data 	sds sdsnew 
args cutoff 	reply reply 
args refs sought 	error format 
sought newlist 	reply 
newtail next keep 	error format 
cmp sha 	hyperloglog redis 
unused args refs 	hyper log 
sought sought 	log probabilistic 
retval cutoff commit 	cardinality approximation 
remote data 	file 
ret args pack 	algorithm exported 
lockfile demux 	redis commands 
keep cmd 	copyright salvatore 
name header pass 	sanfilippo antirez 
header cmd 	gmail dot 
ret hostname args 	rights 
orig sought 	reserved redistribution 
sought pack lockfile 	use source 
sha agent 	binary forms 
feature agent len 	without modification 
setup names 	permitted provided 
src dst item 	following 
args sought 	conditions met 
sought status extra 	redistributions source 
extra args 	code must 
conn dest sought 	retain copyright 
sought shallow 	notice list 
pack lockfile cpy 	conditions 
parse commit 	following disclaimer 
prio queue put 	redistributions binary 
deref tag 	form must 
parse rev 	reproduce copyright 
list push rev 	notice list 
list insert 	conditions 
deref tag parse 	following disclaimer 
clear commit 	documentation materials 
marks rev list 	provided distribution 
push parse 	neither name 
commit mark common 	redis names 
prio queue 	contributors 
parse commit rev 	may used 
list push 	endorse promote 
mark common packet 	products derived 
read line 	software without 
starts starts die 	specific prior 
strcmp skip 	written 
prefix sha hex 	permission software 
strstr strstr 	provided copyright 
strstr die send 	holders contributors 
sideband packet 	express implied 
flush write 	warranties including 
die rev list 	limited 
insert die 	implied warranties 
alternate lookup sha 	merchantability fitness 
hex strbuf 	particular purpose 
addstr strbuf addstr 	disclaimed shall 
strbuf addstr 	copyright owner 
strbuf addstr strbuf 	contributors 
addstr strbuf 	liable direct 
addstr strbuf addstr 	indirect incidental 
strbuf addstr 	special exemplary 
strbuf addstr strbuf 	consequential damages 
addf git 	including limited 
user agent sanitized 	procurement 
packet buf 	substitute goods 
write strbuf release 	services loss 
packet buf 	use data 
write strbuf 	profits business 
release packet flush 	interruption however 
repository shallow 	caused 
write shallow commits 	theory liability 
packet buf 	whether contract 
write packet buf 	strict liability 
flush send 	tort including 
request packet read 	negligence otherwise 
line skip 	arising 
prefix sha hex 	way use 
die shallow 	software even 
skip prefix sha 	advised possibility 
hex die 	damage redis 
lookup die parse 	hyper log 
die unregister 	log 
shallow die die 	implementation following 
send request 	ideas use 
strbuf setlen rev 	bit hash 
packet buf 	function proposed 
write sha 	order limited 
hex sha hex 	cardinalities 
packet buf 	cost additional 
flush send request 	bit per 
strbuf setlen 	use bit 
next flush consume 	registers great 
shallow list 	level accuracy 
ack sha hex 	total 
lookup commit 	per key 
die sha hex 	use redis 
sha hex 	data type 
packet buf write 	type introduced 
mark common 	attempt made 
clear prio queue 	compress 
packet buf 	data structure 
write send request 	also algorithm 
strbuf release 	used original 
consume shallow list 	hyper log 
ack sha 	log algorithm 
hex parse 	difference 
parse commit list 	bit hash 
insert mark 	function used 
complete oid hex 	correction performed 
pop recent 	values near 
commit starts check 	heule nunkesser 
refname format 	hall 
strcmp starts free 	hyper log 
sha hex 	log practice 
hashcmp copy mark 	algorithmic engineering 
complete file 	state art 
parse alternate commit 	cardinality estimation 
list sort 	algorithm 
date mark recent 	flajolet ric 
complete commits 	fusy gandouet 
deref tag lookup 	meunier hyperloglog 
rev list 	analysis near 
push mark common 	optimal cardinality 
filter refs 	estimation 
lookup sha 	algorithm redis 
hex sha hex 	uses two 
sigchain push 	representations dense 
recv sideband close 	representation every 
sigchain pop 	entry represented 
memset start die 	bit 
read pack 	integer sparse 
header die ntohl 	representation run 
argv push 	length compression 
argv push argv 	suitable representing 
push argv 	hyper log 
push argv push 	logs 
argv push 	many registers 
gethostname xsnprintf argv 	memory efficient 
pushf getpid 	way hll 
argv push argv 	header dense 
push argv 	sparse representation 
push argv 	header 
pushf ntohl ntohl 	follows hyll 
argv push 	cardin first 
start command die 	bytes magic 
index pack 	bytes hyll 
lockfile close finish 	one encoding 
command die 	currently 
finish die strcmp 	hll dense 
copy list 	hll sparse 
sort list qsort 	three used 
repository shallow 	bytes cardin 
server supports die 	field bit 
server supports 	integer 
server supports server 	stored little 
supports server 	endian format 
supports server supports 	latest cardinality 
server supports 	computed reused 
server supports server 	data structure 
supports server 	modified 
supports server 	since last 
supports server supports 	computation useful 
server feature 	high probabilities 
everything local packet 	hlladd operations 
flush find 	modify actual 
common warning packet 	data 
flush setup 	structure hence 
alternate shallow setup 	approximated cardinality 
temporary shallow 	significant bit 
pack die git 	significant cached 
config git 	cardinality means 
config git config 	data 
git config 	structure modified 
git config git 	reuse cached 
config fetch 	must recomputed 
pack config list 	dense representation 
insert list 	dense representation 
clear unlink warn 	used 
git path 	redis following 
shallow rollback 	bits counters 
file commit file 	encoded one 
sha file 	starting lsb 
sha append setup 	msb next 
alternate shallow 	bytes 
commit file sha 	needed sparse 
clear nonexistent 	representation sparse 
shallow sha append 	representation encodes 
assign shallow 	registers run 
commits refs sha 	length encoding 
clear sha 	composed 
append sha append 	three opcodes 
setup alternate 	two one 
shallow commit file 	one two 
sha clear 	bytes opcodes 
sha clear xcalloc 	called zero 
assign shallow 	xzero 
commits refs free 	val zero 
sha clear 	opcode represented 
fetch pack 	xxxxxx bit 
setup duplicates refs 	integer represented 
packet flush 	six bits 
die prepare shallow 	xxxxxx 
info fetch 	plus means 
pack reprepare packed 	registers opcode 
git update 	represent contiguous 
shallow clear shallow 	registers xzero 
info remember 	opcode represented 
update flag allocation 	two 
sending many 	bytes xxxxxx 
ack give traversing 	yyyyyyyy bit 
history allow 	integer represented 
specifying sha tip 	bits xxxxxx 
allow request 	significant bits 
sha reachable possibly 	yyyyyyyy 
hidden function 	least significant 
marks rev 	bits plus 
ancestors common cases 	means registers 
desirable mark 	opcode represent 
ancestors example server 	contiguous registers 
yet know 	val 
common next rev 	opcode represented 
send ignoring 	vvvvvxx contains 
common send ignore 	bit integer 
ancestors send 	representing bit 
ignore ancestors send 	integer representing 
also ancestors 	number 
sent depth back 	contiguous registers 
duplicate shallow 	vvvvv obtain 
unshallow commands every 	run length 
time block 	integers vvvvv 
lines exchanged complete 	must incremented 
ancestor local 	one 
tell tell ancestors 	opcode represent 
already know 	values repeated 
use lookup 	times sparse 
interested know reachable 	representation represent 
already scanned 	registers greater 
make sure parsed 	however 
shallow aren 	unlikely find 
stateless rpc need 	hll cardinality 
retain headers 	sparse representation 
keep one window 	still memory 
ahead side 	efficient dense 
wait ack next 	representation 
one need 	happens hll 
replay next rpc 	converted dense 
request peer 	representation sparse 
knows common give 	representation purely 
error fetch 	positional example 
completely empty repo 	sparse 
broken repository 	representation empty 
trash definitely definitely 	hll xzero 
append unmatched 	hll non 
requests list 	zero registers 
already may mean 	position respectively 
sync side 	represented 
time guess wrong 	following three 
mark complete 	opcodes xzero 
remote refs common 	registers val 
refs mark 	zero registers 
common yet server 	val registers 
told first 	registers 
talking upload pack 	xzero registers 
subprocess reads 	example sparse 
spits band stderr 	representation used 
feeds band 	bytes instead 
demux closed start 	order represent 
command cloning 	hll 
unusual common commit 	registers general 
already unshallow 	low cardinality 
remote shallow clone 	big win 
objects repo 	terms space 
worry accept 	efficiency traded 
shallow points exist 	cpu 
pack iow 	time since 
repo pack reprepare 	sparse representation 
packed git 	slower access 
remote also shallow 	following table 
git shallow 	shows average 
may updated refs 	cardinality 
accepted make 	bytes used 
sure shallow roots 	samples per 
actually reachable 	cardinality representable 
refs remote also 	registers big 
shallow check 	dense representation 
safe update without 	size 
updating git 	used sample 
shallow copy refs 	dense representation 
cmdline growable 	uses bytes 
list append refs 	big win 
standard input 	cardinality bigger 
stateless rpc 	cardinalities 
mode use pkt 	constant times 
line read 	involved updating 
stdin flush packet 	sparse representation 
read stdin 	justified memory 
one per line 	savings exact 
eof heads 	maximum 
pull given consumed 	length sparse 
matching remote 	representation implementation 
otherwise git fetch 	switches dense 
remote would 	representation configured 
silently succeed without 	via define 
issuing error 	server 
fetch pack usage 	hll sparse 
sought alloc 	max bytes 
name oid argc 	hyll hll 
argv prefix 	dense hll 
ret dest 	sparse reserved 
sought alloc sought 	future 
pack lockfile 	use must 
pack lockfile ptr 	zero cached 
conn args 	cardinality little 
shallow arg line 	endian data 
line flags 	bytes 
oid hex oidclr 	cached cardinality 
alloc oidcpy 	msb used 
alloc grow packet 	signal validity 
trace identity 	cached greater 
memset starts starts 	smaller error 
strcmp strcmp 	registers 
strcmp strcmp strcmp 	mask index 
strcmp strcmp 	enough count 
strcmp strcmp strcmp 	leading zeroes 
starts strtol 	dense encoding 
strcmp strcmp strcmp 	sparse encoding 
strcmp strcmp 	used 
strcmp usage 	internally never 
usage sought entry 	exposed low 
packet read 	level bit 
line sought entry 	macros macros 
strbuf getline 	access dense 
sought entry strbuf 	representation 
release git 	need bit 
connect remote heads 	counters bit 
fetch pack 	bytes use 
fflush fflush close 	macros make 
close finish 	sure code 
connect error oid 	inlined 
hex remember 	since speed 
update flag allocation 	critical especially 
sending many 	order compute 
ack give traversing 	approximated cardinality 
history allow 	hllcount need 
specifying sha tip 	access 
allow request 	registers reason 
sha reachable 	also want 
possibly hidden function 	avoid conditionals 
marks rev 	code path 
ancestors common cases 	note representation 
desirable mark 	significant 
ancestors example server 	bit msb 
yet know 	every left 
common next rev 	start bits 
send ignoring 	lsb msb 
common send ignore 	forth passing 
ancestors send 	next 
ignore ancestors send 	example want 
also ancestors 	access counter 
sent depth back 	pos illustration 
duplicate shallow 	index first 
unshallow commands every 	containing data 
time block 	pos 
lines exchanged complete 	position first 
ancestor local 	bit counting 
tell tell 	lsb given 
ancestors already know 	pos right 
use lookup 	shift bits 
interested know reachable 	initial 
already scanned 	right shift 
make sure parsed 	pos left 
shallow aren 	shift bits 
stateless rpc need 	bits bits 
retain headers 	initial left 
keep one window 	shift 
ahead side 	bits two 
wait ack next 	bits clean 
one need 	higher order 
replay next rpc 	bits interested 
request peer 	right shifted 
knows common give 	left 
error fetch 	shifted different 
completely empty 	example like 
repo broken repository 	pos bit 
trash definitely 	counter actually 
definitely append unmatched 	contained single 
requests list 	pos 
already may mean 	pos right 
sync side 	shift bits 
time guess wrong 	shift practice 
mark complete 	left shift 
remote refs common 	next bits 
refs mark 	even 
common yet server 	use effect 
told first 	clearing bits 
talking upload pack 	result affacted 
subprocess reads 	setting bit 
spits band stderr 	complex val 
feeds band 	want 
demux closed start 	already right 
command cloning 	range need 
unusual common 	two steps 
commit already unshallow 	one need 
remote shallow 	clear bits 
clone objects repo 	need 
worry accept 	bitwise bits 
shallow points exist 	pos first 
pack iow 	create mask 
repo pack reprepare 	clear bits 
packed git 	position initialize 
remote also shallow 	mask 
git shallow 	left shift 
may updated refs 	bits invert 
accepted make 	result mask 
sure shallow roots 	starts mask 
actually reachable 	left shift 
refs remote also 	bits 
shallow check 	mask invert 
safe update without 	bitwise mask 
updating git 	bitwise val 
shallow copy 	left shifted 
refs cmdline growable 	bits bits 
list append 	focus 
refs standard input 	next initial 
stateless rpc 	build mask 
mode use pkt 	start right 
line read 	shift bits 
stdin flush packet 	invert mask 
read stdin 	mask 
one per line 	right shift 
eof heads 	bits mask 
pull given consumed 	bitwise mask 
matching remote 	clear old 
otherwise git fetch 	bits bitwise 
remote would 	val 
silently succeed without 	left shifted 
issuing error 	bits note 
fetch-pack.h uploadpack unpacklimit 	access last 
depth args 	counter also 
conn dest 	access sds 
sought sought shallow 	always 
pack lockfile 	term exists 
sought represents remote 	skip conditional 
references updated 	need allocate 
names found remote 	explicitly store 
marked fetch.c 	position regnum 
builtin fetch usage 	variable 
fetch prune 	target bytes 
config prune append 	position regnum 
dry run 	val bytes 
force keep multiple 	macros access 
update head 	sparse representation 
verbosity recurse submodules 	macros 
unshallow update 	parameter expected 
shallow max children 	pointer xxxxxx 
depth upload 	vvvvvxx xxxxxx 
pack rla 	hyper log 
gtransport gsecondary submodule 	log algorithm 
prefix recurse 	hash 
submodules shown url 	function murmur 
refmap alloc 	hash bit 
refmap refmap opt 	version modified 
arg unset 	redis order 
opt arg unset 	provide result 
builtin fetch 	big 
options signo head 	little endian 
remote refs 	archs endian 
branch tail old 	neutral given 
tail refspec 	element hyper 
refname oid flag 	log log 
cbdata list 	returns 
item old oid 	length pattern 
head sha 	element hash 
transport head tail 	side effect 
existing refs 	regp index 
remote refs 	element hashes 
item transport refspecs 	count 
refspec count 	number zeroes 
tags autotags map 	starting bit 
tail oref 	hll registers 
tail remote refs 	power two 
fetch refspec 	corresponding first 
fetch refspec remote 	bit 
branch merge 	use index 
action check old 	max run 
msg rla 	bits note 
transaction err ret 	ending sequence 
conflict remote 	zeroes must 
remote display updated 	included 
current branch 	count find 
pretty msg name 	count smallest 
quickref quickref 	count possible 
data sha raw 	zeroes bit 
url remote 	first position 
name map 	count 
commit url len 	may sound 
note kind 	like inefficient 
url filename want 	actually average 
status merge 	high probabilities 
status marker map 	find iterations 
transport map 	index 
ret refs count 	make sure 
map raw 	loop terminates 
url url len 	first bit 
result stale 	used address 
refs url dangling 	initialized since 
msg refnames 	count 
map current branch 	pattern dense 
filename transport 	representation implementation 
name remote transport 	element dense 
transport map 	hyperloglog data 
transport refs count 	structure actually 
existing refs 	nothing 
map autotags 	added max 
retcode peer item 	pattern counter 
old oid 	subset element 
tail remote priv 	belongs incremented 
list name 	needed registers 
list key priv 	expected 
wordlen name 	room hll 
list prev remote 	registers plus 
argv list 	additional right 
result argv errcode 	requirement met 
name remote 	sds automatically 
argc argv refs 	since 
refspec exit 	implicitly terminated 
code argc argv 	function always 
prefix list 	succeed however 
remote result argv 	result operation 
arg options 	approximated cardinality 
parse fetch recurse 	changed 
submodules arg 	returned otherwise 
strcmp git 	returned update 
config git config 	element produced 
alloc grow 	longer run 
transport unlock pack 	zeroes compute 
transport unlock 	sum 
pack unlock pack 	reg dense 
sigchain pop 	representation pre 
branch merge matches 	computer table 
memset fetch 	values reg 
map list insert 	indexed reg 
xmalloc oidcpy 	side 
hashcmp transport remote 	effect integer 
refs starts 	pointed ezp 
ends file fetch 	number zero 
sha file 	registers redis 
fetch sha file 	use registers 
fetch list 	bits 
list list 	code works 
insert list clear 	values modifying 
sha file 	defines target 
fetch alloc alloc 	take faster 
oidcpy list 	path unrolled 
clear transport remote 	loops 
refs fetch 	handle registers 
map parse fetch 	per iteration 
refspec fetch 	additional parens 
map fetch map 	allow compiler 
die branch 	optimize code 
branch merge config 	loss 
strcmp fetch 	precision relevant 
map strcmp merge 	floating point 
config remote 	math commutative 
die fetch map 	increment end 
find non 	loop precomputed 
local tags duplicates 	reg 
getenv snprintf 	times sparse 
transaction begin 	representation implementation 
transaction update transaction 	convert hll 
commit transaction 	sparse representation 
free strbuf release 	given input 
transaction free 	dense 
error strbuf release 	representation representations 
branch prettify 	represented sds 
refname sha info 	input representation 
die oid 	freed side 
hex oidcmp strbuf 	effect function 
addf transport 	returns 
summary strcmp bare 	sparse representation 
repository oid 	valid otherwise 
strbuf addf transport 	err returned 
summary oid 	representation corrupted 
starts update strbuf 	representation already 
addf transport 	right 
summary lookup commit 	one asap 
reference gently 	create right 
lookup commit 	size filled 
reference gently starts 	zero bytes 
starts check 	note cached 
submodule commits update 	cardinality 
strbuf addf 	side effect 
transport summary merge 	exactly cardinality 
bases strbuf 	empty hll 
unique abbrev strbuf 	copy magic 
addstr strbuf 	cached cardinality 
unique abbrev check 	read 
submodule commits 	sparse representation 
update strbuf addf 	non zero 
strbuf release 	registers accordingly 
strbuf unique abbrev 	sparse representation 
strbuf addstr 	valid expect 
strbuf unique abbrev 	find 
check submodule 	idx hll 
commits update strbuf 	registers free 
addf strbuf 	old representation 
release strbuf 	one element 
addf transport summary 	sparse hyperloglog 
hashcpy git 	data 
path fetch head 	structure actually 
fopen error 	nothing added 
strerror transport anonymize 	max pattern 
url xstrdup 	counter subset 
check everything connected 	element belongs 
error warning 	incremented 
lookup commit reference 	needed holding 
gently alloc 	hll function 
oidcpy oidcpy strcmp 	requires reference 
starts starts 	order able 
starts strlen strncmp 	enlarge needed 
strbuf reset 	success 
strbuf addf strbuf 	function returns 
addf oid 	cardinality changed 
hex fputs 	element updated 
fputc fputc strbuf 	error representation 
reset update 	invalid returned 
local free strbuf 	side 
addf error 	effect function 
strbuf release free 	may promote 
fclose check 	hll representation 
everything connected quickfetch 	sparse dense 
transport fetch 	happens requires 
refs store updated 	representable 
refs transport 	sparse representation 
unlock pack stale 	resulting size 
heads transport 	would greater 
anonymize url xstrdup 	server hll 
strlen strncmp 	sparse max 
list append refs 	bytes 
list clear 	update element 
transport summary prettify 	produced longer 
refname warn 	run zeroes 
dangling symref 	count big 
free free refs 	representable sparse 
branch bare 	representation 
repository strcmp die 	dense representation 
git path 	updating sparse 
fetch head fopen 	representation sometimes 
writing error 	may need 
strerror fclose transport 	enlarge buffer 
option die 	bytes 
warning transport transport 	worst xzero 
verbosity option 	split xzero 
option option option 	val xzero 
prepare transport 	make sure 
transport option transport 	enough space 
option fetch 	right 
refs transport disconnect 	pointers take 
die truncate 	execution function 
fetch head map 	valid time 
check current 	step need 
branch list 	locate opcode 
lookup oidcpy transport 	need 
option prune 	modify check 
refs prune refs 	update actually 
fetch refs 	needed points 
free refs free 	previos opcode 
refs find 	end loop 
non local tags 	points 
backfill tags 	next opcode 
free refs list 	end loop 
clear list 	span number 
append skip prefix 	registers covered 
strcmp strcspn 	opcode performance 
list append xstrndup 	critical 
git config 	loop sparse 
remote remote configured 	representation sorting 
list append 	conditionals least 
argv push argv 	frequent opcode 
push argv 	many bytes 
push argv 	sparse 
push argv push 	faster xzero 
argv push 	opcode covers 
argv push argv 	index invalid 
push argv 	format cache 
push argv push 	current opcode 
argv push 	type 
argv push truncate 	avoid macro 
fetch head 	something change 
argv pushl options 	also cache 
argv argv 	run length 
push run command 	opcode step 
opt error 	loop 
argv pop argv 	first stores 
clear die 	index first 
prepare transport xcalloc 	covered current 
strcmp die 	opcode pointed 
xstrfmt sigchain 	next prev 
push common atexit 	store 
parse fetch 	respectively next 
refspec fetch free 	previous opcode 
refspec transport 	opcode respectively 
disconnect packet trace 	last first 
identity strbuf 	span number 
addstr strbuf addf 	registers 
git config 	covered current 
parse options die 	opcode different 
repository shallow 	cases order 
die xstrfmt atoi 	update data 
die parse 	structure place 
fetch recurse submodules 	without 
arg config 	generating scratch 
fetch recurse submodules 	val opcode 
gitmodules config 	already count 
git config die 	update needed 
die remote 	regardless val 
fetch multiple 	run 
remote fetch one 	length field 
remote die 	pfadd returns 
fetch multiple remote 	since changes 
die fetch 	performed val 
multiple remote fetch 	opcode len 
one options 	representing 
argv fetch populated 	less count 
submodules argv 	update since 
clear list clear 	trivial another 
close packs 	trivial handle 
argv pushl argv 	zero opcode 
push run 	len 
command opt argv 	replace val 
clear git 	opcode len 
fetch unspecified unspecified 	general cases 
prune git 	complex requires 
fetch refmap origin 	updated either 
foo used 	currently 
tell command 	represented val 
store anywhere fetched 	opcode len 
remote tracking 	zero opcode 
branch need fetch 	len xzero 
anyway allow 	opcode cases 
branch branch name 	original 
merge honored 	opcode must 
git pull fail 	split muliple 
branch name 	opcodes worst 
merge misconfigured point 	xzero split 
nonexisting branch 	middle 
indeed called git 	resuling xzero 
pull notice 	val xzero 
misconfiguration entry resulting 	resulting sequence 
fetch head 	max length 
marked merging peeled 	bytes perform 
always follows 	split 
matching see peeled 	writing sequence 
want fetch 	buffer newlen 
mark entry 	length later 
list one ignore 	sequence inserted 
setting item 	place old 
non previously saw 	one 
followed peeled 	possibly moving 
reference need check 	right bytes 
lightweight tag 	sequence longer 
want fetch skip 	older one 
duplicates refs 	last covered 
already may lightweight 	sequence 
tag needs 	handle splitting 
see needs fetching 	zero xzero 
tags remote 	handle splitting 
refs list list 	val step 
refs fetched 	substitute sequence 
unless already decided 	old 
ignore item 	one note 
opportunistically updated references 	already allocated 
merge everything 	space sds 
command line 	calling sds 
tags refs happen 	make room 
fetching via 	step 
command line arguments 	merge adjacent 
destination might 	values possible 
missing different remote 	representation updated 
tracking would 	however resulting 
derived configured refspec 	representation may 
cases want 	optimal 
take opportunity update 	adjacent val 
configured remote 	opcodes sometimes 
tracking reference however 	merged single 
want mention 	one scan 
entries fetch head 	upcodes starting 
would simply 	prev 
duplicates existing entries 	need two 
fetch head 	adjacent val 
ignore compute 	opcodes merge 
entries refspecs specified 	len fits 
command line 	val opcode 
list following refspecs 	max 
resulting tags 	len merge 
option one latter 	reiterate without 
fetch head 	incrementing order 
merge removed duplicates 	merge merged 
favor one 	right invalidate 
opportunistic entries fetch 	cached 
head ignore 	cardinality promote 
use defaults note 	dense representation 
merge implies 	corrupted hll 
non branch remote 	need call 
name remote 	hll dense 
fetching given branch 	perform 
name remote 	operation conversion 
given branch name 	however result 
merge note 	must since 
merge implies 	need convert 
non branch remote 	sparse dense 
name also 	requires 
fetch tags append 	updated note 
refs updated 	turn means 
opportunistically head okay 	pfadd make 
update head 	sure command 
old head isn 	propagated slaves 
empty nicely 	aof 
describe fetching remote 	sparse dense 
name likely 	convertion performed 
follow standard layout 	slaves well 
end list 	compute sum 
pass fetch head 	reg sparse 
status type 	representation 
order merged entries 	pre computer 
written merge 	table values 
lets readers use 	reg indexed 
fetch head 	reg side 
refname refer 	effect integer 
merged fall write 	pointed 
anything fetch 	ezp number 
head would want 	zero registers 
bypass transfer 	increment end 
altogether everything going 	loop increment 
fetch already 	end loop 
exists connected locally 	times 
deepening shallow 	hyper log 
clone already objects 	log count 
reachable running 	core algorithm 
rev list good 	approximated count 
exit status 	computed function 
bypass fetch really 	uses 
need perform 	lower level 
claiming failure ensure 	hll dense 
perform network 	sum hll 
exchange deepen history 	sparse sum 
appending truncate 	functions helpers 
fetch head 	compute 
prune refspecs specified 	sum reg 
explicitly via 	part computation 
command line configuration 	representation specific 
care whether 	rest common 
tags specified neither 	sum operation 
tags tags 	data 
specified automated tag 	type used 
following split 	internally speedup 
list white space 	pfcount multiple 
command line 	keys reg 
request record command 	times every 
line reflog 	zero 
need strict transport 	hll approximated 
option validate 	cardinality harmonic 
arguments use remote 	mean registers 
arguments assumed 	values hdr 
remotes groups 	points start 
single remote one 	sds 
remote zero 	representing holding 
one remotes names 	hll representation 
strdup strndup 	sparse representation 
files-backend.c name orig 	hll valid 
name old 	integer pointed 
oid oid peeled 	invalid 
alloc sorted 	non zero 
cache entries flag 	otherwise left 
subdir name 	untouched hll 
dirname dir dir 	count supports 
refname len 	special encoding 
cache dirname len 	hll 
incomplete dir 	raw hdr 
entry entry dir 	registers point 
pos child 	hll registers 
entry refname sha 	element useful 
flag check 	order speedup 
name dir 	pfcount 
entry dir entry 	called multiple 
dir cache 	keys need 
dirname len incomplete 	work bit 
direntry one 	integers encoding 
two dir len 	number registers 
str key 	equal 
ent key ent 	precompute reg 
cmp dir 	small table 
refname len key 	order speedup 
dir subdirname 	computation sum 
len mkdir entry 	reg reg 
index entry 	reg 
dir refname mkdir 	compute sum 
slash dirnamelen 	muliply inverse 
subdir dir refname 	alpha raw 
entry index 	estimate use 
entry dir refname 	linearcounting algorithm 
refname len 	small 
entry index 	cardinalities larger 
entry dir dirname 	values hyper 
dir dir 	log log 
last entry entry 	raw approximation 
current trim 	used since 
flags data entry 	linear 
data data 	counting error 
old current retval 	starts increase 
dir offset 	however hyper 
data entry retval 	log log 
subdir dir 	shows strong 
dir data retval 	bias 
cmp subdir 	range compensate 
subdir subdir dir 	linearcounting polynomial 
entry skip 	regression bias 
conflicting refname entry 	range way 
vdata data 	compute bias 
refname extras skip 	given 
dir err 	cardinality correct 
slash extra 	according apply 
refname pos dirname 	correction use 
ret data 	correction verified 
root referrers validity 	apply correction 
next loose 	since 
packed name packlock 	use bit 
packed refs 	function bit 
packed refs refs 	counters apply 
packed refs 	correction needed 
refs submodule refs 	since would 
submodule refs 	require 
submodule refs packed 	huge approach 
refs header 	call hll 
line sha dir 	dense hll 
last line 	sparse according 
sha refname traits 	hll encoding 
flag refs 	invalid 
packed refs 	representation merge 
file packed cache 	computing max 
refs refname 	registers hll 
sha packed cache 	hyper log 
dirname dir 	log hll 
refs dirnamelen refname 	hll 
path path 	registers registers 
baselen sha flag 	pointed max 
read refs 	hll must 
refs refname sha 	already validated 
dir refs 	via hll 
refname sha recursion 	reply 
len buffer 	way hyper 
path path refname 	log log 
sha retval 	sparse found 
submodule refs refname 	invalid err 
refname resolve 	returned otherwise 
flags sha flags 	function 
entry refname 	always succeeds 
resolve flags 	hyper log 
sha flags refname 	log commands 
path contents 	create hll 
depth bad name 	always create 
path buf 	hll 
save errno refname 	sparse encoding 
resolve flags 	upgraded dense 
sha flags refname 	representation needed 
contents path 	populate sparse 
ret flag refs 	representation many 
data packed 	xzero 
cache loose dir 	opcodes needed 
packed dir 	represent registers 
retval refs trim 	create actual 
flags data 	check valid 
data submodule data 	hll representation 
oid flag 	otherwise 
data submodule data 	reply client 
data submodule 	error err 
data prefix 	key exists 
data prefix data 	check type 
broken flag 	error already 
submodule prefix data 	sent 
data data 	magic hyll 
buf ret data 	dense representation 
old sha 	length match 
mustexist err save 	exactly tests 
errno path 	passed pfadd 
refname old sha 	ele 
extras skip 	ele ele 
flags type err 	ele create 
file orig 	key exact 
file orig refname 	length hold 
last errno 	hll data 
type lflags mustexist 	structure 
resolve flags 	sdsnewlen passed 
attempts remaining refname 	guaranteed bytes 
sha peeled 	initialized zero 
entry data 	perform low 
flags timeout configured 	level operation 
timeout packed 	every 
cache packed cache 	element pfcount 
error save 	approximated cardinality 
errno packed cache 	multi key 
next sha 	keys cardinality 
name flags packed 	multiple keys 
refs prune 	specified 
entry data packed 	pfcount actually 
entry tag 	computes cardinality 
name transaction err 	merge specified 
flags cbdata 	compute hll 
refnames err packed 	max special 
refname ret 	encoding 
removed flag err 	check type 
loose filename 	size empty 
res refnames err 	hll non 
result refname 	existing merge 
newrefname attempts 	hll max 
remaining path ret 	hhl 
newname extras 	setting max 
skip err packed 	max max 
refs loose 	hll compute 
refs sha err 	cardinality resulting 
sha logmsg 	cardinality single 
flags err oldrefname 	hll 
newrefname logmsg 	user specified 
sha orig sha 	single key 
logmoved loginfo 	either cached 
log symref err 	compute one 
path result 	update cache 
refname logfile err 	key 
force create 	cardinality zero 
logfd oflags refname 	since element 
force create 	added otherwise 
err ret 	would key 
old sha sha 	hlladd creates 
committer msg 	side 
msglen written maxlen 	effect check 
len logrec 	cached cardinality 
refname old sha 	valid cached 
sha msg 	recompute update 
logfile flags err 	cached considered 
logfd result 	read 
oflags refname old 	command even 
sha sha 	data structure 
msg flags err 	modified since 
refname old 	cached may 
sha sha msg 	modified given 
flags err 	hll 
ret sha err 	redis need 
term sha 	propagate change 
logmsg flags err 	pfmerge dest 
old msg 	src src 
head sha 	src src 
head flag head 	compute 
log err 	hll max 
target ret path 	maximum max 
refname target 	registers write 
logmsg err sha 	target variable 
refname target 	later check 
logmsg refname target 	type 
logmsg err 	size empty 
ret refname refname 	hll non 
data osha 	existing merge 
nsha email end 	hll max 
message timestamp 	hhl setting 
bob scan refname 	max 
data logfp 	max max 
pos tail cnt 	hll create 
nread buf 	unshare destination 
endp scanp refname 	key needed 
data logfp 	create key 
ret name 	exact 
data retval oldlen 	length hold 
oid data 	hll data 
retval name refnames 	structure sdsnewlen 
err transaction 	passed guaranteed 
err updates refs 	bytes initialized 
affected refnames 	zero 
update reason overwriting 	key exists 
symref write 	sure right 
err update update 	type size 
refname oid 	since merging 
flags data affected 	different check 
refnames transaction 	support 
err updates affected 	dense objects 
refnames update 	destination write 
update flags prune 	resulting hll 
policy newlog 	destination hll 
last kept sha 	registers invalidate 
osha nsha 	cached 
email timestamp 	generate pfadd 
message data policy 	pfmerge semantical 
refname sha 	simplicity since 
flags prepare prune 	theory mass 
cleanup policy 	elements testing 
data reflog log 	debugging 
file status 	pfselftest command 
type err err 	performs self 
update read 	test hll 
loose refs strcmp 	registers implementation 
search dir 	something easy 
create dir entry 	test 
entry dir 	within outside 
read loose refs 	test access 
check refname 	registers test 
format die flex 	conceived test 
alloc str 	different counters 
hashcpy oidclr 	data 
clear dir free 	structure accessible 
alloc grow 	setting values 
strcmp free entry 	result correct 
free flex 	retained affect 
alloc mem strcmp 	adjacent values 
strncmp sort 	hll 
dir bsearch search 	counters byes 
dir create 	size random 
dir entry entry 	values check 
dir dir 	able retrieve 
strchr strchr search 	values test 
subdir find 	approximation 
containing dir search 	error test 
dir strlen 	adds unique 
strlen xmemdupz find 	elements check 
containing dir 	estimated always 
free find containing 	reasonable bounds 
dir search 	check 
dir memmove 	error smaller 
free entry find 	times expected 
containing dir 	standard error 
entry dir strcmp 	make unlikely 
die oidcmp 	test fail 
die warning qsort 	bad 
dup free 	run test 
entry sha file 	performed dense 
error starts 	sparse time 
resolves dir sort 	also verifying 
dir entry 	computed cardinality 
dir entry dir 	make 
entry dir 	sure small 
strcmp dir dir 	cardinalities use 
sort dir 	sparse encoding 
sort dir entry 	check dense 
dirs die 	sparse representations 
dir sort dir 	agree 
entry dir 	check error 
prime dir 	adjust max 
dir list strbuf 	error expect 
grow strlen 	cardinality since 
strchr strchr strbuf 	time time 
search dir 	statistically 
list strbuf addf 	likely much 
list list 	higher error 
strbuf addf strbuf 	due collision 
addch search 	resulting positive 
dir dir strbuf 	success pfdebug 
addstr strbuf 	subcommand 
addch search dir 	key args 
dir sort 	different debugging 
dir entry dir 	related operations 
strbuf addf 	hll implementation 
find descendant strbuf 	pfdebug getreg 
addf strbuf 	key 
release free entry 	force propagation 
stat validity 	encoding change 
clear free 	pfdebug decode 
die release packed 	key pfdebug 
cache free 	encoding key 
entry flex alloc 	pfdebug 
str strcmp 	todense key 
lookup cache create 	force propagation 
cache sha 	encoding change 
hex isspace isspace 	intset.c pos 
strbuf getwholeline 	enc pos 
skip prefix strstr 	pos 
strstr parse 	encoding len 
line check refname 	size pos 
format refname 	mid cur 
safe die hashclr 	curenc newenc 
create entry 	length prepend 
starts sha hex 	src 
hashcpy strbuf 	dst bytes 
release git 	encoding success 
pathdup submodule git 	valenc pos 
pathdup stat 	success valenc 
validity check clear 	pos 
packed cache 	len valenc 
xcalloc acquire packed 	pos estr 
cache create 	file line 
dir entry fopen 	bits size 
stat validity 	mask encoding 
update fileno read 	argc 
packed refs 	argv success 
dir fclose free 	inserts size 
dir packed 	bits start 
dir packed cache 	memcpy memrev 
packed cache 	ifbe memcpy 
die packed dir 	memrev 
create entry 	ifbe memcpy 
strlen strbuf git 	memrev ifbe 
path submodule 	intset encoded 
strbuf git 	intrev ifbe 
path opendir strbuf 	intrev ifbe 
release strbuf 	memrev 
init strbuf readdir 	ifbe memrev 
ends strbuf 	ifbe memrev 
addstr strbuf addstr 	ifbe zmalloc 
stat isdir 	intrev ifbe 
strbuf addch entry 	intrev ifbe 
dir create 	zrealloc 
dir entry hashclr 	intrev ifbe 
resolve gitlink 	intset intrev 
read full hashclr 	ifbe intrev 
sha check 	ifbe intset 
refname format refname 	intset intrev 
safe die 	ifbe 
hashclr entry dir 	intset encoding 
create entry 	intrev ifbe 
strbuf setlen strbuf 	intrev ifbe 
setlen strbuf 	intset resize 
release strbuf 	intrev ifbe 
release closedir create 	intset 
dir entry 	intset encoded 
entry dir dir 	intset intset 
create dir 	intrev ifbe 
entry dir packed 	intrev ifbe 
refs find 	intrev ifbe 
hashcpy strlen git 	intrev 
pathdup submodule 	ifbe intrev 
git pathdup open 	ifbe memmove 
free resolve 	intset encoding 
gitlink packed read 	intrev ifbe 
close isspace 	intset upgrade 
sha hex strncmp 	intset 
isspace resolve 	search intset 
gitlink recursive strlen 	resize intrev 
strbuf lookup 	ifbe intrev 
cache nonbare repository 	ifbe intset 
dir strbuf 	move tail 
release create 	intset 
cache strbuf release 	intrev ifbe 
resolve gitlink 	intrev ifbe 
recursive find packed 	intset encoding 
refs packed 	intrev ifbe 
hashcpy hashclr check 	intset search 
refname format 	intrev 
refname safe strbuf 	ifbe intset 
reset strbuf 	move tail 
git path lstat 	intset resize 
resolve missing 	intrev ifbe 
loose hashclr islnk 	intset encoding 
strbuf reset 	intrev 
strbuf readlink starts 	ifbe intset 
check refname 	search intset 
format strbuf swap 	rand intrev 
hashclr isdir 	ifbe intrev 
open strbuf reset 	ifbe intset 
strbuf read 	intrev 
close close 	ifbe intrev 
strbuf rtrim starts 	ifbe intrev 
sha hex 	ifbe gettimeofday 
isspace hashclr isspace 	intset rand 
strbuf reset 	rand rand 
strbuf addstr hashclr 	intset 
check refname 	intrev ifbe 
format refname safe 	intrev ifbe 
resolve strbuf 	srand time 
release strbuf release 	unused unused 
peel strcmp 	intset encoding 
peel entry hashcpy 	intset 
read full 	encoding intset 
packed peel entry 	encoding intset 
hashcpy peel 	encoding intset 
loose refs find 	encoding intset 
containing dir 	encoding intset 
prime dir 	encoding 
packed cache acquire 	intset encoding 
packed cache 	intset encoding 
packed dir find 	intset encoding 
containing dir 	intset intset 
sort dir sort 	intset intset 
dir entry 	intset 
dirs sort dir 	intset intset 
entry dir 	rand intrev 
sort dir entry 	ifbe check 
dir release 	consistency intset 
packed cache git 	intset intrev 
env entry 	ifbe 
resolve gitlink read 	intset intrev 
full head 	ifbe intset 
head cache strlen 	find intset 
cache strlen 	find check 
strlen strbuf addf 	consistency intset 
git strbuf 	intset 
release rollback 	intrev ifbe 
file free free 	intset intrev 
free read 	ifbe intset 
full strbuf addf 	find intset 
hashclr hashcmp 	find check 
strbuf addf sha 	consistency 
hex sha 	intset intset 
hex dir recursively 	intrev ifbe 
sha xcalloc 	intset intrev 
resolve strbuf git 	ifbe intset 
path empty 	find intset 
directories verify refname 	find 
available dir 	check consistency 
loose refs strbuf 	intset intset 
addf resolve 	intrev ifbe 
verify refname available 	intset intrev 
dir loose 	ifbe intset 
refs strbuf addf 	find 
strerror oid 	intset find 
verify refname 	check consistency 
available dir packed 	intset intset 
refs xcalloc 	intrev ifbe 
xstrdup xstrdup strbuf 	intset intrev 
git path 	ifbe 
safe create leading 	intset find 
directories strbuf 	intset find 
addf hold file 	check consistency 
update unable 	intset intset 
message verify unlock 	intrev ifbe 
strbuf release 	intset 
strbuf release die 	intrev ifbe 
sha hex 	intset find 
die sha hex 	intset find 
error write 	check consistency 
packed entry git 	create check 
config hold 	consistency 
file update timeout 	usec intset 
git path 	search rand 
packed cache 	usec intset 
acquire packed cache 	rand intset 
packed cache 	intset find 
die fdopen file 	rand 
die errno 	intset intset 
die entry dir 	find check 
packed dir 	consistency copyright 
commit file release 	pieter noordhuis 
packed cache 	pcnoordhuis gmail 
packed cache die 	dot 
rollback file 	copyright salvatore 
release packed cache 	sanfilippo antirez 
clear packed 	gmail dot 
cache starts type 	rights reserved 
resolves peel 	redistribution use 
entry die oid 	source 
hex find 	binary forms 
oidcpy create 	without modification 
entry oidcpy flex 	permitted provided 
alloc str 	following conditions 
hashcpy rmdir git 	met redistributions 
path check 	source 
refname format transaction 	code must 
begin transaction 	retain copyright 
transaction commit transaction 	notice list 
free error 	conditions following 
strbuf release transaction 	disclaimer redistributions 
free strbuf 	binary 
release empty parents 	form must 
prune memset 	reproduce copyright 
packed refs packed 	notice list 
refs entry 	conditions following 
dir loose refs 	disclaimer documentation 
commit packed 	materials 
refs die errno 	provided distribution 
prune refs 	neither name 
packed packed 	redis names 
refs unable message 	contributors may 
git path 	used endorse 
packed refs entry 	promote 
rollback packed 	products derived 
refs commit packed 	software without 
refs strbuf 	specific prior 
addf strerror locked 	written permission 
file path 	software provided 
unlink msg free 	copyright 
repack without 	holders contributors 
refs error error 	express implied 
error strbuf 	warranties including 
release strbuf reset 	limited implied 
strbuf git 	warranties merchantability 
path safe create 	fitness 
leading directories 	particular purpose 
error rename git 	disclaimed shall 
path empty 	copyright owner 
directories error 	contributors liable 
error strerror strbuf 	direct indirect 
release packed 	incidental 
refs loose refs 	special exemplary 
verify refname 	consequential damages 
available dir verify 	including limited 
refname available 	procurement substitute 
dir lstat git 	goods services 
path islnk 	loss 
error resolve error 	use data 
error rename 	profits business 
available rename git 	interruption however 
path git 	caused theory 
path error strerror 	liability whether 
error read 	contract 
full strbuf git 	strict liability 
path empty 	tort including 
directories strbuf release 	negligence otherwise 
error error 	arising way 
rename tmp 	use software 
log sha basic 	even 
error strbuf 	advised possibility 
release hashcpy write 	damage note 
lockfile commit 	encodings ordered 
update error strbuf 	intset enc 
release sha 	intset enc 
basic error strbuf 	intset 
release write 	enc required 
lockfile commit update 	encoding provided 
error strbuf 	pos given 
release rename git 	encoding pos 
path git 	configured encoding 
path error strerror 	pos 
rename git 	configured encoding 
path git path 	create empty 
error strerror 	intset resize 
close file 	intset search 
commit file strbuf 	position found 
git path 	sets 
autocreate reflog safe 	pos position 
create leading 	within intset 
directories strbuf addf 	present intset 
strerror open 	sets pos 
empty directories strbuf 	position inserted 
addf open 	never 
strbuf addf strerror 	found empty 
adjust shared 	check know 
perm close log 	cannot find 
setup strbuf 	know insert 
release strlen strlen 	position upgrades 
xmalloc xsnprintf 	intset 
sha hex sha 	larger encoding 
hex copy 	inserts given 
reflog msg write 	integer first 
full free 	encoding resize 
bare repository 	upgrade back 
log setup open 	front 
log write 	overwrite values 
git committer info 	note prepend 
strbuf addf 	variable used 
strerror close close 	make sure 
strbuf addf 	empty space 
strerror files log 	either 
write log 	beginning end 
write strbuf release 	intset beginning 
parse strbuf 	end insert 
addf sha hex 	integer intset 
unlock branch 	upgrade encoding 
strbuf addf sha 	necessary 
hex unlock 	need upgrade 
file write full 	know either 
sha hex 	appended prepended 
write full close 	lies outside 
strbuf addf 	range existing 
file path 	values 
unlock clear loose 	always succeeds 
cache log 	need curry 
write strcmp log 	success abort 
write strbuf 	already present 
detach strbuf addf 	call populate 
free unlock 	pos 
strcmp resolve strcmp 	right position 
log write 	insert cannot 
error strbuf release 	found integer 
commit error 	intset know 
unlock unlock locked 	overwrite tail 
file path 	update 
unlink symlink free 	length determine 
read log 	whether belongs 
write error strbuf 	random member 
release create 	sets given 
symlink update symref 	position position 
reflog fdopen 	range 
file error 	function returns 
strerror update symref 	range returns 
reflog commit 	intset length 
error strerror sha 	intset blob 
basic error 	size bytes 
strbuf release create 	intset.h 
symref locked 	success success 
unlock lstat git 	pos argc 
path isreg 	argv copyright 
path git path 	pieter noordhuis 
sha hex 	pcnoordhuis gmail 
sha hex strchr 	dot 
strtoul isdigit 	copyright salvatore 
isdigit isdigit isdigit 	sanfilippo antirez 
strtol fopen 	gmail dot 
git path fseek 	rights reserved 
error strerror 	redistribution use 
ftell fseek error 	source 
strerror fread 	binary forms 
error strerror 	without modification 
find beginning line 	permitted provided 
strbuf splice 	following conditions 
show one reflog 	met redistributions 
ent strbuf 	source 
reset strbuf splice 	code must 
show one 	retain copyright 
reflog ent strbuf 	notice list 
reset strbuf 	conditions following 
splice die fclose 	disclaimer redistributions 
strbuf release 	binary 
fopen git path 	form must 
strbuf getwholeline 	reproduce copyright 
show one reflog 	notice list 
ent fclose 	conditions following 
strbuf release opendir 	disclaimer documentation 
git path 	materials 
readdir ends 	provided distribution 
strbuf addstr stat 	neither name 
git path 	redis names 
isdir strbuf addch 	contributors may 
reflog read 	used endorse 
full error strbuf 	promote 
setlen closedir 	products derived 
strbuf init reflog 	software without 
strbuf release 	specific prior 
strcmp strbuf addf 	written permission 
die list 	software provided 
append list sort 	copyright 
update reject 	holders contributors 
duplicates sha sha 	express implied 
basic strbuf 	warranties including 
detach strbuf addf 	limited implied 
free hashcmp 	warranties merchantability 
write lockfile strbuf 	fitness 
detach strbuf 	particular purpose 
addf free 	disclaimed shall 
close strbuf addf 	copyright owner 
commit update 	contributors liable 
loose list append 	direct indirect 
repack without 	incidental 
refs unlink warn 	special exemplary 
git path 	consequential damages 
clear loose cache 	including limited 
unlock list 	procurement substitute 
clear list clear 	goods services 
list die 	loss 
list append list 	use data 
sort update 	profits business 
reject duplicates rawref 	interruption however 
die sha 	caused theory 
die verify refname 	liability whether 
available packed 	contract 
refs strbuf addf 	strict liability 
strerror sha 	tort including 
packed commit 	negligence otherwise 
packed refs strbuf 	arising way 
addf strerror 	use software 
list clear prune 	even 
sha hex 	advised possibility 
sha hex hashcpy 	damage intset 
memset sha 	jemalloc.c opt 
basic error strbuf 	abort opt 
release reflog 	junk opt 
exists unlock git 	junk 
pathdup hold 	alloc opt 
file update unable 	junk free 
message error 	opt quarantine 
strbuf release fdopen 	opt redzone 
file error 	opt utrace 
file path strerror 	opt 
prepare reflog 	xmalloc opt 
ent cleanup sha 	zero opt 
close file 	narenas valgrind 
error strerror 	ncpus arenas 
write full file 	arenas narenas 
sha hex 	total 
write str full 	narenas malloc 
file close 	init state 
error file path 	index size 
rollback file 	tab size 
commit file error 	index tab 
strerror commit 	malloc 
error free unlock 	initializer malloc 
rollback file 	initializer init 
free unlock information 	init init 
used along 	initialized init 
information entry describe 	size zero 
single cached 	metadata 
reference data structure 	ptr metadata 
occurs embedded 	size ptr 
entry entry 	size num 
flag dir zero 	size num 
name reference 	size ptr 
resolves may tag 	ind 
isbroken issymref 	arena narenas 
name referred last 	arenas ind 
reference symlink 	arena narenas 
chain knows peeled 	tsd ind 
field holds 	arena tsd 
peeled reference reference 	ind 
known peelable 	tsd oldind 
see documentation peel 	newind oldarena 
exact definition 	newarena ind 
peelable information used 	nthreads tsd 
along information 	ind arena 
entry describe level 	tsd 
hierarchy references 	ind init 
data structure occurs 	missing arena 
embedded entry 	arenas cache 
entry flag 	narenas cache 
dir entry flag 	narenas actual 
incomplete determines 	arenas 
whether references directory 	cache bypassp 
already read 	tsd ret 
entry flag incomplete 	choose first 
unset directory 	tsd tsd 
loose packed references 	tsd arena 
already read 	tsd 
entry flag incomplete 	arenas cache 
directory loose 	tsd tsd 
references hasn read 	narenas arena 
yet subdirectories 	tcache name 
entries within directory 	result 
stored within 	opts klen 
growable pointers entries 	vlen accept 
entries alloc 	opts msg 
entries sorted sorted 	klen vlen 
component name 	buf opts 
strcmp order 	klen 
remaining entries unsorted 	vlen linklen 
loose references 	saved errno 
read lazily one 	linkname envname 
directory time 	match ret 
directory loose references 	tsd usize 
read references 	tctx 
directory stored incomplete 	tsd usize 
stubs created 	tctx size 
subdirectories subdirectories read 	tsd usize 
reading triggered 	ret tsd 
dir entries index 	jemalloc silence 
sorted sorted 	init 
name entries appended 	tsd alignment 
list unsorted 	usize tctx 
sorted required thus 	tsd alignment 
avoid need 	usize tctx 
sort list addition 	memptr alignment 
every reference 	size 
pointer cache 	min alignment 
contains dir bit 	ret tsd 
values entry 	usize result 
flag issymref ispacked 	posix memalign 
isbroken bad 	ret err 
name values see 	tsd 
refs field 	usize tctx 
entry peeled entry 	tsd usize 
contains correct 	tctx ret 
peeled reference might 	tsd num 
sha reference 	size jemalloc 
tag broken entry 	silence 
represents directory 	init tsd 
references entry yet 	old ptr 
read disk 	old usize 
used dir entries 	usize tctx 
representing loose 	tsd old 
references entry 	ptr 
represents either reference 	old usize 
subdirectory references 	usize prof 
directory reference represented 	active old 
entry flags 	tctx tctx 
dir containing subdir 	tsd ptr 
member holds 	tcache 
entries directory read 	usize jemalloc 
far flags 	silence init 
incomplete directory subdirectories 	tsd ptr 
haven read 	usize tcache 
yet incomplete used 	jemalloc silence 
loose reference 	init 
directories references represented 	realloc ptr 
entry flags 	tsd tsd 
dir unset member 	size flags 
describes reference 	usize alignment 
flag member entry 	zero tcache 
level also 	arena 
needed interpret 	arena ind 
contents field words 	tsd size 
much use 	flags usize 
without enclosing entry 	alignment zero 
reference names 	tcache arena 
cannot end slash 	tsd 
directories names 	usize alignment 
always stored trailing 	zero tcache 
slash top 	arena tsd 
level directory always 	usize alignment 
denoted two 	zero tcache 
nice consequences entries 	arena 
subdir sorted 	tsd size 
lexicographically name usually 	flags usize 
references whole 	alignment zero 
generated lexicographic order 	tcache arena 
traversing left 	tctx tsd 
right depth first 	size 
order names 	flags usize 
references subdirectories 	alignment zero 
cannot conflict therefore 	tcache arena 
presence empty 	tsd usize 
subdirectory block creation 	tsd old 
similarly named 	ptr 
reference fact reference 	old usize 
names leading 	usize alignment 
components conflict separate 	zero tcache 
issue regulated 	arena tctx 
verify refname available 	tsd old 
please note 	ptr 
name field contains 	old usize 
fully qualified 	size alignment 
reference subdirectory name 	usize zero 
space could 	tcache arena 
saved storing relative 	prof active 
names would 	old 
require full names 	tctx tctx 
generated fly 	rallocx ptr 
iterating would 	old usize 
callback functions always 	size extra 
able name 	alignment zero 
passed freed iteration 	usize 
issymref ispacked 	ptr old 
flags dir flags 	usize size 
dir full 	extra alignment 
name reference refs 	zero tctx 
heads master 	usize tsd 
full name directory 	ptr 
trailing slash 	old usize 
refs heads manually 	size extra 
refs bisect 	alignment zero 
per worktree might 	usize max 
appear directory 	usize prof 
listing refs main 	active 
repo use 	old tctx 
dir might trigger 	tctx ptr 
reading loose 	size extra 
refs entry 	flags tsd 
end dir unsorted 	usize old 
entry always 	usize 
stored directly dir 	jemalloc silence 
recursion subdirectories 	init alignment 
done optimize entries 	zero usize 
added order 	ptr flags 
clear free entries 	tsd tcache 
dir recursively 	size 
create entry specified 	flags usize 
dirname dirname 	ptr size 
name directory trailing 	flags tsd 
slash refs 	tcache usize 
heads top level 	name oldp 
directory index 	oldlenp 
entry given refname 	newp newlen 
dir non 	name mibp 
recursively sorting 	miblenp mib 
dir necessary entry 	miblen oldp 
found dir 	oldlenp newp 
must already complete 	newlen 
search directory 	write cbopaque 
entry directly within 	opts ptr 
dir without 	ret malloc 
recursing sort dir 	mutex init 
necessary subdirname 	unlikely quarantine 
must directory name 	alloc 
end mkdir 	hook unlikely 
create directory missing 	malloc init 
otherwise desired 	hard unlikely 
directory cannot found 	malloc initialized 
dir must 	malloc init 
already complete since 	hard 
dir complete 	malloc init 
absence subdir means 	unlikely malloc 
subdir really 	init iallocztm 
doesn exist 	idalloctm ialloc 
therefore create empty 	idalloc unlikely 
record mark 	ialloc 
record complete refname 	unlikely ialloc 
reference name 	unlikely idalloc 
find dir within 	malloc cacheline 
dir hold 	ceiling memcpy 
refname refname directory 	dalloc arena 
name ends 	malloc 
dir dir must 	mutex arena 
represent top 	init locked 
level directory must 	malloc mutex 
already complete 	unlock malloc 
sort dirs recurse 	mutex malloc 
subdirectories necessary 	mutex 
mkdir create missing 	unlock tsd 
directories otherwise 	nominal tsd 
desired directory cannot 	arena malloc 
found find 	mutex arena 
entry given 	bind locked 
name dir sorting 	malloc 
dirs recursing 	mutex unlock 
subdirectories necessary name 	malloc mutex 
found corresponds 	malloc mutex 
directory entry entry 	unlock tsd 
given name 	arena malloc 
dir recursing subdirectories 	mutex 
necessary refname 	malloc mutex 
name directory ends 	unlock malloc 
directory contents 	mutex malloc 
removal successful number 	mutex unlock 
entries remaining 	tsd arena 
directory entry contained 	tsd 
deleted entry 	arenas cache 
name found please 	tsd narenas 
note function 	cache narenas 
deletes entry cache 	total dalloc 
filesystem ensure 	tsd arenas 
cache entries 	cache 
might symbolic references 	tsd narenas 
removed entry 	cache tsd 
updated containing dir 	arenas cache 
entries might 	bypassp tsd 
made empty removal 	nominal malloc 
dir must 	malloc 
represent top level 	mutex malloc 
directory must 	mutex unlock 
already complete refname 	tsd nominal 
represents reference 	tsd arenas 
directory trailing slash 	cache tsd 
otherwise directory 	narenas 
representing refname rather 	cache malloc 
one containing 	mutex memcpy 
entry dir unsorted 	malloc mutex 
recursing subdirectories 	unlock memset 
necessary dir 	arena init 
must represent top 	malloc 
level directory 	mutex arena 
success emit warning 	init locked 
iff name 	malloc mutex 
sha die name 	unlock arena 
different sha 	bind locked 
duplicate name make 	malloc 
sure conflict 	mutex unlock 
impossible construction sort 	arena bind 
entries dir 	tsd arena 
non recursively already 	arena unbind 
sorted duplicate 	tsd arenas 
entries check also 	cache 
prevents passing 	tsd arenas 
zero length qsort 	cache dalloc 
problem platforms 	malloc mutex 
duplicates include broken 	tcache stats 
references iteration 	merge malloc 
iff reference 	mutex 
described entry resolved 	unlock malloc 
database emit 	stats print 
warning referred exist 	issetugid getenv 
current performance 	system info 
hack iterating references 	sysconf malloc 
functions current 	write 
current reference entry 	malloc write 
calling callback 	malloc write 
function callback function 	malloc unlikely 
calls peel 	unlikely readlink 
peel first checks 	errno secure 
whether reference 	getenv 
peeled current reference 	reached malloc 
usually returns 	conf next 
reference peeled version 	strncmp strncmp 
available avoids 	chunk dss 
refname lookup common 	prec malloc 
handle one 	conf 
reference style 	error malloc 
iteration calling entry 	conf error 
store old 	conf match 
recursive call call 	conf match 
reference dir 	conf match 
index range offset 	conf 
index dir 	match conf 
recurse subdirectories index 	match malloc 
range sorting 	conf error 
iterating function sort 	conf match 
dir sorted 	malloc conf 
beforehand called references 	error 
including broken 	malloc conf 
ones call reference 	error malloc 
dir dir 	initialized malloc 
order refname recurse 	initialized malloc 
subdirectories entry 	mutex unlock 
appears dir dir 	malloc 
process version 	mutex prof 
dir input 	boot malloc 
dirs must already 	conf init 
sorted subdirs 	atexit malloc 
sorted needed called 	write abort 
references including 	boot 
broken ones directories 	chunk boot 
descend parallel 	ctl boot 
references ignore one 	prof boot 
dir load 	arena boot 
refs dir memory 	tcache boot 
cache hard 	malloc 
work loading loose 	mutex init 
refs done 	memset arena 
dir need recurse 	init malloc 
sub directories 	mutex malloc 
even need care 	init hard 
sorting traversal 	locked 
order matter 	malloc mutex 
reference named refname 	unlock malloc 
could created 	mutex unlock 
without conflicting name 	malloc ncpus 
existing reference 	pthread atfork 
dir see verify 	malloc 
refname available 	write abort 
information sake comments 	malloc mutex 
function suppose 	mutex boot 
refname refs foo 	malloc alloc 
bar expand 	memset init 
dirname prefix including 	init 
trailing slash 	malloc mutex 
still leading dir 	malloc init 
refname refs 	hard needed 
foo reference name 	malloc mutex 
conflict unless 	unlock malloc 
skip found reference 	init 
whose name 	hard locked 
proper prefix 	malloc mutex 
refname refs foo 	unlock malloc 
skip otherwise 	tsd boot 
search next component 	malloc mutex 
look directory 	unlock 
refs foo come 	prof boot 
empty know 	malloc mutex 
nothing whole prefix 	unlock malloc 
even still 	init hard 
search conflicts extras 	recursible malloc 
directory refs 	init 
foo nothing whole 	hard finish 
prefix need 	malloc mutex 
looking conflicting references 	unlock malloc 
need looking 	mutex unlock 
conflicting extras leaf 	malloc tsd 
refname refs 	boot 
foo bar point 	imalloc arena 
searching reference 	prof promoted 
name refname 	imalloc prof 
isn considered conflict 	alloc prep 
still need 	prof active 
check references whose 	unlocked 
names refs 	unlikely imalloc 
foo bar conflict 	prof sample 
found directory 	imalloc unlikely 
named refname refs 	prof alloc 
foo bar 	rollback prof 
problem iff contains 	malloc 
skip count 	unlikely malloc 
references data structure 	init tsd 
instance including 	fetch unlikely 
pointer cache packed 	imalloc prof 
data freed 	unlikely imalloc 
reference count nonzero 	imalloc 
iff packed 	body unlikely 
refs file associated 	unlikely malloc 
instance currently 	write abort 
locked writing 	errno likely 
points associated owned 	isalloc tsd 
somebody referrer 	allocatedp 
count also incremented 	utrace jemalloc 
file locked 	valgrind malloc 
decremented unlocked metadata 	ipalloc arena 
packed refs 	prof promoted 
cache read future 	ipalloc prof 
need repository 	alloc 
full libification submodule 	prep prof 
name main 	active unlocked 
repo allocate length 	unlikely imemalign 
rather flex 	prof sample 
main cache initialized 	ipalloc unlikely 
correctly used 	prof 
main packed refs 	alloc rollback 
file increment 	prof malloc 
reference count packed 	unlikely malloc 
refs decrease 	init tsd 
reference count 	fetch unlikely 
packed refs goes 	unlikely 
zero free 	malloc write 
packed refs otherwise 	abort unlikely 
create submodule 	imemalign prof 
cache caches pointer 	ipalloc unlikely 
cache specified 	likely isalloc 
submodule main repository 	tsd 
use submodule 	allocatedp utrace 
returned structure allocated 	unlikely malloc 
initialized necessarily 	write abort 
populated freed length 	unlikely imemalign 
peeled reference 	errno jemalloc 
line packed refs 	valgrind 
including eol 	malloc isalloc 
packed refs header 	icalloc arena 
line write 	prof promoted 
perhaps traits 	icalloc prof 
added later trailing 	alloc prep 
space required 	prof 
parse one line 	active unlocked 
packed refs 	unlikely icalloc 
file write sha 	prof sample 
sha pointer 	icalloc unlikely 
refname within line 	prof alloc 
terminated problem 	rollback 
answer everything happens 	prof malloc 
answer length 	unlikely malloc 
sha hex representation 	init tsd 
space hex 	fetch unlikely 
name newline end 	unlikely unlikely 
line read 	icalloc 
packed refs file 	prof unlikely 
dir comment 	icalloc unlikely 
line form pack 	unlikely malloc 
refs may 	write abort 
contain zero 	errno likely 
traits interpret traits 	isalloc 
follows traits 	tsd allocatedp 
probably references peeled 	utrace jemalloc 
file contains 	valgrind malloc 
peeled reference use 	iralloc arena 
peeled references 	prof promoted 
refs tags peeled 	iralloc 
peeled file 	prof active 
references outside refs 	unlocked prof 
tags probably 	tctx prof 
peeled even could 	alloc prep 
find peeled 	unlikely irealloc 
reference use fully 	prof 
peeled references 	sample iralloc 
file peeled peeled 	unlikely prof 
inversely important 	alloc rollback 
references file peeled 	prof realloc 
recorded peelable 	malloc initialized 
trait typically 	isalloc 
written alongside peeled 	prof free 
compatibility older 	isalloc tsd 
clients require peeled 	deallocatedp unlikely 
fully peeled 	iqalloc jemalloc 
perhaps traits later 	valgrind free 
well regardless 	malloc 
file header said 	initialized prof 
definitely know 	free tsd 
reference packed cache 	deallocatedp unlikely 
specified cache 	isqalloc jemalloc 
creating necessary reference 	valgrind free 
memory packed 	utrace 
reference cache may 	likely tsd 
called packed 	fetch ifree 
refs file locked 	tcache unlikely 
see packed 	imemalign jemalloc 
refs actually write 	valgrind 
packed refs 	malloc unlikely 
file call 	imemalign jemalloc 
commit packed refs 	valgrind malloc 
read loose 	mallocx align 
references dirname dir 	specified mallocx 
without recursing 	zero 
dirname must end 	tcaches mallocx 
dir must 	tcache tcache 
directory entry corresponding 	mallocx arena 
dirname silently 	arena unlikely 
ignore astronomically unlikely 	likely tcache 
sha sha 	imallocx 
actual consider appearance 	flags decode 
loose reference 	hard unlikely 
file repo corruption 	ipalloct unlikely 
probably due 	icalloct imalloct 
software bug mark 	imallocx flags 
top level 	arena 
directory complete 	prof promoted 
read subdirectory hold 	imallocx flags 
references create 	unlikely imallocx 
incomplete entry refs 	flags decode 
allow recursive 	prof alloc 
symbolic refs within 	prep 
reason though 	prof active 
called resolve gitlink 	unlocked likely 
recursive failed 	imallocx flags 
read loose refs 	imallocx prof 
cache refs 	sample unlikely 
find refname packed 	prof 
refs file 	alloc rollback 
submodule detached head 	prof malloc 
old fashioned 	likely unlikely 
symlink symref entry 	imalloc unlikely 
given refname 	imallocx flags 
packed references exist 	decode 
loose file 	hard imallocx 
doesn exist 	flags unlikely 
check packed options 	malloc init 
forwarded resolve 	tsd fetch 
safe loose reference 	imallocx prof 
file exist 	imallocx 
check packed reference 	prof unlikely 
reference packed 	isalloc tsd 
reference either function 	allocatedp utrace 
needs meaningful 	jemalloc valgrind 
errno failure dwim 	malloc mallocx 
uses isbroken 	zero 
distinguish missing refs 	unlikely malloc 
refs present 	write abort 
invalid complain latter 	utrace iralloct 
stderr know 	arena prof 
whether exists isbroken 	promoted iralloct 
yet might 	prof 
loop back avoid 	active unlocked 
race condition 	prof tctx 
first lstat 	prof alloc 
file read link 	prep unlikely 
file somebody 	irallocx prof 
changes type file 	sample 
file directory 	iralloct unlikely 
symlink lstat reading 	prof alloc 
want report 	rollback isalloc 
error rather starting 	prof realloc 
lstat follow 	ixalloc isalloc 
normalized refs symlinks 	ixallocx 
hand inconsistent 	helper prof 
lstat retry directory 	active unlocked 
anything open 	prof tctx 
use inconsistent lstat 	prof alloc 
retry symbolic 	prep unlikely 
please note fetch 	ixallocx 
head second 	prof sample 
line containing data 	ixallocx helper 
peel entry 	prof alloc 
possible peel 	rollback prof 
status repeel peel 	realloc mallocx 
entry even 	align 
old peeled already 	malloc initialized 
stored call 	malloc init 
function packed reference 	tsd fetch 
entry might 	isalloc unlikely 
stale might even 	unlikely unlikely 
refer since 	ixallocx 
garbage collected entry 	prof ixallocx 
knows peeled 	helper unlikely 
status unchanged peel 	tsd allocatedp 
peeled peel 	tsd deallocatedp 
non tag otherwise 	jemalloc valgrind 
peel invalid 	realloc 
reference packed read 	utrace malloc 
entry cache 	initialized malloc 
hope already know 	init ivsalloc 
peeled optimization 	isalloc malloc 
packed references 	initialized tsd 
forcing filling loose 	fetch 
reference cache 	unlikely tcaches 
could expensive loose 	mallocx tcache 
references anyway 	tcache utrace 
usually knows peeled 	ifree tsd 
call reference 	fetch likely 
specified cache omitting 	mallocx 
references containing 	align specified 
dir called references 	malloc initialized 
including broken 	inallocx isalloc 
ones ever returns 	tsd fetch 
non zero 	unlikely tcaches 
stop iteration otherwise 	mallocx 
must make 	tcache tcache 
sure loose refs 	utrace isfree 
read accessing 	unlikely malloc 
packed refs 	init inallocx 
file avoids race 	unlikely malloc 
condition loose 	init 
refs migrated packed 	ctl byname 
refs file 	unlikely malloc 
simultaneous process memory 	init ctl 
view migration 	nametomib unlikely 
packed cache takes 	malloc init 
care making 	ctl 
sure view date 	bymib stats 
disk call 	print malloc 
reference specified cache 	initialized malloc 
refname begins 	init ivsalloc 
trim non zero 	isalloc malloc 
trim many 	init 
characters beginning refname 	malloc initialized 
passing refname 	malloc initialized 
flags include broken 	ctl prefork 
include broken 	prof prefork 
references iteration 	malloc mutex 
ever returns non 	prefork 
zero stop 	arena prefork 
iteration otherwise free 	chunk prefork 
atexit still 	prefork malloc 
looks verify reference 	initialized malloc 
locked old 	initialized postfork 
sha fail reference 	parent 
doesn exist 	chunk postfork 
mustexist success error 	parent arena 
write error 	postfork parent 
message err errno 	malloc mutex 
negative want 	postfork parent 
create file directory 	prof 
empty directory 	postfork parent 
directory contains empty 	ctl postfork 
directories locks 	parent malloc 
returning success failure 	initialized postfork 
failure errno 	child chunk 
something meaningful 	postfork 
trying foo used 	child arena 
foo bar 	postfork child 
exist normal empty 	malloc mutex 
directory foo 	postfork child 
remain exist creating 	prof postfork 
make sure 	child 
existing packed whose 	ctl postfork 
name begins 	child data 
refname packed whose 	runtime configuration 
name proper 	options initialized 
prefix refname success 	process running 
fall maybe 	inside 
somebody deleted one 	valgrind protects 
directories leading 	arenas initialization 
file write entry 	arenas narenas 
packed refs 	total arenas 
file specified refname 	used service 
peeled non 	external 
write entry 	requests elements 
peeled entry writes 	arenas necessarily 
entry packed 	used arenas 
refs file packed 	created lazily 
refs file 	needed arenas 
writing flags passed 	narenas 
hold file 	used automatic 
update success errors 	multiplexing threads 
errno appropriately 	arenas arenas 
nonzero current packed 	narenas narenas 
refs holding 	total used 
packed refs file 	application 
modified since 	takes action 
last read automatically 	create allocate 
invalidate cache 	arenas read 
read packed refs 	initialization read 
file increment 	initialization common 
reference count 	jnz 
prevent freed write 	used initializing 
current version 	recursively allocate 
packed refs cache 	used avoid 
memory disk 	initialization races 
packed refs file 	another constructor 
must already 	binary 
locked writing see 	mallctl setup 
packed refs 	chunk hooks 
zero success errors 	may end 
errno nonzero 	running one 
rollback lockfile packed 	malloc init 
refs file 	hard 
discard memory packed 	crash trying 
reference cache 	uninitialized force 
packed refs file 	initialization malloc 
read anew 	init hard 
needed function called 	well care 
entry run 	atomicity 
loose references 	accessed init 
loose reference packed 	initialized since 
entry packed 	really matters 
cache reference pruned 	early process 
also prune 	creation separate 
pack refs data 	normally 
pack per 	starts anything 
worktree refs always 	input pointer 
pack tags 	realloc request 
pack symbolic broken 	size result 
refs packed 	pointer function 
cache entry equivalent 	prototypes 
loose entry 	functions referenced 
overwrite existing packed 	prior definition 
entry info 	begin miscellaneous 
loose entry schedule 	support functions 
loose reference 	tsd initialization 
pruning requested empty 	safely 
parents spare 	done side 
refs immediate 	effect deallocation 
subdirs note munges 	possible nothing 
name refs 	deallocate tls 
heads tags tolerate 	data via 
duplicate slashes 	free 
see check refname 	writing tls 
format make 	would cause 
sure nobody touched 	write free 
unlink rewrite 	memory corruption 
packed refs file 	quarantine facility 
omitting refs 	gets 
listed refnames error 	used side 
packed refs 	effect deallocation 
unchanged write error 	make best 
message err 	effort attempt 
nonzero refs refnames 	initializing tsd 
needn sorted 	hooking 
err must look 	allocation events 
packed avoid 	functions used 
locking nothing 	instead mcd 
refname exists packed 	alloc situations 
refs refnames 	cannot tolerate 
cache packed entries 	tls 
disappeared acquiring 	variable access 
write remains loose 	free bsd 
loose file 	libc uses 
name lockfile name 	bootstrap functions 
minus failed 	bootstrap senstive 
rewrite packed refs 	situations 
file loose 	cannot tolerate 
refs might expose 	tls variable 
obsolete packed 	access tls 
reference might even 	allocation early 
point garbage 	data structure 
collected people contrib 	initialization 
git workdir 	create arena 
git logs 	insert arenas 
refs path git 	index ind 
logs refs 	expand arenas 
may live another 	necessary deallocate 
device iow 	arenas 
avoid cross device 	came malloc 
rename errors 	alloc another 
temporary renamed log 	may already 
must live 	initialized arenas 
logs refs success 	ind arena 
fall rename 	actually 
existing directory ought 	initialize arena 
result isdir 	deallocate old 
solaris gives enotdir 	cache small 
sheesh maybe 	allocate cache 
another process deleted 	missing function 
one directories 	must 
path newrefname beginning 	always tell 
create reflog 	truth even 
force create 	slow oom 
reflog created certain 	cleanup note 
refs autocreate 	tsd nominal 
reflog returns non 	check 
zero otherwise 	recursive allocation 
create regardless name 	avoidance note 
fill err 	arenas cache 
failure write sha 	bypass check 
open lockfile 	way copy 
close lockfile errors 	cache 
rollback lockfile 	possible actual 
fill err commit 	number arenas 
change loose 	increased since 
reference already written 	narenas total 
loose reference 	called causes 
lockfile also update 	correctness 
reflogs necessary 	issues unless 
specified lockmsg special 	two threads 
hack branch 	concurrently execute 
updated directly 	arenas extend 
head points may 	mallctl trust 
happen remote 	mallctl 
side push example 	synchronization prevent 
logically head 	read refreshed 
reflog updated solution 	cache init 
implies reverse 	arena necessary 
symref information finding 	slow path 
symrefs pointing 	called 
given branch would 	arena choose 
rather costly 	choose first 
rare direct update 	arena lowest 
branch worth 	number threads 
cheat check head 	assigned record 
cover usage 	index 
scenarios even ones 	first uninitialized 
error check 	arena extant 
commit check ferror 	arenas use 
old name 	possible discontinuities 
email time 	terms initialized 
tab msg corrupt 	versus 
keep scanning 	uninitialized arenas 
backwards either beginning 	due arena 
buffer end 	mallctl use 
previous line jump 	unloaded arena 
end fill 	least loaded 
next block end 	arena 
looking end 	arenas already 
file terminating previous 	initialized initialize 
line beginning 	arena nothing 
buffer newline end 	nothing nothing 
previous line 	nothing merge 
know complete line 	stats 
starting prefix 	extant threads 
onto prior data 	racy since 
collected line 	individual threads 
process start buffer 	recording tcache 
start file 	stats events 
previous line 	consequence 
everything one process 	stats may 
end loop 	slightly date 
start buffer file 	time reported 
read backwards 	threads allocate 
means middle line 	tcache stats 
note may 	merge 
even newline means 	locks bins 
exact end 	code introduced 
previous line rather 	acquires arena 
spot middle 	bin locks 
save away combined 	opposite order 
data next 	deadlocks 
read call reflog 	may result 
indicated name 	end miscellaneous 
name must empty 	support functions 
end name 	begin initialization 
used scratch 	functions look 
space contents restored 	ahead 
silently ignore 	one character 
fail refname appears 	next time 
transaction acquire 	function called 
locks verify old 	end input 
values provided 	cleanly reached 
check values valid 	input 
write values 	remains optimistically 
lockfiles ready activated 	already consumed 
keep one 	comma one 
lockfile open time 	exists automatically 
avoid running 	configure valgrind 
file descriptors reference 	processing 
already desired 	options valgrind 
need write freed 	option remains 
upon failure 	jemalloc compatibility 
write lockfile didn 	reasons runtime 
write anything 	configuration use 
lockfile close 	options 
free file descriptor 	compiled program 
perform updates 	configuration specified 
first live commits 	use contents 
remain referenced 	etc malloc 
freed commit update 	conf symbolic 
freed commit 	link 
update perform deletes 	name configuration 
updates safely 	specified restore 
completed fail refname 	errno nothing 
appears transaction 	opts already 
really undefined call 	initialized malloc 
function active 	conf 
repository existing references 	environment variable 
locking changing 	configuration specified 
packed refs simultaneous 	chunks always 
processes might 	require least 
change reference time 	one header 
existing loose 	page 
versions references 	many size 
setting would precedence 	data pages 
values remote 	possibly additional 
helpers create remote 	page presence 
head master 	redzones order 
branches calling function 	simplify 
really check 	options processing 
none references creating 	use conservative 
already exists 	bound accommodates 
reflog file locked 	constraints init 
holding reference 	must held 
plus might need 	another 
update reference 	initialized allocator 
updateref specified even 	one acquired 
though holding 	init initializing 
git dir logs 	recursively allocating 
reflog locking 	busy wait 
implications use file 	initializing 
machinery anyway 	completes init 
lot work 	must held 
need including cleaning 	print statistics 
program exits 	exit create 
unexpectedly doesn make 	enough scaffolding 
sense adjust 	allow 
reference pointed symbolic 	recursive allocation 
expiring entries 	malloc ncpus 
symbolic reference reflog 	initialize one 
update reference 	arena rest 
remaining reflog entries 	lazily created 
fmt-merge-msg.c fmt 	arena 
merge msg usage 	choose hard 
use branch 	initialize data 
desc key branch 	structures may 
tag branch 	trigger recursive 
head status sha 	allocation init 
data srcs 	must 
origins alloc 	held linux 
given commit used 	threads pthread 
table given 	atfork allocates 
commit table given 	init must 
commit line 	held smp 
merge parents len 	systems 
origin data 	create one 
src origin src 	arena per 
data item 	cpu make 
pulling head sha 	sure arenas 
len singular 	allocated 
plural list name 	practice limit 
desc people 	enough allow 
buffer name buf 	allocator function 
name name 	ctl machinery 
end elem field 	fail allocate 
people commit 	memory 
buffer people kind 	far lower 
label authors 	limits allocate 
committers name 	initialize arenas 
origin data head 	zero practice 
rev opts 	always pre 
count commit branch 	zeroed 
subjects authors 	since mmap 
committers flags sha 	sure copy 
limit ctx 	pointer one 
current branch sep 	arena already 
src data 	initialized end 
subsep tagbuf sig 	initialization 
buf len 	functions begin 
tag body first 	malloc compatible 
tag tagbuf 	functions make 
sha size len 	sure alignment 
buf sig 	large enough 
tagline result head 	power 
parents head 	avoid division 
commit len newline 	know isn 
sha parent 	possible overflow 
obj cmit 	multiplication neither 
opts pos head 	operand uses 
sha current 	significant 
branch current branch 	half bits 
free merge 	size size 
parents len newline 	overflow realloc 
head rev 	ptr equivalent 
argc argv prefix 	free ptr 
inpath message 	realloc 
shortlog len options 	size equivalent 
output ret 	malloc size 
opts strcmp strcmp 	end malloc 
git config 	compatible functions 
error strcmp git 	begin non 
config git 	standard 
config hashcmp hashcmp 	functions malloc 
find merge 	malloc macro 
parent alloc grow 	magic detect 
hashcpy hashcpy 	jemalloc defs 
strlen starts 	define malloc 
sha hex find 	malloc 
merge parent 	glibc provides 
xcalloc hashcpy strstr 	rtld deepbind 
unsorted list 	flag dlopen 
lookup list append 	make possible 
xcalloc init 	inconsistently reference 
src data starts 	libc 
list append 	malloc compatible 
starts list append 	functions https 
skip prefix 	bugzilla mozilla 
list append list 	show bug 
append strcmp 	cgi definitions 
strcmp strlen xmemdupz 	interpose 
xstrfmt strcmp 	hooks glibc 
list append strbuf 	functions actually 
addf strbuf 	passed extra 
addstr strbuf 	argument caller 
addf strbuf addf 	address ignored 
read branch 	end 
desc strchrnul strbuf 	non standard 
addf strbuf 	functions begin 
complete line strbuf 	non standard 
release strstr 	functions allocation 
strlen strchrnul isspace 	move possible 
xmemdupz list 	size 
lookup list insert 	smaller would 
integral free 	guarantee requested 
commit buffer record 	alignment alignment 
person buf 	constraint serendipitously 
unuse commit buffer 	satisfied additionally 
integral integral 	old 
strbuf addf strbuf 	usize may 
addf integral 	current usize 
integral strbuf addf 	place large 
integral git 	reallocation therefore 
author info 	query actual 
git committer info 	usize 
skip prefix 	usize isn 
starts strbuf addf 	knowable ixalloc 
people count 	returns extra 
qsort qsort credit 	non zero 
people credit 	therefore compute 
people deref tag 	maximum 
parse sha 	possible use 
hex setup revisions 	prof alloc 
pending pending 	prep decide 
prepare revision walk 	whether capture 
die revision 	backtrace prof 
record person record 	realloc 
person record 	use actual 
person format commit 	usize decide 
message strbuf 	whether sample 
ltrim list append 	clamp extra 
oid hex 	necessary avoid 
list append 	size 
strbuf detach people 	extra overflow 
info strbuf 	check size 
addf strbuf addf 	overflow end 
branch desc 	non standard 
strbuf addf strbuf 	functions following 
addf clear 	functions 
commit marks clear 	used threading 
commit marks 	libraries protection 
free commit list 	malloc fork 
list clear 	application creates 
list clear list 	allocation main 
clear strbuf 	calls 
addstr strbuf addstr 	fork main 
strbuf addstr 	followed memory 
strbuf addstr strbuf 	allocation child 
addstr print 	process race 
joined strbuf addstr 	occur results 
print joined 	deadlock 
strbuf addstr 	within child 
print joined strbuf 	main may 
addstr print 	forked created 
joined strcmp strbuf 	partially initialized 
addf strcmp 	allocator ordinarily 
strbuf addch strbuf 	jemalloc 
addf strstr 	prevents fork 
strbuf strbuf complete 	malloc races 
line strbuf 	via following 
addch strbuf commented 	functions registers 
lines read 	initialization pthread 
sha file parse 	atfork 
signature verify 	course good 
buffer strbuf addstr 	allocator isn 
fmt tag 	fully initialized 
signature strbuf addch 	fork time 
strbuf commented 	following library 
lines strlen strbuf 	constructor 
insert strbuf 	solution problem 
release strbuf 	may still 
addch strbuf commented 	possible trigger 
lines strlen 	deadlock described 
fmt tag signature 	would involve 
strbuf release 	forking 
free strbuf addch 	via library 
strbuf addbuf 	constructor runs 
strbuf release strchr 	jemalloc runs 
strlen sha 	acquire mutexes 
hex parse peel 	safe order 
type commit 	release 
list insert merge 	mutexes fork 
parent lookup 	completed release 
commit commit list 	mutexes fork 
insert reduce 	completed jemalloc 
heads pop commit 	declsh disable 
hashcmp memset 	warnings 
resolve refdup 	deprecated system 
die starts find 	functions jemalloc 
merge parents 	jemalloc macrosh 
strchr strlen handle 	jemalloc always 
line die 	jemalloc used 
fmt merge msg 	within 
title fmt 	header files 
merge msg sigs 	functions functions 
lookup commit 	inlining enabled 
die init revisions 	single definition 
strbuf complete 	library functions 
line shortlog strbuf 	inlining 
complete line 	disabled jemalloc 
free free git 	always jemalloc 
config parse 	use files 
options usage options 	denoted functions 
strcmp fopen 	always regardless 
die errno strbuf 	whether 
read fileno 	inlining enabled 
die errno 	disable inlining 
strbuf addstr memset 	make debugging 
fmt merge 	profiling easier 
msg write full 	junk.c malloc 
merge data 	conf 
per repository merged 	arena dalloc 
tips came 	junk small 
know know inefficient 	orig arena 
won pulling 	dalloc junk 
merging hundreds heads 	large orig 
time anyway 	huge 
subsumed parents point 	dalloc junk 
line points 	orig watch 
beginning comment branch 	junking saw 
frotz git 	junking ptr 
repository git find 	bin info 
repository name 	ptr 
point src list 	usize ptr 
merge count 	usize min 
committer tip 	max prev 
committer merely annotated 	arena ralloc 
skip merge 	junk large 
use merge parent 	orig 
name want 	recently trimmed 
contaminate field yet 	size shrink 
current branch 	size ptr 
line fmt-merge-msg.h merge 	old usize 
log config 	usize detected 
key fmt merge 	redzone 
msg fopen.c 	corruption ptr 
path mode fopen 	usize offset 
fopen fstat 	arena redzone 
fileno fclose isdir 	corruption orig 
fclose order 	arena dalloc 
following two lines 	junk 
important fread 	small orig 
reads directories undefined 	arena dalloc 
including git 	junk large 
compat avoid 	orig huge 
redefinition fopen within 	dalloc junk 
git compat 	orig 
necessary since fopen 	mallocx ptr 
macro platforms 	sallocx xallocx 
may compiler options 	watch junking 
example aix 	rallocx ptr 
fopen fopen large 	watch junking 
files defined 	dallocx 
previous technique merely 	test skip 
undefining fopen 	test junk 
including git compat 	test skip 
inadequate for-each-ref.c 	test junk 
usage argc argv 	test skip 
prefix format 	test 
sorting tail quote 	junk nallocx 
style filter 	arena ralloc 
opts memset 	junk large 
memset parse options 	orig shrink 
error usage 	size mallocx 
options multi bits 	ptr 
error usage 	rallocx shrink 
options verify format 	size ptr 
usage options 	ptr test 
sorting git config 	skip test 
filter refs 	skip mallocx 
sort show item 	ptr 
clear warn 	dallocx mallocx 
ambiguous refs fsck.c 	ptr sallocx 
downcased msg 	dallocx test 
type text len 	conditions junk 
fsck msg 	filling actually 
type options path 	occurs 
skiplist sorted 	nuanced enough 
buffer sha result 	doesn make 
str msg 	sense duplicate 
msg type 	decision logic 
options msg msg 	test code 
type type 	actually 
msg type options 	check region 
values free 	junk filled 
done equal msg 	nothing test 
report data 	underflow test 
options desc entry 	overflow junk 
res result 	allocc 
commit data options 	junk freec 
parents res 	lapi.c lua 
result tag data 	ident idx 
options obj 	func func 
data options mode 	func size 
name mode 	res 
name len len 	panicf old 
len cmp 	idx idx 
item options retval 	idx idx 
sha full 	func idx 
path empty 	idx idx 
name dot dotdot 	idx 
dotgit zero 	idx idx 
pad bad modes 	index index 
dup entries 	index index 
properly sorted desc 	index index 
mode name 	idx idx 
mode name sha 	res 
data size 	num idx 
obj options buffer 	idx len 
ident obj 	idx idx 
options end commit 	idx idx 
buffer size 	idx len 
options sha sha 	fmt 
graft parent 	argp ret 
count author count 	fmt ret 
err commit 	argp idx 
data size options 	idx key 
buffer ret 	idx idx 
tag data 	narray 
size options sha 	nrec objindex 
ret buffer 	obj res 
eol tag data 	idx idx 
size options 	idx key 
tagged obj data 	idx idx 
size options 	objindex 
obj msg type 	obj idx 
message strlen 	res nargs 
xmalloc tolower strcmp 	nresults func 
open die 	func nresults 
read full die 	nargs nresults 
errno sha 	errfunc 
hex die sha 	status func 
append hashcmp 	func func 
close strcmp strcmp 	status reader 
strcmp die 	data chunkname 
parse msg 	status writer 
parse msg type 	data 
parse msg 	status data 
die parse msg 	res idx 
type die 	size val 
alloc fsck msg 	funcindex name 
type xstrdup 	val funcindex 
strcspn tolower strcmp 	name 
die init 	val api 
skiplist die fsck 	check cast 
msg type 	api check 
free strbuf addch 	registry curr 
tolower strbuf 	func sethvalue 
addch strbuf addstr 	curr 
parse init 	func cast 
desc entry isgitlink 	hvalue curr 
isdir walk 	func setobj 
lookup isreg islnk 	api incr 
walk lookup 	top lua 
blob error 	lua 
oid hex parse 	checkstack lua 
commit walk 	unlock lua 
walk parse tag 	api checknelems 
walk fsck 	api check 
walk fsck walk 	api check 
commit fsck 	setobj 
walk tag error 	lua unlock 
oid hex 	lua lua 
strlen strlen memcmp 	unlock lua 
isdir isdir 	lua check 
init desc entry 	lua newthread 
extract sha 	setthvalue 
strchr strcmp strcmp 	api incr 
strcmp hfs 	top lua 
dotgit ntfs dotgit 	unlock luai 
update entry 	userstatethread cast 
verify ordered report 	lua api 
report report 	check 
report report 	setnilvalue api 
report report report 	check lua 
report report 	unlock lua 
report report strchrnul 	index adr 
report strcspn 	api checkvalidindex 
report report report 	setobjs 
strcspn report 	lua unlock 
report report date 	lua index 
overflows strtoul 	adr api 
report report isdigit 	checkvalidindex setobjs 
isdigit isdigit 	setobjs lua 
isdigit report verify 	unlock 
headers skip 	lua lua 
prefix report sha 	runerror api 
hex report 	checknelems index 
skip prefix sha 	adr api 
hex report 	checkvalidindex curr 
lookup commit graft 	func 
commit list 	api check 
count report 	ttistable hvalue 
report skip prefix 	lua barrier 
fsck ident 	setobj lua 
report report skip 	barrier curr 
prefix report 	func 
fsck ident report 	lua unlock 
sha hex 	lua setobj 
commit buffer fsck 	index adr 
commit buffer 	api incr 
unuse commit buffer 	top lua 
read sha 	unlock 
file report report 	index adr 
verify headers 	ttype unused 
skip prefix report 	index adr 
sha hex 	iscfunction index 
report skip prefix 	adr tonumber 
report strchr 	lua 
report type gently 	type index 
report skip 	adr ttisuserdata 
prefix report 	ttislightuserdata index 
strchr report strbuf 	adr index 
addf check 	adr lua 
refname format report 	rawequal 
skip prefix 	obj lua 
report fsck ident 	index adr 
strbuf release 	index adr 
free report fsck 	equalobj lua 
tag buffer 	unlock lua 
report fsck fsck 	index 
commit fsck 	adr index 
tag report warning 	adr lua 
oid hex 	lessthan lua 
error oid hex 	unlock index 
fatal errors 	adr tonumber 
errors warnings infos 	nvalue 
reported warnings 	index adr 
ignored convert 	tonumber nvalue 
lower without underscores 	lua number 
entries ordered 	integer index 
path order means 	adr isfalse 
directory entry 	index 
ordered adding slash 	adr ttisstring 
end directory 	lua lua 
called ordered file 	tostring lua 
called sorts 	unlock lua 
first len characters 	check index 
need order 	adr 
next one turn 	lua unlock 
directory entry 	tsvalue svalue 
git write used 	index adr 
write nonsense 	ttype tsvalue 
entries name one 	uvalue lua 
blob one 	getn 
make sure duplicate 	hvalue lua 
entries standard 	lua tostring 
modes nonstandard 	tsvalue lua 
early honored full 	unlock index 
mode bits 	adr iscfunction 
find separates header 	clvalue 
body body 	index adr 
crime want see 	ttype rawuvalue 
terminating last 	pvalue index 
header line shallow 	adr ttisthread 
commit early 	thvalue index 
tags contain tagger 	adr 
lines warn 	ttype hvalue 
data type obj 	clvalue thvalue 
mark reachable 	lua touserdata 
calls callers function 	lua setnilvalue 
non obj 	api incr 
hence references parent 	top 
fld safe 	lua unlock 
reference parent safe 	lua setnvalue 
error already 	api incr 
displayed check 	top lua 
single reachable obviously 	unlock 
want parsed 	lua setnvalue 
pack file didn 	cast num 
full fsck 	api incr 
pack forget check 	top lua 
single unreachable 	unlock lua 
missing unreachable ignore 	lua 
like miss 	check setsvalue 
since reached want 	lua newlstr 
complain unreachable 	api incr 
since exist unreachable 	top lua 
exists show 	unlock lua 
asked since something 	pushnil 
prunable used 	lua pushlstring 
means nothing points 	strlen lua 
including unreachable 	lua check 
objects words tip 	lua pushvfstring 
unreachable objects 	lua unlock 
usually commit 	lua 
got dropped starting 	lua check 
points interesting 	start lua 
random unreachable objects 	pushvfstring end 
show even 	lua unlock 
user hasn asked 	lua lua 
unreachable objects 	check 
deleted branch mistake 	api checknelems 
prime candidate 	lua cclosure 
start looking example 	getcurrenv setobj 
otherwise unreachable 	setclvalue lua 
unreachable points ignore 	iswhite obj 
interesting showed 	gco 
interesting cases traverse 	api incr 
pending reachable 	top lua 
objects look requirements 	unlock lua 
warn missing 	setbvalue api 
objects rest 	incr top 
despite error heads 	lua 
isn really 	unlock lua 
fatal mean unreachable 	setpvalue api 
longer makes 	incr top 
sense since everything 	lua unlock 
obviously unreachable 	lua setthvalue 
definition showing dangling 	api 
objects valid 	incr top 
though dangling objects 	lua unlock 
likely lost 	lua index 
heads print warning 	adr api 
clear show 	checkvalidindex lua 
unreachable flag detached 	gettable 
head directory 	lua unlock 
name minus trailing 	lua index 
slash verify 	adr api 
gives error messages 	checkvalidindex setsvalue 
error printed 	lua lua 
lookup given 	gettable 
head information ones 	api incr 
git refs 	top lua 
also consider index 	unlock lua 
file implies 	index adr 
cache show root 	api check 
show tags 	ttistable 
show unreachable include 	setobj lua 
reflogs check 	hvalue lua 
full connectivity check 	unlock lua 
strict keep 	index adr 
cache objects fsck 	api check 
walk options 	ttistable 
fsck obj options 	setobj lua 
head oid 	getnum hvalue 
head points errors 	api incr 
found write 	top lua 
lost found verbose 	unlock lua 
show progress 	lua 
show dangling 	check sethvalue 
path obj msg 	lua api 
type err 	incr top 
obj err obj 	lua unlock 
type message 	lua index 
pending obj type 	adr 
data options 	ttype hvalue 
parent obj obj 	uvalue ttype 
result progress 	sethvalue api 
result entry obj 	incr top 
obj type 	lua unlock 
data options obj 	lua 
obj filename 	index adr 
obj max obj 	api checkvalidindex 
obj item 	ttype sethvalue 
commit tag sha 	clvalue sethvalue 
obj fsck 	uvalue setobj 
obj buffer refs 	thvalue 
refname sha 	setnilvalue api 
obj osha 	incr top 
nsha email timestamp 	lua unlock 
message data 	lua api 
refname logname oid 	checknelems index 
flag data 	adr 
refname oid flag 	api checkvalidindex 
data obj 	lua settable 
sha path data 	lua unlock 
basename path 	lua api 
data path progress 	checknelems index 
path progress 	adr 
flag error err 	api checkvalidindex 
obj fsck 	setsvalue lua 
usage fsck opts 	lua settable 
argc argv 	lua unlock 
prefix heads alt 	lua api 
namelen name 	checknelems 
count progress 	index adr 
arg sha obj 	api check 
mode blob 	ttistable setobj 
obj strcmp git 	lua hvalue 
config pathname 	lua barriert 
strbuf addf free 	hvalue 
fsck msg 	lua unlock 
types strbuf release 	lua api 
skip prefix 	checknelems index 
fsck msg type 	adr api 
git config 	check ttistable 
oid hex objreport 	setobj 
objreport oid 	lua setnum 
hex objerror file 	hvalue lua 
oid hex 	barriert hvalue 
oid hex mark 	lua unlock 
parse fsck 	lua api 
walk free buffer 	checknelems 
start progress 	index adr 
delay traverse 	api checkvalidindex 
one display progress 	ttisnil api 
stop progress 	check ttistable 
sha pack file 	hvalue ttype 
oid hex 	hvalue 
oid hex oid 	lua objbarriert 
hex git 	hvalue uvalue 
pathdup oid hex 	lua objbarrier 
safe create 	rawuvalue ttype 
leading directories error 	lua unlock 
free fopen 	lua 
die errno stream 	api checknelems 
blob fileno 	index adr 
die errno oid 	api checkvalidindex 
hex fclose 	api check 
die errno free 	ttistable ttype 
oid hex 	clvalue 
check reachable check 	hvalue uvalue 
unreachable traverse 	hvalue sethvalue 
reachable max 	thvalue hvalue 
index indexed check 	lua objbarrier 
oid hex 	gcvalue hvalue 
fsck walk objerror 	lua 
fsck free 	unlock lua 
buffer free commit 	api checknelems 
buffer oid 	checkresults lua 
hex oid hex 	call adjustresults 
oid hex 	lua unlock 
parse error sha 	cast 
hex fsck 	lua call 
obj sha lookup 	lua api 
mark reachable 	checknelems checkresults 
error sha hex 	index adr 
sha hex 	api checkvalidindex 
sha hex fsck 	savestack 
handle reflog 	lua pcall 
sha fsck handle 	savestack adjustresults 
reflog sha 	lua unlock 
reflog ent 	cast lua 
parse error oid 	cclosure getcurrenv 
hex branch 	setclvalue 
error mark reachable 	api incr 
oid fsck 	top setpvalue 
handle rawref reflog 	api incr 
fsck sha 	top lua 
starts display progress 	call lua 
start progress 	lua 
loose file objdir 	pcall savestack 
display progress 	lua unlock 
stop progress resolve 	lua lua 
error strcmp 	init lua 
starts error oid 	protectedparser lua 
error parse 	unlock 
error sha hex 	lua api 
mark reachable 	checknelems lfunction 
objerror fsck cache 	lua dump 
parse options 	clvalue lua 
isatty git 	unlock lua 
config fsck head 	lua 
link fsck 	fullgc cast 
dir directory prepare 	cast cast 
alt odb 	lua step 
strbuf fsck dir 	lua unlock 
strbuf release 	lua api 
prepare packed git 	checknelems 
open pack 	lua errormsg 
index start progress 	lua unlock 
verify pack 	lua index 
stop progress sha 	adr api 
lookup mark 	check ttistable 
reachable error heads 	lua 
read cache 	next hvalue 
isgitlink lookup blob 	api incr 
mark reachable 	top lua 
fsck cache 	unlock lua 
check connectivity fatal 	api checknelems 
errors errors 	lua 
warnings infos reported 	check lua 
warnings ignored 	concat cast 
convert lower without 	setsvalue lua 
underscores entries 	newlstr api 
ordered path order 	incr top 
means directory 	lua 
entry ordered adding 	unlock lua 
slash end 	lua unlock 
directory called ordered 	lua lua 
file called 	unlock lua 
sorts first len 	lua check 
characters need 	lua 
order next one 	newudata getcurrenv 
turn directory 	setuvalue api 
entry git write 	incr top 
used write 	lua unlock 
nonsense entries 	ttisfunction clvalue 
name one blob 	getstr 
one make 	lua aux 
sure duplicate entries 	upvalue index 
standard modes 	adr setobj 
nonstandard early honored 	api incr 
full mode 	top lua 
bits find separates 	unlock 
header body 	lua index 
body crime want 	adr api 
see terminating 	checknelems aux 
last header line 	upvalue setobj 
shallow commit 	lua barrier 
early tags contain 	clvalue 
tagger lines 	lua unlock 
warn data type 	lapi roberto 
obj mark 	exp lua 
reachable calls callers 	api see 
function non 	copyright notice 
obj hence 	lua 
references parent fld 	pseudo indices 
safe reference 	enclosing function 
parent safe error 	use table 
already displayed 	environment stack 
check single reachable 	overflow basic 
obviously want 	stack 
parsed pack file 	manipulation subtract 
didn full 	index index 
fsck pack forget 	negative test 
check single 	incompatible code 
unreachable missing unreachable 	function upvalue 
ignore like 	access 
miss since reached 	functions stack 
want complain 	may call 
unreachable since exist 	tag method 
unreachable exists 	may call 
show asked since 	tag method 
something prunable 	lua 
used means 	tostring may 
nothing points including 	create conversion 
unreachable objects 	failed previous 
words tip unreachable 	call may 
objects usually 	reallocate stack 
commit got dropped 	lua 
starting points 	tostring may 
interesting random unreachable 	create push 
objects show 	functions stack 
even user hasn 	ensure functions 
asked unreachable 	lua stack 
objects deleted branch 	functions 
mistake prime 	stack lua 
candidate start looking 	pop index 
example otherwise 	pop load 
unreachable unreachable points 	call functions 
ignore interesting 	run lua 
showed interesting 	code 
cases traverse pending 	execute call 
reachable objects 	data call 
look requirements warn 	function called 
missing objects 	execute call 
rest despite error 	data ccall 
heads isn 	push 
really fatal mean 	function push 
unreachable longer 	argument garbage 
makes sense since 	collection function 
everything obviously 	values expressed 
unreachable definition showing 	kbytes bytes 
dangling objects 	end 
valid though dangling 	cycle signal 
objects likely 	invalid option 
lost heads print 	miscellaneous functions 
warning clear 	avoid warnings 
show unreachable flag 	elements key 
detached head 	push 
directory name 	empty nothing 
minus trailing slash 	lapi.h lapi 
verify gives 	roberto exp 
error messages error 	auxiliary functions 
printed lookup 	lua api 
given head information 	see 
ones git 	copyright notice 
refs also consider 	lua latency.c 
index file 	privdata key 
implies cache fsck.c 	key key 
downcased msg 	privdata val 
type text len 	latency 
fsck msg 	time series 
type options path 	dict type 
skiplist sorted 	buf latency 
buffer sha result 	prev reset 
str msg 	resets sum 
msg type options 	delta 
msg msg 	report advise 
type type 	better advise 
msg type options 	slowlog enabled 
values free 	advise slowlog 
done equal msg 	tuning advise 
report data 	slowlog 
options desc entry 	inspect advise 
res result 	disk contention 
commit data options 	advise scheduler 
parents res 	advise data 
result tag data 	writeback advise 
options obj 	appendfsync 
data options mode 	advise local 
name mode 	disk advise 
name len len 	ssd advise 
len cmp 	write load 
item options retval 	info advise 
sha full 	advise 
path empty name 	large objects 
dot dotdot 	advise mass 
dotgit zero 	eviction advise 
pad bad modes 	relax fsync 
dup entries 	policy advise 
properly sorted desc 	disable 
mode name 	thp advices 
mode name sha 	eventnum fork 
data size 	quality replylen 
obj options buffer 	last seq 
ident obj 	graph max 
options end commit 	elapsed 
buffer size 	buf graph 
options sha sha 	report resets 
graft parent 	unused strcmp 
count author count 	dict gen 
err commit 	hash function 
data size options 	strlen 
buffer ret 	fopen fgets 
tag data 	fclose fclose 
size options sha 	strstr zmalloc 
ret buffer 	smap bytes 
eol tag data 	field dict 
size options 	create 
tagged obj data 	dict fetch 
size options 	time zmalloc 
obj msg type 	memset dict 
message strlen 	zstrdup time 
xmalloc tolower strcmp 	dict safe 
open die 	iterator 
read full die 	dict next 
errno sha 	dict key 
hex die sha 	strcasecmp dict 
append hashcmp 	dict release 
close strcmp strcmp 	iterator dict 
strcmp die 	fetch 
parse msg parse 	time sdsempty 
msg type 	dict size 
parse msg 	sdscat dict 
die parse msg 	safe iterator 
type die 	dict next 
alloc fsck msg 	dict 
type xstrdup 	key dict 
strcspn tolower strcmp 	val sdscat 
die init 	analyze latency 
skiplist die fsck 	sdscatprintf strcasecmp 
msg type 	sdscatprintf strcasecmp 
free strbuf addch 	strcasecmp 
tolower strbuf 	strcasecmp strcasecmp 
addch strbuf addstr 	strcasecmp strcasecmp 
parse init 	strcasecmp strcasecmp 
desc entry isgitlink 	strcasecmp strcasecmp 
isdir walk 	strcasecmp strcasecmp 
lookup isreg islnk 	strcasecmp 
walk lookup 	sdscatlen dict 
blob error oid 	release iterator 
hex parse 	thp anon 
commit walk 	huge pages 
walk parse tag 	size sdscat 
walk fsck 	sdscat 
walk fsck walk 	sdscat sdscat 
commit fsck 	sdscatprintf sdscatprintf 
walk tag error 	sdscat sdscat 
oid hex 	sdscat sdscat 
strlen strlen memcmp 	sdscat sdscat 
isdir isdir 	sdscat 
init desc entry 	sdscat sdscat 
extract sha 	sdscat sdscat 
strchr strcmp strcmp 	sdscat sdscat 
strcmp hfs 	deferred multi 
dotgit ntfs dotgit 	bulk length 
update entry 	reply 
verify ordered report 	multi bulk 
report report 	len reply 
report report report 	reply deferred 
report report 	multi bulk 
report report 	length reply 
report report strchrnul 	multi 
report strcspn 	bulk len 
report report report 	dict size 
strcspn report 	dict iterator 
report report date 	dict next 
overflows strtoul 	dict key 
report report isdigit 	dict 
isdigit isdigit 	val reply 
isdigit report verify 	multi bulk 
headers skip 	len reply 
prefix report sha 	bulk reply 
hex report 	reply reply 
skip prefix sha 	dict 
hex report 	release iterator 
lookup commit graft 	create sparkline 
commit list 	sequence sdsempty 
count report report 	time snprintf 
skip prefix 	snprintf snprintf 
fsck ident 	snprintf 
report report skip 	sparkline sequence 
prefix report 	sample sdscatprintf 
fsck ident report 	sdscatlen sdscatlen 
sha hex 	sparkline render 
commit buffer fsck 	free 
commit buffer 	sparkline sequence 
unuse commit buffer 	strcasecmp dict 
read sha 	fetch reply 
file report report 	multi bulk 
verify headers 	len latency 
skip prefix report 	command 
sha hex 	reply samples 
report skip prefix 	strcasecmp dict 
report strchr 	find dict 
report type gently 	val dict 
report skip 	key latency 
prefix report 	command 
strchr report strbuf 	gen sparkeline 
addf check 	reply bulk 
refname format report 	sdsfree strcasecmp 
skip prefix 	latency command 
report fsck ident 	reply latest 
strbuf release 	events 
free report fsck 	strcasecmp create 
tag buffer 	latency report 
report fsck fsck 	reply bulk 
commit fsck 	buffer sdslen 
tag report warning 	sdsfree strcasecmp 
oid hex 	reply 
error oid hex 	latency reset 
fatal errors 	latency reset 
errors warnings infos 	reply reply 
reported warnings 	reply error 
ignored convert lower 	format latency 
without underscores 	monitor 
entries ordered 	allows easily 
path order means 	observe sources 
directory entry 	latency redis 
ordered adding slash 	instance latency 
end directory 	command different 
called ordered file 	latency 
called sorts 	sources monitored 
first len characters 	like disk 
need order 	execution commands 
next one turn 	fork system 
directory entry 	call forth 
git write used 	copyright 
write nonsense 	salvatore sanfilippo 
entries name one 	antirez gmail 
blob one 	dot rights 
make sure duplicate 	reserved redistribution 
entries standard 	use source 
modes nonstandard early 	binary 
honored full 	forms without 
mode bits 	modification permitted 
find separates header 	provided following 
body body 	conditions met 
crime want see 	redistributions source 
terminating last 	code 
header line shallow 	must retain 
commit early 	copyright notice 
tags contain tagger 	list conditions 
lines warn 	following disclaimer 
data type obj 	redistributions binary 
mark reachable 	form 
calls callers function 	must reproduce 
non obj 	copyright notice 
hence references parent 	list conditions 
fld safe 	following disclaimer 
reference parent safe 	documentation materials 
error already 	provided 
displayed check single 	distribution neither 
reachable obviously 	name redis 
want parsed 	names contributors 
pack file didn 	may used 
full fsck 	endorse promote 
pack forget check 	products 
single unreachable 	derived software 
missing unreachable ignore 	without specific 
like miss 	prior written 
since reached want 	permission software 
complain unreachable 	provided copyright 
since exist unreachable 	holders 
exists show 	contributors express 
asked since something 	implied warranties 
prunable used 	including limited 
means nothing points 	implied warranties 
including unreachable 	merchantability fitness 
objects words tip 	particular 
unreachable objects 	purpose disclaimed 
usually commit 	shall copyright 
got dropped starting 	owner contributors 
points interesting 	liable direct 
random unreachable objects 	indirect incidental 
show even 	special 
user hasn asked 	exemplary consequential 
unreachable objects 	damages including 
deleted branch mistake 	limited procurement 
prime candidate 	substitute goods 
start looking example 	services loss 
otherwise unreachable 	use 
unreachable points ignore 	data profits 
interesting showed 	business interruption 
interesting cases traverse 	however caused 
pending reachable 	theory liability 
objects look requirements 	whether contract 
warn missing 	strict 
objects rest despite 	liability tort 
error heads 	including negligence 
isn really 	otherwise arising 
fatal mean unreachable 	way use 
longer makes 	software even 
sense since everything 	advised 
obviously unreachable 	possibility damage 
definition showing dangling 	dictionary type 
objects valid 	latency events 
though dangling objects 	hash function 
likely lost 	key dup 
heads print warning 	val 
clear show 	dup key 
unreachable flag detached 	compare key 
head directory 	destructor val 
name minus trailing 	destructor utility 
slash verify 	functions returns 
gives error messages 	transparent 
error printed 	huge pages 
lookup given head 	support enabled 
information ones 	kernel otherwise 
git refs 	unable check 
also consider index 	returned report 
file implies 	amount 
cache show root 	anon huge 
show tags 	pages smap 
show unreachable include 	bytes function 
reflogs check 	non zero 
full connectivity check 	process targeted 
strict keep 	thp 
cache objects fsck 	support likely 
walk options 	memory usage 
fsck obj options 	latency issues 
head oid 	latency api 
head points errors 	latency monitor 
found write 	initialization 
lost found verbose 	need create 
show progress 	dictionary time 
show dangling path 	series time 
obj msg 	serie craeted 
type err 	demand order 
obj err obj 	avoid 
type message 	list maintain 
pending obj type 	specified sample 
data options 	specified time 
parent obj obj 	series function 
result progress 	usually called 
result entry obj 	via 
obj type 	latency sample 
data options obj 	needed macro 
obj filename 	adds sample 
obj max obj 	latency higher 
obj item 	server latency 
commit tag sha 	monitor 
obj fsck 	threshold create 
obj buffer refs 	time series 
refname sha 	exist previous 
obj osha 	sample second 
nsha email timestamp 	update old 
message data 	sample 
refname logname oid 	latency old 
flag data 	one reset 
refname oid flag 	data specified 
data obj 	events data 
sha path data 	note even 
basename path 	reset 
data path progress 	makes code 
path progress 	simpler small 
flag error err 	max number 
obj fsck 	events latency 
usage fsck opts 	reporting doctor 
argc argv 	analyze 
prefix heads alt 	samples avaialble 
namelen name 	given structure 
count progress arg 	populate different 
sha obj 	metrics average 
mode blob 	mad min 
obj strcmp git 	max 
config pathname 	forth check 
strbuf addf free 	latency definition 
fsck msg 	latenct stat 
types strbuf release 	info specified 
skip prefix 	elements structure 
fsck msg type 	populate 
git config 	zero values 
oid hex objreport 	first pass 
objreport oid 	populate everything 
hex objerror file 	mad track 
oid hex 	oldest time 
oid hex mark 	period 
parse fsck 	far avg 
walk free buffer 	actually sum 
start progress 	latencies period 
delay traverse one 	oldest time 
display progress 	need make 
stop progress 	first 
sha pack file 	average second 
oid hex 	range seconds 
oid hex oid 	second pass 
hex git 	compute mad 
pathdup oid hex 	create human 
safe create 	readable 
leading directories error 	report latency 
free fopen 	events redis 
die errno stream 	instance better 
blob fileno 	machines enable 
die errno oid 	slowlog reconfigure 
hex fclose 	slowlog 
die errno free 	check slowlog 
oid hex 	lower disk 
check reachable check 	contention intrinsic 
unreachable traverse 	latency data 
reachable max index 	writeback fsync 
indexed check 	rewrites 
oid hex 	avoid remote 
fsck walk objerror 	disks use 
fsck free 	ssd drive 
buffer free commit 	print info 
buffer oid 	aof write 
hex oid hex 	load 
oid hex 	use higher 
parse error sha 	deletion large 
hex fsck 	objects avoid 
obj sha lookup 	mass eviction 
mark reachable 	keys appendfsync 
error sha hex 	always 
sha hex 	slow anon 
sha hex fsck 	huge pages 
handle reflog 	detected asap 
sha fsck handle 	latency engine 
reflog sha 	disabled looks 
reflog ent parse 	like 
error oid 	never enabled 
hex branch 	far show 
error mark reachable 	events stats 
oid fsck 	related comment 
handle rawref reflog 	depending values 
fsck sha 	fork 
starts display progress 	potentially commands 
start progress 	fast command 
loose file objdir 	aof expire 
display progress 	cycle eviction 
stop progress resolve 	cycle non 
error strcmp 	advices 
starts error oid 	suggestions accumulated 
error parse 	far better 
error sha hex 	slow log 
mark reachable 	intrinsic latency 
objerror fsck cache 	aof disk 
parse options 	latency 
isatty git 	latency command 
config fsck head 	implementation latency 
link fsck 	command helper 
dir directory prepare 	produce time 
alt odb 	delay reply 
strbuf fsck dir 	samples 
strbuf release 	memory specified 
prepare packed git 	time series 
open pack 	latency command 
index start progress 	helper produce 
verify pack 	reply latest 
stop progress sha 	subcommand 
lookup mark 	listing last 
reachable error heads 	latency sample 
read cache 	every type 
isgitlink lookup blob 	registered far 
mark reachable 	update min 
fsck cache check 	max 
connectivity fatal 	use label 
errors errors 	number seconds 
warnings infos reported 	minutes hours 
warnings ignored 	days ago 
convert lower without 	happened latency 
underscores entries 	command 
ordered path order 	implementations latency 
means directory 	samples time 
entry ordered adding 	latency samples 
slash end 	specified latency 
directory called ordered 	latest latest 
file called 	latency 
sorts first len 	events classes 
characters need 	latency doctor 
order next one 	returns human 
turn directory 	readable analysis 
entry git write 	instance latency 
used write 	latency 
nonsense entries name 	graph provide 
one blob 	ascii graph 
one make 	latency specified 
sure duplicate entries 	latency history 
standard modes 	latency graph 
nonstandard early honored 	latency 
full mode 	latest latency 
bits find separates 	doctor latency 
header body 	reset common 
body crime want 	error user 
see terminating 	asks latency 
last header line 	information 
shallow commit 	latency.h time 
early tags contain 	latency idx 
tagger lines 	max samples 
warn data type 	time high 
obj mark 	avg min 
reachable calls callers 	max 
function non 	mad samples 
obj hence references 	period latency 
parent fld 	latency latency 
safe reference 	monitor api 
parent safe error 	header file 
already displayed 	see 
check single reachable 	latency information 
obviously want 	copyright salvatore 
parsed pack file 	sanfilippo antirez 
didn full 	gmail dot 
fsck pack forget 	rights reserved 
check single 	redistribution 
unreachable missing unreachable 	use source 
ignore like 	binary forms 
miss since reached 	without modification 
want complain 	permitted provided 
unreachable since exist 	following conditions 
unreachable exists 	met 
show asked since 	redistributions source 
something prunable 	code must 
used means 	retain copyright 
nothing points including 	notice list 
unreachable objects 	conditions following 
words tip unreachable 	disclaimer 
objects usually 	redistributions binary 
commit got dropped 	form must 
starting points 	reproduce copyright 
interesting random unreachable 	notice list 
objects show 	conditions following 
even user hasn 	disclaimer 
asked unreachable 	documentation materials 
objects deleted branch 	provided distribution 
mistake prime 	neither name 
candidate start looking 	redis names 
example otherwise 	contributors may 
unreachable unreachable points 	used 
ignore interesting 	endorse promote 
showed interesting cases 	products derived 
traverse pending 	software without 
reachable objects 	specific prior 
look requirements warn 	written permission 
missing objects 	software 
rest despite error 	provided copyright 
heads isn 	holders contributors 
really fatal mean 	express implied 
unreachable longer 	warranties including 
makes sense since 	limited implied 
everything obviously 	warranties 
unreachable definition showing 	merchantability fitness 
dangling objects 	particular purpose 
valid though dangling 	disclaimed shall 
objects likely 	copyright owner 
lost heads print 	contributors liable 
warning clear 	direct 
show unreachable flag 	indirect incidental 
detached head 	special exemplary 
directory name minus 	consequential damages 
trailing slash 	including limited 
verify gives 	procurement substitute 
error messages error 	goods 
printed lookup 	services loss 
given head information 	use data 
ones git 	profits business 
refs also consider 	interruption however 
index file 	caused theory 
implies cache fsck.h 	liability 
options msg 	whether contract 
msg type options 	strict liability 
values msg 	tort including 
msg type obj 	negligence otherwise 
type message 	arising way 
walk error func 	use 
msg type 	software even 
skiplist obj data 	advised possibility 
options obj 	damage history 
data size options 	length every 
callback function 	monitored representation 
fsck walk 	latency 
type expected type 	sample sampling 
obj everything 	time latency 
error signaled abort 	observed milliseconds 
error signaled 	use time 
abort callback fsck 	force bytes 
type fsck 	usage 
error fsck warn 	everywhere latency 
descend linked 	milliseconds latency 
child objects error 	time series 
processing callback 	given index 
lead abort first 	next sample 
signaled error 	store 
errors everything passed 	max latency 
data local 	observed latest 
read gc.c builtin 	history latency 
usage pack 	statistics structure 
refs prune 	absolute max 
reflogs aggressive depth 	observed 
aggressive window 	since latest 
threshold pack limit 	reset average 
detach prune 	current samples 
expire prune worktrees 	min current 
expire pack 	samples max 
refs cmd reflog 	current 
repack prune 	samples mean 
prune worktrees rerere 	absolute deviation 
pidfile log 	number non 
pack garbage seen 	zero samples 
bits path 	number seconds 
key output signo 	since 
path objdir 	first latency 
dir ent threshold 	monitoring macros 
num loose 	start monitoring 
needed cnt force 	current time 
ret pid 	end monitoring 
host pid 	compute 
pidfile path locking 	difference current 
host exit 	time check 
ret argc argv 	amount time 
prefix aggressive 	elapsed sample 
quiet force name 	elapsed time 
pid daemonized 	configured 
builtin options unlink 	threshold time 
warn list 	nested latency 
clear list append 	lauxlib.c narg 
git config 	extramsg narg 
strcmp approxidate approxidate 	tname msg 
git die 	narg 
config fstat file 	tag level 
commit file 	fmt argp 
rollback file fflush 	narg def 
process log 	lst name 
file process log 	tname 
file sigchain 	tname space 
pop git 	mes narg 
config strcmp git 	narg narg 
config git 	len narg 
config git config 	def len 
git config 	narg 
git config git 	narg def 
config git 	narg narg 
config date git 	def obj 
config date 	obj libname 
git config directory 	size libname 
snprintf warning 	nup 
opendir readdir strspn 	size topop 
closedir prepare 	wild idx 
packed git strcmp 	fname szhint 
argv push 	toget toplen 
argv push argv 	size fnameindex 
pushf many 	serr 
packs repack option 	filename filename 
many loose 	status readstatus 
objects run 	fnameindex size 
hook tempfile active 	buff size 
gethostname xsnprintf 	name ptr 
git pathdup hold 	osize 
file update 	nsize lua 
fopen memset fstat 	getstack lua 
fileno time 	error lua 
fscanf strcmp kill 	getinfo strcmp 
fclose rollback 	lua error 
file free strbuf 	lua 
addf getpid 	error lua 
write full strbuf 	pushfstring lua 
release commit 	lua argerror 
file tempfile free 	lua typerror 
strbuf read 	lua lua 
file git path 	getstack 
error git 	lua getinfo 
path strbuf release 	lua pushfstring 
run command 	lua pushliteral 
opt error 	start lua 
run command opt 	lua pushvfstring 
error strcmp 	end 
usage options argv 	lua concat 
pushl argv 	lua error 
pushl argv pushl 	lua optstring 
argv pushl 	lua checkstring 
argv pushl argv 	strcmp lua 
pushl config 	argerror 
bare repository parse 	lua pushfstring 
options usage 	lua getfield 
options argv push 	lua isnil 
argv pushf 	lua pop 
argv pushf argv 	lua newtable 
push need 	lua 
report last error 	pushvalue lua 
repack daemonize 	setfield lua 
repack option 	touserdata lua 
repo die hold 	getmetatable lua 
file update 	getfield lua 
git path dup 	rawequal 
file sigchain 	lua pop 
push common atexit 	lua typerror 
repack run 	lua checkstack 
command opt error 	lua error 
argv push 	lua type 
argv push run 	tag 
command opt 	error lua 
error argv push 	type lua 
run command 	argerror lua 
opt error run 	tolstring tag 
command opt 	error lua 
error reprepare packed 	isnoneornil 
git clean 	strlen lua 
pack garbage many 	checklstring lua 
loose objects 	tonumber lua 
warning git 	isnumber tag 
builtin command cleanup 	error lua 
unreachable files 	opt 
optimize repository copyright 	lua tointeger 
james bowes 	lua isnumber 
git copyright shawn 	tag error 
pearce quickly 	lua opt 
check needed estimating 	lua getmetatable 
many loose 	lua 
objects sha evenly 	pushstring lua 
distributed check 	rawget lua 
one reasonable estimate 	isnil lua 
perhaps check 	pop lua 
size pack count 	abs index 
small ones 	lua 
setting negative disable 	getmetafield lua 
automatic many 	pushvalue lua 
loose objects many 	call lua 
packs run 	openlib libsize 
repack many 	lua findtable 
packs run repack 	lua 
otherwise tell 	getfield lua 
caller need success 	istable lua 
hostname running 	pop lua 
already locked hour 	findtable lua 
limit generous 	error lua 
never take hand 	pushvalue 
really need 	lua setfield 
strict limit running 	lua lua 
one day 	insert lua 
late big problem 	pushvalue lua 
force used 	pushcclosure lua 
manual user verifies 	setfield 
running gentle 	lua pop 
concurrent remote hosts 	lua type 
least intrusive 	lua tointeger 
possible failure daemonize 	lua pop 
foreground quiet 	lua getfield 
get-tar-commit-id.c builtin 	lua 
tar commit usage 	isnil lua 
argc argv 	pop lua 
prefix buffer header 	newtable lua 
content comment 	pushvalue lua 
usage read full 	setmetatable lua 
die skip 	pushliteral 
prefix write full 	lua setfield 
die errno 	lua pushvalue 
copyright rene scharfe 	lua setfield 
ustar header 	abs index 
extended header content 	lua pushliteral 
gettext.c retval 	lua 
poison requested fmt 	rawget checkint 
buf ret 	lua pushliteral 
charset domain podir 	lua pushinteger 
utf getenv 	lua rawset 
setlocale strcmp 	getsizes lua 
strcmp getenv start 	pushvalue 
vsnprintf end 	lua pushinteger 
setlocale locale charset 	lua rawset 
bind textdomain 	lua pop 
codeset test vsnprintf 	abs index 
setlocale getenv 	lua pushliteral 
bindtextdomain setlocale setlocale 	lua 
init gettext 	rawget checkint 
charset textdomain strcmp 	getsizes lua 
utf strwidth 	pushvalue lua 
strlen copyright arnfj 	rawget checkint 
bjarmason guess 	lua objlen 
user preferred languages 	strlen 
language environment 	lua buffinit 
variable messages locale 	strstr lua 
category gettext 	addlstring lua 
defined result colon 	addstring lua 
separated list 	addstring lua 
like trick 	pushresult 
arranges messages emitted 	lua tostring 
user requested 	lua pushvalue 
encoding avoids setting 	strchr strlen 
ctype environment 	lua pushlstring 
whole program primarily 	lua rawget 
done avoid 	lua 
bug vsnprintf gnu 	isnil lua 
library triggered 	pop lua 
vsnprintf broken error 	createtable lua 
git repository 	pushlstring lua 
inspecting utf locale 	pushvalue lua 
commit contains 	settable 
iso encoded author 	lua istable 
name locale 	lua pop 
aware vsnprintf won 	lua bufflen 
interpolate format 	lua pushlstring 
argument due mismatch 	lua strlen 
data encoding 	lua 
locale even 	strlen lua 
wasn bug wouldn 	concat emptybuffer 
want use 	adjuststack lua 
ctype point require 	addchar lua 
auditing code 	addlstring strlen 
uses functions whose 	emptybuffer 
semantics modified 	lua concat 
ctype setting messages 	lua tolstring 
creates problem 	bufffree memcpy 
since declare encoding 	lua pop 
files gettext 	emptybuffer lua 
implementation recode user 	insert 
locale without 	adjuststack abs 
ctype emit something 	index lua 
like git 	isnil lua 
init icelandic locale 	pop lua 
til git 	rawgeti lua 
lind hlagh git 	tointeger 
gettext knows 	lua pop 
encoding file 	lua rawgeti 
haven told user 	lua rawseti 
encoding non 	lua objlen 
ascii characters encoded 	lua rawseti 
question marks 	abs 
luck ctype environment 	index lua 
call langinfo 	rawgeti lua 
bind textdomain codeset 	rawseti lua 
suffices tell 	pushinteger lua 
gettext encoding emit 	rawseti feof 
say til 	fread 
git lind hlagh 	strerror lua 
git equivalent 	tostring lua 
iso emitted iso 	pushfstring lua 
locale change 	lua gettop 
way advantages setting 	lua pushliteral 
ctype talk 	lua 
user language 	pushfstring fopen 
encoding without major 	errfile getc 
drawbacks changed 	getc getc 
semantics functions rely 	freopen errfile 
however foreign 	getc ungetc 
functions message catalogs 	lua 
aren neat 	load lua 
trick still problem 	tostring ferror 
call perror 	fclose lua 
include stdio include 	settop errfile 
locale include 	lua lua 
errno main setlocale 	load 
messages setlocale 	lua loadbuffer 
ctype errno enodev 	strlen free 
perror test 	realloc lua 
running give message 	tostring lua 
question marks 	newstate lua 
language utf test 	atpanic 
test kein 	lauxlib roberto 
passendes ger 	exp auxiliary 
gefunden vsnprintf bug 	functions building 
since glibc 	lua libraries 
could simply ctype 	see copyright 
environment would 	notice 
make things like 	lua file 
external perror 	uses official 
messages work see 	api lua 
gettext setlocale 	function declared 
sanity gettext tests 	could written 
regression tests 	application 
http sourceware bugzilla 	function free 
show bug 	list references 
cgi content type 	convert stack 
text plain 	index positive 
charset utf taken 	error report 
number columns 	functions 
current locale gettext.h 	stack frame 
strlen use 	count self 
gettext poison 	error self 
gettext ngettext copyright 	argument check 
arnfj bjarmason 	function level 
skeleton implementation gettext 	info 
git replace 	info information 
something uses libintl 	available registry 
wraps gettext 	name name 
translations mark msgid 	already use 
translation translate 	previous top 
strictly speaking lead 	create 
invalid used 	metatable registry 
way foo expand 	name metatable 
foo valid 	userdata metatable 
initializer right hand 	correct metatable 
side must 	correct metatables 
without parentheses many 	error 
compilers accept 	avoid warnings 
language extension allow 	avoid extra 
mistakes like 	test avoid 
msgs one 	extra test 
two three notice 	metatable metatable 
missing comma 	metafield 
one lines forcing 	metatable metafield 
compilation error 	check whether 
parenthesised one two 	lib already 
silently turned 	exists loaded 
onetwo git-compat-util.h interval 	libname found 
path path 	previous 
path path prefix 	result variable 
err err 	create one 
attribute attribute attribute 	exist loaded 
attribute attribute 	libname table 
die routine routine 	loaded table 
routine str 	move 
prefix str prefix 	library table 
buf len 	upvalues copy 
suffix suflen str 	upvalues top 
suffix len 	upvalues getn 
str suffix 	setn size 
len start length 	arrays 
prot flags 	size table 
offset start length 	nil create 
stat stat 	size metatable 
stat buf count 	metatable mode 
offset buf 	store numeric 
count haystack needle 	field 
herror haystack 	use use 
haystacklen needle needlelen 	sizes sizes 
str maxsize 	sizes sizes 
format str maxsize 	push prefix 
format src 	push replacement 
dst src dst 	place 
size handler 	pattern push 
str size size 	last suffix 
size data 	field nil 
len str 	table field 
len ptr size 	table field 
nmemb size 	field 
start length prot 	non table 
flags offset 	table problematic 
start length prot 	part name 
flags offset 	previous table 
path flags buf 	buffer manipulation 
len buf 	put 
len buf len 	nothing stack 
offset path 	number levels 
mode mode mode 	concat fit 
limit pattern 	buffer put 
name namesz sha 	stack put 
path len 	buffer 
offset src src 	stack stack 
len ret 	nil unique 
str len dst 	reference first 
max fmt 	free element 
tolower trans 	freelist stack 
tbl sane ctype 	free 
high lower 	element list 
result result nmemb 	freelist free 
size compar 	elements create 
path file err 	reference freelist 
path mode 	freelist load 
path path mode 	functions 
flag path 	index filename 
mode flag path 	stack unix 
time time 	exec file 
dir sep strrchr 	skip first 
strlen memcmp 	line binary 
strlen strip suffix 	file 
mem strip 	reopen binary 
suffix overflows die 	mode skip 
mult overflows 	eventual close 
die die xcalloc 	file even 
memcpy xstrdup 	errors ignore 
die sane 	results 
istest sane istest 	lua load 
strchr strtoul 	avoid warnings 
strtol derived linux 	lauxlib.h libname 
features test 	nup libname 
macro header convenience 	obj obj 
macros test 	narg 
versions gcc compatible 	tname numarg 
compiler use 	extramsg num 
like git gnuc 	arg num 
prereq code 	arg def 
requiring gcc later 	num arg 
endif see 	arg 
compiler known support 	def num 
flexible members 	arg arg 
empty empty older 	def msg 
gnu extension 	narg narg 
otherwise safer bit 	tname tname 
wasteful traditional 	lvl 
style build 	fmt narg 
zero build time 	def lst 
dependency expression 	filename buff 
cond compile time 	name idx 
condition must 	fname szhint 
compile fail condition 	lauxlib 
isn evaluated 	roberto exp 
compiler used expression 	auxiliary functions 
example define 	building lua 
foo foo foo 	libraries see 
build zero 	copyright notice 
offsetof foo arr 	lua 
degrades pointer 	extra error 
different type size 	code lua 
number elements 	load useful 
visible whose size 	macros buffer 
want work 	manipulation current 
pointers arrays 	position 
declared function parameters 	buffer number 
correct compiler 	stack level 
support usage cause 	compatibility compatibility 
build error 	system pre 
see build zero 	defined references 
macro integer 	lbaselib.c 
overflow undefined helper 	level opt 
macro detect 	level opts 
sum two integers 	optsnum res 
overflow requires 	status chunkname 
returns multiplication overflow 	fname size 
types must 	status 
match must note 	cname fname 
macro evaluates 	status status 
twice checks integer 	validproxy funcs 
bit approximation 	statnames narg 
length representation type 	status nres 
solaris xopen 	funcs 
extended header 	name lua 
file forces programs 	gettop lua 
xpg defeating 	getglobal lua 
xopen source setting 	pushvalue lua 
say xpg 	pushvalue lua 
xpg also solaris 	call 
xpg programs 	lua tostring 
must compiled compiler 	lua error 
non xpg 	lua lua 
programs must compiled 	fputs fputs 
pre compiler 	lua pop 
glibc aix need 	fputs 
open bsd 	lua optint 
needs islnk aix 	lua checkany 
needs min 	lua isnumber 
msvc stops windows 	lua pushnumber 
including winsock 	lua tonumber 
strcasecmp pull windows 	lua 
compatibility stuff 	checkstring lua 
ilp save 	argcheck strtoul 
bet however llp 	isspace lua 
llp needs 	pushnumber lua 
resp size needs 	pushnil lua 
match exceed 	optint 
take everybody aix 	lua settop 
defines list 	lua isstring 
source used mac 	lua lua 
systems netdb 	pushvalue lua 
would given systems 	concat lua 
systems limits 	error 
would given systems 	lua checkany 
gnu hurd 	lua getmetatable 
sentinel attribute valid 	lua pushnil 
gcc version 	lua getmetafield 
general helper functions 	lua type 
apple common 	lua 
crypto openssl callers 	checktype lua 
aware constant 	argcheck lua 
help gcc 	getmetafield lua 
wuninitialized analysis restrict 	error lua 
trick gcc 	settop 
though compilers may 	lua setmetatable 
support variadic 	lua isfunction 
macros since trying 	lua pushvalue 
help gcc 	lua optint 
anyway compilers fall 	lua checkint 
back function 	lua 
usual str begins 	argcheck lua 
found prefix 	getstack lua 
parameter str strlen 	argerror lua 
prefix point 	getinfo lua 
right prefix otherwise 	isnil lua 
untouched examples 	error 
extract branch name 	getfunc lua 
fail branch 	iscfunction lua 
skip prefix 	pushvalue lua 
refs heads branch 	getfenv lua 
skip prefix 	checktype getfunc 
present otherwise use 	lua 
whole skip 	pushvalue lua 
prefix name refs 	isnumber lua 
heads name 	tonumber lua 
buf ends suffix 	pushthread lua 
subtract length 	insert lua 
suffix len otherwise 	setfenv 
len untouched 	lua iscfunction 
str ends suffix 	lua setfenv 
len size 	lua error 
without suffix otherwise 	lua lua 
len size 	checkany lua 
note nul terminate 	checkany 
str length 	lua pushboolean 
mmap use win 	lua rawequal 
mmap mmap 	lua checktype 
use win 	lua checkany 
mmap must multiple 	lua settop 
pagesize mmap 	lua 
must multiple pagesize 	rawget lua 
mmap forward 	checktype lua 
decl remind twin 	checkany lua 
cache changes 	checkany lua 
function used compat 	settop lua 
pread include 	rawset 
cache functions help 	lua pushinteger 
allocate structs 	lua getgccount 
flex arrays copy 	lua checkoption 
data directly 	lua optint 
example foo bar 	lua lua 
name flex 	lua 
foo flex alloc 	pushnumber lua 
mem name 	pushboolean lua 
src len allocate 	pushnumber lua 
foo contents 	checkany lua 
src name 	pushstring lua 
field resulting automatically 	lua 
zero flex 	checktype lua 
field nul terminated 	settop lua 
whether incoming 	next lua 
src buffer flexptr 	pushnil lua 
variants operate 	checktype lua 
structs use flex 	pushvalue 
arrays want 	lua upvalueindex 
store pointer extra 	lua pushvalue 
data allocated 	lua pushnil 
block example foo 	lua checkint 
name bar 	lua checktype 
foo flex alloc 	lua 
str name 	pushinteger lua 
src name point 	rawgeti lua 
block memory 	isnil lua 
freed along pointer 	checktype lua 
repointed anywhere 	pushvalue lua 
str variants 	upvalueindex 
accept parameter rather 	lua pushvalue 
ptr len 	lua pushinteger 
combination note macros 	lua pushnil 
evaluate first 	lua insert 
parameter multiple times 	lua checklstring 
must assignable 	lua 
lvalue silence wuninitialized 	optstring load 
offset calculation 	aux lua 
ctype kwset users 	loadbuffer lua 
sane ctype 	optstring load 
locale works chars 	aux lua 
negative values 	loadfile 
would accepted strtoul 	lua checkstack 
since obvious 	lua pushvalue 
implementation list would 	lua call 
make pointer 	lua isnil 
stack frame simple 	lua isstring 
assignment work 	lua 
many systems 	replace lua 
portable preserves errno 	tolstring lua 
prints message 	error lua 
gives warning enoent 	optstring lua 
returns success 	checktype lua 
includes trying unlink 	settop 
exist tries 	lua load 
unlink file returns 	load aux 
unlink succeeded 	lua optstring 
file already didn 	lua gettop 
exist returns 	lua loadfile 
appends message err 	lua 
suitable error 	error lua 
err buf error 	call lua 
preserves errno 	gettop lua 
prints message gives 	checkany lua 
warning enoent 	toboolean lua 
returns success 	error 
includes trying directory 	lua optstring 
exist calls 	lua gettop 
correct function unlink 	lua checktype 
rmdir warn 	lua optint 
supplied file mode 	lua opt 
call access 	lua 
warn error missing 	getn lua 
file enoent 	checkstack lua 
enotdir warn inaccessible 	error lua 
file ought 	rawgeti lua 
accessible git-credential-gnome-keyring.c result 	rawgeti lua 
result user 	gettop 
data data done 	lua type 
done keyring 	lua tostring 
done result data 	lua pushinteger 
protocol host 	lua checkint 
port path username 	lua argcheck 
password name 	lua 
entries password 	checkany lua 
data result item 	pcall lua 
result entries 	gettop lua 
password data result 	pushboolean lua 
credential helper 	insert lua 
ops buf line 	gettop 
len key 	lua checkany 
key name basename 	lua settop 
argc argv 	lua insert 
ret cred main 	lua pcall 
context main 	lua pushboolean 
context iteration gnome 	lua 
keyring item 	replace lua 
wait request completion 	gettop lua 
strdup strdup 	checkany lua 
keyring gnome keyring 	callmeta lua 
find network 	type lua 
password sync free 	pushstring 
critical gnome 	lua tostring 
keyring result 	lua pushvalue 
message gnome keyring 	lua pushstring 
memory free 	lua toboolean 
gnome keyring memory 	lua pushliteral 
strdup strdup 	lua 
gnome keyring network 	pushfstring lua 
password list 	lua topointer 
free keyring gnome 	lua settop 
keyring network 	lua newuserdata 
password sync free 	lua toboolean 
critical gnome 	lua 
keyring result message 	isboolean lua 
keyring gnome 	newtable lua 
keyring find network 	pushvalue lua 
password sync 	pushboolean lua 
free critical gnome 	rawset lua 
keyring result 	upvalueindex 
message gnome keyring 	lua getmetatable 
item sync 	lua rawget 
gnome keyring 	lua upvalueindex 
network password list 	lua toboolean 
free critical 	lua pop 
gnome keyring result 	lua 
message memset 	argcheck lua 
free free free 	getmetatable lua 
free gnome 	setmetatable lua 
keyring memory free 	status lua 
credential init 	getstack lua 
gnome keyring memory 	gettop 
alloc fgets 	lua tothread 
strlen strchr warning 	lua argcheck 
gnome keyring 	lua pushstring 
memory free strcmp 	costatus costatus 
free strdup 	lua checkstack 
strcmp free strdup 	lua 
strrchr atoi 	error lua 
strcmp free 	pushfstring lua 
strdup strcmp free 	xmove lua 
strdup strcmp 	setlevel lua 
gnome keyring memory 	resume lua 
free gnome 	gettop 
keyring memory strdup 	lua checkstack 
gnome keyring 	lua error 
memory free credential 	lua xmove 
write item 	lua xmove 
credential write item 	lua tothread 
strrchr usage 	lua 
exit application name 	argcheck auxresume 
strcmp credential 	lua gettop 
read credential write 	lua pushboolean 
credential clear 	lua insert 
copyright john szakmeister 	lua pushboolean 
john szakmeister 	lua 
net philipp hartmann 	insert lua 
pah program 	tothread lua 
free software 	upvalueindex auxresume 
redistribute modify terms 	lua gettop 
gnu general 	lua isstring 
license published free 	lua 
software foundation 	lua insert 
either version license 	lua concat 
option later 	lua error 
version program distributed 	lua newthread 
hope useful 	lua argcheck 
without warranty without 	lua 
even implied 	isfunction lua 
warranty merchantability fitness 	iscfunction lua 
particular purpose 	pushvalue lua 
see gnu general 	xmove lua 
license details 	cocreate lua 
received copy gnu 	pushcclosure 
general license 	lua lua 
along program write 	gettop lua 
free software 	pushthread lua 
foundation inc 	pushnil lua 
temple place suite 	pushcfunction lua 
boston usa 	pushcclosure 
credits gnome keyring 	lua setfield 
api handling 	lua pushvalue 
originally written john 	lua setglobal 
szakmeister ported 	lua lua 
credential helper api 	pushliteral lua 
philipp hartmann 	setglobal 
modern gnome keyring 	auxopen auxopen 
support ancient 	lua createtable 
gnome keyring circ 	lua pushvalue 
rhel gnome 	lua setmetatable 
keyring seems introduced 	lua pushliteral 
gnome features 	lua 
roughly around gnome 	setfield lua 
months ubuntu 	pushcclosure lua 
used gnome think 	setglobal open 
sure distro 	lua lbaselib 
used existence 	roberto exp 
non existence gnome 	basic 
keyring seems 	library see 
like decent thing 	copyright notice 
use indicator 	lua system 
ancient gnome keyring 	support stdout 
returns denied 	function need 
entry found setting 	define 
match denied 	print function 
prevent reporting denied 	following model 
errors erase 	changing fputs 
operations still report 	put proper 
denied errors 	place console 
store support really 	window 
ancient gnome 	log file 
keyring circ rhel 	instance number 
guess glib 	arguments function 
version glib 	called print 
roughly gnome released 	result pop 
gnome keyring 	result 
credential api simplified 	standard conversion 
git credential 	least one 
gnome keyring functions 	valid digit 
create special 	skip trailing 
keyring option path 	spaces invalid 
given domain 	trailing 
authtype pick first 	characters number 
one list 	extra information 
sanity check storing 	metatable returns 
actually sensible 	either metatable 
particular make url 	field present 
without protocol 	metatable 
field without either 	function env 
host pathname 	change environment 
depending scheme primary 	current create 
key without 	argument isn 
username password 	one generator 
actually storing credential 	state 
domain authtype 	initial next 
sanity check actually 	generator state 
something match 	initial put 
input restrictive pattern 	error message 
technically blank 	nil plus 
credential means erase 	error 
everything easy 	message reader 
accidentally send since 	load function 
equivalent empty 	lua load 
input explicitly disallow 	uses stack 
require pattern 	stuff reader 
actual content match 	cannot 
domain authtype 	change stack 
pick first one 	top instead 
list matches 	keeps resulting 
table helper operation 	reserved slot 
callbacks used 	inside stack 
credential helper 	avoid 
main function credential 	warnings function 
functions ignore 	call save 
lines know mean 	reserved stack 
future proofs 	slot avoid 
later versions git 	warnings function 
learn lines 	eventual 
helpers updated match 	name plus 
write username 	one reserved 
password lookup operation 	slot empty 
callback unsupported 	range number 
operation given ignore 	elements means 
silently perform 	arith 
credential operation git-credential-osxkeychain.c 	overflow push 
protocol host 	arg avoiding 
path username password 	overflow problems 
port err 	push arg 
msg ret buf 	status results 
len item 	put 
list attr 	error function 
buf len item 	function called 
item buf 	status results 
colon argc argv 	metafield use 
usage start 	create proxy 
vsnprintf end exit 	metatable 
strdup die 	create metatable 
fwrite putchar sec 	mark valid 
keychain item 	metatable weaktable 
copy content write 	check weaktable 
item sec 	metatable metatable 
keychain item free 	valid 
content sec 	coroutine library 
keychain find internet 	running suspended 
password write 	normal resumed 
item find username 	another coroutine 
item sec 	frames running 
keychain item free 	initial 
content sec 	state error 
keychain find 	occured error 
internet password sec 	flag move 
keychain item 	yielded values 
sec keychain internet 	move error 
password keychain 	message 
item fgets strcmp 	error flag 
strlen strchr 	error message 
die strcmp strcmp 	resume returns 
strcmp strcmp 	error extra 
strcmp strcmp strcmp 	info propagate 
strcmp exit 	error 
strcmp strchr atoi 	move function 
xstrdup strcmp 	top move 
xstrdup strcmp xstrdup 	function main 
strcmp xstrdup 	coroutine open 
die read credential 	lib table 
strcmp find 	version 
internet password 	ipairs pairs 
strcmp internet password 	need auxiliary 
strcmp internet 	functions upvalues 
password keychain account 	newproxy needs 
domain require 	weaktable upvalue 
least protocol host 	table 
removal git 	metatable metatable 
give want something 	mode newproxy 
fancy use 	lcode.c previous 
keychain manager store 	pfrom pto 
complete credentials 	jpc first 
yet handle protocols 	nret 
otherwise ignore 	dest jmp 
unknown action git-credential-wincred.c 	offset offset 
err msg 	list node 
size ret advapi 	reg list 
cred write 	list vtarget 
cred enumerate cred 	reg 
free cred 	dtarget next 
wusername password 	list target 
protocol host path 	list list 
target wbuf 	next newstack 
wlen buf len 	reg idx 
str find 	oldsize 
pos ptarget want 	nresults jump 
delim last 	reg reg 
delim pos start 	key func 
len ptarget 	cond temp 
want delim ptarget 	cond temp 
want delim 	line 
cred target creds 	line nelems 
num creds 	tostore opcode 
cred creds num 	getarg getarg 
creds str 	setarg lua 
wlen wstr buf 	code abc 
len argc 	lua 
argv usage start 	code lua 
vsnprintf end 	concat lua 
exit malloc 	code abc 
malloc die load 	lua code 
library die 	abc lua 
proc address proc 	jump 
address proc 	lua abs 
address proc address 	lua syntaxerror 
die wide 	setarg getarg 
multi xmalloc wide 	test mode 
multi die 	opcode getjump 
fwrite putchar free 	getjumpcontrol 
wcsstr wcsstr 	opcode getjumpcontrol 
wcsstr last wcsstr 	opcode getarg 
wcslen wcslen 	setarg create 
wcslen wcsncmp match 	abc getarg 
part last 	getarg getjump 
match part last 	patchtestreg 
wcscmp match 	getjump patchtestreg 
part match part 	fixjump fixjump 
match part 	patchlistaux lua 
last match 	patchtohere lua 
part match part 	patchlistaux lua 
cred enumerate 	getlabel 
match cred write 	lua concat 
item wcslen 	getjump fixjump 
write item cred 	lua syntaxerror 
free wcslen 	cast lua 
cred write die 	checkstack isk 
cred enumerate 	lua 
match cred cred 	freereg lua 
cred free 	ttisnumber lua 
multi wide xmalloc 	lua rawequal 
multi wide 	obj cast 
fgets strlen strchr 	nvalue cast 
strchr die 	nvalue 
strcmp utf utf 	setnvalue cast 
dup strcmp 	num lua 
utf utf 	growvector setnilvalue 
dup strcmp utf 	setobj lua 
utf dup 	barrier setsvalue 
strcmp utf utf 	addk 
dup strcmp 	setnvalue addk 
utf utf dup 	setbvalue addk 
die die 	setnilvalue sethvalue 
setmode fileno setmode 	addk setarg 
fileno read 	getcode setarg 
credential load cred 	getcode 
funcs wcscpy 	setarg getcode 
wcsncat size wcsncat 	lua reserveregs 
size wcsncat 	getarg getcode 
size wcsncat size 	setarg getcode 
wcsncat size 	lua 
wcsncat size wcsncat 	code abc 
size strcmp 	lua code 
credential strcmp store 	freereg freereg 
credential strcmp 	lua code 
erase credential 	abc lua 
git credential helper 	setoneret 
windows credential 	lua getlabel 
manager common helpers 	lua code 
min doesn 	abc lua 
wincred need define 	dischargevars lua 
stuff load 	nil lua 
function pointers match 	code 
optional expected 	abc lua 
delimiter target consuming 	code lua 
matched text 	code lua 
updating target pointer 	number getcode 
find start 	setarg lua 
delimiter end delim 	code 
empty match 	abc lua 
text delimiter end 	lua reserveregs 
host optional 	discharge reg 
followed path update 	discharge reg 
ptarget either 	lua concat 
found delimiter 	hasjumps 
need match search 	need need 
first credential 	lua jump 
matches username strip 	code label 
trailing git 	code label 
use binary pipes 	lua patchtohere 
avoid crlf 	lua 
issues prepare target 	getlabel patchlistaux 
unique key 	patchlistaux lua 
credential otherwise ignore 	dischargevars freeexp 
unknown action 	lua reserveregs 
git.c git usage 	exp reg 
git info 	lua 
git startup info 	dischargevars hasjumps 
use pager 	exp reg 
orig cwd env 	lua exp 
names orig 	nextreg hasjumps 
env save restore 	lua exp 
env balance 	anyreg 
external argv 	lua dischargevars 
argc envchanged orig 	lua exp 
argv cmd 	val nil 
cwd argcp argv 	lua number 
saved errno 	rkask rkask 
count option count 	lua 
argv command 	exp anyreg 
unused nongit child 	freeexp exp 
cmd option 	reg lua 
argc argv status 	exp anyreg 
help prefix 	lua code 
nongit commands argv 	abc 
len argc 	lua exp 
argv cmd builtin 	anyreg lua 
argv cmd 	code lua 
tmp status argcp 	exp lua 
argv done 	code abc 
unblock argc 	lua 
argv cmd done 	freeexp lua 
help xgetcwd 	exp anyreg 
size getenv xstrdup 	freeexp lua 
chdir die 	reserveregs lua 
errno free size 	code abc 
strcmp setenv 	lua 
free unsetenv setenv 	exp freeexp 
setup pager 	getjumpcontrol lua 
strcmp strcmp skip 	test mode 
prefix git 	opcode opcode 
argv exec path 	opcode setarg 
puts git 	getarg 
exec path exit 	getcode opcode 
strcmp puts 	condjump getarg 
system path exit 	discharge anyreg 
strcmp puts 	freeexp condjump 
system path exit 	lua dischargevars 
strcmp puts 	invertjump 
system path 	jumponcond lua 
exit strcmp strcmp 	concat lua 
strcmp strcmp 	patchtohere lua 
setenv strcmp usage 	dischargevars jumponcond 
setenv skip 	lua concat 
prefix setenv strcmp 	lua 
usage setenv 	patchtohere lua 
skip prefix setenv 	dischargevars invertjump 
strcmp usage 	discharge anyreg 
setenv skip prefix 	freeexp lua 
setenv strcmp 	code abc 
xgetcwd setenv free 	lua 
setenv strcmp 	removevalues removevalues 
usage git config 	lua exp 
push parameter 	isnumeral isnumeral 
strcmp setenv strcmp 	luai numadd 
setenv strcmp 	luai numsub 
setenv strcmp setenv 	luai 
strcmp setenv 	nummul luai 
strcmp alternate 	numdiv luai 
shallow file strcmp 	nummod luai 
usage chdir 	numpow luai 
die errno usage 	numunm lua 
save env 	luai 
setup git directory 	numisnan constfolding 
gently lookup 	lua exp 
commit pager choice 	lua exp 
restore env 	freeexp freeexp 
argv push argv 	freeexp freeexp 
pushv run 	lua 
command exit die 	code abc 
errno split 	lua exp 
cmdline die split 	lua exp 
cmdline strerror 	freeexp freeexp 
handle options die 	condjump isnumeral 
memmove die 	lua 
strcmp die trace 	exp anyreg 
argv realloc 	codearith codenot 
memcpy restore 	lua exp 
env strcmp setup 	anyreg codearith 
git directory 	lua lua 
setup git directory 	goiftrue 
gently check 	lua goiffalse 
pager config trace 	lua exp 
repo setup 	nextreg isnumeral 
commit pager choice 	lua exp 
setup work 	lua exp 
trace argv fstat 	lua 
fileno isfifo 	lua dischargevars 
issock fflush die 	lua concat 
errno ferror 	lua lua 
die fclose die 	dischargevars lua 
errno size 	concat lua 
strcmp builtin strip 	exp 
suffix xmemdupz 	val opcode 
strip extension strcmp 	getcode lua 
builtin exit 	getarg getcode 
run builtin 	freeexp setarg 
check pager config 	getcode lua 
commit pager 	exp 
choice strbuf addf 	nextreg codearith 
trace argv 	codearith codearith 
run command opt 	codearith codearith 
exit strbuf 	codearith codearith 
release handle builtin 	codecomp codecomp 
execv dashed 	codecomp 
external handle sigemptyset 	codecomp codecomp 
sigaddset sigprocmask 	codecomp lua 
signal git extract 	dischargejpc lua 
argv path 	growvector lua 
sanitize stdfds restore 	growvector lua 
sigpipe git 	mode 
setup gettext trace 	lua mode 
command performance 	lua mode 
skip prefix 	lua code 
handle builtin die 	create abc 
handle options 	lua mode 
skip prefix commit 	mode 
pager choice 	lua mode 
list common cmds 	lua code 
help exit 	create lua 
setup path run 	lua code 
argv exit 	abc lua 
help unknown cmd 	code 
strerror legacy 	abc lua 
reasons version help 	code cast 
commands written 	lcode roberto 
prepended make look 	exp code 
like flags 	generator lua 
check remaining flags 	see 
normal exit 	copyright notice 
insert command name 	lua jumps 
require working 	current position 
present anything 	function start 
uses needs run 	positions already 
setup reading 	clean 
configuration file git 	connect optimization 
dir may 	save list 
repo avoid somebody 	jumps keep 
closed stdout 	hold returns 
ignore write errors 	current marks 
pipes sockets 	jump 
check enospc eio 	target avoid 
errors turn 	wrong optimizations 
git cmd help 	consecutive instructions 
git help 	basic block 
cmd argv must 	point represents 
git command 	end 
argv belongs caller 	list end 
may reused 	list turn 
subsequent loop iterations 	offset absolute 
save argv 	position check 
restore error 	whether list 
fail command found 	jump 
otherwise pass 	produce produce 
along status code 	inverted found 
tried futzed 	cannot patch 
environment longer safe 	instructions put 
invoke builtins 	already jump 
directly general spawn 	target 
dashed externals 	find last 
needswork figure cases 	element constant 
safe avoid 	found create 
spawning process external 	entry cannot 
ones could 	use nil 
works around insanity 	key 
overriding git 	instead use 
log git show 	table represent 
log show 	nil expression 
many parts git 	open function 
subprograms communicate 	call expression 
via pipe 	open 
expect upstream pipe 	function call 
die sigpipe 	relocate simple 
downstream pipe need 	result one 
read written 	available somewhere 
third party programs 	instructions may 
ignore block 	jump 
sigpipe reason forget 	targets nothing 
restore sigpipe 	put jump 
handling spawning git 	list position 
carefully orchestrated 	whole expression 
machinery restore way 	position eventual 
sigpipe handled 	load 
expect always open 	position eventual 
file descriptors 	load exp 
avoid clobbering files 	already reg 
die also 	local put 
avoids messing 	constant fit 
pipes dup onto 	operand 
stdin stdout 	constant fit 
stderr child processes 	arg constant 
spawn git 	right range 
xxxx git xxxx 	put invalid 
obviously cannot 	kind store 
take flags git 	previous 
xxxx cannot 	last jump 
execute externally since 	always nothing 
would thing 	insert last 
directly call builtin 	jump list 
handler die 	last jump 
one cannot handle 	always 
look flags 	nothing insert 
translate help version 	last jump 
commands user 	list cannot 
didn specify command 	happen interchange 
give help 	lists attempt 
use path 	divide 
find git commands 	attempt divide 
prepend higher 	constant folding 
precedence paths exec 	len attempt 
path option 	produce exchange 
git exec path 	args replace 
environment gitexecdir 	cannot 
makefile build time 	operate non 
gmtime.c timep 	numeric constants 
result timep result 	cannot operate 
ret git 	constants operand 
gmtime memset gmtime 	must stack 
rather free 	list 
bsd gmtime simply 	must closed 
leaves untouched 	list must 
encounters overflow since 	closed operand 
mday cannot 	must stack 
otherwise zero test 	change put 
quickly gpg-interface.c 	instruction 
configured signing 	code save 
key gpg program 	corresponding line 
sigc result 	information free 
check sigc buf 	registers list 
found next 	values lcode.h 
payload plen signature 	line 
slen sigc 	key nresults 
gpg output gpg 	first nret 
status status 	list target 
sigc flags output 	list nelems 
buf size 	tostore lcode 
eol len key 	roberto 
buffer signature 	exp code 
signing key gpg 	generator lua 
args len 	see copyright 
bottom payload payload 	notice lua 
size signature 	marks end 
signature size gpg 	patch 
output gpg 	list invalid 
status gpg 	absolute address 
args gpg path 	list link 
ret buf 	would link 
pbuf free free 	element grep 
free free 	order 
free size skip 	opr change 
prefix strstr 	enums ldblib.c 
strlen xmemdupz strchrnul 	arg fname 
xmemdupz verify 	arg options 
buffer xmemdupz strbuf 	arg name 
detach strbuf 	arg 
detach parse gpg 	name key 
output strbuf 	hook hooknames 
release strbuf release 	smask count 
fputs fputs 	mask mask 
starts starts memchr 	smask arg 
free xstrdup 	mask 
strcmp signing 	count func 
key strcmp config 	smask arg 
error nonbool 	buff mask 
xstrdup git committer 	hook buffer 
info start 	level firstpart 
command error sigchain 	arg 
push write 	dblib lua 
full close close 	pushvalue lua 
finish command 	checkany lua 
error close strbuf 	getmetatable lua 
read close 	pushnil lua 
sigchain pop finish 	type 
command error 	lua argcheck 
strbuf setlen git 	lua settop 
mkstemp error 	lua pushboolean 
strerror write full 	lua setmetatable 
error strerror 	lua checkany 
close start command 	lua 
unlink error 	getfenv lua 
write full 	checktype lua 
close strbuf read 	settop lua 
close strbuf 	setfenv lua 
read close finish 	error lua 
command unlink 	lua 
warn strstr strbuf 	pushstring lua 
release iterate 	setfield lua 
search trust messages 	pushinteger lua 
followed key 	setfield lua 
signer information look 	isthread lua 
gpg content 	tothread 
tag whose payload 	lua pushvalue 
followed detached 	lua lua 
signature offset embedded 	xmove lua 
detached signature 	setfield getthread 
begins end data 	lua optstring 
signature create 	lua 
detached signature contents 	isnumber lua 
buffer append 	getstack lua 
signature buffer 	tointeger lua 
signature strbuf instance 	pushnil lua 
would cause 	isfunction lua 
detached signature appended 	pushfstring 
end username 	lua tostring 
signingkey bad program 	lua pushvalue 
could terminated 	lua xmove 
gpg exits without 	lua argerror 
reading write 	lua getinfo 
gets sigpipe strip 	lua 
line endings 	argerror lua 
windows run gpg 	createtable strchr 
see payload 	settabss settabss 
matches detached signature 	settabsi settabsi 
gpg output 	settabss strchr 
receives diagnostic output 	settabsi 
gpg gpg 	strchr settabsi 
status receives status 	strchr settabss 
output gpg 	settabss strchr 
matter used 	treatstackoption strchr 
gpg-interface.h payload gpg 	treatstackoption getthread 
output gpg 	lua 
status result signer 	getstack lua 
key sigc 	checkint lua 
buf size signature 	argerror lua 
check buffer 	getlocal lua 
signature signing key 	checkint lua 
payload payload 	xmove 
size signature signature 	lua pushstring 
size gpg 	lua pushvalue 
output gpg status 	lua pushnil 
payload plen 	getthread lua 
signature slen sigc 	getstack lua 
sigc flags 	checkint 
possible result result 	lua argerror 
untrusted good 	lua checkany 
good bad graph.c 	lua settop 
graph graph 	lua xmove 
show strbuf 	lua pushstring 
commit color column 	lua 
colors column 	setlocal lua 
colors max colors 	checkint lua 
colors max 	checkint lua 
color col commit 	checktype lua 
revs num 	iscfunction lua 
parents width expansion 	getupvalue 
row commit 	lua setupvalue 
index prev commit 	lua pushstring 
index column 	lua insert 
capacity num columns 	auxupvalue lua 
num columns 	checkany auxupvalue 
mapping size columns 	lua 
columns mapping 	pushlightuserdata lua 
mapping column color 	rawget lua 
opt data 	pushlightuserdata lua 
graph msgbuf 	rawget lua 
opt graph graph 	isfunction lua 
update state 	pushstring 
graph num columns 	lua pushinteger 
graph commit 	lua pushnil 
graph orig list 	lua lua 
graph parents 	getinfo lua 
graph graph graph 	call strchr 
commit graph 	strchr 
commit mapping index 	strchr lua 
graph commit 	pushlightuserdata lua 
existing columns max 	rawget lua 
cols graph 	istable lua 
parent tmp columns 	pop lua 
max columns 	createtable 
mapping idx seen 	lua pushlightuserdata 
commit columns 	lua pushvalue 
col commit old 	lua rawset 
mapping idx 	getthread lua 
graph commit 	isnoneornil lua 
parent graph target 	settop 
graph chars 	lua checkstring 
written extra graph 	lua checktype 
graph graph 	lua optint 
num expansion rows 	makemask gethooktable 
seen chars 	lua pushlightuserdata 
written col graph 	lua 
graph dashless 	pushvalue lua 
commits col num 	rawset lua 
num dashes 	pop lua 
graph seen chars 	sethook getthread 
written col 	lua gethookmask 
col commit graph 	lua 
commit graph 	gethook lua 
seen chars written 	pushliteral gethooktable 
col col 	lua pushlightuserdata 
commit parents par 	lua rawget 
column graph 	lua lua 
tmp mapping 	pushstring 
used horizontal horizontal 	unmakemask lua 
edge horizontal 	pushinteger lua 
edge target target 	gethookcount fputs 
target graph 	fgets strcmp 
graph col graph 	lua 
commit finished 	loadbuffer strlen 
graph msgbuf shown 	lua pcall 
commit line 	fputs lua 
graph msgbuf graph 	tostring fputs 
msgbuf graph 	lua settop 
msgbuf shown graph 	getthread 
show strbuf 	lua isnumber 
graph show commit 	lua tointeger 
msg strbuf 	lua pop 
addstr column color 	lua gettop 
code strbuf 	lua pushliteral 
addch strbuf addstr 	lua 
column color 	isstring lua 
code strbuf 	pushliteral lua 
reset graph padding 	pushliteral lua 
line xmalloc 	getstack lua 
graph column colors 	getstack lua 
alloc alloc 	pushliteral 
alloc alloc realloc 	lua getstack 
realloc realloc 	lua pushliteral 
realloc commit action 	lua getinfo 
graph interesting 	lua pushfstring 
graph interesting next 	lua pushfstring 
interesting parent 	lua 
want color graph 	pushfstring lua 
current column 	pushfstring lua 
color graph find 	pushliteral lua 
commit color 	pushfstring lua 
graph ensure capacity 	concat lua 
first interesting 	gettop 
parent next 	lua concat 
interesting parent graph 	lua gettop 
increment column 	lua ldblib 
color graph insert 	roberto exp 
columns graph 	lua debug 
insert columns graph 	api 
update width 	see copyright 
first interesting parent 	notice lua 
next interesting 	metatable level 
parent graph update 	range table 
columns strbuf 	range range 
addf strbuf write 	cannot 
column strbuf 	touch upvalues 
addch graph pad 	lua turn 
horizontally strbuf 	hooks hook 
addstr graph pad 	hook table 
horizontally graph 	hooks external 
update state graph 	hook 
update state 	hook hook 
strbuf write 	table eventual 
column strbuf addf 	returns size 
strbuf write 	first part 
column strbuf write 	stack size 
column strbuf 	second 
write column strbuf 	part stack 
write column 	still eventual 
strbuf addch graph 	level may 
pad horizontally 	function message 
graph update state 	levels levels 
strbuf addch 	keep 
strbuf addstr revision 	going many 
mark strbuf 	levels find 
write column strbuf 	last levels 
write column 	name main 
graph output commit 	function tail 
graph draw 	call 
octopus merge strbuf 	ldebug.c name 
write column 	func mask 
strbuf write 	count level 
column strbuf write 	status name 
column strbuf 	limit name 
write column strbuf 	name 
addch graph 	lineinfo status 
pad horizontally graph 	status func 
update state 	check arg 
graph mapping correct 	mode lastpc 
graph update 	reg last 
state graph update 	dest 
state first 	dest nup 
interesting parent find 	stackpos name 
column commit 	name name 
strbuf write column 	kind temp 
next interesting 	msg buff 
parent find column 	line 
commit strbuf 	errfunc fmt 
write column strbuf 	argp lua 
addch strbuf 	rel func 
write column 	currentpc getline 
strbuf addch strbuf 	func resethookcount 
write column 	cast 
strbuf addch graph 	lua lua 
pad horizontally 	cast lua 
graph mapping correct 	unlock lua 
graph update 	func getluaproto 
state graph update 	lua getlocalname 
state strbuf 	currentpc 
addch strbuf write 	findlocal lua 
column strbuf 	lua pushobject 
write column strbuf 	lua unlock 
write column 	findlocal lua 
graph pad horizontally 	setobjs lua 
graph mapping 	unlock 
correct graph update 	getstr lua 
state graph 	chunkid lua 
output padding 	chunkid setnilvalue 
line graph output 	lua setbvalue 
skip line 	lua setnum 
graph output pre 	sethvalue 
commit line 	incr top 
graph output commit 	info tailcall 
line graph 	funcinfo currentline 
output post merge 	getfuncname lua 
line graph 	luai apicheck 
output collapsing line 	ttisfunction 
graph next 	clvalue lua 
line strbuf write 	ttisfunction clvalue 
column strbuf 	auxgetinfo strchr 
addchars strbuf addch 	setnilvalue setclvalue 
graph pad 	incr top 
horizontally graph commit 	strchr 
finished graph 	collectvalidlines lua 
show padding graph 	unlock check 
commit finished 	check check 
graph next 	check check 
line fwrite putchar 	check opcode 
strbuf setlen 	opcode 
strbuf release graph 	check getarg 
next line 	check precheck 
fwrite strbuf release 	opcode getarg 
graph padding 	check checkreg 
line fwrite strbuf 	mode getarg 
release graph 	getarg 
commit finished graph 	check check 
next line 	arg mode 
fwrite strbuf setlen 	mode check 
graph commit 	check arg 
finished putchar strbuf 	mode mode 
release api 	getarg 
output padding line 	mode check 
graph similar 	getarg mode 
graph next line 	check opcode 
however guaranteed 	getarg check 
never print 	test mode 
current commit line 	test 
instead commit 	mode check 
line next simply 	check opcode 
output line 	check check 
vertical padding extending 	opcode getarg 
branch lines 	check check 
downwards leaving otherwise 	ttisstring 
unchanged print 	checkreg check 
strbuf stdout graph 	check checkreg 
non lines 	checkreg checkreg 
first prefixed graph 	check checkopenop 
output strbuf 	checkreg checkreg 
ends newline output 	checkreg 
end newline 	check check 
graph line printed 	check opcode 
newline strbuf 	check check 
empty output printed 	check checkopenop 
since first 	checkreg symbexec 
line include 	isk 
graph output caller 	ttisstring indexk 
responsible printing 	svalue indexk 
line graph perhaps 	lua func 
via graph 	currentpc lua 
show commit graph 	getlocalname symbexec 
show oneline 	lua 
calling graph show 	opcode getarg 
strbuf todo 	lua ttisstring 
limit number columns 	svalue getarg 
similar way 	getarg getobjname 
gitk reach specified 	getarg kname 
number columns 	getarg 
omit sections columns 	getstr getarg 
parent commit 	kname lua 
column color optionally 	lua func 
print column 	currentpc opcode 
index column colors 	opcode opcode 
commit currently 	getobjname 
processed rev 	getarg ttype 
info used current 	isinstack getobjname 
traversal number 	cast lua 
interesting parents commit 	runerror lua 
note actual 	runerror ttisstring 
number parents count 	ttisnumber 
excludes parents 	lua ttisstring 
won printed graph 	ttisnumber lua 
output determined 	typeerror lua 
graph interesting width 	tonumber lua 
graph output 	typeerror ttype 
commit rows commit 	ttype 
padded width 	lua runerror 
messages printed graph 	lua runerror 
output aligned 	lua currentline 
next expansion row 	lua chunkid 
print state 	getstr getluaproto 
graph pre 	lua 
commit current output 	pushfstring restorestack 
state tells 	ttisfunction lua 
kind line graph 	setobjs setobjs 
next line 	incr top 
output output state 	lua call 
previous line 	lua 
output primarily used 	start addinfo 
determine first 	lua pushvfstring 
merge line appear 	end lua 
last line 	errormsg ldebug 
previous commit index 	roberto exp 
column refers 	debug 
commit none incoming 	see copyright 
columns refer 	notice lua 
commit equal num 	function lua 
columns commit 	function active 
index previously displayed 	lua functions 
commit used 	current 
determine first 	line information 
line merge graph 	function called 
output appear 	asynchronous signal 
last line previous 	turn hooks 
commit maximum 	lua function 
number columns stored 	skip 
columns columns 	lost tail 
arrays also half 	calls level 
number entries 	found level 
stored mapping mapping 	lost tail 
arrays number 	call level 
columns also called 	local 
branch lines 	variable lua 
places number columns 	function inside 
columns number 	stack pop 
entries mapping column 	found handled 
state output 	lua getinfo 
current commit column 	invalid 
state output 	option skip 
current commit 	pop function 
valid state graph 	tail call 
collapsing tracks 	symbolic execution 
current state character 	code checker 
output line 	invalid 
state graph collapsing 	instruction open 
entry character 	call stores 
empty non negative 	position last 
integer character 	instruction changed 
contains branch line 	reg points 
integer indicates 	neutral 
target position branch 	instruction check 
line maps 	jump setlist 
current column positions 	count tricky 
desired positions 	count previous 
maximum capacity always 	setlist may 
column capacity 	invalid 
temporary computing next 	setlist must 
mapping state 	way back 
outputting mapping 	first even 
line stored part 	previous setlist 
git graph 	even looks 
simply allocate temporary 	like 
time output 	one change 
collapsing line current 	check skip 
column color 	jump check 
used stored index 	jump registers 
column colors 	least two 
start column color 	operands 
maximum since 	least one 
always increment first 	result control 
commit output 	variable space 
way start first 	results affect 
commit allocate 	regs full 
reasonably large number 	check 
columns automatically 	jump forward 
grow columns 	skip lastpc 
later need room 	jump num 
diff output 	returns affect 
prefix callback make 	registers num 
diff output 	returns 
align graph lines 	tracing execute 
returns commit 	pseudo instructions 
printed graph output 	lua function 
otherwise revs 	local symbolic 
boundary commits whose 	execution index 
children shown 	move 
always interesting even 	name key 
uninteresting treesame 	index upvalue 
flags otherwise use 	index key 
commit action 	index useful 
see commit interesting 	name found 
revs first 	calling 
parent first parent 	function lua 
interesting none 	unknown calling 
others next 	function useful 
interesting commit orig 	name found 
commit parents 	ansi way 
ignore first parent 	check 
interesting otherwise 	whether pointer 
call next interesting 	points first 
parent next 	operand wrong 
interesting parent update 	lua code 
graph column 	file line 
color commit already 	information 
columns list 	error handling 
need update mapping 	function move 
correctly commit 	argument push 
isn already columns 	function call 
compute width 	ldebug.h opname 
needed display graph 	fmt 
commit maximum 	ldebug roberto 
width needed row 	exp auxiliary 
rows padded 	functions debug 
width compute 	module see 
number columns widest 	copyright notice 
row count 	lua 
existing column graph 	ldo.c previous 
num columns 	status errcode 
column added commit 	oldtop inuse 
even current 	status errcode 
commit parents printed 	oldstack newsize 
still takes 	oldstack 
column added column 	realsize newsize 
current commit 	oldci line 
part graph num 	hook top 
parents current 	top actual 
commit already graph 	nfixargs htab 
columns counted 	nvar 
column takes spaces 	func funcr 
swap graph 	func nresults 
columns graph columns 	funcr nargs 
graph columns 	first result 
contains state 	first result 
previous commit columns 	res 
contains state 	wanted func 
commit use old 	results first 
columns storage 	arg msg 
compute columns list 	nargs status 
commit one 	nresults func 
update columns mapping 	old 
information commit 	top status 
one first make 	oldn ccalls 
sure enough 	old old 
room graph num 	allowhooks old 
columns graph 	errfunc oldtop 
num parents columns 	buff 
next commit 	name name 
clear graph mapping 	status setsvalue 
populate graph 	lua newliteral 
columns graph 	setsvalue lua 
mapping parents commit 	newliteral setobjs 
may already 	lua 
graph columns graph 	cast lua 
columns contain 	realloc lua 
single entry commit 	close lua 
graph mapping 	seterrorobj restore 
contain information current 	stack limit 
branch line 	luai 
supposed end collapsing 	cast resetstack 
performed merge 	lua unlock 
start childless column 	panic exit 
increment current 	gco gco 
color always need 	lua lua 
increment mapping 	reallocvector 
idx least even 	correctstack lua 
interesting parents 	reallocvector lua 
current commit always 	reallocstack lua 
takes least 	reallocstack lua 
spaces shrink 	lua realloc 
mapping size minimum 	lua 
necessary compute 	runerror savestack 
graph width commit 	savestack cast 
commit count 	lua checkstack 
many interesting parents 	lua lua 
commit store 	unlock hook 
old commit index 	lua 
prev commit 	lua restorestack 
index graph update 	restorestack setnilvalue 
columns update 	lua lua 
graph commit index 	check lua 
commit call 	checkstack lua 
graph update columns 	setobj 
update columns 	lua setnum 
columns mapping update 	setnvalue lua 
graph state 	setstr lua 
note call graph 	newliteral cast 
update state 	num setobjs 
since want 	setnilvalue 
update graph prev 	sethvalue lua 
state line 	iswhite obj 
graph state ever 	gco lua 
printed previous 	gettmbyobj savestack 
commit didn graph 	ttisfunction lua 
padding state 	typeerror 
never finished output 	setobjs incr 
graph skip 	top restorestack 
print line indicate 	setobj ttisfunction 
portion graph 	tryfunc savestack 
missing parents may 	clvalue lua 
need print 	checkstack 
extra rows commit 	restorestack cast 
expand branch 	adjust varargs 
lines around make 	restorestack inc 
room need 	lua setnilvalue 
branch row right 	lua callhook 
commit less 	lua 
parents immediately 	checkstack inc 
print commit line 	restorestack lua 
mapping date 	lua callhook 
entry target greater 	lua unlock 
target greater 	curr func 
target printed look 	lua 
correct next 	lua poscall 
row additional spaces 	savestack lua 
end strbuf 	callhook lua 
lines particular commit 	lua callhook 
width way 	restorestack callrethooks 
fields printed right 	setobjs 
graph remain 	setnilvalue lua 
aligned entire commit 	runerror lua 
could conceivable 	lua precall 
called commit caller 	lua execute 
bug invokes 	lua check 
graph next line 	cast 
immediately graph 	lua lua 
init without 	precall lua 
first calling graph 	lua lua 
update without 	opcode opcode 
outputting anything output 	lua poscall 
padding row 	lua 
leaves branch lines 	execute cast 
unchanged output 	setsvalue lua 
ellipsis indicate portion 	incr top 
graph missing 	lua unlock 
function formats row 	lua 
increases space 	resume error 
around commit multiple 	resume error 
parents make 	luai userstateresume 
room called parents 	lua lua 
need extra 	rawrunprotected cast 
rows every parent 	lua 
graph expansion 	seterrorobj lua 
row tracks 	lua unlock 
current expansion row 	luai userstateyield 
range num 	lua lua 
expansion rows output 	runerror lua 
row first 	unlock 
line pre commit 	saveci lua 
output previous 	rawrunprotected restorestack 
commit merge commit 	lua close 
ended graph 	lua seterrorobj 
post merge state 	restoreci restore 
branch lines 	stack 
graph prev commit 	limit cast 
index printed 	lua lookahead 
previous line print 	lua check 
line otherwise 	lua parser 
print branch lines 	lua lclosure 
increment graph 	hvalue 
expansion row move 	lua newupval 
state graph 	setclvalue incr 
commit necessary 	top lua 
boundary commits print 	initbuffer lua 
see boundary 	pcall savestack 
commits revs boundary 	lua 
revision mark 	freebuffer ldo 
handles cases without 	roberto exp 
draw octopus 	stack call 
merge number characters 	structure lua 
written dashless 	see copyright 
commits represents number 	notice 
parents need 	lua error 
dashes edges fit 	recovery functions 
neatly commit 	chain list 
output row containing 	jump buffers 
commit iterate 	error code 
including graph num 	error 
columns since 	message current 
current commit may 	top overflow 
existing columns 	undo overflow 
happens current 	close eventual 
commit doesn children 	pending closures 
already processed 	chain 
way merge commit 	error handler 
graph pre 	restore old 
commit stage way 	error handler 
merges first 	size enough 
line output commit 	overflow handling 
check see 	overflow 
previous line output 	tail call 
graph post 	debug information 
merge branch line 	ensure minimum 
coming commit 	stack size 
may output branch 	cannot call 
line line 	hooks 
instead makes output 	inside hook 
look nicer 	compat old 
update graph state 	style vararg 
output post 	number extra 
merge row 	arguments create 
since current commit 	arg 
merge find 	table put 
columns parent commits 	extra arguments 
columns use 	arg table 
format edges update 	store counter 
graph state 	field move 
clear mapping since 	parameters 
update columns 	position first 
always inserts leftmost 	argument position 
column first 	first argument 
branch target location 	arg parameter 
always either 	open hole 
current location left 	inside 
current location 	stack func 
never move branches 	previous call 
right makes 	may change 
graph much 	stack tag 
legible since whenever 	method function 
branches cross 	called 
one moving directions 	func function 
column already 	check function 
correct place nothing 	tag method 
left move 	lua function 
left one isn 	prepare call 
already edge 	varargs 
moving horizontally one 	vararg function 
variable target 	previous call 
index graph column 	may change 
therefore target 	stack enter 
actual screen column 	function starting 
first horizontal 	point 
line branch line 	hooks already 
left already 	incremented correct 
target combine line 	function call 
since share 	ensure minimum 
parent commit 	stack size 
anything output mapping 	enter 
since existing 	function actual 
branch line already 	call yielding 
taken care 	next call 
branch line left 	may change 
isn target 	stack lua 
need cross space 	function 
left branch 	tail calls 
always empty branch 	res position 
left space 	result restore 
eventual target mark 	restore savedpc 
branch horizontal 	move results 
edge prevent edges 	correct 
moving horizontally 	place iff 
mapping may smaller 	wanted lua 
old mapping 	multret call 
output line mapping 	function lua 
info mappings 	function called 
first segment 	func 
won next line 	arguments stack 
swap mapping 	right function 
mapping graph mapping 	returns results 
indicates branch 	stack starting 
lines already correct 	original function 
positions done 	position 
otherwise need collapse 	error handing 
branch lines 	stack error 
together output row 	lua function 
containing commit 	call start 
iterate including graph 	coroutine resuming 
num columns 	previous 
since current commit 	common finish 
may existing 	interrupted execution 
columns happens current 	call complete 
commit doesn 	correct top 
children already processed 	multiple results 
update graph 	yielded 
prev state 	inside hook 
since output padding 	execution error 
line showing 	mark dead 
diff merge parents 	protect stack 
called parent 	slots error 
without graph update 	occurred 
called simply 	close eventual 
output single padding 	pending closures 
line print 	execute parser 
strbuf line line 	data parser 
display graph 	buffer used 
info line first 	scanner 
graph print 	initialize eventual 
message buffer message 	upvalues ldo.h 
buffer cmit 	name line 
fmt oneline cmit 	func nresults 
fmt userformat 	func results 
already missing 	func 
terminating newline formats 	oldtop first 
show commit 	result newsize 
message output needed 	newsize errcode 
commit show 	errcode oldtop 
doesn terminating newline 	ldo roberto 
print one 	exp 
start remainder graph 	stack call 
output line 	structure lua 
ends newline output 	see copyright 
graph.h colors 	notice lua 
colors max opt 	results lua 
graph commit 	precall 
graph commit finished 	initiated call 
graph graph 	lua function 
graph graph graph 	call function 
graph show 	funtion yielded 
commit msg graph 	type functions 
pointer opaque 	ran 
structure custom 	runprotected ldump.c 
scheme column colors 	size size 
column color 	size size 
scheme inserts ansi 	data strip 
color escapes 	lua unlock 
colorize graph various 	writer 
color escapes 	lua dump 
stored entry corresponds 	dump dump 
color last 	dump dump 
entry denotes escape 	mem getstr 
resetting color 	dump dump 
back generating graph 	dump 
inserted various 	block getstr 
column characters function 	dump dump 
allows enable 	ttype ttype 
custom color escapes 	dump bvalue 
colors max 	dump number 
argument index last 	nvalue 
reset entry 	dump rawtsvalue 
functions must 	lua dump 
called graph init 	dump function 
called note 	dump vector 
function isn used 	dump dump 
git outside 	dump 
graph used git 	dump dump 
http git 	dump dump 
cgit use html 	dump dump 
colors create 	dump dump 
git graph update 	dump dump 
git graph 	dump 
commit cause graph 	code dump 
begin outputting 	constants dump 
lines commit next 	debug lua 
time graph 	header dump 
next line called 	block dump 
graph update 	header 
called graph commit 	dump function 
finished returns 	ldump roberto 
next call 	exp save 
graph next line 	precompiled lua 
output ellipsis 	chunks see 
indicate portion graph 	copyright 
missing determine 	notice lua 
graph finished outputting 	include trailing 
lines current 	cannot happen 
commit returns graph 	dump lua 
next line 	function precompiled 
needs called graph 	chunk 
update called 	lfunc.c nelems 
returns lines needed 	nelems level 
commit returned 	level size 
graph next line 	local number 
may still 	cast lua 
called without calling 	malloc 
graph update 	size cclosure 
merely output appropriate 	lua link 
vertical padding 	obj gco 
graph output 	cast cast 
next line graph 	lua malloc 
formats next 	size 
graph line specified 	lclosure lua 
strbuf terminated 	link obj 
newline returns line 	gco cast 
includes current 	lua lua 
commit otherwise graph 	link obj 
next line 	gco 
exactly time graph 	setnilvalue ngcotouv 
update called 	lua isdead 
note function isn 	obj gco 
used git 	changewhite obj 
outside graph used 	gco lua 
git http 	lua 
git cgit wrap 	white obj 
html around 	gco lua 
graph lines 	lua unlinkupval 
graph show helper 	lua free 
functions printing 	ngcotouv obj 
stdout graph non 	gco 
print history 	lua isblack 
graph stdout including 	isdead lua 
line containing 	freeupval unlinkupval 
commit print terminating 	setobj lua 
newline last 	linkupval lua 
line graph non 	lua 
print one 	link obj 
line history graph 	gco lua 
stdout print 	freearray lua 
terminating newline last 	freearray lua 
line graph 	freearray lua 
non print one 	freearray 
line vertical 	lua freearray 
graph padding stdout 	lua freearray 
print terminating 	lua free 
newline last 	size cclosure 
line graph non 	size lclosure 
print rest 	lua 
history graph commit 	freemem getstr 
stdout print 	lfunc roberto 
terminating newline last 	exp auxiliary 
line print 	functions manipulate 
commit message strbuf 	prototypes closures 
remainder graph 	see 
stdout similar graph 	copyright notice 
show strbuf 	lua found 
always prints remainder 	corresponding upvalue 
graph strbuf 	dead ressurect 
ends newline output 	found create 
printed graph 	one 
show commit msg 	current lives 
end newline 	stack chain 
strbuf missing terminating 	proper position 
newline including 	link uvhead 
empty output 	list uvhead 
printed graph show 	list 
commit msg 	open open 
also missing terminating 	list free 
newline graph 	upvalue open 
grep.c grep defaults 	list free 
opt run 	upvalue current 
opt arg opt 	lives 
color opt 	link upvalue 
prefix def grep 	gcroot list 
commit pattern 	look local 
type grep pattern 	variable line 
type option 	line function 
create grep pat 	func 
tail pat 	returns found 
len append header 	variable active 
grep pattern 	found lfunc.h 
append grep pattern 	nelems nelems 
append grep 	level level 
pat opt 	func 
pat ret error 	local number 
opt error 	lfunc roberto 
erroffset options line 	exp auxiliary 
eol match 	functions manipulate 
eflags ovector ret 	prototypes closures 
flags opt 	see 
line eol match 	copyright notice 
eflags len 	lua lgc.c 
opt err errbuf 	deadmem curr 
grep pat 	weakkey weakvalue 
list list list 	mode max 
list list 	used 
opt left right 	used lim 
opt header 	iskey count 
expr opt header 	curr deadmask 
expr opt 	newsize udata 
opt left 	oldah oldt 
opt data size 	udsize 
color opt 	old old 
sign opt name 	lim lua 
line eol 	ttisnil gval 
match kwsm offset 	iscollectable gkey 
preg line 	setttype gkey 
eol match eflags 	lua 
line eol 	iswhite isdead 
match eflags hit 	white gray 
bol eol 	gco gray 
eol field len 	black markobject 
match one 	markobject gco 
pattern match expr 	gco 
eval match 	markvalue gray 
expr match line 	black gco 
match next 	gco gco 
pattern next match 	gco lua 
opt bol 	makewhite reallymarkobject 
eol name 	iswhite 
lno sign rest 	isfinalized gco 
match color 	fasttm gco 
line color buf 	markfinalized gco 
match eflags 	sizeudata gco 
grep use locks 	markfinalized gco 
grep attr 	markobject 
mutex grep read 	gfasttm ttisstring 
mutex opt 	strchr svalue 
bol eol xecfg 	strchr svalue 
buf opt 	cast obj 
bol lno eol 	gco markvalue 
opt bol 	sizenode 
end lno funcname 	gnode lua 
lno funcname 	ttype gkey 
needed eol sign 	ttisnil gval 
opt opt 	ttisnil gval 
left lno bol 	removeentry lua 
lno bol 	ttisnil 
last bol 	gkey markvalue 
earliest hit opt 	gkey markvalue 
buf size 	gval stringmark 
driver buf size 	markvalue stringmark 
opt collect 	markobject stringmark 
hits bol left 	markobject 
lno last 	markvalue lua 
hit binary match 	markobject markobject 
count lookahead 	cast cast 
show function textconv 	lua realloc 
xecfg eol 	condhardstacktests lua 
hit buf opt 	realloc 
opt buf 	lua reallocstack 
size grep source 	condhardstacktests lua 
init filename 	reallocstack markvalue 
data size memset 	lua markvalue 
color color 	setnilvalue checkstacksizes 
color color color 	lua 
color color 	isgray gray 
color strcmp 	black gco 
strcmp strcmp strcmp 	traversetable black 
strcmp die 	gray sizenode 
userdiff config strcmp 	gco traverseclosure 
git config 	size 
strcmp parse pattern 	cclosure size 
type arg 	lclosure gco 
strcmp git config 	black gray 
strcmp git 	traversestack gco 
config strcmp git 	traverseproto lua 
config colorbool 	propagatemark 
strcmp strcmp strcmp 	iscollectable ttisstring 
strcmp strcmp 	stringmark rawtsvalue 
strcmp strcmp strcmp 	iswhite gcvalue 
strcmp config 	ttisuserdata isfinalized 
error nonbool color 	uvalue gco 
parse color 	lua 
parse config 	testbit testbit 
error nonbool color 	testbit iscleared 
parse memset 	setnilvalue sizenode 
strlen color color 	gnode ttisnil 
color color 	gval iscleared 
color color color 	key 
color create 	tval iscleared 
grep pat xmalloc 	gval setnilvalue 
append header 	gval removeentry 
grep pattern append 	lua freeproto 
grep pat 	gco lua 
xsnprintf xsnprintf die 	freeclosure 
pcre compile 	gco lua 
compile regexp failed 	freeupval gco 
pcre study 	lua free 
die pcre exec 	gco lua 
size die 	gco gco 
pcre free pcre 	lua 
free die 	freethread gco 
memchr regex 	lua freemem 
special kwsalloc kwsalloc 	sizestring gco 
kwsincr kwsprep 	lua freemem 
compile pcre regexp 	sizeudata gco 
regcomp regerror 	lua 
regfree compile regexp 	otherwhite sweepwholelist 
failed xcalloc 	gco lua 
compile pattern die 	isdead testbit 
die xcalloc 	makewhite lua 
compile pattern die 	isdead bitmask 
compile pattern 	freeobj 
atom compile pattern 	cast lua 
die compile 	resize lua 
pattern die xcalloc 	sizebuffer lua 
compile pattern 	sizebuffer lua 
compile pattern die 	resizebuffer rawgco 
xcalloc compile 	makewhite 
pattern fputc fputc 	fasttm setobj 
indent dump 	setuvalue lua 
grep pat 	call gctm 
dump grep expression 	bitmask sweepwholelist 
indent dump 	sweepwholelist 
grep expression dump 	markobject markobject 
grep expression 	markvalue markvalue 
indent dump grep 	registry markmt 
expression dump 	lua isgray 
grep expression indent 	obj gco 
dump grep 	markvalue 
expression fflush xcalloc 	remarkupvals propagateall 
xcalloc die 	lua iswhite 
die compile regexp 	obj gco 
compile pattern 	markobject markmt 
atom die grep 	propagateall propagateall 
expr grep 	lua 
expr grep expr 	separateudata marktmu 
prep header 	propagateall cleartable 
patterns compile regexp 	cast otherwhite 
compile pattern 	markroot propagatemark 
expr die 	atomic sweepwholelist 
grep splice grep 	lua 
expr compile 	sweeplist check 
grep patterns real 	sizes lua 
dump grep 	gctm lua 
expression free pattern 	singlestep setthreshold 
expr free 	lua lua 
pattern expr free 	singlestep 
pattern expr 	markroot singlestep 
free kwsfree free 	setthreshold lua 
pcre regexp 	isblack iswhite 
regfree free free 	isdead isdead 
free pattern 	lua lua 
expr isalnum want 	ttype 
color output 	reallymarkobject makewhite 
strlen output output 	obj gco 
strlen output 	lua isblack 
output output color 	isdead lua 
output color 	black gray 
strlen output 	lua 
kwsexec regexec fixmatch 	white obj 
pcrematch regmatch 	gco isgray 
output output color 	gray black 
output output 	lua barrier 
color output output 	makewhite lua 
color strlen 	lgc 
output output color 	roberto exp 
strlen output 	garbage collector 
sep snprintf output 	see copyright 
color strlen 	notice lua 
output sep next 	dead key 
match output 	udata 
color output color 	never gray 
output color 	closed open 
output pthread mutex 	upvalues never 
pthread mutex 	black may 
unlock grep 	marked left 
source load driver 	previous 
xdiff find 	move dead 
func find func 	udata need 
isalpha match 	finalization list 
funcname show line 	tmudata bother 
match funcname 	need finalization 
match funcname show 	must 
funcname line 	call method 
show line patmatch 	link curr 
fwrite grep 	end tmudata 
source load alloc 	list list 
filespec fill 	empty creates 
filespec fill filespec 	circular 
die grep 	list weak 
read fill textconv 	mode really 
grep read 	weak clear 
unlock free filespec 	bits must 
grep source 	cleared put 
clear data 	appropriate 
grep source load 	list empty 
driver grep 	entries marks 
attr userdiff textconv 	conditional may 
grep attr 	happen prototype 
unlock grep source 	still created 
binary grep 	mark 
source binary die 	literals mark 
memset lookahead 	upvalue names 
fill textconv grep 	mark nested 
look ahead 	protos mark 
end line match 	local variable 
line show 	names 
name output output 	mark upvalues 
color strlen 	mark upvalues 
output show pre 	number use 
context show 	part stack 
funcname line show 	use handling 
line match 	overflow 
funcname show 	touch stacks 
line show name 	still big 
xdiff clear 	enough still 
find func output 	big enough 
color strlen 	traverse one 
output sep snprintf 	gray 
output strlen 	turning black 
grep source clr 	returns quantity 
hit marker 	traversed table 
grep source chk 	weak keep 
hit marker 	gray next 
grep source grep 	function 
source init 	tells whether 
grep source grep 	key cleared 
source clear 	weak table 
free free free 	non collectable 
grep source 	objects never 
clear data free 	removed 
grep read 	weak tables 
read sha 	behave values 
file grep read 	never removed 
unlock error 	objects really 
sha hex lstat 	collected cannot 
error strerror 	keep 
isreg xsize open 	userdata finalized 
xmallocz read 	keep keys 
full error strerror 	values values 
close free 	never weak 
close grep source 	clear collected 
load file 	entries 
grep source load 	weaktables collected 
sha die 	non empty 
grep attr userdiff 	entry entry 
find path 	table sweep 
userdiff find name 	open upvalues 
grep attr 	dead 
unlock grep 	make white 
source load driver 	next cycle 
grep source 	must erase 
load buffer binary 	curr first 
initialize grep 	element list 
defaults hardcoded defaults 	adjust 
could compiler 	first check 
without initializers code 	size hash 
gets unwieldy 	table big 
unreadable read configuration 	check size 
file store 	buffer buffer 
grep defaults initialize 	big 
one instance 	first element 
grep opt copy 	udata tmudata 
values read 	last element 
configuration information earlier 	root list 
call git 	stop debug 
config grep config 	hooks 
fall atom 	tag method 
use libpcre 	avoid steps 
use libpcre regcomp 	restore hooks 
cannot accept 	restore threshold 
patterns consider pattern 	call tag 
containing nul 	methods 
atom atom atom 	mask collect 
match beginning 	elements free 
must either beginning 	lists mark 
line word 	root make 
boundary last must 	table traversed 
word similarly 	main 
match end must 	stack total 
either end 	size userdata 
line word boundary 	finalized remark 
next must 	occasional upvalues 
word words consist 	maybe dead 
least one 	threads 
character could one 	traverse objects 
match line 	cautch write 
first match 	barrier remarkupvals 
might strict word 	remark weak 
match later 	tables mark 
ones could forward 	running 
next possible 	mark basic 
start next position 	metatables remark 
following non 	gray separate 
word call collect 	userdata finalized 
hits without 	mark preserved 
extended atom protects 	userdata 
access gitattributes 	remark propagate 
machinery safe git 	preserveness collected 
attr mutex 	objects weak 
protecting access rewind 	tables flip 
need look 	current white 
even back find 	first 
function signature 	estimate lua 
back forward punt 	checkmemory start 
complex stuff 	collection gray 
punt header 	objects finish 
stuff find beginning 	mark phase 
line textconv 	nothing 
intimately tied diff 	sweep end 
filespecs pretend 	sweep phase 
one could unify 	nothing sweep 
grep source 	end sweep 
diff filespec structs 	phase end 
mess could 	collection 
away fill textconv 	limit lim 
remotely safe 	gcstepmul reset 
may load objects 	sweep marks 
behind scenes 	sweep elements 
modifies diff tempfile 	returning white 
structure normal 	reset 
fill textconv usage 	collector lists 
diff machinery 	finish pending 
would keep 	sweep phase 
textconv buf separate 	must keep 
diff filespec 	invariant restore 
much grep code 	invariant 
passes around 	mind mark 
grep source assumes 	white avoid 
buf pointer 	barriers make 
beginning thing searching 	table gray 
install textconv 	link upvalue 
version grep source 	rootgc 
taking care 	list closed 
leak existing buffer 	upvalues need 
show hunk 	barrier sweep 
marks first file 	phase sweep 
threads easily 	turning white 
identify first file 	lgc.h 
always put 	lgc roberto 
hunk marks skip 	exp garbage 
first one 	collector see 
later work 	copyright notice 
done might shared 	lua possible 
textconv cache 	states 
data safe know 	garbage collector 
result textconv 	userful bit 
text care binary 	tricks layout 
handling unmatch 	bit use 
look ahead skips 	marked field 
quickly line 	bit 
possibly next hit 	white type 
call need 	bit white 
something skipping current 	type bit 
line response 	black bit 
unmatch current line 	userdata finalized 
inside post 	bit 
context window show 	tables weak 
current line 	keys bit 
context around previous 	tables weak 
hit doesn 	values bit 
hit grep 	collected bit 
foo bla list 	main 
lines either 	lg chunkc 
inversion done outside 	malloc conf 
hit line 	mallocx ptr 
haven shown pre 	dallocx test 
context lines 	make sure 
would need show 	opt 
last hit 	chunk clamping 
within post context 	sufficient practice 
need show 	test program 
line see hit 	fail debug 
want show 	assertion initialization 
needswork real grep 	abort 
foo gives 	rather test 
many bar lines 	soft failing 
feels mostly 	clamping insufficient 
useless sometimes useful 	libev.h watcher 
maybe make 	revents watcher 
another option 	revents 
suppress hit markers 	privdata loop 
meaningful top 	privdata loop 
level node top 	privdata loop 
level nodes 	privdata loop 
hit markers see 	privdata redis 
hits two 	handle 
pass grep check 	read redis 
buffer wide 	handle write 
match otherwise toplevel 	start stop 
terms hit 	start stop 
bit differently first 	redis libev 
clear hit 	del 
markers user provided 	read redis 
buf intact 	libev del 
builtin git grep 	write free 
copyright junio 	malloc init 
hamano use one 	init copyright 
producer threads 	pieter 
consumer threads 	noordhuis pcnoordhuis 
producer adds work 	gmail dot 
items todo 	rights reserved 
consumers pick work 	redistribution use 
items range 	source binary 
todo done todo 	forms 
start todo 	without modification 
work items processed 	permitted provided 
consumer haven 	following conditions 
written result stdout 	met redistributions 
yet work 	source code 
items todo start 	must 
todo end 	retain copyright 
waiting picked consumer 	notice list 
ranges modulo 	conditions following 
todo size work 	disclaimer redistributions 
items added 	binary form 
protects variables 	must 
signalled work item 	reproduce copyright 
added todo 	notice list 
signalled result one 	conditions following 
work item 	disclaimer documentation 
written stdout signalled 	materials provided 
finished everything 	distribution 
skip leading hunk 	neither name 
mark first 	redis names 
file wait work 	contributors may 
done wake 	used endorse 
consumer threads see 	promote products 
work pthreads 	derived 
valid worktree file 	software without 
cache entry 	specific prior 
identical even worktree 	written permission 
file modified 	software provided 
use cache version 	copyright holders 
instead compensate 	contributors 
loop control 	express implied 
ignore empty line 	warranties including 
like grep 	limited implied 
paths must exist 	warranties merchantability 
working pattern 	fitness particular 
specified take first 	purpose 
unrecognized non 	disclaimed shall 
option pattern follows 	copyright owner 
must zero 	contributors liable 
valid refs exists 	direct indirect 
existing paths 	incidental special 
pattern first unrecognized 	exemplary 
non option 	consequential damages 
beginning refs list 	including limited 
continues exists 	procurement substitute 
paths die way 	goods services 
beginning skip 	loss use 
separator know cannot 	data 
separating revisions 	profits business 
pathnames haven 	interruption however 
even patterns yet 	caused theory 
first unrecognized 	liability whether 
non option token 	contract strict 
check revs 	liability 
paths rev rest 	tort including 
paths grep 	negligence otherwise 
usage num threads 	arising way 
threads source 	use software 
done todo todo 	even advised 
start todo 	possibility 
end todo done 	damage nothing 
work added 	attached something 
grep mutex cond 	already attached 
cond write 	create container 
cond result skip 	context events 
first line 	functions 
work ret old 	start stop 
done len 	listening events 
arg hit 	initialize read 
opt opt buf 	write events 
size opt 	libevent.h arg 
err hit read 	arg 
sha file 	privdata privdata 
opt sha filename 	privdata privdata 
name len 	privdata redis 
path pathbuf hit 	handle read 
opt filename 	redis handle 
buf hit opt 	write 
data len 	del del 
path list opt 	del del 
prefix path 	free malloc 
list child status 	copyright pieter 
opt pathspec 	noordhuis pcnoordhuis 
cached hit opt 	gmail 
pathspec len 	dot rights 
check attr 	reserved redistribution 
hit entry old 	use source 
baselen len 	binary forms 
sub data size 	without modification 
opt pathspec 	permitted 
obj name path 	provided following 
data size 	conditions met 
hit len opt 	redistributions source 
pathspec list 	code must 
hit real obj 	retain copyright 
opt pathspec 	notice 
exc std dir 	list conditions 
hit opt 	following disclaimer 
arg unset grep 	redistributions binary 
opt endp 	form must 
opt arg unset 	reproduce copyright 
grep opt 	notice 
stdin patterns lno 	list conditions 
opt arg 	following disclaimer 
unset grep 	documentation materials 
opt opt arg 	provided distribution 
unset grep 	neither name 
opt opt arg 	redis 
unset grep 	names contributors 
opt opt arg 	may used 
unset grep 	endorse promote 
opt opt arg 	products derived 
unset grep 	software without 
opt argc argv 	specific 
prefix hit 	prior written 
opt exclude seen 	permission software 
dashdash external 	provided copyright 
grep allowed ignored 	holders contributors 
pager opt 	express implied 
list pathspec path 	warranties 
list dummy 	including limited 
use index pattern 	implied warranties 
type arg 	merchantability fitness 
options fallback 	particular purpose 
arg sha pager 	disclaimed shall 
len buf 	copyright 
use exclude pthread 	owner contributors 
mutex pthread 	liable direct 
mutex unlock grep 	indirect incidental 
pthread cond 	special exemplary 
wait size grep 	consequential damages 
unlock grep 	including 
size write die 	limited procurement 
grep source 	substitute goods 
clear pthread cond 	services loss 
signal pthread 	use data 
cond signal grep 	profits business 
unlock work 	interruption 
grep source grep 	however caused 
source clear 	theory liability 
data work done 	whether contract 
free grep 	strict liability 
patterns free 	tort including 
strbuf pthread mutex 	negligence 
init pthread 	otherwise arising 
mutex init pthread 	way use 
mutex init 	software even 
pthread cond init 	advised possibility 
pthread cond 	damage nothing 
init pthread cond 	attached 
init size 	something already 
strbuf init xcalloc 	attached create 
grep opt 	container context 
dup compile grep 	events functions 
patterns pthread 	start 
create die strerror 	stop listening 
grep pthread 	events initialize 
cond wait pthread 	install read 
cond broadcast 	write events 
grep unlock pthread 	libuv.h handle 
free pthread 	status 
mutex destroy 	events privdata 
pthread mutex destroy 	privdata privdata 
pthread mutex 	privdata handle 
destroy pthread cond 	privdata loop 
destroy pthread 	redis handle 
cond destroy pthread 	read 
cond destroy 	redis handle 
grep config git 	write poll 
color config 	start poll 
strcmp git config 	start poll 
die quote 	stop poll 
path relative strbuf 	start 
insert strbuf 	poll start 
addstr work strbuf 	poll stop 
release grep 	free close 
source init strbuf 	malloc memset 
release grep 	poll init 
source grep 	linenoise.c 
source clear quote 	unsupported term 
path relative 	completion callback 
strbuf addstr work 	orig termios 
strbuf release 	rawmode mlmode 
grep source init 	atexit registered 
strbuf release 	history 
grep source grep 	max len 
source clear 	history len 
list append xstrndup 	history ifd 
argv push 	ofd buf 
run command exit 	buflen prompt 
read cache 	plen 
isreg intent path 	pos oldpos 
match skip 	len cols 
worktree stage grep 	maxrows history 
sha grep 	index line 
file stage strcmp 	term raw 
entry entry 	ifd 
len entry 	ofd buf 
interesting strbuf isreg 	cols rows 
grep sha 	ifd ofd 
isdir read sha 	start cols 
file die 	seq nread 
sha hex strbuf 	nwritten 
addch init 	saved str 
desc grep free 	len copy 
strbuf setlen 	cvec len 
grep sha grep 	len seq 
read read 	plen buf 
reference grep read 	len 
unlock die 	pos seq 
oid hex strlen 	plen rows 
strbuf init 	rpos rpos 
strbuf strbuf addch 	col old 
init desc 	rows dir 
grep strbuf release 	old 
free die 	pos diff 
deref tag 	stdin stdout 
grep memset setup 	buf buflen 
standard excludes 	prompt nread 
fill directory dir 	seq aux 
path match 	quit 
grep file strtol 	nread buf 
error strcmp 	buflen prompt 
fopen die errno 	count prompt 
strbuf getline 	buf count 
append grep pat 	len line 
fclose strbuf 	linecopy 
release append grep 	len tocopy 
pattern append 	filename filename 
grep pattern append 	buf getenv 
grep pattern 	strcasecmp isatty 
append grep pattern 	atexit tcgetattr 
append grep 	tcsetattr 
pattern init grep 	tcsetattr write 
defaults git 	read sscanf 
config grep 	ioctl cursor 
init parse options 	position write 
grep commit 	cursor position 
pattern type git 	snprintf 
config setup 	write strlen 
git directory strcmp 	write fflush 
append grep 	free free 
pattern git pager 	completion callback 
list append 	linenoise beep 
die compile grep 	strlen 
patterns sha 	refresh line 
context parse die 	refresh line 
verify non 	read free 
filename path strcmp 	completions linenoise 
die start 	beep refresh 
threads verify filename 	line 
parse pathspec 	snprintf free 
die strlen 	completions strlen 
dir sep strcmp 	malloc memcpy 
list append 	realloc free 
strcmp strcmp strbuf 	realloc memcpy 
addf strcmp 	free 
list append strbuf 	strlen init 
detach setup 	snprintf append 
pager die die 	strlen append 
grep directory 	strlen append 
die setup work 	snprintf append 
grep cache 	strlen 
die grep objects 	snprintf append 
wait run 	strlen write 
pager free grep 	free strlen 
patterns initialize 	init lndebug 
grep defaults hardcoded 	snprintf append 
defaults could 	strlen 
compiler without initializers 	lndebug snprintf 
code gets 	append strlen 
unwieldy unreadable 	lndebug snprintf 
read configuration file 	append strlen 
store grep 	append strlen 
defaults initialize one 	append 
instance grep 	lndebug append 
opt copy values 	snprintf append 
read configuration 	strlen lndebug 
information earlier call 	lndebug snprintf 
git config 	append strlen 
grep config fall 	lndebug 
atom use 	snprintf snprintf 
libpcre use libpcre 	append strlen 
regcomp cannot 	lndebug write 
accept patterns consider 	free refresh 
pattern containing 	multi line 
nul atom atom 	refresh 
atom match 	single line 
beginning must either 	write refresh 
beginning line 	line memmove 
word boundary 	refresh line 
last must word 	refresh line 
similarly match 	refresh 
end must either 	line refresh 
end line 	line refresh 
word boundary next 	line free 
must word 	strdup strncpy 
words consist least 	strlen refresh 
one character 	line 
could one match 	memmove refresh 
line first 	line memmove 
match might strict 	refresh line 
word match 	memmove refresh 
later ones could 	line strlen 
forward next 	columns 
possible start next 	linenoise history 
position following 	write read 
non word call 	complete line 
collect hits 	free linenoise 
without extended 	edit move 
atom protects access 	end 
gitattributes machinery 	linenoise edit 
safe git attr 	backspace linenoise 
mutex protecting 	edit free 
access rewind need 	refresh line 
look even 	linenoise edit 
back find function 	move 
signature back 	left linenoise 
forward punt complex 	edit move 
stuff punt 	right linenoise 
header stuff find 	edit history 
beginning line 	next linenoise 
textconv intimately tied 	edit 
diff filespecs 	history next 
pretend one could 	read read 
unify grep 	read linenoise 
source diff 	edit linenoise 
filespec structs mess 	edit history 
could away 	next 
fill textconv remotely 	linenoise edit 
safe may 	history next 
load objects behind 	linenoise edit 
scenes modifies 	move right 
diff tempfile structure 	linenoise edit 
normal fill 	move 
textconv usage diff 	left linenoise 
machinery would 	edit move 
keep textconv buf 	home linenoise 
separate diff 	edit move 
filespec much grep 	end linenoise 
code passes 	edit 
around grep source 	move home 
assumes buf 	linenoise edit 
pointer beginning thing 	move end 
searching install 	linenoise edit 
textconv version 	insert refresh 
grep source taking 	line 
care leak 	refresh line 
existing buffer show 	linenoise edit 
hunk marks 	move home 
first file threads 	linenoise edit 
easily identify 	move end 
first file always 	linenoise 
put hunk 	clear screen 
marks skip first 	refresh line 
one later 	linenoise edit 
work done might 	prev word 
shared textconv 	enable raw 
cache data safe 	mode 
know result 	memset read 
textconv text care 	memmove memcmp 
binary handling 	isprint fflush 
unmatch look ahead 	disable raw 
skips quickly 	mode isatty 
line possibly 	fgets 
next hit call 	strlen enable 
need something 	raw mode 
skipping current line 	linenoise edit 
response unmatch 	disable raw 
current line inside 	mode unsupported 
post context 	term 
window show current 	fflush fgets 
line context 	strlen strdup 
around previous hit 	linenoise raw 
doesn hit 	strdup free 
grep foo bla 	free disable 
list lines 	raw 
either inversion done 	mode free 
outside hit 	history malloc 
line haven shown 	memset strcmp 
pre context 	strdup free 
lines would need 	memmove malloc 
show last 	free 
hit within 	memset memcpy 
post context need 	free fopen 
show line 	fclose fopen 
see hit want 	fgets strchr 
show needswork 	strchr linenoise 
real grep foo 	history 
gives many 	fclose linenoise 
bar lines feels 	guerrilla line 
mostly useless 	editing library 
sometimes useful maybe 	idea line 
make another 	editing lib 
option suppress hit 	needs 
markers meaningful 	lines code 
top level node 	find latest 
top level 	source code 
nodes hit markers 	http github 
see hits 	antirez linenoise 
two pass grep 	number 
check buffer 	crazy assumptions 
wide match 	happen unix 
otherwise toplevel terms 	computers around 
hit bit 	copyright salvatore 
differently first clear 	sanfilippo antirez 
hit markers 	gmail 
user provided buf 	dot copyright 
intact builtin 	pieter noordhuis 
git grep copyright 	pcnoordhuis gmail 
junio hamano 	dot rights 
use one producer 	reserved redistribution 
threads consumer 	use 
threads producer adds 	source binary 
work items 	forms without 
todo consumers pick 	modification permitted 
work items 	provided following 
range todo done 	conditions met 
todo start 	redistributions 
todo work 	source code 
items processed consumer 	must retain 
haven written 	copyright notice 
result stdout yet 	list conditions 
work items 	following disclaimer 
todo start todo 	redistributions 
end waiting 	binary form 
picked consumer ranges 	must reproduce 
modulo todo 	copyright notice 
size work items 	list conditions 
added protects 	following disclaimer 
variables signalled work 	documentation 
item added 	materials provided 
todo signalled result 	distribution software 
one work 	provided copyright 
item written stdout 	holders contributors 
signalled finished 	express implied 
everything skip leading 	warranties 
hunk mark 	including limited 
first file 	implied warranties 
wait work done 	merchantability fitness 
wake consumer 	particular purpose 
threads see work 	disclaimed shall 
pthreads valid 	copyright 
worktree file cache 	holder contributors 
entry identical 	liable direct 
even worktree file 	indirect incidental 
modified use 	special exemplary 
cache version instead 	consequential damages 
compensate loop 	including 
control ignore empty 	limited procurement 
line like 	substitute goods 
grep paths must 	services loss 
exist working 	use data 
pattern specified take 	profits business 
first unrecognized 	interruption 
non option pattern 	however caused 
follows must 	theory liability 
zero valid 	whether contract 
refs exists existing 	strict liability 
paths pattern 	tort including 
first unrecognized non 	negligence 
option beginning 	otherwise arising 
refs list continues 	way use 
exists paths 	software even 
die way beginning 	advised possibility 
skip separator 	damage references 
know cannot separating 	http 
revisions pathnames 	invisible island 
haven even patterns 	net xterm 
yet first 	ctlseqs ctlseqs 
unrecognized non option 	html http 
token check 	www waylabs 
revs paths rev 	www 
rest paths 	products wizcon 
grep.c grep defaults 	html todo 
opt run 	list filter 
opt arg 	bogus ctrl 
opt color opt 	combinations win 
prefix def 	support 
grep commit pattern 	bloat history 
type grep 	search like 
pattern type option 	ctrl readline 
create grep 	list escape 
pat tail pat 	sequences used 
len append 	program 
header grep pattern 	everything three 
append grep 	sequences order 
pattern append grep 	cheap may 
pat opt 	flickering effect 
pat ret error 	slow terminal 
opt error 	lesser 
erroffset options line 	sequences compatible 
eol match 	erase line 
eflags ovector 	sequence esc 
ret flags opt 	effect missing 
line eol 	clear cursor 
match eflags len 	end 
opt err 	line effect 
errbuf grep pat 	clear beginning 
list list 	line cursor 
list list list 	effect clear 
opt left 	entire line 
right opt header 	cuf 
expr opt 	ursor forward 
header expr opt 	sequence esc 
opt left 	effect moves 
opt data size 	cursor forward 
color opt 	chars cub 
sign opt name 	ursor 
line eol 	backward sequence 
match kwsm offset 	esc effect 
preg line 	moves cursor 
eol match 	backward chars 
eflags line eol 	following used 
match eflags 	terminal 
hit bol eol 	width getting 
eol field 	width tiocgwinsz 
len match one 	ioctl fails 
pattern match 	dsr device 
expr eval match 	status report 
expr match 	sequence 
line match next 	esc effect 
pattern next 	reports current 
match opt bol 	cusor position 
eol name 	esc row 
lno sign rest 	column multi 
match color 	line 
line color buf 	mode enabled 
match eflags 	also use 
grep use locks 	additional escape 
grep attr 	sequence however 
mutex grep 	multi line 
read mutex opt 	editing 
bol eol 	disabled cuu 
xecfg buf opt 	cursor sequence 
bol lno 	esc effect 
eol opt bol 	moves cursor 
end lno 	chars cud 
funcname lno funcname 	cursor 
needed eol 	sequence esc 
sign opt opt 	effect moves 
left lno 	cursor chars 
bol lno bol 	linenoise clear 
last bol 	screen called 
earliest hit opt 	two 
buf size 	additional escape 
driver buf size 	sequences used 
opt collect 	order clear 
hits bol left 	screen position 
lno last 	cursor home 
hit binary 	position 
match count lookahead 	cup cursor 
show function 	position sequence 
textconv xecfg eol 	esc effect 
hit buf 	moves cursor 
opt opt buf 	upper left 
size grep 	corner 
source init filename 	erase display 
data size 	sequence esc 
memset color color 	effect clear 
color color 	whole screen 
color color color 	order restore 
color strcmp 	exit 
strcmp strcmp strcmp 	atexit function 
strcmp die 	check restore 
userdiff config strcmp 	needed multi 
git config 	line mode 
strcmp parse 	single line 
pattern type arg 	atexit 
strcmp git 	time linenoise 
config strcmp git 	state structure 
config strcmp 	represents state 
git config colorbool 	line editing 
strcmp strcmp 	pass state 
strcmp strcmp strcmp 	functions 
strcmp strcmp 	implementing specific 
strcmp strcmp config 	editing functionalities 
error nonbool 	terminal stdin 
color parse color 	file descriptor 
parse config 	terminal stdout 
error nonbool color 	file 
parse memset 	descriptor edited 
strlen color color 	line buffer 
color color 	edited line 
color color color 	buffer size 
color create 	prompt 
grep pat 	display prompt 
xmalloc append header 	length current 
grep pattern 	cursor position 
append grep pat 	previous refresh 
xsnprintf xsnprintf 	cursor position 
die pcre compile 	current 
compile regexp 	edited line 
failed pcre study 	length number 
die pcre 	columns terminal 
exec size die 	maximum num 
pcre free 	rows used 
pcre free die 	far 
memchr regex 	multiline mode 
special kwsalloc kwsalloc 	history index 
kwsincr kwsprep 	currently editing 
compile pcre regexp 	ctrl ctrl 
regcomp regerror 	ctrl ctrl 
regfree compile regexp 	ctrl 
failed xcalloc 	ctrl ctrl 
compile pattern 	tab ctrl 
die die xcalloc 	ctrl enter 
compile pattern 	ctrl ctrl 
die compile pattern 	ctrl ctrl 
atom compile 	ctrl 
pattern die compile 	escape backspace 
pattern die 	debugging macro 
xcalloc compile pattern 	low level 
compile pattern 	terminal handling 
die xcalloc compile 	use multi 
pattern fputc 	line 
fputc indent dump 	mode terminal 
grep pat 	name list 
dump grep expression 	terminals know 
indent dump 	able understand 
grep expression dump 	basic escape 
grep expression 	sequences 
indent dump grep 	raw mode 
expression dump 	magic shit 
grep expression 	modify original 
indent dump grep 	mode input 
expression fflush 	modes parity 
xcalloc xcalloc die 	check 
die compile 	strip start 
regexp compile pattern 	stop output 
atom die 	control output 
grep expr grep 	modes disable 
expr grep 	post processing 
expr prep header 	control 
patterns compile 	modes bit 
regexp compile pattern 	chars local 
expr die 	modes choing 
grep splice grep 	canonical extended 
expr compile 	functions signal 
grep patterns real 	chars 
dump grep 	control chars 
expression free pattern 	condition min 
expr free 	number bytes 
pattern expr 	timer want 
free pattern expr 	read every 
free kwsfree 	single 
free pcre regexp 	without timeout 
regfree free 	timer put 
free free pattern 	terminal raw 
expr isalnum 	mode flushing 
want color output 	even check 
strlen output 	late 
output strlen output 	use esc 
output output 	escape sequence 
color output color 	query horizontal 
strlen output 	cursor position 
kwsexec regexec fixmatch 	error returned 
pcrematch regmatch 	success 
output output color 	position cursor 
output output 	report cursor 
color output 	location read 
output color strlen 	response esc 
output output 	rows cols 
color strlen output 	parse 
sep snprintf 	number columns 
output color strlen 	current terminal 
output sep 	fails ioctl 
next match output 	failed query 
color output 	terminal initial 
color output color 	position 
output pthread 	restore later 
mutex pthread mutex 	right margin 
unlock grep 	position restore 
source load driver 	position recover 
xdiff find 	clear screen 
func find func 	used 
isalpha match 	handle ctrl 
funcname show line 	nothing avoid 
match funcname 	warning beep 
match funcname 	used completion 
show funcname line 	nothing complete 
show line 	choices 
patmatch fwrite grep 	already shown 
source load 	completion free 
alloc filespec fill 	list completion 
filespec fill 	option populated 
filespec die grep 	linenoise completion 
read fill 	helper 
textconv grep read 	function linenoise 
unlock free 	edit called 
filespec grep source 	user types 
clear data 	tab key 
grep source load 	order complete 
driver grep 	currently 
attr userdiff textconv 	input state 
grep attr 	editing encapsulated 
unlock grep source 	pointed linenoise 
binary grep 	state structure 
source binary 	described structure 
die memset lookahead 	definition 
fill textconv 	show completion 
grep look ahead 	original buffer 
end line 	tab escape 
match line show 	show original 
name output 	buffer update 
output color strlen 	buffer 
output show 	last read 
pre context show 	character callback 
funcname line 	function called 
show line match 	tab completion 
funcname show 	function used 
line show name 	callback 
xdiff clear 	function registered 
find func output 	user order 
color strlen 	completion options 
output sep snprintf 	given input 
output strlen 	user typed 
grep source 	tab 
clr hit marker 	see example 
grep source 	source code 
chk hit marker 	easy understand 
grep source 	example line 
grep source init 	editing define 
grep source 	simple 
grep source clear 	append buffer 
free free 	structure heap 
free grep source 	allocated append 
clear data 	useful order 
free grep read 	write escape 
read sha 	sequences 
file grep read 	buffer flush 
unlock error 	standard output 
sha hex lstat 	single call 
error strerror 	avoid flickering 
isreg xsize 	effects single 
open xmallocz read 	line 
full error 	low level 
strerror close free 	line refresh 
close grep 	rewrite currently 
source load file 	edited line 
grep source 	accordingly buffer 
load sha die 	content 
grep attr 	cursor position 
userdiff find path 	number columns 
userdiff find 	terminal cursor 
name grep attr 	left edge 
unlock grep 	write prompt 
source load driver 	current 
grep source 	buffer content 
load buffer binary 	erase right 
initialize grep 	move cursor 
defaults hardcoded defaults 	original position 
could compiler 	recover write 
without initializers 	error 
code gets unwieldy 	multi line 
unreadable read 	low level 
configuration file store 	line refresh 
grep defaults 	rewrite currently 
initialize one instance 	edited line 
grep opt 	accordingly 
copy values read 	buffer content 
configuration information 	cursor position 
earlier call git 	number columns 
config grep 	terminal rows 
config fall atom 	used current 
use libpcre 	buf 
use libpcre regcomp 	cursor relative 
cannot accept 	row rpos 
patterns consider pattern 	refresh colum 
containing nul 	position zero 
atom atom atom 	update maxrows 
match beginning 	needed 
must either 	first step 
beginning line word 	clear lines 
boundary last 	used start 
must word similarly 	going last 
match end 	row every 
must either end 	row 
line word 	clear clean 
boundary next must 	top line 
word words 	write prompt 
consist least one 	current buffer 
character could 	content end 
one match line 	screen 
first match 	prompt need 
might strict word 	emit newline 
match later 	move prompt 
ones could forward 	first column 
next possible 	move cursor 
start next position 	right 
following non 	position current 
word call 	cursor relative 
collect hits without 	row till 
extended atom 	reach expected 
protects access gitattributes 	positon column 
machinery safe 	recover 
git attr mutex 	write error 
protecting access 	calls two 
rewind need look 	low level 
even back 	functions refresh 
find function signature 	single line 
back forward 	refresh 
punt complex stuff 	multi line 
punt header 	according selected 
stuff find beginning 	mode insert 
line textconv 	character cursor 
intimately tied diff 	current position 
filespecs pretend 	error 
one could 	writing terminal 
unify grep source 	returned otherwise 
diff filespec 	mlmode avoid 
structs mess could 	full update 
away fill 	line trivial 
textconv remotely safe 	move 
may load 	cursor left 
objects behind scenes 	move cursor 
modifies diff 	right move 
tempfile structure normal 	cursor start 
fill textconv 	line move 
usage diff machinery 	cursor 
would keep 	end line 
textconv buf separate 	substitute currently 
diff filespec 	edited line 
much grep code 	next previous 
passes around 	history entry 
grep source assumes 	specified 
buf pointer 	dir update 
beginning thing 	current history 
searching install textconv 	entry overwrite 
version grep 	next one 
source taking care 	show entry 
leak existing 	character 
buffer show hunk 	right cursor 
marks first 	without altering 
file threads easily 	cursor position 
identify first 	basically happens 
file always put 	keyboard key 
hunk marks 	backspace 
skip first one 	implementation previosu 
later work 	word maintaining 
done might shared 	cursor start 
textconv cache 	current word 
data safe know 	function core 
result textconv 	line 
text care binary 	editing capability 
handling unmatch 	linenoise expects 
look ahead 	already raw 
skips quickly line 	mode every 
possibly next 	key pressed 
hit call need 	returned 
something skipping 	asap read 
current line response 	resulting put 
unmatch current 	buf user 
line inside post 	type enter 
context window 	ctrl typed 
show current line 	function 
context around 	returns length 
previous hit doesn 	current buffer 
hit grep 	populate linenoise 
foo bla list 	state pass 
lines either 	functions implementing 
inversion done outside 	specific 
hit line 	editing functionalities 
haven shown pre 	buffer starts 
context lines 	empty make 
would need 	sure always 
show last hit 	space nulterm 
within post 	latest 
context need show 	history entry 
line see 	always current 
hit want show 	buffer initially 
needswork real 	empty autocomplete 
grep foo gives 	callback returns 
many bar 	error 
lines feels mostly 	reading otherwise 
useless sometimes 	character handled 
useful maybe make 	next errors 
another option 	read next 
suppress hit markers 	character enter 
meaningful top 	ctrl 
level node top 	backspace ctrl 
level nodes 	ctrl right 
hit markers see 	cursor line 
hits two 	empty act 
pass grep 	end file 
check buffer wide 	ctrl 
match otherwise 	swaps current 
toplevel terms hit 	character previous 
bit differently 	ctrl ctrl 
first clear hit 	ctrl ctrl 
markers user 	escape sequence 
provided buf intact 	read 
builtin git 	next two 
grep copyright junio 	bytes representing 
hamano use 	escape sequence 
one producer threads 	use two 
consumer threads 	calls handle 
producer adds work 	slow 
items todo 	terminals returning 
consumers pick work 	two chars 
items range 	different times 
todo done 	esc sequences 
todo start todo 	extended escape 
work items 	read 
processed consumer haven 	additional key 
written result 	right left 
stdout yet work 	home end 
items todo 	esc sequences 
start todo end 	home end 
waiting picked 	ctrl 
consumer ranges modulo 	whole line 
todo size 	ctrl current 
work items added 	end line 
protects variables 	ctrl start 
signalled work item 	line ctrl 
added todo 	end 
signalled result one 	line ctrl 
work item 	clear screen 
written stdout signalled 	ctrl previous 
finished everything 	word special 
skip leading 	mode used 
hunk mark first 	linenoise 
file wait 	order print 
work done wake 	scan codes 
consumer threads 	screen debugging 
see work pthreads 	development purposes 
valid worktree 	implemented linenoise 
file cache entry 	example 
identical even 	program keycodes 
worktree file modified 	option shift 
use cache 	left insert 
version instead compensate 	current right 
loop control 	left edge 
ignore empty line 	manually 
like grep 	raw mode 
paths must exist 	function calls 
working pattern 	line editing 
specified take first 	function linenoise 
unrecognized non 	edit stdin 
option pattern 	file 
follows must zero 	descriptor raw 
valid refs 	mode tty 
exists existing paths 	read file 
pattern first 	pipe interactive 
unrecognized non option 	editing high 
beginning refs 	level 
list continues exists 	function main 
paths die 	api linenoise 
way beginning skip 	library function 
separator know 	checks terminal 
cannot separating revisions 	basic capabilities 
pathnames haven 	checking 
even patterns yet 	blacklist stupid 
first unrecognized 	terminals later 
non option token 	either calls 
check revs 	line editing 
paths rev rest 	function uses 
paths grep 	dummy 
usage num 	fgets able 
threads threads source 	type something 
done todo 	even desperate 
todo start todo 	conditions history 
end todo 	free history 
done work added 	reset 
grep mutex 	used exit 
cond cond write 	avoid memory 
cond result 	leaks reported 
skip first line 	valgrind exit 
work ret 	fix terminal 
old done len 	initial 
arg hit 	conditions api 
opt opt buf 	call entry 
size opt 	linenoise history 
err hit read 	uses pointers 
sha file 	shifted memmoved 
opt sha 	history 
filename name len 	max length 
path pathbuf 	reached order 
hit opt filename 	older entry 
buf hit 	make room 
opt data len 	one exactly 
path list 	suitable 
opt prefix path 	huge histories 
list child 	work well 
status opt pathspec 	hundred entries 
cached hit 	circular buffer 
opt pathspec len 	smarter bit 
check attr 	complex 
hit entry old 	handle initialization 
baselen len 	first call 
sub data size 	duplicated lines 
opt pathspec 	heap allocated 
obj name path 	copy line 
data size 	history 
hit len 	reached max 
opt pathspec list 	length older 
hit real 	line maximum 
obj opt pathspec 	length history 
exc std 	function called 
dir hit opt 	even 
arg unset 	already history 
grep opt endp 	function make 
opt arg 	sure retain 
unset grep opt 	latest len 
stdin patterns 	elements history 
lno opt arg 	length 
unset grep 	smaller amount 
opt opt arg 	items already 
unset grep 	inside history 
opt opt arg 	copy everything 
unset grep 	free elements 
opt opt arg 	use 
unset grep 	save history 
opt opt 	specified file 
arg unset grep 	success returned 
opt argc 	otherwise returned 
argv prefix hit 	load history 
opt exclude 	specified 
seen dashdash external 	file file 
grep allowed 	exist zero 
ignored pager opt 	returned operation 
list pathspec 	performed file 
path list dummy 	exists 
use index 	operation succeeded 
pattern type arg 	returned otherwise 
options fallback 	error returned 
arg sha pager 	linenoise.h prompt 
len buf 	line len 
use exclude pthread 	filename 
mutex pthread 	filename linenoise 
mutex unlock grep 	guerrilla line 
pthread cond 	editing library 
wait size 	idea line 
grep unlock grep 	editing lib 
size write 	needs 
die grep source 	lines code 
clear pthread 	see linenoise 
cond signal pthread 	information copyright 
cond signal 	salvatore sanfilippo 
grep unlock work 	antirez gmail 
grep source 	dot 
grep source clear 	copyright pieter 
data work 	noordhuis pcnoordhuis 
done free grep 	gmail dot 
patterns free 	rights reserved 
strbuf pthread mutex 	redistribution use 
init pthread 	source 
mutex init pthread 	binary forms 
mutex init 	without modification 
pthread cond 	permitted provided 
init pthread cond 	following conditions 
init pthread 	met redistributions 
cond init size 	source 
strbuf init 	code must 
xcalloc grep opt 	retain copyright 
dup compile 	notice list 
grep patterns pthread 	conditions following 
create die 	disclaimer redistributions 
strerror grep pthread 	binary 
cond wait 	form must 
pthread cond broadcast 	reproduce copyright 
grep unlock 	notice list 
pthread free pthread 	conditions following 
mutex destroy 	disclaimer documentation 
pthread mutex destroy 	materials 
pthread mutex 	provided distribution 
destroy pthread cond 	software provided 
destroy pthread 	copyright holders 
cond destroy 	contributors express 
pthread cond destroy 	implied warranties 
grep config 	including 
git color config 	limited implied 
strcmp git 	warranties merchantability 
config die quote 	fitness particular 
path relative 	purpose disclaimed 
strbuf insert strbuf 	shall copyright 
addstr work 	holder 
strbuf release grep 	contributors liable 
source init 	direct indirect 
strbuf release grep 	incidental special 
source grep 	exemplary consequential 
source clear quote 	damages including 
path relative 	limited 
strbuf addstr work 	procurement substitute 
strbuf release 	goods services 
grep source init 	loss use 
strbuf release 	data profits 
grep source 	business interruption 
grep source clear 	however 
list append 	caused theory 
xstrndup argv push 	liability whether 
run command 	contract strict 
exit read cache 	liability tort 
isreg intent 	including negligence 
path match skip 	otherwise 
worktree stage 	arising way 
grep sha grep 	use software 
file stage 	even advised 
strcmp entry entry 	possibility damage 
len entry 	linenoise linit.c 
interesting strbuf isreg 	lualibs 
grep sha 	lib lua 
isdir read sha 	pushcfunction lua 
file die 	pushstring lua 
sha hex strbuf 	call linit 
addch init 	roberto exp 
desc grep 	initialization 
free strbuf setlen 	libraries lua 
grep sha 	see copyright 
grep read read 	notice lua 
reference grep 	liolib.c fnames 
read unlock die 	filename arg 
oid hex 	filename 
strlen strbuf init 	filename mode 
strbuf strbuf 	filename mode 
addch init desc 	findex mode 
grep strbuf 	filename idx 
release free die 	toclose filename 
deref tag 	rlen 
grep memset setup 	first nargs 
standard excludes 	success sucess 
fill directory dir 	arg nargs 
path match 	status mode 
grep file strtol 	modenames offset 
error strcmp 	mode 
fopen die 	modenames res 
errno strbuf getline 	iolib flib 
append grep 	fname cls 
pat fclose strbuf 	lua pushboolean 
release append 	lua pushnil 
grep pattern append 	lua 
grep pattern 	pushfstring strerror 
append grep pattern 	lua pushfstring 
append grep 	strerror lua 
pattern append grep 	pushinteger lua 
pattern init 	pushfstring strerror 
grep defaults git 	lua 
config grep 	argerror lua 
init parse options 	tostring lua 
grep commit 	checkany lua 
pattern type git 	touserdata lua 
config setup 	getfield lua 
git directory 	getmetatable 
strcmp append grep 	lua rawequal 
pattern git 	lua pushnil 
pager list append 	lua pushliteral 
die compile 	lua pushliteral 
grep patterns sha 	tofilep lua 
context parse 	error 
die verify non 	lua newuserdata 
filename path 	lua getmetatable 
strcmp die start 	lua setmetatable 
threads verify 	lua pushnil 
filename parse pathspec 	lua pushliteral 
die strlen 	tofilep 
dir sep strcmp 	lua pclose 
list append 	pushresult tofilep 
strcmp strcmp strbuf 	fclose pushresult 
addf strcmp 	lua getfenv 
list append strbuf 	lua getfield 
detach setup 	lua 
pager die 	tocfunction lua 
die grep directory 	isnone lua 
die setup 	rawgeti tofile 
work grep cache 	aux close 
die grep 	tofilep aux 
objects wait run 	close 
pager free 	tofilep lua 
grep patterns initialize 	pushliteral lua 
grep defaults 	pushfstring lua 
hardcoded defaults could 	checkstring lua 
compiler without 	optstring newfile 
initializers code gets 	fopen 
unwieldy unreadable 	pushresult lua 
read configuration file 	checkstring lua 
store grep 	optstring newfile 
defaults initialize one 	lua popen 
instance grep 	pushresult newfile 
opt copy values 	tmpfile 
read configuration 	pushresult lua 
information earlier 	rawgeti lua 
call git config 	touserdata lua 
grep config 	error lua 
fall atom use 	isnoneornil lua 
libpcre use 	tostring 
libpcre regcomp cannot 	newfile fopen 
accept patterns 	fileerror tofile 
consider pattern containing 	lua pushvalue 
nul atom 	lua rawseti 
atom atom match 	lua rawgeti 
beginning must 	iofile 
either beginning line 	iofile lua 
word boundary 	pushvalue lua 
last must word 	pushboolean lua 
similarly match 	pushcclosure tofile 
end must either 	aux lines 
end line 	lua 
word boundary next 	isnoneornil lua 
must word 	rawgeti lines 
words consist 	lua checkstring 
least one character 	newfile fopen 
could one 	fileerror aux 
match line first 	lines 
match might 	lua gettop 
strict word match 	fscanf lua 
later ones 	pushnumber lua 
could forward next 	pushnil getc 
possible start 	ungetc lua 
next position following 	pushlstring 
non word 	lua buffinit 
call collect hits 	lua prepbuffer 
without extended 	fgets lua 
atom protects access 	pushresult lua 
gitattributes machinery 	objlen strlen 
safe git attr 	lua 
mutex protecting 	addsize lua 
access rewind 	addsize lua 
need look even 	pushresult lua 
back find 	buffinit lua 
function signature back 	prepbuffer fread 
forward punt 	lua 
complex stuff punt 	addsize lua 
header stuff 	pushresult lua 
find beginning line 	objlen lua 
textconv intimately 	gettop clearerr 
tied diff filespecs 	read line 
pretend one 	lua 
could unify grep 	checkstack lua 
source diff 	type lua 
filespec structs mess 	tointeger test 
could away 	eof read 
fill textconv remotely 	chars lua 
safe may 	tostring 
load objects behind 	lua argcheck 
scenes modifies 	read number 
diff tempfile 	read line 
structure normal fill 	read chars 
textconv usage 	lua argerror 
diff machinery would 	ferror 
keep textconv 	pushresult lua 
buf separate diff 	pop lua 
filespec much 	pushnil read 
grep code passes 	getiofile read 
around grep 	tofile lua 
source assumes buf 	touserdata 
pointer beginning 	lua upvalueindex 
thing searching install 	lua error 
textconv version 	read line 
grep source taking 	ferror lua 
care leak 	error strerror 
existing buffer show 	lua 
hunk marks 	toboolean lua 
first file threads 	upvalueindex lua 
easily identify 	settop lua 
first file 	pushvalue lua 
always put hunk 	upvalueindex aux 
marks skip 	close 
first one later 	lua gettop 
work done 	lua type 
might shared textconv 	lua tonumber 
cache data 	lua checklstring 
safe know result 	fwrite pushresult 
textconv text 	write 
care binary handling 	getiofile write 
unmatch look 	tofile tofile 
ahead skips quickly 	lua checkoption 
line possibly 	lua optlong 
next hit call 	fseek pushresult 
need something 	lua 
skipping current line 	pushinteger ftell 
response unmatch 	tofile lua 
current line inside 	checkoption lua 
post context 	optinteger setvbuf 
window show 	pushresult pushresult 
current line context 	fflush 
around previous 	getiofile pushresult 
hit doesn hit 	fflush tofile 
grep foo 	lua newmetatable 
bla list lines 	lua pushvalue 
either inversion 	lua setfield 
done outside hit 	lua 
line haven 	newfile lua 
shown pre context 	pushvalue lua 
lines would 	rawseti lua 
need show last 	pushvalue lua 
hit within 	setfenv lua 
post context need 	setfield 
show line 	lua createtable 
see hit want 	lua pushcfunction 
show needswork 	lua setfield 
real grep 	createmeta newfenv 
foo gives many 	lua replace 
bar lines 	lua 
feels mostly useless 	newfenv createstdfile 
sometimes useful 	createstdfile createstdfile 
maybe make another 	lua pop 
option suppress 	lua getfield 
hit markers meaningful 	newfenv lua 
top level 	setfenv 
node top level 	lua pop 
nodes hit 	liolib roberto 
markers see hits 	exp standard 
two pass 	system library 
grep check buffer 	see copyright 
wide match 	notice 
otherwise toplevel terms 	lua calls 
hit bit 	lua api 
differently first clear 	may change 
hit markers 	file creating 
user provided 	file handles 
buf intact builtin 	always 
git grep 	creates closed 
copyright junio hamano 	file handle 
use one 	opening actual 
producer threads consumer 	file memory 
threads producer 	error file 
adds work items 	left 
todo consumers 	opened file 
pick work items 	handle currently 
range todo 	closed function 
done todo start 	close standard 
todo work 	files stdin 
items processed consumer 	stdout 
haven written 	stderr function 
result stdout yet 	close popen 
work items 	files function 
todo start todo 	close regular 
end waiting 	files make 
picked consumer 	sure 
ranges modulo todo 	argument file 
size work 	ignore closed 
items added protects 	files function 
variables signalled 	separated environment 
work item added 	defines correct 
todo signalled 	close 
result one work 	popen files 
item written 	check valid 
stdout signalled finished 	file handle 
everything skip 	current close 
leading hunk mark 	close file 
first file 	finished 
wait work done 	check valid 
wake consumer 	file handle 
threads see work 	arguments iterate 
pthreads valid 	input read 
worktree file cache 	result removed 
entry identical 	read 
even worktree 	fails eof 
file modified use 	close buffer 
cache version 	check whether 
instead compensate loop 	read something 
control ignore 	include eol 
empty line like 	close 
grep paths 	buffer read 
must exist working 	least eol 
pattern specified 	much read 
take first unrecognized 	number chars 
non option 	actually read 
pattern follows must 	read 
zero valid 	much time 
refs exists existing 	cannot read 
paths pattern 	asked still 
first unrecognized non 	read chars 
option beginning 	end count 
refs list continues 	eof 
exists paths 	close buffer 
die way 	arguments result 
beginning skip separator 	ensure stack 
know cannot 	space results 
separating revisions pathnames 	auxlib buffer 
haven even 	number 
patterns yet first 	line file 
unrecognized non 	read max 
option token check 	size chars 
revs paths 	always success 
rev rest paths 	last result 
grep.h next 	push 
origin pattern patternlen 	nil instead 
regexp pcre 	file already 
regexp pcre extra 	closed eof 
info kws 	generator created 
hit atom unary 	file close 
left right 	optimization 
pattern list 	could done 
pattern tail header 	exactly error 
list header 	create metatable 
tail pattern expression 	file handles 
prefix prefix 	push metatable 
length regexp linenum 	metatable 
invert ignore 	index metatable 
status name unmatch 	file methods 
name count 	copy environment 
word regexp match 	create environment 
debug binary 	fields input 
allow textconv extended 	output 
use reflog 	close open 
filter pcre relative 	library create 
pathname following 	files close 
name color max 	function files 
depth funcname 	pop environment 
funcbody extended regexp 	files 
option pattern 	create environment 
type option 	popen fenv 
color context color 	popen pop 
filename color 	popen llex.c 
function color lineno 	lua tokens 
color match 	newsize 
context color match 	token token 
selected color 	msg token 
selected color sep 	buff msg 
regflags pre 	str old 
context post context 	source seminfo 
last shown 	old 
show hunk mark 	seminfo count 
file heading 	seminfo sep 
priv opt data 	cont del 
size output 	seminfo seminfo 
priv grep opt 	sep sep 
prefix grep 	lua 
pattern type option 	lexerror lua 
grep commit 	resizebuffer cast 
pattern type 	lua lua 
append grep pat 	fix lua 
append grep 	strlen cast 
pattern append header 	lua 
grep pattern 	iscntrl lua 
opt opt opt 	pushfstring lua 
buf size 	pushfstring save 
name buf size 	lua buffer 
path driver 	lua token 
grep source init 	str 
opt opt 	lua chunkid 
opt grep use 	getstr lua 
locks grep 	pushfstring lua 
attr mutex grep 	pushfstring txt 
read mutex 	token lua 
pthread mutex pthread 	lua 
mutex unlock 	lexerror lua 
must end attribute 	newlstr lua 
lookups mutex 	setstr ttisnil 
used around 	setbvalue lua 
access attributes machinery 	check lua 
opt use 	curr 
threads must initialized 	newline next 
destroyed callers 	curr newline 
hash-object.c sha type 	next lua 
flags buf 	syntaxerror lua 
ret type path 	resizebuffer next 
flags literally 	strchr 
sha path type 	save next 
vpath flags 	lua bufflen 
literally type filters 	lua buffer 
flags literally 	localeconv buffreplace 
buf unquoted argc 	lua 
argv prefix 	str lua 
hash usage type 	buffer buffreplace 
hashstdin stdin 	lua lexerror 
paths filters 	lua isdigit 
literally flags vpath 	isdigit save 
hash options 	next 
prefix length errstr 	check next 
arg strbuf 	check next 
read hash sha 	isalnum save 
file literally 	next save 
strbuf release fstat 	buffreplace lua 
hash literally 	str 
index type die 	lua buffer 
sha hex 	trydecpoint lua 
maybe flush die 	save next 
open die 	save next 
errno hash strbuf 	save next 
getline strbuf 	curr 
reset unquote style 	newline inclinenumber 
die strbuf 	lua lexerror 
swap hash strbuf 	skip sep 
release strbuf 	save next 
release parse 	lua lexerror 
options setup git 	skip 
directory strlen 	sep save 
prefix filename git 	next save 
config error 	inclinenumber lua 
usage options hash 	resetbuffer save 
prefix filename 	next next 
hash hash stdin 	lua 
paths git 	newstring lua 
information manager hell 	buffer lua 
copyright linus 	bufflen save 
torvalds copyright junio 	next lua 
hamano create 	lexerror lua 
corrupt objects debugging 	lexerror 
needs bypass 	next save 
data conversion performed 	inclinenumber isdigit 
type limitation 	save next 
imposed index callees 	isdigit next 
hashmap.c str 	lua lexerror 
hash str 	save 
hash buf len 	save next 
hash ucbuf 	save next 
buf len hash 	save next 
ucbuf map 	lua newstring 
size map keydata 	lua buffer 
map key 	lua 
map newsize oldsize 	bufflen lua 
oldtable next 	resetbuffer inclinenumber 
map key keydata 	next next 
unused unused 	skip sep 
unused map function 	lua resetbuffer 
initial size 	read 
size map free 	lua resetbuffer 
entries iter 	curr newline 
map key keydata 	next skip 
map entry 	sep read 
map entry map 	lua lexerror 
key keydata 	next 
old map 	next next 
entry old map 	next next 
iter iter 	next next 
current ent len 	next read 
data keydata 	save next 
data len map 	check 
key xcalloc 	next check 
cmpfn alloc table 	next isdigit 
bucket free 	read numeral 
bucket entry alloc 	isspace lua 
table hashmap 	curr newline 
iter init hashmap 	next 
iter next 	isdigit read 
free free memset 	numeral isalpha 
find entry 	isalnum save 
ptr entry bucket 	next lua 
rehash find 	newstring lua 
entry ptr 	buffer 
rehash hashmap hashmap 	lua bufflen 
memcmp hashmap 	next llex 
init hashmap entry 	lua llex 
init memhash 	llex roberto 
hashmap flex alloc 	exp lexical 
mem hashmap 	analyzer 
entry init hashmap 	see copyright 
implementation hash 	notice lua 
key mappings grow 	order reserved 
shrink load 	reserved words 
factor percent calculate 	never collected 
resize thresholds 	reserved 
size shrink threshold 	word entry 
must slightly 	str make 
smaller grow threshold 	sure str 
resize factor 	collected skip 
prevent erratic resizing 	skip look 
thus divide 	ahead 
resize factor 	token initialize 
calculate initial table 	buffer read 
size allocate 	first lexical 
table entry fix 	analyzer format 
size rehash 	error update 
appropriate existing entry 	point 
fix size 	separator updated 
rehash appropriate initialize 	separator format 
pool hashmap 	error correct 
lookup interned pool 	point options 
found create 	undo change 
hashmap.h buf buf 	error 
buf len 	message lua 
buf len sha 	number optional 
hash next 	exponent sign 
hash table cmpfn 	follow locale 
size tablesize 	point format 
grow shrink map 	error 
next tablepos 	update point 
map function 	separator avoid 
initial size map 	warnings cont 
free entries 	used skip 
entry hash map 	starts newline 
key keydata 	skip 
map entry map 	avoid warnings 
entry map 	skip skip 
entry map key 	avoid wasting 
keydata map 	space avoid 
hash keydata key 	warnings avoid 
map iter 	warnings 
iter map iter 	save error 
data len 	next loop 
memcpy hashmap entry 	handles xxx 
init hashmap 	skip delimiter 
hashmap iter init 	comment skip 
hashmap iter 	sep 
next memintern strlen 	may dirty 
implementation hash 	buffer comment 
key mappings 	comment reserved 
see documentation technical 	word reserved 
api hashmap 	word single 
txt fnv functions 	tokens 
equivalent sha 	look ahead 
safe platforms support 	token use 
reads data 	one discharge 
structures hashmap functions 	read next 
hashmap entry 	token llex.h 
functions hashmap iter 	lua 
functions interning 	tokens source 
help.c cmds name 	str msg 
len ent 	token token 
cmds cmds cmds 	llex roberto 
excludes cmp 	exp lexical 
cmds colopts list 	analyzer 
copts name 	see copyright 
buf cmds path 	notice lua 
prefix dir 	maximum length 
buf len 	reserved word 
ent entlen prefix 	warning change 
main cmds 	order 
cmds env path 	enumeration grep 
exec path 	order reserved 
paths path colon 	terminal symbols 
colopts main 	denoted reserved 
cmds cmds exec 	words terminal 
path elem 	symbols 
elem longest current 	number reserved 
grp autocorrect 	words token 
aliases cmds old 	names semantics 
bad interpreter 	information current 
advice cmd best 	character charint 
similarity main 	input 
cmds cmds cmp 	line counter 
candidate assumed 	line last 
argc argv 	token consumed 
prefix similar refs 	current token 
refname oid 	look ahead 
flags data branch 	token 
remote similar 	func state 
refs cmd error 	parser input 
suggested refs 	stream buffer 
flex alloc mem 	tokens current 
alloc grow 	source name 
free free strcmp 	locale 
strcmp free 	point llimits.h 
strcmp free list 	llimits roberto 
append memset 	exp limits 
print columns list 	basic types 
clear stat 	installation dependent 
isreg open read 	definitions 
strcmp strcmp 	see copyright 
close opendir strbuf 	notice lua 
addf readdir 	chars used 
skip prefix 	small naturals 
strbuf setlen strbuf 	reserved characters 
addstr executable 	maximum 
strlen strip suffix 	safety conversion 
cmdname closedir 	pointer integer 
strbuf release getenv 	hashing problem 
git exec 	integer cannot 
path list commands 	hold whole 
dir qsort 	pointer 
uniq xstrdup strchr 	type ensure 
strcmp list 	maximum alignment 
commands dir free 	result usual 
qsort uniq 	argument conversion 
exclude cmds git 	lua number 
exec path 	assertions 
putchar pretty print 	house debugging 
cmdnames putchar 	avoid warnings 
putchar pretty print 	type machine 
cmdnames putchar 	instructions must 
strcmp size 	least bytes 
strlen strlen qsort 	see 
size puts 	details lopcodes 
size mput strlen 	maximum stack 
puts strcmp 	lua function 
strcmp git config 	minimum size 
skip prefix 	table must 
cmdname strlen git 	power 
config strcmp 	minimum size 
alloc grow free 	buffer macro 
memset memset 	control inclusion 
memset git config 	hard tests 
load command 	stack reallocation 
list cmd list 	lmathlib.c 
cmd list 	dmin dmax 
qsort uniq strcmp 	mathlib lua 
die size 	pushnumber fabs 
strcmp size starts 	lua checknumber 
levenshtein qsort 	lua pushnumber 
die similar 	sin 
enough clean cmdnames 	lua checknumber 
sleep millisec 	lua pushnumber 
similar enough exit 	sinh lua 
strrchr skip 	checknumber lua 
prefix strcmp list 	pushnumber cos 
append guess 	lua 
refs list clear 	checknumber lua 
exit always 	pushnumber cosh 
enable column display 	lua checknumber 
consult column 	lua pushnumber 
layout strategy stuff 	tan lua 
stat lstat 	checknumber 
cannot trust executable 	lua pushnumber 
bit peek 	tanh lua 
file instead dos 	checknumber lua 
executables start 	pushnumber asin 
also use 	lua checknumber 
aliases command lookup 	lua 
empirically derived 	pushnumber acos 
magic number abuses 	lua checknumber 
cmdname len 	lua pushnumber 
levenshtein distance avoid 	atan lua 
compiler stupidity 	checknumber lua 
exact match means 	pushnumber 
command reason 	atan lua 
exec ing gave 	checknumber lua 
enoent probably 	checknumber lua 
bad interpreter line 	pushnumber ceil 
candidate appear 	lua checknumber 
common cmds list 	lua 
yes one 	pushnumber floor 
common commands use 	lua checknumber 
entry common 	lua pushnumber 
cmds give prefix 	fmod lua 
match good 	checknumber lua 
score skip 	checknumber 
count prefix matches 	modf lua 
still counting 	checknumber lua 
prefix matches everything 	pushnumber lua 
ambiguous count 	pushnumber lua 
similar ones still 	pushnumber sqrt 
counting format 	lua 
kept stable compatibility 	checknumber lua 
external projects 	pushnumber pow 
rely output git 	lua checknumber 
version remote 	lua checknumber 
branch name deemed 	lua pushnumber 
similar builtin 	log 
help command emacsclient 	lua checknumber 
prints version 	lua pushnumber 
number stderr bother 	log lua 
checking emacsclient 	checknumber lua 
version seems always 	pushnumber exp 
exits code 	lua 
works emacsclient 	checknumber lua 
version simpler launch 	pushnumber lua 
konqueror kfmclient 	checknumber lua 
always put path 	pushnumber lua 
old path 	checknumber lua 
end man system 	pushnumber 
wide paths 	frexp lua 
find manual page 	checknumber lua 
old path 	pushinteger lua 
need delimiter unable 	pushnumber ldexp 
check git 	lua checknumber 
documentation directory open 	lua 
html defined 	checkint lua 
platform specific way 	gettop lua 
see example 	checknumber lua 
compat mingw use 	checknumber lua 
script web 	pushnumber lua 
browse display html 	gettop 
leaks exec 	lua checknumber 
bellow done 	lua checknumber 
ignore remaining args 	lua pushnumber 
next name 	lua number 
next info name 	rand lua 
html path 	gettop 
show show guides 	lua pushnumber 
colopts builtin 	lua checkint 
help options builtin 	lua argcheck 
help usage 	lua pushnumber 
name viewer buffer 	floor lua 
process argv 	checkint 
version path page 	lua checkint 
man page 	lua argcheck 
path page display 	lua pushnumber 
man page 	floor lua 
filename len path 	error srand 
page cmd 	lua 
page shell 	checkint lua 
cmd name name 	lua pushnumber 
len name 	lua setfield 
len name len 	lua pushnumber 
name len 	lua setfield 
name subkey namelen 	lua 
main cmds 	getfield lua 
cmds git cmd 	setfield lmathlib 
path old 	roberto exp 
path git man 	standard mathematical 
path name 	library see 
page info git 	copyright 
cmd viewer 	notice lua 
page fallback git 	number arguments 
cmd page 	number arguments 
page path page 	avoids rare 
free path 	needed also 
git cmd page 	systems 
page path 	sun rand 
name help 	may larger 
longest argc argv 	rand max 
prefix nongit 	check number 
strcmp strcmp strcmp 	arguments arguments 
die strcasecmp 	number 
start command error 	upper limit 
strbuf read 	lower upper 
close finish command 	limits open 
starts strbuf 	math library 
release error strbuf 	lmem.c block 
strlen atoi 	size 
strbuf release error 	size elems 
strbuf release 	limit errormsg 
check emacsclient version 	newblock newsize 
strbuf addf 	block osize 
execlp warning strerror 	nsize lua 
getenv strip 	runerror 
suffix xstrfmt basename 	lua reallocv 
strbuf addf 	lua runerror 
execlp warning 	lua frealloc 
strerror execlp warning 	lua lua 
strerror strbuf 	lmem roberto 
addf execl warning 	exp 
strerror flex 	memory manager 
alloc str strncasecmp 	see copyright 
strncasecmp strncasecmp 	notice lua 
flex alloc mem 	realloc function 
xstrdup supported 	frealloc ptr 
man viewer man 	size 
viewer info 	osize size 
warning supported man 	nsize osize 
viewer warning 	old size 
man viewer info 	nsize size 
parse config 	lua ensures 
key strcmp config 	ptr 
error nonbool 	iff osize 
man viewer path 	frealloc creates 
strcmp config 	block size 
error nonbool 	frealloc frees 
man viewer cmd 	block specific 
starts git 	frealloc 
column config strcmp 	must particularly 
config error 	frealloc nothing 
nonbool parse help 	equivalent free 
format strcmp 	ansi frealloc 
config error nonbool 	returns cannot 
xstrdup strcmp 	create 
config error nonbool 	reallocate area 
man viewer 	reallocation equal 
starts man viewer 	smaller size 
info git 	cannot fail 
config builtin load 	cannot cannot 
command list 	grow 
cmdlist cmdlist starts 	even little 
git command 	still least 
xstrfmt xstrfmt getenv 	one free 
system path 	place minimum 
strbuf addstr 	size update 
strbuf addch strbuf 	everything 
addstr free 	avoid warnings 
setenv strbuf release 	allocation routine 
man viewer 	lmem.h block 
info strcasecmp exec 	oldsize size 
man man 	block size 
strcasecmp exec woman 	size 
emacs strcasecmp 	elem limit 
exec man konqueror 	errormsg lmem 
exec man 	roberto exp 
cmd warning cmd 	memory manager 
page getenv 	see copyright 
setup man path 	notice 
exec viewer 	lua avoid 
exec viewer exec 	warnings loadlib.c 
viewer die 	lib path 
cmd page 	lib sym 
setenv system path 	lib path 
execlp die 	lib 
system path strstr 	lib sym 
stat mkpath 	buff nsize 
isreg die strbuf 	error buffer 
init strbuf 	lib path 
addf free execl 	lib lib 
git cmd 	sym 
cmd page html 	err str 
page path 	err file 
open html size 	err err 
strlen strlen 	num ret 
puts size mput 	lib path 
strlen puts 	img 
putchar parse options 	ret mod 
git config 	lib sym 
load command list 	nss lib 
list commands 	path lib 
list common 	sym path 
guides help list 	plib 
common cmds 	lib path 
help setup git 	sym reg 
directory gently 	path init 
git config parse 	stat filename 
help format 	path 
lookup git command 	name pname 
free show 	path filename 
man page show 	filename filename 
info page 	name modname 
show html page 	funcname mark 
always enable 	funcname 
column display consult 	name filename 
column layout 	funcname filename 
strategy stuff stat 	name stat 
lstat cannot 	name sentinel 
trust executable bit 	name modname 
peek file 	dot 
instead dos 	modname loaded 
executables start also 	fieldname envname 
use aliases 	def path 
command lookup empirically 	funcs funcs 
derived magic 	loaders dlclose 
number abuses cmdname 	dlopen 
len levenshtein 	lua pushstring 
distance avoid compiler 	dlerror dlsym 
stupidity exact 	lua pushstring 
match means command 	dlerror module 
reason exec 	file name 
ing gave enoent 	strrchr 
probably bad 	lua error 
interpreter line candidate 	lua gsub 
appear common 	lua tostring 
cmds list yes 	lua last 
one common 	error format 
commands use entry 	message 
common cmds 	lua pushstring 
give prefix 	lua pushfstring 
match good score 	free library 
skip count 	load library 
prefix matches still 	pusherror proc 
counting prefix 	address 
matches everything ambiguous 	pusherror link 
count similar 	edit error 
ones still counting 	lua pushstring 
format kept 	link module 
stable compatibility external 	dyld present 
projects rely 	lua 
output git version 	pushliteral create 
remote branch 	file image 
name deemed similar 	file link 
builtin help 	module destroy 
command emacsclient prints 	file image 
version number 	pusherror 
stderr bother 	lua pushstring 
checking emacsclient version 	errorfromcode lookup 
seems always 	symbol module 
exits code works 	lua pushfstring 
emacsclient version 	address symbol 
simpler launch konqueror 	lua 
kfmclient always 	pushliteral lua 
put path old 	pushliteral lua 
path end 	pushfstring lua 
man system wide 	gettable lua 
paths find 	isnil lua 
manual page old 	touserdata 
path need 	lua pop 
delimiter unable check 	lua newuserdata 
git documentation 	lua getmetatable 
directory open html 	lua setmetatable 
defined platform 	lua pushfstring 
specific way see 	lua 
example compat 	pushvalue lua 
mingw use 	settable lua 
script web browse 	checkudata unloadlib 
display html 	load sym 
leaks exec bellow 	lua pushcfunction 
done ignore 	lua 
remaining args help.c 	checkstring lua 
cmds name 	checkstring loadfunc 
len ent cmds 	lua pushnil 
cmds cmds 	lua insert 
excludes cmp cmds 	lua pushstring 
colopts list 	fopen 
copts name buf 	fclose strchr 
cmds path 	strlen lua 
prefix dir buf 	pushlstring lua 
len ent 	gsub lua 
entlen prefix main 	getfield lua 
cmds cmds 	tostring 
env path exec 	lua error 
path paths 	lua lua 
path colon 	pushliteral pushnexttemplate 
colopts main cmds 	lua gsub 
cmds exec 	lua tostring 
path elem elem 	lua 
longest current 	readable lua 
grp autocorrect aliases 	pushfstring lua 
cmds old 	lua concat 
bad interpreter advice 	lua error 
cmd best 	lua tostring 
similarity main cmds 	lua 
cmds cmp 	tostring lua 
candidate assumed argc 	checkstring findfile 
argv prefix 	lua loadfile 
similar refs refname 	loaderror strchr 
oid flags 	lua gsub 
data branch remote 	lua 
similar refs 	pushfstring lua 
cmd error suggested 	lua checkstring 
refs flex 	findfile mkfuncname 
alloc mem 	loadfunc loaderror 
alloc grow free 	lua checkstring 
free strcmp 	strchr 
strcmp free strcmp 	lua pushlstring 
free list 	findfile lua 
append memset print 	tostring mkfuncname 
columns list 	loadfunc loaderror 
clear stat isreg 	lua pushfstring 
open read 	lua 
strcmp strcmp close 	checkstring lua 
opendir strbuf 	getfield lua 
addf readdir skip 	istable lua 
prefix strbuf 	error lua 
setlen strbuf addstr 	lua getfield 
executable strlen 	lua 
strip suffix cmdname 	isnil lua 
closedir strbuf 	pushfstring lua 
release getenv 	checkstring lua 
git exec path 	settop lua 
list commands 	getfield lua 
dir qsort uniq 	getfield 
xstrdup strchr 	lua toboolean 
strcmp list commands 	lua touserdata 
dir free 	lua error 
qsort uniq exclude 	lua getfield 
cmds git 	lua istable 
exec path putchar 	lua 
pretty print 	error lua 
cmdnames putchar putchar 	lua pushliteral 
pretty print 	lua rawgeti 
cmdnames putchar strcmp 	lua isnil 
size strlen 	lua error 
strlen qsort size 	lua 
puts size 	tostring lua 
mput strlen puts 	pushstring lua 
strcmp strcmp 	call lua 
git config 	isfunction lua 
skip prefix cmdname 	isstring lua 
strlen git 	concat 
config strcmp alloc 	lua pop 
grow free 	lua pushlightuserdata 
memset memset memset 	lua setfield 
git config 	lua pushstring 
load command list 	lua call 
cmd list 	lua 
cmd list qsort 	isnil lua 
uniq strcmp 	setfield lua 
die size strcmp 	getfield lua 
size starts 	touserdata lua 
levenshtein qsort die 	pushboolean lua 
similar enough 	pushvalue 
clean cmdnames sleep 	lua setfield 
millisec similar 	lua getstack 
enough exit strrchr 	lua getinfo 
skip prefix 	lua iscfunction 
strcmp list 	lua error 
append guess refs 	lua 
list clear 	lua pushvalue 
exit always enable 	lua setfenv 
column display 	lua pop 
consult column layout 	lua pushvalue 
strategy stuff 	lua pushvalue 
stat lstat cannot 	lua 
trust executable 	call lua 
bit peek file 	pushvalue lua 
instead dos 	setfield lua 
executables start also 	pushstring lua 
use aliases 	setfield strrchr 
command lookup empirically 	lua 
derived magic 	pushlstring lua 
number abuses cmdname 	setfield lua 
len levenshtein 	checkstring lua 
distance avoid compiler 	gettop lua 
stupidity exact 	getfield lua 
match means 	getfield 
command reason exec 	lua istable 
ing gave 	lua pop 
enoent probably bad 	lua findtable 
interpreter line 	lua error 
candidate appear common 	lua pushvalue 
cmds list 	lua 
yes one common 	setfield lua 
commands use 	getfield lua 
entry common cmds 	isnil lua 
give prefix 	pop lua 
match good score 	pop modinit 
skip count 	lua 
prefix matches still 	pushvalue setfenv 
counting prefix 	dooptions lua 
matches everything ambiguous 	checktype lua 
count similar 	getmetatable lua 
ones still counting 	createtable lua 
format kept 	pushvalue 
stable compatibility 	lua setmetatable 
external projects rely 	lua pushvalue 
output git 	lua setfield 
version remote branch 	getenv lua 
name deemed 	pushstring lua 
similar builtin help 	gsub 
command emacsclient 	lua setprogdir 
prints version number 	lua setfield 
stderr bother 	lua newmetatable 
checking emacsclient version 	lua pushcfunction 
seems always 	lua setfield 
exits code works 	lua 
emacsclient version 	lua getfield 
simpler launch konqueror 	lua setfield 
kfmclient always 	lua pushvalue 
put path old 	lua replace 
path end 	lua createtable 
man system 	lua 
wide paths find 	pushcfunction lua 
manual page 	rawseti lua 
old path need 	setfield setpath 
delimiter unable 	setpath lua 
check git documentation 	pushliteral lua 
directory open 	setfield 
html defined platform 	lua findtable 
specific way 	lua setfield 
see example compat 	lua newtable 
mingw use 	lua setfield 
script web browse 	lua pushvalue 
display html 	lua 
leaks exec bellow 	lua pop 
done ignore 	loadlib roberto 
remaining args next 	exp library 
name next 	loader lua 
info name html 	see copyright 
path show 	notice 
show guides 	lua module 
colopts builtin help 	contains implementation 
options builtin 	loadlib unix 
help usage name 	systems dlfcn 
viewer buffer 	implementation darwin 
process argv version 	mac 
path page 	implementation windows 
man page path 	stub systems 
page display 	prefix open 
man page filename 	functions libraries 
len path 	separator open 
page cmd page 	functions 
shell cmd 	libraries error 
name name len 	codes loadfunc 
name len 	implementation loadlib 
name len name 	dlfcn dlfcn 
len name 	available linux 
subkey namelen main 	sun 
cmds cmds 	solaris irix 
git cmd 	free bsd 
path old path 	net bsd 
git man 	aix hpux 
path name page 	probably unix 
info git 	flavors 
cmd viewer page 	least emulation 
fallback git 	layer top 
cmd page page 	functions implementation 
path page 	loadlib windows 
free path git 	functions original 
cmd page 	mac 
page path name 	darwin implementation 
help longest 	mac appends 
argc argv prefix 	function names 
nongit strcmp 	would rare 
strcmp strcmp die 	prevents crashing 
strcasecmp start 	happens 
command error strbuf 	fallback systems 
read close 	avoid warnings 
finish command 	avoid warnings 
starts strbuf release 	avoid warnings 
error strbuf 	check library 
strlen atoi strbuf 	registry 
release error 	entry entry 
strbuf release check 	yet create 
emacsclient version 	one tag 
strbuf addf execlp 	method calls 
warning strerror 	library unloadlib 
getenv strip suffix 	function 
xstrfmt basename 	lib handle 
strbuf addf execlp 	mark library 
warning strerror 	closed unable 
execlp warning strerror 	load library 
strbuf addf 	unable find 
execl warning strerror 	function 
flex alloc 	function errors 
str strncasecmp 	loaded function 
strncasecmp strncasecmp flex 	error error 
alloc mem 	message stack 
xstrdup supported man 	top nil 
viewer man 	error 
viewer info warning 	message require 
supported man 	function open 
viewer warning man 	file open 
viewer info 	failed skip 
parse config key 	separators templates 
strcmp config 	find 
error nonbool man 	next separator 
viewer path 	error accumulator 
strcmp config error 	path file 
nonbool man 	exist readable 
viewer cmd starts 	file name 
git column 	file 
config strcmp config 	name entry 
error nonbool 	possible error 
parse help 	message found 
format strcmp config 	library found 
error nonbool 	path library 
xstrdup strcmp config 	loaded 
error nonbool 	successfully gsub 
man viewer starts 	result library 
man viewer 	found path 
info git config 	library loaded 
builtin load 	successfully root 
command list cmdlist 	root 
cmdlist starts 	found real 
git command xstrfmt 	error function 
xstrfmt getenv 	found found 
system path strbuf 	loaded table 
addstr strbuf 	index check 
addch strbuf addstr 	loops 
free setenv 	already loaded 
strbuf release man 	must load 
viewer info 	iterate available 
strcasecmp exec 	loaders error 
man man strcasecmp 	message accumulator 
exec woman 	loader 
emacs strcasecmp exec 	call find 
man konqueror 	module module 
exec man cmd 	loaded successfully 
warning cmd 	loader returned 
page getenv setup 	error message 
man path 	accumulate 
exec viewer exec 	loaded name 
viewer exec 	sentinel pass 
viewer die cmd 	name argument 
page setenv 	module run 
system path execlp 	loaded module 
die system 	non 
path strstr stat 	nil loaded 
mkpath isreg 	name returned 
die strbuf init 	module use 
strbuf addf 	result extra 
free execl 	copy returned 
git cmd cmd 	loaded 
page html 	name module 
page path open 	function calling 
html size 	function option 
strlen strlen puts 	function module 
size mput 	module module 
strlen puts putchar 	look 
parse options 	last dot 
git config load 	module name 
command list 	name full 
list commands list 	module name 
common guides 	minus last 
help list common 	part 
cmds help 	index loaded 
setup git directory 	table loaded 
gently git 	modname found 
config parse 	previous result 
help format lookup 	variable create 
git command 	one 
free show man 	exist loaded 
page show 	modname table 
info page show 	check whether 
html page 	table already 
always enable column 	name field 
display consult 	table 
column layout strategy 	initialized module 
stuff stat 	initialize create 
lstat cannot trust 	metatable index 
executable bit 	auxiliary mark 
peek file instead 	use environment 
dos executables 	variable 
start also use 	use replace 
aliases command 	auxmark auxmark 
lookup empirically derived 	path create 
magic number 	type loadlib 
abuses cmdname 	create table 
len levenshtein distance 	create 
avoid compiler 	loaders table 
stupidity exact match 	fill pre 
means command 	defined loaders 
reason exec ing 	put field 
gave enoent 	loaders field 
probably bad interpreter 	path 
line candidate 	field cpath 
appear common cmds 	store config 
list yes 	information field 
one common commands 	loaded field 
use entry 	preload open 
common cmds give 	lib 
prefix match 	table table 
good score skip 	lobject.c lua 
count prefix 	nilobject log 
matches still counting 	result endptr 
prefix matches 	str fmt 
everything ambiguous 	argp 
count similar ones 	buff buff 
still counting 	buff fmt 
format kept stable 	msg argp 
compatibility external 	source bufflen 
projects rely output 	len cast 
git version 	ttype 
remote branch name 	ttype ttype 
deemed similar 	luai numeq 
builtin help command 	nvalue nvalue 
emacsclient prints 	bvalue bvalue 
version number stderr 	pvalue pvalue 
bother checking 	lua 
emacsclient version seems 	iscollectable gcvalue 
always exits 	gcvalue lua 
code works emacsclient 	str number 
version simpler 	cast num 
launch konqueror kfmclient 	strtoul isspace 
always put 	setsvalue 
path old 	lua incr 
path end man 	top pushstr 
system wide 	strchr setsvalue 
paths find manual 	lua newlstr 
page old 	incr top 
path need delimiter 	arg 
unable check 	pushstr cast 
git documentation directory 	arg pushstr 
open html 	setnvalue cast 
defined platform specific 	num arg 
way see 	incr top 
example compat mingw 	setnvalue 
use script 	cast num 
web browse display 	arg incr 
html leaks 	top sprintf 
exec bellow done 	arg pushstr 
ignore remaining 	pushstr 
args help.h alloc 	pushstr pushstr 
cnt len 	lua concat 
name num 	cast svalue 
cmd prefix main 	start lua 
cmds cmds 	pushvfstring end 
cmds name len 	strncpy 
cmds excludes 	strlen strcpy 
cmds name colopts 	strcat strcat 
main cmds 	strcspn strcpy 
cmds cmd error 	strncat strcat 
putchar also 	strcat strcat 
used similarity index 	lobject 
help require 	roberto exp 
excludes sorted list 	functions lua 
call die 	objects see 
suspected user mistyped 	copyright notice 
command give 	lua converts 
suggested correct refs 	integer 
help hex.c 	floating point 
hexval table 	represented eeeeexxx 
hex sha val 	real xxx 
hex oid 	eeeee eeeee 
buffer sha hex 	xxx otherwise 
buf val 	expoent 
sha bufno hexbuffer 	converts back 
oid hexval 	must conversion 
hexval sha hex 	failed maybe 
sha hex 	hexadecimal constant 
sha hex hex 	common invalid 
caught val 	trailing 
hex nul avoid 	characters function 
reading past 	handles formats 
end hstrerror.c err 	enough space 
buffer snprintf 	first ensures 
http-backend.c content type 	termination source 
content length 	source 
last modified getanyfile 	skip last 
max request 	part file 
buffer query 	name stop 
name config name 	first newline 
rpc service 	must truncate 
query name name 	lobject.h 
fmt buffer 	lua nilobject 
args code msg 	result fmt 
name name 	argp fmt 
name err err 	source len 
type buf 	lobject roberto 
type name buf 	exp 
alloc buf 	type definitions 
name name name 	lua objects 
name svc 	see copyright 
name svc name 	notice lua 
svc user 	tags values 
alloc buf cnt 	visible 
prog name 	lua extra 
buffer input stream 	tags non 
full request 	values collectable 
buf buf 	objects common 
cnt ret prog 	header collectable 
name buf 	objects 
argv buffer input 	macro form 
encoding user 	included objects 
host gzipped request 	common header 
cld name 	form lua 
oid flag data 	values tagged 
name nons 	values 
buf arg service 	macros test 
name buf 	type macros 
argv svc refname 	access values 
oid flag 	debug macros 
data buf unused 	values different 
target target 	types 
nons arg buf 	sets according 
arg objdirlen 	destination stack 
buf cnt accepted 	stack stack 
type actual 	stack table 
type service 	table table 
name argv svc 	index 
buf dead 	stack elements 
err buf pathinfo 	headers table 
root path 	ensures maximum 
method pattern argc 	alignment ensures 
argv method 	maximum alignment 
dir cmd cmd 	local 
arg proto 	udata function 
getenv xcalloc url 	prototypes constants 
decode parameter 	used function 
name url decode 	functions defined 
parameter list 	inside function 
lookup list insert 	map 
free list 	opcodes source 
lookup parameters start 	lines information 
vsnprintf end 	local variables 
die write 	upvalue names 
die format write 	size size 
format write 	number 
format write show 	upvalues masks 
date date 	style vararg 
mode hdr str 	first point 
hdr str 	variable active 
hdr str hdr 	first point 
str time 	variable 
hdr date hdr 	dead upvalues 
date hdr 	points stack 
str write die 	closed linked 
http status 	list open 
hdr nocache end 	closures tables 
headers start 	chaining 
vfprintf end exit 	means tagmethod 
http status 	present log 
hdr nocache end 	size node 
headers start 	part free 
vfprintf end 	position position 
exit forbidden hdr 	size 
hdr str 	module operation 
end headers write 	hashing size 
die git 	always power 
pathdup xmalloc open 	lopcodes.c lua 
found strerror 	opnames lua 
fstat die errno 	opmodes 
hdr hdr 	lopcodes roberto 
str hdr date 	exp see 
end headers 	copyright notice 
xread die errno 	lua order 
write die 	mode opcode 
close free free 	move 
getanyfile hdr 	loadk loadbool 
nocache send local 	loadnil getupval 
file getanyfile 	getglobal gettable 
hdr cache forever 	setglobal setupval 
send local 	settable newtable 
file getanyfile 	self 
hdr cache forever 	sub mul 
send local 	div mod 
file getanyfile hdr 	pow unm 
cache forever 	len concat 
send local file 	jmp test 
git config 	testset 
git config size 	call tailcall 
strbuf addf 	forloop forprep 
git config strbuf 	tforloop setlist 
reset strbuf 	close closure 
release skip prefix 	vararg lopcodes.h 
forbidden size 	lua 
strcmp forbidden getenv 	opmodes lua 
forbidden xmalloc 	opnames lopcodes 
read full free 	roberto exp 
die alloc 	opcodes lua 
realloc memset git 	machine see 
inflate init 	copyright 
gzip read 	notice lua 
request xread die 	instructions numbers 
git inflate 	instructions opcode 
die write full 	first bits 
die git 	instructions following 
inflate end close 	fields 
free read 	bits bits 
request die errno 	bits bits 
write full 	together argument 
die close free 	represented excess 
getenv getenv 	number minus 
getenv strcmp strcmp 	exactly 
getenv argv 	maximum argument 
pushf getenv argv 	max represented 
pushf start 	max represented 
command exit close 	max half 
inflate request 	maximum corresponding 
copy request 	argument 
close finish command 	basic instruction 
exit strip 	format size 
parse strbuf addf 	position opcode 
oid hex 	arguments limits 
deref tag strbuf 	opcode arguments 
addf oid 	use 
hex parameter hdr 	manipulate arguments 
nocache service 	must fit 
strbuf addf hdr 	luai bitsint 
str end 	bits sign 
headers packet write 	creates mask 
packet flush 	bits 
run service getanyfile 	position creates 
namespaced send 	mask bits 
strbuf strbuf release 	position following 
resolve strip 	macros help 
strbuf addf strbuf 	manipulate instructions 
addf oid 	macros 
hex getanyfile 	operate indices 
head namespaced send 	bit means 
strbuf strbuf 	constant means 
release strlen directory 	test whether 
getanyfile prepare 	constant gets 
packed git strbuf 	index 
grow strbuf 	constant code 
addf strbuf addch 	constant index 
hdr nocache 	invalid fits 
send strbuf strbuf 	bits kst 
release getenv 	constant constant 
strcmp http status 	table 
hdr nocache 	isk kst 
end headers format 	indexk grep 
write exit 	order change 
service strbuf reset 	enums name 
strbuf addf 	args description 
check content type 	kst 
hdr nocache 	nil gbl 
strbuf reset 	kst gbl 
strbuf addf hdr 	kst size 
str end 	length see 
headers run service 	note nil 
strbuf release 	fpf 
vreportf http status 	close variables 
hdr nocache 	stack closure 
end headers exit 	kproto vararg 
getenv getenv 	notes call 
getenv die daemon 	top number 
avoid die 	returns 
end url slash 	call sets 
strbuf addstr 	top last 
strbuf detach xstrdup 	result next 
die getenv 	open instruction 
git setup gettext 	call setlist 
git extract 	may 
argv path die 	use top 
routine die 	vararg use 
recursing routine 	actual number 
die strcmp getdir 	varargs top 
size regcomp 	like call 
die regexec strcmp 	top 
getenv strcmp 	setlist top 
http status hdr 	next instruction 
str strcmp 	real comparisons 
http status hdr 	specifies condition 
nocache end 	test accept 
headers xmemdupz regfree 	skips 
found setup 	next instruction 
path enter repo 	jump masks 
found getenv 	instruction properties 
access found http 	format bits 
config git 	mode bits 
env imp basically 	arg 
strbuf read 	mode bits 
hit max request 	arg mode 
buffer die 	bit instruction 
rather reject 	bit test 
maliciously large request 	argument used 
chew infinite 	argument 
memory read read 	used argument 
full means 	jump offset 
hit eof otherwise 	argument constant 
grow nothing 	constant opcode 
left read service 	names number 
name successfully 	list 
reported failure http-fetch.c 	items accumulate 
http fetch 	setlist instruction 
usage argc argv 	loslib.c filename 
walker commits 	filename fromname 
stdin commits write 	toname buff 
commit url 	err 
arg history verbosely 	key key 
recover git 	key res 
setup gettext 	key res 
git extract argv 	stm reslen 
path usage 	buff cat 
strcmp strcmp usage 	catnames 
walker targets 	syslib lua 
stdin warning str 	pushboolean lua 
end url 	pushnil lua 
slash setup git 	pushfstring strerror 
directory git 	lua pushinteger 
config http init 	lua 
http walker 	pushinteger system 
walker fetch walker 	lua optstring 
targets free 	lua checkstring 
walker free http 	pushresult lua 
cleanup free 	checkstring lua 
http-push.c http push 	checkstring 
usage pushing 	pushresult rename 
aborted remote dir 	lua tmpnam 
exists push 	lua error 
verbosely push 	lua pushstring 
force dry run 	lua pushstring 
helper status 	getenv 
objects url path 	lua checkstring 
path len 	lua pushnumber 
info refs update 	clock lua 
info refs 	pushinteger lua 
info packs packs 	setfield lua 
locks repo 	pushboolean 
obj url dest 	lua setfield 
headers buffer 	lua getfield 
curl result errorstr 	lua isnil 
http code 	lua toboolean 
user data slot 	lua pop 
next request 	lua 
queue head name 	getfield lua 
len cdata 	isnumber lua 
ctx tag closed 	tointeger lua 
user data 	error lua 
url owner 	pop lua 
token tmpfile suffix 	optstring 
start time 	lua opt 
timeout refreshing next 	time gmtime 
path user 	localtime lua 
data flags dentry 	pushnil strcmp 
name dentry 	lua createtable 
flags parent buf 	setfield 
curl url 	setfield setfield 
custom req curl 	setfield setfield 
url custom 	setfield setfield 
req buffer write 	setfield setboolfield 
dav token 	lua buffinit 
headers request request 	lua 
callback data 	addchar strftime 
request request slot 	lua addlstring 
obj req 	lua pushresult 
request hex slot 	lua isnoneornil 
request target 	time lua 
check request 	checktype 
preq request hex 	lua settop 
slot buf 	getfield getfield 
hdr unpacked len 	getfield getfield 
hdrlen size 	getfield getfield 
stream request slot 	getboolfield mktime 
dav headers 	time 
slot results dav 	lua pushnil 
headers current 	lua pushnumber 
time time remaining 	lua pushnumber 
request entry 	difftime time 
request preq obj 	lua checknumber 
req fail 	time 
running queue unused 	lua optnumber 
request parent 	lua optstring 
obj request obj 	lua checkoption 
request target 	lua pushstring 
ret sha 	setlocale exit 
obj ctx tag 	lua 
closed flags 	optint lua 
ctx tag closed 	loslib roberto 
sha ctx 	exp standard 
token sha arg 	operating system 
refname user 	library see 
data name atts 	copyright 
ctx old 	notice lua 
namelen len user 	calls lua 
data name 	api may 
ctx user data 	change push 
len ctx 	nil time 
path timeout slot 	date 
results buffer 	operations year 
buffer url timeout 	month day 
header dav 	hour min 
headers ctx escaped 	sec wday 
saved character 	yday isdst 
parser slot 	undefined 
results prev dav 	field utc 
headers next 	skip invalid 
signo path flags 	date number 
user func 	fields conversion 
user data path 	specifier big 
sha hex 	enough 
parent path sha 	conversion result 
ctx tag 	called without 
closed path url 	args current 
path flags 	time make 
user func user 	sure table 
data url 	top 
slot results buffer 	lparser.c token 
buffer dav 	limit msg 
headers ctx parser 	varname oldsize 
parent path 	name nvars 
hex val slot 	tolevel name 
results buffer 	oldsize 
buffer dav 	level varname 
headers ctx flags 	nvars nexps 
escaped parser 	extra reg 
obj entry blob 	isbreakable func 
obj obj 	oldsize buff 
desc entry revs 	name 
commit count 	lexstate funcstate 
entry obj name 	key tostore 
sha slot 	reg key 
results buffer dav 	val rkkey 
headers remote 	line nparams 
refs refname obj 	needself 
buf buffer 	line args 
slot results dav 	nparams line 
headers path 	line key 
url ret path 	key left 
symref sha 	right limit 
url buffer name 	uop 
head sha 	nextop token 
remote head 	prev extra 
branch pattern force 	conflict nvars 
refs remote 	nexps upval 
head sha symref 	line whileinit 
match patlen 	condexit 
slot results url 	line condexit 
name namelen 	repeat init 
argc argv request 	line nvars 
next request 	isnum prep 
refspec refspec info 	endfor varname 
revs branch 	line 
force objects send 	indexname nvars 
refs local 	line line 
refs arg path 	varname condexit 
commit argv 	line flist 
strbuf addstr xml 	escapelist nvars 
quoted strbuf 	nexps 
detach curl 	needself line 
easy setopt curl 	needself first 
easy setopt 	nret line 
curl easy setopt 	islast lua 
curl easy 	newstring getstr 
setopt curl easy 	lua 
setopt curl 	syntaxerror lua 
easy setopt curl 	pushfstring lua 
easy setopt 	token str 
curl easy setopt 	lua pushfstring 
curl easy 	lua pushfstring 
setopt curl easy 	lua 
setopt curl 	lexerror lua 
easy setopt curl 	next error 
easy setopt 	expected check 
curl easy setopt 	lua next 
curl easy 	testnext error 
setopt curl easy 	expected 
setopt finish 	lua syntaxerror 
request http 	lua pushfstring 
request start active 	lua token 
slot release 	str lua 
http request release 	token 
request oid 	str check 
hex remote url 	lua next 
active slot 	init exp 
curl setup http 	lua codestring 
curl easy 	str checkname 
setopt start active 	lua 
slot free 	growvector lua 
find sha pack 	objbarrier lua 
oid hex 	checklimit cast 
release request sha 	getlocvar getlocvar 
hex oid 	lua lua 
hex http pack 	checklimit 
request strcmp 	lua growvector 
release http pack 	lua objbarrier 
request release 	lua cast 
request start 	cast getlocvar 
active slot release 	init exp 
http pack 	searchvar 
request release request 	init exp 
oid hex 	markupval singlevaraux 
read sha file 	indexupvalue str 
xsnprintf git 	checkname singlevaraux 
deflate init git 	lua hasmultret 
deflate bound 	lua 
strbuf init git 	setreturns lua 
deflate git 	reserveregs lua 
deflate git deflate 	exp nextreg 
end free 	lua reserveregs 
strbuf addstr append 	lua nil 
remote url 	lua 
strbuf detach append 	lexerror lua 
remote url 	removevars lua 
strbuf strbuf detach 	code abc 
active slot 	lua lua 
curl setup 	lua patchtohere 
http start active 	lua 
slot free 	growvector lua 
active slot curl 	objbarrier init 
setup http 	exp lua 
curl slist append 	code lua 
curl slist 	code abc 
append curl easy 	lua 
setopt start 	newproto lua 
active slot free 	sethvalue incr 
dav token 	top setptvalue 
headers active slot 	incr top 
curl setup 	removevars lua 
http curl easy 	ret 
setopt start 	lua reallocvector 
active slot run 	lua reallocvector 
active slot 	lua reallocvector 
time curl slist 	lua reallocvector 
free time 	lua reallocvector 
refresh free 	lua 
free check locks 	reallocvector lua 
curl slist 	lua checkcode 
free free start 	lua anchor 
put oid 	token lua 
hex start move 	setinput lua 
oid hex 	open 
oid hex release 	func lua 
request oid 	next chunk 
hex finish http 	check close 
request release 	func lua 
http request release 	lua lua 
request start 	lua 
fetch packed finish 	exp anyreg 
http pack 	lua next 
request release http 	checkname lua 
pack request 	indexed lua 
release request 	next expr 
start fetch loose 	lua 
start put 	exp val 
start mkcol check 	checknext lua 
locks remote 	checklimit checkname 
list xmalloc fill 	yindex checknext 
active slots 	lua exp 
step active slots 	expr 
check locks 	lua code 
remote list find 	abc lua 
sha pack 	exp lua 
xmalloc fill active 	exp nextreg 
slots step 	lua setlist 
active slots http 	hasmultret 
info packs 	lua setmultret 
lookup parse list 	lua setlist 
contains list 	lua exp 
insert strcmp strcmp 	nextreg lua 
strcmp strcmp 	setlist expr 
xstrdup strcmp 	lua 
skip prefix strtol 	checklimit lua 
strcmp xstrdup 	code abc 
git sha init 	init exp 
git sha 	init exp 
update strlen git 	lua exp 
sha memcpy 	nextreg 
sha hex strchr 	checknext testnext 
strlen strlen 	testnext lua 
xrealloc xsnprintf free 	closelistfield lua 
user func 	lookahead listfield 
strchr user func 	recfield recfield 
strlen strlen 	listfield 
free xmemdupz xstrfmt 	check match 
strchr strlen 	lastlistfield setarg 
active slot curl 	lua setarg 
setup http 	lua testnext 
start active slot 	localvar str 
run active 	checkname 
slot free 	lua next 
free strchr xml 	localvarliteral lua 
entities ident 	syntaxerror lua 
email strbuf addf 	adjustlocalvars cast 
free xsnprintf 	lua reserveregs 
curl slist append 	open 
curl slist 	func checknext 
append active slot 	localvarliteral adjustlocalvars 
curl setup 	parlist checknext 
http curl easy 	chunk check 
setopt curl 	match close 
easy setopt xcalloc 	func 
start active 	pushclosure expr 
slot run active 	testnext lua 
slot xml 	exp nextreg 
parser create xcalloc 	expr lua 
xml user 	syntaxerror lua 
data xml element 	next 
handler xml 	explist lua 
character data 	setmultret check 
handler xml parse 	match constructor 
free xml 	codestring lua 
error xml error 	next lua 
code xml 	syntaxerror 
parser free curl 	lua hasmultret 
slist free 	lua exp 
strbuf release strbuf 	nextreg init 
release free 	exp lua 
free free free 	code abc 
time dav 	lua 
token headers active 	fixline lua 
slot curl 	next expr 
setup http curl 	check match 
easy setopt 	lua dischargevars 
start active slot 	singlevar lua 
run active 	syntaxerror 
slot curl 	prefixexp field 
slist free free 	lua exp 
free free 	anyreg yindex 
free unlock remote 	lua indexed 
locks sigchain 	lua next 
pop strlen memcpy 	checkname 
memcpy sha 	lua self 
hex strcmp skip 	funcargs lua 
prefix sha 	exp nextreg 
hex objpath one 	funcargs init 
remote strcmp 	exp codestring 
one remote strcmp 	init 
str end 	exp init 
url slash user 	exp init 
func strcmp 	exp check 
remote user func 	condition lua 
strcmp strstr 	init exp 
strchr strncmp error 	lua 
xstrdup strcmp 	code abc 
strcmp free 	constructor lua 
xstrfmt xstrdup strbuf 	next body 
addf curl 	primaryexp lua 
slist append curl 	next enterlevel 
slist append 	getunopr 
active slot curl 	lua next 
setup http 	subexpr lua 
curl easy setopt 	prefix simpleexp 
curl easy 	getbinopr lua 
setopt start active 	next lua 
slot run 	infix 
active slot xml 	subexpr lua 
parser create 	posfix leavelevel 
xcalloc xml user 	subexpr enterblock 
data xml 	chunk lua 
element handler xml 	leaveblock lua 
character data 	code 
handler xml parse 	abc lua 
free xml 	reserveregs check 
error xml 	condition testnext 
error code xml 	primaryexp check 
parser free 	conflict lua 
free free strbuf 	checklimit 
release strbuf 	assignment checknext 
release curl slist 	explist adjust 
free remote 	assign lua 
xml entities strbuf 	setoneret lua 
addf free 	storevar init 
curl slist append 	exp 
curl slist 	lua storevar 
append active slot 	expr lua 
curl setup 	goiftrue lua 
http curl easy 	syntaxerror lua 
setopt curl 	code abc 
easy setopt start 	lua 
active slot 	concat lua 
run active slot 	jump lua 
xml parser 	next lua 
create xcalloc 	getlabel cond 
xml user data 	enterblock checknext 
xml element 	block 
handler xml parse 	lua patchlist 
free xml 	lua jump 
error xml error 	check match 
code xml 	leaveblock lua 
parser free error 	patchtohere lua 
error error 	getlabel 
strbuf release strbuf 	enterblock enterblock 
release curl 	lua next 
slist free xmalloc 	chunk check 
one parse 	match cond 
die oid hex 	leaveblock lua 
one init 	patchlist 
desc entry type 	breakstat lua 
process lookup 	patchtohere leaveblock 
process blob 	lua patchlist 
lookup blob free 	lua jump 
buffer revision 	leaveblock expr 
process send request 	lua 
one process 	exp nextreg 
process blob die 	adjustlocalvars checknext 
oid hex 	lua code 
send request dav 	lua jump 
token headers 	enterblock adjustlocalvars 
strbuf addf sha 	lua 
hex active 	reserveregs block 
slot curl setup 	leaveblock lua 
http curl 	patchtohere lua 
easy setopt start 	code lua 
active slot 	code abc 
run active slot 	lua 
strbuf release 	fixline lua 
strbuf release alloc 	patchlist lua 
http fetch 	jump localvarliteral 
free file 	localvarliteral localvarliteral 
lookup unknown oid 	localvar checknext 
hex fetch 	exp 
request remote alloc 	checknext exp 
http fetch 	testnext exp 
free parse oid 	lua code 
hex free 	lua number 
strbuf addf oid 	lua reserveregs 
hex deref 	forbody 
tag strbuf addf 	localvarliteral localvarliteral 
oid hex 	localvarliteral localvar 
free remote dav 	testnext localvar 
token headers 	str checkname 
active slot curl 	checknext adjust 
setup http 	assign 
curl easy setopt 	explist lua 
start active 	checkstack forbody 
slot run active 	enterblock lua 
slot strbuf 	next str 
release xstrfmt 	checkname fornum 
http strbuf error 	forlist 
free xstrfmt 	lua syntaxerror 
http strbuf die 	lua lua 
free free 	check match 
hashclr strbuf rtrim 	leaveblock lua 
skip prefix 	next cond 
xmemdupz sha hex 	checknext 
strbuf release 	block test 
lookup commit die 	block lua 
lookup commit 	concat lua 
die merge bases 	jump lua 
strlen strlen 	patchtohere test 
memcmp error error 	block 
fetch symref 	lua concat 
error strcmp error 	lua jump 
fetch symref 	lua patchtohere 
error sha error 	lua next 
sha file 	block lua 
error sha 	concat 
hex oid error 	lua patchtohere 
file error 	check match 
oid hex verify 	localvar str 
merge error 	checkname init 
xstrfmt active slot 	exp lua 
curl setup 	reserveregs 
http start active 	adjustlocalvars body 
slot run 	lua storevar 
active slot free 	getlocvar testnext 
error free 	localvar str 
error fill active 	checkname testnext 
slots fill 	explist 
function finish active 	adjust assign 
slots fill 	adjustlocalvars singlevar 
active slots git 	field field 
setup gettext 	lua next 
git extract argv 	funcname body 
path xcalloc 	lua 
strcmp strcmp 	storevar lua 
strcmp strcmp strcmp 	fixline primaryexp 
strcmp strcmp 	setarg getcode 
strcmp usage strstr 	assignment lua 
str end 	next block 
url slash strlen 	follow 
strchr strlen 	explist hasmultret 
die usage die 	lua setmultret 
setup git 	opcode getcode 
directory memset http 	lua getarg 
init locking 	getcode lua 
available sigchain push 	exp 
common remote 	anyreg lua 
exists remote exists 	exp nextreg 
remote error 	lua lua 
fetch indices local 	ret ifstat 
heads dav 	whilestat lua 
remote heads 	next 
run request queue 	block check 
remote branch 	match forstat 
match push refs 	repeatstat funcstat 
oid remote 	lua next 
branch error oidcmp 	testnext localfunc 
oid file 	localstat 
newer error oidcpy 	retstat lua 
strcmp oid 	next breakstat 
hex oid hex 	exprstat enterlevel 
remote argv 	block follow 
push argv push 	statement testnext 
argv push 	lua 
oid hex oid 	leavelevel lparser 
argv pushf 	roberto exp 
oid hex init 	lua parser 
revisions setup 	see copyright 
git directory setup 	notice lua 
revisions prepare 	nodes 
revision walk 	block list 
die mark edges 	list active 
uninteresting delta 	blocks chain 
finish active slots 	list jumps 
run request 	loop active 
queue update remote 	locals 
unlock remote 	outside breakable 
check locks argv 	structure variable 
clear update 	block upvalue 
remote info refs 	block loop 
unlock remote 	prototypes recursive 
free http cleanup 	non 
release request 	terminal functions 
dav methods dav 	one found 
flags dav 	levels variable 
xml properties dav 	look current 
request body 	level local 
templates remember update 	used 
flag allocation 	upval found 
allow recursive 	current level 
symbolic refs within 	upper one 
reason though 	local upval 
flags control remote 	upvalue level 
processing flags 	info 
remote passes callback 	points name 
functions dav 	includes call 
token headers options 	last exp 
request started 	provides difference 
abort request error 	close last 
make sure 	expression 
isn another open 	block either 
request pack 	controls scope 
request started abort 	breaks never 
request error 	free registers 
compress first header 	linked list 
nothing data 	funcstates 
nothing keep locks 	registers always 
active url 	valid anchor 
reused move 	table constants 
put fetching packed 	prototype avoid 
necessary fetch 	collected last 
known exist locally 	token 
already request 	read anchored 
queue keep locks 	defunct function 
active push 	must reanchor 
known exist remote 	table prototype 
already request 	stack main 
queue ignore remote 	func 
objects exist 	always vararg 
locally make sure 	read first 
leading directories 	token grammar 
exist remote extract 	rules field 
hex sharded 	name skip 
filename skip ensure 	dot 
collection names 	colon index 
end slash 	expr skip 
needswork remote ignores 	rules constructors 
info refs 	last list 
remote side heed 	item read 
information file 	table 
instead trying determine 	descriptor total 
refs remote 	number record 
file system badly 	elements total 
even know 	number elements 
packed refs subproject 	number elements 
commit repository 	pending 
attempt recovery fetch 	stored recfield 
copy doesn 	name exp 
exist locally may 	exp token 
required updating 	free registers 
server info later 	list item 
cut trailing 	flush 
newline symref refname 	items pending 
otherwise sha 	count last 
find remote 	expression unknown 
branch matching specified 	number elements 
branch name 	constructor yet 
remote head must 	fix 
symref exactly 	stack top 
foolproof remote symlink 	may listfields 
symref look 	recfields expression 
like symref remote 	constructor item 
branch must 	recfield constructor 
remote head run 	part 
extra sanity 	listfield initial 
checks forced remote 	size initial 
head must 	table size 
resolve known remote 	parlist param 
branch must 	param parlist 
resolve known remote 	empty 
branch must 	param name 
ancestor remote head 	param use 
send request 	arg name 
verify dav 	reserve parameters 
compliance support check 	body parlist 
whether remote 	chunk 
server info files 	end explist 
list local 	expr expr 
remote heads validate 	least one 
refspecs remote 	expression funcargs 
branch specified match 	explist arg 
remote know 	list 
remote ancestor trying 	empty funcargs 
push either 	constructor funcargs 
way losing commits 	must use 
remote end 	seminfo next 
likely date begin 	call 
remote branch 	open call 
revision info refspec 	close last 
ignored generate 	argument call 
list objects need 	function arguments 
pushed push 	leaves unless 
missing objects 	changed 
remote would convenient 	one result 
time pack 	expression parsing 
first appropriate update 	prefixexp name 
remote branch 	expr primaryexp 
went well update 	prefixexp name 
remote server 	exp 
info appropriate http-walker.c 	name funcargs 
got indices 	funcargs field 
packs next walker 	exp name 
sha repo 	funcargs funcargs 
req next walker 	simpleexp number 
url buffer 	nil 
slot http specific 	constructor function 
url got 	body primaryexp 
alternates alt queue 	vararg need 
head walker 	arg constructor 
callback data 	left priority 
walker obj req 	binary 
slot req 	right priority 
obj req callback 	order opr 
data obj 	power concat 
req walker data 	right associative 
alt obj 	equality inequality 
req entry walker 	order 
obj req 	logical priority 
walker sha newreq 	unary operators 
tail data 	subexpr simpleexp 
callback data alt 	unop subexpr 
req walker 	binop subexpr 
cdata slot tail 	binop 
data posn 	binary priority 
okay serverlen newalt 	higher limit 
colon colon 	expand operators 
slash target walker 	priorities higher 
buffer url 	limit read 
slot alt 	sub 
req cdata walker 	expression higher 
repo ret 	priority first 
walker repo sha 	untreated rules 
target ret 	statements block 
results preq obj 	chunk structure 
req walker 	chain 
repo sha hex 	variables left 
ret obj 	hand side 
req req walker 	assignment variable 
sha data 	local upvalue 
altbase walker data 	indexed check 
walker data 	whether 
alt alt next 	assignment local 
url data 	variable local 
walker http request 	variable needed 
start active 	previous assignment 
slot release http 	table save 
request finish 	original 
http request 	local safe 
walker say sha 	place use 
hex process 	safe copy 
http request missing 	previous assignment 
target fetch 	eventual position 
alternates release http 	save 
request start 	local variable 
request finish request 	conflict previous 
error free 	assignment use 
sha file start 	safe copy 
request xmalloc 	conflict previous 
hashcpy fill active 	assignment 
slots step 	use safe 
active slots strbuf 	copy make 
reset strbuf 	copy assignment 
addf curl easy 	primaryexp assignment 
setopt start 	assignment explist 
active slot missing 	extra 
target fwrite 	values close 
buffer strstr 	last expression 
strchr memcmp strlen 	avoid assignment 
memcmp strchr 	cond exp 
strchr strchr strbuf 	read condition 
strbuf xmalloc 	falses 
strbuf detach step 	equal whilestat 
active slots 	cond block 
strbuf addf active 	end skip 
slot curl 	conditions finish 
easy setopt curl 	loop repeatstat 
easy setopt 	repeat 
curl easy setopt 	block cond 
start active 	loop block 
slot run active 	scope block 
slot strbuf 	skip repeat 
release strbuf release 	read condition 
http info 	inside 
packs fetch indices 	scope block 
find sha 	upvalues finish 
pack sha 	scope close 
hex sha hex 	loop complete 
http pack 	semantics upvalues 
request start active 	condition 
slot run 	finish scope 
active slot error 	repeat finish 
error finish 	loop forbody 
http pack request 	block control 
release http 	variables scope 
pack request release 	declared 
request sha 	variables end 
hex hashcmp error 	scope declared 
sha file 	variables pretend 
abort http request 	starts loop 
abort request 	fornum name 
step active slots 	exp 
start request 	exp exp 
run active 	forbody initial 
slot close error 	limit optional 
missing target 	step step 
error error hashcmp 	forlist name 
error error 	name 
sha file name 	explist forbody 
release http 	create control 
request release request 	variables create 
fetch http 	declared variables 
fetch pack fetch 	extra space 
alternates error 	call 
sha hex http 	generator forstat 
fetch free 	fornum forlist 
free free xmalloc 	end scope 
xmalloc xmalloc 	loop control 
xstrdup strlen fill 	variables skip 
function request 	first 
started abort request 	variable name 
error use 	loop scope 
alternates necessary 	jumps point 
reusing slot non 	test block 
http alternates 	elseif cond 
counts http git 	block 
host pub 	skip elseif 
scm linux git 	part ifstat 
memcpy dst 	cond block 
serverlen copy git 	elseif cond 
host relative 	block block 
url chop corresponding 	end 
number subpath 	cond block 
data concatenate result 	elseif cond 
code first 	block skip 
drops data drops 	patch correct 
one data 	line info 
one path iow 	part 
one extra 	debug information 
dropped data path 	see variable 
dropped wrong 	point stat 
alternate http 	local name 
git host pub 	name explist 
scm linux 	funcname 
git borrow http 	name field 
git host 	name funcstat 
pub scm linus 	function funcname 
git linus 	body skip 
git objects need 	function definition 
two borrow 	happens 
direct neighbour server 	first line 
got removed 	stat func 
give skip objects 	assignment stat 
end another 	func call 
request already started 	statement uses 
fetching alternates 	results 
wait arrive processing 	stat assignment 
request curl 	stat explist 
message nothing already 	registers returned 
fetched start 	values skip 
fetch use 	values optional 
callback process result 	values 
since another 	tail call 
request may fail 	values one 
need alternates 	single values 
loaded continuing obj 	must stack 
req req 	active values 
might change fetching 	may 
alternates callback 	needed error 
process response therefore 	messages stat 
shortcut variable 	ifstat stat 
req used done 	whilestat stat 
slots silent 	block end 
probably pack http.c 	skip 
git curl 	stat forstat 
ipresolve git curl 	stat repeatstat 
ipresolve active 	stat funcstat 
requests http 	stat localstat 
verbose http post 	skip local 
buffer min 	local 
curl sessions curl 	function stat 
session count 	retstat must 
max requests curlm 	last statement 
curl curl 	stat breakstat 
errorstr curl ssl 	skip must 
verify curl 	last 
ssl ssl cert 	statement avoid 
ssl cipherlist 	warnings chunk 
ssl version name 	stat free 
ssl version 	registers lparser.h 
ssl key ssl 	buff name 
capath ssl 	lparser 
pinnedkey ssl cainfo 	roberto exp 
curl low 	lua parser 
speed limit curl 	see copyright 
low speed 	notice lua 
time curl 	expression descriptor 
ftp epsv curl 	info 
http proxy 	index constant 
curl proxy http 	nval numerical 
proxy authmethod 	info local 
name curlauth param 	info index 
proxy auth 	upvalue upvalues 
curl proxyuserpwd curl 	info 
cookie file 	index table 
curl save cookies 	aux index 
http auth 	name info 
http proactive auth 	table aux 
user agent 	index info 
curl empty auth 	instruction 
cert auth 	info instruction 
ssl cert password 	info result 
required http 	info instruction 
auth methods pragma 	info instruction 
header pragma 	patch list 
header active 	exit 
queue head cached 	patch list 
accept language 	exit defined 
ptr eltsize nmemb 	lparser state 
buffer size 	needed generate 
buffer handle cmd 	code given 
clientp buffer 	function 
ptr eltsize nmemb 	current function 
buffer size 	header table 
buffer ptr eltsize 	find reuse 
nmemb strbuf 	elements enclosing 
slot slot num 	function lexical 
messages slot 	state 
curl message curl 	copy lua 
result result 	state chain 
result result client 	current blocks 
type len 	next position 
result allowed protocols 	code equivalent 
url envname 	ncode 
val remote 	last jump 
url proactive auth 	target list 
low speed 	pending jumps 
limit low speed 	first free 
time normalized 	number elements 
url config http 	number 
max requests 	elements number 
slot next slot 	elements locvars 
newslot num 	number active 
transfers slot curlm 	local variables 
result num 	upvalues declared 
transfers data next 	variable 
fill cfg 	stack lstate.c 
data fill linkp 	lua newvector 
slot fill 	lua newvector 
num transfers curlm 	setnilvalue lua 
result slot 	freearray lua 
readfds writefds 	freearray 
excfds max timeout 	unused stack 
finished curl 	init sethvalue 
timeout slot slot 	lua sethvalue 
buf buf 	registry lua 
url hex two 	lua resize 
digit prefix 	lua 
url hex two 	init lua 
digit prefix 	init lua 
buf results slot 	fix lua 
results curl 	newliteral resethookcount 
info buf ptr 	setnilvalue lua 
ret raw 	close 
name len raw 	lua freeall 
type charset 	lua obj 
buf max places 	gco lua 
max language 	lua freearray 
tags max accept 	lua freebuffer 
language header 	freestack 
size language 	lua frealloc 
tags num langs 	fromstate state 
tag last 	size tostate 
buf len max 	lua malloc 
places format 	state size 
buf curl pos 	lua 
buf url 	link obj 
result target options 	gco preinit 
slot results 	state stack 
headers buf accept 	init setobj 
language ret 	resethookcount lua 
posn raw asked 	iswhite 
got tail 	obj gco 
tail len url 	lua close 
result target 	lua luai 
options ret url 	userstatefree freestack 
result options 	lua freemem 
url filename options 	fromstate 
ret tmpfile 	state size 
result options 	state size 
url buffer ret 	tostate bit 
sha url 	mask lua 
url tmp buf 	white bits 
packs head 	preinit 
sha url pack 	state setnilvalue 
tmp idx 	registry lua 
ret url packs 	initbuffer obj 
head options 	gco lua 
url data buf 	rawrunprotected close 
sha preq 	state 
preq lst tmp 	luai userstateopen 
idx len 	unused lua 
argv target url 	call gctm 
prev posn 	lua lua 
buf preq ptr 	close lua 
eltsize nmemb 	separateudata 
data expn size 	lua rawrunprotected 
posn freq 	lua luai 
retval url 	userstateclose close 
sha hex filename 	state lstate 
prevfile prevlocal 	roberto exp 
prev buf prev 	state 
read prev 	see copyright 
posn freq dir 	notice lua 
freq freq 	main combines 
freq freq memcpy 	state state 
strbuf closedown 	initialize call 
active slot curl 	info 
easy getinfo 	initialize stack 
curl easy getinfo 	initialize first 
curl easy 	function entry 
getinfo callback func 	open parts 
curl multi 	may cause 
info read curl 	memory 
multi handle 	allocation errors 
finish active slot 	init stack 
curl multi 	table globals 
info read 	registry initial 
strcmp git config 	size table 
strcmp git 	close 
config strcmp git 	upvalues collect 
config strcmp 	objects init 
git config strcmp 	stack share 
git config 	table globals 
strcmp git config 	close upvalues 
pathname strcmp 	mark 
git config pathname 	unfinished state 
strcmp git 	memory allocation 
config strcmp git 	error free 
config strcmp 	state call 
git config strcmp 	metamethods udata 
git config 	main 
strcmp git config 	closed close 
strcmp git 	upvalues separate 
config strcmp 	udata metamethods 
git config strcmp 	error function 
git config 	metamethods repeat 
strcmp git config 	errors 
strcmp git 	lstate.h status 
config strcmp git 	top savedpc 
config strcmp 	stack last 
git config strcmp 	stack end 
git config 	stacksize size 
strcmp git config 	ccalls 
strcmp git 	ccalls hookmask 
config pathname warning 	allowhook basehookcount 
git config 	hookcount hook 
curl easy setopt 	env openupval 
credential fill 	gclist error 
curl easy setopt 	jmp 
curl easy 	errfunc gch 
setopt strbuf addf 	lstate roberto 
curl easy 	exp state 
setopt free 	see copyright 
xstrdup curl easy 	notice lua 
setopt curl 	defined 
easy setopt strbuf 	ldo table 
addstr urlencode 	globals registry 
strbuf addch strbuf 	extra stack 
addstr urlencode 	space handle 
strbuf detach curl 	calls extras 
easy setopt 	number 
credential fill proxyauth 	elements informations 
name password 	call function 
getenv size strcmp 	function index 
curl easy 	stack top 
setopt size warning 	function expected 
curl easy 	number 
setopt curl easy 	results function 
setopt xstrdup 	number tail 
xstrdup xstrdup credential 	calls lost 
fill curl 	entry state 
easy setopt 	shared threads 
setsockopt warning strerror 	state 
curl easy 	hash table 
setopt curl easy 	function reallocate 
init die 	memory auxiliary 
curl easy setopt 	data frealloc 
curl easy 	state garbage 
setopt curl easy 	collector 
setopt curl 	position sweep 
easy setopt curl 	strt list 
easy setopt 	collectable objects 
curl easy setopt 	position sweep 
init curl 	rootgc list 
http auth getenv 	gray 
getenv size 	objects list 
strcmp curl easy 	objects traversed 
setopt size 	atomically list 
warning getenv getenv 	weak tables 
curl easy 	cleared last 
setopt curl 	element 
easy setopt cert 	list userdata 
password curl 	temporary buffer 
easy setopt curl 	concatentation number 
easy setopt 	bytes currently 
curl easy setopt 	allocated estimate 
curl easy 	number 
setopt curl easy 	bytes actually 
setopt curl 	use much 
easy setopt curl 	behind schedule 
easy setopt 	size pause 
curl easy setopt 	successive granularity 
curl easy 	called 
setopt curl easy 	unprotected errors 
setopt curl 	head linked 
easy setopt transport 	list open 
allowed transport 	upvalues metatables 
allowed transport 	basic types 
allowed transport allowed 	tag 
curl easy 	method names 
setopt transport restrict 	per state 
protocols warning 	first free 
getenv curl easy 	slot stack 
setopt curl 	current 
easy setopt git 	function call 
user agent 	info current 
curl easy setopt 	function savedpc 
curl easy 	current function 
setopt strcmp getenv 	last free 
getenv getenv 	slot 
getenv getenv curl 	stack stack 
easy setopt 	points end 
starts curl easy 	call info 
setopt starts 	size number 
curl easy setopt 	nested calls 
starts curl 	nested 
easy setopt 	calls resuming 
strstr credential url 	coroutine table 
strbuf addf 	globals temporary 
credential url strbuf 	place environments 
release curl 	list open 
easy setopt getenv 	upvalues 
getenv curl 	stack current 
easy setopt init 	error recover 
curl proxy 	point current 
auth curl keepalive 	error handling 
getenv url 	function stack 
normalize git config 	index 
free curl 	collectable objects 
init die xstrdup 	macros convert 
curl slist 	specific macro 
append curl slist 	convert lua 
append getenv 	lstring.c newsize 
atoi curl multi 	newhash 
init die 	next str 
getenv env 	str step 
env env env 	lua newvector 
env getenv 	gco lmod 
strtol getenv strtol 	lua cast 
getenv credential 	lmod 
url getenv starts 	lua freearray 
curl handle 	lua toobig 
curl multi handle 	cast lua 
curl easy 	malloc lua 
cleanup free curl 	white memcpy 
easy cleanup 	lmod 
curl multi cleanup 	obj gco 
curl cleanup 	cast lua 
curl slist free 	resize lmod 
curl slist 	rawgco memcmp 
free free memset 	getstr isdead 
strlen free 	changewhite 
free free memset 	newlstr lua 
strlen free 	toobig cast 
free curl 	lua malloc 
multi perform process 	lua white 
curl messages 	obj gco 
xmalloc curl handle 	lstring 
curl easy 	roberto exp 
duphandle curl easy 	table keeps 
setopt curl 	handled lua 
easy setopt curl 	see copyright 
easy setopt 	notice lua 
curl easy setopt 	cannot 
curl easy 	resize traverse 
setopt curl easy 	rehash node 
setopt curl 	list save 
easy setopt curl 	next position 
easy setopt 	chain ending 
curl easy setopt 	chain 
curl easy 	entry crowded 
setopt curl 	seed hash 
easy setopt curl 	chars compute 
easy setopt 	hash may 
curl easy setopt 	dead found 
curl easy 	finalized 
setopt init curl 	chain udata 
http auth 	list main 
curl multi handle 	lstring.h newsize 
curl multi 	str lstring 
perform xmalloc fill 	roberto exp 
curl easy 	table 
cleanup curl multi 	keep handled 
perform process 	lua see 
curl messages fill 	copyright notice 
active slots 	lua lstrlib.c 
step active slots 	pos len 
curl multi 	start 
timeout zero zero 	end posi 
zero curl 	pose size 
multi fdset 	level res 
curl easy perform 	sig cont 
finish active 	res res 
slot closedown active 	res 
slot curl 	level res 
multi handle curl 	len previous 
easy cleanup 	res init 
fill active slots 	nlevels find 
run active 	init anchor 
slot end url 	res 
slash needs 	src newstart 
quote strbuf addf 	news srcl 
strbuf addch 	src max 
strbuf detach end 	anchor arg 
url slash 	strfrmt form 
strbuf addf strbuf 	form 
addf append 	spec top 
remote url strbuf 	arg sfl 
detach snprintf 	strfrmt strfrmt 
credential approve 	end form 
credential approve missing 	buff strlib 
target credential 	lua 
reject credential reject 	checklstring lua 
strlcpy curl 	pushinteger lua 
easy strerror start 	checklstring posrelat 
active slot 	lua checkinteger 
snprintf run active 	posrelat lua 
slot handle 	optinteger 
curl result strbuf 	lua pushlstring 
reset curl 	lua pushliteral 
easy getinfo strbuf 	lua checklstring 
addstr strlen 	lua buffinit 
strncasecmp isspace strbuf 	lua addchar 
addch strbuf 	lua 
reset strbuf grow 	pushresult lua 
isspace strbuf 	checklstring lua 
addch tolower strbuf 	buffinit lua 
reset isspace 	addchar tolower 
extract param 	uchar lua 
isspace starts strbuf 	pushresult 
addstr preferred 	lua checklstring 
languages isalnum strbuf 	lua buffinit 
addch realloc 	lua addchar 
strbuf detach realloc 	toupper uchar 
xsnprintf strbuf 	lua pushresult 
addstr strbuf addstr 	lua 
strbuf addstr 	checklstring lua 
strbuf addf strbuf 	checkint lua 
free free 	buffinit lua 
write accept language 	addlstring lua 
strbuf detach 	pushresult lua 
xsnprintf curl easy 	checklstring 
setopt active 	posrelat lua 
slot curl easy 	optinteger posrelat 
setopt curl 	lua optinteger 
easy setopt curl 	lua error 
easy setopt 	lua checkstack 
curl easy 	lua 
setopt ftello curl 	pushinteger uchar 
easy setopt 	lua gettop 
http opt request 	lua buffinit 
remainder curl 	lua checkint 
easy setopt accept 	lua argcheck 
language curl 	uchar 
slist append strbuf 	lua addchar 
addstr strbuf 	uchar lua 
addstr curl easy 	pushresult lua 
setopt curl 	addlstring lua 
slist append curl 	checktype lua 
easy setopt 	settop 
curl easy setopt 	lua buffinit 
curl easy 	lua dump 
setopt run one 	lua error 
slot curlinfo 	lua pushresult 
strbuf extract 	lua error 
content type strbuf 	lua 
release curlinfo 	error lua 
strbuf curl slist 	error lua 
free strbuf 	lua error 
release strcmp skip 	lua tolower 
prefix die 	isalpha iscntrl 
strlen strcmp strbuf 	isdigit 
reset strbuf 	islower ispunct 
http request update 	isspace isupper 
url redirect 	isalnum isxdigit 
credential url strbuf 	islower match 
reset die 	uchar uchar 
credential fill http 	uchar 
request http 	uchar match 
request reauth strbuf 	uchar matchbracketclass 
addf fopen 	uchar lua 
error http request 	error singlematch 
reauth fclose 	uchar match 
finalize file 	match 
strbuf release quote 	singlematch uchar 
url http 	lua error 
strbuf strbuf rtrim 	match capture 
oid hex 	close match 
starts xstrdup strbuf 	check capture 
release free 	size 
sha hex end 	memcmp start 
url slash 	capture start 
strbuf addf sha 	capture end 
hex strbuf 	capture matchbalance 
detach strbuf addf 	lua error 
sha pack 	lua 
index name strbuf 	lua classend 
detach http 	matchbracketclass uchar 
file error free 	matchbracketclass uchar 
free pack 	isdigit uchar 
index parse pack 	match capture 
index sha 	uchar 
pack index 	classend singlematch 
name fetch pack 	uchar match 
index parse 	max expand 
pack index unlink 	max expand 
free verify 	min expand 
pack index close 	memchr 
pack index 	memcmp lua 
finalize file sha 	pushlstring lua 
pack index 	error lua 
name free end 	error lua 
url slash 	pushinteger lua 
strbuf addstr strbuf 	pushlstring 
detach http 	lua checkstack 
strbuf starts starts 	push onecapture 
sha hex 	lua checklstring 
fetch setup pack 	lua checklstring 
index free 	posrelat lua 
fclose free free 	optinteger 
close pack 	size lua 
index fclose 	toboolean strpbrk 
strip suffix die 	lmemfind lua 
xstrfmt run 	pushinteger lua 
command unlink unlink 	pushinteger match 
free unlink 	lua 
sha pack index 	pushinteger lua 
name finalize 	pushinteger push 
file sha pack 	captures push 
name finalize 	captures lua 
file sha pack 	pushnil str 
index name 	find 
free install packed 	aux str 
git free 	find aux 
xcalloc end url 	lua tolstring 
slash strbuf 	lua upvalueindex 
addf sha hex 	lua tostring 
strbuf detach 	lua 
snprintf sha 	upvalueindex lua 
pack name fopen 	tointeger lua 
error active 	upvalueindex match 
slot curl easy 	lua pushinteger 
setopt curl 	lua replace 
easy setopt curl 	lua 
easy setopt 	upvalueindex push 
curl easy setopt 	captures lua 
ftello sha 	checkstring lua 
hex http opt 	checkstring lua 
request remainder 	settop lua 
free free xwrite 	pushinteger 
git inflate 	lua pushcclosure 
git sha update 	lua error 
sha hex 	lua lua 
xcalloc hashcpy sha 	lua tolstring 
file name 	lua addchar 
snprintf snprintf unlink 	isdigit 
warn rename 	uchar lua 
unlink warn 	addchar lua 
error open strrchr 	addlstring push 
mkdir open 	onecapture lua 
error strerror git 	addvalue lua 
inflate init 	type 
git sha init 	lua pushvalue 
remote url 	push captures 
open xread fwrite 	lua call 
sha file 	push onecapture 
close unlink warn 	lua gettable 
memset git 	lua 
inflate init git 	toboolean lua 
sha init 	pop lua 
lseek ftruncate error 	pushlstring lua 
strerror active 	isstring lua 
slot curl easy 	error lua 
setopt curl 	lua 
easy setopt curl 	addvalue lua 
easy setopt 	checklstring lua 
curl easy 	checkstring lua 
setopt curl easy 	type lua 
setopt http 	optint lua 
opt request remainder 	argcheck 
free free 	lua buffinit 
close process http 	match lua 
request warning 	addchar lua 
stat unlink warn 	addlstring lua 
git inflate 	pushresult lua 
end git sha 	pushinteger 
unlink warn 	lua checklstring 
hashcmp unlink warn 	lua addchar 
finalize file 	lua addchar 
sha file name 	lua addchar 
unlink warn 	lua addlstring 
release http request 	lua 
close free 	addlstring lua 
release active slot 	addchar lua 
curlauth digest 	addchar strchr 
corresponding command 	size lua 
line option curl 	error isdigit 
included curlauth 	uchar 
use curlopt keypasswd 	isdigit uchar 
store slot 	isdigit uchar 
results read slot 	isdigit uchar 
reused run 	isdigit uchar 
callback appropriate fall 	lua error 
back ones 	strncpy 
note ever single 	strlen strcpy 
credentials given 	lua gettop 
program run worry 	lua checklstring 
updating buffer 	lua buffinit 
setting initial must 	lua addchar 
free able 	lua 
curlopt proxyauth curlauth 	addchar lua 
curl sockopt 	argerror scanformat 
exists since 	sprintf lua 
curl supported older 	checknumber addintlen 
curl versions 	sprintf lua 
verify authenticity peer 	checknumber 
certificate name 	addintlen sprintf 
cert must match 	lua checknumber 
tried connect 	sprintf lua 
curl also examines 	checknumber addquoted 
variables fallback 	lua checklstring 
need query order 	strchr 
decide whether 	lua pushvalue 
prompt missing password 	lua addvalue 
init curl 	sprintf lua 
proxy auth unlike 	error lua 
many common 	lua lua 
environment variables historically 	addlstring 
lowercase appears 	strlen lua 
curl know implemented 	pushresult lua 
uppercase variants 	createtable lua 
later corrected 	pushliteral lua 
take http proxy 	pushvalue lua 
lowercase also 	setmetatable 
curl lowercase versions 	lua pop 
historical quasi 	lua pushvalue 
standard take precedence 	lua setfield 
curl wait 	lua pop 
slot open queue 	lua lua 
full know 	getfield 
must something since 	lua setfield 
added something 	createmetatable lstrlib 
happen curl multi 	roberto exp 
timeout returns 	standard library 
pathologically timeout curl 	operations pattern 
multi fdset 	matching 
returns file descriptors 	see copyright 
read see 	notice lua 
commit message details 	macro unsign 
helpers modifying 	character relative 
creating see 	position negative 
failing http code 	means 
curle turned 	back end 
failonerror keep server 	empty interval 
custom error 	values overflow 
response translate code 	number arguments 
failure normally 	pattern matching 
curl already put 	init 
reason phrase 	source end 
server curl errorstr 	source total 
unfortunately without 	number captures 
failonerror lost give 	finished unfinished 
numeric status 	look skip 
code check extract 	escapes 
content type 	skip matches 
parameter raw positioned 	ends balance 
start potential 	counts maximum 
parameter whitespace already 	expand item 
removed name 	keeps trying 
name parameter 	match 
appended extract normalized 	maximum repetitions 
version content 	didn match 
type spaces suppressed 	reduce repetition 
letters lowercased 	one repetition 
trailing parameters note 	match failed 
silently even 	undo 
invalid whitespace example 	capture close 
text plain 	capture match 
specifically forbidden rfc 	failed undo 
text plain 	capture optimize 
reasonable output keeps 	tail recursion 
code simple 	start 
charset argument store 	capture position 
charset parameter 	capture end 
example text plain 	capture balanced 
charset utf 	match frontier 
text plain utf 	points next 
text plain 	match 
text plain 	capture results 
max places must 	match end 
larger larger 	pattern match 
smaller minimum http 	succeeded last 
specification allows 	pattern check 
see http tools 	end 
ietf html 	pattern item 
rfc section accept 	points next 
language header 	optional match 
language preferred split 	repetitions repetitions 
colon separated 	repetitions minimum 
preferred languages language 	match 
tags collect 	empty everywhere 
language tag skip 	avoids negative 
codeset modifier 	search inside 
unnecessary parts write 	memchr cannot 
accept language 	found already 
header buf 	correct 
won freed compute 	found level 
places free 	whole match 
language tags last 	number pushed 
one accept 	request special 
language header indicates 	characters plain 
user preferred 	search 
languages examples language 	start end 
language accept 	found empty 
language language utf 	match least 
latin accept 	one position 
language language utf 	found skip 
accept language 	esc 
language utf accept 	capture accumulated 
language language 	result nil 
http request targets 	keep original 
update url 	text result 
appropriate deduced redirects 	accumulator non 
seen requesting 	empty 
url starting 	match skip 
url asked parameter 	number substitutions 
url asked 	maximum size 
curl access must 	formatted item 
begin got 	len format 
parameter url curl 	valid 
reported ended 	flags format 
returns updated url 	specification maximum 
otherwise basic 	size format 
strategy compare asked 	specification accounts 
find bits 	plus 
specific request strip 	margin error 
bits got 	skip flags 
example http example 	skip width 
foo git 	digits skip 
ask http example 	precision digits 
foo git 	format 
info refs might 	item store 
end https 	format store 
example foo 	formatted item 
git info refs 	skip addsize 
would want 	end precision 
url become https 	formatted 
example foo 	keep original 
git note assumes 	skip addsize 
sane redirect 	end also 
scheme entirely possible 	treat cases 
example end 	llh create 
url even end 	metatable 
info refs 	dummy metatable 
simply punt much 	pop dummy 
scheme unlikely 	library index 
represent real git 	metamethod pop 
repository means 	metatable open 
likely abort anyway 	library 
insane redirect 	ltable.c dummynode 
scheme keep error 	key key 
previous request 	key key 
may put 	nums narray 
cruft output stream 	twotoi key 
clear making 	nums 
next request know 	nums ttlg 
strbuf enough 	ause lim 
satisfy current callers 	nums pnasize 
downloads url 	totaluse ause 
stores result given 	size size 
file previous 	lsize 
interrupted download detected 	nasize nhsize 
previous temporary 	oldasize oldhsize 
file still around 	nold old 
download resumed 	nasize nsize 
helpers fetching packs 	nasize nums 
parse pack 	totaluse 
index already issued 	narray nhash 
error message 	key othern 
parse pack 	key key 
index already issued 	key key 
error message 	key key 
data present previous 	key 
transfer attempt 	luai numeq 
resume left helpers 	gnode memcpy 
fetching objects 	hashmod ttype 
loose could failed 	hashnum nvalue 
due lazy 	hashstr rawtsvalue 
directory creation mkdir 	hashboolean 
last path 	bvalue hashpointer 
component previous temp 	pvalue hashpointer 
file present 	gcvalue ttisnumber 
process already fetched 	nvalue lua 
reset inflate 	number luai 
sha error reading 	numeq 
previous temp 	cast num 
file also rewind 	ttisnil arrayindex 
beginning local 	mainposition lua 
file successfully 	rawequal obj 
processed data previous 	key tval 
fetch attempt 	ttype 
fetch data already 	gkey iscollectable 
http.h curl 	gcvalue gkey 
result http code 	gcvalue cast 
auth avail 	gnode gnext 
http connectcode curl 	lua runerror 
use curl 	lua 
result http code 	findindex ttisnil 
finished results 	setnvalue cast 
callback data data 	num setobj 
next buf 	sizenode ttisnil 
posn ptr eltsize 	gval gnode 
nmemb strbuf 	setobj 
ptr eltsize nmemb 	key tval 
strbuf ptr 	gnode setobj 
eltsize nmemb strbuf 	gval gnode 
handle cmd 	lua arrayindex 
clientp slot 	ceillog ttisnil 
slot slot results 	sizenode 
data fill 	ttisnil gval 
remote url proactive 	countint key 
auth git 	tval lua 
curl ipresolve active 	reallocvector setnilvalue 
requests http 	cast ceillog 
verbose http post 	lua 
buffer http 	runerror twoto 
auth curl errorstr 	lua newvector 
code result 	gnode gnext 
buf url hex 	setnilvalue gkey 
two digit 	setnilvalue gval 
prefix url hex 	cast 
two digit 	gnode setarrayvector 
prefix content type 	setnodevector ttisnil 
charset effective 	setobjt lua 
url url url 	setnum lua 
result options 	reallocvector twoto 
url packs 	ttisnil 
head url target 	gval setobjt 
lst packfile 	lua key 
tmpfile slot target 	tval gval 
url preq 	lua freearray 
preq url tmpfile 	twoto sizenode 
localfile curl 	resize 
result errorstr http 	numusearray numusehash 
code sha 	countint computesizes 
real sha stream 	resize lua 
zret rename 	lua link 
slot url sha 	obj gco 
freq freq 	cast 
freq freq detect 	cast setarrayvector 
url version 	setnodevector lua 
multi transfer usable 	freearray sizenode 
implementation define 	lua freearray 
symbol accordingly 	lua free 
shouldn makefile user 	ttisnil 
via cflags 	gkey mainposition 
nothing nothing curlopt 	ttisnil gval 
use ssl 	getfreepos rehash 
known curlopt ftp 	lua lua 
ssl constants 	mainposition key 
known curlftpssl curl 	tval 
request read 	gnext gnext 
write callbacks slot 	gnext gnext 
lifecycle functions 	setnilvalue gval 
run one slot 	gnext gnext 
completion blocking 	gnext gkey 
manner similar curl 	gkey 
easy perform 	lua barriert 
would work want 	lua ttisnil 
use want 	gval gval 
intermingle calls curl 	cast num 
multi curl 	hashnum ttisnumber 
easy file 	gkey 
url ever use 	luai numeq 
one http 	nvalue gkey 
https url ftp 	gval gnext 
url helpers 	hashstr ttisstring 
modifying creating options 	gkey rawtsvalue 
http non 	gkey 
returns content type 	gval gnext 
response non 	ttype lua 
content type non 	getstr rawtsvalue 
returns charset 	nvalue lua 
parameter content type 	number luai 
none present 	numeq 
returns empty non 	cast num 
returns url 	nvalue lua 
ended including redirects 	getnum mainposition 
followed url 	lua rawequal 
effective url non 	obj key 
url munged 	tval 
reflect redirections 	gval gnext 
going requested url 	lua cast 
effective url 	ttisnil lua 
see definition update 	runerror ttisnumber 
url redirect 	luai numisnan 
details values http 	nvalue 
requests url 	lua runerror 
stores result strbuf 	newkey lua 
result pointer 	getnum cast 
http head request 	setnvalue cast 
made instead 	num newkey 
helpers fetching packs 	lua 
helpers fetching 	getstr cast 
http ident.c git 	setsvalue newkey 
name git 	ttisnil lua 
email git date 	getnum ttisnil 
email bogus 	lua getnum 
name bogus ident 	ttisnil 
use config 	lua getnum 
committer ident 	ttisnil ttisnil 
explicitly given author 	unbound search 
ident explicitly 	mainposition ltable 
given ident config 	roberto exp 
given bogus 	lua 
fallback name src 	tables hash 
buf mailname 	see copyright 
mailnamebuf host status 	notice lua 
hints bogus 	implementation tables 
buf email bogus 	aka arrays 
email src 	objects 
len split line 	hash tables 
len span 	tables keep 
status env hint 	elements two 
name email 	parts part 
date str flag 	hash part 
ident strict 	non 
want date want 	negative integer 
name name 	keys candidates 
email flag 	kept part 
flag user ident 	actual size 
explicitly given 	largest least 
data begin end 	half 
begin end 	slots use 
len len min 	hash uses 
cmp cmp 	mix chained 
getpwuid getuid gecos 	scatter table 
strbuf addch 	brent variation 
strbuf addch toupper 	main 
strbuf addstr 	invariant tables 
fopen warning strerror 	element main 
strbuf getline 	position original 
ferror warning strerror 	position hash 
strbuf release 	gives colliding 
fclose strbuf addbuf 	element 
strbuf release 	main position 
fclose memset 	hence even 
getaddrinfo strchr strbuf 	load factor 
addstr freeaddrinfo 	reaches performance 
gethostbyname strchr strbuf 	remains good 
addstr gethostname 	max 
warning strerror strbuf 	size part 
addstr strchr 	maxbits types 
strbuf addstr canonical 	better avoid 
name strbuf 	modulus power 
addf strbuf addstr 	tend many 
strbuf addch 	factors 
mailname host domainname 	number ints 
copy gecos 	inside lua 
xgetpwuid self strbuf 	number key 
trim getenv 	hash lua 
strbuf addstr copy 	numbers avoid 
email xgetpwuid 	problems 
self strbuf trim 	returns main 
datestamp crud 	position element 
strlen crud 	table index 
strbuf grow memset 	hash returns 
isspace isspace 	index key 
strspn isspace strspn 	key 
ident name 	appropriate key 
fputs die die 	live part 
fputs die 	table otherwise 
xgetpwuid self ident 	key match 
email fputs 	condition returns 
die die strbuf 	index 
reset strbuf 	key table 
addstr without crud 	traversals first 
strbuf addstr 	goes elements 
strbuf addstr without 	part elements 
crud strbuf 	hash part 
addch strbuf addch 	beginning 
parse date 	traversal signalled 
die strbuf addstr 	first iteration 
ident date 	key inside 
fmt ident 	part yes 
getenv getenv fmt 	index corrected 
ident getenv 	check 
getenv getenv getenv 	whether key 
getenv fmt 	somewhere chain 
ident getenv getenv 	key may 
getenv ident 	dead already 
sufficient ident sufficient 	use next 
strcmp git 	key 
config strcmp config 	index hash 
error nonbool 	table hash 
strbuf reset strbuf 	elements numbered 
addstr strcmp 	ones key 
config error nonbool 	found avoid 
strbuf reset 	warnings 
strbuf addstr memcmp 	find original 
buf cmp 	element first 
buf cmp ident 	part non 
create git 	nil hash 
lines form 	part non 
name email date 	nil 
copyright linus 	elements rehash 
torvalds traditionally gecos 	number elements 
field office 	smaller number 
phone numbers etc 	elements part 
separated commas 	optimal size 
also stands capitalized 	part 
form login 	half elements 
name sorry donald 	present optimal 
success ipv 	size till 
make fake email 	elements smaller 
address name 	part elements 
hostname domainname read 	already 
etc mailname 	counted key 
debian copy destination 	appropriate index 
avoid special 	count summation 
characters crud 	nums count 
end crud beginning 	traverse keys 
crud end 	slice 
copy rest buffer 	counter adjust 
avoid special 	upper limit 
characters act delimiters 	elements count 
identification line 	count elements 
crud never len 	range total 
maximum reverse 	number 
fmt ident given 	elements summation 
ident line 	nums elements 
split fields allow 	hash part 
caller parse 	use common 
signal success returning 	dummynode positions 
date fields 	free 
result still input 	save old 
line name 	hash part 
email part reading 	must grow 
reflog entry 	create hash 
human readable 	part appropriate 
name look end 	size 
line find 	part must 
trailing mail address 	shrink insert 
even though 	elements vanishing 
already know split 	slice shrink 
mail end 	insert elements 
help cases broken 	hash 
idents extra 	part free 
somewhere email address 	old nums 
note assuming 	number keys 
timestamp never note 	reset counts 
always find 	count keys 
going front always 	part 
hit split 	keys integer 
mail end closing 	keys count 
bracket imap-send.c 	keys hash 
verbosity use curl 	part count 
imap send 	extra key 
usage imap 	compute 
send options buf 	size part 
blen fmt 	resize table 
strp fmt len 	computed sizes 
tmp name 	temporary values 
tunnel host port 	kept malloc 
folder user 	fails 
pass use ssl 	could find 
ssl verify 	free place 
use html auth 	inserts key 
method server 	hash table 
ssl sock bytes 	first check 
offset buf 	whether 
uidnext caps rcaps 	key main 
nexttag num 	position free 
progress pending progress 	check whether 
progress append 	colliding node 
buf name uidvalidity 	main position 
imap prefix 	move 
ctx cmd 	colliding node 
prompt ctx cmd 	empty place 
response ctx 	put key 
data dlen uid 	main position 
next cmd 	otherwise colliding 
tag cap list 	node 
ctx tcmd 	main position 
func func sock 	key goes 
ret sslerr 	empty position 
sock use tls 	free place 
verify host 	cannot find 
pattern cert hostname 	free 
len subj 	place grow 
cname found num 	table insert 
subj alt 	key grown 
names subj alt 	table colliding 
name sock 	node main 
use tls 	position 
verify meth meth 	yes move 
ctx ret 	colliding node 
cert sock buf 	free position 
len sock 	find previous 
buf len sock 	redo chain 
start msg 	place 
msg ret buf 	copy colliding 
blen fmt 	node free 
ret ctx fmt 	pos next 
imap cmd 	also goes 
bufl buf ctx 	free colliding 
fmt cmdp 	node 
ctx fmt cmdp 	main position 
level imap 	node free 
cmd arg ctx 	position chain 
imap arg 	position search 
ctx tcmd imap 	function integers 
cmdp pcmdp 	key 
cmd arg 	key sizearray 
arg resp resp 	check whether 
tag ictx 	key somewhere 
imap ctx challenge 	chain search 
user pass 	function check 
resp len encoded 	whether 
len decoded 	key somewhere 
len hmac hash 	chain main 
hex response 	search function 
response challenge challenge 	index use 
user pass 	specialized version 
ctx cmd prompt 	check 
ret response 	whether key 
srvc folder cred 	somewhere chain 
ctx imap 	zero present 
arg rsp preauth 	index find 
tunnel hints 	present overflow 
gai portstr addr 	table 
addr msg 	built bad 
lastc ctx 	purposes resort 
msg imap prefix 	linear search 
box ret 	binary search 
msg buf content 	find boundary 
type pre 	table 
open pre close 	boundary integer 
body msgs 	index non 
msgs count msgs 	nil nil 
msg ofs 	nil boundary 
data len val 	part binary 
server msgs 	search 
total msg ctx 	must find 
ofs percent 	boundary hash 
srvc curl path 	part hash 
auth server 	part empty 
msgs total ofs 	easy ltable.h 
msgbuf curl 	key 
res percent prev 	key key 
len argc 	key key 
argv msgs 	key narray 
total nongit vsnprintf 	lnhash nasize 
die die 	key key 
xmemdupz err error 	ltable 
err error 	roberto exp 
ssl error perror 	lua tables 
ssl socket 	hash see 
perror perror strchr 	copyright notice 
strcasecmp stack 	lua ltablib.c 
ext general name 	max 
num general 	pos pos 
name strlen host 	lsep last 
matches general 	sep res 
name pop free 	tab funcs 
subject name 	aux getn 
error name text 	lua 
nid error 	checktype lua 
strlen host matches 	pushvalue lua 
error ssl 	pushinteger lua 
library init 	rawgeti lua 
ssl load error 	call 
method method 	lua isnil 
ssl socket perror 	lua pop 
ssl ctx 	lua checktype 
ssl ctx verify 	lua checktype 
ssl ctx 	lua pushnil 
verify paths ssl 	lua 
socket perror 	next lua 
ssl ssl socket 	pushvalue lua 
perror ssl 	pushvalue lua 
rfd ssl socket 	pushvalue lua 
perror ssl 	call lua 
wfd ssl socket 	isnil 
perror ssl 	lua pop 
tlsext host name 	lua checktype 
warning ssl 	lua pushnil 
connect socket 	lua next 
perror ssl peer 	lua pop 
certificate error 	lua 
verify hostname ssl 	type lua 
read xread 	tonumber lua 
socket perror close 	pushnumber lua 
close ssl 	pushinteger aux 
write write full 	getn lua 
socket perror 	checktype 
close close ssl 	lua setn 
shutdown ssl 	lua checkint 
free close close 	lua error 
memmove socket 	lua lua 
read puts start 	pushvalue aux 
vprintf end 	getn 
fflush start vfprintf 	lua gettop 
end isspace 	lua checkint 
strchr isspace start 	lua rawgeti 
vsnprintf die 	lua rawseti 
end xmalloc 	lua error 
nfvasprintf memset cmd 	lua 
result nfsnprintf 	lua setn 
nfsnprintf cap starts 	lua rawseti 
socket write 	aux getn 
free free free 	lua optint 
cap socket 	lua setn 
write free socket 	lua 
write free 	rawgeti lua 
free start issue 	rawgeti lua 
imap cmd 	rawseti lua 
end cmd result 	pushnil lua 
start issue 	rawseti lua 
imap cmd end 	rawgeti 
cmd result 	lua isstring 
isspace skip imap 	lua error 
list isspace 	lua lua 
skip imap list 	lua addvalue 
next arg 	lua optlstring 
size strcmp 	lua 
strchr next arg 	checktype lua 
strcmp next 	optint lua 
arg atoi strcmp 	opt lua 
next arg 	getn lua 
atoi strcmp parse 	buffinit addfield 
capability strcmp 	lua 
isspace strcmp next 	addlstring addfield 
arg atoi 	lua pushresult 
next arg atoi 	lua rawseti 
buffer gets 	lua rawseti 
next arg next 	lua isnil 
arg strcmp 	lua 
skip list skip 	pushvalue lua 
list skip 	pushvalue lua 
list strcmp strcmp 	pushvalue lua 
strcmp strcmp 	call lua 
parse response code 	toboolean lua 
strcmp parse 	pop 
capability next 	lua lessthan 
arg offsetof socket 	lua rawgeti 
write free 	lua rawgeti 
cont socket write 	sort comp 
atoi next 	lua pop 
arg strcmp strcmp 	lua 
starts parse 	rawgeti lua 
response code done 	rawgeti sort 
free free 	comp lua 
free imap exec 	pop lua 
socket shutdown 	rawgeti sort 
free imap close 	comp 
server free 	lua pop 
strlen xmalloc evp 	lua rawgeti 
decode block 	lua pushvalue 
die hmac init 	lua rawgeti 
strlen evp 	lua rawgeti 
hmac update 	lua 
hmac hmac ctx 	error lua 
cleanup hexchar 	pop lua 
hexchar xstrfmt strlen 	rawgeti lua 
xmallocz encoded 	error lua 
size evp encode 	pop lua 
block die 	pop 
die cram socket 	lua rawgeti 
write strlen 	lua rawgeti 
strlen error free 	auxsort aux 
xcalloc xcalloc 	getn lua 
imap info argv 	checkstack lua 
push start 	isnoneornil 
command die imap 	lua checktype 
info snprintf 	lua settop 
memset imap info 	auxsort lua 
getaddrinfo gai 	ltablib roberto 
strerror imap info 	exp library 
socket getnameinfo 	table 
imap info 	manipulation see 
connect close perror 	copyright notice 
freeaddrinfo memset 	lua function 
htons imap info 	argument argument 
gethostbyname perror 	nil result 
imap info socket 	first 
imap info 	key function 
inet ntoa ntohs 	key result 
connect close 	first key 
perror fputs dup 	first empty 
ssl socket 	element insert 
connect close imap 	element 
info buffer 	called arguments 
gets next arg 	insert element 
next arg 	end argument 
strcmp strcmp parse 	position grow 
response code 	necessary move 
imap exec cap 	elements 
imap exec 	size pos 
ssl socket 	position outside 
connect imap exec 	bounds nothing 
imap info 	result pos 
xstrdup xstrdup xstrdup 	pos pos 
xstrdup credential 	nil 
fill xstrdup xstrdup 	last interval 
cap strcmp 	empty quicksort 
cap memset imap 	algorithms modula 
exec imap 	robert sedgewick 
warn imap exec 	addison wesley 
credential approve 	function 
credential clear imap 	compensate function 
exec imap 	compensate function 
exec imap info 	tail recursion 
credential reject 	sort elements 
credential clear imap 	swap elements 
close store 	elements 
xmallocz strbuf attach 	pivot need 
crlf memset 	sort invariant 
strbuf detach 	repeat repeat 
strcmp imap exec 	pop pivot 
strstr strbuf 	swap pivot 
strbuf addstr strbuf 	adjust 
addch strbuf 	smaller half 
addstr strbuf addstr 	larger one 
xml quoted 	call recursively 
strbuf addstr strbuf 	smaller one 
release feof 	repeat routine 
strbuf fread ferror 	larger 
starts strstr 	one smaller 
strstr strstr strstr 	argument make 
starts strchr 	sure two 
strstr strbuf git 	arguments ltm.c 
config git 	lua typenames 
config git config 	lua 
git config 	eventname events 
git die config 	ename lua 
starts starts 	lua fix 
starts xstrdup 	lua getstr 
git config git 	lua ttisnil 
config git 	cast 
config git config 	ttype hvalue 
git config 	uvalue ttype 
imap open store 	lua getstr 
split msg 	ltm roberto 
wrap html imap 	exp tag 
store msg 	methods 
imap close store 	see copyright 
curl init 	notice lua 
die curl easy 	order never 
init die 	collect names 
curl easy setopt 	function used 
curl easy 	macro 
setopt strbuf addstr 	fasttm optimized 
strbuf addch 	absence tag 
strbuf addstr 	methods tag 
curl easy setopt 	method cache 
strbuf release 	fact ltm.h 
curl easy setopt 	lua 
warning strbuf 	typenames events 
addstr strbuf addstr 	ename ltm 
curl easy 	roberto exp 
setopt strbuf release 	tag methods 
curl easy 	see copyright 
setopt curl easy 	notice 
setopt curl 	lua warning 
easy setopt curl 	change order 
easy setopt 	enumeration grep 
curl easy setopt 	order last 
getenv curl 	tag method 
easy setopt setup 	fast 
curl curl 	access number 
easy setopt split 	elements lua.c 
msg wrap 	progname pname 
html crlf 	msg status 
curl easy setopt 	msg narg 
curl curl 	clear 
easy perform curl 	status argv 
easy strerror 	narg argc 
curl easy cleanup 	name status 
curl cleanup 	name status 
git extract argv 	name firstline 
path git 	status 
setup gettext setup 	lmsg msg 
git directory 	firstline buffer 
gently git imap 	prmt status 
config parse 	status oldprogname 
options usage options 	argv status 
warning warning 	fname 
read message count 	narg argv 
messages append 	argv chunk 
msgs imap curl 	filename init 
append msgs 	argc argv 
imap append 	status argv 
msgs imap git 	script 
imap send 	argc argv 
drops patches imap 	status lua 
drafts folder 	sethook lua 
derived isync mbsync 	error signal 
mailbox synchronizer 	lua sethook 
copyright michael elkins 	lua 
mutt copyright 	lua lua 
oswald buddenhagen ossi 	fflush fflush 
users net 	lua isnil 
copyright theodore tytso 	lua tostring 
mit edu 	message lua 
copyright mike cormack 	pop 
program free 	lua isstring 
software redistribute modify 	lua getfield 
terms gnu 	lua istable 
general license published 	lua pop 
free software 	lua getfield 
foundation either 	lua 
version license option 	isfunction lua 
later version 	pop lua 
program distributed hope 	pushvalue lua 
useful without 	pushinteger lua 
warranty without even 	call lua 
implied warranty 	gettop 
merchantability fitness particular 	lua pushcfunction 
purpose see 	lua insert 
gnu general license 	signal lua 
details received 	pcall signal 
copy gnu general 	lua lua 
license along 	message 
program write free 	lua checkstack 
software foundation 	lua pushstring 
inc temple place 	lua createtable 
suite boston 	lua pushstring 
usa available 	lua rawseti 
option strictly opt 	lua 
name tunnel 	loadfile docall 
host port folder 	report lua 
user pass 	loadbuffer strlen 
use ssl ssl 	docall report 
verify use 	lua getglobal 
html auth method 	lua 
responses capability 	pushstring report 
results command queue 	docall lua 
big put 	getfield lua 
last currently open 	tostring lua 
mailbox foreign 	pop lua 
maybe preset dns 	tolstring 
subject alt 	strstr lua 
names common name 	lua pop 
sni rfc 	prompt lua 
open ssl document 	readline strlen 
function implementation 	lua pushfstring 
returns success 	lua 
failure calling lerr 	pushstring lua 
make sure 	freeline lua 
hostname matches certificate 	settop pushline 
simple line 	lua loadbuffer 
buffering make sure 	lua tostring 
enough data 	lua 
read sequence shift 	strlen incomplete 
used bytes 	pushline lua 
terminate next line 	pushliteral lua 
reached sublist 	insert lua 
quoted atom response 	concat lua 
code rfc 	saveline 
says messages must 	lua loadline 
displayed user 	docall report 
rfc response personal 	lua gettop 
mailboxes others 	lua getglobal 
mailboxes shared mailboxes 	lua insert 
unhandled response 	lua 
data least 	pcall lua 
two words ignore 	gettop message 
needswork previously 	lua pushfstring 
handled num exists 	lua lua 
num recent 	tostring lua 
probably unintended side 	settop 
effect ignores 	fputs fflush 
unrecognized two word 	getargs lua 
responses imap 	setglobal strcmp 
send doesn ever 	strcmp lua 
read messages 	loadfile lua 
mailboxes days consider 	insert 
eliminating happen 	docall lua 
last command underway 	pop report 
enforces round 	notail notail 
trip strcmp bad 	notail lua 
arg reached 	lua dostring 
hexchar cram functions 	lua 
code isync 	dolibrary getenv 
project http 	dofile dostring 
isync net length 	lua touserdata 
challenge encoded 	lua lua 
good enough upper 	openlibs lua 
bound challenge 	handle 
decoded result response 	luainit collectargs 
user digest 	print usage 
hex open connection 	print version 
imap server 	runargs handle 
ipv read greeting 	script dotty 
capabilities may 	lua 
changed capabilities cram 	stdin tty 
preauth check 	print version 
target mailbox exists 	dotty dofile 
insert characters 	lua open 
necessary msg ensure 	message lua 
every character 	cpcall 
msg preceded 	report lua 
first pass tally 	close lua 
size need 	roberto exp 
added second pass 	lua stand 
write note 	alone interpreter 
loop otherwise identical 	see 
first pass 	copyright notice 
store msg imap 	lua unused 
also detach 	arg another 
free data msg 	sigint happens 
data leaving 	lstop terminate 
msg data empty 	process 
headers body 	action message 
wrapping needed copy 	keep intact 
next message 	pass error 
msgs starting offset 	message skip 
ofs msg 	function traceback 
update ofs start 	call 
following message 	debug traceback 
iff message 	function index 
successfully copied read 	push traceback 
messages write 	function put 
imap server index-pack.c 	chunk args 
index pack 	traceback 
usage idx size 	function force 
hdr size 	complete garbage 
type real type 	collection errors 
delta depth 	count total 
child obj data 	number arguments 
size first 	number 
last ofs first 	arguments script 
ofs last 	input line 
cache cache used 	ends newline 
pack offset 	first line 
obj sha obj 	starts change 
objects obj 	input 
stat ofs deltas 	repeat gets 
deltas nothread 	complete line 
data objects 	cannot lines 
ofs deltas deltas 	input line 
deltas alloc 	two lines 
resolved deltas threads 	line 
stdin strict 	result print 
fsck fsck options 	clear stack 
verbose show 	collect arguments 
stat check self 	stdin check 
contained connected 	argument extra 
progress input buffer 	characters 
input offset 	end option 
input len consumed 	option invalid 
bytes deepest 	option option 
delta input ctx 	stop file 
input crc 	fails status 
input output curr 	stop 
pack data 	collector initialization 
dispatched threads active 	open libraries 
read mutex 	invalid args 
counter mutex 	executes stdin 
work mutex deepest 	file create 
delta mutex 	state 
type cas mutex 	lua.h panicf 
key mutex 	idx idx 
mutex obj type 	idx idx 
data options 	idx idx 
obj size type 	idx idx 
max foreign 	idx 
min ret bytes 	idx idx 
pack name 	idx idx 
tmp file hdr 	idx idx 
offset format 	idx idx 
offset format buf 	idx idx 
data retain 	idx 
data delta type 	len idx 
unpack entry 	idx idx 
data obj ofs 	idx idx 
offset sha 	fmt argp 
sha size 	fmt idx 
offset shift data 	idx 
obj consume 	idx idx 
data len data 	narr nrec 
inbuf stream 	objindex idx 
status obj compare 	idx idx 
ofs delta 	idx idx 
bases find ofs 	objindex 
delta find 	idx nargs 
ofs delta children 	nresults nargs 
compare delta 	nresults errfunc 
bases find delta 	func reader 
find delta 	chunkname writer 
children entry buf 	data 
buf size 	nresults narg 
buf size data 	data idx 
data len 	level funcindex 
entry data 	funcindex func 
size sha obj 	mask count 
delta delta 	name 
alloc raw delta 	namewhat source 
obj result 	currentline nups 
data delta data 	linedefined lastlinedefined 
compare swap 	src lua 
type prev child 	roberto exp 
result child 	lua 
result prev delta 	extensible extension 
delta delta 	language lua 
delta obj obj 	puc rio 
data sha 	brazil http 
delays ofs delta 	www 
delta sha 	lua see 
obj data obj 	copyright notice 
ret obj 	end file 
fix thin pack 	mark precompiled 
curr pack 	code esc 
pack sha 	lua 
read sha tail 	option multiple 
sha msg 	returns lua 
unresolved objects initial 	pcall lua 
size stream 	call pseudo 
status outbuf append 	indices status 
obj pack 	functions 
sorted pos obj 	read write 
pack name 	blocks loading 
curr pack name 	dumping lua 
index name 	chunks prototype 
curr index name 	memory allocation 
keep name 	functions 
keep msg sha 	basic types 
report name 	minimum lua 
err keep keep 	stack available 
msg len 	function extra 
buf len opts 	include file 
opts idx 	type 
idx opts 	numbers lua 
pack name stat 	type integer 
baseobjects chain 	functions state 
histogram obj bobj 	manipulation basic 
argc argv 	stack manipulation 
prefix stat curr 	access 
index pack 	functions stack 
name keep msg 	push functions 
keep name 	stack functions 
buf idx objects 	lua stack 
opts pack 	functions stack 
sha foreign arg 	lua 
end hdr 	load call 
len len pthread 	functions load 
mutex pthread 	run lua 
mutex unlock init 	code coroutine 
recursive mutex 	functions garbage 
pthread mutex init 	collection 
pthread mutex 	function options 
init pthread 	miscellaneous functions 
mutex init pthread 	useful macros 
mutex init 	compatibility macros 
pthread key create 	functions hack 
xcalloc open 	debug 
die errno pthread 	api codes 
mutex destroy 	masks activation 
pthread mutex destroy 	record functions 
pthread mutex 	called debuger 
destroy pthread mutex 	specific events 
destroy pthread 	local 
mutex destroy close 	field method 
pthread key 	lua main 
free die oid 	tail number 
hex sha 	upvalues part 
info die oid 	active function 
hex die 	copyright 
oid hex 	lua puc 
max index check 	rio rights 
indexed write 	reserved permission 
die git sha 	hereby granted 
update memmove 	free charge 
die flush xread 	person 
die die 	obtaining copy 
errno display throughput 	software associated 
die crc 	documentation files 
overflows die odb 	software deal 
mkstemp xstrdup 	software without 
open die errno 	restriction 
open die 	including without 
errno git sha 	limitation rights 
init fill 	use copy 
htonl die pack 	modify merge 
version die 	publish distribute 
ntohl ntohl use 	sublicense 
start vsnprintf 	sell copies 
end die 	software permit 
pthread getspecific pthread 	persons software 
setspecific xcalloc 	furnished subject 
free data data 	following conditions 
free data 	copyright 
data data prune 	notice permission 
data data 	notice shall 
free data crc 	included copies 
fill use 	substantial portions 
fill use hashcpy 	software software 
fill use 	provided 
fill use msb 	without warranty 
bad fill 	kind express 
use bad bad 	implied including 
unpack entry 	limited warranties 
data xmallocz xmalloc 	merchantability fitness 
memset git 	particular 
inflate init xpread 	purpose noninfringement 
data die 	shall authors 
errno die 	copyright holders 
git inflate git 	liable claim 
inflate consume 	damages liability 
free free die 	whether 
git inflate 	action contract 
end free free 	tort otherwise 
unpack data 	arising connection 
free xmalloc read 	software use 
istream die 	dealings software 
sha hex die 	luac.c 
sha hex 	listing dumping 
memcmp die sha 	stripping output 
hex memset 	output progname 
open istream die 	message message 
sha hex 	argc argv 
unpack data close 	version 
istream free 	size argc 
delta type alloc 	argv argc 
grow data 	argv filename 
pack data 	argc argv 
prune data data 	exit strerror 
data pack 	exit 
patch delta free 	lua exit 
bad data 	usage lua 
prune data free 	usage exit 
deepest delta 	toproto lua 
deepest delta unlock 	newproto setptvalue 
data pack 	incr 
data patch delta 	top lua 
free bad 	newliteral lua 
hash sha file 	newvector lua 
sha counter 	newvector toproto 
counter unlock find 	create create 
delta children 	abc 
find ofs delta 	create abc 
children free 	unused fwrite 
link data 	lua touserdata 
alloc data compare 	lua checkstack 
swap type 	fatal lua 
die resolve delta 	loadfile 
free data 	fatal lua 
alloc data resolve 	tostring combine 
delta free 	lua print 
data unlink data 	fopen cannot 
find unresolved 	lua lua 
deltas free hashcmp 	dump 
alloc data 	lua unlock 
find unresolved deltas 	ferror cannot 
data counter 	fclose cannot 
display progress counter 	doargs usage 
unlock work 	lua open 
delta type work 	fatal 
unlock work 	lua cpcall 
unlock resolve start 	fatal lua 
progress unpack 	tostring lua 
raw entry 	close luac 
alloc grow hashcpy 	lhf exp 
sha free 	lua 
display progress stop 	compiler saves 
progress flush 	bytecodes files 
git sha hashcmp 	also list 
fill die 	bytecodes see 
use fstat die 	copyright notice 
errno isreg 	lua 
lseek die sha 	program name 
die qsort 	output file 
qsort start progress 	list bytecodes 
getenv init 	dump bytecodes 
pthread create die 	strip debug 
strerror pthread 	information 
cleanup delta type 	output file 
resolve display 	name actual 
progress stop progress 	output file 
flush die 	name actual 
realloc memset 	program name 
sha fix unresolved 	end 
deltas strbuf 	options keep 
addf stop progress 	end options 
msg strbuf 	skip end 
release sha close 	options use 
hashcpy fixup 	stdin list 
pack header footer 	output 
hashcmp die 	file parse 
die git deflate 	strip debug 
init git 	information show 
deflate sha write 	version unknown 
die git 	option luaconf.h 
deflate end alloc 	luaconf 
qsort alloc 	roberto exp 
data read sha 	configuration file 
file check 	lua see 
sha signature die 	copyright notice 
sha hex 	lua search 
append obj 	find 
pack find unresolved 	configurable definitions 
deltas display 	lua ansi 
progress free close 	controls use 
fsync die 	non ansi 
close die errno 	features change 
strlen odb 	define 
pack keep open 	want lua 
die errno 	avoid use 
write die write 	non ansi 
die close 	feature library 
die errno snprintf 	needs extra 
directory sha 	library 
hex finalize file 	ldl needs 
die chmod 	extra libraries 
snprintf directory sha 	need extra 
hex finalize 	library lua 
file die chmod 	use posix 
sha hex 	includes 
snprintf sha 	functionallity listed 
hex write die 	open system 
xwrite strcmp 	interfaces extension 
git config die 	xsi change 
strcmp git 	define system 
config die warning 	xsi 
git config 	compatible lua 
ntohl check pack 	path lua 
index ptr 	cpath names 
alloc grow ntohl 	environment variables 
qsort packed 	lua check 
git strlen die 	paths 
open pack 	lua init 
index die read 	name environment 
anomalous offsets 	variable lua 
close pack index 	checks initialization 
free xcalloc 	code change 
delta type 	want 
sha hex delta 	different names 
type sha 	lua path 
hex putchar strcmp 	path lua 
usage reset 	uses look 
pack idx option 	lua libraries 
git config 	lua 
chdir die strcmp 	cpath path 
strcmp strcmp 	lua uses 
skip prefix fsck 	look libraries 
msg types 	change machine 
strcmp strcmp strcmp 	non conventional 
strcmp strcmp 	directory 
starts starts strtoul 	hierarchy want 
usage warning 	install libraries 
starts htonl htonl 	non conventional 
strtoul die 	directories windows 
htonl strtoul die 	exclamation mark 
strcmp strcmp 	path 
usage starts 	replaced path 
strtoul die strtoul 	directory executable 
die usage 	file current 
usage usage die 	process lua 
strip suffix 	dirsep directory 
die strbuf strbuf 	separator 
addstr strip 	submodules change 
suffix die strbuf 	machine use 
strbuf addstr 	directory separator 
die read idx 	windows windows 
option online 	lua automatically 
cpus open pack 	uses 
file parse 	lua pathsep 
pack header xcalloc 	character separates 
xcalloc xcalloc 	templates path 
parse pack objects 	lua path 
resolve deltas 	mark marks 
conclude pack free 	substitution 
free check 	points lua 
objects show 	execdir windows 
pack info alloc 	path replaced 
write idx 	executable directory 
file free close 	lua igmark 
free strbuf 	mark 
release strbuf release 	ignore bulding 
free free 	luaopen function 
always read chunks 	name change 
mutex conditional 	reason system 
variable statically initialized 	cannot use 
windows content 	characters 
linked must must 	one characters 
already present 	common character 
database discard current 	file directory 
buffer used 	names probably 
content make sure 	need change 
least min 	lua 
bytes available buffer 	integer integral 
pointer buffer 	type used 
make sure 	lua pushinteger 
sufficiently large wrap 	lua tointeger 
header consistency 	change ptrdiff 
check inflated first 	adequate 
encountered need 	machine machines 
free memory buf 	ptrdiff gives 
deleted caller 	good choice 
function part find 	lua api 
unresolved deltas 	mark core 
two walkers going 	api 
opposite ways 	functions lualib 
first one find 	api mark 
unresolved deltas 	standard library 
traverses parent node 	functions change 
children deflating 	need define 
nodes along way 	functions 
however memory 	special way 
deflated nodes 	instance want 
limited delta cache 	create one 
limit point 	windows dll 
parent node deflated 	core libraries 
content may 	may 
freed second walker 	want use 
function goes 	following definition 
current node top 	define lua 
parent necessary 	build dll 
deflate node normal 	often libs 
situation parent 	together 
node would already 	core luai 
deflated needs 	func mark 
apply delta worst 	functions exported 
scenario parent 	outside modules 
node longer deflated 	luai data 
running delta 	mark 
cache limit need 	variables exported 
deflate parents 	outside modules 
possibly top 	change need 
deflated objects subject 	mark special 
freed exceed 	way elf 
delta cache limit 	gcc 
like find 	versions later 
unresolved deltas need 	mark hidden 
make sure 	optimize access 
last node freed 	lua compiled 
standard compare 	shared library 
swap atomically check 	empty 
whether type 	lua describes 
want swap otherwise 	error messages 
untouched first 	quote program 
pass find locations 	elements change 
objects calculate 	want different 
sha non delta 	appearance 
objects remember 	lua idsize 
sha offset deltas 	gives maximum 
large blobs 	size description 
check later 	source function 
check pack integrity 	debug information 
input file 	change 
reached end second 	want different 
pass non 	size stand 
delta objects look 	alone configuration 
used deltas 	lua stdin 
used uncompress apply 	tty detects 
deltas recursively 	whether 
checking resulting used 	standard input 
deltas sort 	tty whether 
deltas sha offset 	running lua 
fast searching 	interactively change 
third pass append 	better definition 
objects convert 	non 
thin pack full 	posix non 
pack required 	windows systems 
write sha flush 	stdin tty 
remaining pack 	lua prompt 
sha since 	prompt used 
many unresolved deltas 	stand 
may well 	alone lua 
objects unresolved deltas 	lua prompt 
really want 	continuation prompt 
include smallest number 	used stand 
objects would 	alone lua 
cover much delta 	change 
possible picking 	want different 
trunc deltas first 	prompts also 
allowing deltas 	change prompts 
resolve without additional 	dynamically assigning 
objects since 	globals prompt 
objects found deltas 	prompt 
depending good 	lua progname 
heuristic start resolving 	name stand 
deltas order 	alone lua 
position pack 	program change 
mimic git unpack 	stand alone 
objects write 	interpreter 
last part input 	different name 
buffer stdout 	system able 
address offset table 	detect name 
header fan 	automatically lua 
sha table crc 	maxinput maximum 
table address 	length 
offset table real 	input line 
offset ntohl 	stand alone 
idx high octets 	interpreter change 
ntohl idx 	need longer 
low octets idx 	lines lua 
zero read 	readline 
attributes existing idx 	defines show 
file rid 	prompt read 
idx file need 	line standard 
anymore needswork 	input lua 
extract bit 	saveline defines 
free pack name 	save 
sha file 	read line 
perhaps shouldn matter 	history lua 
much know 	freeline defines 
haven installed pack 	free line 
hence never 	read lua 
read anything zero 	readline 
good bad 	change want 
experiment showed threads 	improve functionality 
mean faster 	gnu readline 
caller know pack 	history facilities 
self contained 	non empty 
inet ntopc src 	line 
dst size 	history show 
fmt nprinted src 	prompt line 
dst size 	luai gcpause 
len words src 	defines pause 
dst size 	garbage collector 
snprintf strlcpy 	cycles 
memset inet ntop 	percentage change 
strlen snprintf 	want run 
size strlcpy inet 	faster slower 
ntop inet 	higher values 
ntop copyright internet 	mean larger 
software consortium 	pauses 
permission use copy 	mean slower 
modify distribute 	collection also 
software purpose without 	change dynamically 
fee hereby 	wait memory 
granted provided copyright 	next luai 
notice permission 	gcmul 
notice appear copies 	defines speed 
software provided 	garbage collection 
internet software consortium 	relative memory 
disclaims warranties 	allocation percentage 
regard software including 	change 
implied warranties 	want change 
merchantability fitness 	granularity garbage 
shall internet software 	collection higher 
consortium liable 	values mean 
special direct indirect 	coarser collections 
consequential damages 	represents 
damages whatsoever resulting 	infinity step 
loss use 	performs full 
data profits whether 	collection also 
action contract 	change dynamically 
negligence tortious action 	runs twice 
arising connection 	speed 
use performance software 	memory allocation 
warning even 	lua compat 
consider trying compile 	getn controls 
system fine 	compatibility old 
world vax inet 	getn behavior 
ntop src 	change 
dst size format 	define want 
address dst 	exact compatibility 
notes uses 	behavior setn 
statics takes addr 	getn lua 
input author 	lua compat 
paul vixie errno 	loadlib 
snprintf inet 	controls compatibility 
ntop src dst 	loadlib change 
size convert 	undefined soon 
binary address presentation 	need loadlib 
printable format 	function function 
author paul vixie 	still 
note need 	available loadlib 
least large enough 	lua compat 
contain specified 	vararg controls 
size systems like 	compatibility old 
crays thing 	vararg feature 
integer variable bits 	change 
keep mind 	undefined soon 
think function 	programs use 
coded use pointer 	access vararg 
overlays world 	parameters instead 
vax preprocess copy 	old arg 
input bytewise 	table 
wordwise find longest 	lua compat 
run src 	mod controls 
shorthanding format result 	compatibility old 
inside best 	math mod 
run following initial 	function change 
run real 	undefined 
hex address encapsulated 	soon programs 
trailing run 	use math 
check overflow copy 	fmod instead 
done inet 	math mod 
ntop src dst 	lua compat 
size convert 	lstr 
network format address 	controls compatibility 
presentation format 	old nesting 
pointer presentation 	facility change 
format address dst 	want old 
see errno 	behaviour undefine 
author paul vixie 	turn 
notreached inet 	advisory error 
ptonc src dst 	nesting lua 
src dst 	compat gfind 
src dst digits 	controls compatibility 
saw digit 	old gfind 
octets tmp pch 	name 
src dst 	change undefined 
xdigits tmp endp 	soon rename 
colonp xdigits 	gfind gmatch 
curtok saw xdigit 	lua compat 
val pch 	openlib controls 
src dst strchr 	compatibility 
memcpy memset 	old lua 
strchr strchr inet 	openlib behavior 
pton memcpy 	change undefined 
inet pton 	soon replace 
inet pton copyright 	lua uses 
internet software 	lua 
consortium permission use 	openlib luai 
copy modify 	apicheck macro 
distribute software purpose 	used lua 
without fee 	api change 
hereby granted provided 	luai apicheck 
copyright notice 	want 
permission notice appear 	lua perform 
copies software 	checks parameters 
provided internet software 	gets api 
consortium disclaims 	calls may 
warranties regard software 	slow interpreter 
including implied 	bit 
warranties merchantability fitness 	may quite 
shall internet 	useful debugging 
software consortium liable 	code interfaces 
special direct 	lua useful 
indirect consequential 	redefinition use 
damages damages whatsoever 	luai 
resulting loss 	bitsint defines 
use data profits 	number bits 
whether action 	change lua 
contract negligence tortious 	cannot automatically 
action arising 	detect number 
connection use performance 	bits 
software warning 	machine probably 
even consider trying 	need change 
compile system 	avoid overflows 
fine world vax 	comparison least 
inet pton 	bits luai 
src dst like 	integer 
inet aton 	least bits 
without hexadecimal shorthand 	luai integer 
src valid 	least bits 
dotted quad 	luai umem 
notice touch dst 	integer big 
unless returning 	enough 
author paul vixie 	count total 
inet pton 	memory used 
src dst convert 	lua luai 
presentation level 	mem integer 
address network order 	big enough 
binary form 	count 
src valid rfc 	total memory 
address notice 	used lua 
touch dst unless 	change weird 
returning full 	reason definitions 
address silently ignored 	good enough 
credit inspired 	machine 
mark andrews author 	definitions part 
paul vixie 	always works 
leading requires special 	may waste 
handling seen 	space machines 
inet pton 	bit longs 
since memmove erroneously 	probably 
fail handle 	need change 
overlapping regions shift 	bit ints 
hand isc 	luai maxcalls 
net pton src 	limits number 
dst convert 	nested calls 
presentation format usually 	change 
means ascii 	need really 
printable network format 	deep recursive 
usually kind 	calls limit 
binary format address 	arbitrary purpose 
valid specified 	stop infinite 
address family address 	recursion 
wasn valid 	exhausting memory 
dst untouched error 	luai maxcstack 
occurred dst 	limits number 
untouched author paul 	lua stack 
vixie notreached 	slots function 
init-db.c init 	use 
bare repository init 	change need 
shared repository 	lots lua 
init dir git 	stack space 
link path 	functions limit 
dir path baselen 	arbitrary purpose 
baselen git 	stop 
exists subdir lnk 	functions consume 
dir path 	unlimited stack 
path len dir 	space must 
free git 	smaller lua 
dir work path 	registryindex change 
buf path 	smaller 
repo version junk 	values following 
reinit filemode 	definitions system 
work path baselen 	small stack 
git dir 	may want 
real git dir 	change larger 
exist git 	values 
dir src 	system large 
dir flags reinit 	stack limits 
git dir 	rigid constants 
buf len git 	control size 
dir slash 	stack allocated 
cwd cwd git 	arrays 
dir opt 	used compiler 
arg unset init 	interpreter others 
usage argc 	limit maximum 
argv prefix git 	number recursive 
dir real 	calls compiler 
git dir work 	interpreter 
dir flags 	perform values 
init options mkdir 	large may 
tried saved 	cause stack 
cwd git dir 	overflow forms 
parent rel 	deep constructs 
safe create 	luai 
dir readdir strbuf 	maxccalls maximum 
setlen strbuf 	depth nested 
setlen strbuf addstr 	calls syntactical 
strbuf addstr 	nested non 
lstat die errno 	terminals program 
lstat die 	luai 
errno isdir opendir 	maxvars maximum 
die errno 	number local 
strbuf addch strbuf 	variables per 
addch copy 	function must 
templates closedir islnk 	smaller luai 
strbuf readlink 	maxupvalues 
die errno symlink 	maximum number 
die errno 	upvalues per 
strbuf release isreg 	function must 
copy file 	smaller lual 
die errno error 	buffersize buffer 
getenv system 	size 
path free 	used lauxlib 
strbuf addstr strbuf 	buffer system 
complete opendir 	lua number 
warning strbuf addstr 	type numbers 
git config 	lua change 
file strbuf setlen 	following 
warning strbuf 	definitions want 
addstr git dir 	build lua 
strbuf complete 	number type 
copy templates closedir 	different may 
free strbuf 	also need 
release strbuf release 	change 
strcmp git 	lua number 
config pathname strcmp 	lua number 
strcmp skip 	integer luai 
prefix strcmp safe 	uacnumber result 
create dir 	usual argument 
git path buf 	conversion 
safe create 	number lua 
dir git 	number scan 
path buf safe 	format reading 
create dir 	numbers lua 
git path buf 	number fmt 
git config 	format 
copy templates git 	writing numbers 
config adjust 	lua number 
shared perm git 	str converts 
dir adjust 	number luai 
shared perm git 	maxnumber str 
path buf 	maximum 
adjust shared perm 	size previous 
git path 	conversion lua 
buf adjust shared 	str number 
perm git 	converts number 
path buf git 	digits sign 
path buf 	point 
access readlink create 	luai num 
symref exit 	macros define 
xsnprintf git 	primitive operations 
config git path 	numbers lua 
buf lstat 	number macro 
chmod lstat chmod 	convert 
git config 	lua number 
bare repository git 	lua number 
config git 	integer macro 
work git config 	convert lua 
git config 	number lua 
needs work config 	integer 
git dir 	change know 
git config git 	faster way 
path buf 	convert lua 
close xmkstemp unlink 	number rounding 
symlink lstat 	method without 
islnk unlink git 	throwing 
config git 	errors system 
path buf access 	pentium machines 
git config 	naive typecast 
probe utf 	extremely slow 
pathname composition strbuf 	alternative worth 
release strbuf 	trying 
addstr directory safe 	pentium resort 
create dir 	trick microsoft 
strbuf setlen strbuf 	compiler use 
addstr safe 	assembler next 
create dir strbuf 	trick work 
setlen strbuf 	pentium 
addstr safe create 	sometimes clashes 
dir strbuf 	direct idiosyncrasy 
release stat die 	option always 
stat die 	works may 
xstrdup real path 	slow luai 
git dir 	user 
real path git 	alignment type 
dir real 	requires maximum 
path stat 	alignment change 
isreg read gitfile 	system requires 
isdir die 	alignments larger 
rename die errno 	instance 
write file 	system supports 
git dir separate 	doubles must 
git dir 	aligned boundaries 
safe create dir 	probably need 
bare repository 	change luai 
check repository format 	luai 
create files 	define lua 
create directory xsnprintf 	handling change 
xsnprintf xsnprintf 	prefer use 
die git config 	longjmp setjmp 
git config 	even want 
strlen strcmp xgetcwd 	use 
strcmp free 	longjmp setjmp 
strcmp strrchr strcmp 	instead regular 
git config 	longjmp setjmp 
perm parse 	lua handles 
options absolute path 	errors exceptions 
xstrdup real 	compiling 
path chdir safe 	code longjmp 
create leading 	setjmp asked 
directories die errno 	use longjmp 
mkdir die 	setjmp otherwise 
errno die errno 	exceptions dummy 
usage xgetcwd 	variable 
setenv free getenv 	unix longjmp 
getenv die 	setjmp efficient 
guess repository type 	handling jumps 
strrchr xstrndup 	lua maxcaptures 
xstrdup real path 	maximum number 
free xgetcwd 	captures 
git work git 	pattern pattern 
work access 	matching change 
git work die 	need captures 
errno git 	limit arbitrary 
work git 	lua tmpnam 
work git dir 	function 
init init 	library uses 
git information manager 	create temporary 
hell copyright 	name lua 
linus torvalds note 	tmpnambufsize maximum 
git hooks 	size name 
file exists repository 	created 
initialized etc 	lua tmpnam 
core git templates 	change alternative 
hooks update 	tmpnam considered 
would cause git 	insecure want 
init fail 	original tmpnam 
think sane means 	anyway 
templates ship 	lua uses 
along way git 	tmpnam posix 
organized really 	available uses 
carefully chosen make 	mkstemp lua 
sure correct 	popen spawns 
vintage git 	process 
dir directly inside 	connected current 
working git 	one file 
find need worktree 	streams change 
explicitly create 	way implement 
git refs heads 	system lua 
tags look 	define 
init templatedir first 	library system 
copy templates 	lua use 
might config file 	change lua 
would want 	problems choosing 
read installing reading 	appropriate library 
existing config 	system 
may overwrote would 	platform either 
created user 	windows dll 
umask shared repository 	mac dyld 
settings would 	unix dlopen 
need fix 	system kind 
create symlink git 	unix 
head master 	good chance 
branch exist yet 	dlopen lua 
forces creation 	dlopen work 
config file check 	use dlopen 
filemode trustability 	also need 
allow config file 	adapt 
check symlink 	src makefile 
supported work good 	probably adding 
check filesystem 	ldl linker 
insensitive make sure 	options lua 
symlinks resolved 	automatically change 
moving target repo 	makefile 
later separate 	ldl must 
git dir check 	also dlua 
see repository 	use dlopen 
version right note 	want kind 
newly created 	library undefine 
repository config 	options 
file fail catching 	win gets 
attempt reinitialize 	lua dll 
repository old tool 	mac gets 
spell configuration 	lua dyld 
read older version 	luai extraspace 
git note 	allows 
use octal numbers 	user specific 
share modes 	data lua 
compatibility values perm 	state data 
perm everybody 	goes lua 
force mode translators 	state pointer 
first either 	change 
reinitialized existing initialized 	define really 
empty second 	need must 
shared last verbatim 	multiple maximum 
directory name 	alignment required 
git dir git 	machine luai 
init always 	userstate 
bare git 	allow user 
dir pwd git 	specific actions 
init git 	threads change 
dir git git 	defined luai 
dir something 	extraspace need 
git usually otherwise 	something 
often bare 	extra created 
point guessing want 	deleted resumed 
share area 	yielded lua 
number branches advantages 	intfrmlen length 
save space 	modifier integer 
sharing sha objects 	conversions 
hand might 	format lua 
make lookup slower 	intfrm integer 
messier judge 	type correspoding 
one per managed 	previous length 
directory point 	modifier change 
haven read configuration 	system 
know shared 	supports support 
repository always 	local configuration 
play safe fallthru 	use space 
git work 	redefinitions without 
makes sense conjunction 	modifying main 
git dir 	part 
without bare error 	file lualib.h 
early git 	lualib roberto 
directory contents interpret-trailers.c 	exp lua 
git interpret 	standard libraries 
trailers usage argc 	see copyright 
argv prefix 	notice 
place trim empty 	lua key 
trailers options 	file handle 
parse options process 	type open 
trailers die 	previous libraries 
process trailers list 	lua bitc 
clear builtin 	idx 
git interpret 	hexdigits buf 
trailers copyright christian 	bit funcs 
couder chriscool 	msg lua 
tuxfamily khash.h hash 	tonumber lua 
upper mit 	checknumber bits 
license copyright attractive 	lua 
chaos attractor 	isnumber lua 
live permission hereby 	typerror barg 
granted free 	barg lua 
charge person obtaining 	isnone barg 
copy software 	lua 
associated documentation files 	pushlstring lua 
software deal 	pushnumber barg 
software without restriction 	lua error 
including without 	lua lua 
limitation rights use 	newlib lua 
copy modify 	bit 
merge publish distribute 	bit operations 
sublicense sell 	library lua 
copies software 	http bitop 
permit persons software 	luajit copyright 
furnished subject 	mike pall 
following conditions copyright 	rights 
notice permission 	reserved permission 
notice shall included 	hereby granted 
copies substantial 	free charge 
portions software software 	person obtaining 
provided without 	copy software 
warranty kind express 	associated 
implied including 	documentation files 
limited warranties merchantability 	software deal 
fitness particular 	software without 
purpose noninfringement shall 	restriction including 
authors copyright 	without limitation 
holders liable claim 	rights 
damages liability 	use copy 
whether action contract 	modify merge 
tort otherwise 	publish distribute 
arising connection 	sublicense sell 
software use dealings 	copies software 
software function 	permit 
uses buckets bytes 	persons software 
working space 	furnished subject 
instead key val 	following conditions 
buckets requested 	copyright notice 
size small hash 	permission notice 
table size 	shall 
changed shrink expand 	included copies 
rehash expand 	substantial portions 
otherwise shrink rehashing 	software software 
needed kick 	provided without 
process sort like 	warranty kind 
cuckoo hashing 	express 
kick existing element 	implied including 
mark deleted 	limited warranties 
old hash table 	merchantability fitness 
write element 	particular purpose 
jump loop 	noninfringement shall 
shrink hash table 	authors 
free working 	copyright holders 
space update hash 	liable claim 
table clear 	damages liability 
deleted elements expand 	whether action 
hash table 	contract tort 
todo implement automatically 	otherwise 
shrinking resize 	arising connection 
already support shrinking 	software use 
speed present 	dealings software 
deleted touch keys 	mit license 
present deleted 	http www 
convenient macros function 	opensource 
test whether 	licenses mit 
bucket contains data 	license php 
param pointer 	msvc stuck 
hash table khash 	last century 
name param 	doesn stdint 
iterator bucket 	convert 
khint containing data 	argument bit 
otherwise function 	type bit 
key given iterator 	type right 
param pointer 	shifts implementation 
hash table khash 	defined per 
name param 	facto 
iterator bucket khint 	standard arithmetic 
key type 	right shifts 
keys function given 	two complement 
iterator param 	behaviour required 
pointer hash table 	test perform 
khash name 	simple 
param iterator bucket 	self test 
khint type 	lua cjsonc 
values discussion hash 	json token 
sets calling 	type name 
results segfault 	escape cfg 
function val function 	args 
start iterator 	optindex setting 
param pointer hash 	min max 
table khash 	errmsg optindex 
name start iterator 	setting options 
khint function 	options cfg 
end iterator param 	cfg 
pointer hash 	cfg cfg 
table khash name 	cfg old 
end iterator 	setting options 
khint function number 	cfg cfg 
elements hash 	cfg cfg 
table param pointer 	cfg 
hash table 	json lindex 
khash name number 	reason json 
elements hash 	lindex escstr 
table khint function 	str len 
number buckets 	cfg json 
hash table 	max 
param pointer hash 	items cfg 
table khash 	current depth 
name number buckets 	json cfg 
hash table 	current depth 
khint function iterate 	json cfg 
entries hash 	current 
table param pointer 	depth json 
hash table 	length comma 
khash name param 	cfg json 
kvar variable 	lindex num 
key assigned param 	len cfg 
vvar variable 	current 
assigned param code 	depth json 
block code 	comma keytype 
execute function iterate 	cfg current 
values hash 	depth json 
table param pointer 	len cfg 
hash table 	local 
khash name 	encode buf 
param vvar variable 	encode buf 
assigned param 	json len 
code block code 	json token 
execute khash 	hex hex 
kwset.c llink rlink 	digit 
trie label 	utf codepoint 
balance accepting links 	json utf 
parent next 	codepoint surrogate 
fail depth shift 	low len 
maxshift obstack 	escape len 
words trie mind 	token 
maxd delta 	json errtype 
next target mind 	json token 
trans trans 	escape json 
kwset kws text 	json token 
len kwset 	endptr json 
trie label link 	token 
depth links 	token json 
last treefails 	exp token 
treedelta hasevery treenext 	found json 
kws kwset 	json slots 
curr trans delta 	json token 
fail last 	json 
next kws text 	token json 
size kwset 	token json 
len kws text 	token json 
len kwsmatch 	len reg 
kwset next trie 	nup err 
accept beg 	reg 
lim mch lmch 	func lua 
delta end 	touserdata lua 
qlim trans kws 	upvalueindex lua 
text size 	error lua 
kwsmatch kwset ret 	argcheck lua 
kws kwset 	gettop 
xmalloc obstack 	lua gettop 
init obstack alloc 	lua pushnil 
kwsfree obstack 	json fetch 
alloc obstack alloc 	config lua 
obstack free 	isnil lua 
abort abort abort 	checkinteger 
enqueue enqueue 	snprintf lua 
memset obstack alloc 	argcheck lua 
enqueue treedelta 	pushinteger lua 
treefails hasevery treenext 	isnil lua 
memcpy memcpy 	isboolean lua 
memchr bmexec cwexec 	toboolean 
obstack free 	lua checkoption 
free file copied 	lua pushboolean 
commit gnu 	lua pushstring 
grep git repository 	json arg 
small changes 	init json 
made adapt code 	option 
git kwset 	json integer 
search keywords 	option json 
copyright free software 	integer option 
foundation inc 	json arg 
program free software 	init json 
redistribute modify 	integer 
terms gnu general 	option json 
license published 	arg init 
free software foundation 	json integer 
either version 	option json 
option later version 	arg init 
program distributed 	json 
hope useful without 	integer option 
warranty without 	json arg 
even implied warranty 	init json 
merchantability fitness 	option strbuf 
particular purpose see 	init strbuf 
gnu general 	free 
license details received 	lua error 
copy gnu 	json arg 
general license 	init json 
along program write 	option json 
free software 	verify invalid 
foundation inc franklin 	number 
street fifth 	setting json 
floor boston usa 	arg init 
written august 	json option 
mike haertel author 	json verify 
may reached 	invalid number 
email address mike 	setting 
mit edu 	lua touserdata 
mail mike haertel 	strbuf free 
free software 	lua newuserdata 
foundation algorithm implemented 	lua newtable 
routines bears 	lua pushcfunction 
startling resemblance one 	lua 
discovered beate 	setfield lua 
commentz walter although 	setmetatable strbuf 
identical see 	init strbuf 
matching algorithm 	free lua 
fast average technical 	error lua 
report ibm 	lua 
germany scientific center 	type lua 
heidelberg tiergartenstrasse 	tolstring strbuf 
heidelberg germany see 	ensure empty 
also aho 	length strbuf 
corasick efficient matching 	append strbuf 
aid bibliographic 	append 
search cacm june 	strbuf append 
vol describes 	strbuf append 
failure function used 	lua pushnil 
balanced edges 	lua next 
labels leaving given 	lua type 
trie node 	lua 
left link must 	tonumber floor 
first field 	lua pop 
right link 	lua pop 
larger labels trie 	json encode 
node pointed 	lua checkstack 
edge label edge 	strbuf 
difference depths 	free lua 
subtrees node trie 	error strbuf 
representing reversed 	append strbuf 
keywords word index 	append lua 
accepted word 	rawgeti json 
zero edges leaving 	append 
node parent 	data lua 
node list trie 	pop strbuf 
nodes level 	append lua 
order aho corasick 	tonumber isinf 
failure function 	isnan json 
depth node root 	encode 
shift function 	isnan strbuf 
search failures max 	append mem 
shift self 	isinf isnan 
descendants structure 	strbuf append 
returned opaquely caller 	mem strbuf 
containing everything 	ensure 
obstack node allocation 	empty length 
number words 	fpconv fmt 
trie trie minimum 	strbuf empty 
depth accepting 	ptr strbuf 
node maximum depth 	extend length 
node delta 	strbuf 
table rapid search 	append lua 
table children 	pushnil lua 
root target one 	next strbuf 
used boyer 	append lua 
moore search one 	type strbuf 
character translation 	append 
table allocate initialize 	json append 
keyword returning 	number strbuf 
opaque pointer memory 	append mem 
available upper 	json append 
bound valid 	strbuf append 
bit exact bit 	json 
given contents 	encode json 
keyword success error 	append data 
message otherwise 	lua pop 
descend trie built 	strbuf append 
reversed keywords 	lua type 
character character installing 	json 
nodes necessary 	append json 
descend outgoing links 	append number 
trie node 	lua toboolean 
looking current character 	strbuf append 
keeping track 	mem strbuf 
path followed current 	append 
character doesn 	mem json 
outgoing link trie 	check encode 
node build 	depth lua 
trie node install 	length json 
link current 	append json 
trie node 	append 
install node parent 	strbuf append 
back fixing 	mem lua 
balance flags rebalance 	touserdata strbuf 
pointer rotations 	append mem 
necessary mark node 	json encode 
reached accepting 	json 
encoding index number 	fetch config 
word keyword 	lua argcheck 
far keep track 	lua gettop 
longest shortest 	strbuf init 
keyword enqueue trie 	strbuf reset 
nodes referenced 	json 
given given queue 	append data 
compute aho 	strbuf lua 
corasick failure function 	pushlstring strbuf 
trie nodes 	free hexdigit 
referenced given given 	decode hex 
failure function 	decode 
parent well 	hex codepoint 
last resort failure 	utf strbuf 
node find 	append mem 
chain fails going 	strbuf reset 
back root 	json token 
first node descendant 	error 
current label 	json append 
delta entries links 	unicode escape 
given preexisting 	json token 
delta larger current 	error json 
depth every 	token error 
label compute vector 	strbuf 
indexed character 	append strbuf 
code trie nodes 	ensure strbuf 
referenced given 	strncasecmp strncasecmp 
compute shift trie 	fpconv strtod 
node well 	json token 
delta table 	error 
next cache given 	json token 
keyword initial 	error json 
values delta table 	next token 
changed later 	json invalid 
delta entry given 	number json 
character smallest 	token 
depth node outgoing 	error json 
edge labeled 	next number 
character check use 	token strncmp 
simple boyer 	strncmp strncmp 
moore algorithm instead 	json invalid 
hairy commentz 	number 
walter algorithm looking 	json next 
one extract 	number token 
trie build boyer 	json token 
moore delta 	error strbuf 
boy easy compared 	free lua 
find minimal 	error 
delta shift 	lua checkstack 
might make backwards 	strbuf free 
match failed 	lua error 
traverse nodes trie 	json decode 
level order 	descend lua 
simultaneously computing delta 	newtable 
table failure 	json next 
function shift function 	token json 
enqueue immediate 	decode ascend 
descendants level order 	json parse 
queue update 	error lua 
delta table descendants 	pushlstring 
node compute 	json next 
failure function descendants 	token json 
node update 	parse error 
shifts node current 	json next 
node chain 	token json 
fails back root 	process 
current node 	lua rawset 
outgoing edge 	json next 
fail doesn shift 	token json 
fail larger 	decode ascend 
difference depths current 	json parse 
node accepting 	error 
shift fail descendants 	json next 
larger difference 	token json 
depths traverse trie 	decode descend 
level order 	lua newtable 
fixing nodes whose 	json next 
shift exceeds 	token 
inherited maxshift create 	json decode 
vector indexed 	ascend json 
character code outgoing 	process lua 
links root 	rawseti json 
node fix things 	next token 
translation table 	json 
fast boyer moore 	decode ascend 
search significance 	json parse 
initial offset 	error json 
skip loop bug 	next token 
initial offset 	lua pushlstring 
happens characters left 	lua 
search carefully 	pushnumber lua 
avoid ever producing 	pushboolean json 
bounds pointer 	parse context 
hairy multiple search 	json parse 
initialize copies 	context lua 
look easy ways 	pushlightuserdata 
given known 	json parse 
match find longest 	error lua 
possible match 	argcheck lua 
anchored starting point 	gettop json 
nearly verbatim 	fetch config 
copy preceding main 	lua 
search loops 	checklstring lua 
search given 	error strbuf 
text match member 	json next 
given keyword 	token json 
pointer first character 	process json 
matching substring 	next 
match found foundlen 	token json 
non store 	parse error 
referenced location length 	strbuf free 
matching substring 	lua checkstack 
similarly foundidx non 	lua pushvalue 
store referenced 	lua 
location index number 	pushcclosure lua 
particular keyword 	setfield lua 
matched free components 	pop lua 
given keyword 	argcheck lua 
kwset.h index offset 	gettop lua 
size kwsmatch 	pushvalue 
file copied commit 	lua upvalueindex 
gnu grep 	lua insert 
git repository 	lua pcall 
small changes made 	lua pushnil 
adapt code 	lua insert 
git kwset header 	lua 
declaring keyword 	error fpconv 
library copyright free 	init lua 
software foundation 	newtable json 
inc program free 	create config 
software redistribute 	lua setfuncs 
modify terms gnu 	lua 
general license 	pushlightuserdata lua 
published free software 	setfield lua 
foundation either 	pushliteral lua 
version option later 	setfield lua 
version program 	pushliteral 
distributed hope useful 	lua setfield 
without warranty 	lua cjson 
without even implied 	lua pushcfunction 
warranty merchantability 	lua setfield 
fitness particular 	lua getfield 
purpose see gnu 	lua 
general license 	pushcclosure lua 
details received copy 	setfield lua 
gnu general 	cjson lua 
license along program 	pushvalue lua 
write free 	setglobal lua 
software foundation inc 	cjson 
franklin street 	safe lua 
fifth floor boston 	cjson json 
usa written 	support lua 
august mike haertel 	copyright mark 
author may 	pulford mark 
reached email address 	kyne 
mike mit 	permission hereby 
edu mail mike 	granted free 
haertel free 	charge person 
software foundation index 	obtaining copy 
number matching 	software associated 
keyword offset 	documentation 
submatch length submatch 	files software 
opaque pointer 	deal software 
newly allocated keyword 	without restriction 
enough memory 	including without 
cannot obtained argument 	limitation rights 
non specifies 	use 
table character translations 	copy modify 
applied pattern 	merge publish 
search text incrementally 	distribute sublicense 
extend keyword 	sell copies 
include given success 	software permit 
error message 	persons 
remember index number 	software furnished 
keyword included 	subject following 
keyword completely built 	conditions copyright 
prepare use 	notice permission 
success error 	notice shall 
message search given 	included 
buffer member 	copies substantial 
keyword pointer leftmost 	portions software 
longest match 	software provided 
found match found 	without warranty 
foundlen non 	kind express 
store length matching 	implied 
substring integer 	including limited 
points similarly foundindex 	warranties merchantability 
non store 	fitness particular 
index particular keyword 	purpose noninfringement 
found therein 	shall authors 
deallocate given keyword 	copyright 
associated storage 	holders liable 
levenshtein.c len row 	claim damages 
row row 	liability whether 
dummy strlen alloc 	action contract 
alloc alloc 	tort otherwise 
free free 	arising 
free function damerau 	connection software 
levenshtein algorithm 	use dealings 
calculate distance basically 	software caveats 
says many 	json values 
letters need swapped 	represented lightuserdata 
substituted deleted 	since 
added least idea 	lua tables 
build distance 	cannot contain 
matrix substrings avoid 	nil compare 
large space 	cjson invalid 
complexity last three 	utf characters 
rows kept 	detected 
memory swaps higher 	passed untouched 
cost one 	required utf 
deletion plus one 	error checking 
insertion two 	done outside 
rows would needed 	library javascript 
stage denotes 	comments 
length current 	part json 
substring distance calculated 	spec currently 
row holds 	supported note 
current row row 	decoding slower 
previous row 	encoding lua 
substring length row 	spends 
row words 	significant time 
start big loop 	managing tables 
row contains 	parsing json 
damerau levenshtein distance 	since difficult 
substring length 	know sizes 
substring length big 	ahead 
loop determine 	time workaround 
minimum cost paths 	solaris platforms 
calculating costs 	missing isinf 
path ending characters 	decoding encode 
respectively given 	buf allocated 
last operation substitution 	used 
swap deletion 	encode keep 
insertion implementation 	buffer encode 
allows costs weighted 	temporary storage 
wap substitution 	configuration ensure 
insertion aka deletion 	correct number 
note algorithm 	arguments 
calculates distance iff 	provided pad 
substitution swap 	nil allow 
deletion insertion levenshtein.h 	functions simply 
swap penalty 	check arg 
substitution penalty insertion 	find whether 
penalty deletion 	argument 
penalty line-log.c extra 	provided process 
prealloc dst 	integer options 
src dst src 	configuration functions 
start end 	process enumerated 
diff diff next 	arguments configuration 
list path 	function 
insertion point cmp 	configures handling 
list path 	extremely sparse 
begin end 	arrays convert 
diff start count 	convert extremely 
start count 	sparse arrays 
data parent target 	objects 
cbdata xpp 	otherwise error 
xecfg ecb diff 	ratio always 
diff offset 	allow sparse 
src target parent 	never allow 
diff touched 	sparse use 
touched tmp tmp 	ratio 
revs commit 	safe always 
found obj commit 	use max 
spec mode 	index safe 
sha spec lines 	configures maximum 
line ends 	number nested 
size cur ends 	arrays 
data spec 	objects allowed 
lines line 	encoding configures 
ends data line 	maximum number 
commit prefix 	nested arrays 
args lines ends 	objects allowed 
data item 	encoding 
ranges name part 	configures number 
range part 	precision converting 
full name spec 	doubles text 
end anchor 	configures json 
ret ret prev 	encoding buffer 
src src 	persistence 
cmp revs commit 	init free 
range old 	buffer setting 
revs commit revs 	changed create 
commit ret 	method clean 
rev prefix args 	strbuf decoding 
commit range 	init 
paths dst src 	tag characters 
range keep 	error tokens 
deletions outq 	require processing 
range opt queue 	update characters 
commit parent 	require processing 
line ends data 	inf 
prefix first 	ininity nan 
line ends data 	number lookup 
color reset 	table parsing 
begin end opt 	escape characters 
prefix rev 	error unicode 
range lines lines 	parsing 
ends pair 	required encoding 
diff opt prefix 	json append 
reset frag 	args lua 
meta old context 	state json 
start end 	strbuf lua 
start end cur 	stack 
last rev 	index returns 
range rev pair 	nothing doesn 
range diff 	lua stack 
tmp diff 	worst len 
file parent file 	unicode escapes 
target pair 	buffer 
range rev queue 	reused constantly 
range changed 	small excess 
pairdiff pair rev 	pages won 
commit range 	hit anyway 
rev commit range 	gains speedup 
parent queue 	find 
parent range changed 	size top 
rev commit 	lua stack 
range diffqueues cand 	pure elements 
parents nparents 	table startkey 
changed rev commit 	table key 
range changed 	integer 
commit list free 	must non 
alloc grow 	integer key 
range grow free 	encode excessively 
range init 	sparse arrays 
memcpy range 	objects enabled 
release range grow 	ensure 
range append 	enough slots 
qsort range check 	free traverse 
invariants range 	table key 
grow range append 	push potential 
range append 	error message 
range init range 	unlike 
init range 	decode key 
release range release 	still stack 
memset range 	lua checkstack 
init range release 	called hence 
diff free 	extra slot 
filepair line log 	lua 
data clear 	error required 
free strcmp search 	next check 
line log 	lua checkstack 
data range 	fails won 
append free xcalloc 	cause crash 
range append 	due 
range append range 	extra stack 
append memset 	reserve slots 
memset memset xdi 	would still 
diff ranges 	improper use 
overlap range append 	api json 
range append 	append 
range append xmalloc 	args lua 
diff ranges 	state json 
init diff ranges 	strbuf size 
filter touched 	passwd lua 
range difference range 	top stack 
shift diff 	prevent 
range range release 	encoding invalid 
range release 	numbers encode 
deref tag die 	invalid numbers 
die die 	handle nan 
entry die 	separately since 
fill filespec diff 	platforms 
populate filespec 	may encode 
die sha hex 	nan encode 
alloc alloc 	invalid numbers 
grow realloc skip 	table startkey 
range arg 	table key 
die xstrndup prefix 	never 
path strlen 	returns table 
alloc filespec fill 	key table 
blob sha 	key serialise 
fill line ends 	lua data 
search line 	json remaining 
log data parse 	types 
range arg 	lua tfunction 
die die line 	lua tuserdata 
log data 	lua tthread 
insert free filespec 	lua tlightuserdata 
free sort 	cannot serialised 
merge range 	never 
xmalloc line log 	returns use 
data init 	buffer reuse 
range copy xstrdup 	existing buffer 
line log 	decoding force 
data copy one 	lowercase convert 
line log 	ascii 
data copy one 	hex digit 
strcmp xmalloc 	numeric digit 
line log data 	note returns 
init xstrdup 	error invalid 
range range copy 	hex digits 
lookup decoration 	including 
line log data 	converts unicode 
merge free 	codepoint utf 
line log data 	returns utf 
line log 	length bytes 
data copy decoration 	utf xxxxxxx 
lookup decoration 	xxxxx 
free line 	xxxxxx xxxx 
log data decoration 	xxxxxx xxxxxx 
lookup decoration 	xxx xxxxxx 
range check invariants 	xxxxxx xxxxxx 
check single 	called index 
commit parse lines 	pointing 
line range 	beginning utf 
argv push argv 	code escape 
detach parse 	xxxx guaranteed 
pathspec free memcpy 	exist remaining 
diff queue 	hex characters 
clear diff queue 	may 
clear diff 	missing translate 
file valid diff 	utf append 
diff free 	temporary token 
filepair strcmp diff 	must advance 
diff free 	index next 
filepair free 	character 
diff file valid 	processed returns 
diff queue 	success error 
clear diff sha 	surrogate pairs 
filter diffs 	require utf 
paths diff might 	bytes fetch 
rename diffcore 	utf 
std filter diffs 	code unit 
paths move 	utf surrogate 
diff queue nth 	pairs take 
line nth 	following form 
line fputs fputs 	yyyyyyyyyy high 
putchar fwrite 	bits 
fputs putchar fputs 	codepoint low 
output prefix 	bits codepoint 
output prefix diff 	check surrogate 
color diff 	pair high 
color diff color 	low error 
diff color 	surrogate 
diff color 	high ensure 
diff color fill 	next code 
line ends 	unicode escape 
fill line ends 	fetch next 
print line 	codepoint error 
print line print 	code 
line print 	low surrogate 
line free free 	calculate unicode 
puts output 	codepoint convert 
prefix dump diff 	codepoint utf 
hacky one 	append bytes 
strcmp diff populate 	advance 
filespec diff 	parse index 
populate filespec diff 	caller must 
ranges init 	ensure next 
collect diff die 	skip json 
free xstrdup 	tmp temporary 
range init range 	strbuf 
map across 	used accumulate 
diff range 	decoded json 
release range move 	tmp sized 
diff ranges 	handle json 
release xmalloc diff 	containing premature 
free filepair 	end 
free line log 	handle escapes 
data copy 	fetch escape 
process diff filepair 	character translate 
strcmp diff 	escape code 
filepair dup memcpy 	append tmp 
free lookup 	skip 
line range show 	append normal 
log dump 	character translated 
diff hacky queue 	single character 
diffs process 	unicode escapes 
files line range 	handled eat 
commit list 	quote 
count alloc alloc 	json numbers 
alloc queue 	take following 
diffs process 	form json 
files line range 	next number 
clear commit 	token uses 
line range commit 	strtod 
list append 	allows forms 
free free free 	numbers starting 
diffqueues line 	infinity infinity 
range clear commit 	hexadecimal numbers 
line range 	numbers leading 
free free free 	zeros 
diffqueues lookup 	json invalid 
line range process 	number detects 
ranges ordinary 	numbers may 
commit process ranges 	pass strtod 
merge commit 	error checking 
process ranges arbitrary 	allowed 
commit free 	strict json 
rewrite parents either 	json invalid 
initialization would 	number may 
fine dst 	pass numbers 
must uninitialized tack 	cause strtod 
range end 	generate 
could simply start 	error reject 
start types 	numbers starting 
check ranges non 	skip minus 
empty sorted 	sign exists 
non overlapping place 	reject numbers 
pass sorting 	starting 
merging ranges range 	leading zeros 
establish invariants 	hex leading 
ranges user output 	zero ordinary 
cursor range 	number reject 
sets sets line 	inf nan 
numbers used 	pass 
merge searches meet 	numbers may 
common ancestor 	still invalid 
also ranges 	strtod skip 
consolidated canonical form 	processed number 
overlapping adjacent 	fills token 
ranges merged empty 	pointer 
ranges removed 	json parse 
cannot make ranges 	temporary error 
may change 	json ptr 
grow exhausted exhausted 	pointer error 
empty range 	eat whitespace 
difference range sets 	store 
pass interesting 	location token 
ranges target side 	required throwing 
diff removes 	errors unexpected 
ranges commit responsible 	tokens syntax 
exhausted note 	errors advance 
takes ownership path 	pointer 
happens caller 	error end 
needs handy debugging 	found known 
removing silences 	single character 
unused function 	token advance 
warning given diff 	index process 
interesting ranges 	characters 
determine hunks diff 	triggered unknown 
touch overlap 	must use 
least one interesting 	strncmp match 
ranges target 	front json 
adjust line counts 	json must 
account lines 	lowercase 
added removed diff 	strict numbers 
given diff 	disabled either 
interesting ranges map 	allowed infinity 
ranges across 	since longer 
diff observe target 	following spec 
commit takes 	decode 
blame target side 	invalid numbers 
ranges every 	enabled attempt 
pair ranges diff 	process numbers 
touched latter 	know invalid 
parent side 	json inf 
shrink fit elements 	hex 
merge two 	required generate 
range sets across 	appropriate token 
files owned 	error otherwise 
pathspec stderr diff 	bad tokens 
might rename 	invalid number 
found creation diff 	token 
queued diff 	starts isn 
queue two path 	recognised function 
scan ahead 	call memory 
determine last diff 	allocated supported 
falls range 	temporary parser 
compute parent hunk 	json 
headers know 	tmp json 
diff correct line 	token exist 
numbers hunks 	stack somewhere 
suffices shift start 	lua error 
end according 	jmp release 
line numbers 	stack 
first last hunk 	note token 
fall range 	index display 
output diff hunk 	starting slots 
range needswork 	required table 
manually building diff 	key 
right thing 	handle empty 
log built diff 	objects push 
pipeline unlike 	key fetch 
functions destructively operates 	key handle 
range needswork 	context slots 
apply heuristics prevent 	required 
mismatches store 	table handle 
away diff later 	empty arrays 
output tuck 	arr handle 
ranges got input 	context lua 
since commit 	setting nil 
caused diff 	table 
needswork enough around 	hence pointer 
something interesting 	lightuserdata used 
merges currently invocation 	instead detect 
merge parent 	unicode utf 
trashes previous one 	see rfc 
diff needswork 	sec 
tramples data structures 	cjson support 
owned parent 	simple data 
take blame follow 	type hence 
path history 	first character 
needswork leaking like 	guaranteed ascii 
sieve single 	worst 
parent took blame 	still enough 
candidates loop 	detect whether 
parents needswork evil 	wrong encoding 
merge detection 	use ensure 
stuff needswork leaking 	temporary buffer 
like sieve 	hold 
line-log.h start 	entire means 
end alloc ranges 	longer need 
parent target 	length checks 
range prealloc range 	since decoded 
range start 	must smaller 
end range start 	entire 
end range 	json ensure 
next path status 	input left 
ranges arg 	initialisation compatibility 
alloc arg args 	lua lua 
pair diff 	setfuncs used 
rev prefix args 	create 
rev rev 	module table 
commit range start 	functions json 
end lines 	config first 
numbered starting ranges 	upvalue code 
include start 	borrowed lua 
exclude end ranges 	source 
ranges must 	fill table 
always disjoint 	given functions 
sorted diff encoded 	copy upvalues 
pre post 	top closure 
image ranges files 	upvalues upvalues 
differ pair 	call 
ranges corresponds hunk 	target function 
range includes 	mode supplied 
start excludes end 	args assumes 
range must 	target function 
begin end last 	returns single 
added range 	non 
place pass sorting 	nil convert 
merging ranges 	thrown errors 
range sort make 	nil error 
ranges disjoint 	message deliberately 
linked list interesting 	error invalid 
files associated 	arguments 
ranges list must 	pcall function 
kept sorted 	stored upvalue 
path simplicity 	since custom 
even though highly 	error handler 
redundant line 	remaining errors 
log data owns 	memory 
path line 	related cjson 
log line-range.c spec 	module table 
nth line 	initialise number 
data lines begin 	conversions cjson 
ret term 	module table 
line num reg 	functions 
error regexp 	config data 
match nline errbuf 	upvalue cjson 
xecfg bol 	module name 
eol buf xecfg 	version fields 
start regexp 	cjson safe 
reg error match 	module 
bol eol 	table fix 
errbuf arg 	method cjson 
nth line data 	table cjson 
lines anchor 	table cjson 
begin end path 	safe table 
pattern term 	lua 
drv xecfg start 	cmsgpackc ptr 
reg error 	len aux 
regexp errbuf bol 	test testp 
eol arg 	target osize 
nth line data 	nsize buf 
lines anchor 	buf 
begin end path 	len newsize 
tmp arg 	buf cursor 
strtol die strtol 	len buf 
die nth 	len hdr 
line regcomp regexec 	hdrlen buf 
nth line 	buf 
regfree regerror die 	enclen buf 
find func 	enclen buf 
isalpha regexec 	enclen buf 
regerror die match 	len buf 
funcname xstrndup 	buf buf 
nth line userdiff 	buf 
find path 	level buf 
xcalloc xdiff find 	level buf 
func regcomp 	level len 
regerror die find 	max stacktop 
funcname matching 	buf level 
regexp die nth 	buf 
line die 	buf level 
nth line nth 	nargs buf 
line match 	len index 
funcname regfree free 	len limit 
free parse 	offset len 
range funcname parse 	cnt 
loc parse 	decode offset 
loc parse range 	offset limit 
funcname parse 	offset argc 
loc parse 	err total 
loc parse one 	results cmds 
item option 	lua 
begin applicable relative 	getallocf local 
range anchors 	realloc realloc 
absolute anchors ignore 	realloc memcpy 
parsing parse 	realloc realloc 
loc called parsing 	buf append 
begin must 	buf 
negative number absolute 	append memcpy 
line relative 	memrevifle buf 
start range anchors 	append memcpy 
beginning file 	memrevifle buf 
represented parsing begin 	append buf 
must positive 	append 
line number immediately 	buf append 
following line 	buf append 
computed allow something 	lua tolstring 
mean starting 	encode bytes 
something lines 	lua toboolean 
something lines ending 	buf 
something could 	append lua 
regexp form scan 	tonumber lua 
interested regex 	tointeger encode 
spec term regexp 	lua tonumber 
input human 	equivalent encode 
terms determine extent 	lua 
line matched 	integer encode 
funcname line skip 	lua objlen 
range arg 	lua rawlen 
input human terms 	encode lua 
compensate numbering 	pushnumber lua 
line-range.h arg nth 	gettable 
line data 	encode lua 
lines anchor begin 	type lua 
end path 	pushnil lua 
arg parse one 	next lua 
item begin 	pop encode 
end option 	map 
notional file data 	lua pushnil 
consisting lines 	lua next 
lines nth line 	lua pushvalue 
callback used 	encode lua 
determine start line 	type encode 
lno inside 	lua 
data caller expected 	type lua 
already suitable 	gettop lua 
map hand make 	pushnil lua 
constant time 	next lua 
lookup anchor line 	pop lua 
relative range 	type 
specifications anchored absolute 	lua tonumber 
ranges unaffected 	equivalent lua 
returns success error 	isinteger lua 
actual range 	tointeger lua 
stored begin 	settop lua 
end counting starts 	settop 
error caller 	table encode 
show usage message 	lua table 
scan past 	encode lua 
range argument could 	table map 
parsed parse 	buf append 
range arg help 	lua 
caller determine 	type encode 
start filename file 	lua encode 
syntax returns 	lua encode 
pointer first character 	lua number 
part argument 	lua isinteger 
obviously malformed line 	encode 
range line 	lua integer 
bufferc buf filename 	encode lua 
buf buf 	number encode 
buf err buf 	lua table 
buf pos 	encode lua 
buf buf 	lua 
buf end buf 	pop lua 
size buf 	gettop lua 
nbytes buffer done 	argerror buf 
len buf 	lua pushvalue 
nbytes buffer done 	encode lua 
len fopen 	type 
fdopen tmpfile ferror 	lua pushlstring 
ferror fclose 	buf free 
rewind ftell error 	lua concat 
strerror fseek 	lua newtable 
error strerror ferror 	lua pushnumber 
fgetc fgets 	decode 
strlen feof strbuf 	lua type 
fread feof 	lua settable 
ferror fread fwrite 	lua newtable 
ferror buffer 	decode lua 
skip bytes feof 	type decode 
ferror fread 	lua 
licensed two 	type lua 
clause bsd style 	settable cur 
license see 	need lua 
license details read 	checkstack cur 
line without 	need lua 
trailing newline error 	pushunsigned 
data exhausted 	cur consume 
newline end file 	cur need 
fine line 	lua pushinteger 
probably saner way 	cur consume 
deal error 	cur need 
line bufferh line 	lua 
buffer infile 	pushunsigned cur 
buf filename buf 	consume cur 
buf buf 	need lua 
buf buf buf 	pushinteger cur 
buf buf 	consume cur 
buf len buf 	need 
len buf 	lua pushunsigned 
len prepare 	cur consume 
write returns number 	cur need 
bytes read 	lua pushinteger 
necessarily written list-objects.c 	cur consume 
revs blob 	cur 
show path name 	need lua 
data obj 	pushunsigned cur 
pathlen revs sha 	consume cur 
show path 	need lua 
name data revs 	pushnumber lua 
show name 	pushinteger 
data obj desc 	cur consume 
entry baselen 	lua pushnil 
commit revs show 	cur consume 
edge parents 	lua pushboolean 
parent revs show 	cur consume 
edge list 	lua 
commit obj 	pushboolean cur 
commit revs revs 	consume cur 
show commit 	need cur 
show data commit 	need memcpy 
pending obj 	memrevifle lua 
name path die 	pushnumber 
strbuf addstr 	cur consume 
show strbuf setlen 	cur need 
die parse 	cur need 
gently die oid 	lua pushlstring 
hex strbuf 	cur consume 
addstr show strbuf 	cur 
addch init 	need cur 
desc entry entry 	need lua 
interesting isdir 	pushlstring cur 
process lookup isgitlink 	consume cur 
process gitlink 	need cur 
process blob lookup 	consume 
blob strbuf 	cur need 
setlen free 	lua pushlstring 
buffer mark uninteresting 	cur consume 
show edge 	cur need 
mark uninteresting show 	cur consume 
edge mark 	decode 
edge parents uninteresting 	lua cur 
mark uninteresting 	need cur 
show edge pending 	consume decode 
strbuf init 	lua cur 
revision pending show 	need cur 
commit show 	consume 
process process blob 	decode lua 
die oid 	hash cur 
hex clear strbuf 	need cur 
release processing 	consume decode 
gitlink entry currently 	lua hash 
nothing since 	lua 
recurse subproject could 	pushunsigned cur 
eventually flag 	consume lua 
actually would 	pushinteger cur 
involve subproject actually 	consume cur 
see subproject 	need lua 
already added alternates 	pushlstring 
list process 	cur consume 
commit tag gitlink 	cur consume 
points recursively 	decode lua 
however unclear whether 	cur consume 
really ever 	decode lua 
reason see superprojects 	hash 
subprojects unified 	lua checklstring 
pool potentially resulting 	lua error 
totally humongous 	lua error 
pack avoiding whole 	cur init 
point gitlinks 	decode lua 
first place note 	type 
could follow 	lua error 
link whether necessarily 	lua error 
makes sense 	lua pushinteger 
ever ever 	lua insert 
another issue nothing 	unpack full 
uninteresting boundary 	lua 
commit may parsed 	optinteger lua 
yet going 	pop lua 
show anyway list-objects.h 	gettop unpack 
rev info 	full lua 
rev info ll-merge.c 	checkinteger lua 
name description 	optinteger 
recursive next cmdline 	lua pop 
drv unused 	lua gettop 
result path orig 	unpack full 
orig name 	lua gettop 
src name src 	lua pushvalue 
name opts 	lua 
marker size stolen 	upvalueindex lua 
drv unused 	insert lua 
result path 	pcall lua 
orig orig name 	gettop lua 
src name 	pushnil lua 
src name opts 	insert 
marker size 	lua newtable 
xmp drv unused 	lua pushcfunction 
result path 	lua setfield 
unused orig orig 	lua pushliteral 
name src 	lua setfield 
name src name 	lua 
opts marker 	pushliteral lua 
size merge drv 	setfield lua 
src path 	pushliteral lua 
len result path 	setfield lua 
orig orig 	pushliteral lua 
name src name 	setfield 
src name 	luaopen create 
opts marker size 	lua pushvalue 
temp cmd 	lua setglobal 
dict path 	luaopen cmsgpack 
args status user 	lua getfield 
merge user 	lua 
merge tail merge 	pushcclosure lua 
key name 	setfield lua 
namelen merge attr 	pushvalue lua 
name path 	setglobal allows 
check path strbuf 	preprocessor directive 
result buf 	max 
path ancestor ancestor 	nesting max 
label label 	tables nesting 
label opts check 	check integer 
opts driver 	without loss 
name marker size 	precision size 
driver path 	pointer 
check marker size 	equal integer 
warning buffer 	bits message 
binary buffer binary 	pack implementation 
buffer binary 	bindings lua 
binary merge 	copyright salvatore 
memset xdl merge 	sanfilippo 
xdl merge 	antirez gmail 
xsnprintf xmkstemp write 	http github 
full die 	antirez lua 
errno close quote 	cmsgpack message 
buf die 	pack specification 
create temp create 	check 
temp create 	following web 
temp xsnprintf strbuf 	site http 
expand run 	wiki msgpack 
command opt open 	display msgpack 
fstat xmallocz 	format specification 
read full free 	see 
close unlink 	copyright notice 
warn strbuf release 	end file 
strbuf release 	changelog feb 
strcmp git config 	ver initial 
parse config 	release feb 
key strncmp 	ver 
xcalloc xmemdupz strcmp 	tables encoding 
git config 	improved feb 
strcmp error xstrdup 	ver minor 
strcmp git 	bug fixing 
config git config 	feb ver 
initialize merge 	module 
attr attr attr 	renamed lua 
unset strcmp 	cmsgpack lua 
size strcmp git 	msgpack apr 
attr git 	ver lua 
attr git check 	support minor 
attr renormalize 	bug 
buffer free strbuf 	fix apr 
detach normalize 	ver multiple 
file normalize file 	pack unpack 
normalize file 	lua allocator 
git path check 	efficiency endian 
merge atoi 	conversion 
find merge 	use floats 
driver find merge 	doubles conversions 
driver git 	performed endian 
attr git check 	independent fashion 
attr atoi 	thing need 
low level way 	function 
core file 	swaps binary 
merge copyright junio 	arch little 
hamano built 	endian left 
low levels tentative 	untouched otherwise 
merge result 	reverse memory 
common ancestor merge 	bytes 
fallthru xtheirs 	arch little 
xours cleanly merged 	endian given 
otherwise got 	conceptual simplicity 
conflict use favor 	lua build 
user defined 	system prefer 
low level 	check 
merge driver support 	endianess runtime 
merge merge 	performance difference 
driver configuration items 	acceptable big 
interested anything 	endian nothing 
merge name variable 	buffer simple 
especially want 	implementation 
look variables merge 	buffers operation 
summary merge 	supported creating 
tool merge verbosity 	empty buffers 
find existing 	appending bytes 
one might processing 	buffer uses 
merge name 	preallocation 
seeing merge name 	every realloc 
merge name 	append behavior 
driver specifies command 	old size 
line command 	size buf 
line command line 	realloc 
interpolated following 	free cursor 
tokens given 	simple data 
shell temporary file 	structure used 
name merge 	parsing basically 
temporary file name 	create cursor 
version temporary 	pointer 
file name branches 	length possible 
version conflict 	access current 
marker length original 	position cursor 
path safely 	check remaining 
quoted shell external 	length cursor 
merge driver 	left 
write results file 	consume cur 
named signal 	consume cursor 
done zero exit 	len advance 
status way 	subtract left 
ll-merge.h xdl opts 	additional field 
result buf 	cursor 
path ancestor ancestor 	error zero 
label label 	initialization used 
label opts 	report errors 
path low level 	enough data 
way core 	complete operation 
file merge favor 	bad 
favor merge 	data format 
lockfile.c path path 	enough room 
depth link 	error cursor 
path flags filename 	common across 
path flags 	code macro 
timeout multiplier remaining 	make 
random initialized 	code look 
backoff wait path 	bit simpler 
err buf 	low level 
path err buf 	encoding fix 
path flags 	raw ieee 
timeout ret result 	format 
path save 	single precision 
errno strbuf setlen 	floats ieee 
strbuf readlink 	ieee positive 
absolute path 	fixnum negative 
strbuf reset trim 	fixnum fix 
last path 	fix 
component strbuf addbuf 	map map 
strbuf reset 	map lua 
strbuf addstr resolve 	types encoding 
symlink strbuf 	lua built 
addstr create tempfile 	bit integer 
strbuf release 	type 
file srand getpid 	lua lower 
file rand 	bit doubles 
sleep millisec strbuf 	need detect 
addf absolute 	may representable 
path strerror strbuf 	lua convert 
addf absolute 	lua 
path strerror unable 	table message 
message die 	pack list 
file timeout 	convert lua 
unable die strbuf 	table message 
addstr tempfile 	pack key 
path strcmp die 	map 
strbuf setlen 	first step 
strbuf detach locked 	count keys 
file path 	table way 
commit file free 	lua api 
free copyright 	need iterate 
junio hamano path 	first 
absolute relative 	time note 
path name last 	alternative would 
path name 	single run 
element path leaving 	hack buffer 
preceding path 	insert map 
empty root directory 	opcodes 
path empty 	message pack 
back past trailing 	hackish lib 
slashes backwards 	keep key 
slash beginning 	next iteration 
allow recursive symbolic 	step two 
links within 	actually 
reason though path 	encoding map 
contains path 	stack key 
might symlink path 	stack key 
symlink attempt 	key encode 
overwrite path real 	key encode 
file directory 	val 
may may exist 	returns lua 
following chain 	table top 
symlinks necessary otherwise 	stack exclusively 
path unmodified 	composed keys 
best effort routine 	numerical keys 
error occurs 	total 
path either left 	number elements 
unmodified name 	without hole 
different symlink symlink 	middle stack 
chain started 	top function 
original path 	entry stack 
absolute path simply 	key 
replaces link 	stack key 
relative path replace 	check valid 
last element 	comparing indexes 
make sure errno 	total number 
contains meaningful 	elements count 
error constants defining 	also 
gaps attempts 	max index 
file first backoff 	encountered max 
period approximately 	reach code 
initial backoff milliseconds 	indexes also 
longest backoff 	note repeated 
period approximately backoff 	keys 
max multiplier 	table max 
initial backoff milliseconds 	count sure 
locking path 	keys form 
retrying quadratic backoff 	count included 
least timeout 	length returns 
milliseconds timeout 	non 
locking file exactly 	zero least 
timeout indefinitely 	key serialize 
success failure held 	message pack 
failure due 	list otherwise 
timeout back backoff 	use map 
backoff recursion 	limit 
meaningful errno failure 	encoding nested 
lockfile.h tempfile 	tables specified 
path flags timeout 	maximum depth 
path flags 	survive called 
path err buf 	circular references 
path err 	tables 
mode path hold 	packs arguments 
file update 	stream multiple 
timeout fdopen tempfile 	upacking later 
tempfile path 	returns error 
tempfile tempfile 	arguments provided 
close tempfile reopen 	copy 
tempfile rename 	argument top 
tempfile tempfile file 	stack encode 
write locks 	processing encode 
used git lockfile 	function pops 
api serves 	stack complete 
two purposes mutual 	reuse 
exclusion atomic 	buffer next 
file updates want 	operation setting 
change file 	free count 
create lockfile filename 	total buffer 
write file 	size current 
contents rename lockfile 	position 
destination filename 	zero concatenate 
create filename file 	nargs buffers 
creat excl 	together decoding 
notice fail somebody 	key decode 
already locked 	message pack 
file atomically 	raw 
rename lockfile destination 	pointed cursor 
commit changes 	lua type 
unlock file automatic 	left result 
cruft removal 	stack elements 
program exits file 	must resize 
changes committed 	stack 
want make sure 	fit values 
lockfile done 	way determine 
remembering lockfiles created 	many objects 
linked list 	msgpack unpack 
setting atexit handler 	front request 
signal handler 	larger 
clean lockfiles mechanism 	stack iteration 
ensures outstanding 	stack big 
lockfiles cleaned program 	enough stack 
exits including 	require resize 
die called program 	doubles size 
terminated signal 	nil 
please note 	raw raw 
lockfiles block writers 	raw map 
readers block 	map types 
guaranteed see either 	idenitified first 
old contents 	positive fixnum 
file contents file 	negative 
assuming filesystem 	fixnum fix 
rename atomically heavy 	raw fix 
lifting done 	map fix 
tempfile module see 	map number 
tempfile calling 	objects unpacked 
sequence caller allocates 	match 
file either 	exits requesting 
variable heap initialized 	negative lim 
zeros use 	invalid loop 
structure call hold 	decode could 
file family 	stream multiple 
functions belongs lockfile 	top 
subsystem storage 	level values 
must remain 	serialized together 
valid throughout life 	left remaining 
program cannot 	size input 
use stack variable 	buffer subtract 
hold structure 	entire 
attempts create lockfile 	buffer size 
calling hold 	unprocessed size 
file update writes 	next start 
content destination 	offset offset 
file either writing 	processed entire 
file descriptor 	buffer 
returned hold file 	results returned 
functions also 	arg elements 
available via calling 	still place 
fdopen file 	lua takes 
file pointer open 	care returning 
file writing 	elements 
file stdio finished 	args one 
writing caller 	arg stack 
close file 	function insert 
descriptor rename lockfile 	first position 
destination calling 	increase count 
commit file commit 	one 
file close 	make room 
file descriptor lockfile 	offset variable 
calling rollback 	pop offset 
file close file 	may exist 
descriptor without 	variable pop 
removing renaming lockfile 	offset 
calling close 	may exist 
file later call 	adds function 
commit file 	bottom stack 
commit file rollback 	call function 
file reopen 	position manually 
file even lockfile 	construct 
committed rolled 	module table 
back file 	instead relying 
must freed altered 	newlib metadata 
caller however 	name globally 
may reused pass 	wrap functions 
another call 	safe 
hold file update 	handler name 
program exits 	globally copyright 
commit file commit 	salvatore sanfilippo 
file rollback 	rights reserved 
file called tempfile 	permission hereby 
module close 	granted 
lockfile thereby rolling 	free charge 
back uncommitted 	person obtaining 
changes need close 	copy software 
file descriptor 	associated documentation 
obtained hold file 	files software 
function calling 	deal 
close file see 	software without 
tempfile information 	restriction including 
covers lockfile 	without limitation 
tempfile helper functions 	rights use 
particular state 	copy modify 
diagram cleanup machinery 	merge 
implemented tempfile 	publish distribute 
module error handling 	sublicense sell 
hold file 	copies software 
functions file descriptor 	permit persons 
success failure 	software furnished 
unless die error 	subject 
used see 	following conditions 
flags errors errno 	copyright notice 
describes reason 	permission notice 
failure errors reported 	shall included 
passing errno 	copies substantial 
unable message unable 	portions 
die similarly 	software software 
commit file commit 	provided without 
file close 	warranty kind 
file success 	express implied 
failure errno appropriately 	including limited 
best roll 	warranties 
back lockfile appended 	merchantability fitness 
filename derive 	particular purpose 
lockfile name flags 	noninfringement shall 
following flags 	authors copyright 
passed hold file 	holders liable 
update already 	claim 
taken file die 	damages liability 
error message 	whether action 
flag specified trying 	contract tort 
file already 	otherwise arising 
locked returns caller 	connection software 
usually symbolic 	use 
links destination path 	dealings software 
resolved means 	lua structc 
lockfile created adding 	dummy endian 
resolved path 	fmt opt 
upon commit 	fmt len 
resolved path overwritten 	opt 
however deref 	size opt 
lockfile created adding 	fmt msg 
path argument 	arg endian 
option used example 	size buff 
detaching symbolic 	size endian 
reference backwards compatibility 	temp 
reasons symbolic 	fmt arg 
link containing name 	totalsize opt 
referred reference 	size toalign 
attempt create lockfile 	buff endian 
file path 	issigned size 
file descriptor writing 	mask 
error file 	fmt data 
currently locked retry 	pos opt 
quadratic backoff 	size issigned 
least timeout 	res fmt 
milliseconds timeout exactly 	pos opt 
timeout retry 	size 
indefinitely flags argument 	thislib isdigit 
error handling 	isdigit lua 
described attempt create 	error getnum 
lockfile file 	getnum lua 
path file descriptor 	error getnum 
writing error 	isp 
flags argument error 	lua error 
handling described 	lua pushfstring 
append appropriate error 	lua argerror 
message buf 	lua checknumber 
following failure hold 	lua addlstring 
file update 	lua 
path err errno 	checkstring defaultoptions 
failing call 	lua pushnil 
emit appropriate error 	lua buffinit 
message die 	optsize gettoalign 
following failure 	lua addchar 
hold file update 	putinteger 
path err 	lua addchar 
errno failing call 	lua checknumber 
associate stdio 	correctbytes lua 
stream lockfile must 	addlstring lua 
still open 	checknumber correctbytes 
without rolling back 	lua 
lockfile error 	addlstring lua 
stream closed automatically 	checklstring lua 
close file 	argcheck lua 
called file committed 	addlstring lua 
rolled back 	addchar controloptions 
path lockfile pointer 	lua 
field within 	pushresult uinttype 
file freed path 	lua checkstring 
file locked 	lua checklstring 
specified file caller 	lua optinteger 
must free 	defaultoptions lua 
memory lockfile 	settop 
still open close 	optsize gettoalign 
file pointer 	lua argcheck 
opened fdopen file 	lua checkstack 
without renaming 	islower getinteger 
lockfile file locked 	lua pushnumber 
upon success 	memcpy 
failure close negative 	correctbytes lua 
roll back 	pushnumber memcpy 
file usually commit 	correctbytes lua 
file commit 	pushnumber lua 
file rollback file 	isnumber lua 
eventually called 	error 
close file succeeds 	lua tonumber 
open lockfile 	lua pop 
closed close file 	lua argcheck 
yet committed 	lua pushlstring 
rolled back used 	memchr lua 
implement sequence 	error 
operations like 	lua pushlstring 
following file write 	controloptions lua 
contents lockfile 	pushinteger lua 
close file cause 	gettop lua 
contents written 	checkstring defaultoptions 
disk pass name 	optsize 
lockfile another 	gettoalign lua 
program allow nobody 	argerror lua 
inspect contents 	argerror isalnum 
wrote still holding 	controloptions lua 
reopen file 	pushinteger lua 
reopen lockfile make 	library 
updates contents 	packing unpacking 
commit file make 	structures roberto 
version permanent 	exp see 
commit change represented 	copyright notice 
close file 	end file 
descriptor file 	valid 
pointer still open 	formats big 
rename lockfile 	endian little 
destination upon success 	endian num 
failure roll 	alignment pading 
back file errno 	size integer 
failing call 	size 
close rename bug 	size sequence 
call commit 	chars packing 
file file currently 	means whole 
locked like 	unpacking means 
commit file rename 	use previous 
lockfile provided 	read 
path path must 	number length 
filesystem file 	zero terminated 
roll back close 	ignored basic 
file descriptor 	integer type 
file pointer lockfile 	corresponding version 
call rollback 	maximum 
file file 	size bytes 
already committed rolled 	integral types 
back lockfile 	power dummy 
log-tree.c name decoration 	structure alignment 
decoration loaded 	requirements endian 
decoration flags decoration 	options 
colors decorate 	number cases 
color slot slot 	need alignment 
name slot 	number bytes 
name decoration obj 	needed align 
refname oid 	element size 
flags data obj 	size 
original oid 	current position 
graft data commit 	len respect 
flags commit 	max alignment 
abbrev parent opt 	options control 
commit abbrev 	endianess alignment 
decoration list head 	ignore 
branch name 	white spaces 
unused rru 	mark separate 
flags decoration commit 	arguments buffer 
use color 	integer types 
prefix separator suffix 	zero end 
decoration current 	format 
head color commit 	negative signal 
color reset 	extension integer 
opt commit number 	types copyright 
result filename 	lua puc 
subject info suffix 	rio rights 
start len 	reserved 
max len filename 	permission hereby 
commit info 	granted free 
ctx subject opt 	charge person 
commit subject 	obtaining copy 
extra headers need 	software associated 
bit cte 	documentation 
subject extra headers 	files software 
name buffer 	deal software 
buffer subject 	without restriction 
buffer buffer filename 	including without 
opt status 	limitation 
bol color reset 	rights use 
eol opt 	copy modify 
commit payload signature 	merge publish 
gpg output 	distribute sublicense 
status sha commit 	sell copies 
nth parent 	software 
commit commit extra 	permit persons 
data opt 	software furnished 
sha tag verify 	subject following 
message status 	conditions copyright 
nth payload size 	notice permission 
gpg message 	notice 
offset opt commit 	shall included 
opt msgbuf 	copies substantial 
log parent abbrev 	portions software 
commit extra 	software provided 
headers ctx 	without warranty 
raw notebuf opt 	kind 
saved fmt 	express implied 
pch msg opt 	including limited 
commit opt 	warranties merchantability 
commit log showed 	fitness particular 
log parents 	purpose noninfringement 
oid parent opt 	shall 
commit log 	authors copyright 
shown strcasecmp strcasecmp 	holders liable 
strcasecmp strcasecmp 	claim damages 
strcasecmp parse decorate 	liability whether 
color slot 	action contract 
config error nonbool 	tort 
color parse 	otherwise arising 
lookup decoration starts 	connection software 
oid hex 	use dealings 
strlen warning 	software lundump.c 
parse name decoration 	size size 
parse starts 	buff 
starts starts strcmp 	name lua 
strcmp name 	pushfstring lua 
decoration parse name 	lua read 
decoration lookup 	load load 
commit name decoration 	load load 
head commit 	lua 
graft find unique 	openspace load 
abbrev lookup 	block lua 
decoration find unique 	newlstr load 
abbrev resolve 	lua newvector 
starts strcmp strbuf 	load vector 
addstr prettify 	load 
refname strbuf addstr 	lua newvector 
diff color 	setnilvalue load 
decorate color name 	setnilvalue setbvalue 
decoration current 	load setnvalue 
pointed head 	load number 
strbuf addstr strbuf 	setsvalue 
addstr strbuf 	load error 
addstr strbuf addstr 	load lua 
decorate color 	newvector load 
strbuf addstr show 	function load 
name strbuf 	lua newvector 
addstr strbuf addstr 	load 
strbuf addstr 	vector load 
strbuf addstr strbuf 	lua newvector 
addstr decorate 	load load 
color show name 	load load 
strbuf addstr 	lua newvector 
strbuf addstr strbuf 	load 
addstr strbuf 	error lua 
addstr format decorations 	newproto setptvalue 
fputs strbuf 	incr top 
release strlen strbuf 	load load 
addf strbuf 	load load 
addf strbuf 	load 
setlen strbuf addstr 	load load 
format commit 	load code 
message fmt output 	load constants 
subject strbuf 	load debug 
release oid hex 	lua checkcode 
snprintf digits 	lua 
number snprintf graph 	header load 
show oneline 	block memcmp 
graph show oneline 	load header 
graph show 	load function 
oneline snprintf strbuf 	lua newliteral 
addf fmt 	memcpy 
output commit snprintf 	lundump roberto 
strbuf release 	exp load 
diff color opt 	precompiled lua 
diff color 	chunks see 
opt strchrnul graph 	copyright notice 
show oneline 	lua 
parse commit 	trailing load 
verify buffer strbuf 	precompiled chunk 
addstr show 	make header 
sig lines strbuf 	endianness lua 
release strbuf 	number integral 
release strbuf release 	lundump.h 
hashcmp hash 	buff name 
sha file lookup 	data strip 
tag strbuf 	full lundump 
init parse tag 	roberto exp 
buffer strbuf 	load precompiled 
addstr common merge 	lua 
oidcmp strbuf 	chunks see 
addf parent strbuf 	copyright notice 
addf strbuf 	lua load 
addf parse signature 	one chunk 
verify buffer 	lundump make 
strbuf addstr 	header 
show sig lines 	lundump dump 
strbuf release 	one chunk 
mergetag graph show 	ldump print 
commit put 	one chunk 
revision mark fputs 	print header 
find unique 	binary 
abbrev show parents 	files lua 
show children 	header binary 
show decorations graph 	files official 
commit finished 	format size 
putchar graph show 	header binary 
remainder putchar 	files 
graph show padding 	lvm.c obj 
putchar graph 	num obj 
show commit log 	mask oldpc 
write email 	npc newline 
headers fputs diff 	res result 
color opt 	key 
fputs put 	val loop 
revision mark fputs 	res key 
find unique 	val loop 
abbrev show parents 	temp oldval 
show children 	res temp 
find unique abbrev 	len 
fputs diff 	res res 
color opt show 	total last 
decorations putchar 	top buffer 
putchar graph show 	tempb tempc 
oneline show 	nexeccalls res 
reflog message show 	nresults 
signature show 	aux func 
mergetag cached commit 	pfunc step 
buffer format 	idx limit 
display notes log 	init plimit 
output encoding 	pstep last 
strbuf detach xcalloc 	val 
non ascii 	ncl nup 
fmt name 	ttisnumber ttisstring 
getenv getenv log 	lua str 
output encoding 	svalue setnvalue 
pretty print commit 	ttisnumber nvalue 
append signoff 	lua 
strbuf addstr strbuf 	number str 
addstr graph 	setsvalue lua 
show oneline graph 	resethookcount lua 
show commit 	callhook func 
msg fwrite commit 	rel getline 
format empty 	getline 
graph show padding 	rel lua 
putchar strbuf 	callhook savestack 
release free diffcore 	setobj setobj 
std diff 	setobj lua 
queue empty diff 	checkstack lua 
flush show 	call 
log commit format 	restorestack setobjs 
empty output 	setobj setobj 
prefix fwrite 	setobj setobj 
putchar diff flush 	lua checkstack 
diff combined 	lua call 
merge diff opt 	ttistable 
tst parse 	hvalue lua 
commit die saved 	ttisnil fasttm 
parents diff 	setobj ttisnil 
root sha log 	lua gettmbyobj 
diff flush 	lua typeerror 
diff combined parse 	ttisfunction 
commit die 	call mres 
diff sha log 	lua runerror 
diff flush 	ttistable hvalue 
parse commit die 	lua ttisnil 
diff sha 	fasttm setobj 
log diff flush 	lua 
line log 	barriert ttisnil 
print log 	lua gettmbyobj 
diff show log 	lua typeerror 
maybe flush 	ttisfunction call 
die local remote 	setobj lua 
tag stash 	runerror 
head grafted comparing 	lua gettmbyobj 
ignore config 	ttisnil lua 
sets tolower match 	gettmbyobj ttisnil 
letters values 	call mres 
documented documentation config 	fasttm fasttm 
txt consistency 	lua 
love consistent log 	rawequal obj 
uses diff 	lua gettmbyobj 
opt tst determining 	ttisnil lua 
whether use 	gettmbyobj lua 
color showing commit 	rawequal obj 
sha use 	call 
check decorate head 	mres isfalse 
output also 	getstr getstr 
branch points 	strcoll strlen 
find decoration entry 	ttype ttype 
current branch 	lua ordererror 
first find head 	ttisnumber 
resolve find 	luai numlt 
matching current branch 	nvalue nvalue 
list caller 	ttisstring strcmp 
makes sure funny 	rawtsvalue rawtsvalue 
color calling 	call order 
format decorations extended 	lua 
makes sure 	ordererror ttype 
current head show 	ttype lua 
head current 	ordererror ttisnumber 
head would appeared 	luai numle 
skipping entry 	nvalue nvalue 
current unknown never 	ttisstring 
error message 	strcmp rawtsvalue 
already given could 	rawtsvalue call 
good signature 	order call 
good otherwise 	order lua 
couldn verify shown 	ordererror lua 
bad use 	ttype 
terminator already handled 	ttype ttype 
record termination 	luai numeq 
end last record 	nvalue nvalue 
otherwise diffopt 	bvalue bvalue 
line termination character 	pvalue pvalue 
entries first 	uvalue 
iow separator entries 	uvalue comp 
entries separated 	uvalue uvalue 
newline output look 	hvalue hvalue 
human readable 	comp hvalue 
last entry ended 	hvalue gcvalue 
newline print 	gcvalue 
graph output newline 	call mres 
otherwise end 	isfalse ttisstring 
completely blank line 	ttisnumber tostring 
look like 	call bin 
gap graph 	lua concaterror 
entry separator newline 	tsvalue 
output primarily 	tostring tsvalue 
intended programmatic consumption 	tostring tsvalue 
never want 	lua runerror 
extra graph output 	lua openspace 
entry separator 	tsvalue memcpy 
history graph requested 	svalue 
print graph 	setsvalue lua 
commit line print 	newlstr lua 
header line 	tonumber lua 
header setup revisions 	tonumber nvalue 
ensures opt 	setnvalue luai 
reflog info opt 	numadd 
graph cannot 	setnvalue luai 
need worry printing 	numsub setnvalue 
graph info 	luai nummul 
pretty printed message 	setnvalue luai 
opt missing 	numdiv setnvalue 
newline msgbuf 	luai 
doesn end newline 	nummod setnvalue 
including empty 	luai numpow 
showing verbose header 	setnvalue luai 
log message 	numunm lua 
pretty oneline format 	call bin 
would want 	lua 
extra newline end 	aritherror lua 
log diff 	lua clvalue 
diffstat output readability 	traceexec lua 
may shown 	lua lua 
three dashes line 	lua checkopenop 
early notes 	opcode 
log message want 	setobjs setobj 
blank line 	setbvalue getarg 
notes without extra 	getarg setnilvalue 
three dashes 	getarg setobj 
line otherwise 	sethvalue lua 
show three dashes 	ttisstring 
line showing 	protect lua 
patch diffstat extra 	gettable protect 
blank line 	lua gettable 
three dashes line 	rkc sethvalue 
show diff 	lua ttisstring 
commit printed log 	protect 
info messages 	lua settable 
root commit one 	getarg setobj 
parent generate 	lua barrier 
merge log entry 	protect lua 
first parent 	settable rkb 
showing summary diff 	rkc 
others merged 	getarg getarg 
show individual diffs 	sethvalue lua 
show parent 	lua lua 
info log info 	protect lua 
next parent 	check setobjs 
log-tree.h commit 	protect 
parent slot name 	lua gettable 
rev info 	rkc arith 
rev info rev 	arith arith 
info commit 	arith arith 
rev info opt 	arith ttisnumber 
commit use 	nvalue 
color prefix separator 	setnvalue luai 
suffix opt 	numunm protect 
commit opt commit 	arith isfalse 
subject extra 	setbvalue ttype 
headers need bit 	setnvalue cast 
cte flags 	num 
strbuf commit rev 	lua getn 
info strbuf 	hvalue setnvalue 
subject rev info 	cast num 
log.c date 	tsvalue getarg 
mode abbrev commit 	getarg setobjs 
show root 	dojump 
follow decoration 	getarg rkb 
style decoration given 	rkc isfalse 
use mailmap 	getarg dojump 
config fmt patch 	getarg isfalse 
subject prefix 	getarg setobjs 
fmt pretty builtin 	dojump 
log usage 	getarg getarg 
rev prefix args 	getarg lua 
opt arg 	precall getarg 
unset option arg 	lua getarg 
unset data 	lua precall 
rev argc argv 	lua 
prefix rev 	close setobjs 
opt mailmap line 	lua clvalue 
builtin log 	getarg lua 
options argc argv 	close lua 
prefix rev 	poscall lua 
opt rev list 	lua 
commit flags 	lua opcode 
rev stage 	nvalue luai 
early output timer 	numadd nvalue 
revs list 	nvalue luai 
show header commit 	numlt luai 
signal rev 	numle 
rev rev commit 	luai numle 
saved nrl 	dojump getarg 
saved dcctc slot 	setnvalue setnvalue 
name argc 	tonumber lua 
argv prefix rev 	runerror lua 
opt buf 	tonumber 
len rev sha 	lua runerror 
rev obj 	lua tonumber 
name sha obj 	lua runerror 
context buf 	lua setnvalue 
size sha rev 	luai numsub 
size buf 	nvalue 
offset offset 	nvalue dojump 
sha pathname mode 	getarg setobjs 
stage context 	setobjs setobjs 
rev opt argc 	protect lua 
argv prefix 	call getarg 
rev objects opt 	ttisnil 
match count 	setobjs dojump 
ret name argc 	getarg getarg 
argv prefix 	getarg cast 
rev opt rev 	cast runtime 
opt argc 	check ttistable 
argv prefix rev 	hvalue 
opt fmt 	lua resizearray 
patch suffix numbered 	setobj lua 
number attach 	setnum lua 
extra hdr extra 	barriert lua 
extra item 	close getarg 
len signoff signature 	lua 
signature file 	lclosure opcode 
config cover 	getarg lua 
letter config output 	opcode lua 
directory realstdout 	findupval getarg 
output directory outdir 	setclvalue protect 
offset commit 	lua 
subject rev quiet 	check getarg 
filename suffix 	cast protect 
len rev ids 	lua checkstack 
check rev 	setobjs setnilvalue 
commit flags flags 	lvm roberto 
info buf 	exp 
buf branch name 	lua machine 
desc rev 	see copyright 
positive branch oid 	notice lua 
tip oid 	limit table 
full branch rev 	tag method 
use stdout 	chains 
origin list branch 	avoid loops 
name quiet 	call linehook 
committer body 	enter function 
msg log encoding 	jump back 
opts need 	loop enter 
bit cte head 	line 
buf msg 	push function 
prefix output directory 	argument argument 
builtin format 	push function 
patch usage keep 	argument argument 
subject opt 	argument table 
arg unset subject 	primitive 
prefix opt 	result nil 
arg unset numbered 	tag method 
cmdline opt 	repeat table 
opt arg unset 	primitive result 
opt arg 	nil tag 
unset opt arg 	method 
unset dir 	repeat avoid 
opt arg unset 	pointing inside 
opt arg 	table may 
unset rev 	rehash first 
opt arg unset 	operand second 
rev opt 	operand 
arg unset opt 	metamethod metatables 
arg unset 	metamethods metamethod 
opt arg unset 	metamethods metamethod 
opt arg 	different metamethods 
unset argc argv 	equal index 
prefix commit 	first 
list rev opt 	finished finished 
total use 	smaller finished 
stdout start number 	longer len 
numbers ignore 	comparing first 
upstream cover letter 	must call 
boundary count 	number 
binary diff zero 	elements handled 
commit origin 	pass least 
reply ids 	second empty 
buf use patch 	result first 
format quiet 	least two 
reroll count branch 	values 
name builtin 	many possible 
format patch options 	collect total 
sprefix check 	length concat 
head sha buf 	got create 
msgid shown 	repeat result 
arg revs flags 	left 
sha commit 	macros common 
cherry usage sign 	tasks lua 
commit verbose 	execute used 
abbrev buf argc 	possible stack 
argv prefix 	reallocation 
revs ids commit 	entry point 
list current 	main loop 
branch upstream head 	interpreter hook 
limit abbrev 	warning several 
options sign 	calls may 
git config maybe 	realloc 
strcmp strcmp 	stack invalidate 
strcmp isatty pager 	skip next 
use parse 	instruction next 
decoration style die 	assignment may 
list append 	change metamethod 
commit format diff 	previous 
opt diff 	instruction top 
opt diff opt 	restart lua 
parse date 	execute lua 
format parse options 	function function 
setup revisions 	precall called 
die memset userformat 	adjust 
find requirements 	results previous 
init display notes 	instruction top 
diff opt 	tail call 
tst xcalloc read 	put frame 
mailmap load 	place previous 
decorations line 	one 
log init setup 	previous frame 
pager cmd 	previous function 
log init defaults 	index move 
cmd log 	frame correct 
init finish putchar 	top one 
sort topological 	call 
order simplify commit 	lost frame 
estimate commit 	function precall 
count show early 	called previous 
header log 	function running 
commit setitimer memset 	yes execution 
sigemptyset sigaction 	increment 
setitimer estimate commit 	index jump 
count signal 	back update 
show early header 	index external 
setup early 	index next 
output prepare revision 	steps may 
walk die 	errors 
finish early 	call func 
output revision log 	args state 
commit free 	index previous 
commit buffer free 	call may 
commit list 	change stack 
diff opt tst 	loop 
diff result 	save control 
code strcmp git 	variable jump 
config strcmp 	back needs 
git config strcmp 	space pre 
git config 	alloc previous 
strcmp git config 	call 
strcmp parse 	may change 
decoration style strcmp 	stack lvm.h 
git config 	obj obj 
strcmp git config 	key val 
skip prefix 	key val 
parse decorate color 	nexeccalls 
config strcmp 	total last 
git config 	lvm roberto 
grep config git 	exp lua 
gpg config 	machine see 
git diff config 	copyright notice 
init grep 	lua 
defaults git config 	lzf.h data 
init revisions 	len data 
memset cmd log 	len data 
init cmd 	len data 
log walk user 	len copyright 
info log 	marc 
output encoding strbuf 	alexander lehmann 
release fflush 	schmorp schmorp 
diff opt touched 	redistribution use 
diff opt 	source binary 
tst stream blob 	forms without 
sha context 	modifica 
die textconv 	tion permitted 
stream blob die 	provided following 
write die 	conditions met 
read sha file 	redistributions source 
error sha 	code must 
hex starts show 	retain 
tagger fwrite 	copyright notice 
free isdir init 	list conditions 
grep defaults 	following disclaimer 
git config memset 	redistributions binary 
init revisions 	form must 
memset cmd log 	reproduce 
init cmd 	copyright notice 
log walk show 	list conditions 
blob putchar 	following disclaimer 
diff color opt 	documentation materials 
diff color 	provided distribution 
opt show tag 	software 
parse error 	provided author 
oid hex 	express implied 
putchar diff color 	warranties including 
opt diff 	limited implied 
color opt read 	warranties mer 
recursive cmd 	chantability 
log walk error 	fitness particular 
free init 	purpose disclaimed 
grep defaults git 	shall author 
config init 	liable direct 
revisions init reflog 	indirect incidental 
walk memset 	spe 
cmd log init 	cial exemplary 
defaults cmd 	consequential damages 
log init finish 	including limited 
cmd log 	procurement substitute 
walk diff opt 	goods services 
tst diff 	loss 
opt init grep 	use data 
defaults git 	profits business 
config init 	interruption however 
revisions memset cmd 	caused theory 
log init 	liability whether 
cmd log walk 	contract 
strlen strncasecmp 	strict liability 
list append strncasecmp 	tort including 
list append 	negligence oth 
list append strcmp 	erwise arising 
die header 	way use 
strcmp git config 	software 
strcmp config 	even advised 
error nonbool list 	possibility damage 
append strcmp 	alternatively contents 
config error nonbool 	file may 
list append 	used terms 
strcmp strcmp strcmp 	gnu 
strcmp strcmp 	general license 
strcasecmp git config 	gpl version 
strcmp xstrdup 	later version 
xstrdup strcmp 	provisions gpl 
strcasecmp strcasecmp git 	applicable instead 
config strcmp 	wish 
git config strcmp 	allow use 
git config 	version file 
strcmp git config 	terms gpl 
pathname strcmp 	allow others 
strcasecmp git config 	use version 
strcmp git 	file 
config git log 	bsd license 
config strlen 	indicate decision 
strbuf addstr error 	deleting provisions 
strbuf complete 	replace notice 
strbuf addf fmt 	provisions required 
output commit 	gpl 
fmt output subject 	provisions recipient 
freopen error 	may use 
strbuf release 	version file 
die lookup commit 	either bsd 
reference lookup 	gpl lzf 
commit reference die 	extremely 
init patch 	fast free 
ids init revisions 	compression decompression 
pending pending 	method http 
prepare revision walk 	liblzf plan 
die revision 	algorithm believed 
commit patch clear 	patent 
commit marks 	free api 
clear commit marks 	version compress 
strbuf addf 	len bytes 
time git committer 	stored memory 
info strbuf 	block starting 
detach strlen putchar 	data 
putchar read 	write result 
branch desc strbuf 	data maximum 
addch strbuf 	length len 
addbuf strbuf 	bytes output 
addch strbuf release 	buffer large 
dwim strlen 	enough 
skip prefix oidcmp 	error occurs 
xstrdup free 	otherwise number 
die git committer 	bytes used 
info reopen 	might considerably 
stdout log write 	len less 
email headers 	original 
commit buffer non 	size makes 
ascii unuse 	sense always 
commit buffer find 	use len 
branch name 	len ensure 
user info title 	compression store 
line remainder 	data 
branch description strbuf 	uncompressed otherwise 
release shortlog 	flag course 
init shortlog commit 	lzf compress 
shortlog output 	might use 
memcpy diff 	different algorithms 
setup done diff 	different 
sha diffcore 	systems even 
std diff flush 	different runs 
print signature 	thus might 
isspace isspace die 	result different 
xmemdupz absolute 	compressed depending 
path strlen xstrdup 	phase 
prefix filename 	moon similar 
numbered callback die 	factors however 
strcmp strcmp 	architecture independent 
list clear list 	result original 
clear list 	data decompressed 
clear header list 	lzf 
clear list 	decompress buffers 
append list clear 	must overlapping 
list append 	option lzf 
free xstrdup xstrdup 	state arg 
git committer 	enabled extra 
info init 	argument 
grep defaults git 	must supplied 
config init 	reflected header 
revisions diff opt 	file refer 
memset parse 	lzf lzf 
options strbuf addf 	decompress data 
strbuf detach 	compressed 
strbuf addstr strbuf 	version lzf 
addch strbuf 	compress function 
addstr strbuf addstr 	stored location 
strbuf addstr 	data length 
strbuf addch strbuf 	len result 
addch strbuf 	stored 
addstr strbuf addstr 	data maximum 
strbuf addstr 	len characters 
strbuf addch strbuf 	output buffer 
addch strbuf 	large enough 
detach split 	hold decompressed 
ident line strlen 	data 
die die 	returned errno 
die setup revisions 	big otherwise 
die die 	number decompressed 
die die diff 	bytes original 
opt tst 	length data 
diff opt init 	returned 
display notes 	error compressed 
outdir setup pager 	data detected 
die mkdir 	zero returned 
die errno head 	errno einval 
pending strcmp 	function fast 
resolve skip prefix 	fast 
xstrdup xstrdup 	copying loop 
oidcmp patch ids 	lzfP.h std 
xfdopen xdup 	copyright marc 
prepare revision walk 	alexander lehmann 
die revision 	schmorp schmorp 
commit patch 	redistribution 
realloc strbuf read 	use source 
file die 	binary forms 
errno strbuf detach 	without modifica 
xcalloc clean 	tion permitted 
message list append 	provided following 
gen message 	conditions 
make cover letter 	met redistributions 
free list 	source code 
append gen message 	must retain 
oid hex 	copyright notice 
reopen stdout die 	list conditions 
log commit 	following 
free commit buffer 	disclaimer redistributions 
print signature 	binary form 
fclose free free 	must reproduce 
list clear 	copyright notice 
list clear list 	list conditions 
clear free 	following 
patch ids 	disclaimer documentation 
sha lookup commit 	materials provided 
reference pending 	distribution software 
find unique abbrev 	provided author 
commit easy 	express implied 
find unique abbrev 	warranties 
strbuf release 	including limited 
parse options branch 	implied warranties 
branch upstream 	mer chantability 
usage options init 	fitness particular 
revisions pending 	purpose disclaimed 
commit die pending 	shall 
commit die 	author liable 
oidcmp patch ids 	direct indirect 
pending commit 	incidental spe 
die prepare revision 	cial exemplary 
walk die 	consequential damages 
revision commit list 	including 
insert commit 	limited procurement 
patch print 	substitute goods 
commit free patch 	services loss 
ids builtin 	use data 
git log related 	profits business 
commands show 	interruption 
whatchanged copyright linus 	however caused 
torvalds junio 	theory liability 
hamano date time 	whether contract 
format git 	strict liability 
log log date 	tort including 
config variable 	negligence 
use full terminal 	oth erwise 
width respect 	arising way 
stat graph width 	use software 
config arguments 	even advised 
point recognized log 	possibility damage 
pretty raw 	alternatively 
special ignore oriented 	contents file 
configuration variables 	may used 
decoration gives 	terms gnu 
rough estimate many 	general license 
commits print 	gpl version 
list already enough 	later 
commits early 	version provisions 
output repeat twice 	gpl applicable 
second note 	instead wish 
use interval reader 	allow use 
isn listening 	version file 
want output throttled 	terms 
writing timer 	gpl allow 
trigger every second 	others use 
even blocked 	version file 
reader signal handler 	bsd license 
minimally intrusively 	indicate decision 
single integer word 	deleting 
sigatomic trying 	provisions replace 
avoid unnecessary 	notice provisions 
system dependencies headers 	required gpl 
restart whole 	provisions recipient 
output less tenth 	may use 
second even 	version 
bother early output 	file either 
thing one 	bsd gpl 
time trigger check 	moment size 
exit code 	hashtable hlog 
exit code check 	decompression independent 
failed changes 	hash 
accumulated rev diffopt 	table size 
careful retain 	difference small 
state information replacing 	small blocks 
rev diffopt 	usually bit 
loop decremented max 	faster low 
count revision 	memory 
didn actually show 	faster configuration 
commit allow 	use hlog 
cycles reflog 	best compression 
ancestry maybe warn 	use sacrifice 
nothing command 	little compression 
line first parent 	quality 
scale real 	favour compression 
terminal size equivalent 	speed gives 
git log 	almost compression 
abbrev commit pretty 	code roughly 
oneline turn 	faster preferred 
given turn given 	mode 
format patch 	operation sacrifice 
given range patch 	compression quality 
ids reset 	favour compression 
next revision walk 	speed roughly 
diffstat unique 	worse compression 
reference point user 	large 
explicitly ask 	blocks small 
parse arguments setup 	redundant blocks 
revisions something 	better speed 
like git 	cases need 
format patch head 	speed enable 
may fail 	binary 
possibly valid sha 	data possibly 
numbered solely 	disable text 
due format numbered 	data unconditionally 
config would 	aligning cost 
conflict keep subject 	much unsure 
command line 	may 
reset numbered always 	choose pre 
generate patch 	hash table 
traditional behaviour git 	might faster 
format patch 	modern cpus 
origin prepares origin 	large blocks 
side still 	also 
otherwise format patch 	makes compression 
head format 	deterministic repeatable 
patch root head 	configuration otherwise 
user wants 	avoid assigning 
revision usual 	values errno 
traversal branch cannot 	variable 
move anywhere 	embedding purposes 
earlier want know 	linux kernel 
root given 	example necessary 
explicitly command line 	note breaks 
say anything 	documentation lzf 
head upstream nothing 	avoiding 
signature inhibits 	errno speed 
signatures non signature 	impact whether 
already make 	pass lzf 
second subsequent mails 	state variable 
replies first 	argument allocate 
already message deep 	stack 
threading make 	small stack 
every mail reply 	environments define 
previous one 	note breaks 
matter options 	prototype lzf 
shallow threading without 	whether extra 
cover letter 	checks 
reply make every 	input validity 
mail reply 	lzf decompress 
one reply cover 	einval input 
letter make 	stream corrupted 
every mail reply 	shields overflowing 
reply cover 	input 
letter make every 	buffer detect 
mail cover 	corrupted streams 
letter reply cover 	check normally 
letter cover 	noticeable modern 
letter reply reply 	hardware slowdown 
specified put 	might 
one extra blank 	slow older 
line formatted 	cpus considerably 
patches flag used 	whether store 
log code 	pointers offsets 
see needs 	inside hash 
emit showing log 	table 
one file 	bit architetcures 
per patch want 	pointers take 
extra blank 	twice much 
line fallthrough fallthrough 	space might 
say anything 	also slower 
head upstream reverse 	autodetect 
list commits 	define lzf 
ls-files.c abbrev show 	user offsets 
deleted show 	autodetect nothing 
cached show others 	changed accesses 
show stage 	need bit 
show unmerged show 	datatype 
resolve undo 	lzf data 
show modified show 	len data 
killed show 	len htab 
valid bit line 	htab end 
terminator debug 	end hval 
mode show 	lit 
eol prefix max 	hslot len 
prefix len 	maxlen memset 
prefix len pathspec 	frst next 
error unmatch 	idx expect 
matched exc given 	expect 
exclude args 	expect frst 
tag cached tag 	next idx 
unmerged tag 	next idx 
removed tag tag 	next idx 
killed tag 	expect expect 
modified tag skip 	expect 
worktree tag 	copyright marc 
resolve undo path 	alexander lehmann 
txt txt 	schmorp schmorp 
txt name tag 	redistribution use 
ent len 	source binary 
dir ent dir 	forms 
ent pos 	without modifica 
len killed 	tion permitted 
tag len alttag 	provided following 
item path 	conditions met 
len dir dtype 	redistributions source 
dir err 	code 
prefix pos first 	must retain 
last next 	copyright notice 
name prefix sha 	list conditions 
pathspec last 	following disclaimer 
stage files usage 	redistributions binary 
opt arg 	form 
unset exclude list 	must reproduce 
opt arg 	copyright notice 
unset dir opt 	list conditions 
arg unset 	following disclaimer 
dir argc argv 	documentation materials 
cmd prefix 	provided 
max prefix 	distribution software 
dir exclude list 	provided author 
builtin files 	express implied 
options bad convert 	warranties including 
attr ascii 	limited implied 
isreg cached convert 	warranties 
stats ascii 	mer chantability 
lstat isreg convert 	fitness particular 
stats ascii 	purpose disclaimed 
write name quoted 	shall author 
relative die 	liable direct 
dir path match 	indirect 
fputs write 	incidental spe 
eolinfo write name 	cial exemplary 
cache name 	consequential damages 
show dir entry 	including limited 
strchr cache 	procurement substitute 
name pos die 	goods 
stage namelen 	services loss 
strncmp cache 	use data 
name pos show 	profits business 
dir entry 	interruption however 
namelen die match 	caused theory 
pathspec namelen 	liability 
isdir isgitlink memcpy 	whether contract 
isalpha tolower 	strict liability 
fputs find unique 	tort including 
abbrev stage 	negligence oth 
write eolinfo write 	erwise arising 
name strlen 	way 
match pathspec find 	use software 
unique abbrev 	even advised 
write name dtype 	possibility damage 
excluded fill 	alternatively contents 
directory show files 	file may 
show killed 	used 
files excluded stage 	terms gnu 
show entry 	general license 
stage skip 	gpl version 
worktree excluded skip 	later version 
worktree lstat 	provisions gpl 
show entry modified 	applicable 
show entry 	instead wish 
cache name pos 	allow use 
memmove strncmp 	version file 
sha die parse 	terms gpl 
indirect die 	allow others 
stage parse pathspec 	use 
memset read 	version file 
die stage strcmp 	bsd license 
list append 	indicate decision 
excludes file setup 	deleting provisions 
standard excludes 	replace notice 
strcmp usage options 	provisions 
memset strlen 	required gpl 
git config read 	provisions recipient 
cache die 	may use 
parse options 	version file 
exclude list exclude 	either bsd 
inside work 	gpl 
setup work parse 	play unless 
pathspec common 	benchmark data 
prefix strlen xcalloc 	format dependent 
die prune 	hash function 
cache die overlay 	hash function 
cache show 	might 
files show info 	seem strange 
report path 	believe works 
error merges file 	idx works 
listing directory 	similar multiplicative 
cache index actual 	hash hlog 
working directory 	hsize 
list shows different 	latter also 
combinations two 	quite fast 
copyright linus torvalds 	newer compresses 
full name 	similarly next 
prefix len 	one also 
caller needs pass 	quite 
empty good 	good albeit 
ent name prefix 	slow cos 
entry cache 	xffffff original 
killed skip unmerged 	lzv like 
pos points 	hash function 
name immediately ent 	much 
name cache 	worse thus 
expect ent name 	slower compressed 
directory leading 	format lllll 
directories ent name 	octets looooo 
registered cache 	oooooooo backref 
ent name killed 	octets 
outside prefix 	offset ooooo 
uninterested cached deleted 	llllllll oooooooo 
files need 	backref octets 
even readdir 	offset requires 
prune index contain 	type wide 
stuff starting 	enough 
prefix read specified 	hold general 
option typically 	pointer difference 
head stage squash 	iso doesn 
stage used 	size might 
error unmatch list 	enough ptrdiff 
check path 	works 
patterns given command 	differences within 
line going 	single also 
write index hoist 	bit pattern 
unmerged entries 	traps since 
stage make room 	platform non 
fallthru stage 	posix 
entry need show 	fails support 
use update 	assumptions windows 
bit mark entry 	bit make 
think twice 	special workaround 
adding nul 	workaround missing 
synonym point showing 	posix 
unmerged unless 	compliance start 
also show stage 	run next 
information find 	test actually 
common prefix pathspec 	take care 
treat unmatching 	faster match 
pathspec elements errors 	found 
flags showing 	first faster 
cached files basic 	conservative test 
sanity check 	second exact 
show stages show 	rare test 
unmerged would 	stop run 
make sense option 	undo 
ls-remote.c remote 	run length 
usage pattern path 	zero len 
pathbuf argc 	octets start 
argv prefix dest 	run one 
flags url 	must copy 
quiet status 	stop 
show symref target 	run start 
uploadpack pattern 	run bytes 
remote transport options 	missing stop 
snprintf error 	run start 
wildmatch parse options 	run end 
xcalloc xstrfmt 	run 
remote die die 	undo run 
die transport 	length zero 
transport option transport 	lzf data 
remote refs 	len data 
transport disconnect check 	len end 
type tail 	end 
match oid hex 	ctrl len 
one among 	errno errno 
list patterns match 	lzf movsb 
tail part 	errno errno 
path restriction found 	errno errno 
something ls-tree.c 	lzf 
line termination 	movsb memcpy 
abbrev options pathspec 	copyright marc 
chomp prefix 	alexander lehmann 
prefix usage baselen 	schmorp schmorp 
pathname spec 	redistribution use 
len speclen sha 	source 
pathname mode 	binary forms 
stage context retval 	without modifica 
baselen type 	tion permitted 
size text size 	provided following 
argc argv 	conditions met 
prefix sha full 	redistributions 
options strncmp 	source code 
strlen strlen memcmp 	must retain 
isgitlink isdir 	copyright notice 
show recursive strcmp 	list conditions 
sha info 	following disclaimer 
xsnprintf xsnprintf 	redistributions 
xsnprintf find unique 	binary form 
abbrev find 	must reproduce 
unique abbrev strbuf 	copyright notice 
addstr write 	list conditions 
name quoted relative 	following disclaimer 
strbuf setlen 	documentation 
git config strlen 	materials provided 
parse options 	distribution software 
usage options sha 	provided author 
die parse 	express implied 
pathspec parse indirect 	warranties including 
die read 	limited 
recursive git information 	implied warranties 
manager hell 	mer chantability 
copyright linus torvalds 	fitness particular 
maybe want 	purpose disclaimed 
recursive version something 	shall author 
similar incomplete 	liable 
example show 	direct indirect 
subprojects baselen pathname 	incidental spe 
retval read 	cial exemplary 
recursive imply show 	consequential damages 
recursive rolls 	including limited 
matching code generally 	procurement 
ignorant pathspec 	substitute goods 
magic mask cannot 	services loss 
lifted converted 	use data 
use match pathspec 	profits business 
entry interesting 	interruption however 
mailinfo.c pos cnt 	caused 
name email 	theory liability 
src line bra 	whether contract 
ket line 	strict liability 
line name attr 	tort including 
ends line 	negligence oth 
boundary line line 	erwise 
line content 	arising way 
top subject 	use software 
pos header line 	even advised 
hdr len 	possibility damage 
line len sample 	alternatively contents 
seg rfc 	file 
seg acc line 	may used 
charset dec 	terms gnu 
piecebuf found error 	general license 
encoding scan 	gpl version 
line hdr data 	later version 
overwrite len 	provisions 
len line ret 	gpl applicable 
line line 	instead wish 
len gap first 	allow use 
nonblank visible 	version file 
perforation buf line 	terms gpl 
line line 	allow 
line line continuation 	others use 
peek line 	version file 
line newline 	bsd license 
line prev lines 	indicate decision 
fout hdr 	deleting provisions 
data len hdr 	replace 
msg patch 	notice provisions 
cmitmsg peek line 	required gpl 
isspace isspace 	provisions recipient 
strbuf strchr strchr 	may use 
strchr strbuf 	version file 
reset strbuf addbuf 	either 
strchr strchr 	bsd gpl 
strbuf reset strbuf 	small win 
strbuf reset 	amd big 
strbuf strbuf trim 	loss intel 
sane name 	run back 
strbuf init strbuf 	reference 
addbuf strchr 	disjunct areas 
parse bogus 	overlapping use 
strchr strbuf release 	octte octte 
isspace strcspn 	copying two 
strbuf reset strbuf 	octets lzio.c 
strbuf cleanup 	size 
space strbuf trim 	buff reader 
strbuf strbuf 	data buff 
setlen sane name 	lua unlock 
strbuf release 	reader lua 
xmalloc strbuf init 	lua fill 
strbuf reset 	lua 
strbuf addbuf strcasestr 	lookahead memcpy 
strbuf setlen 	lua resizebuffer 
strlen strcspn strbuf 	lzio roberto 
xmalloc strbuf 	exp input 
init slurp attr 	stream see 
strbuf insert 	copyright 
error slurp attr 	notice lua 
strbuf release 	lua fill 
free strdup 	removed first 
strcasestr strcasestr memcmp 	put back 
strbuf strbuf 	read number 
strchr memmem strbuf 	missing 
isspace strbuf 	bytes min 
trim strlen strncasecmp 	lzio.h buff 
isspace strlen 	reader data 
skip prefix strspn 	reader data 
memcmp strlen 	lzio roberto 
xmalloc strbuf init 	exp 
strbuf addch 	buffered streams 
hexval hexval strbuf 	see copyright 
addch xmalloc 	notice lua 
strbuf init strbuf 	end stream 
addch strbuf 	read next 
addch strbuf addch 	bytes 
encoding reencode 	part bytes 
error strbuf attach 	still unread 
strlen strlen 	current position 
strstr strbuf 	buffer additional 
reset strbuf reset 	data lua 
isspace strbuf 	state 
strchr strbuf strstr 	reader mallctl.c 
strbuf tolower 	epoch mib 
decode segment decode 	miblen epoch 
segment convert 	mib miblen 
utf strbuf addbuf 	old epoch 
strbuf release 	epoch 
free strbuf addstr 	mib miblen 
strbuf reset 	config always 
strbuf addbuf strbuf 	nbins mib 
release strbuf 	len miblen 
release strbuf release 	bin size 
strlen cmp 	tis 
header strbuf decode 	psz qsz 
header handle 	arena old 
header cmp header 	arena narenas 
strlen strbuf 	dirty mult 
decode header 	orig dirty 
strbuf insert handle 	mult 
content type 	prev dirty 
cmp header strlen 	mult old 
strbuf decode 	dirty mult 
header handle content 	narenas mib 
transfer encoding 	miblen dss 
cmp header strlen 	prec 
strbuf decode 	old dss 
header handle message 	prec mib 
starts isspace 	miblen narenas 
format patch separator 	dirty mult 
starts isspace 	orig dirty 
strcmp handle header 	mult 
strbuf release 	prev dirty 
decode segment decode 	mult old 
segment strbuf 	dirty mult 
reset strbuf addbuf 	narenas arena 
strbuf release 	narenas mallctl 
free starts 	mallctl 
starts starts isspace 	strlen mallctl 
isspace isspace 	mallctl mallctl 
memcmp memcmp memcmp 	mallctl mallctlnametomib 
memcmp check 	mallctlnametomib mallctlbymib 
header convert utf 	strlen mallctlnametomib 
scissors line 	mallctlbymib 
strbuf setlen strbuf 	mallctlbymib mallctlbymib 
release patchbreak 	mallctlbymib mallctl 
strbuf addf strbuf 	mallctl mallctl 
addbuf fwrite 	mallctl mallctlnametomib 
handle commit msg 	test mallctl 
handle patch 	config 
starts starts strbuf 	test mallctl 
getline strbuf 	config test 
rtrim rfc header 	mallctl config 
strbuf addch 	test mallctl 
fgetc ungetc 	config test 
strbuf getline strbuf 	mallctl 
rtrim strbuf 	config test 
addbuf strbuf release 	mallctl config 
strbuf getline 	test mallctl 
multipart boundary strbuf 	config test 
addch memcmp 	mallctl config 
strbuf release free 	test 
error handle 	mallctl config 
filter strbuf release 	test mallctl 
find boundary 	config test 
strbuf reset read 	mallctl config 
one header 	test mallctl 
line check header 	config 
strbuf release 	test mallctl 
strbuf getline strbuf 	config test 
addch find 	mallctl config 
boundary strbuf getwholeline 	test mallctl 
multipart boundary 	opt test 
handle filter 	mallctl 
strbuf reset handle 	opt test 
boundary decode 	mallctl opt 
transfer encoding strbuf 	test mallctl 
insert strbuf 	opt test 
reset strbuf split 	mallctl opt 
strbuf addbuf 	test 
handle filter strbuf 	mallctl opt 
list free 	test mallctl 
handle filter strbuf 	opt test 
release strchr 	mallctl opt 
strlen strcmp cleanup 	test mallctl 
subject cleanup 	opt 
space output header 	test mallctl 
lines strcmp 	opt test 
cleanup space handle 	mallctl opt 
cleanup space 	test mallctl 
fopen perror fopen 	opt test 
perror fclose 	mallctl 
xcalloc xcalloc 	opt test 
isspace fgetc ungetc 	mallctl opt 
read one 	test mallctl 
header line check 	opt test 
header handle 	mallctl opt 
body fwrite fclose 	test 
fclose handle 	mallctl opt 
info strbuf release 	test mallctl 
starts git 	opt test 
config strcmp git 	mallctl opt 
config memset 	test mallctl 
strbuf init strbuf 	opt 
init strbuf 	test mallctl 
init strbuf init 	opt test 
git config 	mallctl opt 
strbuf release strbuf 	test mallctl 
release strbuf 	opt mallctl 
release free strbuf 	mallctlnametomib 
release free 	mallctlbymib test 
strbuf release 	skip mallocx 
free free strbuf 	ptr mallocx 
release john 	ptr dallocx 
doe johndoe fallback 	dallocx mallocx 
bother already 	ptr 
mail address already 	ptr dallocx 
one email 	test skip 
take confusing lines 	nallocx mallctl 
pick around 	mallctl mallctl 
possibly delimited pair 	mallctl 
email part 	mallocx mallocx 
remainder name could 	tcache ptr 
john doe 	dallocx mallocx 
john doe john 	tcache mallocx 
doe john 	mallocx tcache 
doe john zzz 	ptr 
doe john 	dallocx mallocx 
doe comment 	tcache mallocx 
removed email part 	mallocx tcache 
extra spaces 	ptr ptr 
could stay email 	rallocx mallocx 
trim ends 	tcache 
possibly removing pair 	ptr ptr 
end cases 	dallocx mallocx 
note note note 	tcache mallctl 
claim full 	mallctl mallctl 
mime attempt enough 	mallctl mallctl 
heuristics grok 	mallctl 
mime encoded patches 	mallctl mallctl 
often found 	ssize mallctl 
mailing lists example 	mallctl mallctl 
even treat 	mallctlnametomib mallctlbymib 
header lines insensitively 	mallctlnametomib mallctlbymib 
input space 	str 
keep bother finding 	mallctlbymib mallctlbymib 
end space 	str narenas 
since later 	total mallctlbymib 
normalize anyway drop 	str mallctlbymib 
trailing newline 	mallctlbymib str 
rfc decode possibly 	mallctl 
place garbage 	variable mallctl 
pessimism process encoded 	mallctl mallctl 
word begins 	mallctl ssize 
something encoded word 	mallctl test 
lose something 	arenas constant 
unless processed encoded 	test 
word lws 	arenas constant 
one process iso 	test arenas 
foo iso 	constant test 
foo cbar baz 	arenas constant 
search interesting 	test arenas 
parts unwrap encoding 	constant 
optionally normalize 	test arenas 
meta information utf 	bin constant 
content stuff 	test arenas 
inbody stuff 	bin constant 
beginning diff header 	test arenas 
cvs index 	bin 
line filename starts 	constant test 
patches without 	arenas lrun 
headers manual separator 	constant test 
space followed 	arenas hchunk 
filename whitespace mark 	constant mallctl 
must least 	mallctl 
bytes even though 	mallctl test 
arbitrary cruft 	stats arenas 
line cut order 	test stats 
avoid misidentification 	arenas test 
perforation must occupy 	stats arenas 
third visible 	test 
width line dashes 	stats arenas 
scissors must 	test blind 
occupy half perforation 	read write 
trim first 	read write 
blank line 	something bin 
commit message ignoring 	size 
body headers 	allocate deallocate 
normalize log message 	bypass tcache 
utf input 	make sure 
error already may 	tcache allocation 
already read 	returns clean 
secondary headers purge 	create 
give clean 	tcaches exercise 
restart section defines 	tcache recycling 
loosest possible 	flush empty 
field name optional 	tcaches cache 
fields optional 	allocations verify 
field field name 	tcaches 
unstructured crlf 	allocate cached 
field name ftext 	regions verify 
ftext count 	reallocation uses 
mbox headers headers 	cached regions 
first part 	avoid undefined 
line empty 	behavior 
line valid rfc 	test failure 
header stop 	flush non 
header newline need 	empty tcaches 
eat continuation 	destroy tcaches 
lines yuck header 	mallocx.c cmd 
folding hit 	ret 
end boundary pop 	cmd ind 
current boundary 	ret mib 
stack technically won 	miblen ind 
happen multipart 	hugemax size 
boundary fail first 	alignment nsz 
skip next 	rsz 
boundary defaults slurp 	nsz rsz 
section info 	alignment total 
replenish line skip 	mallctl nsizes 
first boundary 	impl mallctlnametomib 
process boundary 	mallctlbymib size 
lines flush leftover 	impl 
unwrap transfer 	huge size 
encoding prepend previous 	nhuge mallocx 
lines decoded 	ptr mallocx 
line may contain 	dallocx ptr 
multiple lines 	mallocx mallocx 
pass one chunk 	align 
time handle 	nallocx nallocx 
filter last line 	mallocx ptr 
line save 	sallocx dallocx 
later chunk saved 	mallocx ptr 
prev appended 	dallocx nallocx 
next iteration read 	mallocx 
line nul 	ptr sallocx 
print inbody headers 	dallocx nallocx 
output patch 	mallocx align 
file process email 	mallocx mallocx 
header perhaps 	align ptr 
others another 	sallocx 
stupid program one 	ptr dallocx 
parsing headers 	test impossible 
email figure authorship 	allocate two 
subject needswork 	objects consume 
might want optional 	half address 
git directory 	space 
discovery mailinfo usage 	MALLOCX arenac 
argc argv 	dss arg 
prefix def charset 	ind arena 
status setup 	ind mib 
mailinfo commit output 	miblen dss 
encoding strcmp 	precs 
strcmp strcmp strcmp 	prec ind 
strcmp strcmp 	dss expected 
starts strcmp strcmp 	err thds 
strcmp usage 	mallctl mallctlnametomib 
usage mailinfo clear 	mallctlbymib mallocx 
mailinfo john 	mallocx 
doe johndoe 	arena ptr 
fallback bother already 	dallocx thd 
mail address 	create thd 
already one email 	test math.c 
take confusing 	exp gamma 
lines pick around 	integer 
possibly delimited 	expected gamma 
pair email part 	increment expected 
remainder name 	norm increment 
could john doe 	expected chi 
john doe 	increment expected 
john doe john 	gamma 
doe john 	increment shape 
zzz doe john 	increment max 
doe comment 	rel err 
removed email part 	max abs 
extra spaces 	err rel 
could stay email 	err 
trim ends 	ret gamma 
possibly removing 	misc expected 
pair end cases 	norm expected 
note note 	chi chi 
note claim full 	expected gamma 
mime attempt 	gamma 
enough heuristics grok 	shape gamma 
mime encoded 	expected shape 
patches often found 	gamma shape 
mailing lists 	shape gamma 
example even treat 	shape fabs 
header lines 	fabs 
insensitively input space 	fabs fabs 
keep bother 	fabs rel 
finding end space 	exp gamma 
since later 	factorial rel 
normalize anyway drop 	gamma rel 
trailing newline 	norm 
rfc decode 	gamma rel 
possibly place garbage 	chi gamma 
pessimism process 	rel gamma 
encoded word begins 	gamma rel 
something encoded 	gamma gamma 
word lose something 	test 
unless processed 	exp gamma 
encoded word lws 	integer expected 
one process 	gamma increment 
iso foo iso 	expected norm 
foo cbar 	increment expected 
baz search interesting 	chi 
parts unwrap 	increment expected 
encoding optionally normalize 	gamma increment 
meta information 	shape increment 
utf content stuff 	math.c exp 
inbody stuff 	gamma integer 
beginning diff header 	expected 
cvs index 	gamma increment 
line filename 	expected norm 
starts patches without 	increment expected 
headers manual 	chi increment 
separator space followed 	expected gamma 
filename whitespace 	increment 
mark must least 	shape increment 
bytes even 	max rel 
though arbitrary cruft 	err max 
line cut 	abs err 
order avoid misidentification 	rel err 
perforation must 	ret 
occupy third visible 	gamma misc 
width line 	expected norm 
dashes scissors must 	expected chi 
occupy half 	chi expected 
perforation trim first 	gamma gamma 
blank line 	shape 
commit message ignoring 	gamma expected 
body headers 	shape gamma 
normalize log 	shape shape 
message utf input 	gamma shape 
error already 	fabs fabs 
may already read 	fabs 
secondary headers 	fabs fabs 
purge give clean 	rel exp 
restart section 	gamma factorial 
defines loosest possible 	rel gamma 
field name 	rel norm 
optional fields optional 	gamma 
field field 	rel chi 
name unstructured crlf 	gamma rel 
field name 	gamma gamma 
ftext ftext count 	rel gamma 
mbox headers 	gamma test 
headers first part 	exp 
line empty 	gamma integer 
line valid rfc 	expected gamma 
header stop 	increment expected 
header newline 	norm increment 
need eat continuation 	expected chi 
lines yuck 	increment 
header folding hit 	expected gamma 
end boundary 	increment shape 
pop current boundary 	increment math.h 
stack technically 	gamma gamma 
won happen multipart 	shape scale 
boundary fail 	gamma 
first skip next 	shape gamma 
boundary defaults 	acu factor 
slurp section info 	oflo gin 
replenish line 	term dif 
skip first boundary 	ret gamma 
process boundary 	shape 
lines flush leftover 	scale gamma 
unwrap transfer 	shape log 
encoding prepend 	log exp 
previous lines decoded 	log fabs 
line may 	fabs fabs 
contain multiple lines 	sqrt 
pass one 	log log 
chunk time handle 	pow exp 
filter last 	norm pow 
line line save 	sqrt log 
later chunk 	log log 
saved prev appended 	exp 
next iteration 	fabs gamma 
read line nul 	exp log 
print inbody 	fabs chi 
headers output patch 	compute natural 
file process 	log gamma 
email header perhaps 	accurate 
others another 	places implementation 
stupid program one 	pike hill 
parsing headers 	algorithm logarithm 
email figure 	gamma function 
authorship subject needswork 	communications acm 
might want 	compute 
optional git directory 	incomplete gamma 
discovery mailinfo.c 	ratio shape 
pos cnt name 	parameter gamma 
email src 	gamma implementation 
line bra ket 	bhattacharjee algorithm 
line line 	incomplete 
name attr ends 	gamma integral 
line boundary 	applied statistics 
line line line 	calculation series 
content top 	expansion calculation 
subject pos header 	continued fraction 
line hdr 	given 
len line len 	lower tail 
sample seg 	area normal 
rfc seg acc 	distribution compute 
line charset 	limit definite 
dec piecebuf 	integral inf 
found error encoding 	satisfies 
scan line 	accurate places 
hdr data overwrite 	implementation wichura 
len len 	algorithm percentage 
line ret line 	points normal 
line len 	distribution applied 
gap first nonblank 	statistics 
visible perforation 	close neither 
buf line line 	close near 
line line 	given lower 
line continuation peek 	tail area 
line line 	chi distribution 
newline line prev 	degrees 
lines fout 	freedom gamma 
hdr data len 	gamma compute 
hdr msg 	upper limit 
patch cmitmsg peek 	definite integral 
line isspace 	satisfies accurate 
isspace strbuf 	places 
strchr strchr strchr 	implementation best 
strbuf reset 	roberts algorithm 
strbuf addbuf strchr 	percentage points 
strchr strbuf 	chi distribution 
reset strbuf strbuf 	applied statistics 
reset strbuf 	shea 
strbuf trim sane 	algorithm remark 
name strbuf 	percentage points 
init strbuf addbuf 	chi distribution 
strchr parse 	applied statistics 
bogus strchr strbuf 	starting approximation 
release isspace 	small 
strcspn strbuf reset 	chi starting 
strbuf strbuf 	approximation wilson 
cleanup space strbuf 	hilferty estimate 
trim strbuf 	starting approximation 
strbuf setlen sane 	tending calculation 
name strbuf 	seven 
release xmalloc 	term taylor 
strbuf init strbuf 	series given 
reset strbuf 	gamma distribution 
addbuf strcasestr strbuf 	shape scale 
setlen strlen 	parameters compute 
strcspn strbuf xmalloc 	upper 
strbuf init 	limit definite 
slurp attr strbuf 	integral satisfies 
insert error 	mb.c mb.h 
slurp attr strbuf 	mtx sync 
release free 	synchronize malloc 
strdup strcasestr strcasestr 	mutex 
memcmp strbuf 	init malloc 
strbuf strchr memmem 	mutex malloc 
strbuf isspace 	mutex unlock 
strbuf trim strlen 	jemalloc types 
strncasecmp isspace 	jemalloc structs 
strlen skip 	jemalloc 
prefix strspn memcmp 	externs according 
strlen xmalloc 	intel architecture 
strbuf init strbuf 	software developer 
addch hexval 	manual current 
hexval strbuf addch 	processors execute 
xmalloc strbuf 	instructions 
init strbuf addch 	order perspective 
strbuf addch 	processors multiprocessor 
strbuf addch encoding 	system intel 
reencode error 	reserves right 
strbuf attach strlen 	change compiler 
strlen strstr 	optimizer 
strbuf reset strbuf 	could order 
reset isspace 	instructions weren 
strbuf strchr strbuf 	form barrier 
strstr strbuf 	therefore even 
tolower decode segment 	running architecture 
decode segment 	need 
convert utf 	memory barriers 
strbuf addbuf strbuf 	everything least 
release free 	optimizer barrier 
strbuf addstr strbuf 	necessary memory 
reset strbuf 	barrier outputs 
addbuf strbuf release 	inputs 
strbuf release 	clobbers hopefully 
strbuf release strlen 	enough keep 
cmp header 	compiler reordering 
strbuf decode header 	instructions around 
handle header 	one outputs 
cmp header strlen 	inputs 
strbuf decode 	clobbers outputs 
header strbuf insert 	inputs clobbers 
handle content 	outputs inputs 
type cmp header 	clobbers outputs 
strlen strbuf 	inputs clobbers 
decode header handle 	much 
content transfer 	slower simple 
encoding cmp 	memory barrier 
header strlen strbuf 	semantics mutex 
decode header 	unlock make 
handle message starts 	work jemalloc 
isspace format 	inlines 
patch separator starts 	memtest.c progress 
isspace strcmp 	printed progress 
handle header strbuf 	full title 
release decode 	pass curr 
segment decode segment 	size bytes 
strbuf reset 	interactive 
strbuf addbuf strbuf 	words bytes 
release free 	interactive step 
starts starts starts 	words iwords 
isspace isspace 	rseed rout 
isspace memcmp memcmp 	bytes sym 
memcmp memcmp 	interactive 
check header convert 	step words 
utf scissors 	iwords bytes 
line strbuf 	interactive words 
setlen strbuf release 	bytes pass 
patchbreak strbuf 	times interactive 
addf strbuf addbuf 	errors 
fwrite handle 	bytes passes 
commit msg handle 	interactive pass 
patch starts 	errors bytes 
starts strbuf getline 	passes backup 
strbuf rtrim 	end left 
rfc header strbuf 	errors 
addch fgetc 	pass len 
ungetc strbuf getline 	megabytes passes 
strbuf rtrim 	bytes megabytes 
strbuf addbuf strbuf 	passes fflush 
release strbuf 	fflush memtest 
getline multipart boundary 	progress 
strbuf addch 	step exit 
memcmp strbuf 	memtest progress 
release free error 	step xorshift 
handle filter 	star next 
strbuf release find 	memtest progress 
boundary strbuf 	step 
reset read one 	memtest progress 
header line 	step exit 
check header strbuf 	memtest progress 
release strbuf 	step memtest 
getline strbuf addch 	progress start 
find boundary 	memtest 
strbuf getwholeline multipart 	compare memtest 
boundary handle 	progress end 
filter strbuf reset 	memtest progress 
handle boundary 	start memtest 
decode transfer encoding 	addressing memtest 
strbuf insert 	progress 
strbuf reset strbuf 	end memtest 
split strbuf 	progress start 
addbuf handle 	memtest fill 
filter strbuf list 	random memtest 
free handle 	progress 
filter strbuf release 	end memtest 
strchr strlen 	compare times 
strcmp cleanup subject 	memtest progress 
cleanup space 	start memtest 
output header lines 	fill memtest 
strcmp cleanup 	progress 
space handle cleanup 	end memtest 
space fopen 	compare times 
perror fopen perror 	memtest progress 
fclose xcalloc 	start memtest 
xcalloc isspace fgetc 	fill memtest 
ungetc read 	progress 
one header line 	end memtest 
check header 	compare times 
handle body fwrite 	memcpy memtest 
fclose fclose 	addressing memtest 
handle info 	fill random 
strbuf release starts 	memtest 
git config 	compare times 
strcmp git config 	memtest compare 
memset strbuf 	times memtest 
init strbuf init 	compare times 
strbuf init 	memtest fill 
strbuf init git 	memtest 
config strbuf 	compare times 
release strbuf release 	memtest compare 
strbuf release 	times memtest 
free strbuf release 	compare times 
free strbuf 	memtest fill 
release free free 	memtest 
strbuf release 	compare times 
john doe johndoe 	memtest compare 
fallback bother 	times memtest 
already mail address 	compare times 
already one 	memcpy malloc 
email take 	strerror 
confusing lines pick 	exit memtest 
around possibly 	test free 
delimited pair email 	ioctl memtest 
part remainder 	alloc test 
name could john 	exit copyright 
doe john 	salvatore 
doe john doe 	sanfilippo antirez 
john doe 	gmail dot 
john zzz doe 	rights reserved 
john doe 	redistribution use 
comment removed email 	source binary 
part extra 	forms 
spaces could stay 	without modification 
email trim 	permitted provided 
ends possibly removing 	following conditions 
pair end 	met redistributions 
cases note 	source code 
note note claim 	must 
full mime 	retain copyright 
attempt enough heuristics 	notice list 
grok mime 	conditions following 
encoded patches often 	disclaimer redistributions 
found mailing 	binary form 
lists example even 	must 
treat header 	reproduce copyright 
lines insensitively input 	notice list 
space keep 	conditions following 
bother finding end 	disclaimer documentation 
space since 	materials provided 
later normalize anyway 	distribution 
drop trailing 	neither name 
newline rfc decode 	redis names 
possibly place 	contributors may 
garbage pessimism process 	used endorse 
encoded word 	promote products 
begins something 	derived 
encoded word lose 	software without 
something unless 	specific prior 
processed encoded word 	written permission 
lws one 	software provided 
process iso foo 	copyright holders 
iso foo 	contributors 
cbar baz search 	express implied 
interesting parts 	warranties including 
unwrap encoding optionally 	limited implied 
normalize meta 	warranties merchantability 
information utf content 	fitness particular 
stuff inbody 	purpose 
stuff beginning diff 	disclaimed shall 
header cvs 	copyright owner 
index line filename 	contributors liable 
starts patches 	direct indirect 
without headers manual 	incidental special 
separator space 	exemplary 
followed filename 	consequential damages 
whitespace mark must 	including limited 
least bytes 	procurement substitute 
even though arbitrary 	goods services 
cruft line 	loss use 
cut order avoid 	data 
misidentification perforation 	profits business 
must occupy third 	interruption however 
visible width 	caused theory 
line dashes scissors 	liability whether 
must occupy 	contract strict 
half perforation trim 	liability 
first blank 	tort including 
line commit message 	negligence otherwise 
ignoring body 	arising way 
headers normalize log 	use software 
message utf 	even advised 
input error already 	possibility 
may already 	damage printed 
read secondary 	chars screen 
headers purge give 	wide progress 
clean restart 	bar many 
section defines loosest 	chars write 
possible field 	fill 
name optional fields 	progress bar 
optional field 	cursor home 
field name unstructured 	clear screen 
crlf field 	fill dots 
name ftext ftext 	cursor home 
count mbox 	clear 
headers headers first 	current line 
part line 	print title 
empty line valid 	cursor home 
rfc header 	clear screen 
stop header newline 	test addressing 
need eat 	fine 
continuation lines yuck 	every location 
header folding 	populated address 
hit end 	verified test 
boundary pop current 	fast may 
boundary stack 	detect asap 
technically won happen 	big 
multipart boundary 	issues memory 
fail first skip 	subsystem fill 
next boundary 	test fill 
defaults slurp section 	words stepping 
info replenish 	single page 
line skip first 	every 
boundary process 	write touch 
boundary lines flush 	pages smallest 
leftover unwrap 	amount time 
transfer encoding prepend 	reducing effectiveness 
previous lines 	caches making 
decoded line may 	hard 
contain multiple 	transfer pages 
lines pass 	swap test 
one chunk time 	call rand 
handle filter 	since system 
last line line 	may completely 
save later 	unable 
chunk saved prev 	handle library 
appended next 	calls resort 
iteration read line 	prng uses 
nul print 	local state 
inbody headers output 	use xorshift 
patch file 	prng 
process email header 	words per 
perhaps others 	iteration random 
another stupid program 	seed like 
one parsing 	memtest fill 
headers email figure 	random uses 
authorship subject 	two 
needswork might want 	specified values 
optional git 	fill memory 
directory discovery 	alternated way 
mailinfo usage argc 	words per 
argv prefix 	iteration test 
def charset status 	specified 
setup mailinfo 	memory number 
commit output encoding 	bytes must 
strcmp strcmp 	multiple interactive 
strcmp strcmp strcmp 	program exists 
strcmp starts 	error prints 
strcmp strcmp strcmp 	ascii 
usage usage 	arts show 
mailinfo clear mailinfo 	progresses instead 
john doe 	interactive used 
johndoe fallback bother 	api call 
already mail 	returns memory 
address already one 	errors 
email take 	found errors 
confusing lines pick 	detected version 
around possibly 	memtest test 
delimited pair 	tests memory 
email part remainder 	small pieces 
name could 	order 
john doe john 	restore memory 
doe john 	content exit 
doe john doe 	one problem 
john zzz 	approach cache 
doe john doe 	avoid real 
comment removed 	memory 
email part extra 	accesses test 
spaces could 	big chunks 
stay email trim 	memory time 
ends possibly 	need backup 
removing pair end 	stack allocator 
cases note 	may 
note note claim 	usable may 
full mime 	already memory 
attempt enough heuristics 	condition trash 
grok mime 	cache useless 
encoded patches 	memory accesses 
often found mailing 	fill 
lists example 	compare cycles 
even treat header 	random accesses 
lines insensitively 	memtest decache 
input space keep 	size performed 
bother finding 	start end 
end space since 	region 
later normalize 	fill compare 
anyway drop trailing 	cycles order 
newline rfc 	trash cache 
decode possibly place 	test across 
garbage pessimism 	page boundaries 
process encoded word 	test 
begins something 	single page 
encoded word lose 	test single 
something unless 	page back 
processed encoded 	single page 
word lws one 	test two 
process iso 	pages 
foo iso foo 	since code 
cbar baz 	test single 
search interesting parts 	page least 
unwrap encoding 	two always 
optionally normalize meta 	test even 
information utf 	number 
content stuff inbody 	pages backup 
stuff beginning 	restore perform 
diff header cvs 	interactive test 
index line 	allocating specified 
filename starts patches 	number megabytes 
without headers 	microbench.c 
manual separator space 	timer nwarmup 
followed filename 	niter func 
whitespace mark must 	compare funcs 
least bytes 	func timer 
even though 	start func 
arbitrary cruft line 	timer 
cut order 	stop malloc 
avoid misidentification perforation 	test fail 
must occupy 	free mallocx 
third visible width 	test fail 
line dashes 	free compare 
scissors must occupy 	funcs 
half perforation 	malloc test 
trim first blank 	fail dallocx 
line commit 	malloc test 
message ignoring body 	fail sdallocx 
headers normalize 	compare funcs 
log message utf 	compare 
input error 	funcs malloc 
already may already 	test fail 
read secondary 	malloc usable 
headers purge give 	size free 
clean restart 	malloc test 
section defines 	fail 
loosest possible field 	sallocx test 
name optional 	fail free 
fields optional field 	compare funcs 
field name 	malloc test 
unstructured crlf field 	fail nallocx 
name ftext 	test 
ftext count mbox 	fail free 
headers headers 	compare funcs 
first part line 	test compiler 
empty line 	optimize away 
valid rfc header 	free malloc 
stop header 	min.c 
newline need eat 	lua gettop 
continuation lines 	lua isstring 
yuck header folding 	lua tostring 
hit end 	lua isnil 
boundary pop current 	lua isboolean 
boundary stack 	lua 
technically won 	toboolean lua 
happen multipart boundary 	lua topointer 
fail first 	lua open 
skip next boundary 	lua lua 
defaults slurp 	dofile lua 
section info replenish 	tostring 
line skip 	lua close 
first boundary process 	min minimal 
boundary lines 	lua interpreter 
flush leftover unwrap 	loads stdin 
transfer encoding 	minimal error 
prepend previous lines 	handling 
decoded line 	interaction standard 
may contain multiple 	library print 
lines pass 	function mq.c 
one chunk time 	timeout sleep 
handle filter 	nanosleep sleep 
last line 	approximately 
line save later 	nanoseconds lower 
chunk saved 	upper bound 
prev appended next 	sleep time 
iteration read 	guaranteed msg 
line nul print 	arg msg 
inbody headers 	arg 
output patch file 	msg receiver 
process email 	senders init 
header perhaps others 	count ptr 
another stupid 	tryget put 
program one parsing 	count ptr 
headers email 	tryget 
figure authorship subject 	put ptr 
needswork might 	fini ptr 
want optional git 	dallocx mallocx 
directory discovery 	ptr put 
mailinfo.h input output 	init thd 
patchfile name 	create 
email keep 	thd create 
subject keep non 	thd thd 
patch brackets 	fini test 
subject message use 	sleep approximately 
scissors use 	nanoseconds lower 
inbody headers metainfo 	upper 
charset content 	bound sleep 
content top charset 	time guaranteed 
message patch 	mq.c timeout 
lines filter stage 	sleep nanosleep 
header stage 	sleep approximately 
hdr data hdr 	nanoseconds 
data log 	lower upper 
message input error 	bound sleep 
mailinfo mailinfo 	time guaranteed 
msg patch mailinfo 	msg arg 
still reading 	msg arg 
log copying patch 	msg 
still checking 	receiver senders 
body headers 	init count 
mailinfo mailmap.c format 	ptr tryget 
git mailmap 	put count 
file git mailmap 	ptr tryget 
blob name 	put 
email name email 	ptr fini 
namemap map 	ptr dallocx 
name email old 	mallocx ptr 
name old 	put init 
email item buffer 	thd create 
name email 	thd 
allow empty email 	create thd 
left right 	thd fini 
nstart nend map 	test sleep 
buffer repo 	approximately nanoseconds 
abbrev email abbrev 	lower upper 
abblen len 	bound 
map filename repo 	sleep time 
abbrev buffer 	guaranteed mq.h 
map buf 	simple templated 
repo abbrev end 	message queue 
map name 	implementation relies 
repo abbrev sha 	mutexes 
buf size 	synchronization reduces 
map repo abbrev 	portability issues 
err map 	given following 
map len cmp 	setup msg 
map email 	msg msg 
emaillen name namelen 	msg 
item subitem 	msg link 
debug debug str 	message data 
debug str 	gen msg 
free free debug 	link api 
debug debug 	follows init 
str debug str 	fini 
free free 	count msg 
list clear func 	tryget msg 
strcasecmp list 	put msg 
insert xcalloc 	msg message 
debug free xstrdup 	queue linkage 
free xstrdup 	embedded 
xcalloc debug xstrdup 	message treated 
xstrdup list 	externally opaque 
insert debug debug 	need initialize 
str debug 	clean externally 
str debug str 	fini perform 
strchr strchr 	cleanup 
isspace isspace strlen 	messages since 
strncmp free 	knows nothing 
isspace xstrdup parse 	payloads sleep 
name email 	time max 
parse name email 	second mtx.c 
mapping fopen 	mtx 
error strerror fgets 	attr mtx 
read mailmap 	mtx mtx 
line fclose 	initialize critical 
strchrnul read mailmap 	section spin 
line sha 	count pthread 
read sha file 	mutexattr 
error error 	init pthread 
read mailmap free 	mutexattr settype 
bare repository 	pthread mutex 
read mailmap file 	init pthread 
read mailmap 	mutexattr destroy 
blob read mailmap 	pthread 
file debug 	mutexattr destroy 
list clear func 	pthread mutex 
debug list 	destroy enter 
find insert index 	critical section 
strncasecmp debug 	spin pthread 
debug str debug 	mutex 
str lookup 	critical section 
prefix lookup prefix 	spin unlock 
debug strlen 	pthread mutex 
strlen debug 	unlock mtx 
debug str debug 	varg arg 
str debug 	arg 
name email simple 	thds mtx 
mail name 	init mtx 
email complex mail 	mtx unlock 
name matching 	mtx fini 
systems min definition 	mtx mtx 
strcasecmp non 	unlock 
implementation supplied anywhere 	mtx init 
unusual cannot 	thd create 
take address function 	thd test 
store namemap 	mtx.c mtx 
cmp workaround assign 	attr mtx 
strcasecmp directly 	mtx 
namemap cmp know 	mtx initialize 
systems matter 	critical section 
unusual replace current 	spin count 
name email 	pthread mutexattr 
simple entry 	init pthread 
whitespace beginning end 	mutexattr 
name nothing 	settype pthread 
look entry map 	mutex init 
match len 	pthread mutexattr 
len nul could 	destroy pthread 
exact match 	mutexattr 
map entry matches 	destroy pthread 
exactly including 	mutex destroy 
cruft end beyond 	enter critical 
len match 	section spin 
len looking asked 	pthread mutex 
whole got 	critical 
nothing matching entry 	section spin 
exist map 	unlock pthread 
exact match overlong 	mutex unlock 
key location 	mtx varg 
overlong key would 	arg arg 
inserted must 	thds 
come real 	mtx init 
location key one 	mtx mtx 
exists points 	unlock mtx 
key definitely prefix 	fini mtx 
map len 	mtx unlock 
found otherwise may 	mtx 
len followed 	init thd 
sorts later len 	create thd 
keep trying 	test mtx.h 
item multiple items 	mtx mtx 
look name 	mtx mtx 
name found choose 	mtx 
simple entry 	slightly simplified 
mailmap.h map repo 	version malloc 
abbrev map 	mutex code 
map email emaillen 	duplication unfortunate 
name namelen 	allocator bootstrapping 
mailsplit.c git 	considerations 
mailsplit usage line 	would leak 
len colon 	test infrastructure 
buf keep mbox 	malloc mutex 
name allow 	used directly 
bare output status 	tests multi.c 
bare list 	multistring 
path dir dent 	orig argv 
name subs 	orig argc 
sub ret maildir 	orig cmd 
dir prec 	must propagate 
skip file ret 	key clients 
list name 	clients 
file dir allow 	key clients 
bare prec 	dbid decr 
skip ret peek 	count zfree 
file done 	zfree zrealloc 
name argc argv 	zmalloc memcpy 
prefix num 	incr 
allow bare 	count free 
dir argp stdin 	client multi 
arg arg 	state init 
argstat ret memcmp 	client multi 
isdigit isdigit 	state unwatch 
isdigit isdigit isdigit 	keys 
strtol line 	reply error 
exit open die 	reply reply 
errno xfdopen 	error discard 
strbuf setlen strbuf 	transaction reply 
addch fwrite 	create propagate 
die errno strbuf 	decr 
getwholeline feof 	count reply 
die errno line 	error reply 
fclose free 	discard transaction 
xstrfmt opendir error 	unwatch keys 
strerror readdir 	reply multi 
free xstrfmt list 	bulk 
insert closedir 	len exec 
free isdigit 	command propagate 
isdigit strtol strtol 	multi call 
populate maildir 	discard transaction 
list free xstrfmt 	list length 
fopen error 	replication 
strerror strbuf getwholeline 	feed monitors 
error strerror 	list rewind 
xstrfmt split one 	list next 
free fclose 	list node 
fclose free list 	equal objects 
clear strcmp 	dict 
fopen error isspace 	fetch list 
fgetc ungetc 	create dict 
strbuf getwholeline error 	incr count 
xstrfmt split 	list node 
one free fclose 	tail zmalloc 
strtol usage 	incr 
strtol usage strcmp 	count list 
die usage 	node tail 
split mbox 	list length 
error stat error 	list rewind 
strerror isdir 	list next 
split maildir split 	list 
mbox error 	node dict 
totally braindamaged mbox 	fetch server 
splitter program 	info list 
splits mbox list 	del node 
files process 	list search 
year close enough 	key 
called first 	list length 
line potentially already 	dict list 
buf normally 	del node 
begin unix line 	decr count 
write specified 	zfree dict 
file copy searching 	size 
line begins 	dict fetch 
something looks 	list rewind 
like date format 	list next 
done one 	list node 
message strtol advanced 	list rewind 
pointers empty 	list 
stdin flags marks 	next list 
end options 	node list 
backwards compatibility specified 	rewind list 
accept mbox 	next list 
dir dir usage 	node dict 
argument parse 	find 
stdin malloc.c.h arena 	reply error 
ordblks smblks 	watch key 
hblks hblkhd usmblks 	reply unwatch 
fsmblks uordblks 	keys reply 
fordblks keepcost capacity 	copyright salvatore 
locked msp 	sanfilippo 
capacity locked msp 	antirez gmail 
enable msp 	dot rights 
bytes msp 	reserved redistribution 
mem msp mem 	use source 
newsize msp 	binary forms 
elements elem size 	without 
msp alignment 	modification permitted 
bytes msp elements 	provided following 
elem size 	conditions met 
chunks msp elements 	redistributions source 
sizes chunks 	code must 
msp msp msp 	retain 
mem msp 	copyright notice 
msp pad dest 	list conditions 
exchange comp 	following disclaimer 
target getpagesize dev 	redistributions binary 
zero size 	form must 
ptr size ptr 	reproduce 
ptr size 	copyright notice 
minfo cptr threadid 	list conditions 
malloc mutex 	following disclaimer 
spins cmp 	documentation materials 
val ret prev 	provided distribution 
ret cmp 	neither 
val ret threadid 	name redis 
malloc mutex 	names contributors 
threadstruct threadid spins 	may used 
malloc mutex 	endorse promote 
attr malloc mutex 	products derived 
malloc mutex 	software 
status stat prev 	without specific 
foot head 	prior written 
prev foot head 	permission software 
child parent 	provided copyright 
index size next 	holders contributors 
sflags smallmap 	express 
treemap dvsize topsize 	implied warranties 
least addr 	including limited 
top trim check 	implied warranties 
release checks 	merchantability fitness 
magic smallbins 	particular purpose 
treebins footprint max 	disclaimed 
footprint mflags 	shall copyright 
mutex seg extp 	owner contributors 
exts magic 	liable direct 
page size granularity 	indirect incidental 
mmap threshold 	special exemplary 
trim threshold mflags 	consequential 
mparams addr 	damages including 
malloc corruption error 	limited procurement 
count mem 	substitute goods 
magic psize gsize 	services loss 
system info 	use data 
buf param number 	profits 
val len 	business interruption 
next mem head 	however caused 
tindex tsize 	theory liability 
idx empty empty 	whether contract 
size size 	strict liability 
sidx tidx 	tort 
sizebits sum lastq 	including negligence 
total nfree 	otherwise arising 
mfree sum maxfp 	way use 
used mmsize 	software even 
offset psize oldp 	advised possibility 
oldsize offset 	damage 
oldmmsize newmmsize newp 	multi exec 
psize psize 	client state 
offset bin newbase 	initialization multi 
oldbase oldfirst 	exec release 
psize qsize tsize 	resources associated 
dsize nsize 	multi 
tbase tsize mmapped 	exec state 
old top 	command multi 
oldsp old end 	commands queue 
ssize rawsp 	flag transacation 
offset asp 	dirty exec 
csp tnext nfences 	exec 
nextp psize 	fail called 
tbase tsize mmap 	every time 
flag mem 	error queueing 
asize esize end 	command send 
rsize asize 	multi command 
end ssize oldbase 	slaves 
rsize released 	aof file 
nsegs pred size 	check exec 
next psize 	command implementation 
pad released unit 	information need 
extra newsize 	propagate multi 
old rel rsize 	exec 
idx sizebits 	aof slaves 
rst trem leftbits 	check need 
leastbit trem 	abort exec 
rsize leastbit trem 	watc hed 
oldmem bytes 	key touched 
oldp oldsize 	previous 
next newp extra 	error queueing 
rsize remainder 	commands failed 
newsize newtopsize newtop 	exec first 
newmem alignment 	returns multi 
bytes req mem 	bulk nil 
leader trailer 	technically 
pos newp leadsize 	error special 
newsize size 	behavior second 
remainder size remainder 	execabort error 
elements sizes 	returned exec 
opts chunks element 	queued commands 
size contents 	unwatch 
size size mem 	asap otherwise 
remainder size 	waste cpu 
marray chunk enabled 	cycles propagate 
size chunk 	multi request 
size bytes mem 	encounter first 
idx smallbits 	write 
rsize leftbits 	way deliver 
leastbit rsize dvs 	multi exec 
rsize mem 	block whole 
psize next prevsize 	aof replication 
prev tsize 	link consistency 
dsize nsize elements 	atomicity 
elem size 	guarantees commands 
mem req oldmem 	may alter 
bytes alignment 	argc argv 
bytes elements elem 	restore mstate 
size chunks 	make sure 
elements sizes chunks 	exec 
bytes pagesz 	command propagated 
bytes pagesz pad 	well multi 
result param 	already propagated 
number mem tbase 	send exec 
tsize msize 	clients waiting 
msp capacity locked 	data 
msize tsize 	monitor since 
tbase capacity 	natural order 
locked msize msp 	commands execution 
enable ret 	actually mutli 
msp freed size 	exec commands 
flag msp 	inside 
bytes mem idx 	transaction instead 
smallbits rsize 	exec flagged 
leftbits leastbit rsize 	cmd skip 
dvs rsize 	monitor command 
msp mem psize 	table correct 
next prevsize 	ordering 
prev tsize dsize 	watch cas 
nsize msp 	alike multi 
elements elem size 	exec implementation 
mem req 	uses per 
msp oldmem bytes 	hash table 
msp alignment 	mapping 
bytes msp 	keys list 
elements elem size 	clients watc 
chunks msp 	hing keys 
elements sizes chunks 	given key 
msp pad 	going modified 
result msp msp 	mark 
result msp 	associated clients 
result msp mem 	dirty also 
param number 	every client 
alloc alloc query 	contains list 
free thr 	watc hed 
sched readfsdword current 	keys 
current current 	possible watch 
interlockedexchange sleep interlockedexchange 	keys client 
interlockedexchange pthread 	freed unwatch 
mutexattr init pthread 	called client 
mutexattr settype 	watched keys 
pthread mutex init 	list 
pthread mutexattr 	need use 
destroy interlockedcompareexchange 	watched key 
initialize critical section 	structures order 
interlockedexchange sleep 	identify key 
init malloc mutex 	redis need 
acquire malloc 	key 
system info initial 	name watch 
open read 	specified key 
close size tick 	check already 
count size 	watching key 
time release malloc 	key already 
ensure initialization 	watched 
aligned chunk mem 	key already 
address segment 	watched key 
holding aligned chunk 	list keys 
mem address 	watched client 
pinuse pinuse chunk 	unwatch keys 
plus offset 	watched 
chunksize mmapped use 	client clean 
mmap aligned 	exec dirty 
chunk mem 	flag caller 
address small chunk 	lookup watched 
plus offset 	key clients 
chunk plus offset 	list 
check chunk 	client list 
cinuse next pinuse 	kill entry 
mmapped pinuse 	client watched 
next chunk prev 	key client 
chunk mmapped 	watched list 
check mmapped chunk 	touch 
chunksize chunk 	key key 
plus offset check 	watc hed 
chunk cinuse 	client next 
next pinuse mmapped 	exec fail 
aligned chunk 	mark clients 
mem pinuse cinuse 	watching 
mem chunk 	key client 
check inuse chunk 	dirty cas 
mmapped chunksize 	check already 
compute index 	watching key 
minsize index minsize 	flushdb flushall 
index check 	watched 
chunk chunksize cinuse 	keys present 
next pinuse 	flush deleted 
check check chunksize 	effect flushing 
chunksize treebin 	operation touched 
check smallbin chunksize 	dbid getting 
check free 	flush 
chunk small index 	flushall operation 
chunksize chunksize 	flushed every 
next chunk check 	client check 
inuse chunk 	waited keys 
chunksize small small 	every watched 
index smallbin 	key 
smallmap marked compute 	matching specified 
index treemap 	key exists 
marked treebin 	mark client 
leftshift index chunksize 	dirty key 
initialized align 	removed mutex.c 
chunk pinuse segment 	isthreaded 
holds chunksize 	postpone init 
cinuse bin find 	postponed mutexes 
check inuse 	restrict pthread 
chunk bin find 	attr restrict 
cinuse check 	attr start 
free chunk next 	routine 
chunk check 	arg control 
smallbin check treebin 	mutex calloc 
check chunk 	mutex attr 
chunksize bin find 	mutex mutex 
check top 	mutex dlsym 
chunk bin find 	malloc 
traverse check 	write abort 
ensure initialization preaction 	pthread pthread 
check malloc 	create fptr 
state initialized 	initialize srw 
align chunk segment 	initialize critical 
holds chunksize 	section 
cinuse next chunk 	spin count 
postaction ensure 	pthread mutex 
initialization preaction check 	init calloc 
malloc state 	pthread mutexattr 
initialized align chunk 	init pthread 
segment holds 	mutexattr 
cinuse chunksize next 	settype pthread 
chunk postaction 	mutex init 
mmap align call 	pthread mutexattr 
direct mmap 	destroy pthread 
align offset chunk 	mutexattr destroy 
mem mchunkptr 	malloc 
mark inuse foot 	mutex malloc 
chunk plus 	mutex unlock 
offset chunk plus 	malloc mutex 
offset aligned 	unlock malloc 
chunk mem 	mutex init 
check mmapped chunk 	malloc 
chunk mem 	abort pthread 
chunksize small mmap 	mutex init 
align call 	calloc data 
mremap mchunkptr mark 	intercept pthread 
inuse foot 	create calls 
chunk plus offset 	order 
chunk plus 	toggle isthreaded 
offset check mmapped 	process goes 
chunk align 	multi threaded 
offset chunk mem 	mutex.h postponed 
mchunkptr chunk 	next isthreaded 
plus offset smallbin 	mutex 
treebin init 	mutex mutex 
bins align chunk 	mutex mutex 
align chunk 	mutex mutex 
chunk plus offset 	mutex acquire 
size pinuse 	srw exclusive 
inuse chunk 	enter 
pinuse check top 	critical section 
chunk size 	spin pthread 
pinuse free chunk 	mutex release 
cinuse chunksize 	srw exclusive 
unlink chunk chunk 	critical section 
plus offset 	spin 
free pinuse insert 	unlock pthread 
chunk check 	mutex unlock 
free chunk check 	jemalloc types 
malloced chunk 	jemalloc structs 
chunk mem chunk 	undo definition 
mem segment 	jemalloc 
holding pad request 	externs jemalloc 
align offset 	inlines net.c 
chunk mem msegmentptr 	type str 
chunk mem 	type prefix 
chunk plus offset 	buf len 
init top 	type 
aligned size 	blocking flags 
pinuse inuse chunk 	interval val 
chunk plus 	yes timeout 
offset chunk plus 	wfd msec 
offset free 	res err 
pinuse insert chunk 	errlen 
check top 	addr port 
chunk ensure initialization 	timeout source 
use mmap 	addr port 
mmap alloc use 	hints servinfo 
noncontiguous segment 	bservinfo blocking 
holding acquire malloc 	bound 
call morecore 	buf buf 
granularity align page 	buf addr 
aligned page 	port timeout 
align call morecore 	addr port 
granularity align 	timeout 
call morecore 	source addr 
granularity align call 	path timeout 
morecore call 	blocking close 
morecore disable contiguous 	snprintf strerror 
release malloc 	redis error 
granularity align call 	setsockopt 
mmap granularity 	redis error 
align acquire malloc 	errno redis 
call morecore 	context close 
call morecore release 	socket redis 
malloc initialized 	error errno 
init bins init 	redis 
top next 	reuse addr 
chunk mem chunk 	fcntl redis 
init top 	error errno 
size segment segment 	redis context 
holds init 	close fcntl 
top segment prepend 	redis 
alloc segment 	error errno 
chunk plus 	redis context 
offset size pinuse 	close setsockopt 
inuse chunk 	redis error 
check top chunk 	strerror setsockopt 
check malloced 	redis 
chunk chunk mem 	error strerror 
chunk mem 	setsockopt redis 
mmapped segment segment 	error strerror 
align chunk 	setsockopt redis 
chunksize cinuse segment 	error strerror 
holds unlink 	setsockopt 
large chunk call 	redis error 
munmap insert 	strerror setsockopt 
large chunk ensure 	redis error 
initialization initialized 	errno redis 
segment holding segment 	context close 
mmapped segment 	redis 
segment link call 	error errno 
mremap call 	redis context 
munmap acquire 	close poll 
malloc call morecore 	redis error 
call morecore 	errno redis 
call morecore release 	context 
malloc init 	close redis 
top check top 	error errno 
chunk release 	redis context 
unused segments compute 	close redis 
index treebin 	check socket 
leftshift index chunksize 	error 
left bits 	redis error 
idx bit least 	errno redis 
bit compute 	context close 
bit idx treebin 	getsockopt redis 
chunksize leftmost 	error errno 
child size rtcheck 	redis 
address chunk 	error errno 
plus offset chunksize 	setsockopt redis 
rtcheck next 	error errno 
unlink large 	setsockopt redis 
chunk inuse pinuse 	error errno 
size pinuse 	snprintf 
inuse chunk size 	memset getaddrinfo 
pinuse free 	getaddrinfo redis 
chunk insert chunk 	error gai 
chunk mem 	strerror socket 
corruption error action 	redis blocking 
least bit 	getaddrinfo 
compute bit idx 	snprintf gai 
treebin chunksize 	strerror redis 
leftmost child chunksize 	error bind 
rtcheck address 	freeaddrinfo snprintf 
chunk plus offset 	strerror redis 
chunksize rtcheck 	error 
next unlink large 	connect redis 
chunk inuse 	context close 
pinuse size 	redis context 
pinuse inuse chunk 	wait ready 
size pinuse 	redis blocking 
free chunk replace 	redis 
chunk mem 	tcp delay 
corruption error action 	snprintf strerror 
preaction mem 	redis error 
chunk chunksize chunk 	freeaddrinfo redis 
plus offset 	context connect 
rtcheck address cinuse 	tcp 
next pinuse 	redis context 
request size mmapped 	connect tcp 
mmap resize 	redis create 
chunk plus offset 	socket redis 
inuse inuse 	blocking strncpy 
chunk mem chunk 	connect 
plus offset 	redis context 
inuse usage error 	wait ready 
action postaction 	redis blocking 
postaction free 	extracted anet 
check inuse chunk 	work properly 
chunk mem 	hiredis 
malloc overhead memcpy 	error reporting 
free malloc 	copyright salvatore 
request size malloc 	sanfilippo antirez 
mem chunk 	gmail dot 
preaction size mem 	copyright pieter 
chunk size 	noordhuis 
size size chunksize 	pcnoordhuis gmail 
mmapped inuse 	dot rights 
inuse chunk mem 	reserved redistribution 
mmapped chunksize 	use source 
chunk plus offset 	binary forms 
inuse inuse 	without 
chunk mem chunksize 	modification permitted 
size chunk 	provided following 
mem check inuse 	conditions met 
chunk postaction 	redistributions source 
free free 	code must 
chunk mem ensure 	retain 
initialization malloc 	copyright notice 
request size request 	list conditions 
size request 	following disclaimer 
size use mmap 	redistributions binary 
disable mmap 	form must 
malloc enable mmap 	reproduce 
preaction mem 	copyright notice 
chunk chunksize mmapped 	list conditions 
memset chunk 	following disclaimer 
plus offset chunk 	documentation materials 
mem size 	provided distribution 
pinuse inuse chunk 	neither 
chunk mem 	name redis 
request size size 	names contributors 
pinuse inuse 	may used 
chunk chunk plus 	endorse promote 
offset size 	products derived 
pinuse inuse 	software 
chunk request size 	without specific 
check inuse 	prior written 
chunk mem chunk 	permission software 
check inuse 	provided copyright 
chunk mem chunk 	holders contributors 
postaction ensure 	express 
initialization preaction pad 	implied warranties 
request small 	including limited 
index smallbin chunksize 	implied warranties 
small index 	merchantability fitness 
size unlink first 	particular purpose 
small chunk 	disclaimed 
inuse pinuse small 	shall copyright 
index size 	owner contributors 
chunk mem check 	liable direct 
malloced chunk 	indirect incidental 
left bits 	special exemplary 
idx bit least 	consequential 
bit compute 	damages including 
bit idx smallbin 	limited procurement 
chunksize small 	substitute goods 
index size unlink 	services loss 
first small 	use data 
chunk small index 	profits 
size inuse 	business interruption 
pinuse small index 	however caused 
size size 	theory liability 
pinuse inuse chunk 	whether contract 
chunk plus 	strict liability 
offset size pinuse 	tort 
free chunk 	including negligence 
replace chunk mem 	otherwise arising 
check malloced 	way use 
chunk tmalloc small 	software even 
check malloced 	advised possibility 
chunk pad 	damage 
request tmalloc large 	defined hiredis 
check malloced 	socket nonblocking 
chunk chunk plus 	note fcntl 
offset size 	getfl setfl 
pinuse free chunk 	interrupted signal 
size pinuse 	use 
inuse chunk inuse 	timeout strlen 
pinuse chunk 	address found 
mem check malloced 	order since 
chunk chunk 	redis client 
plus offset size 	afford test 
pinuse inuse 	connectivity 
chunk chunk mem 	would latency 
check top 	every connect 
chunk check malloced 	otherwise sensible 
chunk sys 	route could 
alloc postaction mem 	use addresses 
chunk mstate 	available 
magic usage 	connectivity getaddrinfo 
error action preaction 	saves self 
check inuse 	determining need 
chunk rtcheck address 	redis alright 
cinuse chunksize 	reset socket 
chunk plus offset 	blocking 
pinuse call 	connect net.h 
munmap chunk minus 	addr port 
offset rtcheck 	timeout addr 
address unlink chunk 	port timeout 
free pinuse 	source addr 
rtcheck next pinuse 	path 
cinuse trim 	timeout interval 
sys trim size 	extracted anet 
pinuse free 	work properly 
chunk chunksize unlink 	hiredis error 
chunk size 	reporting copyright 
pinuse free chunk 	salvatore 
free pinuse 	sanfilippo antirez 
small insert 	gmail dot 
small chunk check 	copyright pieter 
free chunk 	noordhuis pcnoordhuis 
insert large chunk 	gmail dot 
check free 	rights 
chunk release unused 	reserved redistribution 
segments usage 	use source 
error action postaction 	binary forms 
dlmalloc calloc 	without modification 
must clear mem 	permitted provided 
chunk memset 	following 
dlmalloc dlfree mstate 	conditions met 
mem chunk 	redistributions source 
magic usage error 	code must 
action realloc 	retain copyright 
memalign ialloc ialloc 	notice list 
ensure initialization 	conditions 
dlmemalign ensure initialization 	following disclaimer 
dlmemalign ensure 	redistributions binary 
initialization preaction 	form must 
sys trim postaction 	reproduce copyright 
mallinfo malloc 	notice list 
stats change mparam 	conditions 
mem chunk 	following disclaimer 
cinuse chunksize overhead 	documentation materials 
pad request 	provided distribution 
align chunk mstate 	neither name 
chunk mem 	redis names 
memset initial disable 	contributors 
contiguous init 	may used 
bins next chunk 	endorse promote 
mem chunk 	products derived 
init top size 	software without 
check top 	specific prior 
chunk ensure initialization 	written 
pad request 	permission software 
granularity align 	provided copyright 
call mmap init 	holders contributors 
user mstate 	express implied 
ensure initialization pad 	warranties including 
request init 	limited 
user mstate preaction 	implied warranties 
use mmap 	merchantability fitness 
enable mmap disable 	particular purpose 
mmap postaction 	disclaimed shall 
magic call munmap 	copyright owner 
usage error 	contributors 
action magic usage 	liable direct 
error action 	indirect incidental 
preaction pad request 	special exemplary 
small index 	consequential damages 
smallbin chunksize small 	including limited 
index size 	procurement 
unlink first small 	substitute goods 
chunk inuse 	services loss 
pinuse small 	use data 
index size chunk 	profits business 
mem check 	interruption however 
malloced chunk left 	caused 
bits idx 	theory liability 
bit least bit 	whether contract 
compute bit 	strict liability 
idx smallbin chunksize 	tort including 
small index 	negligence otherwise 
size unlink first 	arising 
small chunk 	way use 
small index size 	software even 
inuse pinuse 	advised possibility 
small index size 	damage networking.c 
size pinuse 	pos reply 
inuse chunk chunk 	cur 
plus offset 	len available 
size pinuse free 	tail tail 
chunk replace 	len tail 
chunk mem 	obj buf 
check malloced chunk 	len len 
tmalloc small 	len 
check malloced chunk 	err fmt 
pad request 	len status 
tmalloc large check 	fmt node 
malloced chunk 	length len 
chunk plus offset 	next dbuf 
size pinuse 	sbuf 
free chunk size 	dlen slen 
pinuse inuse 	prefix buf 
chunk inuse pinuse 	len length 
chunk mem 	obj len 
check malloced chunk 	obj len 
chunk plus 	buf 
offset size pinuse 	len dst 
inuse chunk 	src flags 
chunk mem check 	err err 
top chunk 	privdata mask 
check malloced 	cport cfd 
chunk sys alloc 	max 
postaction mem 	cip privdata 
chunk mstate magic 	mask cfd 
usage error 	max handler 
action preaction check 	installed totwritten 
inuse chunk 	objlen objmem 
rtcheck address cinuse 	privdata 
chunksize chunk 	mask processed 
plus offset pinuse 	prevcmd newline 
call munmap 	argc argv 
chunk minus offset 	aux querylen 
rtcheck address 	pos client 
unlink chunk free 	newline 
pinuse rtcheck 	qblen privdata 
next pinuse cinuse 	mask nread 
trim sys 	readlen qblen 
trim size 	remaining bytes 
pinuse free chunk 	longest output 
chunksize unlink 	list 
chunk size pinuse 	biggest input 
free chunk 	buffer bib 
free pinuse small 	client peerid 
insert small 	peerid len 
chunk check free 	peerid client 
chunk insert 	flags 
large chunk check 	events emask 
free chunk 	client client 
release unused segments 	addr type 
usage error 	skipme close 
action postaction magic 	client moreargs 
usage error 	tmp 
action malloc calloc 	len duration 
must clear 	argc argv 
mem chunk memset 	argc argv 
mspace malloc 	newval oldval 
mspace free 	list item 
mem chunk mstate 	size 
magic usage 	name used 
error action realloc 	mem elapsed 
magic usage 	client slave 
error action memalign 	events end 
magic usage 	iterations count 
error action ialloc 	events 
magic usage 	sds alloc 
error action ialloc 	ptr zmalloc 
magic preaction 	size server 
sys trim postaction 	info sds 
usage error 	zmalloc size 
action magic malloc 	zmalloc 
stats usage 	size incr 
error action magic 	count equal 
usage error 	objects zmalloc 
action magic usage 	anet non 
error action 	block anet 
magic usage 	enable 
error action mallinfo 	tcp delay 
mem chunk 	anet keep 
cinuse chunksize overhead 	alive create 
change mparam 	file close 
version aka dlmalloc 	zfree sdsempty 
malloc free 	list 
realloc written doug 	create list 
lea released 	free method 
domain explained http 	list dup 
creativecommons licenses 	method dict 
publicdomain send questions 	create list 
comments complaints 	create 
performance data etc 	dict create 
oswego edu 	list create 
version pre mon 	list free 
nov gee 	method list 
note may updated 	match method 
version malloc 	list 
obtainable ftp 	node tail 
gee oswego edu 	init client 
pub misc 	multi state 
malloc check installing 	client pending 
quickstart library 	replies list 
one file simplify 	node 
common usage 	head server 
ftp compile link 	list length 
another program 	list last 
compile time options 	list node 
reasonable values 	dup decr 
use platforms might 	count 
later want 	list node 
step various compile 	list node 
time tuning 	list length 
options convenience include 	memcpy list 
file code 	length incr 
malloc ftp 	count 
gee oswego edu 	list node 
pub misc 	tail sds 
malloc really need 	used memory 
file unless 	list node 
call functions defined 	list last 
system include 	sdslen 
files file contains 	sdslen sds 
excerpts file 	zmalloc size 
needed malloc ansi 	dup last 
systems haven 	needed sdscatlen 
changed compile time 	sdslen sds 
options naming 	zmalloc 
tuning parameters create 	size incr 
malloc include 	count list 
settings cutting point 	node tail 
indicated note 	sds used 
may already library 	memory close 
containing malloc 	client 
version malloc 	output buffer 
example linux might 	limit reached 
still want 	sdsfree list 
use one file 	length list 
customize settings 	node tail 
avoid overheads associated 	create 
library versions 	sds zmalloc 
vital statistics supported 	size list 
pointer size 	node list 
representation bytes size 	last sdslen 
must type 	sdslen sds 
width pointers ancient 	zmalloc 
system declares 	size dup 
size type need 	last needed 
different width 	sdscatlen sdslen 
pointers use previous 	sds zmalloc 
release malloc 	size sdsfree 
supporting alignment bytes 	list 
suffices nearly 	node tail 
current machines 	create sds 
compilers however define 	zmalloc size 
malloc alignment 	close client 
wider necessary bytes 	output buffer 
expense space 	limit 
minimum overhead per 	reached list 
allocated chunk 	length create 
bytes sizes bytes 	list node 
sizes malloced 	tail sds 
chunk hidden word 	used 
overhead holding 	memory list 
size status information 	node list 
additional cross 	last sdslen 
check word footers 	sds zmalloc 
defined minimum 	size dup 
allocated size ptrs 	last 
bytes including 	needed sdscatlen 
overhead ptrs bytes 	sds zmalloc 
including overhead 	size create 
even request 	list node 
zero bytes malloc 	tail sds 
returns pointer 	used 
something minimum allocatable 	memory close 
size maximum 	client output 
overhead wastage number 	buffer limit 
extra bytes 	reached prepare 
allocated requested malloc 	client write 
less equal 	sds 
minimum size requests 	encoded reply 
mmap threshold 	buffer sdslen 
serviced via mmap 	reply list 
worst wastage 	list length 
bytes plus remainder 	reply buffer 
system page 	decoded 
minimal mmap unit 	reply buffer 
typically bytes 	sdslen reply 
security safe optionally 	list decr 
less security 	count server 
malloc refers 	panic prepare 
ability malicious code 	client 
accentuate effects 	write sdsfree 
errors example freeing 	reply buffer 
space currently 	sdslen sdsfree 
malloc overwriting past 	reply sds 
ends chunks 	list prepare 
code calls malloc 	client 
malloc guarantees 	write reply 
modify memory locations 	buffer reply 
heap variables 	list reply 
even presence usage 	reply reply 
errors routines 	reply error 
additionally detect improper 	length 
frees reallocs 	strlen start 
holds bookkeeping malloc 	sdscatvprintf sdsempty 
corrupted means 	end sdslen 
one aspect 	reply error 
security checks cannot 	length sdslen 
detect possible 	sdsfree 
programming errors footers 	reply reply 
defined nonzero 	reply reply 
allocated chunk carries 	status length 
additional check 	strlen start 
word verify malloced 	sdscatvprintf sdsempty 
space check 	end 
words within execution 	reply status 
program malloc 	length sdslen 
differ across executions 	sdsfree prepare 
externally crafted 	client write 
fake chunks cannot 	list node 
freed improves 	tail 
security rejecting frees 	create list 
reallocs could 	last list 
corrupt heap memory 	node sdscatprintf 
addition checks 	sdsempty sds 
preventing writes 	zmalloc size 
statics always may 	list 
improve security 	node sds 
expense time space 	zmalloc size 
overhead note 	sds used 
footers may also 	memory sdscatlen 
worth mspaces 	sdslen sds 
detected errors cause 	zmalloc 
program abort 	size list 
calling abort instead 	del node 
proceed past 	close client 
errors defining proceed 	output buffer 
error bad 	limit reached 
free effect malloc 	isinf 
encounters bad 	reply bulk 
address caused user 	snprintf snprintf 
overwrites ignore 	reply create 
bad address dropping 	reply bulk 
pointers indices 	decr count 
known memory 	reply 
may appropriate programs 	reply reply 
possible face 	reply reply 
programming errors although 	reply prefix 
may run 	reply reply 
memory dropped memory 	prefix sds 
never reclaimed 	encoded 
like either options 	sdslen reply 
define corruption 	reply prefix 
error action usage 	reply bulk 
error action 	len reply 
anything sure program 	reply reply 
malloc errors 	prefix 
vulnerabilities define insecure 	reply reply 
might might 	reply sds 
provide small performance 	sdscatfmt sdsempty 
improvement safety 	sdslen reply 
safe unless use 	sds reply 
locks defined 	reply 
use locks 	reply bulk 
defined call malloc 	buffer strlen 
free etc 	reply bulk 
surrounded either pthread 	buffer list 
mutex win 	release list 
spinlock depending win 	dup 
especially fast 	memcpy list 
major bottleneck designed 	length create 
provide minimal 	client server 
protection concurrent environments 	log strerror 
provide basis 	close list 
extensions malloc concurrent 	length 
program consider 	write strlen 
instead nedmalloc http 	free client 
www nedprod 	strcmp strcmp 
programs portable nedmalloc 	write strlen 
ptmalloc see 	free client 
http www 	unused 
malloc derived versions 	unused unused 
malloc system 	anet tcp 
requirements combination morecore 	accept server 
mmap munmap 	log server 
malloc use unix 	log accept 
sbrk emulation 	common 
invoked call morecore 	handler unused 
macro mmap 	unused unused 
munmap emulation invoked 	anet unix 
call mmap 	accept server 
call munmap release 	log server 
system memory 	log 
unix systems tends 	accept common 
work best 	handler decr 
morecore mmap enabled 	count list 
win uses 	length list 
emulations alloc also 	first free 
uses common 	client 
library functions 	list search 
like memset compliance 	key server 
believe compliant 	list del 
single unix specification 	node file 
see http 	file close 
www unix also 	list 
svid xpg 	search key 
ansi probably others 	server list 
well overview 	del node 
algorithms fastest space 	list search 
conserving portable 	key server 
tunable malloc ever 	list 
written however 	del node 
among fastest also 	server log 
among space 	replication cache 
conserving portable tunable 	master server 
consistent balance 	log replication 
across factors results 	slave 
good general 	name sdsfree 
purpose allocator 	unblock client 
malloc intensive programs 	dict release 
ways malloc 	unwatch keys 
best fit allocator 	list release 
generally chooses 	pubsub 
best fitting existing 	unsubscribe channels 
chunk request 	pubsub unsubscribe 
ties broken approximately 	patterns dict 
least recently 	release list 
used order strategy 	release list 
normally maintains 	release 
low fragmentation however 	free client 
requests less 	argv unlink 
bytes deviates best 	client close 
fit exactly 	sdsfree list 
fitting available chunk 	search key 
preferring use 	server 
space adjacent used 	list del 
previous small 	node list 
request well 	length refresh 
breaking ties approximately 	good slaves 
recently used 	count replication 
order enhance locality 	handle 
series small 	master disconnection 
allocations large requests 	list search 
relies system 	key server 
memory mapping facilities 	list del 
supported helps 	node decr 
avoid carrying around 	count 
possibly fragmenting 	zfree free 
memory used large 	client multi 
chunks operations 	state sdsfree 
malloc stats mallinfo 	zfree list 
execution times 	node tail 
bounded constant factor 	list 
number bits 	length list 
size counting 	first list 
clearing calloc copying 	node free 
realloc actions 	client list 
surrounding morecore mmap 	del node 
times proportional 	client 
number non contiguous 	pending replies 
regions returned 	write list 
system allocation routines 	node list 
often real 	first sdslen 
time applications optionally 	sds used 
suppress segment 	memory 
traversals segment traversal 	list del 
assures bounded 	node list 
execution even system 	first write 
allocators non 	list del 
contiguous spaces typical 	node list 
expense carrying 	first 
around memory increased 	zmalloc used 
fragmentation implementation 	memory server 
modular seriously 	log strerror 
overuses macros perhaps 	free client 
someday compilers 	client pending 
good job inlining 	replies 
modular code 	file free 
done brute force 	client unused 
expansion enough 	unused write 
seem compilers issue 	client list 
lot warnings 	length list 
code dead unreachable 	rewind 
platforms also 	list next 
intentional uses negation 	list node 
types known 	list del 
cases ignored longer 	node write 
date high 	client client 
level description see 	pending 
http gee 	replies create 
oswego edu html 	file free 
malloc html 	client free 
mspaces mspaces 	client argv 
defined addition malloc 	strchr sdslen 
free etc 	reply 
file also defines 	error protocol 
mspace malloc 	error sdsnewlen 
mspace free etc 	sdssplitargs sdsfree 
versions malloc 	reply error 
routines take mspace 	protocol error 
argument obtained 	sdsrange 
create mspace control 	zfree zmalloc 
bookkeeping mspaces 	sdslen create 
defined versions compiled 	sdsfree zfree 
would like 	cat client 
use allocator allocations 	info sdsempty 
system malloc 	server 
others compile mspaces 	log sdsfree 
something like 	sdsrange server 
mspace mymspace create 	info strchr 
mspace example 	sdslen reply 
define mymalloc 	error protocol 
bytes mspace malloc 	error 
mymspace bytes 	sdslen server 
note need one 	info reply 
instance mspace 	error protocol 
instead use use 	error sdsrange 
prefix relabel 	zfree zmalloc 
malloc similarly create 	server 
local allocators 	info strchr 
storing mspaces locals 	sdslen reply 
example mspace 	error protocol 
tlms tlmalloc size 	error sdslen 
bytes tlms 	reply error 
tlms create mspace 	format 
mspace malloc 	protocol error 
tlms bytes tlfree 	reply error 
mem mspace 	protocol error 
free tlms mem 	sdsrange sdslen 
unless footers 	sds make 
defined mspace 	room 
completely independent cannot 	sdslen sdslen 
allocate one 	create sds 
free another although 	incr len 
conformance weakly 	sdsempty sds 
usage errors always 	make room 
caught footers 	create 
defined chunk carries 	sdsrange sdslen 
around tag 	clients paused 
indicating originating mspace 	process buffer 
frees directed 	process multibulk 
originating spaces compile 	buffer server 
time options 	panic 
careful setting define 	reset client 
values numerical 	process command 
constants type size 	reset client 
systems values 	unused unused 
automatically extended 	sdslen sdslen 
size precision unless 	sds 
explicitly casted 	make room 
also use symbolic 	read server 
values max 	log strerror 
size size one 	free client 
etc win 	server log 
defined win defined 	free 
defining win 	client sds 
sets defaults environment 	incr len 
compilers otherwise 	sdslen cat 
defaults unix beware 	client info 
seem cases 	sdsempty sdscatrepr 
malloc might pure 	server 
drop replacement 	log sdsfree 
win malloc random 	sdsfree free 
looking failures 	client process 
win gdi api 	input buffer 
bits may 	list rewind 
due bugs 	list 
video driver implementations 	next list 
pixel buffers 	node list 
malloc region spans 	length list 
one alloc 	length sdslen 
region dlmalloc uses 	sdslen snprintf 
small granularity 	anet 
pixel buffers may 	format peer 
straddle allocation 	gen client 
regions often microsoft 	peer sdsnew 
allocator avoid 	file events 
alloc free pixel 	sdscatfmt client 
buffers rather 	peer 
malloc possible recompile 	dict size 
malloc larger 	list length 
granularity malloc alignment 	sdslen sdsavail 
size controls 	list length 
minimum alignment malloc 	client output 
chunks must 	buffer 
power two 	memory usage 
least even machines 	sdsempty sds 
smaller alignments 	make room 
would suffice may 	list length 
defined larger 	list rewind 
though note however 	list 
code data 	next list 
structures optimized alignment 	node cat 
mspaces compile 	client info 
support independent allocation 	sdscatlen strcasecmp 
spaces supported 	clients info 
mmap mspaces compile 	reply 
mspace versions 	bulk buffer 
regular versions use 	sdslen sdsfree 
locks causes 	strcasecmp strcasecmp 
call routine surrounded 	reply strcasecmp 
pthread win 	strcasecmp reply 
mutex unlock overridden 	strcasecmp 
per mspace 	strcasecmp reply 
basis mspace 	strcasecmp client 
versions non zero 	type name 
locks used 	reply error 
implementation left functions 	format strcasecmp 
must supplied 	strcasecmp 
manually use spin 	strcasecmp strcasecmp 
locks iff 	reply reply 
use locks gcc 	reply list 
msc uses 	rewind list 
custom spin locks 	next list 
locking currently 	node 
supported platforms gcc 	strcmp client 
recent compilers 	peer client 
otherwise posix locks 	type free 
win critical 	client reply 
sections used footers 	error reply 
provide extra 	reply 
checking dispatching 	strcasecmp sdslen 
placing information footers 	decr count 
allocated chunks 	reply reply 
adds space time 	error decr 
overhead insecure 	count incr 
omit checks usage 	count 
errors heap 	reply strcasecmp 
space overwrites use 	reply bulk 
prefix defined 	reply strcasecmp 
causes compiler prefix 	timeout reply 
routines useful 	pause clients 
want use malloc 	reply 
one part 	reply error 
program regular system 	zmalloc start 
malloc elsewhere 	arg incr 
abort defined abort 	count decr 
defines abort 	count zfree 
failed checks systems 	lookup 
failed check 	command original 
cannot die 	server info 
even print informative 	end free 
message underlying 	client argv 
print routines turn 	zfree lookup 
call malloc 	command 
fail generally best 	original server 
policy simply 	info zrealloc 
call abort useful 	incr count 
many errors 	decr count 
due overwriting show 	lookup command 
address faults 	original 
odd addresses etc 	server info 
rather malloc 	list length 
triggered checks also 	strcasecmp strcasecmp 
abort also 	strcasecmp strcasecmp 
compilers know abort 	client output 
better optimize 	buffer 
code conditionally calling 	memory usage 
proceed error 	client type 
defined controls 	server check 
whether detected bad 	client output 
addresses cause 	buffer limits 
bypassed rather aborting 	cat 
detected bad 	client info 
arguments free realloc 	sdsempty free 
ignored bookkeeping 	client server 
information zeroed upon 	log sdsfree 
detected overwrite 	list rewind 
freed heap space 	list 
thus losing 	next list 
ability ever malloc 	node file 
enabling application 	events client 
proceed proceed error 	pending replies 
defined variable 	write client 
malloc corruption error 	list 
count compiled 	rewind list 
examined see errors 	next list 
occurred option 	node list 
generates slower 	node tail 
code abort policy 	process events 
debug defined 	handle 
debug setting mainly 	clients pending 
intended people 	writes copyright 
trying modify code 	salvatore sanfilippo 
diagnose problems 	antirez gmail 
porting platforms however 	dot rights 
may also 	reserved 
able better isolate 	redistribution use 
user errors 	source binary 
runtime checks assertions 	forms without 
check routines 	modification permitted 
spell detail assumptions 	provided 
invariants underlying 	following conditions 
algorithms checking fairly 	met redistributions 
extensive slow 	source code 
execution noticeably 	must retain 
calling malloc stats 	copyright notice 
mallinfo debug 	list 
attempt check every 	conditions following 
non mmapped 	disclaimer redistributions 
allocated free chunk 	binary form 
course computing 	must reproduce 
summaries abort failure 	copyright notice 
defined debugging 	list 
assertion failures nearly 	conditions following 
impossible version 	disclaimer documentation 
macro causes malloc 	materials provided 
called lead 	distribution neither 
cascade failures blowing 	name redis 
runtime stack 	names 
abort failure cause 	contributors may 
assertions failures 	used endorse 
call abort usually 	promote products 
make debugging 	derived software 
easier malloc 	without specific 
failure action sets 	prior 
errno enomem 	written permission 
win action take 	software provided 
malloc fails 	copyright holders 
able memory none 	contributors express 
available morecore 	implied warranties 
unless win mspaces 	including 
system supports 	limited implied 
sbrk emulation morecore 	warranties merchantability 
sbrk name 	fitness particular 
sbrk style system 	purpose disclaimed 
routine call 	shall copyright 
obtain memory see 	owner 
guidance writing 	contributors liable 
custom morecore functions 	direct indirect 
type argument 	incidental special 
sbrk morecore varies 	exemplary consequential 
across systems 	damages including 
cannot size 	limited 
supports negative arguments 	procurement substitute 
normally type 	goods services 
width size sometimes 	loss use 
declared intptr 	data profits 
doesn much matter 	business interruption 
though internally 	however 
call arguments less 	caused theory 
half max 	liability whether 
size work across 	contract strict 
reasonable possibilities 	liability tort 
although sometimes generating 	including negligence 
compiler warnings 	otherwise 
morecore contiguous morecore 	arising way 
take advantage 	use software 
fact consecutive calls 	even advised 
morecore positive 	possibility damage 
arguments always contiguous 	size consumed 
increasing addresses 	allocator 
unix sbrk 	specified sds 
hurt much anyway 	including fragmentation 
since malloc 	function used 
copes non contiguities 	order compute 
setting definitely 	client output 
non contiguous saves 	buffer 
time possibly 	size amount 
wasted space would 	memory used 
take discover 	sds ptr 
though morecore cannot 	integer encoding 
trim defined 	passing possible 
morecore cannot release 	create 
space back 	non connected 
system given negative 	client useful 
arguments generally 	since commands 
necessary hand crafted 	needs executed 
morecore function 	context client 
cannot handle negative 	commands 
arguments segment 	executed contexts 
traversal non 	instance lua 
zero suppresses traversals 	script need 
memory segments 	non connected 
returned either morecore 	client function 
call mmap 	called 
disables merging segments 	every time 
contiguous selectively 	going transmit 
releasing unused bounds 	data client 
execution times 	behavior following 
mmap system supports 	client receive 
mmap emulation 	data 
morecore mmap used 	normal clients 
system allocation 	function returns 
morecore well mmap 	make sure 
primarily used 	install write 
directly allocate large 	handler loop 
blocks also 	socket 
used backup 	writable data 
strategy cases morecore 	gets written 
fails provide 	client receive 
space system note 	data fake 
single call 	client used 
munmap assumed able 	load 
unmap memory 	aof memory 
may allocated multiple 	master setup 
calls mmap 	write handler 
adjacent mremap linux 	failed function 
realloc uses 	returns err 
mremap allocate large 	function 
blocks extend 	may without 
shrink allocation spaces 	actually installing 
mmap clears 	write handler 
wince mmap clears 	following cases 
memory calloc 	handler already 
doesn need standard 	installed 
unix mmap 	since output 
dev zero 	buffer already 
win wince use 	contained something 
builtin ffs 	client slave 
used causes malloc 	yet online 
use builtin 	want 
ffs function compute 	accumulate writes 
indices compilers 	buffer actually 
may recognize intrinsify 	sending yet 
ffs faster 	typically gets 
supplied version also 	called every 
gcc special 	time 
cased asm instruction 	reply built 
already fast 	adding data 
setting effect similarly 	clients output 
win recent 	buffers function 
compilers asm version 	returns err 
slightly faster 	data 
version malloc getpagesize 	appended output 
derive system 	buffers lua 
includes system 	client always 
page size extent 	without installing 
possible malloc 	handler since 
manages memory system 	socket 
page size 	client reply 
units may usually 	skip handling 
function rather 	send replies 
constant ignored win 	masters receive 
page size 	replies unless 
determined system info 	client 
initialization use 	master force 
dev random used 	reply flag 
causes malloc 	fake client 
use dev random 	aof loading 
initialize secure 	schedule client 
magic seed stamping 	write 
footers otherwise 	output buffers 
current time used 	socket already 
mallinfo defined 	done pending 
compile mallinfo 	writes already 
simple way dealing 	client yet 
mismatches system 	flagged 
declarations file mallinfo 	slaves slave 
field type 	actually receive 
size type fields 	writes stage 
mallinfo originally 	instead installing 
defined svid etc 	write handler 
usefully defined 	flag 
size used usr 	client put 
include malloc 	list clients 
realloc zero bytes 	something write 
frees defined 	socket way 
call realloc zero 	entering loop 
bytes call 	directly 
free people think 	write client 
otherwise since 	sockets avoiding 
malloc returns 	system call 
unique pointer malloc 	really install 
realloc lacks 	write handler 
unistd lacks fcntl 	able 
lacks sys 	write whole 
param lacks sys 	reply authorize 
mman lacks 	caller queue 
lacks lacks sys 	output buffer 
types lacks 	client create 
errno lacks stdlib 	duplicate 
defined unless 	last reply 
win define system 	list exclusively 
header files 	owned reply 
might need manually 	list low 
insert declarations 	level functions 
provide granularity page 	data 
size morecore 	output buffers 
contiguous system info 	already entries 
allocation granularity 	reply list 
win otherwise 	cannot anything 
also settable mallopt 	buffer check 
granularity unit 	buffer 
allocating deallocating memory 	enough space 
system systems 	available append 
contiguous morecore reason 	possible method 
make page 	takes responsibility 
however systems mmap 	sds longer 
tend either 	needed 
require encourage larger 	free otherwise 
granularities increase 	ends robj 
prevent system allocation 	append possible 
functions called 	append possible 
often especially slow 	higher level 
must least 	functions 
one page must 	queue data 
power two 	client output 
setting causes initialization 	buffer following 
either page 	functions ones 
size win 	commands implementations 
region size note 	call 
previous versions 	important place 
malloc equivalent option 	avoid copy 
called top 	write saving 
pad trim threshold 	child running 
also settable 	avoiding touching 
mallopt trim threshold 	refcount 
maximum amount 	field needed 
unused top memory 	encoding raw 
keep releasing 	room buffer 
via malloc trim 	able send 
free automatic 	client without 
trimming mainly useful 	messing 
lived programs 	page optimization 
contiguous morecore trimming 	room buffer 
via sbrk 	bytes max 
slow systems sometimes 	chars bit 
wasteful cases 	integer take 
programs immediately 	avoid 
afterward allocate large 	decoding lower 
chunks high 	level approach 
enough overall system 	normal code 
performance would 	path never 
improve releasing much 	happen actually 
memory rough 	since 
guide might close 	verified room 
average size 	caller expects 
process program running 	sds free 
system releasing 	method free 
much memory would 	sds longer 
allow process 	needed 
run memory generally 	make sure 
worth tuning 	newlines otherwise 
trim thresholds program 	invalid protocol 
undergoes phases 	emitted adds 
several large 	empty reply 
chunks allocated released 	list 
ways reuse 	contain multi 
storage perhaps mixed 	bulk length 
phases chunks 	known function 
trim must greater 	called note 
page size 	install write 
useful effect disable 	even 
trimming completely 	ready sent 
max size note 	since sure 
trick people 	returning loop 
use mallocing huge 	deferred multi 
space freeing 	bulk length 
program startup attempt 	called 
reserve system 	populate length 
memory doesn intended 	gluing next 
effect automatic 	chunk abort 
trimming since memory 	node see 
immediately returned 	deferred multi 
system mmap 	bulk 
threshold also settable 	length embstr 
mallopt mmap 	glue next 
threshold request size 	node non 
threshold mmap 	sds bulk 
directly service request 	reply libc 
requests least 	odd 
size cannot allocated 	systems solaris 
already existing 	format infinite 
space serviced via 	different way 
mmap enough 	better handle 
normal freed space 	way bulk 
already exists 	reply 
used instead mmap 	uses human 
segregates relatively 	readable formatting 
large chunks memory 	instead exposing 
individually obtained 	crude behavior 
released host system 	doubles dear 
request serviced 	user 
mmap never 	integer reply 
reused request least 	bulk len 
directly system 	multi bulk 
may happen remap 	count basically 
successive requests 	used output 
locations segregating space 	prefix 
way benefits 	crlf things 
mmapped space always 	like emitted 
individually released 	often protocol 
back system helps 	shared objects 
keep system 	use integer 
level memory demands 	small 
lived program 	like times 
low also mapped 	create length 
memory doesn 	prefix bulk 
become locked chunks 	reply example 
happen normally 	compute many 
allocated chunks means 	bytes 
even trimming 	take integer 
via malloc 	radix redis 
trim would release 	bulk reply 
however disadvantage 	buffer bulk 
space cannot reclaimed 	reply sds 
consolidated used 	reply 
service later requests 	takes ownership 
happens normal 	sds frees 
chunks advantages mmap 	nul term 
nearly always 	bulk reply 
outweigh disadvantages large 	bulk reply 
chunks large 	copy 
may vary across 	src client 
systems empirically 	output buffers 
derived works well 	dst client 
systems disable 	output buffers 
mmap setting max 	function takes 
size max 	care 
release check rate 	freeing old 
unless mmap 	output buffers 
number consolidated 	destination client 
frees checks release 	specified client 
unused segments 	pending reply 
freeing non contiguous 	buffers 
segments especially 	write socket 
multiple mspaces checking 	may already 
topmost space 	closed ignore 
doesn always suffice 	errors maxclient 
trigger trimming 	directive one 
compensate free period 	client 
max release 	close connection 
check rate current 	note create 
number segments 	client instead 
greater release unused 	check condition 
segments freeing 	since socket 
chunks result consolidation 	already 
best parameter 	non blocking 
compromise slowing 	mode send 
frees relatively costly 	error free 
checks rarely 	kernel best 
trigger versus holding 	effort error 
unused memory 	message 
effectively disable max 	check write 
size may 	errors nothing 
lead slight speed 	avoid warning 
improvement expense 	server running 
carrying around memory 	mode password 
version allow 	specific 
people support multiple 	bound accept 
versions dlmalloc 	requests non 
version win win 	loopback interfaces 
wce win 	instead explain 
malloc failure action 	user fix 
wince reportedly 	needed 
clear win wce 	nothing avoid 
win mac 	warning close 
osx docs 	slaves connections 
advise use sbrk 	useful chained 
seems better 	replication resync 
use mmap osx 	master 
allocators provide 	want force 
alignment morecore darwin 	slaves resync 
size lacks 	well specified 
sys types maximum 	client lists 
possible size 	client could 
bits define mspaces 	referenced 
mspaces mspaces 	including pub 
mspaces malloc alignment 	sub channels 
footers abort 	used free 
abort failure proceed 	client replication 
error use 	cache master 
locks use locks 	marked 
use spin 	current client 
locks insecure mmap 	unset certain 
mmap clears 	operations must 
linux linux 	done client 
mremap malloc failure 	active socket 
action mspaces 	client 
mspaces morecore morecore 	already unlinked 
morecore contiguous 	fake client 
morecore means compute 	already list 
init mparams 	active clients 
morecore contiguous morecore 	unregister handlers 
contiguous granularity 	close 
morecore cannot trim 	socket list 
morecore cannot 	pending writes 
trim trim threshold 	needed client 
mmap mmap 	unblocked blocking 
mmap threshold mmap 	operation list 
max release 	unblocked 
check rate use 	clients master 
builtin ffs 	beging disconnected 
use dev random 	make sure 
mallinfo mallinfo 	cache state 
field type 	resynchronization later 
segment traversal mallopt 	note 
tuning options 	make sure 
svid xpg defines 	client unexpected 
four standard 	state checking 
parameter numbers mallopt 	flags log 
normally defined 	link disconnection 
malloc none used 	slave 
malloc setting 	free query 
effect malloc support 	buffer deallocate 
following options 	structures used 
mallinfo declarations version 	block blocking 
malloc supports 	ops unwatch 
standard svid xpg 	keys 
mallinfo routine 	unsubscribe pubsub 
returns containing usage 	channels free 
properties statistics 	data structures 
work system 	unlink client 
usr include malloc 	close socket 
defining mallinfo 	handlers 
main declaration needed 	references client 
mallinfo returned 	different places 
copy mallinfo malloinfo 	active clients 
contains bunch 	may referenced 
fields even meaningful 	master slave 
version malloc 	cleanup 
fields instead filled 	lost connection 
mallinfo numbers 	slave need 
might interest usr 	remember time 
include malloc 	started zero 
usr include malloc 	attached slaves 
file includes 	time 
declaration mallinfo included 	free replication 
compliant version 	backlog master 
declared must precisely 	slave cleanup 
mallinfo work 	lost connection 
original svid 	master client 
version defined systems 	scheduled 
mallinfo declares 	freeing need 
fields ints others 	queue release 
define system 	dynamically allocated 
defines fields type 	client structure 
different width 	fields 
listed must include 	release client 
system version 	structure schedule 
define usr include 	client free 
malloc define 	safe time 
usr include malloc 	server cron 
usr include 	function 
malloc non mmapped 	function useful 
space allocated 	need terminate 
system number free 	client context 
chunks always 	calling free 
always space mmapped 	client possible 
regions maximum 	client 
total allocated 	valid continuation 
space always total 	flow program 
allocated space 	write data 
total free space 	output buffers 
releasable via 	client client 
malloc trim space 	still 
mallinfo declared 	valid call 
usr include malloc 	err freed 
mallinfo persuade 	buffer sent 
compilers critical functions 	bufpos zero 
inlining defined 	remainder reply 
macros aren used 	fully 
cplusplus declarations 	sent head 
routines use prefix 	next one 
malloc size 	note avoid 
returns pointer newly 	send net 
allocated chunk 	max writes 
least bytes space 	per 
available errno 	bytes single 
enomem ansi 	threaded server 
systems zero malloc 	good idea 
returns minimum 	serve clients 
sized chunk minimum 	well even 
size bytes 	large 
bit systems bytes 	request comes 
bit systems 	fast link 
note size type 	always able 
calls arguments 	accept data 
would negative interpreted 	real world 
requests huge 	scenario 
amounts space often 	think keys 
fail maximum 	loopback however 
supported differs across 	maxmemory limit 
systems cases 	ignore deliver 
less maximum representable 	much data 
size free 	possible 
releases chunk 	deliver clients 
memory pointed previously 	representing masters 
allocated malloc 	count sending 
related routine realloc 	data interaction 
effect malloced 	since always 
already freed free 	send 
cause current 	replconf ack 
program abort calloc 	commands take 
size elements 	time fill 
size element size 	socket output 
returns pointer 	buffer rely 
elements element size 	data 
bytes locations 	pings received 
zero realloc size 	timeout detection 
returns pointer 	close connection 
chunk size contains 	entire reply 
data chunk 	sent write 
minimum size bytes 	handler 
space available 	send data 
returned pointer 	client function 
may may algorithm 	called entering 
prefers extending 	loop hope 
cases possible otherwise 	write replies 
employs equivalent 	client 
malloc copy free 	output buffer 
sequence realloc 	without need 
equivalent malloc space 	use syscall 
available realloc 	order install 
returns errno ansi 	writable handler 
freed fewer 	called 
bytes already held 	forth write 
newly unused 	buffers client 
space lopped freed 	socket nothing 
possible realloc 	left nothing 
size argument zero 	otherwise install 
allocates minimum 	write 
sized chunk old 	handler reset 
unix realloc 	client prepare 
convention allowing 	client process 
last free chunk 	next command 
used argument 	clear asking 
realloc supported memalign 	flag 
size alignment 	well inside 
size returns pointer 	multi executed 
newly allocated 	asking command 
chunk bytes aligned 	client reply 
accord alignment 	skip flag 
argument alignment argument 	reply 
power two 	next command 
argument power two 	sent flag 
nearest greater 	command processed 
power used alignment 	client reply 
guaranteed normal 	skip search 
malloc calls bother 	end 
calling memalign 	line nothing 
argument less overreliance 	without handle 
memalign sure 	split input 
way fragment 	buffer newline 
space valloc size 	slaves used 
equivalent memalign 	refresh 
pagesize pagesize page 	last ack 
size system 	time useful 
pagesize unknown used 	slave ping 
mallopt parameter 	back loading 
number parameter sets 	big rdb 
tunable parameters 	file 
format provide parameter 	data first 
number parameter 	line query 
pair mallopt sets 	buffer setup 
corresponding parameter 	argv client 
argument meaningful returns 	structure create 
successful workaround 	redis 
fact mallopt specified 	objects arguments 
use size 	helper function 
parameters specially treated 	trims query 
maximum size 	buffer make 
svid xpg 	function processes 
ansi defines four 	multi 
standard param 	bulk requests 
numbers mallopt normally 	idempotent client 
defined malloc 	reset multi 
none use malloc 	bulk length 
setting effect 	cannot read 
malloc also supports 	without 
options mallopt 	buffer also 
see details briefly 	contain know 
supported parameters 	sure whole 
follows listed defaults 	line since 
typical configurations 	newline ahead 
symbol param allowed 	find 
param values 	multi bulk 
trim threshold disables 	length setup 
granularity page 	argv client 
size power 	structure read 
page size mmap 	bulk length 
threshold mmap 	unknown 
support malloc footprint 	buffer also 
returns number 	contain going 
bytes obtained system 	read large 
total number 	network make 
bytes allocated malloc 	likely start 
realloc etc 	querybuf 
less unlike mallinfo 	boundary optimize 
function returns 	creation avoiding 
precomputed result called 	large copy 
frequently monitor 	data hint 
memory consumption even 	sds library 
locks otherwise 	amount 
defined function use 	bytes going 
results might 	contain read 
date malloc max 	bulk argument 
footprint returns 	enough data 
maximum number 	trailing optimization 
bytes obtained system 	buffer 
greater current 	contains bulk 
footprint deallocated space 	element instead 
reclaimed system 	creating copying 
peak number bytes 	sds use 
allocated malloc 	current sds 
realloc etc less 	crlf 
unlike mallinfo 	saw fat 
function returns precomputed 	argument see 
result called 	another one 
frequently monitor memory 	likely trim 
consumption even 	pos done 
locks otherwise defined 	multibulk 
function use 	still read 
results might date 	process command 
mallinfo returns 	keep processing 
copy containing various 	something input 
summary statistics 	buffer clients 
arena current 	paused 
total non mmapped 	immediately abort 
bytes allocated 	client middle 
system ordblks number 	something client 
free chunks 	close reply 
smblks always zero 	closes connection 
hblks current 	reply 
number mmapped regions 	written client 
hblkhd total 	make sure 
bytes held mmapped 	reply grow 
regions usmblks 	flag process 
maximum total allocated 	commands determine 
space greater 	request 
current total trimming 	type unknown 
occurred fsmblks 	multibulk processing 
always zero uordblks 	could see 
current total 	length reset 
allocated space normal 	client command 
mmapped fordblks 	executed 
total free 	multi bulk 
space keepcost maximum 	request processing 
number bytes 	bulk reply 
could ideally released 	large enough 
back system 	maximize probability 
via malloc trim 	query 
ideally means 	buffer contains 
ignores page restrictions 	exactly sds 
etc fields 	representing even 
ints bookkeeping may 	risk requiring 
kept longs 	read calls 
reported values may 	way 
wrap around 	function process 
zero thus inaccurate 	multi bulk 
mallinfo independent 	buffer avoid 
calloc size elements 	copying buffers 
size element 	create redis 
size chunks 	representing 
independent calloc similar 	argument redis 
calloc instead 	peer colon 
returning single cleared 	separated port 
space returns 	pair form 
pointers elements independent 	port example 
elements hold 	addresses 
contents size elem 	use around 
size starts 	part like 
cleared independently freed 	unix sockets 
realloc etc 	use path 
elements guaranteed adjacently 	like tmp 
allocated guaranteed 	redis 
occur multiple callocs 	peer always 
mallocs may 	fits inside 
also improve cache 	buffer net 
locality applications 	peer len 
chunks argument optional 	bytes including 
may probably 	term 
typical usage 	failure function 
returned dynamically allocated 	still populates 
also freed 	peerid want 
longer needed otherwise 	relax error 
chunks must 	checking need 
least elements length 	display 
filled pointers 	something anyway 
chunks either independent 	see anet 
calloc returns 	peer implementation 
pointer allocation failed 	info unix 
elements zero 	socket client 
chunks returns chunk 	tcp 
representing zero 	client function 
elements freed wanted 	returns client 
element must 	peer creating 
individually freed longer 	caching client 
needed like 	peerid otherwise 
instead able free 	returning 
instead use 	cached peer 
regular calloc 	never changes 
assign pointers space 	life client 
represent elements 	however expensive 
though cannot independently 	compute concatenate 
free elements 	representing 
independent calloc simplifies 	state client 
speeds implementations 	human readable 
many kinds pools 	format sds 
may also 	client list 
useful constructing large 	client reply 
data structures 	skip 
initially number sized 	client kill 
nodes number 	port client 
known compile time 	kill option 
nodes may 	option old 
later need freed 	style syntax 
example node 	client 
item node next 	kill addr 
node build 	old form 
list node 	kill next 
pool read number 	option index 
nodes needed 	style syntax 
pool node independent 	parse 
calloc node 	options iterate 
pool die organize 	clients killing 
linked list 	matching clients 
node first pool 	kill reply 
pool next 	according old 
pool free pool 	format 
free needed 	client closed 
later first independent 	flag close 
comalloc size 	reply queued 
elements size sizes 	reply output 
chunks independent 	buffers setting 
comalloc allocates elements 	client 
chunks sizes 	name empty 
indicated sizes 	actually removes 
returns pointers elements 	current name 
independently freed 	otherwise check 
realloc etc elements 	charset need 
guaranteed adjacently 	otherwise 
allocated guaranteed occur 	client list 
multiple callocs 	format always 
mallocs may also 	able split 
improve cache 	space different 
locality applications chunks 	fields ascii 
argument optional 	assumed 
may returned dynamically 	rewrite command 
allocated also 	vector client 
freed longer needed 	objects count 
otherwise chunks 	incremented old 
must least elements 	command vector 
length filled 	freed 
pointers chunks either 	old objects 
independent comalloc 	count decremented 
returns pointer 	argument vector 
allocation failed elements 	free objects 
zero chunks 	original vector 
returns chunk representing 	end 
zero elements 	sure objects 
freed wanted element 	reused vector 
must individually 	refcount gets 
freed longer needed 	incremented gets 
like instead 	decremented replace 
able free instead 	argv 
use single 	argc versions 
regular malloc assign 	completely replace 
pointers particular 	client command 
offsets aggregate space 	vector provided 
though cannot 	one rewrite 
independently free elements 	single 
independent comallac 	item command 
differs independent calloc 	vector val 
element may 	count incremented 
different size 	old decremented 
also automatically clear 	possible specify 
elements independent 	argument 
comalloc used speed 	current size 
allocation cases 	argument vector 
several structs objects 	objects gets 
must always 	reallocated argc 
allocated time example 	max however 
head foot 	caller 
send message msg 	make sure 
msglen strlen 	holes arguments 
msg size sizes 	original argument 
head msglen 	vector longer 
foot chunks independent 	one want 
comalloc sizes 	end 
chunks die head 	caller argc 
head head 	free longer 
chunks body chunks 	used objects 
foot foot 	argv command 
foot chunks 	name make 
general though independent 	sure 
comalloc worth 	fix cmd 
larger values elements 	function returns 
small values 	number bytes 
probably won detect 	redis virtually 
enough difference 	store reply 
series malloc calls 	still 
bother overuse 	read client 
independent comalloc increase 	since reply 
overall memory 	output list 
usage since cannot 	may contain 
reuse existing 	objects shared 
noncontiguous small chunks 	really 
might available 	additional memory 
elements pvalloc size 	function returns 
equivalent valloc 	total sum 
minimum page holds 	length objects 
round nearest 	stored output 
pagesize malloc 	list 
trim size pad 	plus memory 
possible gives 	used allocate 
memory back system 	every list 
via negative 	node reply 
arguments sbrk unused 	buffer taken 
memory high 	account 
end malloc pool 	since allocated 
unused mmap 	anyway note 
segments call freeing 	function fast 
large blocks 	called many 
memory potentially reduce 	time caller 
system level 	wishes 
memory requirements program 	main usage 
however cannot 	function currently 
guarantee reduce memory 	enforcing client 
allocation patterns 	output length 
large free 	limits client 
blocks memory locked 	used 
two used 	order enforce 
chunks cannot given 	limits different 
back system 	classes clients 
pad argument malloc 	function one 
trim represents 	following client 
amount free trailing 	type 
space untrimmed 	normal normal 
argument zero minimum 	client client 
amount memory 	type slave 
maintain data structures 	slave client 
left non 	executing monitor 
zero arguments supplied 	command 
maintain enough 	client type 
trailing space service 	pubsub client 
future expected 	subscribed pub 
allocations without obtain 	sub channels 
memory system 	client type 
malloc trim 	master 
returns actually released 	client representing 
memory malloc 	replication master 
stats prints stderr 	function checks 
amount space 	client reached 
obtained system via 	output buffer 
sbrk mmap 	soft 
maximum amount may 	hard limit 
current malloc 	also update 
trim munmap got 	state needed 
called current 	check soft 
number bytes allocated 	limit side 
via malloc 	effect 
realloc etc yet 	non zero 
freed note 	client reached 
number bytes allocated 	soft hard 
number requested 	limit otherwise 
larger number requested 	zero returned 
alignment bookkeeping 	purpose 
overhead includes 	output buffer 
alignment wastage use 	limiting masters 
figure may 	handled like 
greater zero even 	normal clients 
user level 	need check 
chunks allocated reported 	soft 
current maximum 	limit reached 
system memory inaccurate 	continuously specified 
program makes 	amount seconds 
calls system memory 	first time 
allocation functions 	see soft 
normally sbrk outside 	limit 
malloc malloc 	reached client 
stats prints commonly 	still reached 
interesting statistics 	max number 
information obtained calling 	seconds soft 
mallinfo mspaces 	limit 
malloc usable size 	considered reached 
returns number 	asynchronously close 
bytes actually 	client soft 
use allocated chunk 	hard limit 
may requested 	reached output 
although often due 	buffer 
alignment minimum 	size caller 
size constraints use 	check client 
many bytes 	closed checking 
without worrying overwriting 	client client 
allocated objects 	close asap 
particularly great programming 	flag 
practice malloc 	note need 
usable size useful 	close client 
debugging assertions 	asynchronously function 
example malloc malloc 	called contexts 
usable size 	client freed 
mspace opaque type 	safely 
representing independent 	lower level 
region space 	functions pushing 
supports mspace malloc 	data inside 
etc create 	client output 
mspace creates returns 	buffers helper 
independent space 	function 
given initial capacity 	used free 
granularity size 	memory needed 
returns system memory 	order flush 
available create 	slaves output 
space argument locked 	buffers without 
non zero 	returning 
space uses separate 	control loop 
control access 	also called 
capacity space grow 	shutdown best 
dynamically needed 	effort attempt 
service mspace malloc 	send slaves 
requests control 	latest 
sizes incremental increases 	writes note 
space compiling 	following flush 
different granularity 	output buffers 
dynamically setting mallopt 	slaves state 
granularity destroy 	online put 
mspace destroys given 	online 
space attempts 	ack writable 
memory back system 	never installed 
returning total 	since purpose 
number bytes freed 	put online 
destruction results 	ack postpone 
access memory used 	moment 
space become 	installed want 
undefined create mspace 	since slaves 
uses memory 	state receive 
supplied initial mspace 	writes first 
part less 	ack pause 
size bytes space 	clients 
used bookkeeping 	specified unixtime 
capacity must least 	clients paused 
large otherwise 	command processed 
returned initial 	clients data 
space exhausted additional 	change time 
memory obtained 	however 
system destroying space 	function pauses 
deallocate additionally 	normal pub 
allocated space possible 	sub clients 
initial mspace 	slaves still 
mmap large chunks 	served function 
controls whether 	used 
requests large chunks 	server upgrades 
allocated mmapped 	required slaves 
regions separate others 	process latest 
mspace enabled 	bytes replication 
reduces fragmentation however 	stream turned 
chunks necessarily 	masters 
released system upon 	function also 
destroy mspace 	internally used 
disabling setting may 	redis cluster 
increase fragmentation 	manual failover 
avoids leakage 	procedure implemented 
relying destroy mspace 	cluster 
release memory 	failover function 
allocated space mspace 	always succeed 
malloc behaves 	even already 
malloc operates within 	pause progress 
given space 	pause extended 
mspace free behaves 	duration 
free operates 	time left 
within given space 	previous duration 
compiled footers 	however duration 
mspace free actually 	smaller time 
needed free 	left previous 
may called instead 	pause 
mspace free 	change made 
freed chunks space 	left duration 
handled originating 	non zero 
spaces mspace 	clients currently 
realloc behaves realloc 	paused side 
operates within 	effect 
given space compiled 	function checks 
footers mspace 	pause time 
realloc actually needed 	reached clear 
realloc may 	put clients 
called instead mspace 	unblocked clients 
realloc realloced 	queue 
chunks space handled 	order force 
originating spaces 	processing input 
mspace calloc behaves 	buffer touch 
calloc operates 	slaves blocked 
within given space 	clients latter 
mspace memalign 	pending 
behaves memalign operates 	requests processed 
within given 	unblocked function 
space mspace independent 	called redis 
calloc behaves 	order process 
independent calloc 	events time 
operates within given 	time 
space mspace 	blocked interruptible 
independent comalloc behaves 	operation allows 
independent comalloc 	reply clients 
operates within given 	loading error 
space mspace 	loading data 
footprint returns number 	startup 
bytes obtained 	full resynchronization 
system space mspace 	master forth 
max footprint 	calls loop 
returns peak number 	order process 
bytes obtained 	events specifically 
system space mspace 	call 
mallinfo behaves 	loop times 
mallinfo reports properties 	receive acknowledge 
given space 	processed order 
mallinfo malloc usable 	forward accept 
size behaves 	read write 
malloc usable 	close 
size mspace malloc 	sequence needed 
stats behaves 	serve client 
malloc stats reports 	function returns 
properties given 	total number 
space mspace trim 	events processed 
behaves malloc 	see 
trim operates within 	function top 
given space 	comment noparser.c 
mallopt mspaces end 	buff name 
cplusplus make 	data strip 
fully customizable malloc 	unused unused 
header file 	unused 
cut everything line 	unused lua 
put file 	pushliteral lua 
malloc edit suit 	error unused 
include next 	unused unused 
line well programs 	unused unused 
use malloc 	lua 
include malloc 	pushliteral lua 
includes warnings win 	error code 
printing malloc 	used make 
stats malloc failure 	lua core 
action lacks 	contain parsing 
errno magic initialization 	modules 
footers abort 	lcode llex 
lacks stdlib abort 	lparser represent 
failure abort 	total core 
failure debug debug 	able load 
memset etc 	binary files 
lacks ffs lacks 	precompiled 
use builtin 	luac course 
ffs mmap lacks 	build luac 
sys mman 	original parsing 
lacks fcntl mmap 	modules use 
sbrk sysconf 	module simply 
lacks unistd free 	compile 
bsd etc 	make noparser 
lacks unistd 	list file 
declarations locking solaris 	lua libraries 
solaris already 	linker load 
defined amd builds 	parsing modules 
cplusplus cplusplus 	make 
amd start gcc 	luab also 
compatibility compatibility 	want avoid 
intrin header gcc 	dump module 
gcc equivalents 	ldump define 
intrinsic microsoft visual 	nodump define 
functions originally 	nodump 
developed react http 	notify.c classes 
www reactos 	flags flags 
tiny krnl http 	res type 
www tinykrnl 	key dbid 
projects copyright kjk 	chan chanobj 
hyperion hackbunny 	eventobj 
reactos permission 	len buf 
hereby granted free 	sdsempty sdscatlen 
charge person 	sdscatlen sdscatlen 
obtaining copy software 	sdscatlen sdscatlen 
associated documentation 	sdscatlen sdscatlen 
files software deal 	sdscatlen 
software without 	sdscatlen sdscatlen 
restriction including without 	sdscatlen create 
limitation rights 	strlen sdsnewlen 
use copy modify 	sdscatlen sdscatlen 
merge publish 	sdscatsds create 
distribute sublicense sell 	pubsub 
copies software 	publish message 
permit persons software 	decr count 
furnished subject 	sdsnewlen sdscatlen 
following conditions copyright 	sdscatlen sdscatsds 
notice permission 	create pubsub 
notice shall included 	publish 
copies substantial 	message decr 
portions software 	count decr 
software provided without 	count copyright 
warranty kind 	salvatore sanfilippo 
express implied including 	antirez gmail 
limited warranties 	dot 
merchantability fitness particular 	rights reserved 
purpose noninfringement 	redistribution use 
shall authors copyright 	source binary 
holders liable 	forms without 
claim damages liability 	modification permitted 
whether action 	provided 
contract tort otherwise 	following conditions 
arising connection 	met redistributions 
software use dealings 	source code 
software atomic 	must retain 
operations bugbug gcc 	copyright notice 
supports full 	list 
barriers note sync 	conditions following 
test would 	disclaimer redistributions 
acquire barrier 	binary form 
force full barrier 	must reproduce 
end gcc 	copyright notice 
compatibility win use 	list 
locks declarations 	conditions following 
bit scanning win 	disclaimer documentation 
avoid pulling 	materials provided 
win cplusplus cplusplus 	distribution neither 
bit scan 	name redis 
forward defined msc 	names 
ver msc 	contributors may 
ver svr systems 	used endorse 
omit underscore 	promote products 
use supplied emulation 	derived software 
getpagesize guess 	without specific 
size alignment properties 	prior 
bit size 	written permission 
size constants coerced 	software provided 
size annoying 	copyright holders 
necessary avoid 	contributors express 
errors platforms bit 	implied warranties 
mask corresponding 	including 
malloc alignment address 	limited implied 
acceptable alignment 	warranties merchantability 
number bytes offset 	fitness particular 
address align 	purpose disclaimed 
mmap preliminaries morecore 	shall copyright 
mmap define 	owner 
calls checks fail 	contributors liable 
compiler optimizer 	direct indirect 
code rather many 	incidental special 
morecore mmap 	exemplary consequential 
must mfail failure 	damages including 
defined convenience 	limited 
map anon map 	procurement substitute 
anonymous nearly 	goods services 
versions mmap 	loss use 
support map anonymous 	data profits 
following unlikely 	business interruption 
needed supplied cached 	however 
file descriptor 	caused theory 
dev zero map 	liability whether 
anonymous win 	contract strict 
win mmap via 	liability tort 
alloc direct 	including negligence 
mmap use mem 	otherwise 
top minimize 	arising way 
interference function supports 	use software 
releasing coalesed 	even advised 
segments win mmap 	possibility damage 
win mremap 	file keyspace 
define call morecore 	events 
morecore morecore 	notification via 
morecore morecore define 	pub sub 
call mmap 	described http 
call munmap 	redis topics 
call direct mmap 	keyspace events 
mmap mmap 	turn 
munmap munmap direct 	representing notification 
mmap direct 	classes integer 
mmap mmap mmap 	representing notification 
define call 	classes flags 
mremap mremap mremap 	xored function 
mmap mremap 	returns 
mmap mremap mstate 	input contains 
bit continguous 	characters mapping 
morecore disabled failed 	function exactly 
segment bit 	revese function 
create mspace preliminaries 	gets input 
locks defined 	integer 
one plus one 	xored flags 
per mspace 	returns representing 
ensures mparams magic 	selected classes 
unique mparams 	returned sds 
values initialized 	needs released 
also protects sequences 	sdsfree 
calls morecore 	api provided 
many cases sys 	rest redis 
alloc requires 	core simple 
two calls interleaved 	function notify 
calls threads 	keyspace robj 
protect direct calls 	key 
morecore threads 	dbid representing 
still code cope 	name key 
best interference 	redis representing 
per mspace locks 	key name 
surround calls 	dbid database 
malloc free etc 	key 
enable use 	lives notifications 
layered extensions per 	events asap 
mspace locks 	keyspace key 
reentrant regions generally 	notifications keyevente 
bounded times 	key notifications 
use supplied 	object.c 
simple spinlocks custom 	type ptr 
versions use 	ptr len 
locks definitions routines 	ptr len 
bypassed need 	ptr len 
define least initial 	humanfriendly buf 
acquire release 	len 
possibly used malloc 	obj type 
commonly needed 	llval len 
extensions custom pthread 	emb dec 
style spin 	buf flags 
locks gcc place 	bufa bufb 
args cmpxchgl 	astr 
locals evade oddities 	bstr alen 
gccs solaris 	blen minlen 
unknown systems linux 	cmp target 
free bsd 	eptr target 
apple solaris 	msg target 
win custom win 	eptr 
style spin 	target msg 
locks msc todo 	target eptr 
win use 	target msg 
spin locks pthreads 	target msg 
locks cope 	encoding lruclock 
old style linux 	key 
recursive initialization 	key reply 
adding skipped declaration 	zmalloc lru 
pthread win 	clock create 
win critical sections 	sdsnewlen zmalloc 
use spin 	lru clock 
loop initialize transition 	memcpy 
initializing win 	memset create 
use spin locks 	embedded create 
use locks 	raw incr 
user defined locks 	count create 
define implementation 	create sdsfromlonglong 
define initial 	isinf 
define acquire define 	memcpy memcpy 
release define 	snprintf strchr 
mlock malloc mutex 	snprintf create 
use locks 	server create 
state use locks 	raw sdslen 
use locks 	create 
use locks use 	embedded sdslen 
locks chunk 	create server 
representations following includes 	panic quicklist 
lightly edited 	create create 
explanations colin plumb 	ziplist create 
malloc chunk 	dict 
declaration misleading accurate 	create create 
necessary declares 	intset create 
view memory allowing 	ziplist create 
access necessary 	zmalloc dict 
fields known offsets 	create zsl 
given chunks 	create 
memory maintained 	create ziplist 
boundary tag method 	create sdsfree 
originally described 	quicklist release 
knuth see paper 	server panic 
paul wilson 	dict release 
ftp ftp utexas 	zfree 
edu pub 	server panic 
garbage allocsrv survey 	dict release 
techniques sizes 	zsl free 
free chunks stored 	zfree zfree 
front chunk 	server panic 
end makes consolidating 	dict 
fragmented chunks 	release zfree 
bigger chunks fast 	server panic 
head fields 	server panic 
also hold bits 	free free 
representing whether 	list free 
chunks free use 	free 
pictures make 	zset free 
clearer exploded 	hash server 
show state chunk 	panic zfree 
thought extending 	decr count 
high bits head 	reply server 
field header 	info 
prev foot pinuse 	sdslen server 
bit bit 	info sds 
following chunk header 	encoded sdslen 
chunk use 	decr count 
looks like chunk 	incr count 
size previous 	sdsfree 
chunk size chunk 	create embedded 
mem size 	sdslen decr 
size available payload 	count sdsavail 
bytes chunk 	sds free 
size next chunk 	space sds 
may may 	encoded 
use mem free 	incr count 
looks like 	create strlen 
chunk user 	server panic 
payload must use 	server info 
would merged 	sds encoded 
size chunk mem 	sdslen 
next pointer 	sds encoded 
prev pointer size 	sdslen strcoll 
chunk unused 	memcmp compare 
bytes chunk size 	objects flags 
chunk size 	compare objects 
next chunk must 	flags 
use would 	compare objects 
merged mem user 	server info 
payload note 	sds encoded 
since always merge 	sdslen sdigits 
adjacent free 	server info 
chunks chunks adjacent 	sds 
free chunk 	encoded strtod 
must use 	isspace isnan 
given pointer chunk 	server panic 
derived trivially 	reply error 
payload pointer time 	reply 
find whether 	error server 
adjacent chunks free 	info sds 
unlink lists 	encoded strtold 
merge current chunk 	isspace isnan 
chunks always 	server panic 
begin even word 	reply 
boundaries mem 	error reply 
portion returned user 	error server 
also even 	info sds 
word boundary thus 	encoded strtoll 
least word 	isspace server 
aligned pinuse bit 	panic 
bit stored 	reply error 
unused low order 	reply error 
bit chunk 	reply reply 
size always 	error reply 
multiple two words 	error lru 
use bit 	clock 
previous chunk bit 	dict find 
clear word 	dict val 
current chunk size 	command lookup 
contains previous 	reply strcasecmp 
chunk size used 	command lookup 
find front 	reply 
previous chunk first 	reply strcasecmp 
chunk allocated 	command lookup 
always bit preventing 	reply reply 
access non 	bulk str 
existent non owned 	encoding strcasecmp 
memory pinuse 	command 
given chunk cannot 	lookup reply 
determine size 	reply estimate 
previous chunk might 	idle time 
even memory 	reply error 
addressing fault 	redis implementation 
trying cinuse bit 	copyright 
bit stored 	salvatore sanfilippo 
unused second lowest 	antirez gmail 
bit chunk 	dot rights 
size redundantly records 	reserved redistribution 
whether current 	use source 
chunk inuse redundancy 	binary 
enables usage 	forms without 
checks within free 	modification permitted 
realloc reduces 	provided following 
indirection freeing consolidating 	conditions met 
chunks freshly 	redistributions source 
allocated chunk must 	code 
cinuse pinuse 	must retain 
allocated chunk borders 	copyright notice 
either previously 	list conditions 
allocated still use 	following disclaimer 
chunk memory 	redistributions binary 
arena ensured 	form 
making allocations lowest 	must reproduce 
part found 	copyright notice 
chunk free chunk 	list conditions 
physically borders 	following disclaimer 
another one free 	documentation materials 
chunk known 	provided 
preceded followed either 	distribution neither 
inuse chunks 	name redis 
ends memory note 	names contributors 
foot current 	may used 
chunk actually represented 	endorse promote 
prev foot 	products 
next chunk makes 	derived software 
easier deal 	without specific 
alignments etc confusing 	prior written 
trying extend 	permission software 
adapt code 	provided copyright 
exceptions special chunk 	holders 
top top 	contributors express 
available chunk one 	implied warranties 
bordering end 	including limited 
available memory treated 	implied warranties 
specially top 	merchantability fitness 
never included bin 	particular 
used chunk 	purpose disclaimed 
available released back 	shall copyright 
system large 	owner contributors 
see trim threshold 	liable direct 
effect top 	indirect incidental 
chunk treated larger 	special 
thus less 	exemplary consequential 
well fitting available 	damages including 
chunk top 	limited procurement 
chunk doesn update 	substitute goods 
trailing size 	services loss 
field since 	use 
next contiguous chunk 	data profits 
would index 	business interruption 
however space still 	however caused 
allocated top 	theory liability 
foot size enable 	whether contract 
separation merging 	strict 
space extended chunks 	liability tort 
allocated via 	including negligence 
mmap lowest order 	otherwise arising 
bit mmapped 	way use 
bit prev foot 	software even 
fields pinuse 	advised 
bit head fields 	possibility damage 
allocated one 	lru current 
one must carry 	lruclock minutes 
prev foot 	resolution create 
field also used 	encoding obj 
hold offset 	encoding 
chunk within 	raw plain 
mmapped region needed 	ptr points 
preserve alignment 	proper sds 
mmapped chunk trailed 	create encoding 
first two 	obj encoding 
fields fake next 	embstr 
chunk sake 	sds actually 
usage checks size 	unmodifiable allocated 
previous chunk 	chunk create 
free size inuse 	embstr encoding 
bits links 	smaller reids 
used free type 	encoding 
bins chunks 	embstr size 
described described type 	limit otherwise 
various bit 	raw encoding 
flag sets chunks 	used current 
sizes alignments 	limit chosen 
footers footers mapped 	biggest 
chunks need 	allocate embstr 
second word 	still fit 
overhead additional padding 	arena jemalloc 
fake next 	create humanfriendly 
chunk foot smallest 	non zero 
size malloc 	use 
aligned minimal chunk 	exponential format 
conversion malloc 	trims trailing 
headers user pointers 	zeroes end 
back chunk 	however results 
associated aligned address 	loss precision 
bounds request 	otherwise 
chunk sizes pad 	exp format 
request bytes 	used output 
usable size pad 	snprintf modified 
request checking 	humanfriendly option 
minimum maximum operations 	used incrbyfloat 
head foot 	hincrbyfloat 
fields head 	libc odd 
field chunk pinuse 	systems solaris 
bit previous 	format infinite 
adjacent chunk use 	different way 
cinuse bit 	better handle 
chunk use chunk 	way 
obtained mmap 	use digits 
prev foot field 	precision since 
mmapped bit 	bit floats 
otherwise holding offset 	precision rounding 
mmapped region 	able represent 
chunk flag bit 	small 
used malloc 	numbers way 
might useful extensions 	non surprising 
head fenceposts 	user small 
extraction fields head 	numbers represented 
words treat 	way converted 
space ptr offset 	back 
chunk ptr 	exactly user 
next previous 	typed trailing 
physical malloc chunk 	zeroes duplicate 
extract next 	guarantee returned 
chunk pinuse bit 	encoding original 
size footer 	one 
size pinuse bit 	function also 
foot size 	guarantees duplicating 
pinuse bit foot 	small integere 
clear next 	contains representation 
pinuse overhead associated 	small integer 
chunk malloced 	always 
space necessarily cleared 	result fresh 
mmap clears 	unshared refcount 
mmap clears overlaid 	resulting always 
data structures 	refcount variant 
chunks use treated 	decr count 
nodes either 	gets 
lists trees small 	argument useful 
chunks stored 	free method 
circular doubly 	data structures 
linked lists look 	expect free 
like chunk 	prototype free 
size previous chunk 	method 
head size 	function count 
chunk bytes mem 	zero without 
forward pointer 	freeing useful 
next chunk list 	order pass 
back pointer 	functions incrementing 
previous chunk list 	count 
unused space 	received example 
may bytes nextchunk 	function increment 
foot size 	count reset 
chunk bytes larger 	count create 
chunks kept 	otherwise need 
form bitwise digital 	resort 
trees aka 	less elegant 
tries keyed chunksizes 	pattern obj 
malloc chunks 	create function 
free chunks 	increment count 
greater bytes size 	obj decr 
doesn impose 	count 
constraints user chunk 	obj encode 
sizes node 	order save 
looks like chunk 	space make 
size previous 	sure type 
chunk head size 	encode function 
chunk bytes 	types 
mem forward pointer 	use encoded 
next chunk 	memory efficient 
size back pointer 	representations handled 
previous chunk 	commands implementing 
size pointer left 	type specialized 
child child 	encoding 
pointer right child 	objects raw 
child pointer 	embstr encoded 
parent bin index 	words objects 
chunk unused 	still represented 
space nextchunk 	actually chars 
foot size chunk 	safe 
bytes holding 	encode shared 
treenodes unique chunk 	objects shared 
sizes chunks 	objects shared 
size arranged circularly 	everywhere space 
linked list 	redis may 
oldest chunk next 	end 
used fifo 	places handled 
ordering actually members 	handle values 
distinguished non 	keyspace check 
parent pointer chunk 	represent integer 
size existing 	note sure 
node inserted linked 	larger 
existing node 	chars representable 
pointers work way 	bit integer 
pointers small 	encodable use 
chunks contains 	shared note 
power sized range 	avoid shared 
chunk sizes 	integers 
smallest divided half 	maxmemory used 
level chunks 	every needs 
smaller half range 	lru field 
top nose 	lru algorithm 
left subtree larger 	work well 
half right 	small 
subtree course done 	still raw 
inspecting individual 	encoded embstr 
bits rules node 	encoding efficient 
left subtree 	representation sds 
contains smaller sizes 	allocated chunk 
right subtree 	memory 
however node root 	save space 
subtree particular 	cache misses 
ordering relationship either 	encode last 
dividing line 	least optimize 
subtree sizes 	sds inside 
trie relation last 	require 
chunk given 	little space 
size interior need 	free space 
replace leaf 	end sds 
node ordering rules 	relatively large 
permit node 	branch entered 
replaced leaf smallest 	length 
chunk common 	greater obj 
operation best fit 	encoding embstr 
allocator found 	size limit 
walking path leftmost 	original decoded 
leaf unlike 	version encoded 
usual binary follow 	returned 
left child 	already raw 
pointers reach follow 	encoded increment 
right child 	count compare 
pointer time left 	two objects 
one reach 	via strcmp 
leaf child 	strcoll 
pointers smallest chunk 	depending flags 
somewhere along 	note objects 
path worst number 	may integer 
steps find 	encoded use 
node bounded number 	representation numbers 
bits differentiating 	stack 
chunks within bins 	compare much 
current bin 	faster calling 
calculations ranges bit 	decoded important 
sizes bit 	note redis 
sizes typical course 	compare binary 
much better 	used 
first four fields 	binary safe 
must compatible 	comparison used 
malloc chunk type 	wrapper compare 
bins trees 	objects flags 
little helper macro 	binary comparison 
trees segments 	wrapper 
malloc space 	compare objects 
may include non 	flags collation 
contiguous segments 	equal objects 
held list headed 	two objects 
embedded malloc 	point view 
segment record representing 	comparison 
top space 	otherwise returned 
segments also include 	note function 
flags holding 	faster checking 
properties space large 	compare perform 
chunks directly 	optimization integer 
allocated mmap included 	encoded 
list instead 	check stored 
independently created destroyed 	given returns 
without otherwise 	min number 
keeping track segment 	milliseconds never 
management mainly 	requested approximated 
comes play 	lru 
spaces allocated mmap 	algorithm helper 
call mmap 	function command 
might might memory 	need lookup 
adjacent existing 	keys without 
segment morecore normally 	modification lru 
contiguously current 	parameters 
space space almost 	command allows 
always adjacent 	inspect internals 
simpler faster deal 	redis usage 
morecore used 	refcount encoding 
preferentially mmap available 	idletime key 
see sys 	overflow.c 
alloc allocating mmap 	nhchunks mib 
use hinting 	miblen max 
mechanisms inconsistently supported 	size mallctl 
various implementations 	mallctlnametomib mallctlbymib 
unix mmap distinguish 	ptr malloc 
reserving committing 	ptr 
memory instead 	malloc ptr 
ask space exploit 	calloc ptr 
contiguity probably 	calloc malloc 
possible better systems 	ptr ptr 
general scheme 	realloc ptr 
seems significantly better 	realloc 
management entails 	free test 
simpler variant consolidation 	pages.c addr 
scheme used 	size ret 
chunks reduce fragmentation 	addr size 
adjacent memory 	buf addr 
normally prepended appended 	alloc 
existing segment 	size leadsize 
however limitations compared 	size ret 
chunk consolidation 	addr trailsize 
mostly reflect fact 	addr size 
segment processing 	commit prot 
relatively infrequent occurring 	result 
getting memory 	addr size 
system expect 	addr size 
huge numbers segments 	addr size 
segments indexed 	unzeroed err 
traversal requires linear 	alloc mmap 
scans would 	pages 
possible index worth 	unmap free 
extra overhead 	munmap buferror 
complexity programs platforms 	errno malloc 
segments appended 	abort pages 
old ones holding 	unmap pages 
top memory 	map 
cannot prepended others 	pages unmap 
held different 	pages unmap 
segments top segment 	pages unmap 
mstate segment 	mmap pages 
record kept tail 	unmap pages 
segment segments 	commit 
added pushing segment 	impl pages 
records onto 	commit impl 
list headed 	alloc madvise 
mstate seg containing 	alloc allocate 
mstate segment 	given address 
flags control allocation 	one 
merge deallocation 	given fails 
policies bit allocate 	returns use 
segment deallocate 	map cause 
merge others currently 	replacement existing 
holds initial 	mappings want 
segment passed create 	create 
mspace mmapped 	mappings succeeded 
bit segment may 	mapping memory 
merged surrounding 	right place 
mmapped segments trimmed 	following decommit 
allocated munmap 	commit implementation 
neither bit segment 	functional 
obtained morecore 	always disabled 
merged surrounding 	doesn beyong 
morecore segments deallocated 	improved debugging 
trimmed morecore 	cost extra 
negative arguments address 	system calls 
allocated size 	systems 
ptr next segment 	overcommit succeeded 
mmap flag 	mapping memory 
malloc state malloc 	right place 
state holds 	last resort 
bookkeeping space main 	pages.h addr 
fields top 	size 
topmost chunk currently 	addr size 
active segment 	addr alloc 
size cached topsize 	size leadsize 
actual size 	size addr 
topmost space topsize 	size addr 
top foot 	size 
size includes space 	addr size 
reserved adding 	jemalloc types 
fenceposts segment 	jemalloc structs 
records necessary getting 	jemalloc externs 
space system 	jemalloc inlines 
size autotrim top 	posix 
cached mparams 	memalignc alignment 
trim check disabled 	alignment size 
autotrim fails 	alignment size 
designated victim preferred 	total err 
chunk servicing 	buf posix 
small requests exact 	memalign 
fits normally 	posix memalign 
chunk split recently 	posix memalign 
service another 	posix memalign 
small request size 	posix memalign 
cached dvsize 	posix memalign 
link fields chunk 	buferror 
maintained since 	errno test 
kept bin small 	fail malloc 
bins bin 	usable size 
headers free 	free test 
chunks bins hold 	define maxalign 
chunks sizes 	size 
less min large 	pqsort.c swaptype 
size bytes 	cmp cmp 
bin contains chunks 	lrange rrange 
size spaced 	swaptype cmp 
bytes apart simplify 	result cmp 
use linked 	lrange 
lists bin header 	rrange cmp 
acts malloc 	cmp cmp 
chunk pointing real 	cmp cmp 
first node 	swapinit cmp 
exists pointing avoids 	swap 
special casing 	med med 
headers avoid waste 	med med 
allocate pointers 	swap cmp 
bins use repositioning 	swap cmp 
tricks treat 	swap swap 
fields chunk 	min 
bins treebins pointers 	vecswap min 
roots trees 	size vecswap 
holding range sizes 	pqsort pqsort 
equally spaced 	following net 
treebins power two 	bsd libc 
shift shift 	qsort 
last bin holds 	implementation modified 
anything larger 	order support 
bin maps one 	sorting ranges 
bit map 	redis copyright 
small bins smallmap 	salvatore sanfilippo 
one treebins 	rights 
treemap bin sets 	reserved original 
bit non 	copyright notice 
empty clears bit 	follows net 
empty bit 	bsd qsort 
operations used avoid 	lukem exp 
bin bin 	copyright 
searching nearly 	regents university 
search done without 	california rights 
ever looking 	reserved redistribution 
bins won selected 	use source 
bit maps 	binary forms 
conservatively use bits 	without 
per map 	modification permitted 
word even bit 	provided following 
system good 	conditions met 
description bit techniques 	redistributions source 
used see 	code must 
henry warren book 	retain 
hacker delight 	copyright notice 
supplement http hackersdelight 	list conditions 
many intended 	following disclaimer 
reduce branchiness paths 	redistributions binary 
malloc etc 	form must 
well reduce 	reproduce 
number memory locations 	copyright notice 
read written 	list conditions 
segments list segments 	following disclaimer 
headed embedded 	documentation materials 
malloc segment record 	provided distribution 
representing initial 	neither 
space address check 	name university 
support least 	names contributors 
addr field least 	may used 
address ever 	endorse promote 
obtained morecore mmap 	products derived 
attempted frees 	software 
reallocs address less 	without specific 
trapped unless 	prior written 
insecure defined magic 	permission software 
tag cross 	provided regents 
check field always 	contributors express 
hold mparams 	implied 
magic flags 	warranties including 
bits recording whether 	limited implied 
use mmap 	warranties merchantability 
locks contiguous morecore 	fitness particular 
statistics space 	purpose disclaimed 
keeps track current 	shall 
maximum system 	regents contributors 
memory obtained via 	liable direct 
morecore mmap 	indirect incidental 
trim support fields 	special exemplary 
holding amount 	consequential damages 
unused topmost memory 	including 
trigger timming 	limited procurement 
counter force periodic 	substitute goods 
scanning release 	services loss 
unused non topmost 	use data 
segments locking 	profits business 
use locks defined 	interruption 
mutex acquired 	however caused 
released around 	theory liability 
every call mspace 	whether contract 
extension support 	strict liability 
pointer size field 	tort including 
used help 	negligence 
implement extensions malloc 	otherwise arising 
bin types 	way use 
widths sizes locate 	software even 
among fields 	advised possibility 
rarely change use 	damage qsort 
locks unused 	routine 
available extensions malloc 	bentley ilroy 
state malloc 	engineering sort 
malloc holds properties 	function iterate 
including dynamically 	rather recurse 
mallopt single instance 	save stack 
mparams initialized 	space 
init mparams note 	qsort cmp 
non zeroness 	pqsort.h cmp 
magic also 	lrange rrange 
serves initialization flag 	following net 
ensure mparams 	bsd libc 
initialized malloc state 	qsort 
used non 	implementation modified 
mspace calls mspaces 	order support 
system alloc 	sorting ranges 
setup operations mflags 	redis copyright 
page align 	salvatore sanfilippo 
size granularity align 	antirez 
size mmap 	gmail dot 
use granularity alignment 	rights reserved 
windows page 	redistribution use 
align sys alloc 	source binary 
enough padding 	forms without 
ensure malloc request 	modification 
success segment 	permitted provided 
holds address 	following conditions 
segment holding given 	met redistributions 
address segment 	source code 
contains segment link 	must retain 
morecore cannot 	copyright 
trim morecore cannot 	notice list 
trim top 	conditions following 
foot size padding 	disclaimer redistributions 
end segment 	binary form 
including space may 	must reproduce 
needed place 	copyright 
segment records fenceposts 	notice list 
noncontiguous segments 	conditions following 
added hooks preaction 	disclaimer documentation 
defined success 	materials provided 
nonzero failure locking 	distribution neither 
redefine anything 	name 
like use locks 	redis names 
preaction postaction 	contributors may 
use locks 	used endorse 
corruption error action 	promote products 
triggered upon 	derived software 
detected bad addresses 	without 
usage error 	specific prior 
action triggered detected 	written permission 
bad frees 	software provided 
reallocs argument address 	copyright holders 
might triggered 	contributors express 
fault ignored two 	implied 
predefined actions 	warranties including 
might useful custom 	limited implied 
actions help 	warranties merchantability 
diagnose errors count 	fitness particular 
number corruption 	purpose disclaimed 
errors causing resets 	shall 
corruption action 	copyright owner 
proceed error corruption 	contributors liable 
error action 	direct indirect 
usage error 	incidental special 
action proceed error 	exemplary consequential 
debugging setup 	damages 
debug debug indexing 	including limited 
bins addressing 	procurement substitute 
index see smallbin 	goods services 
repositioning assign 	loss use 
index size variable 	data profits 
use asm 	business 
possible gnuc gnuc 	interruption however 
bit representing 	caused theory 
maximum resolved size 	liability whether 
treebin shift 	contract strict 
placing maximum resolved 	liability tort 
bit treebin 	including 
sign bit size 	negligence otherwise 
smallest chunk 	arising way 
held bin index 	use software 
operations bin 	even advised 
maps bit 	possibility damage 
corresponding given index 	see 
mark clear 	pqsort file 
bits given index 	original copyright 
isolate least 	notice print.c 
bit bitmap mask 	code sbx 
bits left 	line full 
least bit mask 	getstr 
bits left 	putchar isprint 
equal least bit 	putchar putchar 
index corresponding 	ttype bvalue 
given bit use 	nvalue print 
asm possible 	rawtsvalue ttype 
gnuc runtime check 	opcode 
support security 	getarg getarg 
main invariant malloc 	getarg getarg 
free etc 	getarg getline 
never writes 	mode mode 
address malloc state 	isk indexk 
unless malloc 	mode 
state corrupted cannot 	isk indexk 
occur via 	mode print 
malloc checks essence 	constant getstr 
means believe 	svalue isk 
pointers sizes maps 	print constant 
etc held 	indexk 
malloc state check 	isk isk 
linked offsetted 	isk print 
embedded data structures 	constant indexk 
checks interspersed 	isk print 
main code way 	constant indexk 
tends minimize 	getstr 
run time cost 	print constant 
footers defined 	getstr getstr 
addition range checking 	print header 
also verify 	print code 
footer fields 	print constants 
inuse chunks used 	print 
guarantee mstate 	locals print 
controlling malloc free 	upvalues print 
intact streamlined 	function print 
version approach described 	lhf exp 
william robertson 	print bytecodes 
run time detection 	see 
heap overflows 	copyright notice 
lisa http www 	lua cannot 
usenix events 	happen prng.h 
lisa tech robertson 	simple linear 
html footer 	congruential pseudo 
inuse chunk holds 	random 
xor mstate 	number generator 
random seed upon 	prng following 
calls free 	constants ensure 
realloc probablistically unguessable 	maximal period 
outside program 	odd number 
computed code 	relatively 
successfully malloc ing 	prime multiple 
chunk provide 	odd number 
protection code already 	relatively prime 
broken security 	see knuth 
means unlike robertson 	taocp vol 
always dynamically 	details 
check addresses offset 	constraints choice 
chunks previous 	disadvantage quality 
next etc turns 	bits proportional 
cheaper relying 	bit position 
hashes check address 	example lowest 
least high 	bit 
morecore mmap check 	cycle next 
address next 	cycle etc 
chunk higher chunk 	reason prefer 
check cinuse 	use upper 
bit check pinuse 	bits macro 
bit insecure 	parameters 
insecure check 	result range 
alleged mstate expected 	number least 
magic field 	significant bits 
footers insecure footers 	state seed 
insecure gcc 	see discussion 
use builtin expect 	prng 
minimize impact 	bits pseudo 
checks gnuc gnuc 	randomness jemalloc 
insecure insecure 	types jemalloc 
macros inuse chunks 	structs jemalloc 
without footers 	externs jemalloc 
cinuse bit pinuse 	inlines 
bit next 	prof.c opt 
chunk cinuse pinuse 	prof opt 
chunk pinuse 	prof active 
next chunk size 	opt prof 
cinuse pinuse 	active init 
bit chunk footers 	opt 
foot inuse 	prof sample 
chunk xor 	opt prof 
mstate seed footers 	interval opt 
setting mparams 	prof gdump 
initialize mparams win 	opt prof 
win sanity 	opt 
check configuration size 	prof leak 
must wide 	opt prof 
pointer type ints 	accum opt 
must least 	prof prefix 
bytes alignment must 	prof active 
least alignment 	prof 
min chunk size 	active mtx 
page size 	prof active 
must powers morecore 	init prof 
contiguous morecore 	active init 
contiguous main malloc 	mtx prof 
area use 	gdump 
dev urandom 	val prof 
fall back time 	gdump mtx 
use dev 	prof interval 
random ensure nonzero 	prof sample 
improve chances 	gctx locks 
fault bad values 	cum 
footers insecure 	gctxs tdata 
footers insecure support 	locks gctx 
mallopt debugging 	gctx mtx 
support check properties 	tdatas tdatas 
chunk whether 	mtx next 
free inuse mmapped 	thr 
etc check 	uid next 
properties top chunk 	thr uid 
third lowest 	mtx prof 
bit check properties 	dump seq 
inuse mmapped 	mtx prof 
chunks check properties 	dump 
inuse chunks 	seq prof 
pinuse mmapped 	dump iseq 
previous chunk offset 	prof dump 
check properties 	mseq prof 
free chunks markers 	dump useq 
always size 	prof 
size size check 	dump mtx 
properties malloced 	prof dump 
chunks point malloced 	buf prof 
unless mmapped 	dump buf 
size less min 	end prof 
chunk size 	dump 
request check subtrees 	prof booted 
traverse chain 	tctx tsd 
sized nodes one 	tctx tdata 
node chain 	even attached 
parent check chunks 	tsd tdata 
treebin check 	even 
chunks smallbin chunk 	attached tsd 
claims free 	name thr 
chunk belongs 	uid thr 
bin chunk followed 	uid ret 
inuse chunk 	thr discrim 
find bin used 	thr 
check functions 	discrim tctx 
traverse chunk check 	uid tctx 
total consecutive 	uid len 
free check properties 	len comp 
malloc state 	len ret 
check bins check 	ret 
chunk check 	uid uid 
top chunk topsize 	discrim discrim 
chunksize top 	tsd tctx 
redundant debug statistics 	updated tdata 
top always 	ptr usize 
free mallinfo operations 	tctx 
smallbins various 	tsd usize 
forms linking unlinking 	tctx vec 
defined macros 	tsd tdata 
even ones 	tsd tdata 
trees typical paths 	idump gdump 
ugly reduces 	nframes 
reliance inlining support 	context arg 
compilers link 	context arg 
free chunk smallbin 	data data 
unlink chunk 	ngctxs thr 
smallbin unlink first 	uid tsd 
chunk smallbin 	gctx 
replace node binning 	tsd tdata 
old one 	self gctx 
used dvsize known 	tdata tctx 
small operations 	gctx tsd 
trees insert chunk 	tctx tdata 
unlink steps 	gctx 
chained node unlink 	destroy tdata 
sized links 	destroy tctx 
choose node 	destroy gctx 
replacement last node 	tsd tdata 
size leaf 	btkey gctx 
node must replaced 	gctx 
leaf node 	gctx tsd 
merely one open 	tdata found 
left right 	tcache btkey 
make sure lefts 	gctx gctx 
rights descendants 	error tdata 
correspond properly bit 	tdatas 
masks use 	tdata arg 
rightmost descendant could 	tdata count 
use leaf 	tdata count 
easy locate tends 	count tsd 
counteract removal 	tdata propagate 
leftmosts elsewhere keeps 	err 
paths shorter 	filename prof 
minimally guaranteed doesn 	dump open 
loop much 	propagate err 
average node 	ret err 
near bottom chain 	propagate err 
parent links 	ret 
relink parent children 	propagate err 
replacement none 	slen propagate 
relays large small 	err format 
bin operations 	ret buf 
relays calls malloc 	tctx tdata 
free realloc 	tctx 
memalign etc mspaces 	gctx tctxs 
mspaces mspaces 	tctx arg 
mspaces direct mmapping 	tctxs tctx 
chunks directly 	arg propagate 
mmapped chunks offset 	err tctxs 
start mmapped 	tctx 
region stored prev 	arg ret 
foot field 	gctx gctxs 
chunk allows reconstruction 	gctxs gctx 
required argument 	arg leak 
munmap freed 	ngctx tsd 
also allows adjustment 	gctxs 
returned chunk 	tdata gctx 
meet alignment requirements 	next destroy 
especially memalign 	tdatas tdata 
also enough space 	arg cnt 
allocated hold 	tabind tdatas 
fake next chunk 	tdata 
size size 	arg propagate 
size maintain pinuse 	err propagate 
bit frees 	err cnt 
malloc mmap check 	ret prof 
wrap around 	dump header 
realloc mmap shrink 	propagate 
mmap regions 	err gctx 
small size keep 	gctxs ret 
old chunk 	format mfd 
big enough big 	filename propagate 
mspace management 	err ret 
initialize top 	mfd 
chunk size ensure 	pid nread 
alignment size 	cnt leak 
fake trailing chunk 	ngctx filename 
holding overhead 	gctxs gctx 
space reset update 	arg ret 
initialize bins 	propagate 
mstate otherwise zeroed 	err tsd 
establish circular 	propagate err 
links smallbins corruption 	filename leakcheck 
action reinitialize 	tdata cnt 
fields forget memory 	tabind leak 
proceed error 	ngctx 
allocate chunk prepend 	gctxs filename 
remainder chunk 	vseq tsd 
successor consolidate remainder 	filename tsd 
first chunk 	tdata filename 
old segment hold 	filename tsd 
noncontiguous region 	filename 
determine locations 	buf tsd 
sizes segment fenceposts 	tdata filename 
old top 	key hash 
reset top space 	thr uid 
segment record 	tsd 
push current record 	thr uid 
insert trailing 	thr discrim 
fenceposts insert rest 	name active 
old top 	tdata tcache 
bin ordinary free 	tsd tdata 
chunk system 	even 
allocation memory system 	attached tsd 
morecore mmap 	tdata even 
directly map large 	attached tcache 
chunks getting 	tsd tdata 
memory three ways 	even attached 
preferred least 	tsd 
preferred order 	tdata destroy 
call morecore normally 	tdata tsd 
contiguously extend 	tdata thr 
memory disabled morecore 	uid thr 
contiguous morecore 	discrim name 
main space mmapped 	active 
previous contiguous 	tdata destroy 
call failed call 	tdata tdatas 
mmap space 	tdata arg 
disabled mmap note 	tsd sample 
settings morecore 	next destroy 
unable fulfill request 	tsd 
mmap mmap 	tdata prof 
used noncontiguous system 	active current 
allocator useful 	active prof 
backup strategy systems 	active old 
holes address 	tsd tdata 
spaces sbrk cannot 	tsd 
contiguously expand 	name ret 
heap mmap 	size tsd 
may able find 	name tdata 
space call 	tsd tdata 
morecore cannot usually 	active tsd 
contiguously extend 	tdata 
memory disabled morecore 	active init 
cases need 	active init 
request enough bytes 	active init 
system ensure 	old prof 
malloc bytes upon 	gdump current 
success pad 	gdump 
enough space top 	prof gdump 
foot plus 	old tsd 
alignment pad make 	memcmp cassert 
sure lose 	prof tdata 
bytes boundary round 	prof sample 
granularity unit 	threshold 
first time recovery 	update malloc 
adjust end 	mutex prof 
page boundary 	tctx destroy 
call morecore size 	prof tctx 
negative treated 	destroy malloc 
subtract existing available 	mutex 
top space 	unlock prof 
morecore request use 	tctx malloc 
mem continuously 	mutex malloc 
extend old space 	mutex unlock 
cope failure 	malloc mutex 
use extend space 	prof 
use release 	tctx destroy 
use space contiguous 	prof tctx 
path future 	destroy malloc 
mmap fail wraps 	mutex unlock 
around zero 	cassert cassert 
noncontiguous morecore first 	prof 
time initialization 	tdata malloc 
offset top embedded 	mutex cassert 
malloc state 	prof tdata 
merge existing 	malloc mutex 
segment consider recent 	unlock prof 
segment traversal 	idump 
suppressed append allocate 	prof gdump 
extended top 	cassert unw 
space system deallocation 	backtrace cassert 
unmap unlink 	cassert unwind 
mmapped segments contain 	cassert unwind 
used chunks 	backtrace 
unmap first chunk 	cassert cassert 
holds entire 	reached atomic 
segment pinned unlink 	iallocztm offsetof 
obsoleted record 	tcache prof 
back cannot unmap 	gctx mutex 
scan first 	choose 
segment reset check 	tctx memcpy 
counter ensure 	cassert prof 
enough room 	enter malloc 
segment overhead shrink 	mutex tctx 
top space 	empty ckh 
granularity size units 	reached 
keeping least 	prof malloc 
one shrink pinned 	mutex unlock 
prefer mremap 	idalloctm tcache 
fall back munmap 	malloc mutex 
avoid wrapping 	unlock prof 
negative make sure 	tctx 
end memory 	empty ckh 
last unmap unused 	prof tdata 
mmapped segments 	destroy malloc 
failure disable autotrim 	mutex unlock 
avoid repeated 	malloc mutex 
failed future calls 	tctx 
malloc support 	prof gctx 
allocate large request 	destroy reached 
best fitting 	malloc mutex 
chunk treebin 	unlock prof 
negation traverse bin 	gctx destroy 
looking node 	prof 
size deepest untaken 	tdata prof 
right subtree 	tdata destroy 
least subtree holding 	idalloctm tcache 
sizes root 	prof enter 
next non empty 	ckh search 
treebin find 	prof 
smallest subtree better 	gctx create 
fit malloc 	prof ckh 
use split allocate 	insert prof 
small request 	idalloctm tcache 
best fitting chunk 	malloc mutex 
treebin realloc 	malloc 
support either shrink 	mutex unlock 
extend top 	prof cassert 
malloc copy free 	prof tdata 
already big 	malloc mutex 
enough expand 	ckh search 
top memalign support 	malloc 
use malloc 	mutex unlock 
must least minimum 	prof lookup 
chunk size 	tcache iallocztm 
ensure power test 	prof gctx 
isn needed 	destroy memset 
avoids compiler warning 	malloc 
misaligned find 	mutex ckh 
aligned spot inside 	insert malloc 
chunk since 	mutex unlock 
need give back 	prof gctx 
leading space 	destroy idalloctm 
chunk least min 	malloc 
chunk size 	mutex tctx 
first calculation places 	insert malloc 
spot less 	mutex unlock 
min chunk size 	prng log 
leader move 	log malloc 
next aligned 	mutex 
spot allocated enough 	tdata iter 
total room 	malloc mutex 
always possible mmapped 	unlock tsd 
chunks adjust 	fetch prof 
offset otherwise give 	tdata malloc 
back leader 	mutex 
use rest give 	ckh count 
back spare 	malloc mutex 
room end comalloc 	unlock creat 
coalloc support 	malloc abort 
provides common support 	jemalloc cassert 
independent routines 	write 
handling combinations result 	malloc write 
opts arg 	abort prof 
bit elements size 	dump flush 
sizes bit 	close cassert 
elements zeroed 	strlen prof 
chunksize element total 	dump 
size elements 	flush memcpy 
request size pointer 	start malloc 
malloced aggregate 	vsnprintf end 
space corresponding chunk 	prof dump 
remaining bytes 	write malloc 
splitting either chunks 	mutex 
malloced ptr 	malloc mutex 
chunk malloced ptr 	unlock malloc 
disable mmap 	mutex unlock 
compute length needed 	memcpy reached 
nothing empty 	prof tctx 
req must still 	merge 
chunk representing 	gctx reached 
empty compute total 	prof dump 
element size 	reached reached 
size sizes allocate 	cassert malloc 
aggregate chunk 	mutex gctx 
first disable 	insert 
direct mmapping malloc 	memset malloc 
won use 	mutex unlock 
since would able 	malloc mutex 
later free 	tctx iter 
realloc space segregated 	malloc mutex 
mmap region 	unlock 
optionally clear elements 	prof tdata 
provided allocate 	gctx first 
pointer part chunk 	gctx malloc 
split elements 	mutex tctx 
element absorbs overallocation 	iter tctx 
slop element 	next 
must exactly exhausted 	tctx idalloctm 
chunk debug 	tcache prof 
routines basic algorithm 	gctx destroy 
small request 	malloc mutex 
bytes minus per 	unlock prof 
chunk overhead 	gctx 
one exists 	destroy malloc 
use remainderless chunk 	mutex unlock 
associated smallbin 	malloc mutex 
remainderless means excess 	memset ckh 
bytes represent 	iter prof 
chunk big enough 	tctx 
use chunk 	merge tdata 
normally chunk adjacent 	malloc mutex 
one used 	unlock prof 
recent small request 	dump prof 
one exists 	dump malloc 
split smallest available 	mutex 
chunk bin 	tdata iter 
saving remainder big 	malloc mutex 
enough use 	unlock jemalloc 
top chunk available 	cassert prof 
memory system 	dump prof 
use otherwise large 	dump 
request find 	prof dump 
smallest available 	tctx iter 
binned chunk fits 	start malloc 
use better 	vsnprintf end 
fitting chunk splitting 	open cassert 
necessary better 	prof 
fitting binned chunk 	open maps 
use chunk 	getpid prof 
big enough use 	open maps 
top chunk 	prof open 
request size mmap 	maps prof 
threshold directly 	dump 
mmap chunk available 	write prof 
memory system 	dump flush 
use ugly ensure 	read close 
postaction occurs 	malloc malloc 
along paths initialize 	malloc mutex 
sys alloc 	prof 
locks remainderless fit 	dump gctx 
smallbin uses 	malloc mutex 
next bin 	unlock cassert 
idx empty use 	prof tdata 
chunk next 	malloc mutex 
nonempty smallbin fit 	prof 
cannot remainderless 	enter gctx 
sizes big allocate 	ckh iter 
force failure 	prof dump 
sys alloc split 	gctx prep 
exhaust split 	memset malloc 
top consolidate freed 	mutex 
chunks preceding 	tdata iter 
succeeding bordering free 	malloc mutex 
chunks exist 	unlock gctx 
place bin intermixed 	iter prof 
special cases 	prof dump 
top mmapped chunks 	open 
usage errors 	prof dump 
footers footers 	header gctx 
consolidate backward consolidate 	iter prof 
forward footers 	dump maps 
force downstream failure 	prof dump 
overflow realloc 	close 
zero bytes frees 	prof gctx 
footers footers 	finish malloc 
serves element mallinfo 	mutex unlock 
mspaces user 	prof leakcheck 
mspaces mspace versions 	prof dump 
routines near 	close 
clones versions nice 	prof gctx 
better alternatives 	finish malloc 
remainderless fit smallbin 	mutex unlock 
uses next 	cassert malloc 
bin idx empty 	snprintf getpid 
use chunk 	malloc 
next nonempty smallbin 	snprintf getpid 
fit cannot 	cassert tsd 
remainderless sizes 	fetch malloc 
big allocate force 	mutex prof 
failure sys 	dump filename 
alloc split exhaust 	malloc 
split top 	mutex unlock 
footers footers consolidate 	prof dump 
backward consolidate 	cassert tsd 
forward force downstream 	fetch prof 
failure overflow 	tdata malloc 
realloc zero bytes 	mutex 
frees footers 	prof dump 
footers serves element 	filename malloc 
mallinfo mspaces 	mutex unlock 
alternative morecore functions 	prof dump 
guidelines creating 	cassert tsd 
custom version morecore 	fetch 
best performance 	malloc mutex 
morecore allocate multiples 	prof dump 
pagesize morecore 	filename malloc 
may allocate 	mutex unlock 
memory requested even 	prof dump 
less usually 	cassert 
result malloc failure 	tsd fetch 
morecore must 	prof tdata 
allocate memory given 	malloc mutex 
argument zero 	prof dump 
instead one past 	filename malloc 
end address 	mutex 
memory previous nonzero 	unlock prof 
call best 	dump cassert 
performance consecutive calls 	hash cassert 
morecore positive 	memcmp malloc 
arguments increasing addresses 	mutex malloc 
indicating space 	mutex 
contiguously extended even 	unlock cassert 
though consecutive 	tcache iallocztm 
calls morecore need 	prof tdata 
contiguous addresses 	mutex choose 
must malloc 	ckh idalloctm 
chunks span multiple 	prof 
regions cases 	sample threshold 
happen contiguous morecore 	update malloc 
need handle 	mutex tdata 
negative arguments may 	insert malloc 
instead mfail 	mutex unlock 
given negative arguments 	prof 
negative arguments 	tdata init 
always multiples pagesize 	impl prof 
morecore must 	thr uid 
misinterpret negative args 	alloc prof 
large positive 	active init 
args suppress calls 	ckh 
even occurring 	count prof 
defining morecore cannot 	tdata destroy 
trim example 	tsd prof 
alternative morecore 	tdata tdata 
custom allocator kindly 	tcache idalloctm 
contributed pre 	ckh 
osx mac uses 	idalloctm malloc 
virtually necessarily 	mutex prof 
physically contiguous non 	tdata destroy 
paged memory 	locked malloc 
locked present won 	mutex unlock 
swapped use 	malloc 
uncommenting section adding 	mutex prof 
includes setting 	tdata destroy 
appropriate defines define 	tsd prof 
morecore core 	tdata malloc 
also shutdown routine 	mutex unlock 
somehow called 	prof 
cleanup upon program 	tdata destroy 
exit define 	prof name 
max pool entries 	alloc prof 
define minimum 	tdata detach 
morecore size 	prof tdata 
next pool pools 	init 
max pool 	impl malloc 
entries core size 	mutex prof 
ptr sbrk 	tdata destroy 
top size size 	malloc mutex 
minimum morecore 	unlock prof 
size size minimum 	tdata 
morecore size 	expire malloc 
current execution level 	mutex malloc 
task level 	mutex tdata 
ptr pool allocate 	iter tdata 
resident size 	next prof 
page size ptr 	tdata 
mfail save 	destroy locked 
ptrs freed cleanup 	malloc mutex 
pools next 	unlock malloc 
pool ptr next 	mutex unlock 
pool ptr 	tsd prof 
size ptr 	tdata 
page mask page 	prof tdata 
mask sbrk 	detach malloc 
top ptr size 	mutex malloc 
ptr size 	mutex unlock 
currently support shrink 	malloc mutex 
behavior mfail 	malloc 
sbrk top cleanup 	mutex unlock 
allocated memory 	tsd fetch 
pools called last 	prof tdata 
thing shutting 	strlen iallocztm 
driver cleanup mem 	tcache memcpy 
ptr ptr 	prof 
pools ptr pools 	tdata isgraph 
max pool 	isblank prof 
entries ptr ptr 	name alloc 
pool deallocate 	idalloctm tcache 
ptr ptr history 	strlen tsd 
yet released 	fetch 
mspace mmap 	prof tdata 
large chunks thanks 	tsd fetch 
jean brouwers 	prof tdata 
fix insufficient sys 	malloc mutex 
alloc padding 	malloc mutex 
alignment fix bad 	unlock 
error check 	malloc mutex 
mspace footprint adaptations 	malloc mutex 
ptmalloc courtesy 	unlock malloc 
wolfram gloger reentrant 	mutex malloc 
spin locks 	mutex unlock 
courtesy earl chew 	malloc 
others win 	mutex malloc 
improvements courtesy niall 	mutex unlock 
douglas earl 	cassert memcpy 
chew segment traversal 	cassert cassert 
max release 	malloc mutex 
check rate 	init 
options extension hook 	malloc mutex 
malloc state 	init malloc 
various small adjustments 	mutex init 
reduce warnings 	tsd fetch 
compilers various configuration 	ckh malloc 
extensions changes 	mutex 
platforms thanks contributed 	init tdata 
thu sep 	malloc mutex 
doug lea gee 	init malloc 
max footprint 	mutex init 
functions ensure appropriate 	malloc mutex 
literals size 	init 
fix conditional compilation 	malloc mutex 
problem define 	init atexit 
settings avoid concatenating 	malloc write 
segments one 	abort alloc 
provided create mspace 	malloc mutex 
rename variables 	init 
avoid compiler 	alloc malloc 
shadowing warnings use 	mutex init 
initialization better 	unwind backtrace 
handling sbrk interference 	malloc mutex 
simplify fix 	prefork malloc 
segment insertion trimming 	mutex 
mspace destroy 	prefork malloc 
reinstate realloc zero 	mutex prefork 
bytes frees 	malloc mutex 
option thanks especially 	prefork malloc 
dennis flanagan 	mutex 
help sun jun 	prefork malloc 
doug lea 	mutex prefork 
gee fix memalign 	malloc mutex 
brace error 	postfork parent 
wed jun doug 	malloc mutex 
lea gee 	postfork 
fix improper endif 	parent malloc 
nesting casts 	mutex postfork 
needed mon 	parent malloc 
may doug lea 	mutex postfork 
gee use 	parent malloc 
trees large bins 	mutex 
support mspaces 	postfork parent 
use segments unify 	malloc mutex 
sbrk mmap 	postfork parent 
system allocation removing 	malloc mutex 
need emulation 	postfork child 
platforms without sbrk 	malloc 
safety checks 	mutex postfork 
optional footer checks 	child malloc 
thanks william 	mutex postfork 
robertson idea code 	child malloc 
refactoring incorporate 	mutex postfork 
suggestions platform specific 	child 
changes thanks 	malloc mutex 
dennis flanagan colin 	postfork child 
plumb niall 	malloc mutex 
douglas aaron 	postfork child 
bachmann emery berger 	data minimize 
others speed 	memory 
non fastbin processing 	bloat non 
enough fastbins 	prof builds 
useless cfree avoid 	initialized opt 
conflicts apps 	prof active 
memcpy memset compilers 	accessed via 
handle builtins 	prof 
better options one 	active unlocked 
ever used 	initialized opt 
rename others sat 	prof active 
aug doug 	init accessed 
lea gee fix 	via prof 
malloc state 	active 
bitmap misdeclaration thu 	init initialized 
jul doug 	opt prof 
lea gee allow 	gdump accessed 
tuning first 	via prof 
sorted bin 	gdump unlocked 
size use ptr 	table 
type ptr 	mutexes shared 
casts thanks john 	among gctx 
belmonte better 	leaf locks 
detection support non 	problem one 
contiguousness morecore 	gctx time 
thanks andreas mueller 	primary 
conal walsh 	motivation sharing 
wolfram gloger bypass 	though gctx 
malloc frees 	ephemeral destroying 
thanks emery berger 	mutexes causes 
fix freeing 	complications systems 
old top non 	allocate 
contiguous chunk 	creating destroying 
sysmalloc raised trim 	mutexes atomic 
map thresholds 	counter table 
fix mmap 	mutexes shared 
related defines thanks 	among tdata 
lubos lunak 	operations 
fix copy macros 	require holding 
added lacks 	multiple tdata 
fcntl thanks neal 	locks problem 
walfield branch 	one tdata 
free bin calculation 	time even 
trim mmap 	though 
thresholds sun mar 	gctx may 
doug lea 	acquired holding 
gee introduce independent 	tdata hash 
comalloc independent 	prof prof 
calloc thanks michael 	gctx master 
pachos motivation 	data 
help make optional 	structure knows 
file available 	backtraces currently 
allow requests bit 	captured extant 
systems win 	prof tdata 
sbrk mmap 	structures regardless 
munmap code walter 	state 
sys thanks 	attached detached 
also andreas mueller 	expired buffer 
mueller paradatec 	rather large 
anonymous allow malloc 	stack allocation 
alignment thanks 	use single 
ruud waij helping 	buffer 
test memalign 	profile dumps 
check alignment arg 	minimize memory 
realloc shift 	bloat non 
chunks backwards since 	prof builds 
leads fragmentation 	dump profiles 
programs doesn seem 	bootstrapping 
help others 	complete function 
collect cases malloc 	prototypes functions 
requiring system 	referenced prior 
memory sysmalloc use 	definition red 
mmap backup 	black trees 
sbrk place 	compute 
state malloc state 	sample threshold 
introduce fastbins 	isn important 
although similar many 	practice function 
minor tunings 	rarely executed 
cosmetic improvements introduce 	potential sample 
use malloc 	bias 
wrappers use malloc 	minimal contrived 
introduce malloc 	programs create 
failure action morecore 	single allocation 
contiguous thanks 	space vec 
tony bennett tbennett 	length len 
nvidia others 	nlimbo 
include errno support 	order avoid 
failure action 	race condition 
sun dec doug 	prof tctx 
lea gee 	destroy prof 
negative arguments added 	gctx destroy 
several win 	duplicate 
cleanups martin 	check gctx 
fong mcfong yahoo 	still unused 
lacks sys 	cache destroying 
param systems without 	prof lookup 
sys param 	increments gctx 
win platforms cleanup 	nlimbo 
header file 	order avoid 
inclusion win platforms 	race condition 
cleanup code 	function prof 
avoid microsoft visual 	tctx destroy 
compiler complaints 	order avoid 
use prefix quickly 	race 
allow existence 	main body 
existing memory allocation 	prof tctx 
routines malloc 	destroy entry 
getpagesize win platforms 	function gctx 
needs work 	gctx destroy 
use rather 	gctx 
win code conform 	compensate increment 
usage non 	prof tctx 
win code improve 	destroy prof 
win sbrk 	lookup tctx 
emulation find region 	tdata must 
routine avoid 	held 
infinite loop always 	tctx tdata 
call rather 	held upon 
free wed jun 	entry released 
doug lea 	increment gctx 
gee ordering problem 	nlimbo order 
boundary stamping 	keep 
sun may doug 	another winning 
lea gee 	race destroy 
added pvalloc recommended 	gctx one 
liu added 	gctx dropped 
bit pointer support 	without would 
mainly wolfram 	possible 
gloger added 	another sample 
anonymously donated win 	allocation associated 
sbrk emulation 	gctx deallocate 
malloc calloc getpagesize 	sampled successfully 
optimizations raymond 	prof gctx 
nijssen malloc extend 	destroy 
top fix 	gctx result 
mask error caused 	would gctx 
wastage foreign 	longer exists 
sbrks linux mremap 	time accesses 
support code 	prof gctx 
liu tue dec 	destroy 
doug lea 	dumping needs 
gee integrated documentation 	tctx remain 
code support 	valid dumping 
mmap help wolfram 	finished change 
gloger gloger 	state dumping 
lrz uni muenchen 	complete 
use last 	destruction late 
remainder cases 	dump iteration 
pack bins idea 	phase never 
colin nyx 	seen insert 
edu use ordered 	oom increment 
bins instead 	nlimbo 
best fit threshold 	order avoid 
eliminate block 	race condition 
local decls simplify 	prof tctx 
tracing debugging 	destroy prof 
support another realloc 	gctx destroy 
via move 	note 
top fix error 	negative cache 
occurring initial 	lacks look 
sbrk word aligned 	cache link 
rely page 	prof tctx 
size units instead 	gctx body 
sbrk unit 	function 
avoid surprises sbrk 	compiled unless 
alignment conventions 	heap profiling 
mallinfo mallopt 	enabled possible 
thanks raymond nijssen 	compile jemalloc 
raymond ele 	floating point 
tue suggestion pad 	support 
argument malloc 	completely disabled 
trim top pad 	avoiding floating 
mallopt parameter 	point code 
precautions cases routines 	important memory 
call sbrk 	constrained systems 
courtesy wolfram gloger 	also 
gloger lrz 	enables workaround 
uni muenchen added 	versions glibc 
macros etc 	properly save 
allowing use linux 	restore floating 
libc hjl 	point registers 
gnu mit edu 	lazy 
inverted history 	symbol loading 
list sat 	internally calls 
dec doug lea 	whatever malloc 
gee tuned 	implementation happens 
behave nicely changes 	integrated application 
removed preallocation 	note 
code since current 	compilers gcc 
scheme work 	may use 
required undo bad 	floating point 
preallocations exceeds 	registers fast 
work saved good 	memory moves 
cases test 	jemalloc 
programs longer use 	must compiled 
list unconsolidated 	optimizations disabled 
bins since scheme 	mno sse 
consistently outperforms 	order workaround 
given changes use 	complete compute 
best fit 	sample 
large chunks prevent 	interval geometrically 
worst cases 	distributed random 
added support 	variable mean 
debugging sat nov 	prof sample 
doug lea 	log tdata 
gee removed footers 	bytes 
chunks use 	sample log 
thanks paul wilson 	prof sample 
wilson texas 	information math 
edu suggestion wed 	see non 
nov doug 	uniform random 
lea gee added 	variate 
malloc trim 	generation luc 
help wolfram gloger 	devroye springer 
wmglo dent 	verlag york 
med uni muenchen 	http luc 
tue apr 	devroye rnbookindex 
doug lea tue 	html 
apr doug 	flush buffer 
lea realloc expand 	full finish 
directions malloc 	writing write 
swap order 	much fit 
clean bin strategy 	tctx tdata 
realloc conditionally 	held 
expand backwards scavenge 	gctx held 
used bins 	tctx gctx 
use bin counts 	held since 
guide preallocation 	dumping started 
occasionally bin list 	ignore gctx 
chunks first 	held 
scan optimizations colin 	captured dump 
nyx edu 	tctx gctx 
sat aug doug 	held since 
lea faster 	dumping started 
bin computation slightly 	ignore increment 
different binning 	nlimbo 
merged consolidations one 	gctx won 
part malloc 	away dump 
proper eliminating old 	additionally link 
malloc find 	gctx dump 
space malloc 	list included 
clean bin scan 	prof 
returns chunks 	dump second 
propagate failure realloc 	pass standard 
malloc returns 	iteration won 
stuff allow compilation 	work soon 
non ansi 	decrement gctx 
compilers kpv research 	nlimbo 
att sat 	unlock gctx 
aug doug lea 	another concurrently 
oswego edu 	destroy corrupt 
removed potential odd 	therefore tear 
address access 	one node 
prev chunk removed 	time 
dependency getpagesize 	iteration gctx 
misc cosmetics bit 	held avoid 
documentation anticosmetics 	dumping gctx 
mangled names macros 	useful data 
evade debugger 	make space 
strangeness tested 	prof 
sparc dec mips 	dump buf 
gcc dec 	read put 
allowing detlefs zorn 	gctx limbo 
comparison study 	clear counters 
sigplan notices trial 	preparation summing 
version fri 	iterate 
aug doug lea 	tdatas non 
oswego edu 	expired ones 
loosely libg malloc 	snapshot tctx 
retains overall 	stats merge 
structure old version 	associated gctx 
details differ 	merge 
match-trees.c mode path 	tctx stats 
score mode 	gctx create 
mode path score 	dump file 
mode mode 	dump profile 
path score 	header dump 
desc hash buffer 	per 
size hash 	gctx profile 
hash one two 	stats dump 
one buf 	proc pid 
two buf score 	maps possible 
got entry 	prefix pid 
one got entry 	seq 
two cmp 	vseq heap 
hash hash best 	prefix pid 
score best 	seq heap 
match recurse limit 	filename specified 
one one 	automatically generate 
buf path elem 	one 
mode score 	initialize empty 
newbase hash prefix 	cache tdata 
hash result 	must held 
subpath toplen buf 	tdatas mtx 
desc rewrite 	must held 
rewrite subtree 	detach 
status name mode 	destroy tdata 
sha hash 	detaching would 
hash shifted depth 	allow another 
limit prefix 	win race 
del prefix score 	destroy tdata 
del score 	validate 
mode hash hash 	input opt 
shifted shift 	prof must 
prefix sub sub 	state arenas 
mode mode 	initialized function 
candidate best score 	must executed 
score isdir 	early 
islnk isdir isdir 	enable opt 
islnk islnk 	prof way 
isdir isdir islnk 	profiles never 
islnk isdir 	automatically dumped 
islnk read sha 	cause backtracing 
file die 	machinery 
sha hex 	allocate state 
die sha hex 	enabling profiling 
init desc 	prof.h vec 
name compare entry 	len curobjs 
len entry 	curbytes accumobjs 
len fill desc 	accumbytes 
strict fill 	tdata thr 
desc strict entry 	uid thr 
entry name 	discrim cnts 
entries compare score 	gctx tctx 
missing score 	uid prepared 
missing hashcmp score 	state 
differs score 	dump cnts 
matches free free 	nlimbo tctxs 
fill desc 	cnt summed 
strict entry extract 	vec thr 
isdir score 	uid thr 
trees free xstrfmt 	discrim 
xstrfmt match 	name attached 
trees free 	expired tctx 
update entry free 	uid next 
strchrnul read 	tctx prng 
sha file die 	state bytes 
sha hex 	sample 
init desc entry 	enq enq 
extract strlen 	idump enq 
memcmp isdir die 	gdump dumping 
sha hex 	active cnt 
update entry die 	summed vec 
sha hex 	opt 
splice hashcpy write 	prof opt 
sha file 	prof active 
free score trees 	opt prof 
xcalloc xcalloc 	active init 
match trees match 	opt prof 
trees hashcpy 	sample 
entry die 	opt prof 
sha hex splice 	interval opt 
entry isdir 	prof gdump 
entry isdir score 	opt prof 
trees score 	opt prof 
trees score trees 	leak 
hashcpy splice 	opt prof 
hashcpy heh found 	accum opt 
sha collisions 	prof prefix 
different kind objects 	prof active 
inspect two 	prof gdump 
trees give score 	val 
tells similar 	prof interval 
two lacks entry 	prof sample 
two entries 	tsd tctx 
path appear two 	updated ptr 
path appear 	usize tctx 
one different subtree 	tsd 
blob match 	usize tctx 
one subtrees 	vec tsd 
two pick best 	prof dump 
match hash 	open prof 
subdirectory prefix come 	dump header 
replacing another 	filename 
hash trying come 	tsd tsd 
merge one 	tdata tsd 
two results shape 	sample tsd 
similar one 	active tsd 
two might correspond 	name active 
subtree one 	active 
needs shifted prefixing 	init active 
otherwise empty 	tdata tsd 
directories hand could 	create tsd 
cover one 	usize commit 
might need pick 	tdata tsd 
subtree needswork 	usize 
limits recursion depth 	prof active 
hardcoded avoid 	update ptr 
excessive overhead 	ptr usize 
see one subtree 	tctx ptr 
resembles two 	usize old 
need prefix two 	ptr 
fake trees 	tctx ptr 
match prefix see 	usize tctx 
two subtree 	ptr usize 
resembles one need 	tctx tsd 
pick subtree 	ptr usize 
two shifting need 	tctx 
pick subtree 	prof active 
two user says 	updated old 
trees shifted 	ptr old 
much unfortunately cannot 	usize old 
fundamentally tell 	tctx tsd 
one prefixed recursive 	ptr 
merge work 	usize tsd 
either direction hash 	create tdata 
shift prefix 	ptr ptr 
hash hash 	usize tctx 
shift prefix hash 	ptr 
plausible need 	usize old 
evaluate score neither 	ptr old 
plausible shift 	tctx tsd 
shift adding shift 	usize update 
prefix match 	tdata tdata 
shift removing shift 	tsd 
prefix match 	usize prof 
memmem.c haystack haystack 	active update 
len needle 	ret tdata 
needle len begin 	ptr usize 
last possible 	tctx tsd 
tail point memcmp 	ptr 
first occurrence 	usize tctx 
empty deemed occur 	prof active 
beginning sanity 	updated old 
check otherwise 	ptr old 
loop might search 	usize old 
whole memory 	tctx 
merge-base.c rev rev 	sampled old 
show result 	sampled tsd 
merge usage arg 	ptr usize 
revkey count 	tctx cassert 
args revs result 	tsd prof 
count args 	tdata 
show revs result 	unlikely tsd 
argc argv 	nominal prof 
one two commit 	tdata init 
alloc sha 	tsd prof 
revs commit osha 	tdata unlikely 
nsha ident 	prof 
timestamp message cbdata 	tdata reinit 
revs argc 	tsd prof 
argv sha refname 	tdata cassert 
commitname revs 	arena prof 
derived bases 	tctx cassert 
ret argc argv 	arena 
prefix rev 	prof tctx 
rev show cmdmode 	cassert arena 
options merge 	prof tctx 
bases many dirty 	reset cassert 
oid hex 	prof tdata 
sha die lookup 	prof 
commit reference 	sample threshold 
die commit list 	update likely 
insert commit 	prof sample 
reference reduce heads 	accum update 
oid hex 	init prof 
commit list insert 	backtrace 
commit reference 	prof lookup 
reduce heads octopus 	cassert isalloc 
merge bases 	unlikely prof 
oid hex die 	malloc sample 
commit reference 	prof tctx 
commit reference 	cassert 
merge bases sha 	isalloc prof 
lookup commit 	sample accum 
parse commit alloc 	update unlikely 
grow one 	prof malloc 
commit one commit 	sample prof 
dwim strlen 	tctx 
die die sha 	reset unlikely 
die lookup 	prof free 
commit reference memset 	sampled prof 
reflog ent 	tctx cassert 
merge bases many 	isalloc unlikely 
dirty oid 	prof 
hex free commit 	free sampled 
list git 	option defaults 
config parse options 	hard limit 
usage options 	stack backtrace 
die handle ancestor 	depth version 
die handle 	prof 
octopus handle 	backtrace builtin 
independent usage options 	address necessarily 
handle fork 	hard coded 
point usage options 	number backtrace 
alloc commit 	frame handlers 
reference show merge 	kept 
good one 	sync setting 
one merge found 	initial hash 
common ancestor 	table size 
among reflog entries 	size memory 
found one 	buffer use 
must one reflog 	writing 
entries found 	dump files 
found merge-blobs.c obj 	size stack 
buf size 	allocated buffer 
path size merge 	used prof 
status res 	number mutexes 
path size res 	shared 
common read 	among gctx 
sha file 	space allocated 
free free merge 	unless profiling 
read sha 	enabled okay 
file fill mmfile 	provision number 
blob fill 	mutexes 
mmfile blob fill 	shared among 
mmfile blob 	tdata space 
xstrdup three way 	allocated unless 
filemerge free 	profiling enabled 
mmfile free mmfile 	okay provision 
free mmfile 	prof 
function used cmd 	tdata pointers 
merge respect 	close used 
merge conflictstyle option 	encode state 
need worry 	information used 
label common ancestor 	cleaning shutdown 
removed either 	jemalloc 
branch note 	types backtrace 
depends caller done 	stored len 
proper warning 	program counters 
removing file got 	data structure 
modified branch 	passed libgcc 
merge-blobs.h blob blob 	unwind 
blob merge 	backtrace callback 
blobs merge-file.c merge 	functions profiling 
file usage 	counters dumper 
opt arg unset 	must finish 
label count 	destroying data 
names argc argv 	performed 
prefix names 	allocation copy 
mmfs result xmp 	tdata thr 
stdout quiet 	uid discrim 
prefixlen options fname 	necessary tdata 
filename fpath 	may defunct 
error git config 	teardown 
parse options 	profiling counters 
usage options 	tdata associated 
freopen error strerror 	context uid 
strlen prefix 	distinguishes multiple 
filename read mmfile 	tctx created 
buffer binary 	coexisting 
error xdl merge 	gctx tctxs 
free prefix 	two ways 
filename fopen error 	coexistence occur 
fwrite error 	dumper cause 
fclose error free 	tctx retained 
read configuration 	purgatory 
file merge-index.c pgm 	state although 
one shot 	single producer 
quiet err pos 	must create 
path found 	tctx share 
arguments hexbuf ownbuf 	thr uid 
stage path 	multiple 
pos argc argv 	consumers concurrently 
prefix force 	execute portions 
file arg 	prof tctx 
die stage strcmp 	destroy prof 
sha hex 	tctx destroy 
xsnprintf die run 	gets 
command opt 	called time 
die exit cache 	cnts cur 
name pos 	objs bytes 
strlen merge entry 	drop threshold 
stage merge 	hit first 
entry signal usage 	consumer 
read cache 	finishes executing 
strcmp strcmp strcmp 	prof tctx 
strcmp merge 	destroy linkage 
die merge one 	gctx tctxs 
path die 	prof alloc 
already exists cache 	prep 
stage already 	prof malloc 
merged nothing without 	sample prevents 
cannot rely 	sample destroy 
waitpid tell 	race current 
happened children merge-ours.c 	dump related 
builtin merge 	state 
usage diff index 	gctx copy 
args argc 	cnts snapshotted 
argv prefix strcmp 	early dump 
usage cmd 	phase dump 
diff index exit 	mtx protects 
exit implementation 	nlimbo 
git merge builtin 	cnt summed 
copyright thomas 	tctxs number 
harning original original 	threads currently 
copyright junio 	cause gctx 
hamano pretend resolved 	state limbo 
heads declare 	due 
trumps everybody need 	one initializing 
exit index 	gctx initializing 
match head 	per counters 
current index committing 	associated gctx 
merge result 	preparing destroy 
merge-recursive.c one two 	gctx 
subtree shift 	dumping heap 
shifted comment commit 	profile includes 
desc pair 	gctx nlimbo 
pair branch branch 	must single 
dst entry 	destroyer order 
dst entry ren 	safely 
ren mode 	destroy gctx 
sha rename conflict 	profile counters 
info setup 	one allocated 
rename conflict info 	context linkage 
fmt commit 	contexts dumped 
title msg len 	temporary 
mode sha 	storage summation 
path stage refresh 	dump associated 
options desc 	backtrace backtrace 
index common 	vector variable 
head merge opts 	size referred 
result sha 	monotonically 
path mode stage 	increasing unique 
context baselen 	monotonically increasing 
match path entries 	discriminator among 
item unmerged 	tdata structures 
item one two 	associated thr 
onelen twolen 	uid 
cmp entries sorted 	included heap 
entries last 	profile dumps 
file last len 	non counter 
next path 	used initialize 
len pair src 	prof tctx 
entry dst 	tctx 
entry entries renames 	uid locking 
opts item 	necessary incrementing 
pair path clear 	field one 
options entry 	ever hash 
clean path 	prof prof 
update cache update 	tctx 
working directory 	tracks backtraces 
path branch newpath 	non zero 
suffix len 	allocation deallocation 
path check working 	counters associated 
copy pos 	specific prof 
dirpath path pos 	tctx 
path path 	objects threads 
status msg path 	may write 
pathlen pathlen 	prof tctx 
sha mode path 	contents freeing 
update cache 	associated objects 
update buf size 	sampling 
strbuf lnk 	state state 
clean sha mode 	used avoid 
path sha 	dumping operating 
mode result buf 	prof internals 
one branch 	early dump 
branch orig 	phase 
src src opts 	tdata currently 
name name 	dumped threads 
name merge status 	tdata initialized 
one branch 	aren accidentally 
branch result result 	included later 
buf merge 	dump 
status one branch 	phases profiling 
filename branch 	active tdata 
filename side side 	prof active 
mfi path 	mallctl temporary 
sha mode sha 	storage summation 
mode sha 	dump 
mode branch branch 	backtrace vector 
one path 	used calls 
sha mode sha 	prof backtrace 
mode sha 	jemalloc structs 
mode change 	mean bytes 
change past renamed 	samples 
pair rename 	prof interval 
branch branch orig 	high water 
dest sha 	memory dumping 
sha mode mode 	profile dumping 
target entry 	dump leak 
stage sha mode 	summary 
rename stage 	exit report 
dst name dst 	cumulative bytes 
entry cur 	minimize memory 
branch branch name 	bloat non 
one mfi 	prof builds 
path mfi mfi 	accessed 
path path 	via prof 
renames renames dst 	active unlocked 
dst sre 	accessed via 
renames renames dst 	prof gdump 
ren branch 	unlocked profile 
branch ren 	dump 
src ren dst 	interval measured 
lookup compare 	bytes allocated 
tmp ren src 	arena triggers 
ren dst 	profile dump 
ren dst src 	reaches threshold 
dst merge 	effect 
renamed stage stage 	interval profile 
mfi path 	dumps averages 
one sha mode 	prof interval 
sha dst 	though actual 
buf size sha 	interval dumps 
mode sha 	tend 
mode renormalize path 	sporadic interval 
ret path 	maximum approximately 
sha mode sha 	prof interval 
mode sha 	narenas initialized 
mode path sha 	opt prof 
mode sha 	sample 
mode sha 	potentially modified 
mode rename conflict 	profiling resets 
info reason 	jemalloc externs 
path mfi one 	even opt 
conflict remains 	prof sampling 
pair path renamed 	temporarily 
outside head 	disabled setting 
path file stage 	prof active 
merged path 	locking used 
entry clean merge 	reading prof 
normalize mode 	active fast 
mode mode sha 	path 
sha sha 	guarantees regarding 
conflict info branch 	take threads 
branch mode 	notice state 
sha conf path 	changes locking 
head merge 	used reading 
common result code 	prof 
clean entries 	gdump val 
head merge 	fast path 
path list current 	guarantees regarding 
backup result 	take threads 
iter merged common 	notice state 
ancestors mrtree 	changes 
clean cnt saved 	compute sample 
saved sha 	threshold sample 
name head merge 	usize passed 
num list 	prof alloc 
list result clean 	prep larger 
head commit 	actually 
next commit arg 	got allocated 
shift shift 	backtrace captured 
oidcmp lookup alloc 	allocation even 
commit node 	though actual 
xmalloc hashcmp fputs 	usize insufficient 
strbuf reset 	cross 
show strbuf addchars 	sample threshold 
start strbuf 	jemalloc inlines 
vaddf end 	prof accumc 
strbuf addch flush 	malloc conf 
output flush 	propagate err 
output fputs merge 	filename 
remote find 	thd ind 
unique abbrev parse 	iteration varg 
commit commit 	thd ind 
buffer find commit 	count prev 
subject unuse 	count prev 
commit buffer make 	active 
cache entry 	thds thd 
error cache entry 	args open 
parse init 	btalloc alloc 
desc memset setup 	permuted backtrace 
unpack trees 	dallocx mallctl 
porcelain init desc 	prof 
init desc 	count test 
init desc 	skip mallctl 
unpack trees cache 	thd create 
free unmerged 	thd test 
cache stage stage 	prof activec 
namelen die 	malloc 
cache cache fully 	conf name 
valid cache 	expected func 
update die lookup 	line old 
strbuf addstr 	name old 
isdir list insert 	expected val 
list insert 	func 
strbuf setlen isdir 	line old 
memset read 	prof active 
recursive xcalloc entry 	old expected 
entry entry 	func line 
list insert xcalloc 	prof active 
stage list 	old 
lookup list insert 	expected prof 
xcalloc stage 	active func 
hashcpy stage 	line prof 
strlen strlen name 	active old 
compare memset 	expected func 
list append qsort 	line 
list clear 	prof active 
strlen memcmp list 	old expected 
insert isreg 	prof active 
islnk list clear 	func line 
xcalloc diff 	expect sample 
setup diff opt 	func 
diff opt 	line expected 
clr diff setup 	backtraces mallctl 
done diff 	mallctl mallctl 
sha diffcore std 	mallctl mallctl 
diff free 	mallctl prof 
filepair xmalloc list 	count 
lookup insert 	mallocx ptr 
stage data list 	prof count 
lookup insert 	dallocx test 
stage data 	skip mallctl 
list insert diff 	prof active 
flush file 	mallctl 
cache cacheinfo cacheinfo 	prof active 
cacheinfo hashcpy 	mallctl prof 
hashcpy hashcpy file 	active mallctl 
cache cache 	prof active 
file exists strlen 	prof sampling 
stage path 	probe 
strbuf addstr strbuf 	mallctl prof 
addf flattened 	active mallctl 
path list list 	prof active 
file exists 	prof sampling 
strbuf setlen strbuf 	probe mallctl 
addf list 	prof 
insert strbuf detach 	active mallctl 
strbuf addstr 	prof active 
strbuf addch cache 	prof sampling 
name pos 	probe mallctl 
strncmp strbuf 	prof active 
release strbuf release 	mallctl 
lstat isdir 	prof active 
cache name pos 	prof sampling 
strlen strcmp 	probe mallctl 
stage tracked file 	prof active 
exists strlen 	mallctl prof 
strlen strncmp output 	active 
unlink unsorted 	test prof 
list item safe 	active prof 
create leading 	active prof 
directories error die 	active prof 
would lose 	active prof 
untracked error unlink 	active 
error isgitlink 	prof active 
read sha file 	prof active 
die sha 	prof active 
hex die 	restore settings 
sha hex isreg 	prof gdumpc 
convert working 	malloc 
free strbuf detach 	conf prof 
make room 	dump open 
path free isreg 	propagate err 
islnk open 	filename active 
die errno write 	gdump 
full close 	gdump old 
islnk xmemdupz safe 	open test 
create leading 	skip mallctl 
directories unlink symlink 	mallocx ptr 
die errno 	mallocx ptr 
free die sha 	mallctl 
hex free 	mallocx ptr 
cacheinfo update file 	mallctl mallocx 
flags strcmp 	ptr dallocx 
strcmp mkpathdup mkpathdup 	dallocx dallocx 
mkpathdup mkpathdup 	dallocx test 
mkpathdup mkpathdup 	prof 
read mmblob read 	idumpc malloc 
mmblob read 	conf prof 
mmblob merge free 	dump open 
free free 	propagate err 
free free free 	filename active 
isreg hashcpy 	open 
hashcpy sha sha 	test skip 
sha sha 	mallctl mallocx 
hashcpy sha hashcpy 	ptr dallocx 
isreg merge 	test prof 
way die write 	resetc malloc 
sha file 	conf 
die free isgitlink 	propagate err 
merge submodule 	filename active 
islnk hashcpy sha 	prof sample 
die xstrfmt 	prof sample 
xstrfmt merge file 	prof sample 
free free 	orig 
hashcpy hashcpy 	prof sample 
hashcpy merge file 	prof sample 
dir way 	next prof 
unique path file 	dump header 
cache update 	intercepted cnt 
file output update 	copy 
file output 	propagate err 
update file output 	cnt prof 
output update 	dump header 
file free handle 	orig varg 
change file 	thd ind 
cache update stages 	objs 
sha hashcpy 	prof sample 
filespec entry unique 	orig thds 
path update 	thd args 
file file unique 	count tdata 
path dir 	count prof 
way unique path 	sample 
output update 	orig ptrs 
file update 	nsz open 
stages update stages 	mallctl mallctl 
free output 	mallctl prof 
merge file one 	sample test 
update file 	skip 
filespec entry update 	mallctl prof 
file file 	sample mallctl 
cache filespec entry 	prof sample 
update file 	prof reset 
file cache handle 	prof sample 
file handle 	prof 
file output file 	sample memcpy 
would lose 	test skip 
untracked file would 	prof active 
lose untracked 	prof count 
merge file special 	mallocx ptr 
markers merge 	prof 
file special 	count mallctl 
markers file update 	mallctl mallctl 
file update 	prof count 
file unique path 	dallocx prof 
unique path 	count prof 
output file update 	active 
file update 	memset mallctl 
file free free 	mallctl dallocx 
list insert 	btalloc ptr 
list insert strcmp 	dallocx test 
strcmp die 	skip prof 
strcmp file update 	count 
entry setup 	prof tdata 
rename conflict info 	count prof 
list lookup 	sample prof 
strcmp die setup 	reset prof 
rename conflict 	active thd 
info file tracked 	create 
hashcpy hashcpy 	thd prof 
sha setup 	count prof 
rename conflict info 	tdata count 
sha update 	prof active 
file flags sha 	prof reset 
output merge 	test 
file one output 	skip prof 
update file 	sample prof 
unique path output 	active prof 
update file 	reset prof 
free update entry 	reset mallocx 
setup rename 	ptr 
conflict info list 	prof reset 
clear list 	sallocx xallocx 
clear sha read 	nallocx xallocx 
sha file 	dallocx prof 
error sha hex 	active prof 
free error 	reset 
sha hex strbuf 	test test 
attach sha 	simple resets 
read sha 	test resets 
strbuf read sha 	prof sample 
strbuf renormalize 	changes make 
buffer renormalize buffer 	sure 
memcmp strbuf 	test code 
release strbuf release 	restored prof 
handle change 	sample clean 
hashcpy hashcpy hashcpy 	remaining objects 
dir way 	test sampling 
merge file special 	allocation 
markers sha 	site across 
output strcmp cacheinfo 	resets reset 
output isgitlink 	profiling reset 
output update stages 	profiling allocate 
file cache 	small promoted 
update stages tracked 	reset 
hashcpy update 	profiling perform 
stages unique path 	successful xallocx 
output update 	perform unsuccessful 
file free 	xallocx dallocx 
update file stage 	intercept dumping 
sha stage 	prior 
sha stage sha 	running tests 
merge content 	prof namec 
conflict rename conflict 	malloc conf 
rename rename 	name expected 
conflict rename rename 	func line 
blob unchanged 	name 
blob unchanged output 	old name 
file handle 	func line 
modify dir way 	name name 
unique path 	old varg 
output file cache 	thd ind 
update file 	name 
file cache free 	thds thd 
output update 	args mallctl 
file flags merge 	str mallctl 
content file 	mallctl name 
die shift 	impl test 
shift sha output 	skip 
git merge 	mallctl name 
trees show die 	mallctl name 
oid hex 	mallctl mallctl 
oid hex exit 	mallctl mallctl 
unmerged cache 	name malloc 
list clear list 	snprintf 
clear files 	mallctl name 
dirs files dirs 	mallctl name 
unmerged record 	mallctl mallctl 
conflict files renames 	name mallctl 
renames process 	name mallctl 
renames process entry 	name 
die list 	test skip 
clear list clear 	thd create 
list clear 	thd test 
free free 	input shouldn 
free write memory 	allowed shouldn 
show output 	allowed 
output commit title 	simultaneous read 
output commit 	write shouldn 
title merge bases 	allowed pubsub.c 
reverse commit 	pat channel 
list show commit 	clients retval 
list count 	channel 
output output commit 	notify clients 
title pop 	retval pattern 
commit lookup make 	retval pat 
commit discard 	pattern notify 
cache merge recursive 	pat retval 
die discard 	notify 
cache read cache 	count channel 
merge trees 	notify count 
make commit commit 	pattern channel 
list insert 	message receivers 
commit list 	list pat 
insert flush output 	receivers 
show diff 	pat mblen 
warn rename limit 	replylen cobj 
deref tag 	channel decr 
parse strlen make 	count zfree 
commit parse 	equal objects 
commit xcalloc sha 	dict 
hex error 	size list 
sha hex commit 	length dict 
list insert 	incr count 
hold locked index 	dict find 
merge recursive 	list create 
write locked index 	dict 
error git 	incr count 
config git config 	dict val 
git config 	list node 
git config memset 	tail reply 
merge recursive 	reply reply 
config getenv 	bulk 
strtol getenv strbuf 	reply client 
init list 	subscriptions count 
init list init 	incr count 
list init 	dict dict 
strcmp strcmp strcmp 	find server 
skip prefix 	info 
strcmp diff alg 	dict val 
strcmp diff 	list search 
alg skip prefix 	key server 
parse algorithm 	info list 
diff xdl clr 	del node 
strcmp strcmp 	list 
strcmp strcmp strcmp 	length dict 
strcmp strcmp 	reply reply 
skip prefix skip 	reply bulk 
prefix parse 	reply dict 
rename score recursive 	size list 
merge algorithm 	length 
stolen git 	decr count 
merge recursive fredrik 	list search 
kuivinen thieves 	key list 
alex riesen johannes 	node tail 
schindelin june 	incr count 
july since use 	zmalloc 
entry put 	decoded list 
read pool cannot 	node tail 
rely since 	reply reply 
want write index 	reply bulk 
eventually cannot 	reply client 
reuse index temporary 	subscriptions 
data rename 	count incr 
could modifications side 	count list 
history file 	search key 
renamed returns index 	list del 
entry instance 	node list 
doesn correspond 	search 
real cache entry 	key list 
git index 	del node 
create dictionary mapping 	reply reply 
file names 	reply bulk 
stage data objects 	reply dict 
dictionary contains 	size 
one entry every 	list length 
path non 	decr count 
zero stage entry 	dict safe 
care entries 	iterator dict 
conflicts adjacent particular 	next dict 
file conflict 	key 
appearing files corresponding 	pubsub unsubscribe 
directory order 	channel reply 
rest list irrelevant 	reply reply 
achieve sort 	reply dict 
name compare provide 	size list 
mode ifdir 	length 
conflicts sort 	dict release 
correctly use mode 	iterator list 
ifdir everything 	rewind list 
simplicity since cases 	next pubsub 
changes order 	unsubscribe pattern 
due sorting cause 	reply 
problems foo 	reply reply 
foo bar compare 	reply dict 
equal make 	size list 
sure foo comes 	length dict 
foo bar 	find dict 
conflict file conflict 	val 
currently exist 	list rewind 
working want allow 	list next 
removed make 	reply reply 
room corresponding directory 	reply bulk 
needed files 	reply bulk 
underneath directories conflicts 	list 
processed corresponding 	length list 
file involved 	rewind decoded 
conflict directory ends 	list next 
removed merge 	stringmatchlen sdslen 
won touch file 	sdslen reply 
directory needs 	reply 
written working copy 	reply bulk 
file simply 	reply bulk 
removed make room 	reply bulk 
path make 	decr count 
room necessary paths 	pubsub subscribe 
note directory 	channel 
file need present 	pubsub unsubscribe 
file reinstated 	channels pubsub 
unique name time 	unsubscribe channel 
processed merging 	client subscriptions 
merge bases want 	count pubsub 
bother working 	subscribe 
directory changes ensure 	pattern pubsub 
conflicts adjacent 	unsubscribe patterns 
entries list 	pubsub unsubscribe 
check last file 	pattern client 
path correspond 	subscriptions count 
conflict whether path 	pubsub 
last file 	publish message 
something record okay 	cluster propagate 
last file 	publish force 
make room path 	command propagation 
friends needed 	reply strcasecmp 
determine whether path 	dict 
could exist 	iterator deferred 
file working directory 	multi bulk 
possible conflict 	length dict 
occur exists stage 	next dict 
file information 	key stringmatchlen 
renames occurred need 	sdslen 
three trees 	sdslen reply 
merge able 	bulk dict 
associate correct cache 	release iterator 
entries rename 	deferred multi 
information always equal 	bulk length 
either note 	strcasecmp 
usually bad idea 	reply multi 
call update 	bulk len 
stages path calling 	dict fetch 
update file 	reply bulk 
path since sometimes 	reply list 
lead spurious 	length 
refusing lose untracked 	strcasecmp reply 
file messages 	list length 
update file via 	reply error 
make room 	format copyright 
path via would 	salvatore sanfilippo 
lose untracked 	antirez 
instead reverse order 	gmail dot 
calls executing 	rights reserved 
update file 	redistribution use 
first update stages 	source binary 
strbuf converting 	forms without 
stage definitely tracked 	modification 
stage tracked 	permitted provided 
merge started cases 	following conditions 
path tracked 	met redistributions 
unlink conflict files 	source code 
way make 	must retain 
sure leading directories 	copyright 
created something 	notice list 
exists unlink file 	conditions following 
work tracking 	disclaimer redistributions 
successful unlink good 	binary form 
existing file 	must reproduce 
error really cares 	copyright 
may later 	notice list 
decide recursively descend 	conditions following 
submodule directory 	disclaimer documentation 
update index 	materials provided 
work low level 	distribution neither 
file merging 	name 
update removal merge 	redis names 
modes cannot 	contributors may 
arbitrarily accept either 	used endorse 
sha sha 	promote products 
correct since middle 	derived software 
point simply 	without 
reuse version merge 	specific prior 
need call 	written permission 
update file path 	software provided 
renamed since 	copyright holders 
would needlessly touch 	contributors express 
path could 	implied 
call update file 	warranties including 
flags update 	limited implied 
cache update one 	warranties merchantability 
file renamed 	fitness particular 
branches different 	purpose disclaimed 
names fixme rename 	shall 
source conflicts 	copyright owner 
could detect wrong 	contributors liable 
instead find 	direct indirect 
unique pathname either 	incidental special 
rename source 	exemplary consequential 
file unique path 	damages 
use unique 	including limited 
path instead src 	procurement substitute 
put merged 	goods services 
content merge path 	loss use 
usually need 	data profits 
path path however 	business 
rename side 	interruption however 
merge could also 	caused theory 
involved rename 	liability whether 
conflict cases keep 	contract strict 
added file 	liability tort 
around resolving 	including 
conflict path favor 	negligence otherwise 
two files 	arising way 
renamed thing path 	use software 
mfi clean 	even advised 
mfi clean might 	possibility damage 
make sense 	pubsub 
two way merge 	low level 
results think 	api number 
cases makes sense 	channels patterns 
merge undo 	client subscribed 
renames detected later 	subscribe client 
non recursive 	channel 
merge todo refactor 	returns operation 
needed bug 	succeeded client 
mark src entry 	already subscribed 
processed dealing 	channel channel 
rename source 	client channels 
one file renamed 	hash 
sides bug 	table client 
ren src stage 	channel list 
think rename 	clients hash 
source cases two 	table notify 
different files 	client unsubscribe 
renamed thing bug 	client 
mark src 	channel returns 
entry processed dealing 	operation succeeded 
rename source 	client subscribed 
renamed maybe changed 	specified channel 
use sha 	channel client 
mode unpack trees 	channels 
loads entries 	hash table 
common commit stage 	channel may 
head commit 	pointer hash 
stage merge commit 	tables protect 
stage keep 	client channel 
track side 	clients 
corresponds rename bug 	list hash 
ren src 	table free 
stage stage think 	list associated 
rename source 	hash entry 
added file side 	latest client 
identical file 	possible 
renamed clean merge 	abuse redis 
also need 	pubsub creating 
overwrite file already 	millions channels 
working copy 	notify client 
call update file 	safe release 
flags instead 	subscribe 
update file update 	client pattern 
cache update 	returns operation 
changed safety note 	succeeded client 
binary used 	already subscribed 
renormalizations performed comparison 	pattern 
skipped files 	notify client 
unchanged since 	unsubscribe client 
sha already compared 	channel returns 
rename conflict 	operation succeeded 
info pair rename 	client subscribed 
one file 	specified 
one otherwise normal 	channel protect 
rename content 	may notify 
merge resulted file 	client unsubscribe 
contents already 	channels number 
early file contents 	channels client 
recorded correct 	subscribed 
path may merge 	subscribed nothing 
involves rename 	still reply 
per entry merge 	client unsubscribe 
function deleted 	patterns number 
one deleted deleted 	patterns client 
one unchanged 	subscribed 
touch working file 	subscribed nothing 
exist modify 	still reply 
deleted side 	client publish 
may put directory 	message send 
way added 	clients listening 
one nothing directory 	channel 
nothing directory 	send clients 
file overwrite file 	listening matching 
already present 	channels pubsub 
added check permissions 	commands implementation 
modified differently 	pubsub command 
entry deleted altogether 	pub 
mode means 	sub introspection 
path want actively 	pubsub channels 
merge commits 	pattern pubsub 
resulting commit flag 	numsub channel 
indicating cleanness 	channel pubsub 
merge common ancestor 	numpat 
use empty 	ql.c head 
merge fails 	head entries 
result contains files 	nentries head 
conflict markers 	entries nentries 
cleanness flag ignored 	head entries 
never actually 	head 
used result merge 	entries head 
trees always 	entries head 
overwritten committed conflicts 	entries head 
already resolved 	entries ptr 
clear previous settings 	first ptr 
head remote 	last 
die error code 	test empty 
builtin merge 	list elm 
recursive usage branch 	first last 
githead env 	next ptr 
name argc argv 	next ptr 
prefix bases 	prev 
bases count failed 	prev init 
result arg 	entries tail 
sha strlen 	insert test 
xsnprintf getenv init 	entries list 
merge options 	init entries 
ends usagef starts 	tail 
parse merge 	insert test 
opt die size 	entries list 
xmalloc sha 	tail test 
die warning size 	empty list 
die sha 	init entries 
die sha die 	head 
better branch 	insert test 
name better branch 	entries list 
name merge 	init entries 
recursive recursive merge 	head insert 
algorithm stolen 	test entries 
git merge recursive 	list 
fredrik kuivinen 	head test 
thieves alex riesen 	empty list 
johannes schindelin 	init entries 
june july 	tail insert 
since use entry 	insert insert 
put read 	insert 
pool cannot rely 	insert insert 
since want 	insert insert 
write index eventually 	test entries 
cannot reuse 	list test 
index temporary data 	number ring 
rename could 	entries 
modifications side history 	insert insert 
file renamed 	used internally 
returns index entry 	macros already 
instance doesn 	tested need 
correspond real cache 	test completely 
entry git 	however 
index create dictionary 	insertion deletion 
mapping file 	middle lists 
names stage data 	otherwise tested 
objects dictionary 	ql.h list 
contains one 	definitions list 
entry every path 	functions 
non zero 	qr.c entries 
stage entry care 	entries entries 
entries conflicts 	entries entries 
adjacent particular file 	entries entries 
conflict appearing 	entries entries 
files corresponding directory 	next 
order rest 	ptr prev 
list irrelevant achieve 	ptr init 
sort name 	entries test 
compare provide mode 	independent entries 
ifdir conflicts 	next prev 
sort correctly use 	init 
mode ifdir 	entries insert 
everything simplicity since 	test entries 
cases changes 	ring init 
order due 	entries insert 
sorting cause problems 	test independent 
foo foo 	entries 
bar compare equal 	init entries 
make sure 	insert next 
foo comes foo 	prev init 
bar conflict 	entries insert 
file conflict currently 	split test 
exist working 	split 
want allow removed 	entries meld 
make room 	test entries 
corresponding directory needed 	ring meld 
files underneath 	test split 
directories conflicts processed 	entries split 
corresponding file 	test 
involved conflict directory 	entries ring 
ends removed 	split test 
merge won touch 	entries ring 
file directory 	meld test 
needs written 	entries ring 
working copy file 	test 
simply removed 	number ring 
make room path 	entries split 
make room 	index nentries 
necessary paths note 	qr.h ring 
directory file 	definitions ring 
need present file 	functions 
reinstated unique 	meld split 
name time processed 	functionally equivalent 
merging merge 	need two 
bases want bother 	copies code 
working directory 	quarantine.c tsd 
changes ensure conflicts 	quarantine 
adjacent entries 	tsd quarantine 
list check last 	tsd quarantine 
file path 	upper bound 
correspond conflict whether 	tsd maxobjs 
path last 	quarantine tsd 
file something 	quarantine 
record okay last 	tsd quarantine 
file make 	ret ncopy 
room path friends 	ncopy tsd 
needed determine 	quarantine obj 
whether path could 	tsd quarantine 
exist file 	upper 
working directory possible 	bound tsd 
conflict occur 	ptr quarantine 
exists stage file 	usize upper 
information renames 	bound offset 
occurred need three 	obj tsd 
trees merge 	quarantine 
able associate correct 	tsd nominal 
cache entries 	iallocztm offsetof 
rename information always 	tcache tsd 
equal either 	nominal quarantine 
note usually bad 	init tsd 
idea call 	quarantine 
update stages 	tsd quarantine 
path calling update 	idalloctm tcache 
file path 	quarantine init 
since sometimes lead 	quarantine drain 
spurious refusing 	one memcpy 
lose untracked file 	memcpy 
messages update 	memcpy idalloctm 
file via make 	tcache tsd 
room path 	quarantine isalloc 
via would lose 	idalloctm quarantine 
untracked instead 	drain one 
reverse order calls 	isalloc 
executing update 	cassert tsd 
file first update 	quarantine idalloctm 
stages strbuf 	quarantine drain 
converting stage definitely 	quarantine grow 
tracked stage 	unlikely likely 
tracked merge started 	arena 
cases path 	quarantine junk 
tracked unlink 	small memset 
conflict files way 	idalloctm tsd 
make sure 	quarantine quarantine 
leading directories created 	drain idalloctm 
something exists 	tcache 
unlink file work 	tsd quarantine 
tracking successful 	quarantine pointers 
unlink good existing 	close used 
file error 	encode state 
really cares may 	information used 
later decide 	cleaning 
recursively descend submodule 	shutdown function 
directory update 	prototypes non 
index work low 	functions check 
level file 	whether quarantine 
merging update removal 	initialized quarantine 
merge modes 	init 
cannot arbitrarily 	may triggered 
accept either sha 	recursive initialization 
sha correct 	objs ring 
since middle point 	buffer data 
simply reuse 	contiguous objs 
version merge need 	ring 
call update 	buffer data 
file path renamed 	wrap around 
since would 	drain one 
needlessly touch path 	objects quarantine 
could call 	size limit 
update file flags 	would 
update cache 	exceeded appending 
update one file 	ptr grow 
renamed branches 	quarantine ring 
different names fixme 	buffer full 
rename source 	quarantine grow 
conflicts could detect 	must 
wrong instead 	free slot 
find unique 	fails grow 
pathname either rename 	append ptr 
source file 	size doesn 
unique path use 	exceed quarantine 
unique path 	size 
instead src put 	redzone validation 
merged content 	valgrind isn 
merge path usually 	operation allocate 
need path 	enough regions 
path however rename 	completely fill 
side merge 	quarantine 
could also involved 	plus one 
rename conflict 	last iteration 
cases keep added 	occurs completely 
file around 	full quarantine 
resolving conflict path 	regions drained 
favor two 	quarantine 
files renamed thing 	last deallocation 
path mfi 	occurs therefore 
clean mfi 	region recycling 
clean might make 	occur loop 
sense two 	completes test 
way merge results 	underflow 
think cases 	test overflow 
makes sense merge 	malloc conf 
undo renames 	quarantined detected 
detected later non 	redzone corruption 
recursive merge 	ptr usize 
todo refactor needed 	offset 
bug mark 	arena redzone 
src entry processed 	corruption orig 
dealing rename 	stringify mallocx 
source one file 	ptr dallocx 
renamed sides 	test skip 
bug ren src 	nallocx 
stage think 	quarantine clear 
rename source cases 	mallocx ptr 
two different 	dallocx ptr 
files renamed 	test skip 
thing bug mark 	mallocx ptr 
src entry 	dallocx 
processed dealing rename 	mallocx ptr 
source renamed 	sallocx dallocx 
maybe changed use 	test quarantine 
sha mode 	pointers close 
unpack trees loads 	used encode 
entries common 	state 
commit stage head 	information used 
commit stage 	cleaning shutdown 
merge commit stage 	function prototypes 
keep track 	non functions 
side corresponds rename 	check whether 
bug ren 	quarantine 
src stage stage 	initialized quarantine 
think rename 	init may 
source added 	triggered recursive 
file side identical 	initialization objs 
file renamed 	ring buffer 
clean merge also 	data 
need overwrite 	contiguous objs 
file already working 	ring buffer 
copy call 	data wrap 
update file flags 	around drain 
instead update 	one objects 
file update cache 	quarantine 
update changed 	size limit 
safety note binary 	would exceeded 
used renormalizations 	appending ptr 
performed comparison skipped 	grow quarantine 
files unchanged 	ring buffer 
since sha already 	full 
compared rename 	quarantine grow 
conflict info pair 	must free 
rename one 	slot fails 
file one 	grow append 
otherwise normal rename 	ptr size 
content merge 	doesn 
resulted file contents 	exceed quarantine 
already early 	size redzone 
file contents recorded 	validation valgrind 
correct path 	isn operation 
may merge involves 	allocate enough 
rename per 	regions 
entry merge function 	completely fill 
deleted one 	quarantine plus 
deleted deleted one 	one last 
unchanged touch 	iteration occurs 
working file exist 	completely full 
modify deleted 	quarantine 
side may put 	regions drained 
directory way 	quarantine last 
added one nothing 	deallocation occurs 
directory nothing 	therefore region 
directory file 	recycling occur 
overwrite file already 	loop 
present added 	completes test 
check permissions modified 	underflow test 
differently entry 	overflow quarantine.c 
deleted altogether mode 	tsd quarantine 
means path 	tsd quarantine 
want actively merge 	tsd 
commits resulting 	quarantine upper 
commit flag indicating 	bound tsd 
cleanness merge 	maxobjs quarantine 
common ancestor use 	tsd quarantine 
empty merge 	tsd quarantine 
fails result contains 	ret 
files conflict 	ncopy ncopy 
markers cleanness flag 	tsd quarantine 
ignored never 	obj tsd 
actually used result 	quarantine upper 
merge trees 	bound tsd 
always overwritten 	ptr 
committed conflicts already 	quarantine usize 
resolved clear 	upper bound 
previous settings head 	offset obj 
remote die 	tsd quarantine 
error code merge-recursive.c 	tsd nominal 
one two 	iallocztm 
subtree shift shifted 	offsetof tcache 
comment commit 	tsd nominal 
desc pair pair 	quarantine init 
branch branch 	tsd quarantine 
dst entry dst 	tsd quarantine 
entry ren 	idalloctm 
ren mode sha 	tcache quarantine 
rename conflict 	init quarantine 
info setup rename 	drain one 
conflict info 	memcpy memcpy 
fmt commit 	memcpy idalloctm 
title msg len 	tcache 
mode sha 	tsd quarantine 
path stage refresh 	isalloc idalloctm 
options desc 	quarantine drain 
index common head 	one isalloc 
merge opts 	cassert tsd 
result sha path 	quarantine 
mode stage 	idalloctm quarantine 
context baselen match 	drain quarantine 
path entries 	grow unlikely 
item unmerged item 	likely arena 
one two 	quarantine junk 
onelen twolen cmp 	small 
entries sorted 	memset idalloctm 
entries last file 	tsd quarantine 
last len 	quarantine drain 
next path len 	idalloctm tcache 
pair src 	tsd quarantine 
entry dst 	quarantine 
entry entries renames 	pointers close 
opts item 	used encode 
pair path clear 	state information 
options entry 	used cleaning 
clean path update 	shutdown function 
cache update 	prototypes 
working directory path 	non functions 
branch newpath 	check whether 
suffix len path 	quarantine initialized 
check working 	quarantine init 
copy pos dirpath 	may triggered 
path pos 	recursive 
path path status 	initialization objs 
msg path 	ring buffer 
pathlen pathlen sha 	data contiguous 
mode path 	objs ring 
update cache update 	buffer data 
buf size 	wrap 
strbuf lnk 	around drain 
clean sha mode 	one objects 
path sha 	quarantine size 
mode result buf 	limit would 
one branch 	exceeded appending 
branch orig src 	ptr 
src opts 	grow quarantine 
name name name 	ring buffer 
merge status 	full quarantine 
one branch branch 	grow must 
result result 	free slot 
buf merge status 	fails 
one branch 	grow append 
filename branch filename 	ptr size 
side side 	doesn exceed 
mfi path sha 	quarantine size 
mode sha 	redzone validation 
mode sha mode 	valgrind 
branch branch 	isn operation 
one path 	allocate enough 
sha mode sha 	regions completely 
mode sha 	fill quarantine 
mode change change 	plus one 
past renamed 	last 
pair rename branch 	iteration occurs 
branch orig 	completely full 
dest sha sha 	quarantine regions 
mode mode 	drained quarantine 
target entry stage 	last deallocation 
sha mode 	occurs 
rename stage dst 	therefore region 
name dst 	recycling occur 
entry cur branch 	loop completes 
branch name 	test underflow 
one mfi path 	test overflow 
mfi mfi 	malloc 
path path renames 	conf quarantined 
renames dst 	detected redzone 
dst sre 	corruption ptr 
renames renames dst 	usize offset 
ren branch 	arena redzone 
branch ren src 	corruption 
ren dst 	orig stringify 
lookup compare tmp 	mallocx ptr 
ren src 	dallocx test 
ren dst ren 	skip nallocx 
dst src 	quarantine 
dst merge renamed 	clear mallocx 
stage stage 	ptr dallocx 
mfi path one 	ptr test 
sha mode 	skip mallocx 
sha dst buf 	ptr dallocx 
size sha 	mallocx 
mode sha mode 	ptr sallocx 
renormalize path 	dallocx test 
ret path 	quarantine pointers 
sha mode sha 	close used 
mode sha 	encode state 
mode path sha 	information 
mode sha 	used cleaning 
mode sha mode 	shutdown function 
rename conflict 	prototypes non 
info reason path 	functions check 
mfi one 	whether quarantine 
conflict remains pair 	initialized 
path renamed 	quarantine init 
outside head path 	may triggered 
file stage 	recursive initialization 
merged path entry 	objs ring 
clean merge 	buffer data 
normalize mode mode 	contiguous 
mode sha 	objs ring 
sha sha conflict 	buffer data 
info branch 	wrap around 
branch mode 	drain one 
sha conf path 	objects quarantine 
head merge 	size 
common result code 	limit would 
clean entries 	exceeded appending 
head merge path 	ptr grow 
list current 	quarantine ring 
backup result iter 	buffer full 
merged common 	quarantine 
ancestors mrtree clean 	grow must 
cnt saved 	free slot 
saved sha name 	fails grow 
head merge 	append ptr 
num list list 	size doesn 
result clean 	exceed 
head commit next 	quarantine size 
commit arg 	redzone validation 
shift shift oidcmp 	valgrind isn 
lookup alloc 	operation allocate 
commit node 	enough regions 
xmalloc hashcmp fputs 	completely 
strbuf reset 	fill quarantine 
show strbuf addchars 	plus one 
start strbuf 	last iteration 
vaddf end strbuf 	occurs completely 
addch flush 	full quarantine 
output flush output 	regions 
fputs merge 	drained quarantine 
remote find unique 	last deallocation 
abbrev parse 	occurs therefore 
commit commit buffer 	region recycling 
find commit 	occur loop 
subject unuse commit 	completes 
buffer make 	test underflow 
cache entry error 	test overflow 
cache entry 	quarantine.h ptr 
parse init desc 	usize curbytes 
memset setup 	curobjs first 
unpack trees 	maxobjs 
porcelain init desc 	objs tsd 
init desc 	tsd ptr 
init desc unpack 	tsd tsd 
trees cache 	tsd fetch 
free unmerged cache 	tsd quarantine 
stage stage 	quarantine 
namelen die cache 	alloc hook 
cache fully 	work per 
valid cache update 	quarantine size 
die lookup 	valgrind enabled 
strbuf addstr isdir 	jemalloc types 
list insert 	dynamically 
list insert strbuf 	sized ring 
setlen isdir 	buffer jemalloc 
memset read recursive 	structs jemalloc 
xcalloc entry 	externs jemalloc 
entry entry 	inlines quicklist.c 
list insert xcalloc 	optimization 
stage list 	level quicklist 
lookup list insert 	quicklist compress 
xcalloc stage 	quicklist fill 
hashcpy stage strlen 	quicklist fill 
strlen name 	depth fill 
compare memset list 	compress 
append qsort 	quicklist node 
list clear strlen 	quicklist len 
memcmp list 	current next 
insert isreg islnk 	node lzf 
list clear 	node decompressed 
xcalloc diff setup 	lzf 
diff opt 	node data 
diff opt clr 	lzf quicklist 
diff setup 	node forward 
done diff sha 	reverse depth 
diffcore std 	depth quicklist 
diff free 	old 
filepair xmalloc list 	node node 
lookup insert 	quicklist old 
stage data list 	node node 
lookup insert 	quicklist old 
stage data list 	node node 
insert diff 	fill 
flush file cache 	offset node 
cacheinfo cacheinfo 	fill ziplist 
cacheinfo hashcpy hashcpy 	overhead fill 
hashcpy file 	merge quicklist 
cache cache file 	orig head 
exists strlen 	node 
stage path strbuf 	quicklist orig 
addstr strbuf 	tail node 
addf flattened path 	quicklist node 
list list 	quicklist longval 
file exists strbuf 	longstr fill 
setlen strbuf 	compress 
addf list 	quicklist node 
insert strbuf detach 	quicklist node 
strbuf addstr 	gone iter 
strbuf addch cache 	entry prev 
name pos 	next deleted 
strncmp strbuf release 	node 
strbuf release 	quicklist index 
lstat isdir cache 	data entry 
name pos 	quicklist nokeep 
strlen strcmp stage 	quicklist center 
tracked file 	fill prev 
exists strlen strlen 	prev 
strncmp output 	prev next 
unlink unsorted list 	next next 
item safe 	target node 
create leading directories 	offset node 
error die 	orig start 
would lose untracked 	orig 
error unlink 	extent start 
error isgitlink 	extent quicklist 
read sha file 	entry full 
die sha 	prev fill 
hex die sha 	node node 
hex isreg 	next 
convert working free 	quicklist entry 
strbuf detach 	quicklist entry 
make room path 	quicklist start 
free isreg 	count extent 
islnk open die 	entry node 
errno write 	next 
full close islnk 	del entire 
xmemdupz safe 	node len 
create leading directories 	quicklist direction 
unlink symlink 	iter quicklist 
die errno free 	direction idx 
die sha 	entry 
hex free 	iter iter 
cacheinfo update file 	entry offset 
flags strcmp 	update orig 
strcmp mkpathdup mkpathdup 	copy current 
mkpathdup mkpathdup 	node lzf 
mkpathdup mkpathdup read 	lzf 
mmblob read 	quicklist idx 
mmblob read mmblob 	entry accum 
merge free 	index forward 
free free free 	quicklist longval 
free free 	longstr quicklist 
isreg hashcpy hashcpy 	data 
sha sha 	sval saver 
sha sha hashcpy 	vstr vlen 
sha hashcpy 	vlong pos 
isreg merge way 	node data 
die write 	vstr quicklist 
sha file die 	data 
free isgitlink 	slong vstr 
merge submodule 	vlen vlong 
islnk hashcpy sha 	ret quicklist 
die xstrfmt 	ust print 
xstrfmt merge file 	forward iter 
free free 	entry 
hashcpy hashcpy hashcpy 	prev print 
merge file 	print len 
dir way unique 	count head 
path file 	count tail 
cache update file 	count errors 
output update 	loopr 
file output update 	rloopr node 
file output 	low raw 
output update file 	high raw 
free handle 	prefix result 
change file cache 	argc argv 
update stages 	err 
sha hashcpy filespec 	optimize start 
entry unique 	options option 
path update 	count runtime 
file file unique 	start populate 
path dir 	data data 
way unique path 	data 
output update 	ret data 
file update stages 	ret iter 
update stages 	entry count 
free output merge 	iter entry 
file one 	entry entry 
update file filespec 	entry 
entry update 	entry iter 
file file cache 	entry entry 
filespec entry 	entry copy 
update file file 	copy copy 
cache handle 	entry entry 
file handle file 	entry 
output file 	entry entry 
would lose untracked 	num nums 
file would 	entry words 
lose untracked 	result result 
merge file special 	iter entry 
markers merge 	del 
file special markers 	res entry 
file update 	iter vals 
file update file 	num nums 
unique path 	entry iter 
unique path output 	num nums 
file update 	entry 
file update file 	num nums 
free free 	entry num 
list insert list 	nums entry 
insert strcmp 	num nums 
strcmp die strcmp 	nums num 
file update 	stop 
entry setup rename 	list sizes 
conflict info 	start list 
list lookup strcmp 	depth node 
die setup 	low raw 
rename conflict 	high raw 
info file tracked 	stop 
hashcpy hashcpy 	zmalloc quicklist 
sha setup rename 	fill quicklist 
conflict info 	compress depth 
sha update file 	quicklist create 
flags sha 	quicklist options 
output merge file 	zmalloc 
one output 	zfree zfree 
update file unique 	zfree zmalloc 
path output 	lzf compress 
update file free 	zfree zrealloc 
update entry 	zfree zmalloc 
setup rename conflict 	lzf 
info list 	decompress zfree 
clear list clear 	zfree quicklist 
sha read 	allows compression 
sha file 	quicklist decompress 
error sha hex 	node quicklist 
free error 	decompress 
sha hex strbuf 	node quicklist 
attach sha 	compress node 
read sha strbuf 	quicklist compress 
read sha 	node quicklist 
strbuf renormalize buffer 	compress node 
renormalize buffer 	quicklist 
memcmp strbuf release 	compress quicklist 
strbuf release 	insert node 
handle change hashcpy 	quicklist insert 
hashcpy hashcpy 	node unlikely 
dir way merge 	likely likely 
file special 	quicklist 
markers sha output 	node size 
strcmp cacheinfo 	meets optimization 
output isgitlink output 	requirement size 
update stages 	meets safety 
file cache 	limit likely 
update stages tracked 	quicklist 
hashcpy update 	node size 
stages unique path 	meets optimization 
output update 	requirement size 
file free update 	meets safety 
file stage 	limit likely 
sha stage sha 	quicklist 
stage sha 	node allow 
merge content conflict 	insert ziplist 
rename conflict 	push quicklist 
rename rename conflict 	node update 
rename rename 	quicklist create 
blob unchanged blob 	node 
unchanged output 	ziplist push 
file handle modify 	ziplist quicklist 
dir way 	node update 
unique path output 	quicklist insert 
file cache 	node likely 
update file 	quicklist 
file cache free 	node allow 
output update 	insert ziplist 
file flags merge 	push quicklist 
content file 	node update 
die shift shift 	quicklist create 
sha output 	node 
git merge trees 	ziplist push 
show die 	ziplist quicklist 
oid hex oid 	node update 
hex exit 	quicklist insert 
unmerged cache list 	node quicklist 
clear list 	create 
clear files dirs 	node ziplist 
files dirs 	len ziplist 
unmerged record conflict 	blob len 
files renames 	quicklist insert 
renames process renames 	node ziplist 
process entry 	index 
die list 	ziplist quicklist 
clear list clear 	push tail 
list clear 	ziplist next 
free free free 	zfree quicklist 
write memory 	append values 
show output output 	ziplist 
commit title 	quicklist quicklist 
output commit title 	compress zfree 
merge bases 	zfree ziplist 
reverse commit list 	quicklist del 
show commit 	node quicklist 
list count output 	node 
output commit 	update quicklist 
title pop commit 	del index 
lookup make 	likely quicklist 
commit discard cache 	index ziplist 
merge recursive 	ziplist insert 
die discard 	quicklist 
cache read cache 	compress quicklist 
merge trees 	decompress node 
make commit commit 	quicklist decompress 
list insert 	node ziplist 
commit list insert 	merge ziplist 
flush output 	len 
show diff warn 	quicklist node 
rename limit 	update quicklist 
deref tag parse 	del node 
strlen make 	quicklist compress 
commit parse commit 	quicklist node 
xcalloc sha 	allow 
hex error sha 	merge quicklist 
hex commit 	ziplist merge 
list insert hold 	quicklist node 
locked index 	allow merge 
merge recursive write 	quicklist ziplist 
locked index 	merge 
error git 	quicklist node 
config git config 	allow merge 
git config 	quicklist ziplist 
git config memset 	merge quicklist 
merge recursive 	node allow 
config getenv strtol 	merge 
getenv strbuf 	quicklist ziplist 
init list init 	merge quicklist 
list init 	create node 
list init strcmp 	zmalloc memcpy 
strcmp strcmp 	ziplist range 
skip prefix strcmp 	ziplist 
diff alg 	len quicklist 
strcmp diff alg 	node update 
skip prefix 	ziplist range 
parse algorithm diff 	ziplist len 
xdl clr 	quicklist node 
strcmp strcmp strcmp 	update 
strcmp strcmp 	quicklist create 
strcmp strcmp 	node ziplist 
skip prefix skip 	push ziplist 
prefix parse 	quicklist insert 
rename score recursive 	node quicklist 
merge algorithm 	node 
stolen git merge 	allow insert 
recursive fredrik 	quicklist node 
kuivinen thieves alex 	allow insert 
riesen johannes 	quicklist node 
schindelin june july 	allow insert 
since use 	quicklist 
entry put read 	decompress node 
pool cannot 	use ziplist 
rely since want 	next ziplist 
write index 	push ziplist 
eventually cannot reuse 	insert quicklist 
index temporary 	node 
data rename could 	update quicklist 
modifications side 	recompress quicklist 
history file 	decompress node 
renamed returns index 	use ziplist 
entry instance 	insert quicklist 
doesn correspond real 	node 
cache entry 	update quicklist 
git index create 	recompress quicklist 
dictionary mapping 	decompress node 
file names stage 	use ziplist 
data objects 	push quicklist 
dictionary contains one 	node 
entry every 	update quicklist 
path non zero 	recompress quicklist 
stage entry 	decompress node 
care entries conflicts 	use ziplist 
adjacent particular 	push quicklist 
file conflict appearing 	node 
files corresponding 	update quicklist 
directory order 	recompress quicklist 
rest list irrelevant 	create node 
achieve sort 	ziplist push 
name compare provide 	ziplist quicklist 
mode ifdir 	node 
conflicts sort correctly 	update quicklist 
use mode 	insert node 
ifdir everything simplicity 	quicklist decompress 
since cases 	node use 
changes order due 	quicklist split 
sorting cause 	node 
problems foo foo 	ziplist push 
bar compare 	quicklist node 
equal make sure 	update quicklist 
foo comes 	insert node 
foo bar conflict 	quicklist merge 
file conflict 	nodes 
currently exist working 	quicklist insert 
want allow 	quicklist insert 
removed make 	quicklist index 
room corresponding directory 	quicklist del 
needed files 	node quicklist 
underneath directories conflicts 	decompress 
processed corresponding 	node use 
file involved conflict 	ziplist range 
directory ends 	quicklist node 
removed merge won 	update quicklist 
touch file 	empty quicklist 
directory needs written 	recompress 
working copy 	ziplist compare 
file simply removed 	zmalloc quicklist 
make room 	index quicklist 
path make room 	iterator quicklist 
necessary paths 	compress 
note directory file 	zfree init 
need present 	entry quicklist 
file reinstated unique 	decompress node 
name time 	use ziplist 
processed merging 	index next 
merge bases want 	ziplist 
bother working 	quicklist compress 
directory changes ensure 	quicklist next 
conflicts adjacent 	quicklist quicklist 
entries list check 	create node 
last file 	zmalloc memcpy 
path correspond conflict 	zmalloc 
whether path 	memcpy quicklist 
last file something 	insert node 
record okay 	init entry 
last file make 	likely quicklist 
room path 	decompress node 
friends needed determine 	use 
whether path 	ziplist index 
could exist file 	ziplist ziplist 
working directory 	index ziplist 
possible conflict occur 	quicklist push 
exists stage 	head ziplist 
file information 	index 
renames occurred need 	quicklist del 
three trees 	index ziplist 
merge able associate 	index ziplist 
correct cache 	saver quicklist 
entries rename information 	del index 
always equal 	zmalloc 
either note usually 	memcpy quicklist 
bad idea 	pop custom 
call update stages 	quicklist push 
path calling 	head quicklist 
update file path 	push tail 
since sometimes 	ziplist 
lead spurious refusing 	len ziplist 
lose untracked 	len unused 
file messages update 	gettimeofday ustime 
file via 	quicklist iterator 
make room path 	quicklist next 
via would 	quicklist 
lose untracked 	release iterator 
instead reverse order 	itrprintr itrprintr 
calls executing 	info yell 
update file first 	yell itrprintr 
update stages 	yell itrprintr 
strbuf converting stage 	rev 
definitely tracked 	yell ziplist 
stage tracked merge 	len yell 
started cases 	ziplist len 
path tracked unlink 	ziplist len 
conflict files 	yell ziplist 
way make sure 	len 
leading directories 	quicklist allows 
created something exists 	compression yell 
unlink file 	yell snprintf 
work tracking successful 	unused unused 
unlink good 	mstime quicklist 
existing file 	verify 
error really cares 	quicklist release 
may later 	quicklist quicklist 
decide recursively descend 	push tail 
submodule directory 	verify quicklist 
update index work 	release quicklist 
low level 	quicklist 
file merging update 	push head 
removal merge 	verify quicklist 
modes cannot arbitrarily 	release quicklist 
accept either 	quicklist push 
sha sha correct 	tail genstr 
since middle 	verify 
point simply reuse 	quicklist release 
version merge 	quicklist quicklist 
need call update 	push head 
file path 	genstr verify 
renamed since would 	quicklist release 
needlessly touch 	quicklist 
path could 	quicklist push 
call update file 	tail genstr 
flags update 	verify quicklist 
cache update one 	release quicklist 
file renamed 	quicklist push 
branches different names 	head 
fixme rename 	genstr verify 
source conflicts could 	quicklist release 
detect wrong 	quicklist quicklist 
instead find unique 	rotate verify 
pathname either 	quicklist release 
rename source file 	quicklist 
unique path 	quicklist push 
use unique path 	head quicklist 
instead src 	rotate verify 
put merged content 	quicklist release 
merge path 	quicklist quicklist 
usually need path 	push 
path however 	head quicklist 
rename side 	push head 
merge could also 	quicklist push 
involved rename 	head quicklist 
conflict cases keep 	push head 
added file 	quicklist 
around resolving conflict 	push head 
path favor 	genstr info 
two files renamed 	info quicklist 
thing path 	rotate verify 
mfi clean mfi 	verify verify 
clean might 	quicklist 
make sense two 	release quicklist 
way merge 	quicklist pop 
results think cases 	verify quicklist 
makes sense 	release quicklist 
merge undo renames 	genstr quicklist 
detected later 	push 
non recursive merge 	head info 
todo refactor 	quicklist pop 
needed bug 	strcmp err 
mark src entry 	zfree verify 
processed dealing 	quicklist release 
rename source one 	quicklist 
file renamed 	quicklist push 
sides bug ren 	head info 
src stage 	quicklist pop 
think rename source 	verify quicklist 
cases two 	release quicklist 
different files renamed 	quicklist 
thing bug 	push head 
mark src entry 	genstr info 
processed dealing 	quicklist pop 
rename source renamed 	strcmp genstr 
maybe changed 	err genstr 
use sha mode 	zfree 
unpack trees 	verify quicklist 
loads entries 	release quicklist 
common commit stage 	quicklist push 
head commit 	head genstr 
stage merge commit 	quicklist pop 
stage keep 	strcmp 
track side corresponds 	genstr err 
rename bug 	genstr zfree 
ren src stage 	verify quicklist 
stage think 	release quicklist 
rename source added 	quicklist fill 
file side 	quicklist 
identical file renamed 	push head 
clean merge 	genstr quicklist 
also need overwrite 	iterator quicklist 
file already 	next genstr 
working copy call 	strcmp err 
update file 	err 
flags instead update 	verify quicklist 
file update 	release iterator 
cache update 	quicklist release 
changed safety note 	quicklist quicklist 
binary used 	fill quicklist 
renormalizations performed comparison 	push 
skipped files 	head genstr 
unchanged since sha 	quicklist iterator 
already compared 	quicklist next 
rename conflict info 	genstr strcmp 
pair rename 	err err 
one file one 	verify 
otherwise normal 	quicklist release 
rename content merge 	iterator quicklist 
resulted file 	release quicklist 
contents already early 	quicklist index 
file contents 	quicklist insert 
recorded correct path 	verify 
may merge 	quicklist release 
involves rename per 	quicklist quicklist 
entry merge 	index quicklist 
function deleted 	insert verify 
one deleted deleted 	quicklist release 
one unchanged 	quicklist 
touch working file 	quicklist push 
exist modify 	head quicklist 
deleted side may 	index quicklist 
put directory 	insert verify 
way added one 	quicklist release 
nothing directory 	quicklist 
nothing directory file 	quicklist push 
overwrite file 	head quicklist 
already present added 	index quicklist 
check permissions 	insert verify 
modified differently entry 	quicklist release 
deleted altogether 	quicklist 
mode means path 	quicklist push 
want actively 	tail quicklist 
merge commits resulting 	fill quicklist 
commit flag 	push tail 
indicating cleanness 	quicklist fill 
merge common ancestor 	quicklist 
use empty 	push tail 
merge fails result 	quicklist push 
contains files 	tail quicklist 
conflict markers cleanness 	push tail 
flag ignored 	itrprintr quicklist 
never actually used 	iterator 
result merge 	quicklist next 
trees always overwritten 	strncmp quicklist 
committed conflicts 	insert itrprintr 
already resolved clear 	quicklist index 
previous settings 	strncmp err 
head remote die 	quicklist 
error code 	index strncmp 
builtin merge recursive 	err quicklist 
usage branch 	index strncmp 
githead env 	err quicklist 
name argc argv 	index strncmp 
prefix bases 	err 
bases count failed 	quicklist index 
result arg 	strncmp err 
sha strlen xsnprintf 	quicklist index 
getenv init 	strncmp err 
merge options ends 	quicklist release 
usagef starts 	iterator 
parse merge opt 	quicklist release 
die size 	quicklist quicklist 
xmalloc sha die 	push tail 
warning size 	genstr quicklist 
die sha die 	index quicklist 
sha die 	insert 
better branch name 	genstr verify 
better branch 	quicklist release 
name merge recursive 	quicklist quicklist 
recursive merge 	push head 
algorithm stolen 	genstr quicklist 
git merge recursive 	index 
fredrik kuivinen 	quicklist insert 
thieves alex riesen 	genstr err 
johannes schindelin 	verify quicklist 
june july since 	release quicklist 
use entry 	verify quicklist 
put read pool 	dup 
cannot rely 	verify quicklist 
since want write 	release quicklist 
index eventually 	release quicklist 
cannot reuse index 	quicklist push 
temporary data 	head genstr 
rename could modifications 	verify 
side history 	quicklist dup 
file renamed returns 	verify quicklist 
index entry 	release quicklist 
instance doesn correspond 	release quicklist 
real cache 	quicklist fill 
entry git 	quicklist 
index create dictionary 	push head 
mapping file 	genstr verify 
names stage data 	quicklist dup 
objects dictionary 	verify quicklist 
contains one entry 	release quicklist 
every path 	release 
non zero stage 	quicklist quicklist 
entry care 	push tail 
entries conflicts adjacent 	genstr quicklist 
particular file 	index strcmp 
conflict appearing files 	err quicklist 
corresponding directory 	index 
order rest list 	strcmp err 
irrelevant achieve 	quicklist release 
sort name compare 	quicklist quicklist 
provide mode 	push tail 
ifdir conflicts sort 	genstr quicklist 
correctly use 	index 
mode ifdir 	strcmp err 
everything simplicity since 	quicklist index 
cases changes 	strcmp err 
order due sorting 	quicklist release 
cause problems 	quicklist quicklist 
foo foo bar 	push 
compare equal 	tail genstr 
make sure foo 	quicklist index 
comes foo 	strcmp err 
bar conflict file 	quicklist release 
conflict currently 	quicklist quicklist 
exist working want 	push 
allow removed 	tail genstr 
make room corresponding 	quicklist index 
directory needed 	err quicklist 
files underneath directories 	release quicklist 
conflicts processed 	quicklist del 
corresponding file involved 	range 
conflict directory 	verify quicklist 
ends removed 	release quicklist 
merge won touch 	quicklist push 
file directory 	head genstr 
needs written working 	verify quicklist 
copy file 	del 
simply removed make 	range verify 
room path 	quicklist release 
make room necessary 	quicklist quicklist 
paths note 	push head 
directory file need 	genstr verify 
present file 	quicklist 
reinstated unique name 	del range 
time processed 	verify quicklist 
merging merge bases 	release quicklist 
want bother 	quicklist fill 
working directory changes 	quicklist push 
ensure conflicts 	tail 
adjacent entries 	genstr verify 
list check last 	quicklist del 
file path 	range verify 
correspond conflict whether 	quicklist release 
path last 	quicklist quicklist 
file something record 	fill 
okay last 	quicklist push 
file make room 	tail genstr 
path friends 	verify quicklist 
needed determine whether 	del range 
path could 	verify quicklist 
exist file working 	release 
directory possible 	quicklist quicklist 
conflict occur exists 	fill quicklist 
stage file 	push tail 
information renames occurred 	genstr verify 
need three 	quicklist del 
trees merge able 	range 
associate correct 	verify quicklist 
cache entries 	release quicklist 
rename information always 	quicklist fill 
equal either 	quicklist push 
note usually bad 	tail genstr 
idea call 	quicklist 
update stages path 	del range 
calling update 	verify quicklist 
file path since 	release quicklist 
sometimes lead 	quicklist fill 
spurious refusing lose 	quicklist push 
untracked file 	tail 
messages update file 	genstr verify 
via make 	quicklist del 
room path via 	range verify 
would lose 	quicklist release 
untracked instead reverse 	quicklist quicklist 
order calls 	push 
executing update file 	tail quicklist 
first update 	push tail 
stages strbuf 	quicklist push 
converting stage definitely 	tail quicklist 
tracked stage 	push tail 
tracked merge started 	verify 
cases path 	quicklist index 
tracked unlink conflict 	err quicklist 
files way 	index err 
make sure leading 	quicklist index 
directories created 	err quicklist 
something exists unlink 	index 
file work 	err quicklist 
tracking successful unlink 	index err 
good existing 	quicklist index 
file error really 	err quicklist 
cares may 	index err 
later decide recursively 	quicklist 
descend submodule 	index err 
directory update index 	quicklist index 
work low 	err quicklist 
level file 	index err 
merging update removal 	quicklist release 
merge modes 	quicklist 
cannot arbitrarily accept 	quicklist fill 
either sha 	quicklist push 
sha correct since 	tail quicklist 
middle point 	push tail 
simply reuse version 	quicklist index 
merge need 	err 
call update file 	quicklist index 
path renamed 	strncmp err 
since would needlessly 	verify quicklist 
touch path 	release quicklist 
could call update 	quicklist push 
file flags 	tail 
update cache update 	quicklist push 
one file 	tail quicklist 
renamed branches 	push tail 
different names fixme 	quicklist push 
rename source 	tail quicklist 
conflicts could detect 	push 
wrong instead 	tail quicklist 
find unique pathname 	replace index 
either rename 	quicklist replace 
source file unique 	index quicklist 
path use 	release quicklist 
unique path instead 	quicklist 
src put 	push tail 
merged content merge 	strlen quicklist 
path usually 	iterator quicklist 
need path path 	next quicklist 
however rename 	compare quicklist 
side merge could 	del 
also involved 	entry quicklist 
rename conflict cases 	release iterator 
keep added 	quicklist iterator 
file around 	quicklist next 
resolving conflict path 	strncmp err 
favor two 	quicklist 
files renamed thing 	release iterator 
path mfi 	quicklist push 
clean mfi clean 	tail quicklist 
might make 	iterator quicklist 
sense two way 	next quicklist 
merge results 	compare 
think cases makes 	quicklist del 
sense merge 	entry quicklist 
undo renames detected 	release iterator 
later non 	quicklist iterator 
recursive merge todo 	quicklist next 
refactor needed 	strncmp 
bug mark src 	err quicklist 
entry processed 	release iterator 
dealing rename source 	quicklist release 
one file 	quicklist quicklist 
renamed sides 	push tail 
bug ren src 	quicklist 
stage think 	push tail 
rename source cases 	quicklist push 
two different 	tail quicklist 
files renamed thing 	push tail 
bug mark 	quicklist push 
src entry processed 	tail 
dealing rename 	quicklist iterator 
source renamed maybe 	quicklist next 
changed use 	quicklist compare 
sha mode unpack 	quicklist del 
trees loads 	entry quicklist 
entries common commit 	release 
stage head 	iterator err 
commit stage merge 	quicklist iterator 
commit stage 	quicklist next 
keep track side 	quicklist compare 
corresponds rename 	err quicklist 
bug ren 	release 
src stage stage 	iterator quicklist 
think rename 	release quicklist 
source added file 	quicklist push 
side identical 	tail quicklist 
file renamed clean 	iterator 
merge also 	idx quicklist 
need overwrite file 	next err 
already working 	quicklist release 
copy call update 	iterator quicklist 
file flags 	release quicklist 
instead update file 	quicklist 
update cache 	push tail 
update changed safety 	verify quicklist 
note binary 	del range 
used renormalizations performed 	quicklist del 
comparison skipped 	range quicklist 
files unchanged 	index 
since sha already 	err verify 
compared rename 	quicklist release 
conflict info pair 	quicklist quicklist 
rename one 	push tail 
file one otherwise 	verify quicklist 
normal rename 	del 
content merge resulted 	range quicklist 
file contents 	del range 
already early file 	verify quicklist 
contents recorded 	index err 
correct path may 	quicklist index 
merge involves 	err 
rename per entry 	quicklist push 
merge function 	tail quicklist 
deleted one deleted 	index strncmp 
deleted one 	err quicklist 
unchanged touch working 	index err 
file exist 	quicklist 
modify deleted 	release quicklist 
side may put 	quicklist push 
directory way 	tail verify 
added one nothing 	quicklist del 
directory nothing 	range quicklist 
directory file overwrite 	del 
file already 	range verify 
present added check 	quicklist index 
permissions modified 	quicklist release 
differently entry deleted 	quicklist quicklist 
altogether mode 	push tail 
means path want 	verify 
actively merge 	quicklist del 
commits resulting commit 	range err 
flag indicating 	quicklist release 
cleanness merge common 	ziplist ziplist 
ancestor use 	push ziplist 
empty merge fails 	push 
result contains 	genstr quicklist 
files conflict 	create ziplist 
markers cleanness flag 	verify verify 
ignored never 	verify quicklist 
actually used result 	release mstime 
merge trees 	mstime 
always overwritten committed 	quicklist quicklist 
conflicts already 	push tail 
resolved clear previous 	genstr quicklist 
settings head 	push head 
remote die error 	genstr err 
code merge-recursive.h 	err 
ancestor branch branch 	quicklist release 
subtree shift 	mstime err 
xdl opts verbosity 	quicklist doubly 
detect rename 	linked list 
diff rename limit 	ziplists copyright 
merge rename 	matt 
limit rename score 	stancliff matt 
needed rename 	genges rights 
limit show 	reserved redistribution 
rename progress call 	use source 
depth obuf 	binary forms 
current file current 	without 
directory conflict 	modification permitted 
file ancestors result 	provided following 
head merge 	conditions met 
common result head 	redistributions source 
merge num 	code must 
result merge trees 	start 
recursive ancestor 	copyright notice 
consolidation rename detecting 	quicklist conditions 
three way 	following disclaimer 
merge recursion git 	redistributions binary 
merge recursive 	form must 
fed trees wrap 	reproduce 
commits call 	copyright notice 
merge recursive proper 	quicklist conditions 
merge-tree.c merge 	following disclaimer 
usage next 	documentation materials 
link mode path 	provided distribution 
blob merge 	neither 
result merge result 	name redis 
end entry 	names contributors 
entry entry size 	may used 
path entry 	endorse promote 
size priv nbuf 	products derived 
entry size 	software 
src dst xpp 	without specific 
xecfg ecb 	prior written 
entry link desc 	permission software 
walk stage 	provided copyright 
mode sha path 	holders contributors 
res info 	express 
path info result 	implied warranties 
orig path 	including limited 
info newbase 	implied warranties 
buf buf buf 	merchantability fitness 
stage info 	particular purpose 
entry path link 	disclaimed 
info entry 	shall copyright 
mask mask dirmask 	owner contributors 
entry info 	liable direct 
info desc rev 	indirect incidental 
sha buf 	special exemplary 
argc argv prefix 	consequential 
buf buf 	damages including 
buf read sha 	limited procurement 
file merge 	substitute goods 
blobs read sha 	services loss 
file memset 	use data 
origin result xdi 	profits 
diff die 	business interruption 
free free explanation 	however caused 
oid hex 	theory liability 
show result 	whether contract 
list show diff 	strict liability 
hashcmp xcalloc 	tort 
lookup blob xmallocz 	including negligence 
traverse path 	otherwise arising 
len make traverse 	way use 
path traverse 	software even 
path create entry 	advised possibility 
create entry 	damage 
merge entry isdir 	memcpy debug 
traverse path 	printing snprintf 
fill descriptor entry 	genstr optimization 
sha fill 	levels size 
descriptor entry sha 	filling maximum 
fill descriptor 	size 
entry sha merge 	bytes multi 
trees free 	element ziplist 
free free free 	larger values 
traverse path 	live isolated 
create entry 	ziplists minimum 
isdir unresolved directory 	ziplist 
isdir link 	size bytes 
entry isdir link 	attempting compression 
entry isdir 	minimum size 
link entry merge 	reduction bytes 
entry entry 	store compressed 
empty resolve entry 	quicklist 
isdir resolve 	node data 
entry empty resolve 	also prevents 
unresolved setup 	storing compression 
traverse info traverse 	compression resulted 
trees sha 	larger size 
die fill descriptor 	original 
die usage 	data verbose 
descriptor descriptor descriptor 	testing debug 
merge trees 	printing simple 
free free free 	way give 
show result 	quicklist entry 
stages existed 	structs 
empty entry never 	values one 
compares even 	call create 
another empty entry 	quicklist free 
already bother 	quicklist release 
showing treat missing 	create quicklist 
entries directories 	parameters 
unresolved directory handled 	cached quicklist 
merge two 	count free 
trees together common 	entire quicklist 
origin walks 	compress ziplist 
sorted trees step 	node update 
checking every 	encoding 
possible name note 	details returns 
directories automatically 	ziplist compressed 
sort differently files 	successfully returns 
see name 	compression failed 
compare never 	ziplist small 
see file directory 	compress 
conflicts won 	bother compressing 
ever compare iow 	small values 
directory changes 	cancel compression 
filename automatically seen 	fails doesn 
directory going 	compress small 
away filename created 	enough 
think three 	lzf compress 
way diff output 	aborts rejects 
either successful 	compression compressable 
merge mode sha 	compress uncompressed 
filename note 	nodes uncompress 
note note fixme 	ziplist 
really really 	node update 
need walk index 	encoding details 
parallel conflict 	returns successful 
mode sha filename 	decode failure 
mode sha 	decode someone 
filename mode 	requested 
sha filename lines 	decompress decompress 
may exist 	good decompress 
course successful merge 	compressed nodes 
rules three 	force node 
way merge git 	immediately compresable 
read modified 	extract 
added removed identically 	raw lzf 
touch modified 	data quicklist 
take touch directory 	node pointer 
made file 	lzf data 
fall unresolved recurses 	assigned data 
likewise opposite 	length 
added modified removed 	compressed lzf 
touch take 	data force 
merge.c commit strategy 	quicklist meet 
xopts xopts 	compression guidelines 
common head arg 	compress depth 
remotes args 	way 
ret head 	guarantee interior 
remote overwrite ignore 	nodes compressed 
trees opts 	iterate interior 
trees dir file 	compress depth 
oid hex 	compress next 
argv pushf argv 	node 
pushf argv 	find compress 
push merge argument 	depth larger 
argv push 	entire list 
argv push argv 	immediately length 
push merge 	less compress 
argument run command 	depth 
opt argv 	sides compress 
clear discard cache 	anything optimized 
read cache 	cases small 
die resolve undo 	depth counts 
clear xcalloc 	iterate reach 
refresh cache hold 	compress 
locked index 	depth sides 
memset memset 	list note 
memset memset setup 	length checks 
standard excludes 	top function 
setup unpack trees 	skip checks 
porcelain parse 	everything 
indirect parse indirect 	exists point 
parse init 	forward reverse 
desc unpack trees 	one node 
write locked 	beyond depth 
index die builtin 	previously used 
git merge 	quicklist 
copyright miklos vajna 	decompress node 
vmiklos frugalware 	use recompress 
git merge junio 	insert node 
hamano cleans 	old node 
metadata uninteresting succeeded 	insert node 
merge changes 	old 
ignore error 	node note 
example nothing restore 	node always 
called merge 	uncompressed assign 
necessary ignore errors 	head tail 
since user 	need uncompress 
see use full 	insert 
terminal width 	creates element 
respect stat graph 	far initialize 
width config 	head tail 
run post merge 	wrappers node 
hook name 	inserting around 
merge commit message 	existing 
see remote 	node size 
matches name name 	previous offset 
number count 	size forward 
number name name 	offset overestimates 
barf values 	encodes integer 
future versions git 	type 
check many 	approximate merged 
files differ 	ziplist size 
check many unmerged 	one ziplist 
entries pretend 	header trailer 
user told merge 	entry head 
remote tracking 	node 
branch upstream current 	quicklist returns 
branch msg 	used existing 
without edit use 	head returns 
editor stdin 	head created 
stdout tty current 	entry tail 
head reachable 	node 
another commit merged 	quicklist returns 
want record 	used existing 
parent resulting merge 	tail returns 
unless given 	tail created 
flip variable find 	create node 
head among 	consisting 
independent tips merged 	pre formed 
find parents 	ziplist used 
record checking 	loading entire 
independent ones bad 	ziplists stored 
merge check 	retrieved later 
detached head current 	append 
branch invoke 	values ziplist 
git reset merge 	individually quicklist 
unmerged entry 	allows restore 
advise git file 	old rdb 
git commit 	ziplists quicklists 
merged head valid 	smaller 
one reason 	ziplist sizes 
forbid git merge 	saved rdb 
branch yet 	ziplist returns 
born git pull 	quicklist argument 
could traditional 	frees passed 
merge msg head 	ziplist 
commit way 	write longval 
tell see second 	create potentially 
token head 	multi node 
people might 	quicklist single 
misused used commit 	existing ziplist 
ish head 	returns 
instead traditional format 	quicklist frees 
never would 	passed ziplist 
additional safety measure 	deleted node 
check invoked 	within compress 
directly first rest 	depth compressed 
commits merged 	nodes 
prepare standard merge 	needing decompressed 
summary message 	one entry 
appended given message 	list given 
already date 	node entry 
already date common 	pointer entry 
ancestors found 	node 
need real merge 	note quicklist 
head reach 	del index 
merge date first 	requires uncompressed 
common merging 	nodes already 
one remote 	uncompressed node 
common merging one 	somewhere 
remote octopus 	returns entire 
fast forward need 	node deleted 
real merge 	node still 
octopus fast forward 	exists also 
one common 	updates param 
see really trivial 	next 
octopus reach 	offset ziplist 
remote date calculate 	deleted node 
individual merge 	original node 
bases otherwise git 	longer valid 
merge head 	one element 
head would missed 	represented 
going make 	entry entry 
commit point need 	stores enough 
real merge 	metadata proper 
matter strategy 	position correct 
use would operate 	ziplist correct 
index possibly 	quicklist 
affecting working resolved 	node invalid 
cleanly desired 	future usage 
index means index 	current node 
must sync 	deleted must 
head commit strategies 	update iterator 
responsible ensure 	node 
stash away local 	offset deleted 
changes one 	node changes 
remember strategy left 	needed already 
state working 	reset iter 
necessary avoid writing 	existing iter 
later exit 	offset 
status code merge 	doesn move 
backend exits 	offset next 
conflicts left resolved 	element still 
handle given 	offset offset 
merge automerge 	next element 
succeeded resulting means 	still 
strategy module 	offset deleted 
resolved merge cleanly 	last element 
pick result 	offet length 
best strategy user 	ziplist next 
fix already 	call quicklist 
result working name 	next 
attr builtin 	jump next 
merge usage squash 	node replace 
option commit 	quicklist entry 
option edit message 	offset index 
verify signatures 	data length 
overwrite ignore merge 	returns 
msg use 	replace happened 
strategies use strategies 	returns replace 
use strategies 	failed changes 
alloc xopts xopts 	happened quicklist 
xopts alloc 	index provides 
branch branch 	uncompressed 
mergeoptions option renormalize 	node given 
verbosity allow 	two nodes 
rerere abort current 	merge ziplists 
merge show 	helps quicklist 
progress upstream sign 	element ziplists 
commit strategy 	fill 
pull twohead pull 	factor handle 
octopus opt 	much higher 
arg unset buf 	levels note 
name ret 	must left 
main cmds cmds 	calling function 
loaded strategies 	considered 
found ent opt 	unusable function 
name unset 	must used 
opt arg unset 	instead quicklist 
opt arg 	node input 
unset builtin merge 	arguments returns 
options stash 	input 
len buffer 	node picked 
argv sha verbose 	merge merging 
args sha 	possible merged 
verbose args head 	ziplists unused 
stash args 	quicklist node 
msg commit remoteheads 	merge 
rev filename 	returned nothing 
ctx head commit 	changed attempt 
remoteheads head 	merge ziplists 
msg reflog message 	within two 
head argv 	nodes either 
opts remote msg 	side 
remote head 	center attempt 
branch head buf 	merge center 
bname ptr 	prev prev 
found len early 	center prev 
seen nonzero 	center next 
truname desc 	center 
bmo argv argc 	next next 
status boolval 	center prev 
common head one 	center center 
trees trees 	center next 
opts sha strategy 	merge prev 
common remoteheads 	prev 
head head arg 	prev could 
clean result 	moved invalidate 
reversed opt data 	merge next 
count ret 	next next 
list alloc buf 	could moved 
attr list 	invalidate 
msg filename msg 	merge center 
filename commit 	node previous 
list remoteheads err 	node center 
msg merge 	could deleted 
editor comment remoteheads 	invalidate 
msg head 	didn merge 
remoteheads result 	target needs 
result commit parents 	valid use 
pptr head 	result center 
head subsumed common 	merge original 
remoteheads result 	merge 
strategy parents buf 	next node 
result commit 	split node 
filename msgbuf argc 	two parts 
argv head 	parameterized offset 
second token second 	argument controls 
sha cnt 	quicklist 
rev argv branch 	node gets 
args remoteheads 	returned returned 
filename buf oid 	node elements 
name stdin 	offset input 
stdout head commit 	node keeps 
head subsumed 	elements 
remoteheads parents remotes 	offset including 
commit merge 	offset returned 
names merge 	node elements 
msg opts remotes 	offset including 
merge names 	offset input 
filename pos npos 	node 
fetch head 	keeps elements 
file sha ptr 	offset returned 
commit saved 	node elements 
head commit head 	offset returned 
subsumed argc 	node elements 
argv merge msg 	offset 
remoteheads remotes 	end input 
autogen commit argc 	node keeps 
argv prefix 	elements offset 
result stash head 	returned node 
sha head 	keep elements 
commit buf head 	including 
arg flag 	offset returned 
head subsumed automerge 	node elements 
common strategy 	offset input 
remoteheads branch 	node keeps 
free nargc nargv 	elements offset 
remote head 	end 
commit hex signature 	input node 
check commit 	keeps elements 
list msg commit 	taken returned 
date common 	node returns 
one ret cnt 	newly created 
strbuf setlen 	node 
strbuf addf error 	split possible 
size strcmp 	copy original 
memset load command 	ziplist split 
list size 	means deleting 
strncmp cmdname exclude 	list ends 
cmds cmdlist 	insert 
cmdlist exit xcalloc 	entry existing 
xstrdup alloc 	entry entry 
grow append 	inserted entry 
strategy strategy alloc 	otherwise inserted 
grow xstrdup 	entry reference 
unlink git path 	node 
merge head 	create node 
unlink git path 	list populate 
merge msg 	accounting flags 
unlink git path 	easier checks 
merge mode 	later determine 
start command die 	insert 
strbuf read 	element tail 
close finish command 	next free 
die strbuf 	space inserting 
setlen sha die 	insert entry 
sha hex 	head next 
run command opt 	node 
die sha 	head previous 
hex run command 	free space 
opt die 	inserting insert 
sha reset 	entry tail 
hard sha hex 	previous node 
run command 	full 
opt strbuf release 	prev next 
refresh cache 	full create 
drop save git 	node attach 
path squash 	quicklist node 
msg open die 	full need 
errno init 	split 
revisions pending pending 	covers cases 
setup revisions 	range elements 
prepare revision walk 	quicklist elements 
die strbuf 	may span 
addstr revision strbuf 	across multiple 
addch strbuf 	quicklist 
addf oid hex 	nodes careful 
pretty print 	tracking start 
commit write full 	end returns 
die errno 	entries deleted 
close die 	nothing deleted 
errno strbuf release 	range 
strbuf addstr 	inclusive start 
getenv strbuf addf 	position requesting 
getenv squash 	elements exist 
message update close 	limit list 
packs run 	size negative 
command opt diff 	offset 
setup diff 	limit max 
setup done diff 	size rest 
sha diffcore 	list lrem 
std diff flush 	end iterate 
run hook 	next nodes 
strbuf release strbuf 	everything 
branchname memset 	deleted deleting 
merge parent die 	count node 
dwim strlen 	entire node 
starts strbuf addf 	without ziplist 
sha hex 	math deleting 
starts strbuf 	nodes 
addf sha hex 	one calculate 
starts strbuf 	size current 
addf sha hex 	node offset 
strrchr isdigit 	negative first 
strbuf addf strbuf 	run loop 
setlen exists 	deleting 
strbuf addf sha 	entire range 
hex strbuf 	start offset 
release strbuf release 	end list 
merge remote 	since negative 
strbuf addf sha 	offset number 
hex strbuf 	elements 
addf sha hex 	tail list 
strbuf release 	use directly 
strbuf release split 	deletion count 
cmdline die 	positive offset 
split cmdline strerror 	greater remaining 
realloc memmove 	extent 
parse options 	remaining extent 
free starts starts 	entire offset 
strcmp strlen 	deleting less 
free xstrdup strcmp 	extent node 
strcmp git 	use extent 
config strcmp git 	directly 
config strcmp 	passthrough ziplist 
git config strcmp 	compare returns 
git config 	quicklist iterator 
strcmp git config 	iter initialization 
maybe strcmp 	every call 
strcmp git config 	quicklist 
strcmp git 	next next 
config fmt merge 	element quicklist 
msg config 	initialize iterator 
git gpg config 	specific offset 
git diff 	idx make 
config memset 	iterator 
parse indirect parse 	nodes direction 
indirect parse 	direction release 
indirect cache free 	iterator still 
parse init 	valid current 
desc unpack trees 	node encode 
write cache 	current 
die hold locked 	node next 
index refresh 	element iterator 
cache write locked 	note must 
index error 	insert list 
rollback file strcmp 	iterating may 
strcmp error 	list 
init merge options 	iterating quicklist 
strcmp isatty 	del entry 
parse merge opt 	function insert 
die merge 	quicklist iterating 
remote commit list 	create iterator 
insert hold 	addition 
locked index 	iter quicklist 
merge recursive write 	iterator quicklist 
locked index 	direction quicklist 
die index file 	entry entry 
rollback file 	quicklist next 
merge command stage 	iter 
xstrdup strchr 	entry entry 
alloc grow xstrdup 	use entry 
free alloc 	entry use 
grow xstrdup memset 	entry longval 
split merge 	populates entry 
strategies append strategy 	values 
strategy size 	iteration returns 
append strategy git 	iteration complete 
path merge 	iteration possible 
msg open die 	contents entry 
errno write 	valid use 
full die errno 	current 
close git 	index use 
path merge 	existing iterator 
msg strbuf reset 	offset prev 
strbuf read 	next necessary 
file die errno 	populate existing 
error write 	ziplist 
merge state exit 	position ran 
strbuf addbuf 	ziplist entries 
strbuf addch strbuf 	pick next 
commented addf 	node update 
write merge msg 	offset run 
run commit 	retrieval 
hook index file 	forward traversal 
git path 	reverse traversal 
merge msg abort 	duplicate quicklist 
commit launch 	success copy 
editor git path 	original quicklist 
merge msg 	returned 
abort commit read 	original quicklist 
merge msg 	success error 
strbuf stripspace 	never modified 
abort commit strbuf 	returns newly 
release strbuf 	allocated quicklist 
addbuf strbuf release 	copy 
write trivial 	count must 
commit list append 	equal orig 
commit list 	count populate 
append prepare commit 	entry element 
commit die 	specified zero 
finish drop save 	index 
free commit 	head element 
list commit list 	next head 
insert strbuf 	negative integers 
addch prepare commit 	used order 
commit die 	count tail 
strbuf addf finish 	last 
strbuf release 	element penultimate 
drop save 	index range 
git path merge 	returned returns 
msg fopen 	element found 
die errno append 	returns element 
conflicts hint 	found 
fputs strbuf release 	reverse forward 
fclose rerere 	forward normal 
sha lookup commit 	head tail 
reference gently 	offset reverse 
die hashcmp init 	need negative 
revisions setup 	offset 
revisions run diff 	tail head 
files count 	undo result 
unmerged entries branch 	original index 
die die 	caller use 
die xcalloc die 	result compress 
merge remote 	caller 
merge remote strbuf 	recompress node 
addf oid 	needed rotate 
hex git 	quicklist moving 
path merge head 	tail element 
open die 	head first 
errno write full 	tail 
die errno 	entry found 
close strbuf addch 	ziplist populated 
write merge 	longval instead 
msg git path 	write longval 
merge mode 	tail entry 
open die errno 	head 
strbuf reset 	must happen 
strbuf addf write 	tail deleted 
full die 	quicklist one 
errno close getenv 	node head 
git config 	ziplist also 
maybe die fstat 	tail 
fstat isatty 	ziplist push 
isatty reduce heads 	head could 
pop commit 	reallocated single 
commit list 	ziplist would 
insert memset fmt 	make pre 
merge msg 	existing 
strbuf setlen git 	unusable tail 
path fetch 	entry pop 
head open die 	quicklist result 
errno strbuf 	data ptr 
read die errno 	data saver 
close die 	function 
errno strchr sha 	pointer data 
hex memcmp 	number quicklist 
merge parent die 	element returned 
commit list 	sval means 
insert strbuf release 	elements available 
commit list 	means 
insert strcmp handle 	check data 
fetch head 	sval values 
reduce parents merge 	data use 
parent help 	data otherwise 
unknown commit 	use sval 
list insert reduce 	malloc 
parents merge 	copy data 
name merge remote 	passed pop 
prepare merge 	function returns 
message strbuf release 	malloc quicklist 
strcmp usage 	wrapper allow 
options resolve refdup 	argument 
starts sha 	switching head 
lookup commit die 	tail pop 
git config 	rest file 
parse branch merge 	test cases 
options parse 	test helpers 
options file exists 	unix 
git path 	time microseconds 
merge head die 	unix time 
cmd reset 	milliseconds iterate 
read cache 	entire quicklist 
unmerged die resolve 	print list 
conflict file 	print 
exists git path 	returns physical 
merge head 	count elements 
die die file 	found iterating 
exists git 	list count 
path cherry pick 	number list 
head die 	nodes 
die resolve undo 	verify list 
clear die 	metadata matches 
setup upstream die 	physical list 
strcmp usage 	contents generate 
options die die 	concatenating integer 
collect parents 	prefix 
die die read 	main test 
empty update 	callable files 
old style invocation 	head tail 
warning strbuf 	beacuse node 
addstr collect 	head tail 
parents collect parents 	head 
usage options 	tail beacuse 
memset check commit 	node head 
signature find 	tail ignore 
unique abbrev die 	compression verify 
die die 	ziplist small 
signature check clear 	compress 
strbuf addstr 	force unique 
strbuf addf merge 	node force 
remote setenv 	reset insert 
strbuf reset strbuf 	bar bob 
addf sha 	iterating list 
hex setenv merge 	insert 
remote strbuf 	fill spills 
reset merge remote 	node didn 
merge remote 	fix insert 
merge remote edit 	iterating verify 
option strategies 	results lrem 
strategies merge 	bar 
bases commit list 	check result 
insert octopus 	lrem bar 
merge bases free 	result must 
update finish 	abc foo 
date hashcmp find 	foobar foobared 
unique abbrev 	zap 
find unique abbrev 	test foo 
strbuf addstr 	lrem foo 
strbuf addstr checkout 	check result 
fast forward 	lrem foo 
finish drop save 	ignoring part 
refresh cache 	still 
git committer info 	deleting foo 
read trivial 	two foo 
merge trivial merge 	result must 
bases hashcmp 	abc foo 
finish date die 	foobar foobared 
git committer 	zap 
info save 	test foo 
state hashcpy restore 	result tests 
state merge 	check results 
strategy evaluate result 	deletion hij 
write trivial 	ltrim keep 
finish automerge restore 	inclusive 
state restore 	remaining force 
state merge strategy 	disable compression 
finish write 	sequential integers 
merge state suggest 	compress check 
conflicts free 	always fails 
builtin git merge 	ltrim 
copyright miklos 	keep inclusive 
vajna vmiklos frugalware 	remaining ltrim 
git merge 	keep inclusive 
junio hamano cleans 	remaining make 
metadata uninteresting 	sure loop 
succeeded merge changes 	forever 
ignore error 	run longer 
example nothing 	test compression 
restore called merge 	depth outside 
necessary ignore 	primary test 
errors since user 	loop skip 
see use 	many 
full terminal width 	redundant test 
respect stat 	cases quicklist.h 
graph width config 	fill compress 
run post 	quicklist depth 
merge hook name 	quicklist fill 
merge commit 	quicklist 
message see remote 	fill depth 
matches name 	quicklist quicklist 
name number count 	quicklist quicklist 
number name 	quicklist quicklist 
name barf values 	fill compress 
future versions 	quicklist 
git check 	node quicklist 
many files differ 	node iter 
check many 	entry quicklist 
unmerged entries pretend 	index data 
user told 	quicklist start 
merge remote tracking 	stop 
branch upstream 	quicklist direction 
current branch msg 	quicklist direction 
without edit 	idx iter 
use editor stdin 	node iter 
stdout tty 	orig quicklist 
current head reachable 	index 
another commit 	entry quicklist 
merged want record 	quicklist quicklist 
parent resulting 	quicklist data 
merge unless given 	sval saver 
flip variable 	quicklist data 
find head among 	slong 
independent tips 	len node 
merged find 	data argc 
parents record checking 	argv quicklist 
independent ones 	doubly linked 
bad merge check 	quicklist implementation 
detached head 	copyright 
current branch invoke 	matt stancliff 
git reset 	matt genges 
merge unmerged entry 	rights reserved 
advise git 	redistribution use 
file git commit 	source binary 
merged head 	forms 
valid one reason 	without modification 
forbid git 	permitted provided 
merge branch yet 	following conditions 
born git 	met redistributions 
pull could traditional 	source code 
merge msg 	must 
head commit way 	retain copyright 
tell see 	notice quicklist 
second token 	conditions following 
head people might 	disclaimer redistributions 
misused used 	binary 
commit ish head 	form must 
instead traditional 	reproduce copyright 
format never would 	notice quicklist 
additional safety 	conditions following 
measure check invoked 	disclaimer documentation 
directly first 	materials 
rest commits merged 	provided distribution 
prepare standard 	neither name 
merge summary message 	redis names 
appended given 	contributors may 
message already date 	used endorse 
already date 	promote 
common ancestors found 	products derived 
need real 	software without 
merge head reach 	specific prior 
merge date 	written permission 
first common 	software provided 
merging one remote 	copyright 
common merging 	holders contributors 
one remote octopus 	express implied 
fast forward 	warranties including 
need real merge 	limited implied 
octopus fast 	warranties merchantability 
forward one common 	fitness 
see really 	particular purpose 
trivial octopus reach 	disclaimed shall 
remote date 	copyright owner 
calculate individual merge 	contributors liable 
bases otherwise 	direct indirect 
git merge head 	incidental 
head would 	special exemplary 
missed going make 	consequential damages 
commit point 	including limited 
need real 	procurement substitute 
merge matter strategy 	goods services 
use would 	loss 
operate index possibly 	use data 
affecting working 	profits business 
resolved cleanly desired 	interruption however 
index means 	caused theory 
index must sync 	liability whether 
head commit 	contract 
strategies responsible ensure 	strict liability 
stash away 	tort including 
local changes one 	negligence otherwise 
remember strategy 	arising way 
left state working 	use software 
necessary avoid 	even 
writing later exit 	advised possibility 
status code 	damage node 
merge backend exits 	quicklist iterator 
conflicts left 	data structures 
resolved handle 	used currently 
given merge automerge 	quicklist 
succeeded resulting 	node describing 
means strategy module 	ziplist quicklist 
resolved merge 	use bit 
cleanly pick result 	fields keep 
best strategy 	quicklist node 
user fix already 	bytes 
result working 	count bits 
merge.c commit strategy 	max max 
xopts xopts 	bytes max 
common head arg 	count actually 
remotes args 	encoding bits 
ret head remote 	raw 
overwrite ignore 	lzf container 
trees opts trees 	bits none 
dir file 	ziplist recompress 
oid hex argv 	bit node 
pushf argv 	temporarry decompressed 
pushf argv 	usage 
push merge argument 	attempted compress 
argv push 	bit used 
argv push argv 	verifying testing 
push merge 	extra bits 
argument run command 	free future 
opt argv 	use 
clear discard cache 	pads remainder 
read cache 	bits ziplist 
die resolve undo 	size bytes 
clear xcalloc 	count items 
refresh cache hold 	ziplist raw 
locked index 	lzf 
memset memset memset 	none ziplist 
memset setup 	node previous 
standard excludes setup 	compressed node 
unpack trees 	compress small 
porcelain parse indirect 	bits steal 
parse indirect 	future 
parse init 	usage quicklist 
desc unpack trees 	lzf holding 
write locked 	followed compressed 
index die builtin 	length compressed 
git merge 	field compressed 
copyright miklos vajna 	lzf 
vmiklos frugalware 	data total 
git merge junio 	compressed length 
hamano cleans 	note uncompressed 
metadata uninteresting succeeded 	length stored 
merge changes 	quicklist node 
ignore error example 	quicklist 
nothing restore 	node compressed 
called merge necessary 	node points 
ignore errors 	quicklist lzf 
since user see 	lzf size 
use full 	bytes quicklist 
terminal width 	bit 
respect stat graph 	systems describing 
width config 	quicklist count 
run post merge 	number total 
hook name 	entries len 
merge commit message 	number quicklist 
see remote 	nodes 
matches name name 	compress compression 
number count 	disabled otherwise 
number name name 	number quicklist 
barf values 	nodes uncompressed 
future versions git 	ends quicklist 
check many 	fill 
files differ check 	user requested 
many unmerged 	fill factor 
entries pretend user 	total count 
told merge 	entries ziplists 
remote tracking branch 	number quicklist 
upstream current 	nodes 
branch msg 	fill factor 
without edit use 	individual nodes 
editor stdin 	depth end 
stdout tty current 	nodes compress 
head reachable 	offset current 
another commit merged 	ziplist 
want record 	quicklist node 
parent resulting merge 	encodings quicklist 
unless given 	compression disable 
flip variable find 	quicklist container 
head among 	formats prototypes 
independent tips merged 	directions 
find parents 	iterators quicklist 
record checking independent 	rallocx.c tsz 
ones bad 	szs offset 
merge check detached 	len ret 
head current 	buf psz 
branch invoke git 	qsz 
reset merge 	start sizes 
unmerged entry 	start size 
advise git file 	align align 
git commit 	mallocx ptr 
merged head valid 	sallocx rallocx 
one reason 	ptr 
forbid git merge 	sallocx rallocx 
branch yet 	ptr sallocx 
born git pull 	dallocx test 
could traditional 	fail mallocx 
merge msg head 	ptr sallocx 
commit way 	validate 
tell see second 	fill memset 
token head 	validate fill 
people might misused 	rallocx ptr 
used commit 	sallocx validate 
ish head instead 	fill validate 
traditional format 	fill 
never would additional 	memset validate 
safety measure 	fill dallocx 
check invoked 	mallocx mallocx 
directly first rest 	align ptr 
commits merged 	rallocx mallocx 
prepare standard merge 	align 
summary message 	ptr ptr 
appended given message 	dallocx mallocx 
already date 	mallocx align 
already date common 	ptr rallocx 
ancestors found 	mallocx align 
need real merge 	ptr 
head reach 	ptr sallocx 
merge date first 	validate fill 
common merging 	validate fill 
one remote common 	validate fill 
merging one 	dallocx test 
remote octopus fast 	rand.c 
forward need 	seedval carry 
real merge octopus 	carry next 
fast forward 	seed low 
one common 	high mul 
see really trivial 	addequ addequ 
octopus reach 	mul 
remote date calculate 	addequ mul 
individual merge 	low carry 
bases otherwise git 	low low 
merge head 	pseudo random 
head would missed 	number generation 
going make 	functions 
commit point need 	derived drand 
real merge 	function obtained 
matter strategy use 	pysam source 
would operate 	code functions 
index possibly affecting 	used order 
working resolved 	replace 
cleanly desired index 	math random 
means index 	lua implementation 
must sync 	something exactly 
head commit strategies 	behavior across 
responsible ensure 	different systems 
stash away local 	lua 
changes one 	uses libc 
remember strategy left 	rand required 
state working 	implement specific 
necessary avoid writing 	prng generating 
later exit 	sequence different 
status code merge 	systems 
backend exits 	seeded integer 
conflicts left resolved 	original code 
handle given 	appears domain 
merge automerge succeeded 	modified removing 
resulting means 	non needed 
strategy module resolved 	functions 
merge cleanly 	style coding 
pick result best 	stuff copyright 
strategy user 	salvatore sanfilippo 
fix already 	antirez gmail 
result working name 	dot rights 
attr builtin 	reserved 
merge usage squash 	redistribution use 
option commit 	source binary 
option edit message 	forms without 
verify signatures 	modification permitted 
overwrite ignore merge 	provided following 
msg use 	conditions 
strategies use strategies 	met redistributions 
use strategies 	source code 
alloc xopts xopts 	must retain 
xopts alloc 	copyright notice 
branch branch mergeoptions 	list conditions 
option renormalize 	following 
verbosity allow rerere 	disclaimer redistributions 
abort current 	binary form 
merge show progress 	must reproduce 
upstream sign 	copyright notice 
commit strategy 	list conditions 
pull twohead pull 	following 
octopus opt 	disclaimer documentation 
arg unset buf 	materials provided 
name ret 	distribution neither 
main cmds cmds 	name redis 
loaded strategies 	names contributors 
found ent opt 	may 
name unset 	used endorse 
opt arg unset 	promote products 
opt arg 	derived software 
unset builtin merge 	without specific 
options stash 	prior written 
len buffer argv 	permission 
sha verbose 	software provided 
args sha verbose 	copyright holders 
args head 	contributors express 
stash args msg 	implied warranties 
commit remoteheads 	including limited 
rev filename 	implied 
ctx head commit 	warranties merchantability 
remoteheads head 	fitness particular 
msg reflog message 	purpose disclaimed 
head argv 	shall copyright 
opts remote msg 	owner contributors 
remote head 	liable 
branch head buf 	direct indirect 
bname ptr 	incidental special 
found len early 	exemplary consequential 
seen nonzero 	damages including 
truname desc bmo 	limited procurement 
argv argc 	substitute 
status boolval common 	goods services 
head one 	loss use 
trees trees opts 	data profits 
sha strategy 	business interruption 
common remoteheads 	however caused 
head head arg 	theory 
clean result 	liability whether 
reversed opt data 	contract strict 
count ret 	liability tort 
list alloc buf 	including negligence 
attr list 	otherwise arising 
msg filename msg 	way 
filename commit 	use software 
list remoteheads err 	even advised 
msg merge 	possibility damage 
editor comment remoteheads 	rand.h seedval 
msg head 	copyright salvatore 
remoteheads result result 	sanfilippo 
commit parents 	antirez gmail 
pptr head head 	dot rights 
subsumed common 	reserved redistribution 
remoteheads result strategy 	use source 
parents buf 	binary forms 
result commit 	without 
filename msgbuf argc 	modification permitted 
argv head 	provided following 
second token second 	conditions met 
sha cnt 	redistributions source 
rev argv branch 	code must 
args remoteheads 	retain 
filename buf oid 	copyright notice 
name stdin 	list conditions 
stdout head commit 	following disclaimer 
head subsumed 	redistributions binary 
remoteheads parents remotes 	form must 
commit merge 	reproduce 
names merge msg 	copyright notice 
opts remotes 	list conditions 
merge names filename 	following disclaimer 
pos npos 	documentation materials 
fetch head file 	provided distribution 
sha ptr 	neither 
commit saved 	name redis 
head commit head 	names contributors 
subsumed argc 	may used 
argv merge msg 	endorse promote 
remoteheads remotes 	products derived 
autogen commit argc 	software 
argv prefix 	without specific 
result stash head 	prior written 
sha head 	permission software 
commit buf head 	provided copyright 
arg flag 	holders contributors 
head subsumed automerge 	express 
common strategy 	implied warranties 
remoteheads branch free 	including limited 
nargc nargv 	implied warranties 
remote head commit 	merchantability fitness 
hex signature 	particular purpose 
check commit list 	disclaimed 
msg commit 	shall copyright 
date common 	owner contributors 
one ret cnt 	liable direct 
strbuf setlen 	indirect incidental 
strbuf addf error 	special exemplary 
size strcmp 	consequential 
memset load command 	damages including 
list size 	limited procurement 
strncmp cmdname exclude 	substitute goods 
cmds cmdlist 	services loss 
cmdlist exit xcalloc 	use data 
xstrdup alloc 	profits 
grow append strategy 	business interruption 
strategy alloc 	however caused 
grow xstrdup unlink 	theory liability 
git path 	whether contract 
merge head unlink 	strict liability 
git path 	tort 
merge msg 	including negligence 
unlink git path 	otherwise arising 
merge mode 	way use 
start command die 	software even 
strbuf read 	advised possibility 
close finish command 	damage 
die strbuf 	rb.c magic 
setlen sha die 	key ret 
sha hex 	key node 
run command opt 	black height 
die sha 	black depth 
hex run command 	nil 
opt die 	ret left 
sha reset hard 	node right 
sha hex 	node node 
run command opt 	data search 
strbuf release 	node node 
refresh cache drop 	nnodes 
save git 	search node 
path squash 	black height 
msg open die 	imbalances node 
errno init 	data nnodes 
revisions pending pending 	ret node 
setup revisions 	data 
prepare revision walk 	nnodes ret 
die strbuf 	sfmt bag 
addstr revision strbuf 	nodes black 
addch strbuf 	height imbalances 
addf oid hex 	start nnodes 
pretty print 	start 
commit write full 	nnodes gen 
die errno 	empty ptr 
close die errno 	first ptr 
strbuf release 	last ptr 
strbuf addstr getenv 	search ptr 
strbuf addf 	nsearch 
getenv squash message 	ptr psearch 
update close 	rbtn left 
packs run 	rbtn right 
command opt diff 	rbtn red 
setup diff 	rbtn red 
setup done diff 	rbtn 
sha diffcore 	red rbtn 
std diff flush 	red recurse 
run hook 	recurse search 
strbuf release strbuf 	ptr nsearch 
branchname memset 	ptr psearch 
merge parent die 	ptr 
dwim strlen 	iter reverse 
starts strbuf addf 	iter nsearch 
sha hex 	psearch rbtn 
starts strbuf addf 	black height 
sha hex 	recurse iterate 
starts strbuf addf 	iterate 
sha hex 	reverse next 
strrchr isdigit strbuf 	node prev 
addf strbuf 	node init 
setlen exists 	gen rand 
strbuf addf sha 	gen rand 
hex strbuf 	range 
release strbuf release 	insert rbtn 
merge remote 	black height 
strbuf addf sha 	recurse iterate 
hex strbuf 	iterate reverse 
addf sha hex 	empty ptr 
strbuf release 	first 
strbuf release split 	ptr last 
cmdline die 	next prev 
split cmdline strerror 	node node 
realloc memmove 	iter reverse 
parse options free 	iter reached 
starts starts 	fini 
strcmp strlen free 	gen rand 
xstrdup strcmp 	test duplicates 
strcmp git config 	allowed force 
strcmp git 	arbitrary ordering 
config strcmp 	non identical 
git config strcmp 	items 
git config 	equal keys 
strcmp git config 	red nodes 
maybe strcmp 	must interleaved 
strcmp git config 	black nodes 
strcmp git 	self left 
config fmt merge 	subtree 
msg config 	right subtree 
git gpg config 	test search 
git diff 	test nsearch 
config memset parse 	test psearch 
indirect parse 	test 
indirect parse indirect 	nsearch test 
cache free 	psearch insert 
parse init desc 	order insert 
unpack trees 	reverse order 
write cache 	initialize nodes 
die hold locked 	insert 
index refresh 	nodes nodes 
cache write locked 	rb.h cpp 
index error 	macro implementation 
rollback file strcmp 	left leaning 
strcmp error 	red black 
init merge options 	trees 
strcmp isatty 	parent pointers 
parse merge opt 	used color 
die merge 	bits stored 
remote commit list 	least significant 
insert hold 	bit right 
locked index merge 	child 
recursive write 	pointers compact 
locked index die 	defined thus 
index file 	making node 
rollback file merge 	linkage compact 
command stage 	possible red 
xstrdup strchr 	black 
alloc grow xstrdup 	trees usage 
free alloc 	include stdint 
grow xstrdup memset 	include stdbool 
split merge 	define ndebug 
strategies append strategy 	optional see 
strategy size 	include 
append strategy git 	define compact 
path merge 	optional embed 
msg open die 	color bits 
errno write 	right child 
full die errno 	pointers include 
close git 	node 
path merge msg 	structure root 
strbuf reset 	structure left 
strbuf read file 	accessors right 
die errno 	accessors color 
error write merge 	accessors right 
state exit 	accessors 
strbuf addbuf 	color accessors 
strbuf addch strbuf 	node initializer 
commented addf 	initializer utility 
write merge msg 	macros proto 
run commit 	macro generates 
hook index file 	function 
git path 	prototypes correspond 
merge msg abort 	functions generated 
commit launch 	equivalently parameterized 
editor git path 	call gen 
merge msg 	gen macro 
abort commit read 	generates 
merge msg 	type specific 
strbuf stripspace abort 	red black 
commit strbuf 	implementation cpp 
release strbuf addbuf 	macros arguments 
strbuf release 	attr function 
write trivial commit 	attribute 
list append 	generated functions 
commit list 	prefix prefix 
append prepare commit 	generated functions 
commit die 	type type 
finish drop save 	red black 
free commit 	data 
list commit list 	structure type 
insert strbuf 	type red 
addch prepare commit 	black node 
commit die 	data structure 
strbuf addf finish 	node field 
strbuf release 	name 
drop save git 	red black 
path merge 	node linkage 
msg fopen die 	link cmp 
errno append 	node comparison 
conflicts hint fputs 	function name 
strbuf release 	following 
fclose rerere 	prototype cmp 
sha lookup commit 	type node 
reference gently 	type key 
die hashcmp init 	interpretation comparison 
revisions setup 	function values 
revisions run diff 	node 
files count 	node node 
unmerged entries branch 	cases node 
die die 	key macro 
die xcalloc die 	argument first 
merge remote 	argument comparison 
merge remote strbuf 	function 
addf oid 	makes possible 
hex git path 	write comparison 
merge head 	functions treat 
open die errno 	first argument 
write full 	specially assuming 
die errno close 	following 
strbuf addch 	setup node 
write merge 	node node 
msg git path 	node node 
merge mode 	link node 
open die errno 	gen node 
strbuf reset 	link 
strbuf addf write 	cmp following 
full die 	api generated 
errno close getenv 	description initialize 
git config 	red black 
maybe die fstat 	structure args 
fstat isatty 	pointer 
isatty reduce heads 	uninitialized red 
pop commit 	black empty 
commit list insert 	description determine 
memset fmt 	whether empty 
merge msg strbuf 	args pointer 
setlen git 	initialized 
path fetch head 	red black 
open die 	ret empty 
errno strbuf 	otherwise node 
read die errno 	first node 
close die 	last description 
errno strchr sha 	first 
hex memcmp 	last node 
merge parent die 	args pointer 
commit list 	initialized red 
insert strbuf release 	black ret 
commit list 	first last 
insert strcmp handle 	node 
fetch head 	empty node 
reduce parents merge 	next node 
parent help 	node node 
unknown commit list 	prev node 
insert reduce 	node description 
parents merge name 	node 
merge remote 	successor predecessor 
prepare merge message 	args pointer 
strbuf release 	initialized red 
strcmp usage 	black node 
options resolve refdup 	node ret 
starts sha 	node 
lookup commit die 	successor predecessor 
git config 	node last 
parse branch merge 	first node 
options parse 	search node 
options file exists 	key description 
git path 	search 
merge head die 	node matches 
cmd reset 	key args 
read cache unmerged 	pointer initialized 
die resolve 	red black 
conflict file exists 	key search 
git path 	key 
merge head die 	ret node 
die file 	matches key 
exists git path 	match node 
cherry pick 	nsearch node 
head die 	key node 
die resolve undo 	psearch 
clear die 	node key 
setup upstream die 	description search 
strcmp usage 	node matches 
options die die 	key match 
collect parents 	found would 
die die read 	key 
empty update 	successor predecessor 
old style invocation 	key args 
warning strbuf 	pointer initialized 
addstr collect parents 	red black 
collect parents 	key search 
usage options memset 	key 
check commit 	ret node 
signature find unique 	matches key 
abbrev die 	match hypothetical 
die die 	node successor 
signature check clear 	predecessor successor 
strbuf addstr 	predecessor 
strbuf addf merge 	insert node 
remote setenv 	node description 
strbuf reset strbuf 	insert node 
addf sha 	args pointer 
hex setenv merge 	initialized red 
remote strbuf 	black 
reset merge remote 	node node 
merge remote 	inserted node 
merge remote edit 	node description 
option strategies 	node args 
strategies merge bases 	pointer initialized 
commit list 	red 
insert octopus merge 	black node 
bases free 	node removed 
update finish date 	node iter 
hashcmp find 	node start 
unique abbrev 	node node 
find unique abbrev 	arg 
strbuf addstr 	node reverse 
strbuf addstr checkout 	iter node 
fast forward 	start node 
finish drop save 	node arg 
refresh cache 	description iterate 
git committer info 	forward 
read trivial 	backward starting 
merge trivial merge 	node modified 
bases hashcmp 	iteration must 
finish date die 	immediately terminated 
git committer 	callback function 
info save state 	causes 
hashcpy restore 	modification args 
state merge strategy 	pointer initialized 
evaluate result 	red black 
write trivial finish 	start node 
automerge restore 	start iteration 
state restore 	start 
state merge strategy 	first last 
finish write 	node callback 
merge state suggest 	function called 
conflicts free 	node iteration 
builtin git merge 	normal circumstances 
copyright miklos 	callback 
vajna vmiklos frugalware 	function causes 
git merge 	iteration callback 
junio hamano cleans 	function returns 
metadata uninteresting 	non iteration 
succeeded merge changes 	immediately terminated 
ignore error 	non 
example nothing restore 	returned iterator 
called merge 	useful starting 
necessary ignore errors 	iteration modifying 
since user 	arg opaque 
see use full 	pointer passed 
terminal width 	ret 
respect stat 	iteration completed 
graph width config 	non callback 
run post 	caused termination 
merge hook name 	iteration wind 
merge commit 	unwind fix 
message see remote 	node 
matches name 	split node 
name number count 	lean left 
number name 	root make 
name barf values 	black wind 
future versions 	silence compiler 
git check many 	warning 
files differ 	find node 
check many unmerged 	successor preparation 
entries pretend 	swap swap 
user told merge 	node successor 
remote tracking 	node successor 
branch upstream 	right 
current branch msg 	child following 
without edit 	code wrong 
use editor stdin 	thing right 
stdout tty 	child pointer 
current head reachable 	however doesn 
another commit 	matter 
merged want record 	pointer properly 
parent resulting 	successor pruned 
merge unless given 	pruned leaf 
flip variable 	node child 
find head among 	pointers never 
independent tips 	accessed 
merged find parents 	bother setting 
record checking 	nil node 
independent ones bad 	successor left 
merge check 	child splice 
detached head current 	node without 
branch invoke 	losing 
git reset 	left child 
merge unmerged entry 	contained one 
advise git 	node prune 
file git commit 	red node 
merged head 	requires fixup 
valid one reason 	node 
forbid git 	pruned black 
merge branch yet 	unwind balance 
born git 	restored following 
pull could traditional 	diagrams indicate 
merge msg 	path removed 
head commit way 	node 
tell see 	pathp pathp 
second token head 	balance restored 
people might 	rotation modified 
misused used commit 	subtree root 
ish head 	pathp balance 
instead traditional format 	restored 
never would 	rotation modified 
additional safety 	subtree root 
measure check invoked 	may actually 
directly first 	root root 
rest commits merged 	pathp pathp 
prepare standard 	pathp 
merge summary message 	balance restored 
appended given 	rotation modified 
message already date 	subtree root 
already date 	may actually 
common ancestors found 	root root 
need real 	pathp 
merge head reach 	balance restored 
merge date 	rotation modified 
first common merging 	subtree root 
one remote 	pathp balance 
common merging one 	restored pathp 
remote octopus 	balance 
fast forward need 	restored rotation 
real merge 	modified subtree 
octopus fast 	root may 
forward one common 	actually root 
see really 	root pathp 
trivial octopus reach 	root 
remote date 	rdb.c reason 
calculate individual merge 	rdb len 
bases otherwise 	rdb type 
git merge head 	rdb type 
head would 	rdb rdb 
missed going make 	rdb 
commit point 	rdb len 
need real merge 	buf nwritten 
matter strategy 	rdb isencoded 
use would operate 	buf len 
index possibly 	type enc 
affecting working resolved 	rdb 
cleanly desired 	enctype flags 
index means 	plain encode 
index must sync 	enc val 
head commit 	buf len 
strategies responsible ensure 	len enc 
stash away 	endptr 
local changes one 	buf rdb 
remember strategy 	data compress 
left state working 	len original 
necessary avoid 	len nwritten 
writing later exit 	rdb len 
status code 	comprlen 
merge backend exits 	outlen nwritten 
conflicts left 	rdb flags 
resolved handle given 	plain len 
merge automerge 	clen val 
succeeded resulting means 	rdb len 
strategy module 	enclen 
resolved merge cleanly 	nwritten buf 
pick result 	rdb buf 
best strategy 	nwritten enclen 
user fix already 	rdb obj 
result working 	rdb flags 
mergesort.c ptr len 	encode 
list next 	plain isencoded 
next list next 	len buf 
next compare 	rdb rdb 
curr prev next 	rdb val 
next nth 	buf len 
next compare pop 	min 
item pop 	max rdb 
item pop item 	val buf 
pop item 	len rdb 
compare pop item 	rdb type 
pop item 	rdb nwritten 
next nth next 	node 
next mergesort.h 	data compress 
list next next 	len eleobj 
compare sort 	eleobj score 
linked list 	key val 
place next returns 	len rdb 
next element 	key 
given element linked 	val expiretime 
list next 	rdb key 
takes two elements 	keylen val 
makes next 	vallen rdb 
element list compare 	key val 
takes two 	rdb 
elements returns negative 	key val 
positive sign 	buf vlen 
subtracting mingw.c delay 	rdb redis 
winerr error 	bits rdb 
errcode answer answer 	error magic 
len format 	cksum 
question retry hook 	size expires 
args answer 	size keystr 
pathname ret tries 	key expire 
wpathname wpath 	rdb error 
findbuf handle 	eofmark filename 
wbuf err pathname 	tmpfile 
ret tries 	cwd rdb 
wpathname path mode 	error cwdp 
ret wpath 	cwdp filename 
filename oflags args 	childpid start 
mode wfilename 	retval dirty 
attrs type stream 	childpid 
filename otype 	tmpfile rdbtype 
file wfilename wotype 	rdb ele 
filename otype 	dec len 
stream file wfilename 	len llval 
wotype stream 	zsetlen maxelelen 
ret buf len 	ele 
result filename 	score znode 
mode wfilename dirname 	len ret 
wdirname filename 	field field 
mode wfilename win 	encoded fstr 
time wfilename 	vstr flen 
attributes follow 	vlen 
file name buf 	maxlen pos 
fdata wfilename 	buf len 
findbuf handle buffer 	filename dbid 
follow file 	type rdbver 
name buf namelen 	buf expiretime 
alt name 	rdb 
file name buf 	key val 
file name 	size expires 
buf buf fdata 	size auxkey 
win time 	auxval cksum 
file name times 	expected exitcode 
mft aft 	bysignal 
attrs wfilename seconds 	latency exitcode 
wtemplate filename 	bysignal slaves 
hnsec filedes timep 	readlen slave 
result timep 	errorcode exitcode 
result pointer 	bysignal fds 
len wpointer arg 	clientids 
force quotes 	numfds childpid 
count count cmd 	start pipefds 
buf opt 	slave retval 
path envpath dir 	slave sockets 
path dir 	dirty msg 
cmd isexe exe 	len 
path cmd 	ids msglen 
path exe prog 	slave server 
len isexe 	log redis 
env name size 	check rdb 
free old 	exit rio 
environ size environ 	write 
alloc deltaenv 	rdb write 
wenvblk tmpenv wenvpos 	raw rio 
next pid 	read rio 
proc pinfo pinfo 	read rdb 
cmd argv 	write 
deltaenv dir 	raw rio 
prepend cmd fhin 	read rdb 
fhout fherr 	write raw 
args wcmd wdir 	rdb write 
wargs wenvblk 	raw rdb 
flags ret cons 	write 
quoted quoted 	raw htonl 
info cmd argv 	rdb write 
prepend cmd 	raw rio 
cmd argv deltaenv 	read rio 
dir fhin 	read rio 
fhout fherr pid 	read 
path prog 	ntohl rio 
interpr argv iprog 	read rio 
cmd argv 	read rio 
interpr path prog 	read rdb 
pid argc 	exit report 
argv status cmd 	corrupt 
argv pid 	rdb zmalloc 
status cmd 	memcpy create 
argv path prog 	create sdsfromlonglong 
pid sig 	strtoll strlen 
env name size 	memcmp rdb 
high mid 	encode 
cmp env name 	integer rdb 
size free 	write raw 
old name pos 	rdb save 
namevalue node 	len rdb 
service hints res 	save len 
sin res 	rdb 
salen host hostlen 	write raw 
serv servlen 	zmalloc lzf 
flags sin ent 	compress zfree 
ent ipv 	rdb save 
dll res node 	lzf blob 
service hints 	zfree 
res salen host 	rdb load 
hostlen serv 	len rdb 
servlen flags 	load len 
wsa initialized libraries 	zmalloc zmalloc 
name name 	sdsnewlen rio 
namelen host res 	read 
node service 	lzf decompress 
hints res salen 	zfree create 
host hostlen 	zfree zfree 
serv servlen flags 	sdsfree rdb 
domain type 	integer encoding 
protocol sockfd sockfd 	rdb 
sockfd sockfd 	write raw 
lvl optname optval 	rdb save 
optlen sockfd 	lzf rdb 
sockfd backlog sockfd 	save len 
sockfd err 	rdb write 
pold pnew attrs 	raw 
gle tries 	rdb encode 
wpold wpnew 	integer rdb 
attrsold uid user 	write raw 
name len 	server rdb 
timer timer timer 	save len 
interval one 	rdb 
shot sigint dummy 	write raw 
type zero 	rdb save 
atexit done sig 	server info 
sig handler 	sds encoded 
old sig path 	rdb save 
buf unixpath 	raw 
htmlpath shell execute 	sdslen rdb 
shell oldpath 	load len 
newpath create hard 	rdb load 
link woldpath 	integer rdb 
wnewpath pid status 	load lzf 
options ppinfo 	rdb 
info path ret 	exit report 
path pos 	corrupt rdb 
wcs utfs 	create create 
wcslen utflen wpos 	raw rio 
utf hex 	read decr 
utf wcs utflen 	count 
tmp crt 	zmalloc rio 
glob argc argv 	read zfree 
env glob 	rdb load 
size result buffer 	rdb load 
wcs len 	isnan isfinite 
maxlen argc buffer 	snprintf 
wenv wargv 	strlen rdb 
buf fgets strlen 	write raw 
getchar tolower 	rio read 
strncasecmp tolower strncasecmp 	rio read 
start vsnprintf 	sscanf rdb 
end mingw getenv 	save 
run command 	type rdb 
opt isatty fileno 	save type 
isatty fileno 	server panic 
read yes 	rdb save 
answer xutftowcs path 	type rdb 
wchmod wunlink 	save 
size file use 	type server 
error last 	panic rdb 
error sleep file 	save type 
use error 	rdb save 
last error ask 	type server 
yes possible 	panic 
wunlink wcscpy wcscat 	rdb save 
find first 	type rdb 
file last error 	save type 
wcscmp wcscmp 	server panic 
find next file 	server panic 
last error 	rdb 
find close find 	load type 
close xutftowcs 	rdb type 
path wrmdir size 	rdb save 
file use 	rdb save 
error last 	len quicklist 
error err win 	node 
posix last 	compressed quicklist 
error dir empty 	lzf rdb 
sleep file 	save lzf 
use error last 	blob rdb 
error ask 	save raw 
yes possible wrmdir 	server 
xutftowcs path 	panic dict 
wmkdir start arg 	iterator rdb 
end strcmp 	save len 
xutftowcs path wopen 	dict size 
file attributes 	dict next 
isatty fileno fgetc 	dict 
console ctrl 	key rdb 
handler fgetc last 	save dict 
error mingw 	release iterator 
console ctrl 	intset blob 
handler strcmp xutftowcs 	len rdb 
path xutftowcs 	save 
size wfopen strcmp 	raw server 
xutftowcs path 	panic ziplist 
xutftowcs size wfreopen 	blob len 
fflush write 	rdb save 
osfhandle file type 	raw dict 
xutftowcs path 	iterator 
waccess xutftowcs path 	rdb save 
wchdir xutftowcs 	len dict 
path wchmod time 	size dict 
filetime hnsec 	next dict 
wcslen dir sep 	key dict 
file attributes 	val 
last error xutftowcs 	rdb save 
path file 	rdb save 
attributes file attr 	dict release 
mode filetime 	iterator server 
time filetime 	panic ziplist 
time filetime time 	blob 
find first 	len rdb 
file readlink find 	save raw 
close last 	dict iterator 
error valid directory 	rdb save 
prefix lstat 	len dict 
strlen memcpy lstat 	size 
stat stat 	dict next 
osfhandle file type 	dict key 
fstati file 	dict val 
information handle file 	rdb save 
attr mode 	rdb save 
filetime time filetime 	dict 
time filetime 	release iterator 
time xutftowcs path 	server panic 
file attributes 	server panic 
file attributes wopen 	rdb save 
time filetime 	server info 
time filetime 	rdb 
system time file 	save type 
time file 	rdb save 
time osfhandle close 	millisecond time 
file attributes 	rdb save 
sleep xutftowcs path 	type rdb 
wmktemp xwcstoutf 	save 
strlen mktemp open 	rdb save 
system time 	rdb save 
file time filetime 	type rdb 
hnsec create 	save raw 
pipe err win 	rdb save 
posix last 	raw 
error open osfhandle 	rdb save 
hcast close 	aux field 
handle close handle 	strlen strlen 
open osfhandle 	rdb save 
hcast close close 	aux field 
handle memcpy 	strlen 
gmtime memcpy 	rdb save 
localtime wgetcwd size 	aux field 
xwcstoutf isspace 	str str 
xmalloc strlen strcasecmp 	rdb save 
open read 	aux field 
close strcspn strrchr 	str 
strrchr strchr 	rdb save 
mingw getenv xstrdup 	aux field 
strchr alloc 	str time 
xstrdup strlen free 	rdb save 
free free 	aux field 
snprintf access xstrdup 	str 
strlen access 	zmalloc used 
file attributes xstrdup 	memory mstime 
strlen strcasecmp 	snprintf rdb 
strchr strchr xstrdup 	write raw 
lookup prog 	rdb save 
alloc memcpy putenv 	info 
strlen alloc 	aux fields 
grow xutftowcs 	dict size 
free create file 	dict safe 
close handle 	iterator rdb 
memset winansi osfhandle 	save type 
winansi osfhandle 	rdb 
winansi osfhandle xutftowcs 	save len 
path xutftowcs 	dict size 
path strbuf init 	dict size 
quote arg 	dict size 
strbuf addstr free 	dict size 
quote arg 	rdb 
strbuf addch strbuf 	save type 
addstr free 	rdb save 
alloc mult xutftowcs 	len rdb 
strbuf release 	save len 
make environment block 	dict next 
memset create 	dict 
process free 	key dict 
free close handle 	val init 
enter critical 	expire rdb 
section xmalloc critical 	save key 
section mingw 	pair dict 
spawnve path split 	release 
path lookup 	iterator rdb 
parse interpreter path 	save type 
lookup mingw 	memrev ifbe 
spawnve free mingw 	rio write 
spawnve free 	dict release 
free path split 	iterator 
parse interpreter 	random hex 
path split path 	chars rio 
lookup alloc 	write rio 
memcpy mingw spawnv 	write rio 
waitpid exit 	write rdb 
free free free 	save 
path split 	rio rio 
shell exec 	write snprintf 
mingw spawnv waitpid 	getpid fopen 
exit path 	getcwd server 
split path lookup 	log strerror 
mingw execv 	rio 
free free path 	init file 
split open 	rdb save 
process terminate process 	rio fflush 
close handle 	fsync fileno 
err win posix 	fclose rename 
last error 	getcwd 
close handle open 	server log 
process close 	strerror unlink 
handle tolower tolower 	server log 
compareenv bsearchenv 	time server 
free strchr memmove 	log strerror 
memmove bsearchenv 	fclose 
strchr alloc grow 	unlink time 
putenv gethostbyname 	ustime fork 
wsa last 	close listening 
error xmalloc xstrdup 	sockets redis 
xcalloc htons 	proc title 
atoi free free 	rdb 
free gethostbyaddr 	save zmalloc 
snprintf snprintf inet 	dirty server 
ntoa getservbyport 	log exit 
snprintf snprintf ntohs 	child ustime 
wsa cleanup 	zmalloc used 
free library wsa 	memory 
startup makeword 	latency sample 
die wsa last 	needed server 
error load 	log strerror 
library proc address 	server log 
proc address 	time update 
proc address free 	dict 
library atexit 	resize policy 
ensure socket initialization 	snprintf unlink 
gethostname ensure 	rdb load 
socket initialization 	encoded encoding 
gethostbyname ipv freeaddrinfo 	rdb load 
ensure socket 	len 
initialization ipv getaddrinfo 	create quicklist 
ensure socket 	quicklist options 
initialization ipv getnameinfo 	rdb load 
ensure socket 	encoded decoded 
initialization wsa socket 	sdslen quicklist 
wsa last 	push 
error open osfhandle 	tail decr 
closesocket error 	count decr 
strerror osfhandle connect 	count rdb 
osfhandle bind 	load len 
osfhandle setsockopt osfhandle 	create dict 
shutdown osfhandle 	expand 
listen osfhandle accept 	create intset 
open osfhandle 	rdb load 
closesocket error 	encoded encoding 
strerror xutftowcs path 	representable intset 
xutftowcs path 	type convert 
wrename move file 	dict 
last error 	expand dict 
file attributes file 	decr count 
attributes wrmdir 	rdb load 
file attributes move 	len create 
file last 	zset rdb 
error file attributes 	load 
size sleep 	encoded encoding 
ask yes possible 	rdb load 
system info 	sds encoded 
user name wait 	sdslen sdslen 
single mingw 	zsl insert 
create beginthreadex wait 	dict 
single error 	incr count 
error last error 	zset length 
close handle 	zset convert 
close handle 	rdb load 
timeval timeval stop 	len create 
timer timeval 	hash 
timeval timeval atexit 	hash type 
start timer 	convert rdb 
signal isatty fputs 	load server 
exit timer 	sds encoded 
exit sigint strlcpy 	rdb load 
die make 	server 
backslash path load 	sds encoded 
library die 	ziplist push 
proc address die 	sdslen ziplist 
hcast shell 	push sdslen 
execute free library 	sdslen sdslen 
die xutftowcs 	decr 
path xutftowcs path 	count decr 
proc address 	count hash 
module handle create 	type convert 
hard link 	decr count 
err win 	decr count 
posix last error 	rdb 
open process 	load encoded 
wait single close 	rdb load 
handle wait 	encoded encoding 
single close handle 	encoding dict 
exit code 	rdb exit 
process enter critical 	report 
section close 	corrupt rdb 
handle free critical 	server rdb 
section close 	load len 
handle close handle 	create quicklist 
dos drive 	quicklist options 
prefix skip dos 	rdb 
drive prefix 	load quicklist 
dir sep dir 	append ziplist 
sep strpbrk 	rdb load 
dir sep dir 	create ziplist 
sep wide 	zipmap rewind 
multi getenv 	zipmap 
getenv getenv setenv 	next ziplist 
getenv getenv 	push ziplist 
setenv fputs exit 	push zfree 
malloc die 	hash type 
startup xwcstoutf memcpy 	length hash 
malloc startup 	type 
wgetmainargs die startup 	convert list 
wcslen max 	type convert 
wcslen max wcslen 	intset len 
alloc malloc 	type convert 
startup malloc startup 	zset length 
wcstoutfdup startup 	zset 
wcstoutfdup startup wcstoutfdup 	convert hash 
startup free 	type length 
qsort setup windows 	hash type 
environment initialize 	convert rdb 
critical section 	exit report 
setmode fileno setmode 	corrupt 
fileno setmode 	rdb rdb 
fileno winansi init 	exit report 
version memset 	corrupt rdb 
xsnprintf xsnprintf xsnprintf 	time fstat 
newline flush 	fileno zmalloc 
buffer full line 	used 
could read 	memory zmalloc 
answer find answer 	used memory 
understand read 	rio update 
files cannot removed 	checksum update 
process source 	cached time 
destination file open 	replication 
wrong moment 	send newline 
retry order give 	master loading 
process higher 	progress process 
chance complete operation 	events blocked 
give time 	mstime fopen 
slice retry 	rio 
sleep bit process 	init file 
source destination 	rio read 
file open wrong 	memcmp fclose 
moment retry 	server log 
order give process 	atoi fclose 
higher chance 	server 
complete operation give 	log start 
time slice 	loading rdb 
retry sleep bit 	load type 
ctrl pressed 	rdb load 
simulate sigint retry 	time rdb 
write used 	load 
behind scenes stdio 	type rdb 
output functions 	load millisecond 
since git code 	time rdb 
check errors 	load type 
stdio write operation 	rdb load 
happen write 	len 
called later 	server log 
stdio function even 	exit rdb 
earlier write 	load len 
call failed pipe 	rdb load 
whose readable 	len dict 
end closed first 	expand 
call write 	dict expand 
reports epipe windows 	rdb load 
subsequent write 	rdb load 
calls report einval 	server log 
impossible notice 	server log 
whether fflush invocation 	decr 
triggered therefore 	count decr 
einval errors whole 	count rdb 
sale check 	load rdb 
pipe supported msvcrt 	load decr 
version unit 	count decr 
filetime nanoseconds since 	count 
january utc 	expire decr 
returns nanoseconds 	count rio 
hekto nanoseconds since 	read memrev 
epoch windows 	ifbe server 
unix epoch conversion 	log server 
verifies safe 	log 
create leading directories 	rdb exit 
would succeed 	report corrupt 
implies parent directory 	rdb fclose 
exists keep 	stop loading 
lstat code separate 	server 
function avoid 	log rdb 
recursion path ends 	exit report 
slash stat 	corrupt rdb 
fail enoent strip 	server log 
trailing slashes 	time server 
stat follow act 	log 
like stat 	server log 
report link target 	latency start 
otherwise report 	monitor rdb 
link used 	temp file 
git fallthru provide 	latency end 
lstat fstat 	monitor 
functions since provided 	latency sample 
lstat fstat 	needed time 
functions slow stat 	update slaves 
functions tailored 	waiting bgsave 
git usage read 	server log 
fast meant 	server 
complete note git 	log server 
stat redirected 	log zmalloc 
mingw lstat since 	read zrealloc 
windows doesn 	read close 
really handle symlinks 	close list 
well file 	rewind 
name ended windows 	list next 
returned enoent 	server log 
without trailing 	replication slave 
slashes direct non 	name strerror 
file handles 	free client 
fstat used git 	server 
must write 	log replication 
permission ignore errors 	slave name 
open report 	anet non 
ignore errors creates 	block anet 
non inheritable 	send timeout 
handles gmtime msvcrt 	zfree 
dll safe 	update slaves 
reentrant localtime msvcrt 	waiting bgsave 
dll safe 	background save 
reentrant see http 	done handler 
msdn microsoft 	disk background 
library ykft aspx 	save 
parsing command 	done handler 
line arguments count 	socket server 
chars quote 	panic pipe 
insert necessary 	zmalloc list 
even exe least 	length zmalloc 
error strip 	list 
options splits path 	length list 
parts earlier 	rewind list 
catches series exe 	next replication 
means want 	setup slave 
detect exe files 	full resync 
scripts extension 	psync 
determines absolute path 	initial offset 
cmd split 	anet block 
path path cmd 	anet send 
contains slash 	timeout ustime 
backslash lookup performed 	fork rio 
used number 	init 
elements environ including 	fdset zfree 
terminating allocated 	close listening 
size environ bytes 	sockets redis 
create environment 	proc title 
block suitable 	rdb save 
create process merges 	rio 
current process 	eof mark 
environment supplied environment 	rio flush 
changes copy 	zmalloc dirty 
environment leaving space 	server log 
changes merge 	zmalloc write 
supplied environment changes 	zfree 
temporary environment 	zfree exit 
create environment block 	child ustime 
temporary environment 	zmalloc used 
terminator determine whether 	memory latency 
associated console 	sample needed 
console associated process 	server 
since child 	log strerror 
console process windows 	list rewind 
would normally 	list next 
create console window 	close close 
since redirecting 	server log 
std streams 	time 
need console necessary 	update dict 
use detached 	resize policy 
process instead create 	zfree zfree 
window make 	reply error 
ssh recognize console 	rdb save 
already console 	reply 
specified detached process 	reply reply 
windows would 	error reply 
disassociate child console 	error rdb 
create window 	save background 
figure concatenate argv 	reply status 
quoting args 	reply 
process human readable 	copyright salvatore 
process want 	sanfilippo antirez 
present log error 	gmail dot 
messages handle 	rights reserved 
useful purpose 	redistribution use 
cannot close either 	source 
possible turn 	binary forms 
process process handle 	without modification 
process terminated 	permitted provided 
keep handle list 	following conditions 
waitpid full 	met redistributions 
path script file 	source 
indicate tried 	code must 
failed check git 	retain copyright 
command shell 	notice list 
script compare environment 	conditions following 
entries key 	disclaimer redistributions 
stopping found complement 	binary 
insert position 	form must 
name contains sets 	reproduce copyright 
variable otherwise 	notice list 
unsets size includes 	conditions following 
terminating env 	disclaimer documentation 
must room 	materials 
size entries insert 	provided distribution 
returns size 	neither name 
optionally frees removed 	redis names 
entries optionally 	contributors may 
free removed replaced 	used endorse 
entry key 	promote 
specified insert replace 	products derived 
entry otherwise 	software without 
key existing entry 	specific prior 
note isn 	written permission 
complete replacement getaddrinfo 	software provided 
assumes service 	copyright 
contains numerical port 	holders contributors 
simple search 	express implied 
gethostbyname returns one 	warranties including 
host one 	limited implied 
found note getaddrinfo 	warranties merchantability 
supposed allow 	fitness 
service looked 	particular purpose 
getservbyname currently implemented 	disclaimed shall 
gai strerror 	copyright owner 
function tcpip header 	contributors liable 
need load 	direct indirect 
one dynamically wsa 	incidental 
last error 	special exemplary 
values regular bsd 	consequential damages 
error codes 	including limited 
biased wsabaseerr however 	procurement substitute 
strerror know 	goods services 
networking specific errors 	loss 
values beginning 	use data 
therefore choose biased 	profits business 
error code 	interruption however 
errno someone looks 	caused theory 
code somewhere 	liability whether 
least number usually 	contract 
listed convert 	strict liability 
file descriptor 	tort including 
convert file descriptor 	negligence otherwise 
rename first 	arising way 
errno right move 	use software 
file cannot 	even 
overwrite existing files 	advised possibility 
todo translate 	damage lzf 
errors revert file 	compression library 
attributes failure 	load type 
process source destination 	rdb format 
file open 	one 
wrong moment retry 	integer function 
order give 	used load 
process higher chance 	types also 
complete operation 	special types 
give time slice 	like end 
retry sleep 	file 
bit note 	type expire 
doesn actual pagesize 	type forth 
allocation granularity 	saves encoded 
future windows specific 	length first 
git code 	two bits 
needs real getpagesize 	first 
function need 	used hold 
find another solution 	encoding type 
timer works 	see rdb 
like ticktack trivial 	definitions information 
routine time 	types encoding 
waits receive signal 	save 
terminate main 	bit len 
tells terminate setting 	save bit 
timer signalled 	len save 
state ticktack interrupts 	bit len 
wait state 	load encoded 
timer interval length 	length 
call signal 	isencoded argument 
handler tell 	length actually 
terminate see msdn 	length encoding 
documentation referring 	type see 
result codes unc 	rdb enc 
paths skip 	definitions 
server name error 	rdb information 
malformed unc 	read bit 
path reserve space 	encoding type 
ascii utf 	read bit 
encoding utf encoding 	len read 
ffff utf 	bit 
convert udcxx surrogate 	len read 
pair invalid 	bit len 
utf printable unicode 	encodes argument 
convert invalid 	integer fits 
utf non printable 	supported ranges 
unicode convert 	encoded 
hex windows tmp 	types function 
temp convert 	successfully encodes 
dir separators 	integer representation 
forward slashes help 	stored buffer 
shell commands 	pointer enc 
called git executable 	length 
mistaking dir 	returned otherwise 
separators escape characters 	returned loads 
simulate term 	integer encoded 
enable color see 	specified encoding 
color disable 	type enctype 
msvcrt command line 	returned 
wildcard expansion 	changes according 
getmainargs called mingw 	flags see 
startup code 	rdb generinc 
see init mingw 	load info 
runtime wide 	anti warning 
arguments environment determine 	objects 
size argv 	form without 
environ conversion buffer 	space range 
nedmalloc free 	values fit 
crt memory 	bit encoded 
allocate resizable environment 	integers save 
list note 	space 
xmalloc xmemdupz etc 	check possible 
call getenv 	encode number 
cannot use initializing 	number converted 
environment allocate 	back identical 
buffer wchar encodes 	possible encode 
max utf 	integer 
bytes convert command 	data compressed 
line arguments 	save disk 
environment utf sort 	require least 
environment log 	four bytes 
getenv putenv fix 	compression worth 
windows specific 	load 
environment settings initialize 	lzf compressed 
critical section 	rdb format 
waitpid pinfo list 	returned changes 
file mode 	according flags 
file modes 	info check 
stdin err initialize 	rdb 
unicode console 	load function 
assuming variants mingw.h 	allocate target 
name gecos 	according uncompressed 
dir handler flags 	size load 
interval sysname 	compressed representation 
nodename release version 	uncompress 
machine path 	target save 
buf bufsiz oldpath 	len data 
newpath fildes 	disk representation 
mode seconds name 	integer save 
cmd signum 	special form 
oldset pid path 	integer 
mode pid 	encoding lzf 
status options pid 	compression bytes 
sig ssl 	unable compress 
ssl ssl 	even aaaaaaaaaaaaaaaaaa 
filedes seconds timep 	skip means 
result timep 	data 
result uid type 	compressed save 
sig oldpath 	old way 
newpath buf pathname 	store verbatim 
path filename 	save either 
oflags stream filename 	encoded encode 
otype filename 	like 
otype stream stream 	rdb save 
buf len 	raw handle 
filename mode dirname 	encoded objects 
filename mode 	avoid decode 
pointer len name 	encode already 
namevalue host 	integer 
namelen host res 	encoded load 
node service 	rdb file 
hints res salen 	according flags 
host hostlen 	rdb load 
serv servlen 	none flags 
flags domain type 	load 
protocol sockfd 	rdb unencoded 
sockfd sockfd lvl 	rdb load 
optname optval 	enc returned 
optlen sockfd sockfd 	type redis 
backlog sockfd 	encode special 
rlim cur resource 	way 
rlp file 	memory efficient 
name buf file 	flag passed 
name buf 	function longer 
buf file name 	guarantees obj 
times cmd 	ptr sds 
argv env dir 	rdb 
fhin fhout 	load plain 
fherr cmd argv 	plain allocated 
cmd argv 	zmalloc instead 
sig handler sig 	redis save 
path path 	doubles saved 
ret path 	prefixed 
path dir wcs 	bit integer 
utf wcslen 	specifying length 
utflen wcs utf 	representation bit 
wcslen wcs 	integer special 
utf result utf 	values order 
wcs utflen 	specify 
pinfo winerr commit 	following conditions 
getpid getpid 	number inf 
ssl osfhandle ssl 	inf check 
rfd osfhandle 	safe range 
ssl wfd osfhandle 	casted assuming 
ntohl dir 	bit 
sep xutftowcsn xutftowcsn 	also assuming 
min reports 	implementations around 
flockfile actually things 	precision bit 
available header 	assumptions test 
files symbolic link 	inside interval 
sanitize preprocessor 	casting 
polluted windows 	safe two 
headers defining macros 	castings make 
collide git 	sure part 
local versions winuser 	zero use 
trivial stubs 	integer printing 
bash cannot reliably 	function 
detect negative 	much faster 
codes failure simple 	information serialization 
adaptors implementations 	check rdb 
missing functions defined 	save save 
min libgcc 	type avoid 
replacements existing functions 	warning 
use mingw 	use rdb 
specific stat lstat 	load type 
fstat implementations 	load type 
windows use stat 	rdb format 
bit size 	returns type 
ansi emulation 	specifically 
wrappers git specific 	valid type 
compatibility converts 	save redis 
utf encoded utf 	returns error 
support repositories 	number bytes 
legacy encoded file 	written success 
names invalid 	save 
utf bytes xff 	save list 
converted corresponding 	save save 
printable unicode chars 	sorted save 
invalid utf 	hash length 
bytes would make 	disk saved 
non printable 	rdb 
unicode converted hex 	save function 
code lead 	currently use 
bytes followed appropriate 	trick length 
number trail 	little changes 
bytes encodings encodings 	code future 
ffff detected 	could 
invalid utf 	faster solution 
maximum space requirement 	save key 
target buffer 	pair expire 
two wide chars 	time type 
per utf 	key error 
strlen utf wchar 	returned 
maximum space 	success key 
needed entire input 	actually saved 
consists invalid 	returned otherwise 
utf bytes range 	returned key 
per following 	already expired 
table utf utf 	save 
code point 	expire time 
utf sequence bytes 	key already 
words ratio 	expired skip 
ffff ffff invalid 	save type 
invalid encoded 	key save 
utf surrogate pair 	aux 
encoded two 	field wrapper 
hex digits 	rdb save 
note utf encoding 	aux field 
scheme extended 	used key 
even indefinite sequences 	val length 
largest valid 	obtained 
code point ffff 	strlen wrapper 
encodes utf 	strlen key 
bytes parameters wcs 	integer type 
wide target 	range save 
buffer utf convert 	aux fields 
wcslen size 	information 
target buffer wchar 	rdb generated 
utflen size 	fields state 
convert terminated returns 	rdb created 
length converted 	produces dump 
wcslen wcs failure 	database rdb 
errors einval 	format 
one input parameters 	sending specified 
invalid erange 	redis channel 
output buffer 	success returned 
small simplified variant 	otherwise err 
xutftowcsn assumes 	returned part 
input terminated simplified 	output 
file system 	output missing 
specific variant xutftowcsn 	errors function 
assumes output 	returns err 
buffer size max 	error integer 
path wide 	pointed error 
chars input terminated 	errno 
fails enametoolong 	error write 
input converts utf 	opcode write 
encoded utf 	resize opcode 
maximum space requirement 	trim size 
target buffer 	max currently 
three utf chars 	largest 
per wide 	type able 
wcslen wcs 	represent rdb 
maximum space needed 	sizes however 
entire input 	limit actual 
consists utf words 	size load 
range xffff 	since 
uffff modulo surrogate 	sizes hints 
pairs per 	resize hash 
following table utf 	tables iterate 
utf code 	writing every 
point utf sequence 	entry release 
words bytes 	error 
ratio ffff ffff 	eof opcode 
ffff dbff 	crc checksum 
dfff note invalid 	zero checksum 
code points 	computation disabled 
ffff cannot represented 	loading code 
utf parameters 	skips 
utf target buffer 	check wrapper 
wcs wide 	rdb save 
convert utflen 	rio additionally 
size target buffer 	adds prefix 
returns length 	suffix 
converted failure errors 	generated rdb 
einval one 	dump prefix 
input parameters invalid 	eof bytes 
erange output 	unguessable hex 
buffer small critical 	suffix bytes 
section used 	hex 
implementation spawn functions 	announced prefix 
mingw spawnv 	way processes 
waitpid intialised replacement 	receiving payload 
main macro 	understand ends 
replacement main adds 	without processing 
win specific 	content 
initialization used pthread 	write error 
api implementation 	error already 
windows mkdir.c dir 	rdb save 
mode retval 	rio call 
tmp dir 	save disk 
len strlen strdup 	err 
mkdir free 	error success 
platforms deal trailing 	current working 
mkdtemp.c mktemp 	dir path 
mkdir mktag.c sha 	error messages 
expected type 	make sure 
ret size buffer 	data 
repl buffer 	remain output 
size typelen type 	buffers use 
sha type 	rename make 
line tag line 	sure file 
tagger line 	changed atomically 
len argc argv 	generate 
prefix buf 	file child 
result sha read 	parent per 
sha file 	second unreached 
lookup replace type 	load redis 
check sha 	specified type 
signature free 	specified 
error memcmp error 	file success 
sha hex 	newly allocated 
error memcmp error 	returned otherwise 
strchr error 	read read 
uintmax memcmp error 	list load 
uintmax strlen 	every 
error uintmax memcpy 	single element 
verify error 	list read 
sha hex error 	list use 
uintmax memcmp 	regular many 
error uintmax strstr 	entries faster 
strstr strpbrk 	expand 
strpbrk error uintmax 	dict right 
error uintmax 	size asap 
strspn error uintmax 	order avoid 
error uintmax 	rehashing load 
strspn atoi error 	every single 
uintmax error 	element 
uintmax usage 	list fetch 
strbuf read die 	integer element 
errno verify 	also called 
tag die write 	converted regular 
sha file 	hash table 
die strbuf release 	encoded 
sha hex 	read list 
signature file simple 	load every 
format four 	single element 
lines sha type 	list care 
tag tagname 	integer encoded 
tagger committer followed 	added 
blank line 	skiplist convert 
free form tag 	loading since 
message signature 	sorted sets 
block git doesn 	stored ordered 
care verified 	many entries 
gpg similar 	use 
first four lines 	hash table 
guaranteed least 	load every 
bytes sha bytes 	field ziplist 
type tag 	load raw 
bytes shortest possible 	pair ziplist 
type line 	convert 
tag bytes shortest 	hash table 
single character 	size threshold 
tag line tagger 	exceeded load 
bytes shortest 	remaining fields 
possible tagger line 	values hash 
refuse tag 	table 
something verify verify 	load encoded 
line verify 	pair hash 
type line verify 	table pairs 
tag line 	read obj 
actual type verify 	type fix 
matches verify 	encoding 
tag name 	make sure 
allow control characters 	convert encoded 
spaces verify 	data type 
tagger line check 	type accordingly 
correct form 	current configuration 
name email followed 	many 
line angle 	elements encoded 
brackets within name 	data type 
email address 	note check 
fields spaces within 	length max 
email address 	element size 
field check author 	scan 
name least 	eventually everything 
one character space 	converted convert 
acceptable timestamp 	ziplist encoded 
digits followed space 	hash must 
timezone digits 	deprecated loading 
hhmm max verify 	dumps 
blank line 	created redis 
separating header 	gets deprecated 
body actual stuff 	mark loading 
afterwards care 	state setup 
verify basic sanity 	fields needed 
needs start 	provide 
sha ntype ntagger 	loading stats 
mktree.c mode 	load refresh 
sha len name 	loading progress 
alloc used 	info loading 
mode sha path 	finished track 
ent len 	loading 
sha buf size 	progress order 
ent mktree 	serve client 
usage buf len 	time time 
nul term 	needed calculate 
line allow missing 	rdb checksum 
ptr ntr 	take 
mode path sha 	non trivial 
prefix sha 	amount time 
nul term 	load update 
line allow missing 	cached time 
batch mode 	since used 
got eof getline 	create 
option strlen 	update last 
strchr die flex 	interaction time 
alloc mem 	clients important 
hashcpy alloc grow 	things read 
name compare 	type handle 
qsort strbuf init 	special 
strbuf addf 	types expiretime 
strbuf write sha 	load expire 
file strbuf 	associated next 
release strtoul die 	key load 
strchr sha 	note loading 
hex die isgitlink 	expire 
unquote style 	need load 
die strbuf 	actual type 
detach type type 	read time 
die sha 	need read 
info die sha 	type expiretime 
hex die 	opcode 
sha hex append 	specifies time 
parse options 	seconds convert 
getline die mktree 	milliseconds expiretime 
line write 	milliseconds precision 
puts sha hex 	expire times 
fflush strbuf 	introduced 
release exit git 	rdb like 
stupid content 	expiretime precision 
tracker copyright junio 	read time 
hamano type 	need read 
derived mode type 	type eof 
derived sha 	end 
read non recursive 	file exit 
output format 	main loop 
mode type 	selectdb specified 
sha tab name 	database read 
type perfectly 	type resizedb 
normal commit submodule 	hint 
beginning sha 	size keys 
beginning name type 	currently selected 
redundantly derivable 	data order 
three ways agree 	avoid useless 
check type 	rehashing read 
identified sha problem 	type 
missing objects 	aux fields 
presumed right type 	use state 
exists wrong 	rdb backward 
type problem regardless 	compatible implementations 
allow missing 	rdb loading 
entry never correct 	requierd 
empty lines 	skip aux 
denote boundaries batch 	fields understand 
mode execution 	aux field 
gets last 	composed two 
entry terminated line 	key fields 
line made 	name 
optional consistent original 	staring considered 
non batch 	information fields 
behaviour mktree skip 	logged startup 
creating empty 	log level 
reset entry buffer 	notice ignore 
use batch 	fields 
mode mmap.c start 	understand aux 
length prot 	field contract 
flags offset count 	read type 
start length 	read key 
die xmalloc xpread 	read check 
memset free 	key 
free msvc.c msvc.h 	already expired 
size sisz 	function used 
strlen strlen strnicmp 	loading rdb 
porting function 	file disk 
mv.c builtin 	either startup 
usage prefix pathspec 	rdb 
count flags 	received master 
result length copy 	latter master 
path len 	responsible key 
slash file src 	expiry would 
first submodule 	expire keys 
gitfile submodule dotgit 	snapshot 
src length 	taken master 
first last src 	may reflected 
slash first 	slave hash 
last len slash 	table expire 
path argc 	time needed 
argv prefix gitmodules 	verify 
modified ignore 	checksum rdb 
errors builtin options 	version unexpected 
source destination 	end file 
dest path 	handled fatal 
submodule gitfile src 	exit avoid 
dst dst 	warning 
pos alloc memcpy 	background saving 
strlen dir 	child bgsave 
sep xmemdupz xstrdup 	terminated work 
basename free 	handle function 
pathspec strlen xmalloc 	covers actual 
memcpy isgitlink 	bgsav 
die staging gitmodules 	sigusr whitelisted 
die strbuf 	way kill 
addf read gitfile 	child without 
xstrdup strbuf 	tirggering error 
release slash cache 	conditon possibly 
name pos 	slaves 
die strncmp free 	waiting bgsave 
gitmodules config 	order served 
git config parse 	first stage 
options usage 	sync bulk 
options hold 	transfer dump 
locked index read 	rdb 
cache die 	background saving 
copy pathspec xcalloc 	child bgsave 
copy pathspec 	terminated work 
xcalloc copy pathspec 	handle function 
lstat isdir 	covers rdb 
lstat strncmp die 	salves 
memmove memmove 	socket transfers 
memmove memmove rename 	diskless replication 
die errno 	child returns 
connect work git 	exit code 
dir update 	read slave 
path gitmodules cache 	client 
name pos 	associated status 
strlen rename cache 	code terminate 
entry stage 	slaves error 
updated gitmodules write 	state process 
locked index 	returned error 
die git 	consider 
builtin command copyright 	list slaves 
johannes schindelin 	emtpy special 
keep trailing slash 	normal code 
needed git 	path make 
file dir error 	space count 
special normalized 	make 
checking last first 	space enough 
files overwrite 	elements specified 
check source destination 	first element 
name-hash.c ent 	replication process 
parent namelen name 	slaves correctly 
name istate 	received 
name namelen key 	full payload 
istate namelen 	others terminated 
dir istate dir 	search slave 
istate dir 	reply order 
parent istate istate 	slave replication 
istate istate 	process 
name len 	need find 
name len name 	list must 
namelen icase 	error code 
len istate name 	means success 
namelen dir 	found slaves 
istate name start 	list 
ptr ptr 	restore socket 
dir istate name 	non blocking 
namelen icase 	background rdb 
istate strncasecmp hashmap 	saving transfer 
entry init 	terminates call 
memihash hashmap dir 	right 
sep find 	handler spawn 
dir entry flex 	rdb child 
alloc mem 	writes rdb 
hashmap entry init 	sockets slaves 
memihash hashmap 	currently slave 
hash dir entry 	state 
hash dir 	wait bgsave 
entry namelen 	start state 
hash dir entry 	fork create 
namelen hashmap 	pipe used 
free hashmap entry 	order send 
init memihash 	back 
namelen hashmap dir 	parent slaves 
entry hashmap 	successfully received 
init hashmap init 	writes collect 
hash index 	file descriptors 
entry hash index 	slaves want 
entry hashmap 	transfer 
dir entry toupper 	rdb wait 
toupper namelen 	bgsave start 
memcmp slow name 	state also 
lazy init 	allocate corresponding 
name hash find 	client useful 
dir entry 	child 
lazy init 	process order 
name hash find 	build report 
dir entry 	sent via 
memcpy lazy init 	unix pipe 
name hash 	sent parent 
hashmap hash memihash 	put 
name hashmap 	socket non 
next hashmap free 	blocking mode 
hashmap free 	simplify rdb 
name hash hashing 	transfer restore 
names index 	children returns 
state copyright linus 	since 
torvalds directory 	duped socket 
component hash quick 	share nonblock 
lookup git 	attribute parent 
status directory components 	create child 
stored without 	process child 
closing slash despite 	returning 
submodules directory 	least one 
never reach 	slave served 
point stored index 	rdb file 
state name 	expected need 
hash ordinary cache 	send report 
entries length 	parent 
parent directory lookup 	via pipe 
existing entry 	format message 
directory found create 	len slave 
hash table 	slave error 
recursively missing parent 	len slave 
directories reference 	slave 
directory entry parents 	errors integers 
release reference 	basically reply 
directory entry parent 	composed bits 
directory name 	len field 
hash find exact 	plus additional 
entry pointer 	bit 
equality index file 	integers entry 
exists find 	total len 
entries matching 	entries represents 
hash code decide 	slave client 
whether entry 	master match 
matches name always 	report 
exact compare 	specific slave 
even want ignoring 	error replication 
comparison quick 	process terminated 
exact one first 	success error 
common name-rev.c 	code error 
cutoff commit tip 	occurred 
name generation 	write message 
distance deref name 	parent good 
parents parent 	slaves unable 
number len name 	transfer message 
path filter 	parent exit 
subpath refname shorten 	error 
unambiguous tags 	parent abort 
name filter sha 	replication process 
refname alloc 	childre waiting 
sorted sha 	parent per 
refname shorten unambiguous 	second undo 
path oid 	state 
flags data data 	change caller 
abbreviate output 	perform cleanup 
deref commit table 	slaves bgsave 
table found 	start state 
buffer len obj 	early call 
caller name 	replication 
always allow undefined 	setup slave 
name name 	full resync 
oid name rev 	turned bgsave 
usage data 	end unreached 
forty start sha 	rdb.h rdb 
name len 	type 
argc argv prefix 	rdb rdb 
revs peel 	rdb rdb 
tag data 	len rdb 
opts sha commit 	isencoded rdb 
peeled buffer 	rdb filename 
max obj parse 	filename 
commit xstrfmt 	childpid filename 
die xmalloc strip 	rdb type 
suffix xstrfmt 	rdb exitcode 
xstrfmt name rev 	bysignal rdb 
name rev 	key val 
wildmatch strchr shorten 	expiretime 
unambiguous starts 	rdb copyright 
starts name abbrev 	salvatore sanfilippo 
alloc grow 	antirez gmail 
hashcpy xstrdup hashcmp 	dot rights 
parse starts 	reserved redistribution 
subpath matches tip 	use 
table parse 	source binary 
name abbrev name 	forms without 
rev xstrdup 	modification permitted 
qsort sha 	provided following 
pos exact match 	conditions met 
strlen strcmp 	redistributions 
snprintf oid hex 	source code 
rev name 	must retain 
find unique abbrev 	copyright notice 
die oid 	list conditions 
hex ishex ishex 	following disclaimer 
sha lookup 	redistributions 
rev name fwrite 	binary form 
git config 	must reproduce 
parse options error 	copyright notice 
usage options 	list conditions 
sha parse deref 	following disclaimer 
tag feof 	documentation 
fgets name rev 	materials provided 
line max 	distribution neither 
index indexed show 	name redis 
name show 	names contributors 
name one 	may used 
day many generations 	endorse 
maximally preferred 	promote products 
one merge traversal 	derived software 
match matched 	without specific 
fully matched subpath 	prior written 
broken repository 	permission 
returns buffer flush 	software provided 
hidden opt 	copyright holders 
nedmalloc.c idx ret 	contributors express 
nedalloc tls 	implied warranties 
last error alternative 	including limited 
malloc implementation 	implied 
multiple threads without 	warranties merchantability 
contention dlmalloc 	fitness particular 
niall douglas boost 	purpose disclaimed 
software license 	shall copyright 
version august permission 	owner contributors 
hereby granted 	liable 
free charge 	direct indirect 
person organization obtaining 	incidental special 
copy software 	exemplary consequential 
accompanying documentation covered 	damages including 
license software 	limited procurement 
use reproduce display 	substitute 
distribute execute 	goods services 
transmit software prepare 	loss use 
derivative works 	data profits 
software permit third 	business interruption 
parties software 	however caused 
furnished subject following 	theory 
copyright notices 	liability whether 
software entire statement 	contract strict 
including license 	liability tort 
grant restriction following 	including negligence 
disclaimer must 	otherwise arising 
included copies 	way 
software whole part 	use software 
derivative works 	even advised 
software unless copies 	possibility damage 
derivative works 	tbd include 
solely form machine 	necessary headers 
executable code 	current 
generated source language 	rdb version 
processor software 	format changes 
provided without warranty 	way longer 
kind express 	backward compatible 
implied including limited 	number gets 
warranties merchantability 	incremented 
fitness particular purpose 	defines related 
title non 	dump file 
infringement shall copyright 	format store 
holders anyone 	bits lengths 
distributing software liable 	keys requires 
damages liability 	lot 
whether contract 	space check 
tort otherwise arising 	significant bits 
connection software 	first interpreter 
use dealings software 	length two 
enable full 	msb len 
aliasing msvc pragma 	bits 
optimize define 	len byes 
fullsanitychecks need enable 	bits bits 
footers frees 	next bit 
right mspace dlmalloc 	integer full 
wants debug 	bit len 
either disable checking 	follow 
release builds 	means specially 
means spend much 	encoded follow 
time kernel 	six bits 
side define use 	number specify 
spin locks 	kind follows 
define disable checking 	see 
release builds 	rdb enc 
maximum concurrent 	defines lengths 
threads pool possible 	stored single 
maximum number 	keys may 
threadcaches allocated maximum 	values fit 
size allocated 	inside 
cache number cache 	length stored 
entries finer 	disk first 
grained bins topbitpos 	two bits 
threadcachemax number 	remaining two 
cache entries topbitpos 	bits specify 
threadcachemax point 	special 
free space cache 	encoding accordingly 
garbage collected 	following defines 
enable testing valgrind 	bit integer 
causes misoperation 	bit integer 
enable testing valgrind 	bit integer 
causes misoperation 	compressed 
fails someone tried 	fastlz dup 
free block 	types rdb 
twice keep 	types reason 
less bytes bit 	readability dealing 
systems bytes 	rdb types 
bit systems last 	memory 
mspace entry 	types note 
used much free 	adding rdb 
space stored 	type update 
cache max entries 	rdb type 
use cache 	types encoded 
unset negative use 	objects 
mspace directly 	note adding 
otherwise cache mspace 	rdb type 
entries pool 	update rdb 
come oldest end 	type test 
list tcsanitycheck 	type type 
tcbptr nedblksize tcsanitycheck 	special 
tcbptr list 	rdb opcodes 
exhausted disable calculate 	saved loaded 
best fit 	rdb save 
bin size 	type rdb 
finer grained bin 	load type 
fit match 	redis-benchmark.c 
close move bin 	hostip hostport 
necessary bump 	hostsocket numclients 
bin nedblksize blk 	liveclients requests 
malloc blk 	requests issued 
size acquire mymspace 	requests finished 
mutex removing 	keysize 
cache entries older 	datasize randomkeys 
age free 	randomkeys keyspacelen 
cache release mymspace 	keepalive pipeline 
mutex make 	start totlatency 
sure valid memory 	latency title 
block calculate 	clients 
best fit bin 	quiet csv 
size finer 	loop idlemode 
grained bin 	dbnum dbnumstr 
fit dlmalloc round 	tests auth 
round preserve 	privdata mask 
indexing free mem 	ust 
size threads 	mst next 
system pool allocate 	privdata mask 
system pool 	reply privdata 
screwed gets called 	mask ptr 
last used 	nwritten cmd 
mspace use strategy 	len 
run list 	buf len 
available mspaces looking 	curlat perc 
unlocked one 	reqpersec title 
fail create one 	cmd len 
exceed threads 	argc argv 
ready modify lists 	lastarg 
drat must 	exit status 
destroy really want 	loop client 
make sure 	data rps 
goes memory 	name buf 
careful breaking aliasing 	argc argv 
rules write 	data 
twice created mspace 	cmd len 
idx end 	title argv 
last one used 	gettimeofday gettimeofday 
mspace last 	file file 
used mspace returns 	redis free 
locked ready 	sdsfree 
use mspace locked 	zfree zfree 
mymspace mutex 	list search 
disable use cache 	key list 
use mspace 	del node 
use cache use 	free client 
mspace use 	file 
cache reallocs always 	file create 
happen mspace 	file random 
happened skip locking 	free client 
preferred mspace 	stop reset 
frees always 	client create 
happen mspace happened 	missing 
skip locking 	clients free 
preferred mspace use 	client unused 
mspace implementation 	unused unused 
purely libc version 	ustime redis 
avoid crash 	buffer read 
due allocation free 	exit 
different heaps 	redis reply 
nedmalloc.h mem size 	exit exit 
size mem 	free reply 
size mem alignment 	sdsrange client 
bytes parno 	done unused 
pad elemsno elemsize 	unused 
chunks elems 	unused free 
sizes chunks capacity 	client randomize 
threads mem 	client key 
size size mem 	ustime sdslen 
size mem 	write sdslen 
alignment bytes 	strerror 
parno pad elemsno 	free client 
elemsize chunks 	sdslen file 
elems sizes chunks 	create file 
nedalloc alternative 	zmalloc redis 
malloc implementation multiple 	connect non 
threads without 	block 
contention dlmalloc niall 	redis connect 
douglas boost 	unix non 
software license version 	block exit 
august permission 	sdsempty redis 
hereby granted free 	format command 
charge person 	sdscatlen 
organization obtaining copy 	free sdscatprintf 
software accompanying 	sdslen sdslen 
documentation covered license 	sdscatlen sdslen 
software use 	sdscatlen zmalloc 
reproduce display 	zmalloc strstr 
distribute execute transmit 	zrealloc 
software prepare 	create file 
derivative works software 	list node 
permit third 	tail create 
parties software furnished 	client usleep 
subject following 	qsort create 
copyright notices software 	client 
entire statement 	create missing 
including license grant 	clients mstime 
restriction following 	main mstime 
disclaimer must included 	show latency 
copies software 	report free 
whole part derivative 	clients 
works software 	strcmp atoi 
unless copies derivative 	strcmp atoi 
works solely 	strcmp atoi 
form machine executable 	strcmp strdup 
code generated 	strcmp atoi 
source language 	strcmp 
processor software provided 	strdup strcmp 
without warranty 	strdup strcmp 
kind express implied 	atoi strcmp 
including limited 	atoi strcmp 
warranties merchantability fitness 	atoi strcmp 
particular purpose 	strcmp 
title non infringement 	strcmp strcmp 
shall copyright 	strcmp sdsnew 
holders anyone distributing 	sdscat sdscat 
software liable 	sdstolower strcmp 
damages liability whether 	atoi sdsfromlonglong 
contract tort 	strcmp 
otherwise arising connection 	exit unused 
software use 	unused unused 
dealings software see 	exit fflush 
malloc function 	mstime fflush 
replace system allocator 	strlen memcpy 
causes nedalloc 	strstr 
functions called 	srandom time 
malloc free etc 	signal signal 
instead nedmalloc 	create loop 
nedfree etc may 	create time 
may want 	list create 
ned prevents functions 	parse 
defined nedalloc 	options zmalloc 
uses instead extspec 	create client 
defined dllexport 	create missing 
attribute visibility whatever 	clients main 
like defaults 	sdsnew sdscatlen 
use locks want 	sdscatlen 
define mlock 	strlen redis 
initial acquire release 	format command 
locked initializer 	argv benchmark 
size functions gets 	free zmalloc 
usable size 	memset test 
allocated block note 	selected 
always bigger 	test selected 
asked due 	benchmark test 
rounding etc pool 	selected test 
functions creates 	selected redis 
memory pool use 	format command 
nedp functions 	benchmark 
capacity much allocate 	free test 
immediately know 	selected redis 
allocating lot memory 	format command 
soon zero 	benchmark free 
threads specifies many 	test selected 
threads normally 	redis 
accessing pool concurrently 	format command 
setting zero 	benchmark free 
means demand careful 	test selected 
rapidly consume 	redis format 
system resources bursts 	command benchmark 
concurrent threads 	free 
use pool 	test selected 
destroys memory pool 	redis format 
previously created 	command benchmark 
nedcreatepool sets associated 	free test 
pool retrieve 	selected redis 
passing memory block 	format 
allocated pool 	command benchmark 
gets previously nedpsetvalue 	free test 
zero memory 	selected redis 
unknown optionally also 	format command 
retrieve pool 	benchmark free 
disables cache calling 	test 
returning existing 	selected redis 
cache data central 	format command 
pool notes-cache.c 	benchmark free 
validity sha commit 	test selected 
pretty ctx 	redis format 
msg ret name 	command 
validity flags 	benchmark free 
sha commit 	test selected 
sha key sha 	redis format 
outsize sha 	command benchmark 
size key sha 	free test 
data size 	selected 
sha read lookup 	test selected 
commit reference 	test selected 
gently memset format 	test selected 
commit message 	test selected 
strbuf trim strcmp 	redis format 
strbuf release 	command 
memset xstrdup strbuf 	benchmark free 
addf notes 	test selected 
cache match validity 	test selected 
init notes 	redis format 
strbuf release write 	command benchmark 
notes commit 	free 
strlen update note 	test selected 
read sha 	test selected 
file write 	redis format 
sha file note 	command benchmark 
notes-cache.h validity 	free test 
name validity sha 	selected 
outsize sha 	test selected 
data size notes 	redis format 
cache notes-merge.c 	command benchmark 
obj local remote 	free test 
path sha 	selected test 
hex sha sha 	selected 
list len 	redis format 
obj insert occupied 	command benchmark 
last index 	free test 
cmp uninitialized remote 	selected redis 
num changes 	format command 
opt changes len 	argv 
occupied obj 	benchmark free 
changes len local 	redis benchmark 
opt match 	utility copyright 
obj obj 	salvatore sanfilippo 
buf size path 	antirez gmail 
ret obj 	dot 
note size buf 	rights reserved 
result buf 	redistribution use 
local remote status 	source binary 
lref rref 	forms without 
reason changes num 	modification permitted 
changes conflicts 	provided 
local remote changes 	following conditions 
num changes 	met redistributions 
conflicts local result 	source code 
sha local 	must retain 
sha remote sha 	copyright notice 
local remote 	list 
bases sha sha 	conditions following 
result parents 	disclaimer redistributions 
commit result sha 	binary form 
dir path 	must reproduce 
buffer msg 	copyright notice 
baselen obj sha 	list 
blob sha 	conditions following 
buf ret memset 	disclaimer documentation 
strbuf init 	materials provided 
sha hex sha 	distribution neither 
sha sha 	name redis 
sha strcmp path 	names 
sha hashcmp 	contributors may 
memmove memset trace 	used endorse 
sha hex 	promote products 
sha hex diff 	derived software 
setup diff 	without specific 
opt diff setup 	prior 
done diff 	written permission 
sha diffcore std 	software provided 
xcalloc verify 	copyright holders 
notes filepair 	contributors express 
trace sha hex 	implied warranties 
sha hex 	including 
find notes merge 	limited implied 
pair pos 	warranties merchantability 
hashcmp sha sha 	fitness particular 
hashcpy sha 	purpose disclaimed 
sha hashcpy hashcpy 	shall copyright 
hashcpy hashcpy 	owner 
hashcpy trace sha 	contributors liable 
hex sha 	direct indirect 
hex sha hex 	incidental special 
diff flush 	exemplary consequential 
free pathspec trace 	damages including 
sha hex 	limited 
sha hex diff 	procurement substitute 
setup diff 	goods services 
opt diff setup 	loss use 
done diff 	data profits 
sha diffcore 	business interruption 
std verify notes 	however 
filepair trace 	caused theory 
sha hex sha 	liability whether 
hex find 	contract strict 
notes merge pair 	liability tort 
pos trace 	including negligence 
sha hex sha 	otherwise 
hex sha 	arising way 
hex hashcmp sha 	use software 
hashcmp hashclr 	even advised 
sha sha hashcmp 	possibility damage 
hashcpy hashcmp 	use hiredis 
hashcmp hashcpy trace 	sds 
sha hex 	pointers rand 
sha hex sha 	inside command 
hex diff 	buf number 
flush free pathspec 	pointers client 
file exists 	randptr number 
git path 	unused 
empty dir git 	pointers client 
path die 	randptr bytes 
git path die 	obuf already 
git path 	written start 
safe create leading 	time request 
directories git 	request 
path die errno 	latency number 
git path 	pending requests 
file exists git 	replies consume 
path die 	non zero 
git path git 	number pending 
pathdup sha 	prefix 
hex safe create 	commands commands 
leading directories 	auth prefixed 
die errno file 	pipeline benchmark 
exists die 	commands discarded 
open die errno 	first send 
write full 	size 
die errno 	bytes pending 
die close free 	prefix commands 
read sha 	prototypes implementation 
file die sha 	calculate latency 
hex sha 	first read 
hex die sha 	means 
hex sha 	server already 
hex write buf 	sent reply 
worktree free 	need parse 
read mmblob read 	parsing overhead 
mmblob read 	part latency 
mmblob merge sha 	calculate 
hex free 	prefix commands 
free free die 	auth discard 
write buf 	prefix commands 
worktree free trace 	first response 
sha hex 	also 
sha hex 	need fix 
sha hex sha 	pointers need 
hex strbuf 	randomize initialize 
addstr strbuf addf 	request nothing 
sha hex 	written enforce 
sha hex check 	upper 
notes merge 	bound number 
worktree sha sha 	requests really 
sha hex 	initialize randomize 
write note worktree 	keys start 
sha sha 	time create 
sha hex write 	benchmark 
note worktree 	client configured 
sha sha sha 	send command 
sha hex 	passed cmd 
merge worktree trace 	len bytes 
note merge 	command copied 
one change manual 	times 
sha hex 	client output 
sha hex 	buffer reused 
note die sha 	send request 
hex note 	server accordingly 
die sha hex 	configured pipeline 
note die 	size 
die trace trace 	also initial 
sha hex 	command prepended 
sha hex sha 	order make 
hex sha 	sure right 
hex hashcmp trace 	database selected 
hashcmp trace 	needed 
hashcmp hashcmp trace 	initial discarded 
note die 	soon first 
trace merge one 	reply received 
change trace 	create client 
sha hex sha 	scratch pointer 
hex sha 	instead 
hex diff remote 	want create 
diff local 	client another 
merge changes 	client reference 
free strcmp hashclr 	pointer points 
trace read 	client use 
full die check 	reference 
refname format 	following information 
sha lookup commit 	take client 
reference die 	command line 
sha hex trace 	use offsets 
sha hex 	rand elements 
sha check refname 	inside 
format hashclr 	command line 
die lookup commit 	used arguments 
reference die 	randomization even 
sha hex trace 	cloning another 
sha hex 	client prefix 
die hashcpy hashcpy 	commands 
merge bases 	applied needed 
sha hex sha 	suppress hiredis 
hex oid 	cleanup unused 
hex oid 	buffers max 
hex sha hex 	speed build 
hashcmp hashcpy 	request 
hashcmp hashcpy merge 	buffer queue 
diffs commit 	requests accordingly 
list insert commit 	pipeline size 
list insert 	simply clone 
create notes commit 	example client 
free commit 	buffer 
list strbuf release 	prefix request 
trace sha 	buffer auth 
hex commit buffer 	commands applicable 
strstr strbuf 	commands discarded 
addstr git path 	first response 
die opendir 	client 
die errno strbuf 	reused commands 
addch readdir 	used number 
dot dotdot 	different zero 
strlen sha hex 	selected prefix 
strbuf addstr 	request buffer 
stat die errno 	command 
index path 	discarded first 
die note die 	time replies 
sha hex 	received client 
sha hex strbuf 	reused command 
setlen create 	used append 
notes commit strlen 	request 
unuse commit 	find substrings 
buffer sha hex 	output buffer 
strbuf release 	need randomized 
closedir strbuf addstr 	copy offsets 
git path 	adjust different 
dir recursively strbuf 	prefix 
release diff 	length strlen 
remote diff local 	rand listen 
tend process 	backlog quite 
merge pairs 	limited systems 
order therefore cache 	returns number 
last returned 	consumed 
index search sequentially 	options list 
appropriate position 	tests run 
found since inserts 	form lrange 
happen diff 	test comma 
remote mainly appends 	order make 
care inserting 	sure 
middle list expensive 	searching testname 
memmove obj 	always match 
belongs obj belongs 	test enabled 
obj belongs 	user meant 
obj belongs cmp 	provide option 
obj belongs 	arg 
obj belongs immediately 	starts dash 
preceding index 	done otherwise 
len found addition 	use remainder 
deletion pair 	command arguments 
addition deletion 	running benchmark 
deletion either deletion 	every 
part pair 	named test 
pair local uninitialized 	selected command 
sha local 	line tests 
uninitialized touch local 	selected passed 
uninitialized sha 	user never 
overwritten following addition 	receive 
addition either 	reply wait 
addition part pair 	every run 
pair local 	benchmark command 
uninitialized two sha 	remainder arguments 
local uninitialized 	run benchmark 
two sha local 	suite 
sha two 	redis-check-aof.c error 
sha modification modification 	epos buf 
one sha 	prefix target 
shall match local 	buf eptr 
shall uninitialized 	target length 
local two 	real 
sha must establish 	target len 
notes merge 	target argc 
worktree abort notes 	pos multi 
merge worktree 	str argc 
already exists notes 	argv filename 
merge worktree 	fix 
already established ignore 	size pos 
epipe conflicts 	diff buf 
section commit message 	strncmp error 
first time 	ftello fgets 
conflict checkout remote 	error strtol 
conflict checkout 	consume 
local regular conflict 	newline ftello 
checkout result 	fread error 
merge change successfully 	read malloc 
resolved stored 	read bytes 
notes change results 	consume newline 
conflict stored 	read 
notes instead 	ftello read 
written notes merge 	argc read 
worktree conflict 	strcasecmp error 
markers nothing remote 	strcasecmp error 
change nothing 	free free 
change local remote 	feof 
nothing local 	strlen error 
change adopt remote 	strlen exit 
change need 	strcmp exit 
file level merge 	exit fopen 
local remote 	exit redis 
dereference local local 	fstat 
sha local 	fileno exit 
sha sha indicates 	exit process 
unborn dereference 	fgets strncasecmp 
remote remote sha 	exit ftruncate 
failed remote 	fileno exit 
sha remote 	exit 
looks like unborn 	fclose copyright 
perform merge 	pieter noordhuis 
empty notes result 	pcnoordhuis gmail 
remote commit 	dot copyright 
result local commit 	salvatore sanfilippo 
find merge 	antirez 
bases todo handle 	gmail dot 
multiple merge 	rights reserved 
bases already merged 	redistribution use 
result local 	source binary 
commit fast forward 	forms without 
result remote 	modification 
commit non trivial 	permitted provided 
merge without 	following conditions 
conflicts commit result 	met redistributions 
lifo order 	source code 
iterate files git 	must retain 
notes merge 	copyright 
worktree found 	notice list 
notes write updated 	conditions following 
notes commit 	disclaimer redistributions 
resulting reusing commit 	binary form 
message parents 	must reproduce 
commit store commit 	copyright 
sha result 	notice list 
sha write file 	conditions following 
blob files 	disclaimer documentation 
within git notes 	materials provided 
merge worktree 	distribution neither 
git notes merge 	name 
worktree directory 	redis names 
since might current 	contributors may 
working directory 	used endorse 
user notes-merge.h local 	promote products 
remote commit 	derived software 
msg verbosity local 	without 
result sha 	specific prior 
commit result 	written permission 
sha merge notes 	software provided 
remote local 	copyright holders 
given notes local 	contributors express 
must notes 	implied 
referenced local notes 	warranties including 
level merge 	limited implied 
performed commits given 	warranties merchantability 
two refs 	fitness particular 
merged producing one 	purpose disclaimed 
following outcomes 	shall 
merge trivially results 	copyright owner 
existing commit 	contributors liable 
fast forward already 	direct indirect 
date local 	incidental special 
untouched sha result 	exemplary consequential 
written result 	damages 
sha returned merge 	including limited 
successfully completes 	procurement substitute 
producing merge 	goods services 
commit local contains 	loss use 
updated notes 	data profits 
sha resulting commit 	business 
written result 	interruption however 
sha returned merge 	caused theory 
results conflicts 	liability whether 
similar merge result 	contract strict 
merge result 	liability tort 
minus unmerged entries 	including 
stored local 	negligence otherwise 
sha resulting commit 	arising way 
amended conflicts 	use software 
resolved written result 	even advised 
sha unmerged 	possibility damage 
entries written git 	increase 
notes merge 	length also 
worktree directory 	consume stop 
conflict markers returned 	loop finish 
local remote 	redis-check-rdb.c level 
must given non 	positions errors 
either although 	types 
may refer non 	target num 
existing notes 	peek buf 
notes interpreted empty 	dump version 
notes merge 	offset type 
trivially results points 	offset timelen 
finalize conflict 	isencoded 
resolution earlier notes 	buf len 
merge given 	type enctype 
notes must notes 	offset enc 
corresponding given 	val buf 
commit result commit 	slen clen 
created previous 	offset 
call notes merge 	isencoded len 
function resolved 	buf store 
notes git 	offset key 
notes merge worktree 	buf len 
create notes 	val store 
merge commit sha 	offset 
stored result 	val offset 
sha abort conflict 	key length 
resolution earlier 	length offset 
notes merge removes 	indent width 
notes merge 	body head 
worktree git notes 	tail 
merge worktree 	ops bytes 
notes-utils.c parents msg 	body bytes 
msg len 	offset body 
result sha sha 	body tmp 
parent sha 	num valid 
parent msg buf 	bytes 
commit sha 	entry dump 
parse notes merge 	version offset 
strategy cmd 	crc crc 
rewrite mode 	rdbfilename size 
env rewrite refs 	stat data 
env obj 	argv 
obj ret msg 	argc memcpy 
write notes 	read bytes 
die read lookup 	error memcmp 
commit parse 	error strtol 
commit die commit 	error read 
list insert 	bytes 
commit die die 	rdb check 
strbuf addstr 	type shift 
strbuf complete line 	error shift 
create notes 	error read 
commit strbuf insert 	bytes rdb 
update strbuf 	check 
release strcasecmp strcasecmp 	type read 
strcasecmp strcasecmp 	bytes shift 
starts strcmp git 	error read 
config strcmp 	bytes read 
config error 	bytes read 
nonbool parse combine 	bytes 
notes error 	ntohl read 
strcmp starts list 	bytes read 
refs glob 	bytes read 
warning xmalloc getenv 	bytes shift 
getenv xcalloc 	error zmalloc 
parse combine notes 	sprintf 
error list 	load length 
refs colon sep 	load length 
git config 	zmalloc read 
list clear free 	bytes zfree 
free load 	zmalloc lzf 
notes trees list 	decompress 
clear free 	zfree zfree 
copy note commit 	zfree load 
notes free 	length load 
notes free 	integer load 
free deduce parent 	lzf shift 
commit points 	error 
nothing root orphan 	zmalloc read 
commit commit 	bytes zfree 
unchanged prepare commit 	load shift 
message reflog 	error zfree 
message commit message 	zfree read 
starts index 	bytes 
note refs prefix 	zmalloc read 
implied underlying 	bytes zfree 
glob translators first 	sscanf load 
name environment 	shift error 
variable second notes-utils.h 	zfree zfree 
parents msg 	process 
msg len result 	shift error 
sha msg 	load length 
trees cmd enabled 	shift error 
combine refs 	process shift 
refs env 	error process 
mode env parse 	shift 
notes merge 	error process 
strategy cmd obj 	shift error 
obj msg 	process shift 
create notes commit 	error process 
given notes 	shift error 
properties created commit 	process 
result converting 	shift error 
write notes parents 	shift error 
given parents 	load type 
commit referenced author 	load length 
committer determined 	shift error 
commit commit message 	shift 
msg resulting 	error shift 
commit sha stored 	error process 
result sha 	time load 
notes.c key sha 	type load 
val sha 	pair shift 
next path 	error 
mode sha notes 	peek type 
display notes 	shift error 
refs display notes 	shift error 
trees subtree 	memset memset 
node key sha 	memset memset 
key sha 	strlen 
parent index entry 	server log 
parent stack 	sprintf print 
entry type combine 	centered sprintf 
notes node 	print centered 
ret hex hex 	sprintf sprintf 
len sha 	sprintf 
sha len len 	strncpy strlen 
val path 	memset strlen 
mode sha subtree 	sprintf print 
node sha 	centered server 
prefix len buf 	log process 
desc entry 	header 
len path 	server log 
len type non 	exit load 
note path 	entry print 
fanout sha fanout 	valid print 
path hex 	error stack 
sha fanout flags 	load 
data ret 	entry print 
path path len 	skipped zfree 
next buf 	print valid 
path tws full 	shift error 
path buf 	print error 
mode path path 	stack 
len sha 	crc shift 
tws path tws 	error server 
ret tws 	log server 
path mode sha 	log open 
path len 	error fstat 
ret root next 	error 
non note 	error mmap 
note path 	error sprintf 
ret sha note 	sprintf sprintf 
sha note 	sprintf sprintf 
path data note 	sprintf sprintf 
path len 	sprintf 
mode next sha 	process munmap 
sha note 	close exit 
sha note path 	server log 
data cur 	exit redis 
sha sha buf 	check rdb 
cur len 	copyright 
len buf len 	pieter noordhuis 
ret cur 	pcnoordhuis gmail 
sha sha cur 	dot copyright 
sha sha 	salvatore sanfilippo 
list sha data 	antirez gmail 
len item 	dot 
data buf 	rights reserved 
cur sha sha 	redistribution use 
sort uniq 	source binary 
list buf ret 	forms without 
refname oid 	modification permitted 
flag refs list 	provided 
glob sha 	following conditions 
list globs split 	met redistributions 
globs copy 	source code 
load refs notes 	must retain 
notes combine 	copyright notice 
notes flags sha 	list 
sha mode 	conditions following 
root refs flags 	disclaimer redistributions 
item counter 	binary form 
trees opt display 	must reproduce 
env load 	copyright notice 
config refs item 	list 
sha note 	conditions following 
sha combine 	disclaimer documentation 
notes sha sha 	materials provided 
found flags 	distribution neither 
data result root 	name redis 
data ret 	names 
flags sha output 	contributors may 
encoding raw 	used endorse 
utf sha msg 	promote products 
msg linelen 	derived software 
msglen reencoded sha 	without 
output encoding 	specific prior 
raw obj obj 	written permission 
force combine 	software provided 
notes note existing 	copyright holders 
note ptr 	contributors express 
type clr ptr 	implied 
type subtree 	warranties including 
sha prefixcmp load 	limited implied 
subtree free 	warranties merchantability 
note search 	fitness particular 
nibble ptr type 	purpose disclaimed 
clr ptr 	shall 
type note search 	copyright owner 
clr ptr 	contributors liable 
type subtree sha 	direct indirect 
prefixcmp load 	incidental special 
subtree free note 	exemplary consequential 
search note 	damages 
search ptr type 	including limited 
clr ptr 	procurement substitute 
type hashcmp clr 	goods services 
ptr type 	loss use 
ptr type free 	data profits 
note search 	business 
ptr type ptr 	interruption however 
type clr 	caused theory 
ptr type hashcmp 	liability whether 
hashcpy free 	contract strict 
ptr type 	liability tort 
nibble clr ptr 	including 
type note 	negligence otherwise 
consolidate nibble note 	arising way 
search ptr 	use software 
type clr ptr 	even advised 
type ptr 	possibility damage 
type sha free 	data 
ptr type 	type hold 
hashcmp hashcmp combine 	offset file 
notes sha 	size hold 
note free subtree 	stack errors 
sha prefixcmp 	data type 
load subtree free 	hold 
subtree sha 	opcode optional 
prefixcmp load subtree 	key name 
free note 	success status 
insert ptr 	store types 
type ptr type 	output valid 
sha free 	type 
xcalloc note insert 	type added 
ptr type 	update following 
ptr type note 	condition necessary 
insert ptr 	number bytes 
type note free 	read negative 
clr ptr 	peek 
type free clr 	expect first 
ptr type 	bytes equal 
hexval hexval strcmp 	redis needs 
xmalloc hashcpy 	qualify type 
non note cmp 	failure discard 
non note 	time 
cmp non note 	consume bytes 
cmp non 	failure read 
note cmp strcmp 	bit len 
hashcpy free 	read bit 
fill descriptor 	len encoding 
die sha hex 	type 
memcpy entry 	read bit 
strlen sha hex 	len read 
segment xcalloc 	bit len 
hashcpy hashcpy isdir 	convert val 
note insert 	returns processable 
die sha hex 	valid 
sha hex 	unknown encoding 
strbuf addch strbuf 	read key 
addch strbuf 	first done 
addch strbuf addstr 	success reset 
non note 	error container 
strbuf detach free 	optionally 
ptr type 	consume expire 
sha hex xsnprintf 	entries followed 
determine fanout 	valid type 
ptr type note 	entry selectdb 
helper clr 	expire eof 
ptr type 	display 
clr ptr type 	truncation last 
construct path 	chars display 
fanout load subtree 	unprintable characters 
free clr 	display error 
ptr type construct 	stack exclude 
path fanout 	checksum 
strbuf addf strbuf 	rdb end 
xmalloc strbuf 	search next 
init write stack 	valid entry 
finish subtree 	find consecutive 
write sha file 	valid entries 
strbuf release 	check 
free write entry 	found consecutive 
strlen matches 	valid entries 
write stack write 	print many 
stack finish 	bytes skipped 
subtree write stack 	find valid 
init subtree 	opcode 
memchr write 	advance position 
entry strcmp write 	another potential 
note helper 	error print 
strlen write non 	many valid 
note write 	ops processed 
note helper sha 	expect 
file xmalloc 	eof last 
sha read sha 	eof error 
file free 	eof error 
sha read sha 	reset type 
file free 	verify checksum 
free hashcpy xmalloc 	print 
memcpy memcpy 	summary errors 
free free write 	initialize vars 
sha file 	types types 
free hashcpy sha 	used dumping 
read sha 	disk rdb 
file free 	check 
list split free 	main called 
strbuf addstr 	form redis 
strbuf addch list 	redis executed 
note lines 	redis check 
list note lines 	rdb redis-cli.c 
list empty 	spectrum 
items list sort 	palette color 
list duplicates 	size spectrum 
list write sha 	palette color 
file strbuf 	spectrum palette 
release list clear 	mono size 
unsorted list 	spectrum 
list append glob 	palette mono 
specials glob 	spectrum palette 
sha warning unsorted 	spectrum palette 
list list 	size context 
append xstrdup list 	hostip hostport 
split place 	hostsocket 
list empty 	repeat interval 
items list refs 	dbnum interactive 
glob list 	shutdown monitor 
clear free strcmp 	mode pubsub 
config error 	mode latency 
nonbool list refs 	mode 
glob getenv 	latency dist 
notes xcalloc xstrdup 	mode latency 
sha treeish 	history lru 
read die entry 	test mode 
die sha 	lru test 
hex hashclr hashcpy 	sample 
load subtree 	size cluster 
alloc xcalloc init 	mode cluster 
notes list 	reissue command 
append notes getenv 	slave mode 
list refs 	pipe mode 
colon sep git 	pipe 
config list 	timeout getrdb 
refs glob 	mode stat 
load notes trees 	mode scan 
list clear 	mode intrinsic 
xmalloc hashcpy hashcpy 	latency mode 
note insert 	intrinsic 
hashcpy hashclr note 	latency duration 
sha note 	pattern rdb 
find note helper 	filename bigkeys 
strbuf init 	stdinarg auth 
note write non 	output delim 
note write 	prompt 
stack finish subtree 	eval eval 
write sha 	ldb eval 
file strbuf release 	ldb sync 
note sha 	eval ldb 
hex note note 	end enable 
free free 	ldb 
free free free 	eval last 
memset init 	cmd type 
notes note 	force cancel 
read sha file 	loop ust 
free encoding 	len path 
utf reencode free 	history 
strlen strcmp 	path home 
strbuf addstr starts 	help entries 
starts strbuf 	help entries 
addf strchrnul strbuf 	len version 
addstr strbuf 	commandslen groupslen 
strbuf addch free 	len 
format note 	pos tmp 
note note note 	help version 
note starts 	argc argv 
starts strbuf insert 	len entry 
strbuf insert 	help buf 
sha expand notes 	startpos 
use non 	mask matchlen 
balancing simple structure 	tmp reply 
node nodes 	reply result 
leaf node 	force prefix 
leaf nodes node 	idxlen prefixlen 
pointers children 	prefixfmt 
bottom bits pointer 	prefix tmp 
used identify 	len color 
pointer type ptr 	bold ccode 
pointer ptr 	len color 
ptr pointer next 	tmp tmp 
node cast 	output 
node ptr pointer 	raw reply 
note entry 	reply output 
cast leaf node 	slot argc 
ptr pointer 	argv repeat 
subtree entry cast 	command argvlen 
leaf node 	output 
root node statically 	raw fmt 
allocated node 	reply tries 
leaf nodes 	argc argv 
come two variants 	lastarg seconds 
note entries 	version buf 
subtree entries distinguished 	arg 
leaf node 	nread version 
pointer see note 	count args 
entry key 	sds argc 
sha referenced sha 	argv repeat 
note subtree 	argc argv 
entry key prefix 	line 
sha trailing 	argc argv 
referenced last key 	len elen 
store length 	historyfile history 
prefix sha containing 	line argc 
notes subtree 	argv elapsed 
notes may contain 	repeat 
entries notes 	skipargs argc 
follow naming conventions 	argv retval 
notes typically 	argc argv 
none still 	script buf 
need keep track 	nread argv 
keep simple 	got 
linked list sorted 	comma keys 
alpha betically 	retval reply 
non note path 	eval ldb 
list populated 	reply start 
parsing objects load 	latency count 
subtree non 	history 
notes correctly written 	interval avg 
back objects 	history start 
produced write notes 	max count 
grounded last 	character samples 
next search appropriate 	tot coloridx 
location given 	color 
key found start 	reply start 
root node 	latency count 
current level matching 	history interval 
subtree entry 	history start 
unpack subtree 	outputs samples 
entry restart search 	buf 
current level 	nread payload 
use nth nibble 	buf original 
key index 	output nread 
node recurse node 	payload buf 
increment matching 	nread nwritten 
subtree entry unpack 	obuf 
subtree entry 	pos ibuf 
restart search current 	obuf aneterr 
level otherwise 	reader reply 
found one following 	eof done 
subtree entry 	magic last 
match key note 	read 
entry may 	time mask 
may match key 	nread loop 
unused leaf 	nwritten nwritten 
node pointer location 	nread echo 
unpack resume 	reply reply 
search unpack 	size 
resume search fall 	key type 
find leaf 	keys types 
node search location 	reply keys 
appropriate given 	types sizes 
key note entry 	reply sizecmds 
matching key 	totalsize 
note entry consolidate 	total keys 
node non 	maxkeys typeunit 
entries give non 	reply keys 
zero otherwise 	type types 
replace node given 	pct info 
index given 	field 
parent node entry 	result info 
entry entries 	field reply 
given one entry 	aux requests 
replace parent 	buf reply 
index leaf 	cur min 
node search location 	max 
appropriate given 	alpha buf 
leaf node key 	buflen reply 
location hold 	key start 
matching entry abort 	cycle misses 
nothing copy 	output test 
matching entry given 	end 
entry replace 	run time 
matching leaf node 	runs start 
entry free 	end latency 
leaf node consolidate 	avg avg 
nodes repeatedly 	argc argv 
walking towards root 	firstarg 
type bits 	gettimeofday ustime 
type mismatch nothing 	snprintf anet 
key mismatch 	format addr 
nothing found matching 	snprintf snprintf 
entry consolidate 	getenv strcmp 
level parent 	sdscatprintf 
levels possible cannot 	sdsempty getenv 
consolidate top 	sdscatprintf sdsempty 
level first build 	sdscatprintf sdsempty 
stack ancestors 	strtoll redis 
root current node 	git sha 
next unwind 	sdscatprintf 
stack note consolidate 	redis git 
done insert 	sha strtoll 
leaf node search 	redis git 
location appropriate 	dirty sdscatprintf 
given leaf node 	sdscat malloc 
key location 	malloc 
unused store tweaked 	sdscatprintf sdsempty 
pointer directly 	sdssplitargs sdsnew 
location holds note 	cli version 
entry matches 	sdsfree cli 
note inserted combine 	output help 
two notes 	strcasecmp 
calling given 	strcasecmp cli 
combine notes function 	output command 
location holds 	help cli 
note entry matches 	output command 
subtree inserted 	help strncasecmp 
unpack subtree inserted 	isspace 
location location 	strlen strncasecmp 
holds matching subtree 	sdsnewlen sdscat 
entry unpack 	linenoise completion 
subtree location restart 	sdsfree redis 
insert operation 	command free 
level create node 	reply 
holding node 	redis command 
location node inserted 	free reply 
store node 	redis free 
location type bits 	redis connect 
skip concatenation 	redis connect 
entry unpack entry 	unix 
unpack restart 	redis free 
insert non 	anet keep 
matching leaf node 	alive cli 
skip insertion 	auth cli 
empty note free 	sdsempty sdscatprintf 
entire notes 	sdscat 
data contained given 	sdscat sdscatprintf 
fall convert 	sdscatrepr sdscat 
sha hex corresponding 	sdscat sdscat 
sha hex 	memset sdscat 
sha segment ascii 	sdsnew snprintf 
hex format 	sdscatprintf 
hex len length 	cli format 
segment must 	reply tty 
multiple sha sha 	sdscatlen sdslen 
written sha 	sdsfree sdsfree 
len max bytes 	exit getenv 
store sha 	strstr 
must hex 	color term 
len returns error 	sdscatlen strstr 
invalid arguments 	strstr strstr 
invalid sha hex 	strstr strstr 
format otherwise 	strstr strstr 
returns number bytes 	strstr 
written sha 	strstr sdscatfmt 
hex len pads 	sdscatlen sdscat 
sha sha 	strstr strstr 
len included returned 	strstr strstr 
length note 	strstr strstr 
takes ownership path 	strstr 
nothing sorts 	isdigit sdscatcolor 
first non note 	sdsempty sdscatlen 
sorts equal 	sdscatlen strstr 
overwrite sorts next 	cli refresh 
entry path 	prompt sds 
sha sha complete 	cat 
len note 	colorized ldb 
sha incomplete 	reply sdscatlen 
len current component 	sdscatprintf sdscat 
consists hex 	cli format 
chars note subtree 	reply raw 
subtree determine 	sdscatlen 
full path non 	sdslen sdsfree 
note entry 	exit sdsempty 
filename already found 	sdscat sdscatrepr 
entry path 	strlen sdscatrepr 
directory part path 	sdscatprintf sdscatrepr 
must deduced 	sdscat 
subtree containing entry 	cli format 
overall notes 	reply csv 
follows strict progressive 	sdscatlen sdslen 
fanout structure 	sdscat sdsfree 
etc fanouts fanout 	exit redis 
means non 	reply 
note found path 	redis free 
dead beef 	cli print 
following code 	context error 
found beef hand 	exit strncmp 
use non 	strcmp strchr 
obvious non note 	strchr 
paths middle 	atoi strchr 
notes deserve coming 	sdsfree sdsnew 
note non 	atoi cli 
notes sha like 	refresh prompt 
top level 	cli format 
problems conclude strongly 	reply 
advised make 	raw cli 
sure non notes 	format reply 
least one 	raw sdscat 
non hex character 	cli format 
top level 	reply tty 
path component determine 	cli 
optimal disk 	format reply 
fanout part notes 	csv sdscat 
given sub 	fwrite sdslen 
level structure 	sdsfree free 
determine whether given 	reply strcasecmp 
existing fanout 	strcasecmp 
expanded sub values 	cli output 
fanout variable 	help strcasecmp 
fanout notes stored 	strcasecmp strcasecmp 
directly root 	strcasecmp strcasecmp 
notes fanout fanout 	strcasecmp strcasecmp 
fanout etc 	strcasecmp 
following simple heuristic 	strcasecmp strcasecmp 
works well 	strcasecmp strcasecmp 
practice even numbered 	strcasecmp strcasecmp 
level remember 	strcasecmp strcasecmp 
disk fanout level 	strcasecmp 
corresponds two 	strcasecmp strcasecmp 
levels peek entries 	strcasecmp strcasecmp 
level either 	strcasecmp strcasecmp 
nodes subtree entries 	strcasecmp malloc 
likely plenty 	sdslen redis 
notes level 	append 
incremented fanout hex 	command argv 
sha nul 	cli read 
recurse node subtree 	reply exit 
entries note 	fflush cli 
represent parts note 	read reply 
yet explored 	exit 
direct relationship subtree 	slave mode 
entries level 	free cli 
fanout variable subtree 	read reply 
entries level 	free strcasecmp 
fanout preserved since 	atoi cli 
correspond exactly 	refresh 
fanout directory disk 	prompt strcasecmp 
structure however 	cli usleep 
subtree entries level 	fflush free 
fanout preserved 	fflush redis 
rather consolidated 	free redis 
notes level achieve 	connect 
unconditionally unpacking 	usleep start 
subtree entries exist 	redisv command 
threshold level 	end exit 
fanout invoke callback 	strcmp sdsfree 
subtree create 	sdsnew strcmp 
trailing slash needed 	usage 
unpack subtree 	strcmp usage 
resume traversal path 	strcmp strcmp 
subtree next 	atoi strcmp 
entries per determine 	strcmp strtoll 
common part 	strcmp atof 
write stack tws 	strcmp 
point last 	atoi strcmp 
matching write stack 	strcmp strcmp 
entry start 	strcmp strcmp 
subtrees needed satisfy 	strcmp strcmp 
path directory 	strcmp strcmp 
components given 	strtoll 
path given entry 	strcmp strcmp 
current nothing 	strcmp strcmp 
prefer note non 	strcmp atoi 
note subtree 	strcmp strcmp 
entry weave non 	strcmp atoi 
note entries 	strcmp 
note entries nothing 	strcmp strcmp 
note failed 	strcmp strcmp 
find prune note 	strcmp sdsfree 
read note 	sdsnew strcmp 
blob objects separate 	strcmp cli 
notes two 	version 
newlines anyway concatenate 	sdsfree exit 
cur msg 	exit exit 
msg buf create 	sdsempty read 
blob buf 	fileno perror 
lines named list 	exit sdscatlen 
trailing newlines 	cli 
removed read 	version sdsfree 
sha file nul 	exit zmalloc 
terminates last 	sdsnew cli 
line file eol 	send command 
terminated empty 	cli connect 
list removed later 	cli 
along empty 	send command 
came empty lines 	cli print 
within file 	context error 
read note blob 	cli connect 
objects unique 	issue command 
lines create blob 	repeat 
sort uniq 	strstr strstr 
list list argument 	sds malloc 
must strdup 	strlen sdsnewlen 
core notes config 	sdsnewlen sdssplitargs 
note removed 	linenoise multi 
prepare traversal current 	line 
notes last 	linenoise completion 
forward entry 	callback isatty 
list grounded entries 	fileno history 
write objects 	path linenoise 
representing current notes 	history load 
fill given 	cli 
strbuf notes associated 	refresh prompt 
given given 	linenoise cli 
notes structure initialized 	split args 
initialized see 	linenoise history 
documentation init notes 	linenoise history 
given notes 	save 
notes used instead 	free strcasecmp 
raw gives 	strcasecmp exit 
userformat otherwise note 	strcasecmp strcasecmp 
message given 	sdsfree sdsnew 
human consumption end 	atoi cli 
annotation newline 	refresh 
anyway happy 	prompt cli 
fallback expand notes 	connect strcasecmp 
builtin git 	linenoise clear 
notes copyright johan 	screen mstime 
herland johan 	atoi issue 
herland net git 	command 
notes johannes 	repeat cli 
schindelin builtin tag 	read reply 
kristian gsberg 	mstime sdsfreesplitres 
carlos rica invoke 	free exit 
git show 	zrealloc read 
stat notes write 	arg 
message editing 	stdin issue 
redirect edit subcommand 	command issue 
end none 	command sdsfree 
given original args 	sdsempty fopen 
therefore still 	strerror exit 
argv append buf 	fread 
previous note 	sdscatlen fclose 
contents git 	redis command 
notes merge git 	free reply 
notes merge 	zmalloc sdsnew 
call notes merge 	sdsnew sdscatprintf 
abort git 	sdsempty 
notes merge worktree 	issue command 
read merge 	cli read 
result git notes 	reply strncpy 
merge target 	repl cli 
notes git notes 	connect mstime 
merge reuse 	exit 
existing commit message 	mstime reconnecting 
reflog message 	redis command 
skip notes merge 	exit mstime 
resulted trivially 	free reply 
result sha update 	fflush mstime 
notes commit 	mstime 
merge unresolved conflicts 	mstime usleep 
update git 	ceil tot 
notes merge 	fflush ustime 
merge result store 	exit ustime 
updated git 	reconnecting redis 
notes merge non 	command 
zero conflicts 	exit ustime 
git notes usage 	free reply 
git notes 	ustime show 
list usage git 	latency dist 
notes usage 	legend show 
git notes copy 	latency 
usage git 	dist samples 
notes append usage 	ustime usleep 
git notes 	write exit 
edit usage git 	read exit 
notes show 	exit strtoull 
usage git notes 	send 
merge usage 	sync read 
git notes usage 	exit cli 
git notes 	read reply 
prune usage 	send sync 
git notes usage 	strcmp open 
note given 	strerror 
use editor edit 	exit read 
path buf 	exit write 
sha note sha 	strerror exit 
note path 	close fsync 
data sha size 	exit redis 
buf show 	reader 
args show buf 	create time 
cbuf old 	srand time 
note buf sha 	anet non 
opt arg 	block exit 
unset opt arg 	wait read 
unset opt 	strerror 
arg unset buf 	exit redis 
len opt 	reader feed 
arg unset 	time redis 
force rewrite cmd 	reader reply 
buf ret 	exit memcmp 
msg obj obj 	free 
split err 	reply write 
subcommand flags argc 	strerror exit 
argv prefix 	read rand 
note retval options 	memcpy memcpy 
argc argv 	strerror exit 
prefix argc argv 	time 
prefix allow 	redis reader 
empty note note 	free exit 
options argc 	exit redis 
argv prefix stdin 	command exit 
note note 	exit exit 
obj rewrite cmd 	exit 
options argc 	strtoull redis 
argv prefix allow 	command exit 
empty note 	free reply 
note logmsg 	strcmp strcmp 
usage options edit 	strcmp strcmp 
size prev 	strcmp 
buf argc argv 	strcmp exit 
prefix note 	redis append 
retval options show 	command redis 
args ret 	reply exit 
msg sha parent 	exit type 
sha pretty 	free 
ctx local free 	reply redis 
ret git 	append command 
config notes strategy 	redis reply 
argc argv 	exit free 
prefix msg result 	reply size 
sha abort 	sdsempty 
result strategy options 	exit send 
merge key 	scan zrealloc 
existing name flag 	zrealloc exit 
status sha 	key types 
argc argv 	key sizes 
prefix flag stdin 	sdscpy 
options retval 	exit usleep 
argc argv prefix 	free reply 
verbose options 	zfree zfree 
argc argv prefix 	sdslen sdsfree 
options argc 	exit strstr 
argv prefix result 	strlen 
notes options 	strchr strchr 
unlink warn free 	malloc memcpy 
strbuf release 	info field 
sha hex sha 	strtol free 
hex read 	sprintf sprintf 
sha file write 	sprintf 
die free 	sprintf reconnecting 
start command die 	redis command 
sha hex 	exit sprintf 
strbuf read die 	info field 
errno strbuf 	sprintf info 
commented lines 	field 
write die strbuf 	bytes human 
release strbuf 	info field 
release finish command 	sprintf info 
die sha 	field sprintf 
hex git pathdup 	info field 
open die 	sprintf 
errno write die 	info field 
copy obj 	sprintf info 
strbuf addch strbuf 	field info 
commented lines 	field info 
strlen strbuf addch 	field free 
write die 	reply 
write commented close 	usleep redis 
strbuf release 	command redis 
strbuf reset launch 	command exit 
editor die 	exit strtoull 
strbuf stripspace write 	free reply 
sha file 	exit 
error error 	rand pow 
exit strbuf grow 	pow pow 
strlen strbuf 	pow snprintf 
addch strbuf addstr 	power law 
strbuf stripspace 	rand srand 
strbuf addch strcmp 	time 
strbuf read 	getpid mstime 
die errno strbuf 	mstime lru 
read file 	test gen 
die errno strbuf 	key redis 
stripspace strbuf 	append command 
addch sha die 	redis 
read sha 	reply lru 
file free die 	test gen 
free die 	key redis 
strbuf free parse 	append command 
reuse arg 	redis reply 
init copy 	exit 
notes rewrite init 	exit unused 
notes strbuf 	ustime signal 
getline strbuf split 	ustime compute 
die strbuf 	something fast 
rtrim strbuf rtrim 	ustime exit 
sha die 	sdsnew 
sha die copy 	isatty fileno 
note rewrite 	getenv sdsnew 
copy note error 	cli init 
strbuf list 	help parse 
free commit notes 	options cli 
free notes 	connect 
finish copy notes 	exit latency 
rewrite init 	mode cli 
notes starts die 	connect exit 
parse options 	latency dist 
error usage options 	mode cli 
init notes 	connect 
check sha 	exit slave 
die note puts 	mode cli 
sha hex 	connect exit 
error sha hex 	rdb cli 
note free 	connect exit 
notes parse options 	pipe 
error usage 	mode cli 
options sha die 	connect exit 
init notes 	find big 
check note free 	keys cli 
notes free 	connect exit 
note data error 	stat 
sha hex 	mode cli 
append edit sha 	connect exit 
hex prepare 	scan mode 
note data write 	cli connect 
note data 	exit lru 
note die commit 	test 
notes sha 	mode intrinsic 
hex note 	latency mode 
commit notes free 	signal cli 
note data 	connect repl 
free notes parse 	cli connect 
options error 	exit 
usage options notes 	eval mode 
copy stdin 	noninteractive convert 
error usage options 	sds redis 
error usage 	cli command 
options sha die 	line copyright 
sha die 	salvatore 
init notes check 	sanfilippo antirez 
note error 	gmail dot 
sha hex sha 	rights reserved 
hex note 	redistribution use 
error sha hex 	source binary 
note die 	forms 
commit notes free 	without modification 
notes strcmp 	permitted provided 
parse options 	following conditions 
error usage options 	met redistributions 
sha die 	source code 
init notes check 	must 
note prepare 	retain copyright 
note data read 	notice list 
sha file 	conditions following 
strbuf grow strbuf 	disclaimer redistributions 
insert strbuf 	binary form 
insert free write 	must 
note data 	reproduce copyright 
note die snprintf 	notice list 
sha hex 	conditions following 
note snprintf commit 	disclaimer documentation 
notes free 	materials provided 
note data free 	distribution 
notes parse 	neither name 
options error 	redis names 
usage options sha 	contributors may 
die init 	used endorse 
notes check note 	promote products 
error sha 	derived 
hex execv git 	software without 
cmd free 	specific prior 
notes error error 	written permission 
notes merge 	software provided 
abort error sha 	copyright holders 
die lookup 	contributors 
commit reference die 	express implied 
parse commit 	warranties including 
die hashcpy hashclr 	limited implied 
xcalloc init 	warranties merchantability 
notes resolve refdup 	fitness particular 
die notes 	purpose 
merge commit die 	disclaimed shall 
memset format 	copyright owner 
commit message 	contributors liable 
strbuf trim strbuf 	direct indirect 
insert update 	incidental special 
sha free notes 	exemplary 
strbuf release 	consequential damages 
merge abort free 	including limited 
parse options 	procurement substitute 
error usage options 	goods services 
error usage 	loss use 
options error usage 	data 
options init 	profits business 
notes merge options 	interruption however 
merge abort 	caused theory 
merge commit notes 	liability whether 
strbuf addstr 	contract strict 
expand loose notes 	liability 
init notes 	tort including 
check parse notes 	negligence otherwise 
merge strategy 	arising way 
error usage 	use software 
options skip prefix 	even advised 
die strbuf 	possibility 
addf git config 	damage use 
notes strategy 	sds hiredis 
git config notes 	one sds 
strategy strbuf 	functions present 
release strbuf addf 	binary seconds 
notes strbuf 	seconds 
notes merge update 	latency dist 
notes update 	palettes actual 
find shared symref 	palette use 
notes die 	last arg 
notes create symref 	stdin option 
notes die 	output 
notes git path 	mode see 
free notes 	output defines 
strbuf release strbuf 	ask synchronous 
release sha 	mode lua 
error note 	debugger lua 
parse options init 	debugging 
notes check 	session ended 
one note one 	handle manual 
note strbuf 	script debug 
getwholeline strbuf rtrim 	eval commands 
one note 	utility functions 
strbuf release commit 	dbnum 
notes free 	needed check 
notes parse options 	env histfile 
error usage 	env otherwise 
options init notes 	help functions 
check prune 	used help 
notes commit notes 	commands 
free notes 	git commit 
parse options error 	working status 
usage options 	available output 
puts notes 	command help 
git config parse 	stdout print 
options strbuf 	help 
addstr expand notes 	output command 
setenv strbuf 	help filtering 
release strcmp list 	command name 
strcmp strcmp 	compare arguments 
copy strcmp strcmp 	networking parsing 
append edit 	send 
strcmp show strcmp 	auth command 
merge strcmp 	server send 
cmd strcmp prune 	dbnum server 
strcmp error 	connect server 
usage options use 	force zero 
non balancing 	connection 
simple structure node 	performed even 
nodes leaf 	already connected 
node leaf nodes 	socket aggressive 
node pointers 	keep alive 
children bottom 	socket option 
bits pointer used 	redis 
identify pointer 	context socket 
type ptr pointer 	order prevent 
ptr ptr 	timeouts caused 
pointer next node 	execution commands 
cast node 	time 
ptr pointer note 	improves detection 
entry cast 	real errors 
leaf node ptr 	auth right 
pointer subtree 	producing output 
entry cast leaf 	standard output 
node root 	want 
node statically allocated 	interesting output 
node leaf 	quoted characters 
nodes come two 	forth calculate 
variants note 	chars needed 
entries subtree entries 	represent largest 
distinguished leaf 	index 
node pointer 	prefix nested 
see note entry 	multi bulks 
key sha 	grow idxlen 
referenced sha note 	spaces setup 
subtree entry 	prefix format 
key prefix sha 	every 
trailing referenced 	entry use 
last key store 	prefix first 
length prefix 	element parent 
sha containing notes 	caller already 
subtree notes 	prepended index 
may contain entries 	number 
notes follow 	format multi 
naming conventions notes 	bulk entry 
typically none 	helpe function 
still need keep 	sds cat 
track keep 	colorized ldb 
simple linked list 	reply 
sorted alpha 	appending colorize 
betically non 	sds defaults 
note path list 	white colorize 
populated parsing 	lua debugger 
objects load subtree 	status replies 
non notes 	according 
correctly written back 	prefix current 
objects produced 	line point 
write notes grounded 	nothing lua 
last next 	debugger replies 
search appropriate location 	arrays simple 
given key 	status 
found start root 	colorize output 
node current 	fun debugging 
level matching subtree 	session detect 
entry unpack 	end debugging 
subtree entry restart 	session signal 
search current 	caller 
level use nth 	session ended 
nibble key 	filter cases 
index node 	reconnect avoid 
recurse node increment 	compiler warning 
matching subtree 	check need 
entry unpack subtree 	connect 
entry restart 	different node 
search current level 	reissue request 
otherwise found 	comments show 
one following subtree 	position pointer 
entry match 	pointer pointer 
key note entry 	moved 
may may 	moved moved 
match key unused 	debugging mode 
leaf node 	pass help 
pointer location unpack 	redis user 
resume search 	manually calls 
unpack resume search 	script 
fall find 	debug setup 
leaf node 	activation debugging 
search location appropriate 	mode next 
given key 	eval needed 
note entry matching 	actually activate 
key note 	ldb 
entry consolidate node 	eval needed 
non entries 	setup argument 
give non zero 	length error 
otherwise replace 	slave mode 
node given index 	lost connection 
given parent 	master 
node entry entry 	store database 
entries given 	number successfully 
one entry replace 	executed make 
parent index 	grep friendly 
leaf node search 	send command 
location appropriate 	reconnecting 
given leaf node 	link needed 
key location 	cursor left 
hold matching 	edge clear 
entry abort nothing 	line cursor 
copy matching 	left edge 
entry given entry 	clear 
replace matching 	line user 
leaf node entry 	likely command 
free leaf 	name stop 
node consolidate nodes 	ldb requires 
repeatedly walking 	eval turn 
towards root type 	plain 
bits type 	sds still 
mismatch nothing key 	cannot send 
mismatch nothing 	command print 
found matching entry 	error reconnect 
consolidate level 	next time 
parent levels possible 	issue 
cannot consolidate 	command got 
top level first 	redirected cluster 
build stack 	mode split 
ancestors root 	user provided 
current node next 	command multiple 
unwind stack 	sds 
note consolidate done 	arguments function 
insert leaf 	normally uses 
node search location 	sdssplitargs sds 
appropriate given 	able understand 
leaf node key 	quoted escapes 
location unused 	forth 
store tweaked pointer 	however lua 
directly location 	debugging mode 
holds note entry 	eval command 
matches note 	used want 
inserted combine two 	remaining lua 
notes calling 	script 
given combine notes 	eval passed 
function location 	verbatim single 
holds note entry 	big argument 
matches subtree 	eval use 
inserted unpack 	history stdin 
subtree inserted location 	tty 
location holds 	eval mode 
matching subtree entry 	restart session 
unpack subtree 	debugging session 
location restart insert 	ended show 
operation level 	eval reply 
create node holding 	free 
node location 	argument vector 
node inserted store 	linenoise returns 
node location 	malloc lines 
type bits skip 	like readline 
concatenation entry 	eval mode 
unpack entry unpack 	load 
restart insert 	script file 
non matching leaf 	sds debugging 
node skip 	script enable 
insertion empty 	lua debugger 
note free entire 	create argument 
notes data 	vector 
contained given fall 	call save 
convert sha 	may reverteed 
hex corresponding sha 	debugging session 
hex sha 	ended immediately 
segment ascii hex 	error compiling 
format hex 	script 
len length segment 	show enter 
must multiple 	repl caller 
sha sha written 	restart session 
sha len 	repl returned 
max bytes store 	caller latency 
sha must 	latency 
hex len returns 	history modes 
error invalid 	milliseconds milliseconds 
arguments invalid sha 	latency distribution 
hex format 	mode requires 
otherwise returns 	colors xterm 
number bytes written 	milliseconds 
sha hex 	structure store 
len pads sha 	samples distribution 
sha len 	max latency 
included returned length 	fit interval 
note takes 	usec number 
ownership path nothing 	samples 
sorts first 	interval associated 
non note sorts 	character visualization 
equal overwrite 	helper function 
sorts next entry 	latency dist 
path sha 	mode performs 
sha complete len 	spectrum 
note sha 	visualization collected 
incomplete len current 	samples targeting 
component consists 	xterm terminal 
hex chars note 	takes distsamples 
subtree subtree 	structures ordered 
determine full 	smaller 
path non note 	bigger max 
entry filename 	last sample 
already found entry 	max must 
path directory 	mean olds 
part path must 	samples greater 
deduced subtree 	previous 
containing entry overall 	one also 
notes follows 	stop sentinel 
strict progressive fanout 	tot total 
structure etc 	number samples 
fanouts fanout means 	different buckets 
non note 	sum 
found path dead 	samples conut 
beef following 	max sample 
code found beef 	side effect 
hand use 	function sets 
non obvious non 	buckets count 
note paths 	convert 
middle notes 	samples index 
deserve coming note 	inside palette 
non notes 	proportional percentage 
sha like top 	given bucket 
level problems 	represents way 
conclude strongly advised 	intensity 
make sure 	different parts 
non notes least 	spectrum change 
one non 	relative number 
hex character top 	requests avoids 
level path 	pollute visualization 
component determine optimal 	non 
disk fanout 	latency related 
part notes given 	info foreground 
sub level 	color black 
structure determine whether 	last sample 
given existing 	show legend 
fanout expanded 	different 
sub values fanout 	buckets values 
variable fanout 	colors meaning 
notes stored directly 	spectrum easily 
root notes 	readable use 
fanout fanout fanout 	mostly logarithmic 
etc following 	scale 
simple heuristic works 	certain linear 
well practice 	intervals interesting 
even numbered level 	others like 
remember disk 	milliseconds range 
fanout level corresponds 	minute minute 
two levels 	populate 
peek entries level 	relevant bucket 
either nodes 	time time 
subtree entries likely 	show spectrum 
plenty notes 	slave mode 
level incremented fanout 	sends sync 
hex sha 	reads 
nul recurse 	number bytes 
node subtree entries 	payload used 
note represent 	slave mode 
parts note yet 	rdb start 
explored direct 	need send 
relationship subtree entries 	sync 
level fanout 	command payload 
variable subtree entries 	hiredis client 
level fanout 	lib understand 
preserved since correspond 	part protocol 
exactly fanout 	want mess 
directory disk structure 	buffers 
however subtree 	everything performed 
entries level fanout 	direct low 
preserved rather 	level send 
consolidated notes level 	sync command 
achieve unconditionally 	read payload 
unpacking subtree entries 	making 
exist threshold 	sure read 
level fanout 	discard payload 
invoke callback subtree 	use hiredis 
create trailing 	read incoming 
slash needed unpack 	protocol rdb 
subtree resume 	transfer 
traversal path subtree 	mode function 
next entries 	rdb uses 
per determine common 	replication protocol 
part write 	order fetch 
stack tws point 	rdb file 
last matching 	remote 
write stack entry 	server write 
start subtrees 	file close 
needed satisfy path 	file descriptor 
directory components 	asap fsync 
given path given 	may take 
entry current 	time 
nothing prefer note 	bulk pipe 
non note 	mode input 
subtree entry 	output buffers 
weave non note 	consumed standard 
entries note 	input special 
entries nothing note 	reply 
failed find 	recognize use 
prune note read 	non blocking 
note blob 	transfer raw 
objects separate notes 	protocol read 
two newlines 	replies server 
anyway concatenate cur 	time 
msg msg 	handle readable 
buf create blob 	state read 
buf lines 	replies server 
named list trailing 	read socket 
newlines removed 	feed hiredis 
read sha file 	reader 
nul terminates 	consume replies 
last line file 	check reply 
eol terminated 	echo command 
empty list 	everything received 
removed later along 	server handle 
empty came 	writable 
empty lines within 	state send 
file read 	protocol server 
note blob objects 	transfer current 
unique lines 	buffer server 
create blob sort 	accept data 
uniq list 	buffer 
list argument must 	empty load 
strdup core 	stdin echo 
notes config note 	sequence starts 
removed prepare 	garbage protocol 
traversal current notes 	read stdin 
last forward 	echo 
entry list grounded 	likely still 
entries write 	properly formatted 
objects representing 	crlf ignored 
current notes fill 	redis effects 
given strbuf 	everything transferred 
notes associated given 	queue 
given notes 	special echo 
structure initialized initialized 	command match 
see documentation 	replies make 
init notes given 	sure everything 
notes notes 	read server 
used instead raw 	handle 
gives userformat 	timeout reached 
otherwise note message 	eof getting 
given human 	replies server 
consumption end annotation 	seconds echo 
newline anyway 	received find 
happy fallback expand 	big 
notes builtin 	keys handle 
git notes copyright 	error conditions 
johan herland 	validate types 
johan herland 	correct update 
net git notes 	iterator grab 
johannes schindelin 	number 
builtin tag kristian 	keys free 
gsberg carlos 	reply pipeline 
rica invoke git 	type commands 
show stat 	retrieve types 
notes write message 	pipeline size 
editing redirect 	commands 
edit subcommand end 	skip keys 
none given 	deleted retreive 
original args therefore 	sizes skip 
still argv 	keys dissapeared 
append buf previous 	scan type 
note contents 	retreive 
git notes merge 	size theoretically 
git notes 	key could 
merge call notes 	removed added 
merge abort 	different type 
git notes 	type size 
merge worktree read 	total 
merge result 	keys pre 
git notes merge 	scanning status 
target notes 	message sds 
git notes merge 	keep track 
reuse existing 	overall biggest 
commit message reflog 	per 
message skip 	type scan 
notes merge resulted 	loop calculate 
trivially result 	approximate percentage 
sha update notes 	completion grab 
commit merge 	keys point 
unresolved conflicts update 	keys 
git notes 	reallocate type 
merge merge result 	size need 
store updated 	retreive types 
git notes merge 	sizes update 
non zero 	stats keep 
conflicts notes.c 	track 
key sha val 	biggest key 
sha next 	name type 
path mode sha 	keep track 
notes display 	biggest size 
notes refs display 	type update 
notes trees 	overall 
subtree node key 	progress sleep 
sha key 	directed done 
sha parent index 	output biggest 
entry parent 	keys found 
stack entry type 	types find 
combine notes 	free 
node ret hex 	sds containing 
hex len 	max keys 
sha sha len 	success stats 
len val 	mode specified 
path mode 	info field 
sha subtree node 	info 
sha prefix 	command output 
len buf desc 	info buffer 
entry len 	allocated result 
path len type 	needs free 
non note 	field found 
path fanout sha 	returned 
fanout path 	like function 
hex sha fanout 	automatically convert 
flags data 	result error 
ret path path 	missing field 
len next 	min returned 
buf path tws 	convert 
full path 	number bytes 
buf mode path 	human readable 
path len 	form forth 
sha tws path 	bytes keys 
tws ret 	used memory 
tws path 	clients 
mode sha path 	blocked blpopping 
len ret 	clients requets 
root next non 	connections children 
note note 	scan mode 
path ret sha 	lru test 
note sha 	mode 
note path data 	integer min 
note path 	max inclusive 
len mode next 	power law 
sha sha 	distribution depending 
note sha note 	alpha greater 
path data 	alpha 
cur sha sha 	bias towards 
buf cur 	lower values 
len len buf 	alpha output 
len ret 	follows rule 
cur sha sha 	returned numbers 
cur sha 	account 
sha list 	frequency generates 
sha data len 	key name 
item data 	among lru 
buf cur sha 	test sample 
sha sort 	size keys 
uniq list buf 	distribution 
ret refname 	milliseconds perform 
oid flag refs 	cycles second 
list glob 	writes reads 
sha list globs 	use pipelining 
split globs 	batching 
copy load refs 	writes reads 
notes notes 	times per 
combine notes flags 	cycle order 
sha sha 	fill target 
mode root refs 	instance easily 
flags item 	write 
counter trees opt 	cycle read 
display env 	cycle print 
load config 	stats intrisic 
refs item sha 	latency mode 
note sha 	measure max 
combine notes sha 	latency 
sha found 	running process 
flags data result 	result syscalls 
root data 	basically software 
ret flags sha 	provide hint 
output encoding 	much time 
raw utf sha 	kernel 
msg msg 	leaves process 
linelen msglen reencoded 	without chance 
sha output 	run computation 
encoding raw obj 	compiler optimize 
obj force 	run less 
combine notes note 	microseconds 
existing note 	even slow 
ptr type 	hardware runs 
clr ptr type 	less microseconds 
subtree sha 	modern reporting 
prefixcmp load subtree 	program main 
free note 	latency 
search nibble ptr 	mode latency 
type clr 	distribution mode 
ptr type note 	slave mode 
search clr 	rdb mode 
ptr type subtree 	pipe mode 
sha prefixcmp 	find 
load subtree free 	big keys 
note search 	stat mode 
note search ptr 	scan mode 
type clr 	lru test 
ptr type hashcmp 	mode intrinsic 
clr ptr 	latency 
type ptr type 	mode start 
free note 	interactive mode 
search ptr 	command provided 
type ptr type 	ignore sigpipe 
clr ptr 	interactive mode 
type hashcmp hashcpy 	force 
free ptr 	reconnect note 
type nibble clr 	repl mode 
ptr type 	abort connection 
note consolidate nibble 	error attempt 
note search 	performed every 
ptr type clr 	command 
ptr type 	send otherwise 
ptr type sha 	arguments execute 
free ptr 	redisassert.h estr 
type hashcmp hashcmp 	file line 
combine notes 	redisassert drop 
sha note free 	replacemnet 
subtree sha 	prints stack 
prefixcmp load subtree 	trace redis 
free subtree 	logs file 
sha prefixcmp 	included instead 
load subtree free 	inside libraries 
note insert 	used 
ptr type ptr 	redis assertions 
type sha 	instead redis 
free xcalloc note 	disappearing sigabort 
insert ptr 	details stack 
type ptr type 	trace inside 
note insert 	log 
ptr type note 	file copyright 
free clr 	salvatore sanfilippo 
ptr type free 	antirez gmail 
clr ptr 	dot rights 
type hexval hexval 	reserved redistribution 
strcmp xmalloc 	use 
hashcpy non note 	source binary 
cmp non 	forms without 
note cmp non 	modification permitted 
note cmp 	provided following 
non note 	conditions met 
cmp strcmp hashcpy 	redistributions 
free fill 	source code 
descriptor die sha 	must retain 
hex memcpy 	copyright notice 
entry strlen sha 	list conditions 
hex segment 	following disclaimer 
xcalloc hashcpy hashcpy 	redistributions 
isdir note 	binary form 
insert die sha 	must reproduce 
hex sha 	copyright notice 
hex strbuf addch 	list conditions 
strbuf addch 	following disclaimer 
strbuf addch strbuf 	documentation 
addstr non 	materials provided 
note strbuf detach 	distribution neither 
free ptr 	name redis 
type sha hex 	names contributors 
xsnprintf determine 	may used 
fanout ptr 	endorse 
type note helper 	promote products 
clr ptr 	derived software 
type clr ptr 	without specific 
type construct 	prior written 
path fanout load 	permission software 
subtree free 	provided 
clr ptr type 	copyright holders 
construct path 	contributors express 
fanout strbuf addf 	implied warranties 
strbuf xmalloc 	including limited 
strbuf init write 	implied warranties 
stack finish 	merchantability 
subtree write sha 	fitness particular 
file strbuf 	purpose disclaimed 
release free write 	shall copyright 
entry strlen 	owner contributors 
matches write 	liable direct 
stack write stack 	indirect 
finish subtree 	incidental special 
write stack init 	exemplary consequential 
subtree memchr 	damages including 
write entry strcmp 	limited procurement 
write note 	substitute goods 
helper strlen write 	services 
non note 	loss use 
write note helper 	data profits 
sha file 	business interruption 
xmalloc sha read 	however caused 
sha file 	theory liability 
free sha read 	whether 
sha file 	contract strict 
free free hashcpy 	liability tort 
xmalloc memcpy 	including negligence 
memcpy free free 	otherwise arising 
write sha 	way use 
file free 	software 
hashcpy sha read 	even advised 
sha file 	possibility damage 
free list split 	exit rehashing.c 
free strbuf 	keyp key 
addstr strbuf addch 	privdata key 
list note 	key 
lines list note 	dict type 
lines list 	test times 
empty items list 	perfect run 
sort list 	approx run 
duplicates list write 	des requested 
sha file 	returned 
strbuf release list 	dup approx 
clear unsorted 	run exit 
list list append 	dict gen 
glob specials 	hash function 
glob sha warning 	show buckets 
unsorted list 	show 
list append 	buckets zmalloc 
xstrdup list split 	dict size 
place list 	rand dict 
empty items list 	size dict 
refs glob 	keys qsort 
list clear free 	zfree 
strcmp config 	dict create 
error nonbool list 	srand time 
refs glob 	dict show 
getenv notes xcalloc 	dict size 
xstrdup sha 	dict dict 
treeish read die 	resize 
entry die 	show dict 
sha hex hashclr 	release dict 
hashcpy load 	create dict 
subtree alloc xcalloc 	stress keys 
init notes 	dict dict 
list append notes 	resize 
getenv list 	stress keys 
refs colon 	dict release 
sep git config 	hash function 
list refs 	key dup 
glob load notes 	val dup 
trees list 	key 
clear xmalloc hashcpy 	compare key 
hashcpy note 	destructor val 
insert hashcpy hashclr 	destructor release.c 
note sha 	buildid crc 
note find note 	strlen copyright 
helper strbuf 	salvatore 
init note write 	sanfilippo antirez 
non note 	gmail dot 
write stack finish 	rights reserved 
subtree write 	redistribution use 
sha file strbuf 	source binary 
release note 	forms 
sha hex 	without modification 
note note free 	permitted provided 
free free 	following conditions 
free free memset 	met redistributions 
init notes 	source code 
note read sha 	must 
file free 	retain copyright 
encoding utf reencode 	notice list 
free strlen 	conditions following 
strcmp strbuf addstr 	disclaimer redistributions 
starts starts 	binary form 
strbuf addf strchrnul 	must 
strbuf addstr 	reproduce copyright 
strbuf strbuf addch 	notice list 
free format 	conditions following 
note note note 	disclaimer documentation 
note note 	materials provided 
starts starts strbuf 	distribution 
insert strbuf 	neither name 
insert sha 	redis names 
expand notes use 	contributors may 
non balancing 	used endorse 
simple structure node 	promote products 
nodes leaf 	derived 
node leaf nodes 	software without 
node pointers 	specific prior 
children bottom bits 	written permission 
pointer used 	software provided 
identify pointer type 	copyright holders 
ptr pointer 	contributors 
ptr ptr pointer 	express implied 
next node 	warranties including 
cast node ptr 	limited implied 
pointer note 	warranties merchantability 
entry cast leaf 	fitness particular 
node ptr 	purpose 
pointer subtree entry 	disclaimed shall 
cast leaf 	copyright owner 
node root 	contributors liable 
node statically allocated 	direct indirect 
node leaf 	incidental special 
nodes come two 	exemplary 
variants note 	consequential damages 
entries subtree entries 	including limited 
distinguished leaf 	procurement substitute 
node pointer see 	goods services 
note entry 	loss use 
key sha referenced 	data 
sha note 	profits business 
subtree entry key 	interruption however 
prefix sha 	caused theory 
trailing referenced last 	liability whether 
key store 	contract strict 
length prefix sha 	liability 
containing notes 	tort including 
subtree notes may 	negligence otherwise 
contain entries 	arising way 
notes follow 	use software 
naming conventions notes 	even advised 
typically none 	possibility 
still need keep 	damage every 
track keep 	time redis 
simple linked list 	git sha 
sorted alpha 	dirty status 
betically non note 	changes small 
path list 	file 
populated parsing objects 	recompiled access 
load subtree 	information files 
non notes correctly 	functions replication.c 
written back 	newfd slave 
objects produced write 	buf newsize 
notes grounded 	ptr 
last next search 	len thislen 
appropriate location 	llstr len 
given key 	slaves dictid 
found start root 	argv argc 
node current 	len llstr 
level matching subtree 	selectcmd 
entry unpack 	dictid len 
subtree entry restart 	slave aux 
search current 	objlen slave 
level use nth 	monitors dictid 
nibble key 	argv argc 
index node recurse 	cmdrepr 
node increment 	cmdobj monitor 
matching subtree entry 	offset skip 
unpack subtree 	len thislen 
entry restart search 	psync offset 
current level 	slave offset 
otherwise found one 	buf 
following subtree 	buflen psync 
entry match key 	offset psync 
note entry 	len master 
may may 	runid buf 
match key unused 	buflen mincapa 
leaf node 	retval 
pointer location unpack 	socket target 
resume search 	slave slave 
unpack resume search 	master runid 
fall find 	slave port 
leaf node search 	offset slave 
location appropriate 	privdata 
given key note 	mask slave 
entry matching 	buf nwritten 
key note entry 	buflen bgsaveerr 
consolidate node 	type startbgsave 
non entries give 	mincapa slave 
non zero 	buf 
otherwise replace node 	newline sent 
given index 	privdata privdata 
given parent node 	mask buf 
entry entry 	nread readlen 
entries given 	left eofmark 
one entry replace 	lastbytes 
parent index 	usemark eof 
leaf node search 	reached rem 
location appropriate 	sync size 
given leaf node 	retry flags 
key location 	arg cmd 
hold matching entry 	buf 
abort nothing 	read reply 
copy matching entry 	psync runid 
given entry 	psync offset 
replace matching leaf 	reply offset 
node entry 	privdata mask 
free leaf node 	tmpfile 
consolidate nodes 	err dfd 
repeatedly walking towards 	maxtries psync 
root type 	result errlen 
bits type mismatch 	port port 
nothing key 	client port 
mismatch nothing 	client 
found matching entry 	mbcount slaves 
consolidate level 	slave slavestate 
parent levels possible 	newfd good 
cannot consolidate 	slave lag 
top level first 	sha retval 
build stack 	key 
ancestors root current 	oldest sha 
node next 	offset count 
unwind stack note 	slave timeout 
consolidate done 	numreplicas ackreplicas 
insert leaf node 	offset last 
search location 	offset 
appropriate given leaf 	last numreplicas 
node key 	numreplicas offset 
location unused store 	replication cron 
tweaked pointer 	loops ping 
directly location holds 	argv slave 
note entry 	slave 
matches note 	idle idle 
inserted combine two 	max idle 
notes calling 	slaves waiting 
given combine notes 	mincapa slave 
function location 	anet peer 
holds note entry 	anet 
matches subtree 	format addr 
inserted unpack subtree 	snprintf snprintf 
inserted location 	server zmalloc 
location holds matching 	zfree zmalloc 
subtree entry 	server list 
unpack subtree location 	length 
restart insert 	zfree memcpy 
operation level create 	sdslen feed 
node holding 	replication backlog 
node location node 	list length 
inserted store 	server list 
node location 	length 
type bits skip 	create sdscatprintf 
concatenation entry 	sdsempty feed 
unpack entry unpack 	replication backlog 
restart insert 	list rewind 
non matching leaf 	list next 
node skip 	reply 
insertion empty note 	decr count 
free entire 	feed replication 
notes data contained 	backlog len 
given fall 	feed replication 
convert sha hex 	backlog feed 
corresponding sha 	replication 
hex sha segment 	backlog feed 
ascii hex 	replication backlog 
format hex len 	list rewind 
length segment 	list next 
must multiple sha 	reply multi 
sha written 	bulk 
sha len 	len reply 
max bytes store 	bulk sdsnew 
sha must 	gettimeofday sdscatprintf 
hex len returns 	sdscatprintf sdscatprintf 
error invalid 	sdscatprintf client 
arguments invalid sha 	peer 
hex format 	sdscatprintf sdscatrepr 
otherwise returns number 	sdslen sdscatlen 
bytes written 	sdscatlen create 
sha hex len 	list rewind 
pads sha 	list next 
sha len included 	reply 
returned length 	decr count 
note takes ownership 	server log 
path nothing 	server log 
sorts first non 	server log 
note sorts 	server log 
equal overwrite sorts 	server 
next entry 	log server 
path sha 	log server 
sha complete len 	log server 
note sha 	log server 
incomplete len current 	log server 
component consists 	log 
hex chars note 	reply sds 
subtree subtree 	sdsnewlen snprintf 
determine full path 	write free 
non note 	client strcasecmp 
entry filename already 	server log 
found entry 	server 
path directory part 	log replication 
path must 	slave name 
deduced subtree containing 	reply server 
entry overall 	log replication 
notes follows strict 	slave name 
progressive fanout 	server 
structure etc fanouts 	log replication 
fanout means 	slave name 
non note 	list node 
found path dead 	tail snprintf 
beef following 	write free 
code found beef 	client 
hand use 	reply replication 
non obvious non 	backlog server 
note paths 	log replication 
middle notes deserve 	slave name 
coming note 	refresh good 
non notes sha 	slaves 
like top 	count server 
level problems conclude 	log rdb 
strongly advised 	save slaves 
make sure non 	sockets rdb 
notes least 	save background 
one non hex 	server 
character top 	log list 
level path 	rewind list 
component determine optimal 	next list 
disk fanout 	del node 
part notes given 	reply 
sub level 	error list 
structure determine whether 	rewind list 
given existing 	next replication 
fanout expanded sub 	setup slave 
values fanout 	full resync 
variable fanout notes 	psync 
stored directly 	initial offset 
root notes fanout 	replication script 
fanout fanout 	cache flush 
etc following simple 	reply error 
heuristic works 	client pending 
well practice even 	replies 
numbered level 	reply error 
remember disk fanout 	server log 
level corresponds 	replication slave 
two levels 	name strcasecmp 
peek entries level 	master resynchronization 
either nodes 	anet 
subtree entries likely 	disable tcp 
plenty notes 	delay list 
level incremented fanout 	node tail 
hex sha 	list rewind 
nul recurse node 	list next 
subtree entries 	copy 
note represent parts 	client output 
note yet 	buffer replication 
explored direct relationship 	setup slave 
subtree entries 	full resync 
level fanout variable 	server log 
subtree entries 	server 
level fanout preserved 	log server 
since correspond 	log server 
exactly fanout directory 	log start 
disk structure 	bgsave replication 
however subtree 	list length 
entries level fanout 	create 
preserved rather 	replication backlog 
consolidated notes level 	reply strcasecmp 
achieve unconditionally 	reply strcasecmp 
unpacking subtree entries 	strcasecmp strcasecmp 
exist threshold 	put slave 
level fanout invoke 	online 
callback subtree 	strcasecmp replication 
create trailing slash 	send ack 
needed unpack 	reply error 
subtree resume traversal 	format reply 
path subtree 	create file 
next entries per 	server 
determine common 	log strerror 
part write stack 	free client 
tws point 	refresh good 
last matching write 	slaves count 
stack entry 	server log 
start subtrees 	replication 
needed satisfy path 	slave name 
directory components 	unused unused 
given path given 	write sdslen 
entry current 	server log 
nothing prefer note 	strerror free 
non note 	client 
subtree entry weave 	sdsrange sdslen 
non note 	sdsfree lseek 
entries note entries 	read server 
nothing note 	log strerror 
failed find prune 	free client 
note read 	write 
note blob objects 	server log 
separate notes 	strerror free 
two newlines anyway 	client close 
concatenate cur 	file put 
msg msg buf 	slave online 
create blob 	list 
buf lines 	rewind list 
named list trailing 	next server 
newlines removed 	log replication 
read sha file 	slave name 
nul terminates 	free client 
last line file 	server 
eol terminated 	log open 
empty list removed 	redis fstat 
later along 	free client 
empty came empty 	server log 
lines within 	strerror sdscatprintf 
file read note 	sdsempty 
blob objects 	file create 
unique lines create 	file free 
blob sort 	client start 
uniq list list 	bgsave replication 
argument must 	time time 
strdup core 	write 
notes config note 	unused replication 
removed prepare 	send newline 
traversal current notes 	master create 
last forward 	client memcpy 
entry list grounded 	unused unused 
entries write 	unused 
objects representing current 	sync read 
notes fill 	line server 
given strbuf notes 	log strerror 
associated given 	server log 
given notes structure 	server log 
initialized initialized 	strncmp 
see documentation init 	strlen memcpy 
notes given 	memset server 
notes notes used 	log strtol 
instead raw 	server log 
gives userformat otherwise 	read server 
note message 	log 
given human 	strerror cancel 
consumption end annotation 	replication handshake 
newline anyway 	memcpy memmove 
happy fallback expand 	memcpy memcmp 
notes builtin 	write server 
git notes copyright 	log 
johan herland 	strerror ftruncate 
johan herland net 	server log 
git notes 	strerror rdb 
johannes schindelin builtin 	fsync range 
tag kristian 	rename server 
gsberg carlos rica 	log 
invoke git 	strerror cancel 
show stat notes 	replication handshake 
write message 	server log 
editing redirect edit 	signal flushed 
subcommand end 	empty file 
none given original 	server 
args therefore 	log rdb 
still argv 	load server 
append buf previous 	log cancel 
note contents 	replication handshake 
git notes merge 	zfree close 
git notes 	replication 
merge call notes 	create master 
merge abort 	client server 
git notes merge 	log stop 
worktree read 	append start 
merge result git 	append server 
notes merge 	log 
target notes git 	sleep server 
notes merge 	log exit 
reuse existing commit 	cancel replication 
message reflog 	handshake sdsempty 
message skip notes 	start arg 
merge resulted 	sdslen 
trivially result sha 	sdscatlen sdscat 
update notes 	sdscatlen sync 
commit merge 	write sdslen 
unresolved conflicts update 	sdsfree sdscatprintf 
git notes 	sdsempty strerror 
merge merge result 	sdsfree 
store updated 	end sync 
git notes merge 	read line 
non zero 	sdscatprintf sdsempty 
conflicts git notes 	strerror sdsnew 
usage git 	snprintf server 
notes list usage 	log 
git notes 	server log 
usage git notes 	memcpy send 
copy usage 	synchronous command 
git notes append 	server log 
usage git 	sdsfree file 
notes edit usage 	send 
git notes 	synchronous command 
show usage 	sdslen sdsfree 
git notes merge 	file strncmp 
usage git 	strchr strchr 
notes usage git 	server log 
notes prune 	memset 
usage git notes 	memcpy strtoll 
usage note 	server log 
given use editor 	replication discard 
edit path 	cached master 
buf sha note 	sdsfree strncmp 
sha note 	server 
path data sha 	log sdsfree 
size buf 	replication resurrect 
show args show 	cached master 
buf cbuf 	strncmp server 
old note buf 	log server 
sha opt 	log 
arg unset opt 	sdsfree replication 
arg unset 	discard cached 
opt arg 	master unused 
unset buf len 	unused unused 
opt arg 	close getsockopt 
unset force rewrite 	server 
cmd buf 	log strerror 
ret msg obj 	server log 
obj split 	file send 
err subcommand flags 	synchronous command 
argc argv 	send synchronous 
prefix note retval 	command 
options argc 	strncmp strncmp 
argv prefix argc 	server log 
argv prefix 	sdsfree server 
allow empty note 	log sdsfree 
note options 	send synchronous 
argc argv prefix 	command 
stdin note 	send synchronous 
note obj rewrite 	command server 
cmd options 	log sdsfree 
argc argv 	sdsfree sdsfromlonglong 
prefix allow empty 	send synchronous 
note note 	command 
logmsg usage options 	sdsfree sdsfree 
edit size 	send synchronous 
prev buf argc 	command server 
argv prefix 	log sdsfree 
note retval options 	send synchronous 
show args 	command 
ret msg sha 	sdsfree send 
parent sha 	synchronous command 
pretty ctx local 	server log 
free ret 	sdsfree slave 
git config notes 	resynchronization sdsnew 
strategy argc 	server 
argv prefix msg 	log slave 
result sha 	resynchronization server 
abort result strategy 	log disconnect 
options merge 	slaves free 
key existing 	replication backlog 
name flag status 	server 
sha argc 	log sync 
argv prefix flag 	write server 
stdin options 	log strerror 
retval argc argv 	snprintf getpid 
prefix verbose 	open sleep 
options argc argv 	server 
prefix options 	log strerror 
argc argv prefix 	create file 
result notes 	server log 
options unlink warn 	strerror zstrdup 
free strbuf 	file close 
release sha hex 	server 
sha hex 	log sdsfree 
read sha file 	anet tcp 
write die 	non block 
free start 	best effort 
command die sha 	bind connect 
hex strbuf 	server 
read die errno 	log strerror 
strbuf commented 	create file 
lines write die 	close server 
strbuf release 	log file 
strbuf release finish 	close server 
command die 	undo 
sha hex git 	connect master 
pathdup open 	close unlink 
die errno write 	zfree replication 
die copy 	abort sync 
obj strbuf addch 	transfer slave 
strbuf commented 	handshake 
lines strlen strbuf 	state undo 
addch write 	connect master 
die write commented 	sdsfree sdsnew 
close strbuf 	free client 
release strbuf 	disconnect blocked 
reset launch editor 	clients 
die strbuf 	disconnect slaves 
stripspace write sha 	replication discard 
file error 	cached master 
error exit strbuf 	free replication 
grow strlen 	backlog cancel 
strbuf addch strbuf 	replication 
addstr strbuf 	handshake sdsfree 
stripspace strbuf addch 	list length 
strcmp strbuf 	free replication 
read die errno 	backlog free 
strbuf read 	client replication 
file die errno 	discard 
strbuf stripspace 	cached master 
strbuf addch sha 	cancel replication 
die read 	handshake reply 
sha file free 	error strcasecmp 
die free 	strcasecmp replication 
die strbuf 	unset 
free parse reuse 	master cat 
arg init 	client info 
copy notes rewrite 	sdsempty server 
init notes 	log sdsfree 
strbuf getline strbuf 	reply strcasecmp 
split die 	server 
strbuf rtrim strbuf 	log reply 
rtrim sha 	sds sdsnew 
die sha die 	replication master 
copy note 	cat client 
rewrite copy note 	info sdsempty 
error strbuf 	server 
list free commit 	log sdsfree 
notes free 	reply reply 
notes finish copy 	multi bulk 
notes rewrite 	len reply 
init notes starts 	bulk buffer 
die parse 	reply 
options error 	deferred multi 
usage options init 	bulk length 
notes check 	list rewind 
sha die note 	list next 
puts sha 	anet peer 
hex error sha 	reply 
hex note 	multi bulk 
free notes parse 	len reply 
options error 	bulk reply 
usage options sha 	bulk reply 
die init 	bulk deferred 
notes check note 	multi 
free notes 	bulk length 
free note data 	reply multi 
error sha 	bulk len 
hex append edit 	reply bulk 
sha hex 	buffer reply 
prepare note data 	bulk 
write note 	reply slave 
data note 	handshake state 
die commit notes 	reply bulk 
sha hex 	reply reply 
note commit notes 	multi bulk 
free note 	len 
data free notes 	reply bulk 
parse options 	reply bulk 
error usage options 	reply bulk 
notes copy 	server server 
stdin error usage 	log unlink 
options error 	client 
usage options sha 	sdsfree replication 
die sha 	handle master 
die init notes 	disconnection server 
check note 	log free 
error sha hex 	client list 
sha hex 	node 
note error 	tail create 
sha hex note 	file server 
die commit 	log strerror 
notes free notes 	free client 
strcmp parse 	client pending 
options error usage 	replies 
options sha 	create file 
die init notes 	server log 
check note 	strerror free 
prepare note data 	client list 
read sha 	rewind list 
file strbuf grow 	next 
strbuf insert 	dict create 
strbuf insert free 	list create 
write note 	dict empty 
data note die 	list release 
snprintf sha 	list create 
hex note snprintf 	sdsdup 
commit notes 	list length 
free note 	list last 
data free notes 	list node 
parse options 	dict server 
error usage options 	list del 
sha die 	node 
init notes check 	dict list 
note error 	node head 
sha hex execv 	server dict 
git cmd 	find list 
free notes error 	rewind list 
error notes 	next 
merge abort error 	reply timeout 
sha die 	reply replication 
lookup commit reference 	count acks 
die parse 	offset reply 
commit die hashcpy 	list node 
hashclr xcalloc 	tail 
init notes resolve 	block client 
refdup die 	replication request 
notes merge 	ack slaves 
commit die memset 	list search 
format commit 	key server 
message strbuf trim 	list 
strbuf insert 	del node 
update sha free 	list rewind 
notes strbuf 	list next 
release merge abort 	unblock client 
free parse 	reply replication 
options error usage 	count 
options error 	acks offset 
usage options error 	unblock client 
usage options 	reply slave 
init notes merge 	handshake state 
options merge 	time server 
abort merge commit 	log 
notes strbuf 	cancel replication 
addstr expand loose 	handshake time 
notes init 	server log 
notes check 	cancel replication 
parse notes merge 	handshake time 
strategy error 	server 
usage options skip 	log free 
prefix die 	client server 
strbuf addf git 	log connect 
config notes 	master server 
strategy git config 	log replication 
notes strategy 	send 
strbuf release strbuf 	ack create 
addf notes 	replication feed 
strbuf notes merge 	slaves decr 
update notes 	count list 
update find shared 	rewind list 
symref notes 	next 
die notes create 	write list 
symref notes 	length list 
die notes 	rewind list 
git path free 	next server 
notes strbuf 	log replication 
release strbuf release 	slave 
sha error 	name free 
note parse options 	client list 
init notes 	length free 
check one note 	replication backlog 
one note 	server log 
strbuf getwholeline strbuf 	list 
rtrim one 	length list 
note strbuf release 	length replication 
commit notes 	script cache 
free notes parse 	flush list 
options error 	rewind list 
usage options init 	next 
notes check 	start bgsave 
prune notes commit 	replication refresh 
notes free 	good slaves 
notes parse 	count asynchronous 
options error usage 	replication implementation 
options puts 	copyright 
notes git config 	salvatore sanfilippo 
parse options 	antirez gmail 
strbuf addstr expand 	dot rights 
notes setenv 	reserved redistribution 
strbuf release strcmp 	use source 
list strcmp 	binary 
strcmp copy strcmp 	forms without 
strcmp append 	modification permitted 
edit strcmp show 	provided following 
strcmp merge 	conditions met 
strcmp cmd strcmp 	redistributions 
prune strcmp 	source code 
error usage options 	must retain 
use non 	copyright notice 
balancing simple structure 	list conditions 
node nodes 	following disclaimer 
leaf node 	redistributions 
leaf nodes node 	binary form 
pointers children 	must reproduce 
bottom bits pointer 	copyright notice 
used identify 	list conditions 
pointer type ptr 	following disclaimer 
pointer ptr 	documentation 
ptr pointer next 	materials provided 
node cast 	distribution neither 
node ptr pointer 	name redis 
note entry 	names contributors 
cast leaf node 	may used 
ptr pointer 	endorse 
subtree entry cast 	promote products 
leaf node 	derived software 
root node statically 	without specific 
allocated node 	prior written 
leaf nodes come 	permission software 
two variants 	provided 
note entries 	copyright holders 
subtree entries distinguished 	contributors express 
leaf node 	implied warranties 
pointer see note 	including limited 
entry key 	implied warranties 
sha referenced sha 	merchantability 
note subtree 	fitness particular 
entry key prefix 	purpose disclaimed 
sha trailing 	shall copyright 
referenced last key 	owner contributors 
store length 	liable direct 
prefix sha containing 	indirect 
notes subtree 	incidental special 
notes may contain 	exemplary consequential 
entries notes 	damages including 
follow naming conventions 	limited procurement 
notes typically 	substitute goods 
none still 	services 
need keep track 	loss use 
keep simple 	data profits 
linked list sorted 	business interruption 
alpha betically 	however caused 
non note path 	theory liability 
list populated 	whether 
parsing objects load 	contract strict 
subtree non 	liability tort 
notes correctly written 	including negligence 
back objects 	otherwise arising 
produced write notes 	way use 
grounded last 	software 
next search appropriate 	even advised 
location given 	possibility damage 
key found start 	utility functions 
root node 	pointer representing 
current level matching 	slave listening 
subtree entry 	port 
unpack subtree 	pair mostly 
entry restart search 	useful logging 
current level 	since want 
use nth nibble 	log slave 
key index 	address listening 
node recurse node 	port 
increment matching 	clear user 
subtree entry unpack 	example closing 
subtree entry 	connection slave 
restart search current 	master backlog 
level otherwise 	buffer created 
found one following 	increment 
subtree entry 	replication offset 
match key note 	one make 
entry may 	sure able 
may match key 	psync previous 
unused leaf 	slave needed 
node pointer location 	avoid 
unpack resume 	incrementing master 
search unpack 	repl offset 
resume search fall 	backlog exists 
find leaf 	slaves attached 
node search location 	data inside 
appropriate given 	buffer 
key note entry 	virtually first 
matching key 	next generated 
note entry consolidate 	replication stream 
node non 	function called 
entries give non 	user modifies 
zero otherwise 	replication 
replace node given 	backlog size 
index given 	runtime function 
parent node entry 	update server 
entry entries 	repl backlog 
given one entry 	size resize 
replace parent 	buffer 
index leaf node 	setup contains 
search location 	data previous 
appropriate given 	one possibly 
leaf node key 	less data 
location hold 	recent bytes 
matching entry abort 	data 
nothing copy 	free space 
matching entry given 	buffer enlarged 
entry replace 	actually flush 
matching leaf node 	old buffer 
entry free 	realloc empty 
leaf node consolidate 	one 
nodes repeatedly 	refill data 
walking towards root 	incrementally reason 
type bits 	copying gigabytes 
type mismatch nothing 	adds latency 
key mismatch 	even worse 
nothing found matching 	often 
entry consolidate 	need alloc 
level parent levels 	additional space 
possible cannot 	freeing old 
consolidate top 	buffer next 
level first build 	next since 
stack ancestors 	buffer 
root current node 	empty data 
next unwind 	replication backlog 
stack note consolidate 	function also 
done insert 	increments replication 
leaf node search 	offset stored 
location appropriate 	server 
given leaf node 	master repl 
key location 	offset want 
unused store tweaked 	feed backlog 
pointer directly 	without incrementing 
location holds note 	buffer circular 
entry matches 	buffer 
note inserted combine 	write much 
two notes 	data every 
calling given 	iteration rewind 
combine notes function 	idx index 
location holds 	reach limit 
note entry matches 	offset 
subtree inserted 	first backlog 
unpack subtree inserted 	wrapper feed 
location location 	replication backlog 
holds matching subtree 	takes redis 
entry unpack 	objects input 
subtree location restart 	aren 
insert operation 	slaves backlog 
level create node 	buffer populate 
holding node 	asap slaves 
location node inserted 	attached backlog 
store node 	send command 
location type bits 	every 
skip concatenation 	slave needed 
entry unpack entry 	pre computed 
unpack restart 	command command 
insert non 	backlog send 
matching leaf node 	slaves write 
skip insertion 	command 
empty note free 	replication backlog 
entire notes 	multi bulk 
data contained given 	reply length 
fall convert 	need feed 
sha hex corresponding 	buffer bulk 
sha hex 	reply 
sha segment ascii 	plain create 
hex format 	crlf payload 
hex len length 	len crlf 
segment must 	write command 
multiple sha sha 	every slave 
written sha 	feed 
len max bytes 	slaves still 
store sha 	waiting bgsave 
must hex len 	start feed 
returns error 	slaves waiting 
invalid arguments 	initial sync 
invalid sha hex 	commands 
format otherwise 	queued output 
returns number bytes 	buffer initial 
written sha 	sync completes 
hex len pads 	already sync 
sha sha 	master multi 
len included returned 	bulk 
length note 	length additional 
takes ownership path 	argument stored 
nothing sorts 	inside buffer 
first non note 	argc feed 
sorts equal 	slave replication 
overwrite sorts next 	backlog 
entry path 	starting specified 
sha sha complete 	offset end 
len note 	backlog compute 
sha incomplete len 	amount bytes 
current component 	need discard 
consists hex 	point 
chars note subtree 	oldest actaully 
subtree determine 	server repl 
full path non 	backlog discard 
note entry 	amount data 
filename already found 	seek specified 
entry path 	offset 
directory part path 	feed slave 
must deduced 	data since 
subtree containing entry 	circular buffer 
overall notes 	split reply 
follows strict progressive 	two parts 
fanout structure 	cross 
etc fanouts fanout 	boundary offset 
means non 	provide reply 
note found path 	psync command 
dead beef 	received slave 
following code 	returned valid 
found beef hand 	immediately 
use non 	bgsave process 
obvious non note 	started executing 
paths middle 	command clients 
notes deserve coming 	psync offset 
note non 	replication backlog 
notes sha like 	exists 
top level 	created later 
problems conclude strongly 	increment offset 
advised make 	one send 
sure non notes 	fullresync reply 
least one 	specific full 
non hex character 	resynchronization 
top level 	side effect 
path component determine 	setup slave 
optimal disk 	full sync 
fanout part notes 	different ways 
given sub 	remember slave 
level structure 	client 
determine whether given 	structure offset 
existing fanout 	sent slaves 
expanded sub values 	later attach 
fanout variable 	background rdb 
fanout notes stored 	saving process 
directly root 	duplicating 
notes fanout fanout 	client output 
fanout etc 	buffer right 
following simple heuristic 	offset slave 
works well 	replication state 
practice even numbered 	slave wait 
level remember 	bgsave 
disk fanout level 	end start 
corresponds two 	accumulating differences 
levels peek entries 	point force 
level either 	replication stream 
nodes subtree entries 	emit statement 
likely plenty 	slave 
notes level 	incremental differences 
incremented fanout hex 	start selecting 
sha nul 	right database 
recurse node subtree 	number normally 
entries note 	function called 
represent parts note 	immediately 
yet explored 	successful bgsave 
direct relationship subtree 	replication started 
entries level 	one already 
fanout variable subtree 	progress attached 
entries level 	slave going 
fanout preserved since 	accumulate 
correspond exactly 	incremental changes 
fanout directory disk 	slave well 
structure however 	slaveseldb order 
subtree entries level 	force emit 
fanout preserved 	sleect statement 
rather consolidated notes 	replication 
level achieve 	stream send 
unconditionally unpacking 	reply slaves 
subtree entries exist 	approached old 
threshold level 	sync command 
fanout invoke callback 	function handles 
subtree create 	psync 
trailing slash needed 	command point 
unpack subtree 	view master 
resume traversal path 	receiving request 
subtree next 	resynchronization success 
entries per determine 	otherwise err 
common part 	returned 
write stack tws 	proceed usual 
point last 	full resync 
matching write stack 	runid master 
entry start 	advertised wannabe 
subtrees needed satisfy 	slave via 
path directory 	psync 
components given 	runid changed 
path given entry 	master different 
current nothing 	instance way 
prefer note non 	run used 
note subtree 	slaves want 
entry weave non 	force 
note entries 	full resync 
note entries nothing 	still data 
note failed 	slave asking 
find prune note 	reached point 
read note 	able perform 
blob objects separate 	resync 
notes two 	client state 
newlines anyway concatenate 	make slave 
cur msg 	inform client 
msg buf create 	send backlog 
blob buf 	data offset 
lines named list 	end 
trailing newlines 	slave use 
removed read 	connection buffers 
sha file nul 	since used 
terminates last 	accumulate commands 
line file eol 	stage sure 
terminated empty 	socket 
list removed later 	send buffer 
along empty 	empty write 
came empty lines 	never fail 
within file 	actually note 
read note blob 	need selected 
objects unique 	server 
lines create blob 	slaveseldb force 
sort uniq 	master emit 
list list argument 	since slave 
must strdup 	already state 
core notes config 	previous connection 
note removed 	master 
prepare traversal current 	caller full 
notes last 	resync needed 
forward entry 	need full 
list grounded entries 	resync reason 
write objects 	note reply 
representing current notes 	psync 
fill given 	right full 
strbuf notes associated 	sync needed 
given given 	reply must 
notes structure initialized 	include master 
initialized see 	offset time 
documentation init notes 	rdb 
given notes 	file transfer 
notes used instead 	generated need 
raw gives 	delay reply 
userformat otherwise note 	moment start 
message given 	bgsave replication 
human consumption end 	goals 
annotation newline 	selecting disk 
anyway happy fallback 	socket target 
expand notes 	depending configuration 
builtin git 	making sure 
notes copyright johan 	script cache 
herland johan 	flushed 
herland net git 	start mincapa 
notes johannes 	argument bitwise 
schindelin builtin tag 	among slaves 
kristian gsberg 	capabilities slaves 
carlos rica invoke 	waiting bgsave 
git show 	represents 
stat notes write 	slave capabilities 
message editing 	slaves support 
redirect edit subcommand 	tested via 
end none 	slave capa 
given original args 	macros side 
therefore still 	effects 
argv append buf 	starting bgsave 
previous note 	handle slaves 
contents git notes 	wait start 
merge git 	state preparing 
notes merge 	full sync 
call notes merge 	bgsave 
abort git 	succesfully started 
notes merge worktree 	sending error 
read merge 	dropping list 
result git notes 	slaves flush 
merge target 	lua scripting 
notes git notes 	script 
merge reuse 	cache bgsave 
existing commit message 	actually started 
reflog message 	returns success 
skip notes merge 	err otherwise 
resulted trivially 	failed bgsave 
result sha update 	slaves 
notes commit 	waiting full 
merge unresolved conflicts 	resynchorinization list 
update git 	salves inform 
notes merge 	error happened 
merge result store 	close connection 
updated git 	asap 
notes merge non 	target socket 
zero conflicts 	rdb save 
notes.h cur sha 	slaves sockets 
sha cur 	already setup 
sha sha cur 	salves full 
sha sha 	resync 
cur sha sha 	otherwise disk 
root first 	target flush 
non note prev 	script cache 
non note 	since need 
update combine notes 	slave differences 
initialized dirty 	accumulated 
notes combine notes 	without requiring 
flags sha 	slaves match 
note sha combine 	cached scripts 
notes sha 	sync psync 
sha obj 	command implemenation 
obj force combine 	ignore 
notes flags 	sync already 
data result flags 	slave monitor 
use notes 	mode refuse 
extra notes refs 	sync requests 
opt sha 	slave link 
output encoding raw 	master 
refs flags 	sync issued 
list glob list 	server pending 
globs function 	data send 
type combining two 	client already 
notes annotating 	issued commands 
adding note annotating 	need 
existing note 	fresh reply 
caller decide combine 	buffer registering 
two notes 	differences bgsave 
decision made passing 	current dataset 
function following 	copy slaves 
form function 	needed 
accepts two sha 	resynchronization psync 
existing note 	command fails 
note respectively function 	usual full 
combines notes 	resynchronization however 
whatever way sees 	happens master 
fit writes 	resynchronization 
resulting sha first 	already replied 
sha argument 	fullresync runid 
cur sha non 	offset slave 
zero indicates 	knows runid 
failure two given 	offset psync 
sha shall 	later 
non different either 	connection master 
may sha 	lost full 
indicates empty non 	resync needed 
existent note 	increment stats 
resulting sha cur 	failed 
sha sha 	psyn runid 
note removed 	used slaves 
notes combine notes 	force full 
function passing 	resync purpose 
combine notes concatenate 	albe partially 
appends contents 	resync 
note contents existing 	slave uses 
note common 	sync dealing 
notes combinators notes 	old implementation 
encapsulates notes 	replication protocol 
structure associated notes 	like redis 
whenever notes 	cli 
pointer required may 	slave flag 
pass order 	client expect 
use notes need 	receive replconf 
pass non 	ack feedbacks 
need refer several 	full resynchronization 
different notes 	setup 
trees simultaneously 	slave one 
notes notes notes 	waiting bgsave 
used notes 	start following 
passed init notes 	code paths 
first following 	change state 
defined option git 	handle 
notes given 	slave differently 
git notes environment 	non critical 
variable core 	fails bgsave 
notes config variable 	progress disk 
git notes 	target background 
refs notes commits 	save 
flags controlling 	progress check 
behaviour notes initialization 	good one 
behaviour initialize 	replication another 
notes specified given 	slave registering 
notes notes 	differences since 
readable notes treeish 	server 
notes however 	forked save 
made writable 	attach slave 
flag strict names 	check least 
used initialize 	capabilities slave 
given notes notes 	triggered current 
structure given 	bgsave 
given git notes 	perfect server 
environment variable 	already registering 
used missing notes 	differences another 
used refs 	slave right 
notes commits need 	state copy 
initialize notes 	buffer 
structure switching one 	way need 
notes another 	wait next 
must first initialize 	bgsave order 
notes structure 	differences bgsave 
calling free notes 	progress socket 
notes pass 	target 
notes initialized combine 	rdb child 
notes function 	process writing 
passed becomes 	directly children 
combine notes function 	sockets need 
given notes 	wait next 
passed combine notes 	bgsave 
function combine 	order synchronize 
notes concatenate precondition 	bgsave progress 
notes structure 	diskless replication 
zeroed achieved memset 	rdb child 
notes given 	created inside 
note given notes 	replication 
structure already 	cron since 
exists note given 	want delay 
sha given 	start seconds 
combine notes function 	wait slaves 
invoked tie 	arrive target 
given combine notes 	disk 
combine notes 	slave capable 
function given notes 	supporting diskless 
used passing 	replication bgsave 
note sha 	progress start 
sha indicates addition 	one replconf 
empty non 	option 
existent note potentially 	option command 
expensive unless 	used slave 
already exists note 	order configure 
given sha 	replication process 
combining note empty 	starting sync 
note given 	command 
combine notes function 	currently use 
results changed 	command communicate 
note returns zero 	master listening 
success non 	port slave 
zero means combine 	redis instance 
notes failed 	master 
important changes made 	accurately list 
note given 	slaves listening 
notes structure 	ports info 
persistent subsequent call 	output future 
write notes 	command used 
returns zero given 	order 
note given 	configure replication 
notes structure important 	initiate incremental 
changes made 	replication instead 
note given notes 	full resync 
structure persistent 	number arguments 
subsequent call write 	must 
notes returns 	odd make 
zero note removed 	sure every 
note note 	option corresponding 
sha containing note 	process every 
data given 	option pair 
given notes copy 	ignore 
note one 	capabilities understood 
another given notes 	master replconf 
returns obj 	ack used 
already note 	slave inform 
force otherwise returns 	master amount 
non zero 	replication 
force given combine 	stream processed 
notes function 	far command 
failed combine obj 	normal clients 
note obj 	never use 
existing note returns 	diskless replication 
zero success 	need 
important changes made 	really put 
copy note 	slave online 
given notes structure 	first ack 
persistent subsequent 	received confirms 
call write notes 	slave online 
returns zero 	ready 
flags controlling behaviour 	data note 
note behaviour 	command reply 
note traverse every 	anything replconf 
single note 	getack used 
given notes 	order request 
unpacking subtree entries 	ack 
along way 	asap slave 
following flags used 	note command 
alter behaviour 	reply anything 
dont unpack subtrees 	function puts 
causes note 	slave online 
unpack recurse subtree 	state 
entries traversing 	called slave 
notes causes notes 	received rdb 
within subtrees 	file initial 
passed callback use 	synchronization ready 
flag want 	send incremental 
traverse notes want 	stream 
traverse parts 	commands things 
notes already unpacked 	put slave 
includes least 	online state 
notes added changed 	useless function 
subtrees causes 	called state 
subtree entries 	already 
encountered passed callback 	online repl 
recursing subtree 	put online 
entries note objects 	ack make 
represent intermediate 	sure writable 
directories notes passed 	installed since 
callback subtree 	calling 
entries trailing slash 	sync command 
path callback 	disables accumulate 
may use differentiate 	output buffer 
note entries 	without sending 
subtree entries note 	slave update 
already unpacked 	count 
subtree entries part 	good slaves 
notes therefore 	prevent timeout 
yielded flag used 	sending rdb 
together dont 	file send 
unpack subtrees note 	preamble configured 
subtree entry 	replication 
recurse invoke 	process currently 
specified callback function 	preamble bulk 
note given 	count file 
notes callback returns 	form length 
nonzero note 	fall sending 
walk aborted callback 	data 
returned note 	preamble already 
hence zero note 	transfered send 
indicates notes 	rdb bulk 
walked successfully important 	data function 
callback function 	called end 
allowed change notes 	every 
words following 	background saving 
functions invoked current 	replication rdb 
notes within 	transfer strategy 
callback note note 	modified disk 
copy note 	socket way 
free notes 	around 
write given notes 	goal function 
structure database 	handle slaves 
creates encapsulating current 	waiting successful 
state given 	background saving 
notes stores sha 	order perform 
result argument 	non 
returns zero success 	blocking synchronization 
non zero 	schedule bgsave 
failure important changes 	slaves attached 
made given 	bgsave progress 
notes persistent function 	good one 
returned zero 	replication 
please also remember 	slave accumulating 
create corresponding 	differences argument 
commit update appropriate 	bgsaveerr background 
notes flags 	saving succeeded 
controlling operation prune 	otherwise err 
notes annotating 	passed 
non existing 	function type 
objects given notes 	argument type 
notes given 	child terminated 
notes associated objects 	disk socket 
longer exist 	target rdb 
database removed notes 	disk 
important changes 	save prepare 
made prune notes 	send rdb 
given notes 	disk slave 
structure persistent subsequent 	socket otherwise 
call write 	already rdb 
notes returns zero 	slaves 
free initialize 	socket transfer 
given notes structure 	used diskless 
important changes 	replication work 
made given notes 	trivial put 
since last 	slave online 
successful call write 	note 
notes lost 	wait replconf 
load notes 	ack message 
machinery displaying several 	slave order 
notes trees 	really put 
opt specifies additional 	online install 
settings displaying 	write 
suppress notes indicates 	handler accumulated 
notes core 	data transfered 
notes notes display 	however change 
loaded extra 	replication state 
notes refs may 	asap since 
contain list 	slave 
globs style notes 	technically online 
display notes 	timeout otherwise 
loaded append notes 	slave returns 
given sha 	given replication 
trees init display 	state handshake 
notes flags 	state 
bitwise combination notes 	otherwise avoid 
show header 	master detect 
notes refname 	slave timing 
header notes indent 	loading rdb 
indent notes 	file initial 
places must call 	synchronization 
init display 	send single 
notes function load 	newline character 
notes listed 	valid protocol 
refs output notes 	guaranteed either 
terminated refs 	sent entierly 
match glob list 	since 
refs colon 	indivisible function 
separated glob list 	called two 
globs end 	contexts flush 
list empty components 	current data 
ignored helper 	empty load 
used parse git 	data 
notes display 	received rdb 
style environment 	file master 
variables expand inplace 	pinging back 
note like 	stage best 
foo notes foo 	effort callback 
refs notes 	used 
foo similar expand 	empty flushing 
notes check 	away old 
whether located via 	data load 
sha first 	dataset received 
falls back expand 	master link 
notes sha 	master 
fails object.c obj 	synchroniziation performed 
hash objs 	function materializes 
obj hash size 	master client 
idx type 	store server 
type str len 	master starting 
gentle sha 	specified 
obj hash size 	file descriptor 
sha first 	master offset 
obj tmp 	master old 
hash size hash 	psync capable 
obj sha 	flag accordingly 
obj type sha 	asynchronously 
obj parse 	read sync 
buffer sha name 	payload receive 
sha size 	master vars 
eaten repl buffer 	used hold 
obj item 	eof mark 
list list list 	last 
obj slopbuf 	bytes received 
obj name mode 	form server 
path alloc 	match reached 
objects entry obj 	end transfer 
name ent 	repl transfer 
want data src 	size 
dst objects 	still read 
name src objects 	bulk length 
flags obj 	master reply 
size strlen 	stage newline 
size strncmp die 	works ping 
sha hash 	order 
hash obj hash 	take connection 
obj hashcmp 	live refresh 
xcalloc insert obj 	last interaction 
hash free 	timestamp two 
hashcpy grow hash 	possible forms 
insert obj 	bulk 
hash lookup create 	payload one 
alloc node 	usual count 
parse die sha 	bulk format 
hex lookup 	used diskless 
replace lookup sha 	transfers master 
file sha 	know 
info check sha 	beforehand size 
signature error 	file transfer 
sha hex parse 	latter following 
blob buffer 	format used 
lookup blob 	eof bytes 
lookup read sha 	delimiter 
file check 	end file 
sha signature free 	announced delimiter 
error sha 	transmitted delimiter 
hex parse buffer 	random enough 
free xmalloc 	probability collision 
realloc xstrdup xstrdup 	actual 
path free 	file content 
free want release 	ignored repl 
entry release 	transfer size 
entry free strcmp 	avoid entering 
contains name 	code path 
release entry obj 	next 
none obj 	call read 
commit obj obj 	bulk data 
blob obj 	mark used 
tag numerical 	want detect 
hash specified sha 	eof asap 
must power 	order 
please note consistent 	avoid writing 
across computer 	eof mark 
architectures insert obj 	file update 
hash table 	last bytes 
hash length size 	check matches 
must power 	delimiter 
collisions simply overflow 	last bytes 
next empty 	file reached 
bucket look record 	eof sync 
given sha 	data disk 
hash map stored 	time time 
obj hash 	otherwise 
found move started 	end transfer 
look need 	may suffer 
walk hash table 	big delay 
next time 	memory buffers 
look increase 	copied actual 
size hash map 	disk 
stored obj 	check transfer 
hash next power 	complete loading 
least copy 	memory need 
existing values hash 	readable handler 
map note 	otherwise called 
size must always 	recursively 
power match 	since rdb 
hash obj zero 	load call 
length entry 	loop process 
name initialized without 	events time 
requiring malloc 	time non 
free use empty 	blocking 
instead allocating 	loading setup 
one free memory 	connected slave 
associated entry 	master link 
result unspecified state 	restart aof 
examined iff 	subsystem finished 
already contains 	sync 
entry name obstack.c 	trigger aof 
obstack compat 	rewrite done 
size alignment chunkfun 	start appending 
freefun chunk 	file send 
extra size alignment 	synchronous command 
chunkfun freefun 	master 
arg chunk extra 	used send 
length old 	auth replconf 
chunk chunk size 	commands starting 
obj size 	replication sync 
already obj obj 	command returns 
plp obj 	sds 
plp nbytes compat 	representing result 
symbol call 	operation error 
chunkfun obstack alloc 	first create 
failed handler 	command send 
ptr align call 	master use 
chunkfun obstack 	simple 
alloc failed 	protocol simplicity 
handler ptr align 	currently send 
call chunkfun 	simple transfer 
obstack alloc failed 	command server 
handler ptr 	read reply 
align ptr align 	server 
call freefun 	resynchronization master 
call freefun abort 	reconnect cached 
fxprintf exit 	master structure 
obstack subroutines used 	least issue 
implicitly stack 	psync command 
macros copyright free 	order 
software foundation 	trigger full 
inc file part 	resync psync 
gnu library 	command order 
gnu library free 	obtain master 
software redistribute 	run master 
modify terms gnu 	replication 
lesser general 	offset function 
license published 	designed called 
free software foundation 	sync master 
either version 	following assumptions 
license option later 	made pass 
version gnu 	function 
library distributed hope 	already connected 
useful without 	socket function 
warranty without even 	close file 
implied warranty 	descriptor however 
merchantability fitness particular 	successful resynchronization 
purpose see 	function 
gnu lesser general 	reuse file 
license details 	descriptor server 
received copy gnu 	master client 
lesser general 	structure function 
license along gnu 	split two 
library write 	halves 
free software 	read reply 
foundation inc franklin 	function writes 
street fifth 	psync command 
floor boston usa 	socket function 
note modifying 	call needed 
file version number 	read 
must incremented 	reply order 
whenever callers compiled 	read reply 
old obstack 	command useful 
longer properly call 	order support 
functions obstack 	non 
comment code gnu 	blocking operations 
library actually 	write loop 
compiling library installed 	read data 
library supports 	read reply 
library code part 	function returns 
gnu library 	psync 
also included many 	write err 
gnu distributions 	write error 
compiling linking 	psync wait 
code waste gnu 	reply signal 
library especially 	need another 
shared library rather 	call 
every gnu 	read reply 
program understand configure 	however even 
gnu libc 	read reply 
omit files simpler 	function may 
source file 	psync wait 
random thing gnu 	reply 
library determine 	signal insufficient 
alignment malloc really 	data read 
smart would 	complete work 
round addresses alignment 	enter loop 
fact might 	wait function 
less smart round 	returns 
addresses much 	psync psync 
rounding prepare copy 	command succeded 
block data 	psync fullresync 
unit machines 	psync supported 
copying successive ints 	full resync 
work redefine 	needed 
copying unit works 	master run 
last resort 	replication offset 
functions allocating room 	saved psync 
calling obstack 	supported server 
chunk alloc jump 	understand psync 
handler pointed 	caller 
obstack alloc failed 	fall back 
handler user 	sync psync 
defined function either 	write err 
abort gracefully 	error writing 
use longjump shouldn 	command socket 
variable points 	psync 
function print abort 	wait reply 
looong time 	call function 
ago anyway sure 	read reply 
variable used 	notable side 
non gnu 	effects side 
macros avoid multiple 	effect 
evaluation gnu 	function call 
library still exports 	function removes 
somebody might 	readable handler 
use define macro 	unless psync 
either calls 	wait reply 
functions traditional malloc 	server 
free calling 	repl master 
calls functions mmalloc 	initial offset 
mfree adds 	right according 
extra first argument 	master reply 
state use 	used populate 
extra arg free 	server 
use since 	master structure 
compilers like mips 	replication offset 
compilers allow 	writing half 
expr initialize 	initially repl 
obstack use specify 	master initial 
chunk size 	offset 
size means objects 	mark current 
start multiples 	master run 
alignment means use 	offset valid 
chunkfun function 	later able 
use allocate chunks 	full resync 
freefun function 	psync 
free nonzero successful 	command offset 
calls obstack 	right information 
alloc failed handler 	propagated client 
allocation fails 	structure representing 
points chunk size 	master server 
gnu malloc 	master 
fit block mhead 	issue psync 
extra gnu 	command reading 
malloc use values 	half master 
range checking 	may send 
range checking 	empty newlines 
extra bytes won 	receives 
missed terribly 	psync reply 
range checking used 	keep connection 
larger request 	alive full 
whole extra bytes 	resync parse 
would allocated 	reply order 
number irrelevant gnu 	extract 
malloc suspect 	run replication 
less sensitive size 	offset unexpected 
request initial 	condition actually 
chunk contains empty 	fullresync reply 
points chunk 	means master 
size gnu malloc 	supports 
fit block 	psync reply 
mhead extra gnu 	format seems 
malloc use 	wrong stay 
values range checking 	safe blank 
range checking 	master runid 
extra bytes 	make 
won missed terribly 	sure next 
range checking 	psyn fail 
used larger request 	going full 
whole extra 	resync discard 
bytes would allocated 	cached master 
number irrelevant 	structure 
gnu malloc suspect 	resync accepted 
less sensitive 	replication state 
size request initial 	accordingly reach 
chunk contains 	point received 
empty allocate current 	either error 
chunk obstack 	since 
assumption length bytes 	master understand 
need added 	psync unexpected 
current length length 	reply master 
allocated copies 	psync supported 
end old chunk 	caller cases 
beginning one 	error 
compute size 	log unexpected 
chunk allocate initialize 	fired user 
chunk compute 	turned instance 
aligned chunk move 	master slaveof 
existing chunk 	one must 
word time fast 	asap 
safe sufficiently 	check errors 
aligned used copy 	socket send 
odd remaining 	ping check 
bytes one extra 	master able 
copying unit 	reply without 
cross page boundary 	errors 
machine strict 	writable readable 
alignment copying units 	remains registered 
copy remaining 	wait pong 
bytes one one 	reply send 
copied data 	ping check 
old chunk 	errors 
free chunk chain 	timeout take 
chunk might 	care receive 
contain empty chunk 	pong command 
certainly contains 	accept two 
empty yet nonzero 	replies valid 
obj allocated 	positive 
obstack debugging use 	pong reply 
program probably 	check authentication 
losing suppress wmissing 	error note 
prototypes warning 	older versions 
want declare obstack 	redis replied 
debugging addr 	operation 
objects chunk point 	permitted instead 
previous chunk 	proper error 
use rather since 	code test 
cannot exactly 	auth master 
beginning chunk might 	required receive 
empty exactly 	auth 
end adjacent 	reply slave 
chunk free objects 	port master 
obstack including 	info command 
obj everything allocate 	list slave 
recently obj 	listening port 
obj zero free 	correctly 
everything addr 	receive replconf 
objects chunk point 	listening port 
previous chunk 	reply ignore 
use cannot beginning 	error redis 
chunk empty 	versions support 
address end another 	replconf 
chunk chunks 	listening port 
tell whether current 	inform master 
chunk contains 	capabilities currently 
empty may obj 	send one 
chunks older 	capability possible 
versions libc used 	chain 
function obstack 	capabilities form 
free intended 	replconf capa 
called non gcc 	capa capa 
compilers feature 	master ignore 
available gcc versions 	capabilities understand 
later empty 	receive 
change yes would 	capa reply 
possible newline 	ignore error 
use fputs must 	redis versions 
happen memory 	support replconf 
exhausted message appears 	capa resynchonization 
places like 	cached 
translation reused instead 	master slave 
creating similar 	resynchronization least 
requires separate translation 	use psync 
elide code 	start full 
obstack.h limit prev 	resynchronization master 
contents chunk 	run 
size chunk next 	offset resync 
free chunk 	next reconnection 
limit tempint 	attempt reached 
tempptr alignment mask 	point repl 
obstack chunk 	state receive 
extra arg obstack 	psync 
obstack obstack 	later note 
obstack obstack obstack 	psync wait 
stack macros 	reply take 
copyright free software 	care uninstalling 
foundation inc 	read handler 
file part gnu 	file 
library gnu 	descriptor psync 
library free software 	failed supported 
redistribute modify 	want slaves 
terms gnu lesser 	resync well 
general license 	chained replication 
published free software 	mater 
foundation either 	may transfer 
version license option 	entirely different 
later version 	data way 
gnu library 	incrementally feed 
distributed hope useful 	slaves force 
without warranty 	slaves 
without even implied 	resync well 
warranty merchantability 	allow chained 
fitness particular purpose 	slaves psync 
see gnu 	fall back 
lesser general license 	sync needed 
details received 	otherwise 
copy gnu lesser 	psync result 
general license 	psync fullresync 
along gnu library 	server repl 
write free 	master runid 
software foundation inc 	repl master 
franklin street 	initial 
fifth floor boston 	offset already 
usa summary 	populated prepare 
apparent functions 	suitable temp 
defined macros idea 	file bulk 
would use 	transfer setup 
pre tested macros 	non 
solve specific 	blocking download 
problems would run 	bulk file 
fast caution 	handle send 
side effects arguments 	synchronous command 
please may 	sync cmd 
evaluated many times 	write 
macros operate 	errors function 
stack objects starts 	called non 
life small 	blocking connection 
may grow maturity 	currently progress 
consider building 	undo never 
word syllable syllable 	call 
move growing 	function directly 
finished never changes 	use cancel 
address top 	replication handshake 
stack typically 	instead abort 
immature growing rest 	download bulk 
stack mature 	dataset 
size address objects 	sync ing 
routines grab 	master never 
large chunks memory 	call function 
function supply 	directly use 
called obstack chunk 	cancel replication 
alloc occasion 	handshake 
free chunks calling 	instead function 
obstack chunk 	aborts non 
free must define 	blocking replication 
declare obstack 	attempt one 
macros independent stack 	progress canceling 
represented obstack 	non 
obstack macros expects 	blocking connect 
pointer structure 	attempt initial 
first argument one 	bulk transfer 
motivation problem 	replication handshake 
growing symbol 	progress returned 
tables unless fascist 	replication 
pig read 	state server 
mind gosper immortal 	repl state 
quote hakmem 	repl state 
item context would 	connect otherwise 
like put 	zero returned 
arbitrary upper limit 	operation 
length symbols 	perforemd replication 
practice often means 	specified master 
build many 	address port 
symbols symbols time 	clients blocked 
reading symbol 	master slave 
know one traditional 	force 
method read 	slaves resync 
symbol buffer realloc 	well psync 
ating buffer 	allow chained 
every time read 	slaves psync 
symbol longer 	cancel replication 
buffer beaut 	setting 
still want copy 	instance master 
symbol buffer 	nothing instance 
permanent symbol table 	turned master 
entry say 	slaves inherits 
half time obstacks 	replication offset 
work differently 	master 
use one obstack 	certain conditions 
symbol names 	makes replicas 
read symbol grow 	comparable replication 
name obstack 	offset understand 
gradually name complete 	updated function 
finalize symbol 	called 
exists already free 	slave lose 
newly read 	connection master 
name way take 	unexpected way 
large chunk 	lost connection 
allocating memory 	master disconnect 
low addresses want 	slaves 
build symbol 	yet maybe 
chunk chars current 	able psync 
high water 	master later 
mark chunk finished 	disconnect slaves 
adding chars 	full resync 
got end symbol 	master 
know chars 	slaveof allowed 
create mostly chars 	cluster mode 
burst highest 	replication automatically 
address chunk would 	configured current 
typically expect 	address master 
chunk say times 	node 
average isn 	special host 
clear enough chars 	port combination 
make already 	one turns 
contiguous chunk guaranteed 	instance master 
point lies 	otherwise master 
moving chars 	address 
needed second win 	check already 
potentially need 	attached specified 
never explicitly shuffled 	slave previous 
formed change 	master user 
address lifetime chars 	specified different 
burst chunk 	one 
boundary allocate larger 	role command 
chunk copy 	provide information 
partly formed end 	role instance 
old chunk 	master slave 
beginning larger chunk 	additional information 
carry accreting 	related 
characters end normally 	replication easy 
would special 	process format 
macro provided single 	send replconf 
time growing 	ack command 
allows use variables 	master inform 
ordinary growth 	current 
macro summary 	processed offset 
allocate large chunks 	connected master 
carve one 	command effects 
time current chunk 	master caching 
carved never 	psync order 
moves free append 	implement 
data size 	synchronization need 
currently growing exactly 	able cache 
one growing 	master client 
obstack one time 	structure disconnection 
run one 	cached server 
obstack per control 	cached 
block may 	master flushed 
many control blocks 	away following 
dare way 	functions function 
unwind obstack back 	called free 
previous state 	client order 
may objects much 	cache 
would stack 	master client 
contents file 	structure instead 
need type pointer 	destryoing free 
subtraction ptrdiff 	client asap 
type defined gnu 	function returns 
use way 	every 
pollute stddef symbols 	action needed 
otherwise include 	avoid problems 
stddef use ptrdiff 	client really 
addressed result 	suspended done 
aligning next multiple 	function functions 
must type 	deal 
must power similar 	cached master 
bptr align 	replication discard 
optimize common pointers 	cached master 
converted integers 	make sure 
aligned integers converted 	kill client 
back ptr 	reason 
type narrower 	want use 
pointer play safe 	future replication 
compute alignment 	resurrect cached 
relative otherwise use 	master used 
faster strategy 	successful psync 
computing alignment relative 	handshake 
lives front 	order reactivate 
chunk past end 	cached master 
chunk address 	unlink client 
prior chunk objects 	server structures 
begin control 	save master 
current current chunk 	server 
preferred size 	master later 
allocate chunks address 	replication handle 
current obstack 	master disconnection 
chunk address building 	invalidate peer 
next current 	cache caching 
address current chunk 	master 
temporary macros 	happens instead 
mask alignment 	actual free 
prototypes vary use 	client call 
extra arg 	make sure 
use casts prototypeless 	adjust replication 
function type 	state 
assignments prototypes quiets 	function also 
wstrict prototypes 	server master 
first arg chunk 	free cached 
alloc dealloc 	master called 
funcs chunk alloc 	longer conditions 
dealloc funcs 	resync 
take extra arg 	reconnection turn 
possibility current 	cached master 
chunk contains zero 	current master 
length prevents 	file descriptor 
freeing chunk allocate 	passed argument 
bigger chunk 	socket 
replace longer used 	master function 
call failed 	called successfully 
handler error 	setup resynchronization 
retained binary compatibility 	stream data 
declare external 	receive start 
functions use obstack 	master 
error handler 	left list 
called obstack chunk 	clients close 
alloc failed 	asap may 
allocate memory user 	also need 
defined function 	install write 
either abort gracefully 	handler 
use longjump 	well pending 
shouldn action print 	data write 
message abort 	buffers close 
pointer beginning allocated 	asap min 
allocated next 	slaves write 
note might address 	function 
chunk might 	counts number 
needed hold size 	slaves lag 
size allocating 	min slaves 
ordinary chunks 	max lag 
pointer next yet 	option 
allocated current 	active server 
chunk mask specifying 	prevent writes 
low bits 	enough connected 
clear address prevent 	slaves specified 
prototype warnings 	lag less 
provide complete argument 	replication 
list next 	script cache 
step really gcc 	goal code 
defines gnuc 	keep track 
implement extension compiler 	scripts already 
doesn define 	sent every 
gnuc minor gnu 	connected 
traditional define 	slave order 
macros compute args 	able replicate 
without variable 	evalsha without 
also avoid temp 	translating eval 
slot make 	every time 
faster code 	possible 
obstack alignment good 	use capped 
enough pointers 	collection implemented 
ints data added 	hash table 
far current 	fast lookup 
shares much alignment 	scripts send 
local variable 	evalsha 
named avoid name 	plus linked 
conflict obstack 	list used 
blank called gnuc 	eviction oldest 
stdc note 	entry max 
call obstack newchunk 	number items 
enclosed avoid 	reached 
expressions arms conditional 	care taking 
expression casting 	different cache 
third operand tried 	every different 
compilers won 	slave since 
accept gnuc 	fill cache 
stdc obstack pack-bitmap-write.c 	costly 
commit bitmap 	goal code 
write flags xor 	avoid big 
offset commit 	script trasmitted 
pos commits trees 	big number 
blobs tags 	times per 
bitmaps reused pack 	second 
selected selected 	wasting bandwidth 
selected alloc progress 	processor speed 
show progress 	problem need 
pack checksum writer 	rebuild cache 
show index 	scratch time 
index entry seen 	time 
objects seen 	every used 
objects seen objects 	script need 
alloc commit 	transmitted single 
reused sha entry 	time reappear 
name data 	cache system 
commit data 	works 
commit hash pos 	every time 
bitmap pos 	slave connects 
commit data parent 	flush whole 
max xor 	script cache 
offset search next 	send evalsha 
stored best 	sent 
offset best bitmap 	master evalsha 
test xor 	without trying 
curr pack reuse 	convert eval 
bitmap threshold 	evalsha specifically 
reuse need reset 	slaves every 
revs stored 	time 
hash pos hash 	trasmit script 
ret idx 	eval slaves 
min commits max 	also corresponding 
commits must 	sha script 
region min region 	cache sure 
offset next 	every 
pack sha 	slave knows 
hash pos indexed 	script starting 
commits indexed 	script flush 
commits max bitmaps 	command replicate 
next reused 	command slaves 
bitmap chosen buf 	time 
len bitmap 	flush script 
pos table index 	cache last 
index index 	slave disconnects 
stored commit pos 	flush cache 
index index 	handle script 
entry hash sha 	load 
index index 	well since 
filename options tmp 	scripts loaded 
file version 	master sometimes 
flags header ewah 	initialize script 
ewah ewah 	cache called 
ewah sha info 	startup 
ewah ewah 	empty script 
ewah ewah 	cache called 
die sha hex 	every time 
realloc alloc 	longer sure 
grow packlist find 	every slave 
die sha 	knows 
hex bitmap find 	scripts current 
pos mark 	aof context 
seen mark seen 	longer aware 
find pos 	script general 
bitmap sha end 	flush cache 
bitmap ewah 	every 
bitmap include mark 	time slave 
seen mark 	reconnects master 
seen ewah pool 	performs full 
ewah xor 	sync psync 
ewah pool free 	require flushing 
ewah pool 	every 
free bitmap 	time aof 
init sha start 	rewrite performed 
progress init 	every time 
revisions reset revision 	left without 
walk merge 	slaves aof 
bases bitmap reset 	order 
reset seen 	reclaim otherwise 
pending prepare revision 	unused memory 
walk die 	entry script 
traverse commit list 	cache reach 
bitmap ewah 	max number 
put sha die 	entries 
oid hex 	oldest removed 
display progress bitmap 	list evict 
free stop 	oldest current 
progress compute xor 	returns non 
offsets prepare 	zero specified 
bitmap git init 	entry 
sha rebuild 	exists inside 
existing bitmaps 	cache slaves 
sha end qsort 	aware script 
start progress 	sha synchronous 
push bitmapped commit 	replication redis 
next commit 	synchronous 
index find reused 	replication design 
bitmap find 	summarized points 
reused bitmap push 	redis masters 
bitmapped commit 	replication offset 
display progress stop 	used psync 
progress sha 	master 
write ewah serialize 	increment offset 
die sha 	every time 
pos die sha 	commands sent 
write sha 	slaves slaves 
write sha write 	ping back 
dump bitmap 	masters 
htonl sha write 	offset processed 
hashcpy odb 	far synchronous 
mkstemp die 	replication adds 
errno sha memcpy 	wait command 
htons htons 	form wait 
htonl hashcpy sha 	num 
write dump 	replicas milliseconds 
bitmap dump bitmap 	timeout returns 
dump bitmap 	number replicas 
dump bitmap write 	processed query 
selected commits 	least num 
write hash cache 	replicas 
sha close 	timeout reached 
adjust shared perm 	command implemented 
die errno 	way every 
rename die errno 	time client 
build initial 	processes command 
type index packfile 	remember 
compute actual 	replication offset 
bitmaps commits bitmapped 	sending command 
sha write 	slaves wait 
die error 	called ask 
write bitmap index 	slaves send 
disk pack-bitmap.c 	acknowledgement 
sha root xor 	asap client 
flags pack 	blocked time 
reuse objects map 	see blocked 
map size 	receive enough 
map pos commits 	given offset 
trees blobs 	timeout 
tags bitmaps entry 	reached wait 
count hashes 	command unblocked 
objects hashes count 	reply sent 
alloc positions 	client flag 
result version parent 	broadcast replconf 
composed index 	getack 
bitmap size index 	command slaves 
header flags 	sleep function 
end index 	note way 
root sha xor 	clients want 
flags stored 	wait synchronouns 
hash pos ret 	replication 
buffer pos 	given loop 
result buffer pos 	iteration send 
index recent 	single getack 
bitmaps xor offset 	number slaves 
flags bitmap 	already acknowledged 
xor bitmap commit 	specified 
idx pos 	replication offset 
sha len packfile 	wait replicas 
idx name 	acknowledge processing 
ret seen sha 	latest write 
positions pos 	command previous 
bitmap pos sha 	commands 
offset sha 	argument parsing 
pos name eindex 	first without 
hash pos 	blocking otherwise 
hash ret 	block client 
bitmap pos name 	put list 
data bitmap 	clients 
pos commit data 	waiting ack 
data sha 	slaves make 
bitmap pos hash 	sure server 
pos commit 	send ack 
data data bitmap 	request slaves 
pos parent 	returning 
revs roots seen 	loop called 
needs walk 	unblock client 
mapped pos pos 	perform blocking 
incdata objects 	type specific 
show reach eindex 	cleanup client 
obj show 	list 
objects type roots 	clients waiting 
revs pending 	replica acks 
pending wants haves 	never call 
wants bitmap 	directly call 
haves bitmap 	unblock client 
tag packfile entries 	instead 
reuse percent 	check clients 
result reuse threshold 	blocked wait 
reuse objects 	unblocked since 
sha entry show 	received enough 
reachable count 	slaves every 
type commits trees 	time 
blobs tags 	find client 
prg seen name 	satisfied given 
data tdata 	offset number 
bitmap pos commit 	replicas remember 
data tdata 	next client 
bitmap pos revs 	may 
root result 	unblocked without 
pos result popcnt 	calling replication 
tdata reposition 	count acks 
source dest pos 	offset requested 
word offset 	offset replicas 
bit pos 	equal 
mapping reused bitmaps 	less slave 
show progress 	replication offset 
num objects reposition 	instance offset 
rebuild stored 	already processed 
progress hash pos 	master replication 
hash ret 	stream 
sha entry ewah 	offset may 
pool lookup 	master support 
stored bitmap ewah 	however function 
xor ewah 	designed offset 
pool free ewah 	express amount 
pool ewah 	data 
read mmap error 	processed master 
ewah pool 	positive integer 
free error memcmp 	replication cron 
error ntohs 	replication cron 
error ntohs error 	function called 
ntohl xmalloc 	time 
hashcpy put 	per second 
sha error sha 	non blocking 
hex read 	connection timeout 
read read nth 	bulk transfer 
packed sha 	timeout timed 
read bitmap error 	master 
error store 	already connected 
bitmap strip suffix 	slave check 
die xstrfmt 	connect master 
open pack index 	send ack 
pack bitmap 	master time 
filename git open 	time 
noatime free 	note send 
fstat close warning 	periodic acks 
close xsize 	masters support 
xmmap close load 	psync replication 
bitmap header 	offsets attached 
munmap init 	slaves 
sha init sha 	ping time 
pos load 	time slaves 
pack revindex read 	implement timeout 
bitmap read 	masters able 
bitmap read bitmap 	detect link 
read bitmap 	disconnection 
load bitmap entries 	even tcp 
munmap prepare 	connection actually 
packed git open 	first send 
pack bitmap 	ping according 
open pack bitmap 	ping slave 
load pack 	period 
bitmap sha pos 	second send 
end find 	newline slaves 
pack entry one 	pre synchronization 
find revindex 	stage slaves 
position bitmap position 	waiting master 
packfile bitmap 	create 
position extended 	rdb file 
put sha pos 	newline ignored 
realloc realloc 	slave refresh 
pack name hash 	last timer 
bitmap position 	preventing timeout 
ext index bitmap 	ignore 
bitmap bitmap 	ping period 
sha end bitmap 	refresh connection 
ewah lookup 	per second 
stored bitmap bitmap 	since certain 
bitmap position 	timeouts seconds 
ext index include 	example 
sha end 	psync response 
lookup stored bitmap 	worry ping 
ewah bitmap 	disconnect timedout 
bitmap ewah list 	slaves attached 
insert bitmap 	slaves replication 
position bitmap pending 	backlog 
bitmap prepare 	memory free 
revision walk 	configured time 
die traverse commit 	aof disabled 
list bitmap 	longer attached 
show reach find 	slaves free 
pack entry 	replication 
one open pack 	script cache 
bitmap parse 	need propagate 
die list insert 	evalsha diskless 
list insert 	replication slaves 
die parse die 	waiting wait 
list insert 	bgsave 
list insert bitmapped 	start state 
pack load 	check enough 
pack bitmap find 	seconds elapsed 
objects reset 	start bgsave 
revision walk die 	code also 
find objects 	useful 
die bitmap bitmap 	trigger bgsave 
free ewah 	diskless replication 
bit ctz 	turned config 
nth packed sha 	already slaves 
sha hex 	wait bgsave 
bitmap popcount show 	start 
objects type 	state start 
show objects type 	bgsave usually 
show objects 	socket target 
type show objects 	disk target 
type show 	recent socket 
extended objects bitmap 	disk 
free count 	config change 
type count type 	refresh number 
count type 	slaves lag 
count type bitmap 	min slaves 
position die 	max lag 
oid hex bitmap 	incremented 
display progress 	frequency rio.c 
bitmap position 	buf len 
die oid hex 	buf len 
bitmap display 	rio buffer 
progress prepare bitmap 	buf len 
git die 	retval 
die sha end 	buf len 
lookup stored 	rio file 
bitmap oid hex 	buf len 
ewah checksum 	retval doflush 
ewah bitmap die 	count broken 
oid hex 	nwritten 
bitmap popcount prepare 	buf len 
revision walk 	rio fdset 
die bitmap start 	fds numfds 
progress traverse 	buf len 
commit list stop 	bytes prefix 
progress bitmap 	count 
bitmap free ewah 	cbuf clen 
iterator init 	buf len 
ewah iterator 	nwritten lbuf 
next ewah bit 	llen dbuf 
ctz bitmap 	dlen sdscatlen 
prepare bitmap git 	sdslen 
xcalloc nth 	memcpy unused 
packed sha packlist 	fwrite fflush 
find bitmap 	aof fsync 
start progress stop 	fileno fread 
progress free 	ftello fflush 
bitmap free entry 	sdscatlen 
bitmap index 	sdslen sdslen 
representing bitmap given 	write sdsclear 
commit currently 	unused unused 
active bitmap index 	unused rio 
design repositories 	fdset write 
single bitmap index 	zmalloc 
available index 	zmalloc memcpy 
biggest packfile repository 	sdsempty zfree 
since bitmap 	zfree sdsfree 
indexes need 	crc server 
full closure one 	rio write 
bitmap index 	rio 
available alternates active 	write bulk 
bitmap index 	count rio 
largest one packfile 	write rio 
bitmap index 	write rio 
belongs mark first 	write bulk 
reuse objects 	snprintf 
packfile reused sent 	rio write 
without repacking 	bulk rio 
calculations mmapped buffer 	simple stream 
whole bitmap 	oriented abstraction 
index size mmaped 	provides write 
buffer current 	code 
position loading index 	consume produce 
type indexes 	data different 
bitmap marks objects 	concrete input 
packfile given 	output devices 
type provides 	instance rdb 
type information yielding 	code 
objects packfile 	rio abstraction 
walk allows better 	used read 
delta bases 	write rdb 
map sha stored 	format memory 
bitmap bitmapped 	buffers files 
commits number bitmapped 	rio 
commits name 	provides following 
hash cache present 	methods read 
extended index 	read stream 
trying perform bitmap 	write write 
operations objects 	stream tell 
packed pack objects 	current 
added fake 	offset also 
index assumed appear 	possible checksum 
end packfile 	method used 
operations bitmap 	rio order 
result last performed 	compute checksum 
walk version 	data 
bitmap index read 	written read 
bitmap current 	query rio 
read position mmaped 	current checksum 
index increase 	copyright pieter 
read position accordingly 	noordhuis 
parse known 	pcnoordhuis gmail 
bitmap format options 	dot copyright 
code means 	salvatore sanfilippo 
insertion succeeded changes 	antirez gmail 
sha already 	dot rights 
existed map bad 	reserved 
shouldn duplicated 	redistribution use 
commits index roots 	source binary 
walk ones 	forms without 
bitmaps bitmap index 	modification permitted 
together form 	provided following 
initial reachability 	conditions 
analysis ones without 	met redistributions 
bitmaps index 	source code 
stored mapped list 	must retain 
processing best 	copyright notice 
scenario found bitmaps 	list conditions 
roots resulting 	following 
bitmap full reachability 	disclaimer redistributions 
analysis iterate 	binary form 
roots bitmaps check 	must reproduce 
determine reachable 	copyright notice 
existing bitmap cannot 	list conditions 
find existing 	following 
bitmap need push 	disclaimer documentation 
actual walk 	materials provided 
run confirm reachable 	distribution neither 
open bitmapped 	name redis 
pack parse yet 	names contributors 
may need 	may 
use haves 	used endorse 
list none haves 	promote products 
contained packfile 	derived software 
bitmap anything optimize 	without specific 
want anything 	prior written 
done going use 	permission 
bitmaps load 	software provided 
actual bitmap entries 	copyright holders 
disk point 	contributors express 
rev list becomes 	implied warranties 
invalidated must 	including limited 
perform revwalk bitmaps 	implied 
reuse packfile 	warranties merchantability 
content need objects 	fitness particular 
reuse full 	purpose disclaimed 
pack reuse pack-bitmap.h 	shall copyright 
magic version 	owner contributors 
options entry count 	liable 
checksum bitmap 	direct indirect 
idx signature 	incidental special 
commits trees blobs 	exemplary consequential 
tags show 	damages including 
reachable revs revs 	limited procurement 
packfile entries 	substitute 
mapping reused bitmaps 	goods services 
show progress 	loss use 
show sha index 	data profits 
index pack 	business interruption 
indexed commits indexed 	however caused 
commits max 	theory 
bitmaps pack index 	liability whether 
index filename 	contract strict 
options pack-check.c offset 	liability tort 
sha entry 	including negligence 
entry curs offset 	otherwise arising 
len index 	way 
crc data crc 	use software 
avail data 	even advised 
curs progress 	possibility damage 
count index size 	buffer implementation 
index ctx 	returns success 
sha pack sig 	failure 
pack sig 	returns success 
ofs objects err 	failure enough 
entries remaining 	buffer len 
data size offset 	bytes returns 
len eaten 	read write 
index size index 	position 
ctx sha 	buffer flushes 
err progress count 	buffer target 
err curs 	device applicable 
crc use pack 	returns success 
crc ntohl 	failures nothing 
git sha init 	write 
use pack 	appends buffer 
git sha 	update checksum 
update git sha 	current checksum 
use pack 	bytes read 
hashcmp error hashcmp 	written read 
error unuse 	write 
pack alloc nth 	chunk size 
packed sha 	specific vars 
die nth packed 	stdio file 
offset qsort 	pointer implementation 
check pack crc 	returns success 
error sha 	failure 
hex unpack entry 	returns success 
error sha 	failure returns 
hex check sha 	read write 
signature error 	position file 
sha hex display 	flushes buffer 
progress free 	target 
display progress free 	device applicable 
open pack 	returns success 
index error 	failures update 
git sha init 	checksum current 
git sha 	checksum bytes 
update git sha 	read 
hashcmp error 	written read 
verify pack index 	write chunk 
verify packfile 	size specific 
unuse pack note 	vars file 
pack header 	descriptors implementation 
checks actually performed 	returns 
use pack 	success failure 
first opens pack 	function returns 
file anything 	success able 
goes wrong checks 	correctly write 
call die 	least one 
immediately make sure 	file 
everything reachable 	descriptor buf 
idx valid since 	adn len 
verified objects 	function performs 
matches idx 	flush operation 
pack scan streaming 	pending buffer 
check pack 	function 
file first sort 	also used 
entries pack 	order implement 
offset since unpacking 	rio fdset 
efficient way 	flush start 
verify sha sum 	always append 
index file 	buffer 
pack-objects.c pdata sha 	gets larger 
found mask 	given size 
pos pdata entry 	actually write 
found pdata 	sockets prevent 
sha index pos 	entering belove 
found pdata 	flush 
sha index pos 	write little 
entry sha 	chunchs big 
hash hashcmp closest 	writes parallelize 
pow free 	kernel sending 
xcalloc locate 	data background 
entry hash die 	tcp 
locate entry 	socket skip 
hash realloc memset 	alraedy error 
hashcpy rehash 	make sure 
objects objects going 	write count 
pack collected 	bytes socket 
pack structure contains 	regardless 
dynamically expanded 	writes blocking 
data map resolve 	sockets sole 
sha position 	user rio 
stats indexed commits 	target ewouldblock 
nothing going 	returned sndtimeo 
reuse existing data 	socket 
make sure 	option translate 
corrupt bust pack 	error one 
size limit 	recognizable user 
make sure 	mark broken 
cached delta data 	error returns 
remains previous 	success 
attempt pack split 	failure error 
occurred large 	target support 
blob compress well 	reading returns 
header type 	read write 
followed zero bytes 	position file 
length deltas 	flushes 
relative contain additional 	buffer target 
encoding relative 	device applicable 
offset delta position 	returns success 
pack deltas 	failures flush 
reference contain additional 	implemented write 
bytes sha 	method 
bust pack size 	recognizes buffer 
limit bust 	count zero 
pack size limit 	flush request 
apply size 	update checksum 
limit limited 	current checksum 
packsize first earlier 	bytes 
fit limit 	read written 
avoid mistaking unlimited 	read write 
limit delta 	chunk size 
unlimited packfile written 	specific vars 
another pack 	functions function 
already exists pack 	installed 
could end 	memory file 
another pack reuse 	streams checksum 
check decided 	computation needed 
pack split may 	file rio 
pack delta 	fsync every 
unusable want pack 	bytes 
afresh pack 	file written 
undeltified need deltify 	zero means 
already written 	automatic file 
writing bust limit 	sync performed 
written normal 	feature useful 
already scheduled 	contexts 
written offset impossible 	since rely 
mark fact 	write buffers 
involved write first 	sometimes buffers 
writing deltified 	way much 
recursion offset non 	resulting many 
zero written 	disk 
already deltified write 	concentrated little 
first recurse 	time fsync 
cannot depend one 	way instead 
make sure 	pressure distributed 
sufficiently large wrap 	across time 
node siblings 	higher 
drop level left 	level following 
subtree nodes 	higher level 
possible sibling might 	functions use 
children next 	lower level 
back parent node 	rio functions 
right side 	help 
subtree keep 	generating redis 
going right done 	protocol append 
hit original 	file write 
root node pass 	multi bulk 
sibling level 	count format 
nothing fully connect 	count 
delta child 	write binary 
delta sibling network 	safe format 
make sure 	count payload 
delta sibling sorted 	write format 
original recency 	count payload 
order mark first 	write 
child mark 	format count 
objects tip tags 	payload rio.h 
give objects 	rio buf 
original recency order 	len rio 
see tagged 	buf len 
tip fill 	rio 
tagged tips remaining 	rio rio 
commits tags 	buf len 
trees rest really 	cksum processed 
tight order 	bytes max 
know actual number 	processing chunk 
objects written 	ptr 
many bytes written 	pos buffered 
many bytes 	autosync fds 
total many objects 	state numfds 
total fake 	pos buf 
pretending objects writing 	buf len 
size gives 	bytes 
smooth progress meter 	write buf 
end matches 	len bytes 
answer write wrong 	read fds 
entries header 	numfds prefix 
rewrite like fast 	count buf 
packs runtime 	len 
accessed mtime 	buf len 
order since newer 	bytes update 
packs likely 	cksum write 
contain younger objects 	read update 
creating multiple 	cksum tell 
packs modify mtime 	flush 
later ones 	copyright pieter 
preserve mark written 	noordhuis pcnoordhuis 
objects written 	gmail dot 
previous pack adding 	copyright salvatore 
check whether 	sanfilippo antirez 
already added packing 	gmail 
list skip 	dot rights 
however asked excludei 	reserved redistribution 
previous mention 	use source 
include make sure 	binary forms 
adjust flags 	without modification 
tweak numbers accordingly 	permitted 
optimization pass 	provided following 
index position 	conditions met 
would found item 	redistributions source 
since saves 	code must 
look lines later 	retain copyright 
want entry 	notice 
check whether want 	list conditions 
pack want 	following disclaimer 
objects found non 	redistributions binary 
local stores 	form must 
local option used 	reproduce copyright 
side effect 	notice 
check find packed 	list conditions 
version therefore 	following disclaimer 
pass pack information 	documentation materials 
avoid look 	provided distribution 
later pack missing 	neither name 
closure phony 	redis 
cache entry going 	names contributors 
evict find 	may used 
mechanism toplevel 	endorse promote 
node would almost 	products derived 
always change 	software without 
commit pbase cache 	specific 
acts limited 	prior written 
hashtable found index 	permission software 
within slots 	provided copyright 
slot cached find 	holders contributors 
one either 	express implied 
got bogus request 	warranties 
need read 	including limited 
perhaps cache need 	implied warranties 
either cache 	merchantability fitness 
throwaway copy evict 	particular purpose 
reuse want 	disclaimed shall 
pack type even 	copyright 
reuse delta 	owner contributors 
since non delta 	liable direct 
representations could 	indirect incidental 
still reused 	special exemplary 
determine delta whether 	consequential damages 
reuse otherwise 	including 
find cheaply possible 	limited procurement 
actual type 	substitute goods 
size delta hence 	services loss 
already got 	use data 
need means wish 	profits business 
reuse delta 	interruption 
data even found 	however caused 
list objects 	theory liability 
want pack goodie 	whether contract 
depth matter 	strict liability 
find deltas never 	tort including 
consider reused 	negligence 
delta deltify objects 	otherwise arising 
order avoid 	way use 
circular deltas 	software even 
must delta already 	advised possibility 
know type 	damage backend 
extract actual size 	functions 
delta header 	since functions 
choice fall back 	tolerate writes 
recursive delta 	reads simplified 
walk sha info 	zero error 
find type 	non zero 
point error condition 	complete 
prepare pack 	success update 
permit missing preferred 	cksum method 
ignored preferred 	used compute 
result larger pack 	checksum data 
file transfer 	read written 
still take place 	far 
avoid filesystem 	method designed 
trashing loose objects 	called current 
search deltas 	checksum buf 
list sorted 	len fields 
type filename hash 	pointing block 
size see 	data 
progressively smaller smaller 	checksum computation 
files prefer 	current checksum 
deltas bigger file 	number bytes 
smaller deletes 	read written 
potentially cheaper perhaps 	maximum single 
importantly bigger 	read 
file likely recent 	write chunk 
one deepest 	size backend 
deltas therefore oldest 	specific vars 
objects less 	memory buffer 
susceptible accessed often 	target stdio 
newest first 	file 
cache delta objects 	pointer target 
large enough 	bytes written 
compared delta size 	since last 
bother diffs 	fsync fsync 
different types 	autosync bytes 
bother delta discarded 	written 
earlier reusing 	multiple target 
delta data note 	used write 
src entry 	sockets file 
marked preferred always 	descriptors error 
considered even 	state errno 
produce suboptimal delta 	following 
still save 	functions stream 
transfer cost already 	call actual 
know side 	implementation read 
won send src 	write tell 
entry bust 	update checksum 
allowed depth size 	needed 
filtering heuristics 	rtree.c rtree 
load data already 	bits alloc 
done objects 	dalloc bits 
included resulting pack 	leaf height 
resilient ignore 	rtree node 
read pack 	level 
could created nevertheless 	nchildren child 
prefer shallower 	rtree subtree 
sized deltas handle 	rtree level 
memory allocation 	elmp node 
outside cache accounting 	rtree level 
compiler optimize 	rtree 
strangeness away pthreads 	elm level 
defined compute 	hmin rtree 
delta create objects 	subtree dalloc 
going pack 	rtree subtree 
current pack edge 	atomic cas 
take depth 	atomic 
objects depend current 	read alloc 
account otherwise 	atomic write 
would become deep 	rtree node 
decided cache 	init rtree 
delta data 	node init 
best compress right 	significant 
away first 	bits keys 
anyway threaded save 	passed rtree 
lot time 	used root 
non threaded write 	level interior 
phase well 	levels leaf 
allow caching deltas 	level 
within cache 	compute lookup 
size limit writing 	table used 
stdout since 	rtree start 
network likely throttling 	level another 
writes anyway 	already process 
therefore best write 	initializing 
phase asap 	spin wait 
instead afford spending 	initialization complete 
time compressing 	nelms node 
writes moment made 	rtree node 
delta already 	node rtree 
max depth 	keys 
leaving window pointless 	node rtree 
evict first 	sfmt keys 
move best delta 	node rtree 
window currently 	calloc free 
deltified keep longer 	rtree ptr 
first attempted 	rtree 
next main waits 	rtree rtree 
condition least 	rtree ptr 
one workers stopped 	rtree rtree 
working indicated 	ptr rtree 
working member work 	rtree rtree 
completed work 	rtree 
sets working signals 	ptr rtree 
main waits 	ptr rtree 
condition data ready 	rtree rtree 
becomes mutex 	init gen 
conditional variable statically 	rand 
initialized windows 	rtree gen 
must data 	rand rtree 
ready wait condition 	ptr rtree 
main may 	ptr rtree 
order sure work 	rtree ptr 
available see 	rtree 
data ready initialized 	ptr rtree 
spawned reset 	rtree fini 
right away working 	gen rand 
doesn work 	test significant 
assigned partition work 	bits keys 
amongst work 	passed 
threads use small 	rtree used 
segments deltas 	root level 
found split chunks 	interior levels 
path boundaries 	leaf level 
start work threads 	compute lookup 
wait work 	table 
completion time done 	used rtree 
work steal 	start level 
half remaining 	another already 
work largest number 	process initializing 
unprocessed objects 	spin wait 
give newly idle 	initialization 
ensure good 	complete rtree.c 
load balancing remaining 	rtree bits 
list segments 	alloc dalloc 
simply worth splitting 	bits leaf 
anymore possible 	height rtree 
paths many objects 	node 
hash boundary 	level nchildren 
might found steal 	child rtree 
exact half 	subtree rtree 
tag peelable packed 	level elmp 
locally repacking 	node rtree 
need doubly careful 	level 
order make 	rtree elm 
sure stealth 	level hmin 
corruption gets propagated 	rtree subtree 
pack clients 	dalloc rtree 
receiving streamed packs 	subtree atomic 
validate everything 	cas 
anyway need incur 	atomic read 
additional cost 	alloc atomic 
happens decided reuse 	write rtree 
existing delta 	node init 
pack reuse delta 	rtree node 
implied found 	init 
include anyway compare 	significant bits 
objects offset 	keys passed 
order order emulate 	rtree used 
git rev 	root level 
list objects output 	interior levels 
produced pack 	leaf 
originally store list 	level compute 
sha discarded 	lookup table 
either written 	used rtree 
recently reachable another 	start level 
filled list 	another already 
tracks options reader 	process 
pack might 	initializing spin 
understand would therefore 	wait initialization 
prevent blind 	complete nelms 
reuse disk make 	node rtree 
sure shallows 	node node 
read threads means 	rtree 
autodetect pack 	keys node 
usage pack written 	rtree sfmt 
list result 	keys node 
written non empty 	rtree calloc 
reuse keep 	free rtree 
unreachable unpack unreachable 	ptr 
include tag 	rtree rtree 
unpack unreachable expiration 	rtree rtree 
local incremental 	ptr rtree 
ignore packed 	rtree ptr 
keep allow ofs 	rtree rtree 
delta pack 	rtree 
idx opts name 	rtree ptr 
progress window 	rtree ptr 
pack size limit 	rtree rtree 
depth delta 	rtree init 
search threads pack 	gen rand 
stdout num 	rtree 
preferred progress state 	gen rand 
pack compression 	rtree ptr 
level pack compression 	rtree ptr 
seen reuse 	rtree rtree 
packfile reuse packfile 	ptr rtree 
objects reuse 	ptr 
packfile offset use 	rtree rtree 
bitmap index 	fini gen 
write bitmap index 	rand test 
write bitmap 	significant bits 
options delta 	keys passed 
cache size max 	rtree 
delta cache 	used root 
size cache max 	level interior 
small delta 	levels leaf 
size window memory 	level compute 
limit written 	lookup table 
written delta reused 	used 
reused delta 	rtree start 
indexed commits indexed 	level another 
commits indexed 	already process 
commits alloc commit 	initializing spin 
entry size 	wait initialization 
size delta size 	complete 
buf buf 	rtree.h pun 
delta buf pptr 	child val 
size stream 	subtree pun 
maxsize sha stream 	subtree bits 
ibuf obuf 	cumbits alloc 
olen readlen 	dalloc 
zret curs offset 	height start 
len expect 	level levels 
stream fakebuf curs 	rtree bits 
offset len 	alloc dalloc 
avail entry limit 	rtree rtree 
usable delta 	level 
size datalen header 	rtree elm 
dheader hdrlen 	level rtree 
buf ofs pos 	key rtree 
entry limit 	key level 
usable delta curs 	node elm 
revidx offset 	rtree 
datalen header dheader 	elm level 
hdrlen ofs 	rtree elm 
pos entry write 	dependent rtree 
offset limit 	elm val 
len usable 	rtree level 
delta reuse path 	rtree 
oid flag 	level rtree 
data peeled entry 	key dependent 
endp endp 	rtree key 
order endp root 	val rtree 
end last 	key start 
untagged objects buffer 	level 
write total 	rtree key 
read pack offset 	level node 
remaining last 	elm child 
mtime write order 	rtree elm 
sha pack 	level child 
tmp name packfile 	rtree 
size tmpname 	elm dependent 
utb check attr 	rtree elm 
delta path 	val rtree 
check sha exclude 	level subtree 
index pos 	rtree level 
entry sha 	subtree 
exclude found pack 	rtree key 
found offset 	dependent subkey 
offset create entry 	start level 
closure warning 	node child 
entry entry bitmap 	rtree key 
sha temporary 	val 
data size sha 	subkey start 
next pcache 	level node 
sha ent nent 	child unlikely 
data size 	floor rtree 
neigh available cache 	node valid 
name name 	atomic 
cmplen fullname entry 	read rtree 
cmp sub 	child tryread 
downlen done pbase 	unlikely rtree 
paths done 	node valid 
pbase paths num 	rtree child 
done pbase 	read 
paths alloc 	hard atomic 
hash hash pos 	read atomic 
name cmplen 	write rtree 
hash sha data 	node valid 
size sha 	atomic read 
entry curs entry 	rtree 
used used 	subtree tryread 
avail ofs buf 	unlikely rtree 
revidx sorted 	node valid 
offset entry entry 	rtree subtree 
data index 	read hard 
depth src size 	rtree 
trg size 	start level 
delta size read 	unlikely rtree 
mutex cache 	node valid 
mutex progress mutex 	rtree subkey 
trg src 	rtree val 
max depth mem 	read 
usage trg 	rtree child 
entry src 	tryread reached 
entry trg size 	rtree start 
src size 	level rtree 
delta size sizediff 	subtree read 
max size 	rtree 
depth delta buf 	subkey rtree 
warned warned 	val write 
child freed mem 	rtree child 
list list 	read reached 
size window depth 	radix implementation 
processed count 	tailored 
mem usage entry 	singular purpose 
max depth 	associating metadata 
best tail ret 	chunks currently 
idx swap 	owned jemalloc 
dist dst src 	rtree bits 
size old 	per 
free routine 	level must 
list list size 	power two 
remaining window 	larger machine 
depth working data 	address width 
ready mutex 	used two 
cond processed progress 	stage 
cond arg 	free node 
list list size 	initialization node 
window depth 	allocation callback 
processed ret active 	function argument 
threads sub 	number contiguous 
size target victim 	rtree 
sub size 	node elm 
path oid flag 	structures allocate 
data peeled 	resulting memory 
window depth delta 	must zeroed 
list deltas 	jemalloc types 
entry done level 	non 
line sha 	subtree points 
commit data 	subtree rooted 
obj name data 	along hypothetical 
commit offset 	path leaf 
alloc pack revs 	node corresponding 
pack sha 	key 
sha last found 	depending keys 
recent objects 	used store 
sha mtime revs 	arbitrary combination 
sha revs 	subtree pointers 
obj name data 	may remain 
commit data 	suppose 
revs line flags 	keys comprise 
len sha 	bits rtree 
opt arg unset 	bits per 
val opt 	level results 
arg unset argc 	level leftmost 
argv prefix 	leaf 
use rev list 	directly accessed 
thin shallow 	via subtrees 
progress implied 	subtree prefixed 
rev list reflog 	excluding accessed 
rev list 	via subtrees 
index pack objects 	remainder 
options realloc 	accessed via 
read sha file 	subtrees levels 
die sha 	unused levels 
hex read sha 	unused levels 
file die 	val val 
sha hex diff 	practical 
delta die 	implications currently 
free free git 	uses lower 
deflate init 	bits address 
git deflate bound 	space userland 
xmalloc git 	thus leaving 
deflate git deflate 	subtrees 
end free 	unused avoiding 
git deflate init 	level traversal 
read istream 	number key 
die sha 	bits distinguished 
hex git deflate 	level cumulative 
sha write 	number 
die die git 	key bits 
deflate end 	distinguished traversing 
memset git inflate 	corresponding level 
init use 	precomputed table 
pack git inflate 	used convert 
git inflate 	number 
end use pack 	leading key 
sha write 	bits subtree 
open istream read 	level start 
sha file 	jemalloc structs 
die sha hex 	jemalloc externs 
free delta 	read 
compress encode pack 	first read 
header close 	may stale 
istream free 	reading val 
sha write sha 	behalf pointer 
write close 	valid allocation 
istream free sha 	guaranteed 
write sha 	clean read 
write close istream 	even without 
free sha 	synchronization rtree 
write write large 	update became 
blob data 	visible memory 
close istream sha 	pointer 
write free 	came existence 
encode pack header 	arbitrary read 
find pack 	behalf ivsalloc 
revindex check pack 	may dependent 
crc error 	previous rtree 
sha hex unuse 	write 
pack write 	means stale 
reuse check pack 	read could 
inflate error 	result synchronization 
sha hex 	omitted read 
unuse pack write 	first read 
reuse unuse 	may 
pack sha write 	stale node 
sha write 	leaf contains 
unuse pack sha 	values rather 
write sha 	child pointers 
write unuse pack 	node leaf 
sha write 	contains 
copy pack data 	values rather 
unuse pack 	child pointers 
crc begin write 	jemalloc inlines 
reuse write 	scripting.c lua 
reuse crc end 	reply lua 
write one 	reply 
write overflows die 	lua reply 
packlist find 	lua reply 
peel packlist find 	lua reply 
write order 	evalsha lua 
write order 	entry reply 
descendants write order 	lua 
tag alloc 	idx active 
write order write 	forked logs 
order write 	traces children 
order write order 	bpcount step 
family write 	luabp src 
order die pack 	lines 
valid die 	currentline cbuf 
git open noatime 	maxlen maxlen 
die errno 	hint sent 
lseek die errno 	digest script 
xread die 	len ctx 
errno sha write 	hash 
reuse packfile 	cset lua 
objects display progress 	reply lua 
close display 	reply lua 
progress start progress 	reply bulklen 
alloc compute 	lua reply 
write order 	lua 
sha throughput create 	reply lua 
tmp packfile 	reply mbulklen 
write pack header 	lua error 
write reused 	dbg msg 
pack write one 	lua lua 
display progress 	lua 
sha close sha 	err replylen 
close sha 	mbulklen lua 
close fixup pack 	error argc 
header footer 	cmd reply 
close stat warning 	argv argv 
strerror utime 	size 
warning strerror strbuf 	cached objects 
addf bitmap 	cached objects 
writer checksum bitmap 	len inuse 
writer build 	recursion warning 
type index finish 	obj obj 
tmp packfile 	len 
strbuf addf 	dbuf num 
sha hex stop 	cmdlog call 
progress bitmap 	flags lua 
writer show progress 	lua lua 
bitmap writer 	argc digest 
reuse bitmaps bitmap 	len 
writer commits 	lua field 
bitmap writer build 	lua lua 
bitmap writer 	lua lua 
finish strbuf release 	lua argc 
free puts 	log lua 
sha hex free 	argc 
free stop 	flags lua 
progress die git 	argc level 
attr setup 	log len 
delta attr check 	lua libname 
git check 	luafunc lua 
attr size 	lua 
attr packlist find 	lua code 
loose nonlocal 	setup lua 
find pack entry 	compare func 
one pack 	errh func 
valid size size 	lua elev 
pbase cache 	elec 
hashcmp pbase cache 	lua funcname 
incr read 	body funcdef 
sha file free 	retval lua 
xmalloc free 	elapsed evalsha 
hashcpy free free 	lua funcname 
entry isgitlink 	numkeys 
entry len memcmp 	err sha 
entry type 	count propargv 
isdir name cmp 	script funcname 
len pbase 	sha log 
init desc pbase 	entry entry 
pbase put 	trimmed 
done pbase 	proto act 
path pos alloc 	srcstring srclen 
grow memmove 	pid pid 
pack name hash 	evalsha line 
check pbase 	idx line 
path name cmp 	line 
len entry 	line argcp 
init desc pbase 	argv argc 
read reference 	copy plen 
hashcmp free xcalloc 	slen lnum 
hashcpy free 	line prefix 
free size free 	current 
free free 	thisline around 
use pack unpack 	context lua 
header buffer 	idx level 
unuse pack use 	strl strp 
pack use 	expected index 
pack msb error 	repr 
sha hex 	repr lua 
error sha 	idx lua 
hex find pack 	prefix reply 
revindex nth 	reply reply 
packed sha packlist 	reply reply 
find unuse 	reply 
pack size delta 	reply bulklen 
unuse pack 	reply reply 
unuse pack sha 	mbulklen reply 
info hashcmp 	log lua 
xcalloc qsort check 	varname name 
free max 	lua 
size read read 	vars name 
sha file 	prefix argv 
read unlock die 	argc arg 
sha hex 	line lua 
die sha hex 	argv argc 
read read 	code 
sha file read 	expr lua 
unlock warning 	argv argc 
sha hex 	saved lua 
die sha hex 	level argv 
die sha 	argc newval 
hex create delta 	lua 
index warning 	argv argc 
delta index create 	buf nread 
delta free 	ctx num 
free cache delta 	lua timeout 
cacheable cache 	elapsed 
unlock xrealloc cache 	timelimit reason 
unlock free 	sha init 
check delta limit 	sha update 
delta index 	sha redis 
free delta index 	protocol lua 
free xcalloc 	type 
progress progress unlock 	redis protocol 
display progress 	lua type 
progress unlock 	bulk redis 
free unpacked free 	protocol lua 
unpacked check 	type status 
delta limit delta 	redis 
compress cache 	protocol lua 
cache unlock free 	type error 
delta index 	redis protocol 
free free read 	lua type 
release pack 	multi bulk 
memory read unlock 	strchr 
init recursive 	lua pushnumber 
mutex pthread mutex 	strchr lua 
init pthread 	pushboolean lua 
mutex init pthread 	pushlstring strchr 
cond init 	lua newtable 
free routine free 	lua 
routine pthread 	pushstring lua 
cond destroy pthread 	pushlstring lua 
mutex destroy 	settable strchr 
pthread mutex 	lua newtable 
destroy pthread mutex 	lua pushstring 
destroy find 	lua 
deltas progress pthread 	pushlstring lua 
cond signal 	settable strchr 
progress unlock pthread 	lua pushboolean 
mutex pthread 	lua newtable 
cond wait pthread 	lua pushnumber 
mutex unlock 	redis 
init threaded search 	protocol lua 
find deltas 	type lua 
cleanup threaded search 	settable ldb 
xcalloc pthread 	log sdscatprintf 
mutex init pthread 	sdsempty lua 
cond init 	newtable 
pthread create die 	lua pushstring 
strerror progress 	lua getstack 
pthread cond wait 	lua getinfo 
progress unlock 	sdscatprintf sdsempty 
pthread mutex 	lua pushstring 
pthread cond signal 	sdsfree 
pthread mutex 	lua pushstring 
unlock pthread pthread 	lua settable 
cond destroy 	lua pushstring 
pthread mutex destroy 	lua gettable 
cleanup threaded 	lua error 
search free starts 	lua 
peel packlist 	getglobal lua 
find entry details 	pushstring lua 
alloc die 	gettable lua 
sha hex start 	pushvalue lua 
progress qsort 	pcall lua 
find deltas stop 	pop 
progress die 	lua pushstring 
free strcmp git 	lua gettable 
config strcmp 	lua pushvalue 
git config strcmp 	lua getglobal 
git config 	lua call 
strcmp git 	lua 
config die strcmp 	pop lua 
git config 	type reply 
strcmp git config 	bulk buffer 
strcmp git 	lua tostring 
config strcmp git 	lua strlen 
config strcmp 	reply 
git config die 	lua toboolean 
warning strcmp 	reply lua 
git config die 	tonumber lua 
git config 	pushstring lua 
fgets feof ferror 	gettable lua 
die die 	type 
errno clearerr sha 	sdsnew lua 
hex die 	tostring sdsmapchars 
preferred sha hex 	reply sds 
die preferred 	sdscatprintf sdsempty 
entry entry 	sdsfree lua 
index commit bitmap 	pop 
preferred entry 	lua pop 
preferred find pack 	lua pushstring 
entry one 	lua gettable 
oidcmp memset open 	lua type 
pack index 	sdsnew lua 
die alloc grow 	tostring 
nth packed 	sdsmapchars reply 
sha lookup unknown 	sds sdscatprintf 
mark pack 	sdsempty sdsfree 
qsort entry free 	lua pop 
find pack 	deferred multi 
entry one sha 	bulk 
lookup open 	length lua 
pack index die 	pop lua 
nth packed 	pushnumber lua 
sha packlist find 	gettable lua 
sha pack 	type lua 
kept nonlocal 	pop 
loosened discarded force 	lua reply 
loose die 	redis reply 
prepare bitmap walk 	deferred multi 
pack options 	bulk length 
allow reuse reuse 	reply lua 
packfile bitmap 	pop 
display progress traverse 	lua gettop 
bitmap commit 	server log 
list sha append 	lua push 
sha append 	error lua 
init revisions setup 	push error 
revisions repository 	lua 
shallow fgets strlen 	error zrealloc 
strcmp starts 	lua type 
sha hex die 	lua tonumber 
shallow die 	snprintf lua 
handle revision arg 	tolstring memcpy 
die list 	sdssetlen 
bitmap prepare 	create decr 
revision walk die 	count lua 
mark edges 	push error 
uninteresting traverse commit 	lua error 
list unseen 	sdsnew sdscatprintf 
recent objects traversal 	sdscatlen 
die prepare 	sdscatsds ldb 
revision walk die 	log lookup 
traverse commit 	command lua 
list objects unpacked 	push error 
packs loosen 	lua push 
unused packed objects 	error 
sha clear 	lua push 
strtoul die strtoul 	error lua 
die approxidate 	push error 
reset pack idx 	lua push 
option git 	error lua 
config isatty parse 	push 
options usage 	error free 
options argv 	memory needed 
push argv push 	lua push 
argv push 	error node 
argv push argv 	query lua 
push argv 	push 
push argv push 	error exec 
die online 	command propagate 
cpus warning die 	multi call 
warning die 	list length 
die repository shallow 	sdsnewlen list 
prepare packed 	length 
git start progress 	list node 
read list 	list first 
stdin list argv 	sdscatlen sdslen 
clear cleanup 	list del 
preferred stop progress 	node list 
prepare pack 	first 
write pack file 	redis protocol 
objects going 	lua type 
pack collected 	ldb log 
pack structure contains 	redis reply 
dynamically expanded 	lua sort 
data map resolve 	sdsfree 
sha position 	sdslen decr 
stats indexed commits 	count sdsalloc 
nothing going 	decr count 
reuse existing data 	zfree lua 
make sure 	error lua 
corrupt bust pack 	redis 
size limit 	command lua 
make sure cached 	redis command 
delta data 	lua gettop 
remains previous attempt 	lua pushstring 
pack split 	lua error 
occurred large blob 	lua 
compress well 	tolstring sha 
header type 	hex lua 
followed zero bytes 	pushstring lua 
length deltas 	gettop lua 
relative contain additional 	type lua 
encoding relative 	push 
offset delta position 	error lua 
pack deltas 	newtable lua 
reference contain additional 	pushstring lua 
bytes sha 	pushvalue lua 
bust pack size 	settable lua 
limit bust 	redis 
pack size limit 	single field 
apply size 	table lua 
limit limited packsize 	redis single 
first earlier 	field table 
fit limit avoid 	lua pushboolean 
mistaking unlimited 	redis 
limit delta unlimited 	srand rand 
packfile written 	lua pushboolean 
another pack 	lua pushboolean 
already exists pack 	lua pushboolean 
could end 	lua gettop 
another pack reuse 	sdscatprintf 
check decided 	sdsempty ldb 
pack split may 	cat stack 
pack delta 	sdscatlen ldb 
unusable want pack 	log lua 
afresh pack 	gettop lua 
undeltified need deltify 	pushstring 
already written 	lua error 
writing bust limit 	lua pushstring 
written normal 	lua error 
already scheduled written 	lua tonumber 
offset impossible 	lua pushstring 
mark fact involved 	lua 
write first 	error lua 
writing deltified recursion 	gettop lua 
offset non 	pushstring lua 
zero written 	error lua 
already deltified write 	isnumber lua 
first recurse 	pushstring 
cannot depend one 	lua error 
make sure 	lua tonumber 
sufficiently large wrap 	lua pushstring 
node siblings 	lua error 
drop level left 	sdsempty lua 
subtree nodes 	tolstring 
possible sibling might 	sdscatlen sdscatlen 
children next 	server log 
back parent node 	raw sdsfree 
right side 	lua pushcfunction 
subtree keep going 	lua pushstring 
right done 	lua 
hit original root 	call lua 
node pass 	load lib 
sibling level nothing 	lua load 
fully connect 	lib lua 
delta child 	load lib 
delta sibling network 	lua 
make sure 	load lib 
delta sibling sorted 	lua load 
original recency 	lib lua 
order mark first 	load lib 
child mark 	lua load 
objects tip tags 	lib 
give objects 	lua load 
original recency order 	lib lua 
see tagged 	load lib 
tip fill tagged 	lua pushnil 
tips remaining 	lua setglobal 
commits tags trees 	sdsempty 
rest really 	sdscatlen strlen 
tight order know 	lua loadbuffer 
actual number 	sdslen lua 
objects written 	pcall sdsfree 
many bytes written 	lua open 
many bytes 	ldb 
total many objects 	init lua 
total fake 	load libraries 
pretending objects writing 	lua unsupported 
size gives 	functions dict 
smooth progress meter 	create lua 
end matches 	newtable 
answer write wrong 	lua pushstring 
entries header 	lua pushcfunction 
rewrite like fast 	lua settable 
packs runtime 	lua pushstring 
accessed mtime order 	lua pushcfunction 
since newer 	lua 
packs likely contain 	settable lua 
younger objects 	pushstring lua 
creating multiple packs 	pushcfunction lua 
modify mtime 	settable lua 
later ones 	pushstring lua 
preserve mark written 	pushnumber 
objects written 	lua settable 
previous pack adding 	lua pushstring 
check whether 	lua pushnumber 
already added packing 	lua settable 
list skip 	lua pushstring 
however asked excludei 	lua 
previous mention 	pushnumber lua 
include make sure 	settable lua 
adjust flags 	pushstring lua 
tweak numbers accordingly 	pushnumber lua 
optimization pass 	settable lua 
index position would 	pushstring 
found item 	lua pushcfunction 
since saves look 	lua settable 
lines later 	lua pushstring 
want entry check 	lua pushcfunction 
whether want 	lua settable 
pack want 	lua 
objects found non 	pushstring lua 
local stores 	pushcfunction lua 
local option used 	settable lua 
side effect 	pushstring lua 
check find packed 	pushcfunction lua 
version therefore 	settable 
pass pack information 	lua pushstring 
avoid look 	lua pushcfunction 
later pack missing 	lua settable 
closure phony 	lua pushstring 
cache entry going 	lua pushnumber 
evict find 	lua 
mechanism toplevel node 	settable lua 
would almost 	pushstring lua 
always change commit 	pushnumber lua 
pbase cache 	settable lua 
acts limited hashtable 	pushstring lua 
found index 	pushnumber 
within slots 	lua settable 
slot cached find 	lua pushstring 
one either 	lua pushnumber 
got bogus request 	lua settable 
need read 	lua pushstring 
perhaps cache need 	lua 
either cache 	pushcfunction lua 
throwaway copy evict 	settable lua 
reuse want 	pushstring lua 
pack type even 	pushcfunction lua 
reuse delta 	settable lua 
since non delta 	setglobal 
representations could 	lua getglobal 
still reused determine 	lua pushstring 
delta whether 	lua pushcfunction 
reuse otherwise find 	lua settable 
cheaply possible 	lua pushstring 
actual type 	lua 
size delta hence 	pushcfunction lua 
already got 	settable lua 
need means wish 	setglobal lua 
reuse delta 	loadbuffer strlen 
data even found 	lua pcall 
list objects 	lua 
want pack goodie 	loadbuffer strlen 
depth matter 	lua pcall 
find deltas never 	create client 
consider reused 	scripting enable 
delta deltify objects 	globals protection 
order avoid 	dict 
circular deltas must 	release lua 
delta already 	close scripting 
know type extract 	release scripting 
actual size 	init lua 
delta header choice 	newtable lua 
fall back 	pushlstring 
recursive delta 	sdslen lua 
walk sha info 	rawseti lua 
find type 	setglobal lua 
point error condition 	number redis 
prepare pack 	lrand lua 
permit missing preferred 	gettop 
ignored preferred 	lua pushnumber 
result larger pack 	lua checkint 
file transfer 	lua argcheck 
still take place 	lua pushnumber 
avoid filesystem 	floor lua 
trashing loose objects 	checkint 
search deltas 	lua checkint 
list sorted type 	lua argcheck 
filename hash 	lua pushnumber 
size see progressively 	floor lua 
smaller smaller 	error redis 
files prefer deltas 	srand 
bigger file 	lua checkint 
smaller deletes 	sdsempty sdscat 
potentially cheaper perhaps 	sdscatlen sdscatlen 
importantly bigger 	sdscatlen sdslen 
file likely recent 	sdscatlen lua 
one deepest 	loadbuffer 
deltas therefore oldest 	sdslen reply 
objects less 	error format 
susceptible accessed often 	lua tostring 
newest first 	lua pop 
cache delta objects 	sdsfree sdsfree 
large enough 	lua 
compared delta size 	pcall reply 
bother diffs 	error format 
different types bother 	lua tostring 
delta discarded 	lua pop 
earlier reusing delta 	dict sdsnewlen 
data note 	server 
src entry marked 	info incr 
preferred always 	count unused 
considered even 	unused mstime 
produce suboptimal delta 	server log 
still save 	file process 
transfer cost already 	events 
know side 	blocked server 
won send src 	log lua 
entry bust 	pushstring lua 
allowed depth size 	error redis 
filtering heuristics 	srand reply 
load data already 	reply 
done objects 	error reply 
included resulting pack 	error sha 
resilient ignore 	hex sdslen 
read pack could 	lua getglobal 
created nevertheless 	lua getglobal 
prefer shallower sized 	lua 
deltas handle 	isnil lua 
memory allocation outside 	pop lua 
cache accounting 	pop reply 
compiler optimize 	lua create 
strangeness away pthreads 	function lua 
defined compute 	pop 
delta create objects 	lua getglobal 
going pack 	server lua 
current pack edge 	isnil lua 
take depth 	lua mstime 
objects depend current 	lua sethook 
account otherwise 	lua 
would become deep 	sethook lua 
decided cache 	pcall lua 
delta data best 	sethook create 
compress right 	file lua 
away first anyway 	reply error 
threaded save 	format 
lot time non 	lua tostring 
threaded write 	lua pop 
phase well 	lua reply 
allow caching deltas 	redis reply 
within cache 	lua pop 
size limit writing 	prevent 
stdout since 	command propagation 
network likely throttling 	create also 
writes anyway 	propagate decr 
therefore best write 	count replication 
phase asap 	script cache 
instead afford spending 	exists 
time compressing 	dict fetch 
writes moment made 	replication script 
delta already 	cache server 
max depth leaving 	info rewrite 
window pointless 	client 
evict first move 	command argument 
best delta 	reset count 
window currently deltified 	create rewrite 
keep longer 	client command 
first attempted 	argument force 
next main waits 	command 
condition least 	propagation eval 
one workers stopped 	command eval 
working indicated 	command debugging 
working member work 	sdslen reply 
completed work 	eval command 
sets working signals 	reply 
main waits 	error strcasecmp 
condition data ready 	scripting reset 
becomes mutex 	reply replication 
conditional variable statically 	script cache 
initialized windows 	flush strcasecmp 
must data ready 	reply 
wait condition 	multi bulk 
main may order 	len dict 
sure work 	find reply 
available see data 	reply strcasecmp 
ready initialized 	sha hex 
spawned reset 	sdslen 
right away working 	sdsnewlen dict 
doesn work 	find lua 
assigned partition work 	create function 
amongst work 	sdsfree reply 
threads use small 	bulk buffer 
segments deltas 	sdsfree 
found split chunks 	force command 
path boundaries 	propagation strcasecmp 
start work threads 	reply sds 
wait work 	sdsnew reply 
completion time done 	sds sdsnew 
work steal 	reply 
half remaining work 	strcasecmp client 
largest number 	pending replies 
unprocessed objects give 	reply error 
newly idle 	strcasecmp ldb 
ensure good load 	disable reply 
balancing remaining 	strcasecmp 
list segments 	ldb enable 
simply worth splitting 	reply strcasecmp 
anymore possible 	ldb enable 
paths many objects 	reply reply 
hash boundary 	error reply 
might found steal 	error 
exact half 	list create 
tag peelable packed 	list free 
locally repacking 	method list 
need doubly careful 	create sdsempty 
order make 	list first 
sure stealth corruption 	list 
gets propagated 	del node 
pack clients receiving 	ldb flush 
streamed packs 	log sdsfree 
validate everything anyway 	sdsempty list 
need incur 	node tail 
additional cost 	sdslen 
happens decided reuse 	sdsrange sdscatlen 
existing delta 	ldb log 
pack reuse delta 	ldb log 
implied found 	sdsnew sdsempty 
include anyway compare 	sdscatfmt list 
objects offset 	length 
order order emulate 	list length 
git rev 	list first 
list objects output 	sdscatlen sdsmapchars 
produced pack 	sdscatsds sdscatlen 
originally store list 	list del 
sha discarded 	node 
either written recently 	write sdslen 
reachable another 	sdsfree fork 
filled list tracks 	reply error 
options reader 	sigemptyset sigaction 
pack might understand 	sigaction server 
would therefore 	log 
prevent blind 	close listening 
reuse disk make 	sockets list 
sure shallows 	node tail 
read threads means 	free client 
autodetect pack-objects.c 	server log 
pdata sha found 	anet 
mask pos 	block anet 
pdata entry found 	send timeout 
pdata sha 	sdsdup sdslen 
index pos found 	sdssetlen sdssplitlen 
pdata sha 	sdslen sdsfree 
index pos entry 	ldb 
sha hash 	log sdsnew 
hashcmp closest pow 	ldb send 
free xcalloc 	logs write 
locate entry hash 	client server 
die locate 	log exit 
entry hash realloc 	child 
memset hashcpy 	server log 
rehash objects 	anet non 
objects going pack 	block anet 
collected pack 	send timeout 
structure contains dynamically 	sdsfreesplitres list 
expanded data 	search 
map resolve sha 	key list 
position stats 	del node 
indexed commits nothing 	list length 
going reuse 	list rewind 
existing data make 	list next 
sure corrupt 	server 
bust pack size 	log kill 
limit make 	list release 
sure cached delta 	list create 
data remains 	ldb start 
previous attempt pack 	session eval 
split occurred 	command 
large blob compress 	ldb end 
well header 	session ldb 
type followed 	disable ldb 
zero bytes length 	breakpoint memmove 
deltas relative 	sdslen sdsdup 
contain additional encoding 	strchr 
relative offset 	strstr atoi 
delta position pack 	zmalloc strstr 
deltas reference 	atoi sdsnewlen 
contain additional bytes 	sdsfree sdsfreesplitres 
sha bust 	sdsfree ldb 
pack size limit 	source 
bust pack 	line ldb 
size limit apply 	breakpoint sdscatprintf 
size limit 	sdsempty ldb 
limited packsize first 	log abs 
earlier fit 	ldb log 
limit avoid mistaking 	source 
unlimited limit 	line lua 
delta unlimited 	type sdscat 
packfile written another 	lua tolstring 
pack already 	sdscatrepr sdscat 
exists pack could 	lua toboolean 
end another 	sdscatprintf 
pack reuse check 	lua tonumber 
decided pack 	sdscatlen sdsempty 
split may pack 	sdsempty lua 
delta unusable 	pushnil lua 
want pack afresh 	next lua 
pack undeltified 	type 
need deltify already 	lua tonumber 
written writing 	ldb cat 
bust limit written 	stack rec 
normal already 	sdscatlen sdscatlen 
scheduled written offset 	ldb cat 
impossible mark 	stack 
fact involved write 	rec sdscatlen 
first writing 	ldb cat 
deltified recursion 	stack rec 
offset non zero 	sdscatlen lua 
written already 	pop sdslen 
deltified write first 	sdsrange 
recurse cannot 	sdslen sdsrange 
depend one make 	sdscatlen sdscatsds 
sure sufficiently 	sdscatlen sdsfree 
large wrap node 	sdsfree lua 
siblings drop 	topointer sdscatprintf 
level left subtree 	sdscat 
nodes possible 	ldb cat 
sibling might children 	stack rec 
next back 	sdsnew ldb 
parent node right 	cat stack 
side subtree 	ldb log 
keep going right 	max 
done hit 	len ldb 
original root node 	redis protocol 
pass sibling 	human ldb 
level nothing 	redis protocol 
fully connect delta 	human bulk 
child delta 	ldb 
sibling network make 	redis protocol 
sure delta 	human status 
sibling sorted original 	ldb redis 
recency order 	protocol human 
mark first child 	status ldb 
mark objects 	redis 
tip tags give 	protocol human 
objects original 	multi bulk 
recency order see 	strchr sdscatlen 
tagged tip 	strchr sdscatlen 
fill tagged tips 	sdscatrepr strchr 
remaining commits 	sdscatrepr 
tags trees rest 	strchr sdscatlen 
really tight 	sdscatlen ldb 
order know actual 	redis protocol 
number objects 	human sdscatlen 
written many 	sdscatlen sdsnew 
bytes written many 	ldb 
bytes total 	redis protocol 
many objects total 	human ldb 
fake pretending 	log max 
objects writing size 	len lua 
gives smooth 	getstack lua 
progress meter end 	getlocal 
matches answer 	strcmp ldb 
write wrong entries 	log stack 
header rewrite 	lua pop 
like fast packs 	lua pop 
runtime accessed 	strcmp strcmp 
mtime order since 	lua 
newer packs 	getglobal ldb 
likely contain younger 	log stack 
objects creating 	lua pop 
multiple packs modify 	ldb log 
mtime later 	sdsnew lua 
ones preserve 	getstack 
mark written objects 	lua getlocal 
written previous 	strstr sdscatprintf 
pack adding check 	sdsempty ldb 
whether already 	log stack 
added packing list 	sdsfree lua 
skip however 	pop 
asked excludei previous 	ldb log 
mention include 	sdsnew ldb 
make sure adjust 	log sdsnew 
flags tweak 	ldb log 
numbers accordingly optimization 	sdscatfmt sdsempty 
pass index 	ldb 
position would found 	log source 
item since 	line sdslen 
saves look lines 	ldb log 
later want 	sdscatfmt sdsempty 
entry check 	ldb log 
whether want pack 	sdsnew 
want objects 	ldb log 
found non local 	sdsnew ldb 
stores local 	breakpoint ldb 
option used side 	list ldb 
effect check 	log sdsnew 
find packed version 	ldb 
therefore pass 	del breakpoint 
pack information avoid 	ldb log 
look later 	sdsnew ldb 
pack missing closure 	log sdsnew 
phony cache 	sdsjoinsds sdscatsds 
entry going evict 	sdsnew 
find mechanism 	lua loadbuffer 
toplevel node would 	sdslen lua 
almost always 	pop lua 
change commit pbase 	loadbuffer sdslen 
cache acts 	ldb log 
limited hashtable 	sdscatfmt 
found index within 	sdsempty lua 
slots slot 	tostring lua 
cached find one 	pop sdsfree 
either got 	sdsfree sdsfree 
bogus request need 	lua pcall 
read perhaps 	ldb 
cache need either 	log sdscatfmt 
cache throwaway 	sdsempty lua 
copy evict reuse 	tostring lua 
want pack 	pop ldb 
type even reuse 	log stack 
delta since 	lua 
non delta representations 	pop lua 
could still 	getglobal lua 
reused determine delta 	pushstring lua 
whether reuse 	gettable lua 
otherwise find cheaply 	pushlstring sdslen 
possible actual 	lua 
type size 	pcall lua 
delta hence already 	pop lua 
got need 	getstack lua 
means wish reuse 	getinfo strstr 
delta data 	ldb log 
even found list 	sdscatprintf 
objects want 	sdsempty ldb 
pack goodie depth 	log source 
matter find 	line ldb 
deltas never consider 	log sdsnew 
reused delta 	atoi ldb 
deltify objects order 	log 
avoid circular 	sdscatprintf sdsempty 
deltas must delta 	ldb log 
already know 	sdscatprintf sdsempty 
type extract actual 	ldb repl 
size delta 	parse command 
header choice fall 	read 
back recursive 	sdscatlen sdsfree 
delta walk 	sdsempty strcasecmp 
sha info find 	strcasecmp ldb 
type point 	log sdsnew 
error condition prepare 	ldb log 
pack permit 	sdsnew 
missing preferred ignored 	ldb log 
preferred result 	sdsnew ldb 
larger pack file 	log sdsnew 
transfer still 	ldb log 
take place avoid 	sdsnew ldb 
filesystem trashing 	log 
loose objects search 	sdsnew ldb 
deltas list 	log sdsnew 
sorted type filename 	ldb log 
hash size 	sdsnew ldb 
see progressively smaller 	log sdsnew 
smaller files 	ldb 
prefer deltas 	log sdsnew 
bigger file smaller 	ldb log 
deletes potentially 	sdsnew ldb 
cheaper perhaps importantly 	log sdsnew 
bigger file 	ldb log 
likely recent one 	sdsnew 
deepest deltas 	ldb log 
therefore oldest objects 	sdsnew ldb 
less susceptible 	log sdsnew 
accessed often newest 	ldb log 
first cache 	sdsnew ldb 
delta objects large 	log 
enough compared 	sdsnew ldb 
delta size bother 	log sdsnew 
diffs different 	ldb log 
types bother delta 	sdsnew ldb 
discarded earlier 	log sdsnew 
reusing delta data 	ldb 
note src 	log sdsnew 
entry marked 	ldb log 
preferred always considered 	sdsnew ldb 
even produce 	log sdsnew 
suboptimal delta still 	ldb log 
save transfer 	sdsnew 
cost already know 	ldb log 
side won 	sdsnew ldb 
send src entry 	log sdsnew 
bust allowed 	ldb log 
depth size filtering 	sdsnew ldb 
heuristics load 	log 
data already done 	sdsnew ldb 
objects included 	log sdsnew 
resulting pack resilient 	ldb log 
ignore read 	sdsnew ldb 
pack could created 	send logs 
nevertheless prefer 	strcasecmp 
shallower sized deltas 	strcasecmp strcasecmp 
handle memory 	strcasecmp strcasecmp 
allocation outside 	strcasecmp strcasecmp 
cache accounting compiler 	strcasecmp ldb 
optimize strangeness 	trace ldb 
away pthreads defined 	send 
compute delta 	logs strcasecmp 
create objects going 	strcasecmp ldb 
pack current 	maxlen ldb 
pack edge take 	send logs 
depth objects 	strcasecmp strcasecmp 
depend current account 	ldb 
otherwise would 	ldb send 
become deep decided 	logs strcasecmp 
cache delta 	strcasecmp ldb 
data best compress 	eval ldb 
right away 	send logs 
first anyway threaded 	strcasecmp 
save lot 	strcasecmp lua 
time non threaded 	pushstring lua 
write phase 	error strcasecmp 
well allow 	strcasecmp ldb 
caching deltas within 	redis ldb 
cache size 	send 
limit writing stdout 	logs strcasecmp 
since network 	strcasecmp ldb 
likely throttling writes 	print ldb 
anyway therefore 	print ldb 
best write phase 	send logs 
asap instead 	strcasecmp 
afford spending time 	strcasecmp atoi 
compressing writes 	atoi ldb 
moment made delta 	list ldb 
already max 	send logs 
depth leaving window 	strcasecmp strcasecmp 
pointless evict 	ldb 
first move best 	list ldb 
delta window 	send logs 
currently deltified 	ldb log 
keep longer first 	sdsnew ldb 
attempted next 	send logs 
main waits condition 	sdsfreesplitres 
least one 	sdsfreesplitres lua 
workers stopped working 	getstack lua 
indicated working 	getinfo ldb 
member work completed 	breakpoint strstr 
work sets 	mstime ldb 
working signals main 	log 
waits condition 	sdscatprintf sdsempty 
data ready becomes 	ldb log 
mutex conditional 	source line 
variable statically initialized 	ldb send 
windows must 	logs ldb 
data ready wait 	repl 
condition main 	lua pushstring 
may order sure 	lua error 
work available 	mstime copyright 
see data 	salvatore sanfilippo 
ready initialized spawned 	antirez gmail 
reset right 	dot 
away working doesn 	rights reserved 
work assigned 	redistribution use 
partition work amongst 	source binary 
work threads 	forms without 
use small segments 	modification permitted 
deltas found 	provided 
split chunks path 	following conditions 
boundaries start 	met redistributions 
work threads wait 	source code 
work completion 	must retain 
time done work 	copyright notice 
steal half 	list 
remaining work largest 	conditions following 
number unprocessed 	disclaimer redistributions 
objects give newly 	binary form 
idle ensure 	must reproduce 
good load 	copyright notice 
balancing remaining list 	list 
segments simply 	conditions following 
worth splitting anymore 	disclaimer documentation 
possible paths 	materials provided 
many objects hash 	distribution neither 
boundary might 	name redis 
found steal exact 	names 
half tag 	contributors may 
peelable packed locally 	used endorse 
repacking need 	promote products 
doubly careful order 	derived software 
make sure 	without specific 
stealth corruption gets 	prior 
propagated pack 	written permission 
clients receiving streamed 	software provided 
packs validate 	copyright holders 
everything anyway need 	contributors express 
incur additional 	implied warranties 
cost happens 	including 
decided reuse existing 	limited implied 
delta pack 	warranties merchantability 
reuse delta implied 	fitness particular 
found include 	purpose disclaimed 
anyway compare objects 	shall 
offset order 	copyright owner 
order emulate git 	contributors liable 
rev list 	direct indirect 
objects output produced 	incidental special 
pack originally 	exemplary consequential 
store list sha 	damages 
discarded either 	including limited 
written recently reachable 	procurement substitute 
another filled 	goods services 
list tracks options 	loss use 
reader pack 	data profits 
might understand would 	business 
therefore prevent 	interruption however 
blind reuse 	caused theory 
disk make sure 	liability whether 
shallows read 	contract strict 
threads means autodetect 	liability tort 
pack usage 	including 
pack written list 	negligence otherwise 
result written 	arising way 
non empty reuse 	use software 
keep unreachable 	even advised 
unpack unreachable include 	possibility damage 
tag unpack 	debugger 
unreachable expiration local 	shared state 
incremental ignore 	stored inside 
packed keep allow 	structure max 
ofs delta 	number breakpoints 
pack idx opts 	len limit 
name progress 	replies 
window pack 	dumps socket 
size limit depth 	debugging client 
delta search 	debugging eval 
threads pack stdout 	right fork 
num preferred 	debugging session 
progress state pack 	list 
compression level 	messages send 
pack compression seen 	client messages 
reuse packfile 	redis commands 
reuse packfile objects 	executed since 
reuse packfile 	last stop 
offset use bitmap 	forked 
index write 	debugging sessions 
bitmap index write 	pids breakpoints 
bitmap options 	line numbers 
delta cache size 	number valid 
max delta 	entries inside 
cache size cache 	stop 
max small 	next line 
delta size 	ragardless breakpoints 
window memory limit 	stop next 
written written 	line redis 
delta reused reused 	breakpoint called 
delta indexed 	lua 
commits indexed commits 	script source 
indexed commits 	code split 
alloc commit entry 	line number 
size size 	lines src 
delta size buf 	current line 
buf delta 	number 
buf pptr size 	debugger client 
stream maxsize 	command buffer 
sha stream ibuf 	max dump 
obuf olen 	reply length 
readlen zret curs 	already hint 
offset len 	maxlen 
expect stream fakebuf 	utility functions 
curs offset 	perform sha 
len avail 	input use 
entry limit usable 	hashing script 
delta size 	bodies order 
datalen header dheader 	obtain 
hdrlen buf 	lua function 
ofs pos entry 	name implementation 
limit usable 	redis sha 
delta curs revidx 	digest point 
offset datalen 	bytes buffer 
header dheader hdrlen 	sha 
ofs pos 	converted hexadecimal 
entry write offset 	number plus 
limit len 	term redis 
usable delta reuse 	reply lua 
path oid 	type conversion 
flag data peeled 	functions 
entry endp 	take redis 
endp order endp 	reply redis 
root end 	protocol format 
last untagged 	convert lua 
objects buffer write 	type thanks 
total read 	function 
pack offset remaining 	introduction connected 
last mtime 	clients trivial 
write order sha 	implement redis 
pack tmp 	lua function 
name packfile size 	basically take 
tmpname utb 	arguments 
check attr delta 	execute redis 
path check 	command context 
sha exclude index 	non connected 
pos entry 	client take 
sha exclude found 	generated reply 
pack found 	convert 
offset offset create 	suitable lua 
entry closure 	type trick 
warning entry 	scripting feature 
entry bitmap sha 	need introduction 
temporary data 	full redis 
size sha next 	internals 
pcache sha 	api script 
ent nent data 	like normal 
size neigh 	client bypasses 
available cache name 	slow paths 
name cmplen 	note function 
fullname entry cmp 	sanity 
sub downlen 	check reply 
done pbase paths 	generated redis 
done pbase 	directly allows 
paths num done 	faster errors 
pbase paths 	returned table 
alloc hash hash 	single 
pos name 	err field 
cmplen hash sha 	error function 
data size 	used order 
sha entry 	push error 
curs entry used 	lua stack 
used avail 	format 
ofs buf revidx 	used redis 
sorted offset 	pcall errors 
entry entry data 	lua table 
index depth 	single err 
src size trg 	field error 
size delta 	note 
size read mutex 	table never 
cache mutex 	valid reply 
progress mutex trg 	proper commands 
src max 	since returned 
depth mem usage 	tables otherwise 
trg entry 	always 
src entry trg 	indexed integers 
size src 	never debugging 
size delta size 	active step 
sizediff max 	mode log 
size depth 	errors resulting 
delta buf warned 	redis 
warned child 	commands attempt 
freed mem list 	figure function 
list size 	called possible 
window depth processed 	error lua 
count mem 	stack lua 
usage entry max 	push 
depth best 	error generated 
tail ret idx 	non error 
swap dist 	trapping version 
dst src size 	redis pcall 
old free 	redis call 
routine list list 	function 
size remaining 	lua error 
window depth working 	execution script 
data ready 	halted sort 
mutex cond processed 	currently stack 
progress cond 	make output 
arg list 	commands 
list size window 	like keys 
depth processed 	smembers something 
ret active threads 	deterministic called 
sub size 	lua play 
target victim sub 	well replication 
size path 	sorted 
oid flag data 	table sort 
peeled window 	assuming list 
depth delta list 	elements initial 
deltas entry 	stack stack 
done level line 	table table 
sha commit 	sort 
data obj name 	stack table 
data commit 	table sort 
offset alloc pack 	stack table 
revs pack 	error interested 
sha sha 	error problem 
last found recent 	elements 
objects sha 	inside slower 
mtime revs sha 	function able 
revs obj 	handle table 
name data commit 	sort table 
data revs 	redis compare 
line flags len 	helper 
sha opt 	stack table 
arg unset val 	stack table 
opt arg 	sort stack 
unset argc argv 	table table 
prefix use 	sort stack 
rev list thin 	table 
shallow progress 	table sort 
implied rev list 	stack table 
reflog rev 	table sort 
list index pack 	redis compare 
objects options 	helper stack 
realloc read 	sorted 
sha file die 	table stack 
sha hex 	sorted lua 
read sha file 	reply redis 
die sha 	reply conversion 
hex diff delta 	functions need 
die free 	check 
free git deflate 	error status 
init git 	reply error 
deflate bound xmalloc 	returned single 
git deflate 	element table 
git deflate end 	err field 
free git 	status 
deflate init read 	replies returned 
istream die 	single element 
sha hex git 	table field 
deflate sha 	discard field 
write die die 	popped lua 
git deflate 	redis 
end memset 	functions implementations 
git inflate init 	cached across 
use pack 	calls recursive 
git inflate git 	calls detection 
inflate end 	lua debug 
use pack sha 	hooks 
write open 	possible trigger 
istream read sha 	recursive call 
file die 	lua redis 
sha hex free 	command normally 
delta compress 	never happen 
encode pack header 	make 
close istream 	function reentrant 
free sha write 	futile makes 
sha write 	slower least 
close istream free 	detect misuse 
sha write 	abort require 
sha write close 	least 
istream free 	one argument 
sha write 	build arguments 
write large blob 	vector use 
data close 	lua tolstring 
istream sha write 	number conversion 
free encode 	since 
pack header find 	lua uses 
pack revindex 	format specifier 
check pack crc 	loses precision 
error sha 	use cached 
hex unuse pack 	check one 
write reuse 	arguments 
check pack inflate 	passed lua 
error sha 	script integer 
hex unuse pack 	lua isstring 
write reuse 	integers well 
unuse pack sha 	setup fake 
write sha 	client 
write unuse pack 	command execution 
sha write 	log command 
sha write 	debugging active 
unuse pack sha 	command lookup 
write copy 	commands allowed 
pack data unuse 	inside 
pack crc 	scripts write 
begin write reuse 	commands forbidden 
write reuse 	read slaves 
crc end write 	command marked 
one write 	non deterministic 
overflows die packlist 	already 
find peel 	called context 
packlist find write 	script reached 
order write 	memory limit 
order descendants write 	configured via 
order tag 	maxmemory commands 
alloc write order 	could 
write order 	enlarge memory 
write order 	usage allowed 
write order family 	first write 
write order 	context script 
die pack valid 	otherwise stop 
die git 	middle 
open noatime die 	redis cluster 
errno lseek 	node need 
die errno xread 	make sure 
die errno 	lua trying 
sha write reuse 	access non 
packfile objects 	local 
display progress close 	keys commands 
display progress 	received master 
start progress alloc 	duplicate relevant 
compute write 	flags lua 
order sha throughput 	client single 
create tmp 	commands 
packfile write pack 	replication need 
header write 	wrap propagate 
reused pack 	multi exec 
write one display 	block atomic 
progress sha 	like lua 
close sha close 	script 
sha close 	context aof 
fixup pack header 	slaves run 
footer close 	command flags 
stat warning strerror 	according redis 
utime warning 	repl settings 
strerror strbuf addf 	convert 
bitmap writer 	result redis 
checksum bitmap writer 	command suitable 
build type 	lua type 
index finish tmp 	first thing 
packfile strbuf 	need create 
addf sha hex 	single 
stop progress 	client output 
bitmap writer show 	buffers fast 
progress bitmap 	path common 
writer reuse 	reply inside 
bitmaps bitmap writer 	client buffer 
commits bitmap 	create 
writer build bitmap 	sds use 
writer finish 	client buffer 
strbuf release free 	directly debugger 
puts sha 	active log 
hex free free 	reply redis 
stop progress 	sort 
die git attr 	output needed 
setup delta 	assuming non 
attr check git 	multi bulk 
check attr 	reply expected 
size attr packlist 	clean command 
find loose 	code 
nonlocal find pack 	may changed 
entry one 	argv argc 
pack valid size 	use argv 
size pbase 	argc client 
cache hashcmp 	instead local 
pbase cache incr 	variables 
read sha 	cache cached 
file free xmalloc 	objects must 
free hashcpy 	small sds 
free free entry 	encoded refcount 
isgitlink entry 	must owner 
len memcmp entry 	cache 
type isdir 	error stack 
name cmp len 	form table 
pbase init 	err field 
desc pbase pbase 	extract plain 
put done 	error redis 
pbase path pos 	call 
alloc grow 	redis pcall 
memmove pack name 	adds redis 
hash check 	sha hex 
pbase path 	lua scripts 
name cmp len 	hashing function 
entry init 	used 
desc pbase read 	sha ing 
reference hashcmp 	lua scripts 
free xcalloc hashcpy 	returns table 
free free 	single field 
size free free 	field passed 
free use 	argument 
pack unpack header 	helper function 
buffer unuse 	handy returning 
pack use pack 	redis protocol 
use pack 	error status 
msb error sha 	reply lua 
hex error 	redis 
sha hex find 	error reply 
pack revindex 	err error 
nth packed sha 	redis status 
packlist find 	reply err 
unuse pack 	error redis 
size delta unuse 	error 
pack unuse 	reply redis 
pack sha info 	status reply 
hashcmp xcalloc 	redis replicate 
qsort check free 	commands turn 
max size 	single commands 
read read sha 	replication 
file read 	script never 
unlock die sha 	called write 
hex die 	command far 
sha hex read 	returns otherwise 
read sha 	script already 
file read unlock 	started 
warning sha 	write returns 
hex die sha 	stick whole 
hex die 	scripts replication 
sha hex create 	single commands 
delta index 	replication provide 
warning delta 	different 
index create delta 	math random 
free free 	sequences every 
cache delta cacheable 	call user 
cache unlock 	normally expects 
xrealloc cache unlock 	redis breakpoint 
free check 	allows 
delta limit delta 	stop execution 
index free 	debuggign session 
delta index free 	within lua 
xcalloc progress 	code implementation 
progress unlock display 	like breakpoint 
progress progress 	code 
unlock free unpacked 	immediately function 
free unpacked 	redis debug 
check delta limit 	log message 
delta compress 	output console 
cache cache unlock 	take multiple 
free delta 	arguments 
index free 	separated commas 
free read release 	nothing returned 
pack memory 	caller redis 
read unlock init 	repl propagation 
recursive mutex 	write commands 
pthread mutex init 	executed 
pthread mutex 	context script 
init pthread cond 	aof slaves 
init free 	redis log 
routine free routine 	glue together 
pthread cond 	arguments lua 
destroy pthread mutex 	engine 
destroy pthread 	initialization reset 
mutex destroy pthread 	stuff load 
mutex destroy 	currently sandboxing 
find deltas progress 	concerns functions 
pthread cond 	want expose 
signal progress 	redis 
unlock pthread mutex 	scripting environment 
pthread cond 	function installs 
wait pthread mutex 	metamethods table 
unlock init 	prevent creation 
threaded search find 	globals accidentally 
deltas cleanup 	last 
threaded search xcalloc 	called scripting 
pthread mutex 	engine initialization 
init pthread cond 	sequence may 
init pthread 	interact creation 
create die strerror 	globals 
progress pthread 	strict lua 
cond wait progress 	http metalua 
unlock pthread 	luaforge net 
mutex pthread cond 	src lib 
signal pthread 	strict lua 
mutex unlock pthread 	html 
pthread cond 	modified adapted 
destroy pthread 	redis initialize 
mutex destroy cleanup 	scripting environment 
threaded search 	function called 
free starts peel 	first time 
packlist find 	server 
entry details alloc 	startup setup 
die sha 	argument called 
hex start progress 	multiple times 
qsort find 	lifetime redis 
deltas stop progress 	process setup 
die free 	following 
strcmp git config 	scripting release 
strcmp git 	call order 
config strcmp git 	reset lua 
config strcmp 	scripting environment 
git config die 	however simpler 
strcmp git 	call 
config strcmp git 	scripting reset 
config strcmp 	debug change 
git config 	initialize dictionary 
strcmp git config 	use map 
strcmp git 	scripts useful 
config die warning 	replication 
strcmp git 	need replicate 
config die git 	evalsha eval 
config fgets 	need remember 
feof ferror die 	associated script 
die errno 	redis commands 
clearerr sha hex 	table 
die preferred 	fields redis 
sha hex die 	call redis 
preferred entry 	pcall redis 
entry index commit 	log log 
bitmap preferred 	levels redis 
entry preferred find 	sha 
pack entry 	hex redis 
one oidcmp memset 	error reply 
open pack 	redis status 
index die 	reply redis 
alloc grow nth 	replicate commands 
packed sha 	redis 
lookup unknown mark 	repl associated 
pack qsort 	flags redis 
entry free find 	breakpoint redis 
pack entry 	debug table 
one sha lookup 	redis replace 
open pack 	math 
index die nth 	random math 
packed sha 	randomseed implementations 
packlist find sha 	helper function 
pack kept 	use sort 
nonlocal loosened discarded 	multi bulk 
force loose 	output 
die prepare bitmap 	non deterministic 
walk pack 	commands containing 
options allow reuse 	elements helper 
reuse packfile 	function use 
bitmap display 	pcall error 
progress traverse bitmap 	reporting 
commit list 	note error 
sha append sha 	function want 
append init 	report information 
revisions setup revisions 	caller makes 
repository shallow 	sense point 
fgets strlen strcmp 	view 
starts sha 	user debugging 
hex die shallow 	script create 
die handle 	non connected 
revision arg die 	client use 
list bitmap 	execute redis 
prepare revision walk 	commands 
die mark 	inside lua 
edges uninteresting traverse 	interpreter note 
commit list 	need create 
unseen recent 	function called 
objects traversal die 	scripting reset 
prepare revision 	lua 
walk die traverse 	beginners often 
commit list 	use local 
objects unpacked packs 	likely introduce 
loosen unused 	subtle bugs 
packed objects sha 	code prevent 
clear strtoul 	problems 
die strtoul die 	protect accesses 
approxidate reset 	variables release 
pack idx option 	resources related 
git config 	lua scripting 
isatty parse options 	function used 
usage options 	order 
argv push argv 	reset scripting 
push argv 	environment redis 
push argv push 	objects lua 
argv push 	table stored 
argv push 	variable redis 
argv push die 	provided 
online cpus 	math random 
warning die warning 	replace math 
die die 	random implementation 
repository shallow prepare 	affected specific 
packed git 	libc random 
start progress read 	implementations 
list stdin 	output sequence 
list argv clear 	seed every 
cleanup preferred 	arch following 
stop progress prepare 	implementation one 
pack write 	shipped lua 
pack file objects 	rand 
going pack 	replaced redis 
collected pack structure 	lrand avoids 
contains dynamically 	rare needed 
expanded data map 	also systems 
resolve sha 	sun rand 
position stats 	may 
indexed commits nothing 	larger rand 
going reuse 	max check 
existing data make 	number arguments 
sure corrupt 	arguments number 
bust pack size 	upper limit 
limit make 	lower 
sure cached delta 	upper limits 
data remains 	eval script 
previous attempt pack 	commands implementation 
split occurred 	define lua 
large blob compress 	function specified 
well header 	function 
type followed zero 	name body 
bytes length 	function name 
deltas relative contain 	musts characters 
additional encoding 	since functions 
relative offset delta 	defined lua 
position pack 	context 
deltas reference 	form hex 
contain additional bytes 	sha sum 
sha bust 	success returned 
pack size limit 	nothing left 
bust pack 	lua stack 
size limit apply 	error 
size limit 	err returned 
limited packsize first 	appropriate error 
earlier fit 	client context 
limit avoid mistaking 	also save 
unlimited limit 	sha original 
delta unlimited packfile 	script 
written another 	map dictionary 
pack already exists 	replicate write 
pack could 	aof evalsha 
end another pack 	commands eval 
reuse check 	original script 
decided pack 	lua 
split may pack 	script count 
delta unusable 	hook use 
want pack afresh 	detect scripts 
pack undeltified 	timeout script 
need deltify already 	timeouts reenter 
written writing 	loop 
bust limit written 	permit others 
normal already 	call script 
scheduled written offset 	kill shutdown 
impossible mark 	nosave needed 
fact involved write 	reason need 
first writing 	mask 
deltified recursion offset 	client executing 
non zero 	script loop 
written already deltified 	client may 
write first 	disconnect could 
recurse cannot depend 	longer eval 
one make 	command 
sure sufficiently 	replicate whole 
large wrap node 	scripts want 
siblings drop 	prng sequence 
level left subtree 	every call 
nodes possible 	prng affected 
sibling might children 	external 
next back 	state flag 
parent node right 	zero remember 
side subtree 	far random 
keep going right 	command called 
done hit 	way allow 
original root node 	user 
pass sibling 	call commands 
level nothing fully 	like srandmember 
connect delta 	randomkey lua 
child delta sibling 	scripts far 
network make 	write command 
sure delta sibling 	called 
sorted original 	otherwise replication 
recency order 	aof would 
mark first child 	end non 
mark objects 	deterministic sequences 
tip tags give 	thanks flag 
objects original 	error 
recency order see 	every time 
tagged tip 	write command 
fill tagged tips 	called random 
remaining commits 	command used 
tags trees rest 	number arguments 
really tight 	keys 
order know actual 	obtain script 
number objects 	sha check 
written many bytes 	function already 
written many 	defined lua 
bytes total many 	state hash 
objects total 	code 
fake pretending objects 	eval call 
writing size 	already sha 
gives smooth 	evalsha convert 
progress meter end 	lowercase use 
matches answer 	tolower since 
write wrong entries 	function 
header rewrite 	managed always 
like fast packs 	show profiler 
runtime accessed 	output consuming 
mtime order since 	non trivial 
newer packs 	amount time 
likely contain younger 	push 
objects creating 	pcall error 
multiple packs modify 	handler function 
mtime later 	stack lookup 
ones preserve mark 	lua function 
written objects 	nil stack 
written previous pack 	function 
adding check 	defined define 
whether already added 	body function 
packing list 	evalsha call 
skip however 	error error 
asked excludei previous 	handler stack 
mention include 	error 
make sure adjust 	handler stack 
flags tweak 	error sent 
numbers accordingly optimization 	client lua 
pass index 	create function 
position would found 	returns err 
item since 	following 
saves look lines 	guaranteed non 
later want 	nil populate 
entry check whether 	argv keys 
want pack 	table accordingly 
want objects found 	arguments eval 
non local 	received 
stores local option 	right context 
used side 	lua client 
effect check 	hook order 
find packed version 	able stop 
therefore pass 	script execution 
pack information avoid 	running 
look later 	much time 
pack missing closure 	hook time 
phony cache 	limit enabled 
entry going evict 	hook make 
find mechanism 	lua script 
toplevel node would 	execution 
almost always 	slower debugging 
change commit pbase 	instead line 
cache acts 	hook debugger 
limited hashtable found 	call back 
index within 	every line 
slots slot cached 	executed 
find one 	script point 
either got bogus 	whether script 
request need 	never seen 
read perhaps 	already defined 
cache need either 	call zero 
cache throwaway 	arguments 
copy evict reuse 	expect single 
want pack 	perform cleanup 
type even reuse 	need error 
delta since 	success disable 
non delta representations 	hook restore 
could still 	readable 
reused determine delta 	handler unregistered 
whether reuse 	script timeout 
otherwise find cheaply 	detected call 
possible actual 	lua garbage 
type size delta 	collector time 
hence already 	time 
got need means 	avoid full 
wish reuse 	cycle performed 
delta data even 	lua adds 
found list 	latency call 
objects want 	performed every 
pack goodie depth 	lua 
matter find 	cycle period 
deltas never consider 	executed commands 
reused delta 	lua cycle 
deltify objects order 	period collection 
avoid circular 	steps calling 
deltas must delta 	every 
already know 	command uses 
type extract actual 	much cpu 
size delta 	consume lua 
header choice fall 	reply error 
back recursive 	handler success 
delta walk sha 	convert 
info find 	lua redis 
type point error 	protocol send 
condition prepare 	client convert 
pack permit missing 	consume reply 
preferred ignored 	error handler 
preferred result 	single 
larger pack file 	commands replication 
transfer still 	emit exec 
take place avoid 	least write 
filesystem trashing 	evalsha propagated 
loose objects search 	slave aof 
deltas list 	file 
sorted type filename 	full eval 
hash size 	unless sure 
see progressively smaller 	script already 
smaller files 	context attached 
prefer deltas bigger 	slaves current 
file smaller 	aof 
deletes potentially cheaper 	file enabled 
perhaps importantly 	use cache 
bigger file likely 	sha scripts 
recent one 	already propagated 
deepest deltas 	full eval 
therefore oldest objects 	called 
less susceptible 	replication script 
accessed often newest 	cache repliation 
first cache 	everytime slave 
delta objects large 	attaches master 
enough compared 	need flush 
delta size bother 	cache 
diffs different 	scripts replicated 
types bother delta 	evalsha aof 
discarded earlier 	need every 
reusing delta data 	time rewrite 
note src 	aof file 
entry marked preferred 	script 
always considered 	script cache 
even produce suboptimal 	replicate eval 
delta still 	script cache 
save transfer cost 	slaves aof 
already know 	know know 
side won 	match 
send src entry 	possible provided 
bust allowed 	sha right 
depth size filtering 	length error 
heuristics load 	asap way 
data already done 	eval command 
objects included 	implemented 
resulting pack resilient 	without length 
ignore read 	sanity check 
pack could created 	propagating command 
nevertheless prefer 	good idea 
shallower sized deltas 	ldb redis 
handle memory 	lua 
allocation outside cache 	debugging facilities 
accounting compiler 	initialize lua 
optimize strangeness away 	debugger data 
pthreads defined 	structures pending 
compute delta create 	messages specified 
objects going 	list 
pack current 	enable debug 
pack edge take 	mode lua 
depth objects 	scripts client 
depend current account 	exit debugging 
otherwise would 	mode pov 
become deep decided 	client 
cache delta 	function enough 
data best compress 	properly shut 
right away 	client debugging 
first anyway threaded 	session see 
save lot 	ldb end 
time non threaded 	session 
write phase 	information append 
well allow caching 	log entry 
deltas within 	specified ldb 
cache size limit 	log version 
writing stdout 	ldb log 
since network likely 	prevents 
throttling writes 	producing logs 
anyway therefore 	greater ldb 
best write phase 	maxlen first 
asap instead 	time limit 
afford spending time 	reached hint 
compressing writes 	generated 
moment made delta 	inform user 
already max 	reply trimming 
depth leaving window 	disabled debugger 
pointless evict 	maxlen command 
first move best 	send ldb 
delta window 	logs 
currently deltified keep 	debugging client 
longer first 	multi bulk 
attempted next main 	reply consisting 
waits condition 	simple log 
least one workers 	entries include 
stopped working 	newlines 
indicated working 	replaced spaces 
member work completed 	entries sent 
work sets 	also consumed 
working signals main 	avoid warning 
waits condition 	check write 
data ready becomes 	since 
mutex conditional 	next read 
variable statically initialized 	error close 
windows must 	debugging session 
data ready wait 	start debugging 
condition main 	session calling 
may order sure 	eval 
work available 	implementation techique 
see data ready 	use capture 
initialized spawned 	client socket 
reset right away 	file descriptor 
working doesn 	order perform 
work assigned partition 	direct 
work amongst 	within lua 
work threads 	hooks way 
use small segments 	enter redis 
deltas found 	order handle 
split chunks path 	function returns 
boundaries start 	caller 
work threads wait 	proceed call 
work completion 	eval instead 
time done work 	caller abort 
steal half 	operation happens 
remaining work largest 	parent forked 
number unprocessed 	session 
objects give newly 	since children 
idle ensure 	fork returned 
good load balancing 	error caller 
remaining list 	call ldb 
segments simply worth 	end session 
splitting anymore 	ldb 
possible paths many 	start session 
objects hash 	returned child 
boundary might 	ignore important 
found steal exact 	signals handled 
half tag 	parent 
peelable packed locally 	log creation 
repacking need 	child close 
doubly careful order 	listening socket 
make sure 	make sure 
stealth corruption gets 	parent crashes 
propagated pack 	reset 
clients receiving streamed 	sent clients 
packs validate 	parent close 
everything anyway need 	client parent 
incur additional 	side setup 
cost happens decided 	debugging session 
reuse existing 	first 
delta pack reuse 	argument eval 
delta implied 	script split 
found include anyway 	different lines 
compare objects 	since way 
offset order 	debugger accesses 
order emulate git 	source 
rev list 	code end 
objects output produced 	debugging session 
pack originally 	eval call 
store list sha 	debugging enabled 
discarded either 	returned emit 
written recently reachable 	remaining 
another filled 	logs endsession 
list tracks options 	mark fork 
reader pack 	session exit 
might understand would 	otherwise restore 
therefore prevent 	client state 
blind reuse disk 	close 
make sure 	client connectin 
shallows read threads 	sending eval 
means autodetect 	reply order 
pack-objects.h idx size 	signal end 
pack pack 	debugging session 
offset delta 	cleanup 
delta child delta 	specified pid 
sibling delta 	among list 
data delta size 	children spawned 
delta size 	forked debugging 
hash pack pos 	sessions removed 
pack header 	children 
size objects objects 	list pid 
alloc index 	found non 
index size pdata 	zero returned 
sha index 	number children 
pos pdata sha 	still received 
index pos 	termination 
name hash isspace 	acknowledge via 
uncompressed size 	wait parent 
already pack delta 	process kill 
deltified objects 	forked sessions 
bases deltified 	wrapper eval 
objects uses cached 	evalsha 
delta uncompressed 	enables debugging 
delta data size 	makes sure 
uncompressed delta 	eval returns 
data size compressed 	whatever happened 
could delta 	session ended 
name hint hash 	pointer 
pack available 	ldb src 
used delta objects 	source code 
near tip 	line considering 
refs assigned write 	line one 
order effectively 	returning special 
creates sortable number 	range 
last sixteen 	lines breakpoint 
non whitespace characters 	specified line 
last characters 	specified breakpoint 
count things end 	ignore already 
sort together 	reached max 
pack-redundant.c pack 	returns 
redundant usage load 	breakpoint added 
packs verbose 	already space 
alt odb next 	breakpoint line 
sha front 	invalid specified 
back size next 	breakpoint returning 
pack unique 	operation 
objects objects next 	performed breakpoint 
free nodes 	expect valid 
item list list 	multi bulk 
list ret 	command debugging 
old prev list 	client query 
sha list 	buffer 
sha list sha 	success command 
hint cmp 	parsed returned 
list sha hint 	sds otherwise 
prev cmp 	returned read 
hint entry ret 	buffer working 
ret step 	copy 
step hint 	simpler modify 
cmp old opl 	freely sake 
list subset 	simpler parsing 
pll list diff 	redis protocol 
ret step 	parser joke 
step cmp subset 	simplest 
ret ret 	thing works 
min min perm 	context also 
perm perm 	forgiving regarding 
perm missing perm 	broken protocol 
size hint 	seek parse 
subset local alt 	count 
step filename 	multi bulk 
argc argv prefix 	len pointer 
min red 	parse argument 
ignore sha buf 	bulk len 
arg alloc 	pointer length 
llist item put 	arg 
llist item 	skip already 
put free 	parsed argument 
xmalloc llist init 	skip log 
llist item 	specified line 
llist item llist 	lua debugger 
item llist 	output 
insert hashcmp llist 	implement list 
insert llist 	command lua 
insert back hashcmp 	debugger around 
llist item 	whole file 
put llist sorted 	listed otherwise 
xmalloc memcpy 	small 
pack list difference 	portion file 
xmalloc memcpy 	around specified 
pack list difference 	line shown 
hashcmp llist 	line number 
sorted llist sorted 	specified amonut 
free free 	context 
pack list 	lines specified 
size xmalloc pack 	via context 
list insert 	argument append 
permutations xmalloc pack 	human readable 
list insert 	representation lua 
llist copy llist 	position 
sorted difference 	idx stack 
inplace llist free 	lua state 
llist free 	sds passed 
hashcmp pack list 	argument sds 
insert pack 	represented attached 
list insert llist 	returned 
copy llist 	used order 
sorted difference inplace 	implement ldb 
pack list 	log stack 
size permutations superset 	element automatically 
xmalloc memcpy 	removed stack 
pll free die 	converted 
pack bytecount 	different type 
pack list 	first index 
insert llist init 	expect check 
llist insert 	fails note 
sorted unique llist 	create two 
sorted difference 	representations 
inplace cmp two 	time one 
packs llist 	assuming table 
sorted difference inplace 	one assuming 
llist sorted 	end know 
difference inplace llist 	right one 
init open 	first 
pack index llist 	key start 
insert back 	iteration nil 
llist copy pack 	test far 
list insert 	table looks 
pack list insert 	like stack 
strlen die 	table 
strstr pack die 	key repr 
pack strcmp 	full repr 
usage strcmp 	stack table 
strcmp strcmp strcmp 	key ready 
usage prepare 	next iteration 
packed git load 	strip 
pack file 	last representations 
die load objects 	right one 
cmp local 	discard higher 
packs scan alt 	level wrapper 
odb packs 	ldb cat 
llist init isatty 	stack 
fgets xmalloc 	rec uses 
sha hex die 	initial recursion 
llist insert 	level produce 
sorted unique llist 	debugger log 
sorted difference 	entry representing 
inplace llist sorted 	lua 
difference inplace 	currently top 
minimize pack list 	stack element 
size pack 	popped modified 
redundancy pack 	check ldb 
bytecount pack list 	cat stack 
difference sha 	actual 
pack index name 	implementation redis 
pack bytecount 	protocol reply 
copyright lukas sandstrom 	appends human 
lukass etek 	readable form 
chalmers file licensed 	passed sds 
gpl objects 	note 
must present local 	sds passed 
packfiles insert 	reference pointer 
front insert entry 	pointer modified 
already exists 	pointer sds 
insert end returns 	semantics following 
pointer item 	functions 
front sha list 	helpers ldb 
since sorted 	redis protocol 
found know 	human take 
previous element computes 	care given 
cmp doesn 	redis type 
doesn permutations free 	log 
time since 	redis reply 
refer done cmp 	debugger output 
doesn doesn 	human readable 
another function find 	format resulting 
objects missing 	longer len 
unique packs objects 	plus 
missing unique 	chars used 
find permutations contain 	prefix gets 
missing objects 	truncated print 
find permutation smallest 	command lua 
size unique 	debugger scans 
packs list objects 	lua 
present remote 	varname starting 
packs scales like 	current stack 
list pruned 	frame top 
cmp two 	stack frame 
packs later sha 	first matching 
ignore objects 	variable 
given stdin pack-refs.c 	printed stack 
pack refs 	level variable 
usage argc argv 	index discard 
prefix flags 	name stack 
opts parse options 	vars two 
usage options 	selected 
pack refs pack-revindex.c 	cases print 
entries max 	command without 
tmp bits pos 	arguments lua 
swap num 	debugger prints 
ent index ofs 	variables current 
revindex ofs 	stack 
pos alloc alloc 	frame variable 
memset bucket 	index command 
bucket memcpy free 	list breakpoints 
free alloc 	lua debugger 
ntohl ntohl 	eval command 
ntohl ntohl sort 	compiles 
revindex create 	user passed 
pack revindex error 	fragment code 
load pack 	executes showing 
revindex find revindex 	result left 
position pack 	stack glue 
index existing packs 	script 
give easy 	together composed 
access offsets corresponding 	multiple arguments 
pack file 	compile expression 
data starts entries 	prepending failed 
store size 	statement call 
compressed representation uncompressed 	implement 
size easily 	debugger redis 
available examining pack 	command use 
entry header 	trick order 
also rather expensive 	make implementation 
find sha 	simple call 
given offset 	lua 
pack index file 	redis call 
sorted name 	command implementation 
mapping offset revindex 	ldb step 
list offset 	enabled side 
index pairs ordered 	effect redis 
offset know 	command 
offset next offset 	reply logged 
packed representation 	stack redis 
ends index used 	redis call 
sha main 	force redis 
index least significant 	call log 
digit radix 	stack 
sort sorts items 	redis result 
entries offset 	disable logging 
field max parameter 	discard result 
must least 	clean stack 
large largest offset 	trace command 
lets quit 	lua 
sort early 	debugger prints 
use digit size 	backtrace querying 
bits keeps 	lua starting 
memory usage reasonable 	current callframe 
generally smaller 	back outer 
packfile quit two 	one 
rounds radix 	impleemnts debugger 
sorting want know 	maxlen command 
bucket digit 	queries sets 
bits least significant 	ldb maxlen 
end need 	variable user 
temporary storage rather 	knows 
extra copy 	command read 
results entries sort 	debugging commands 
back forth 	client debugging 
real temporary storage 	session continuing 
iteration loop 	otherwise err 
keep track 	client 
pointers always sorting 	closed connection 
max bits 	timing processing 
zero know radix 	commands command 
digit higher 	lua interpreter 
zero entries loop 	found make 
everybody lands 	sure 
zero bucket want 	script runs 
pos store 	without user 
index last element 	input since 
bucket actually 	client longer 
one past last 	connected flush 
element first 	old 
count items bucket 	buffer execute 
gives relative 	command free 
offset last bucket 	command vector 
cumulatively index 	free current 
previous bucket index 	command argv 
drop elements 	inside 
correct buckets 	loop core 
temporary iterate pos 	lua debugger 
counter backwards 	called time 
avoid extra index 	lua start 
count since 	executing line 
going backwards must 	events 
also backwards 	outside script 
keep sort stable 	interesting check 
note use 	timeout occurred 
iterator make sure 	timeout ignore 
handle objects 	count client 
even bit system 	closed 
means cannot 	connection timeout 
use obvious loop 	connection kill 
condition counting 	script otherwise 
backwards must instead 	process remain 
check wrap 	blocked indefinitely 
around max contains 	sdallocx.c 
sorted list 	ptr nsz 
swap next 	alignment total 
iteration ended data 	mallocx sdallocx 
original great 	nallocx mallocx 
move back temporary 	align mallocx 
storage ordered 	mallocx 
list offsets objects 	align sdallocx 
pack knows 	mallocx align 
pack format trailer 	test sds.c 
follows immediately 	type size 
last data pack-revindex.h 	init initlen 
offset ofs 	type 
ofs pack-write.c opts 	hdrlen init 
offset opts 	initlen reallen 
ofsval index name 	addlen newsh 
objects objects 	avail len 
opts sha sorted 	newlen type 
sha list 	oldtype 
last last obj 	hdrlen newsh 
offset index 	type oldtype 
version tmp 	hdrlen len 
file hdr next 	alloc incr 
obj obj 	flags len 
offset large offset 	oldlen 
obj crc 	len curlen 
val obj offset 	len curlen 
obj offset 	len aux 
split entries hdr 	aux buf 
pack pack 	len fmt 
sha pack name 	cpy 
count pack 	staticbuf buflen 
sha pack offset 	fmt fmt 
aligned buf 	initlen next 
old sha ctx 	str num 
sha ctx 	unum buf 
hdr buf sha 	buf 
packname name 	cset start 
encode pack 	end len 
header pack tmp 	start end 
name tmpname 	newlen len 
name buffer pack 	minlen cmp 
tmp name 	len 
written list written 	sep seplen 
pack idx 	count tokens 
opts sha idx 	newtokens tokens 
tmp name 	count len 
basename len memset 	line argc 
hashcmp bsearch 	current 
qsort sha check 	vector inq 
odb mkstemp 	insq done 
xstrdup unlink open 	setlen argv 
die errno 	argc sep 
sha need large 	argv argc 
offset htonl 	sep 
htonl sha write 	seplen size 
htonl sha 	ptr size 
write htonl 	ptr oldfree 
sha write sha 	oldlen type 
write hashcmp 	sds req 
die sha hex 	type 
htonl sha 	sds hdr 
write need large 	size malloc 
offset htonl 	memset sds 
sha write need 	hdr sds 
large offset 	hdr sds 
htonl htonl sha 	hdr 
write sha 	sds hdr 
write sha close 	memcpy sdsnewlen 
htonl htonl 	strlen sdsnewlen 
htonl sha write 	sdsnewlen sdslen 
git sha 	free sds 
init git sha 	hdr 
init lseek 	size strlen 
die errno read 	sdssetlen sdssetlen 
full die 	sdsavail sdslen 
errno lseek 	sds hdr 
die errno git 	size sds 
sha update 	req 
htonl git sha 	type sds 
update write 	hdr size 
die xmalloc xread 	realloc malloc 
die errno 	memcpy free 
git sha update 	sdssetlen sdssetalloc 
git sha 	sdslen 
update git sha 	sds hdr 
hashcmp die 	size sds 
git sha init 	req type 
msb free 	sds hdr 
git sha git 	size realloc 
sha write 	malloc 
die fsync die 	memcpy free 
read full 	sdssetlen sdssetalloc 
skip prefix xstrfmt 	sdsalloc sds 
directory odb 	hdr size 
mkstemp xstrdup 	sds hdr 
sha adjust shared 	size 
perm die 	sds type 
errno write idx 	len sds 
file adjust 	hdr sds 
shared perm die 	hdr sds 
errno strbuf 	hdr sds 
addf sha hex 	hdr 
free pack 	sdslen sds 
name rename die 	make room 
errno strbuf 	memset sdssetlen 
setlen strbuf addf 	sdslen sds 
sha hex 	make 
rename die errno 	room memcpy 
strbuf setlen 	sdssetlen sdscatlen 
free entry sha 	strlen sdscatlen 
contains pack 	sdslen sdsalloc 
content sha 	sds make 
hash exit sha 	room 
hash sorted 	sdslen memcpy 
names objects passed 	sdssetlen sdscpylen 
sorted sha 	strlen sdsll 
exit last offset 	str sdsnewlen 
use index 	strlen malloc 
index versions need 	copy 
header write 	vsnprintf end 
first level table 	free malloc 
list sorted 	sdscat free 
use entry lookup 	start sdscatvprintf 
able avoid 	end sdslen 
eight extra binary 	start 
search iterations 	sdsavail sds 
write actual sha 	make room 
entries write 	arg strlen 
crc table write 	sdslen sdsavail 
bit offset 	sds make 
table write 	room 
large offset table 	memcpy sdsinclen 
update pack 	arg sdsll 
header count compute 	str sdsavail 
sha pack 	sds make 
data associated pack 	room memcpy 
write sha 	sdsinclen 
end sha also 	sdsull str 
returned pack 	sdsavail sds 
sha pack sha 	make room 
non sha 	memcpy sdsinclen 
existing pack without 	sdsinclen sdsinclen 
header update 	end 
computed validated one 	sdslen strchr 
provided pack 	strchr memmove 
sha validation performed 	sdssetlen sdslen 
pack offset 	memmove sdssetlen 
bytes pack file 	sdslen tolower 
sha remaining 	sdslen 
data pack 	toupper sdslen 
offset end computed 	sdslen memcmp 
returned pack 	malloc realloc 
sha note pack 	memcmp sdsnewlen 
sha updated 	sdsnewlen sdsfree 
last pack sha 	free 
pack sha 	sdsfree free 
refer buffer caller 	sdscatlen sdscatprintf 
interested resulting 	sdscatlen sdscatlen 
sha pack data 	sdscatlen sdscatlen 
pack offset 	sdscatlen isprint 
compute sha remainder 	sdscatprintf 
pack also 	sdscatprintf sdscatlen 
means making pack 	isspace sdsempty 
offset big 	hex digit 
enough matter anymore 	hex digit 
first thing 	hex digit 
expect index pack 	hex 
output pack 	digit sdscatlen 
keep bytes 	sdscatlen isspace 
newly created pack 	sdscatlen sdscatlen 
sha name 	isspace sdscatlen 
keep need corresponding 	sdscatlen realloc 
keep file 	malloc 
later tough luck 	sdsfree free 
per header 	sdsfree sdslen 
pretty dense thing 	sdsempty sdscat 
first low 	sdscat sdsempty 
four bits size 	sdscatsds sdscatlen 
three bits 	malloc 
type high bit 	realloc free 
size continues 	sdsnew sdsfree 
afterwards low seven 	sdsnewlen sdscat 
bits size 	test cond 
continuation high bit 	sdslen memcmp 
size continues 	sdscpy 
pack.h hdr signature 	sdscpy sdsfree 
hdr version 	sdscatprintf sdsempty 
hdr entries 	sdsfree sdsnew 
flags version limit 	sdscatfmt sdsfree 
anomaly alloc 	sdsnew sdscatfmt 
anomaly anomaly pack 	sdsfree 
idx option 	sdsnew sdstrim 
idx signature idx 	sdsfree sdsnew 
version sha 	sdstrim sdsfree 
crc offset index 	sdsnew sdstrim 
name objects 	sdsdup sdsrange 
objects pack idx 	sdsfree 
option sha 	sdsdup sdsrange 
curs offset len 	sdsfree sdsdup 
packed git 	sdsrange sdsfree 
packed git progress 	sdsdup sdsrange 
encode pack 	sdsfree sdsdup 
header pack header 	sdsrange 
pack tmp 	sdsfree sdsdup 
name name 	sdsrange sdsfree 
buffer pack tmp 	sdsfree sdsnew 
name written 	sdsnew sdsfree 
list written pack 	sdsfree sdsnew 
idx opts 	sdsnew 
sha packed header 	sdsfree sdsfree 
pack first 	sdsnew sdsnew 
four bytes index 	sdsfree sdsfree 
formats later 	sdsnewlen sdscatrepr 
version start signature 	sdsempty sdslen 
older git 	sdsfree 
binaries would find 	sdsfree sdsnew 
illegal abort 	test cond 
reading file number 	sdslen sdsavail 
objects packfile 	sdslen sds 
cannot exceed every 	make room 
would need 	test 
least bytes data 	cond sdslen 
overall packfile 	test cond 
cannot exceed 	sdsavail sdsavail 
version index file 	sds incr 
due offsets 	len test 
limited bits clearly 	cond 
signature exceeds 	memcmp test 
maximum old git 	cond sdslen 
binaries also 	sdsfree sds 
compare first bytes 	test sds 
next bytes 	lib library 
index abort non 	copyright 
monotonic index 	salvatore sanfilippo 
error second word 	antirez gmail 
smaller first 	dot copyright 
word would proposed 	oran agra 
future index 	copyright redis 
format idx signature 	labs 
would greater 	inc rights 
idx version flag 	reserved redistribution 
bits verify 	use source 
write idx 	binary forms 
file list offsets 	without modification 
would fit 	permitted 
within limit need 	provided following 
written bit 	conditions met 
entity verification packed 	redistributions source 
index header 	code must 
common part structure 	retain copyright 
used write 	notice 
idx file pager.c 	list conditions 
pager process 	following disclaimer 
signal signo stdout 	redistributions binary 
tty pager 	form must 
pager process pager 	reproduce copyright 
pager env 	notice 
term columns startup 	list conditions 
col cols 	following disclaimer 
number width cmd 	documentation materials 
want key 	provided distribution 
fflush fflush 	neither name 
close close finish 	redis 
command signal 	names contributors 
finish command wait 	may used 
pager wait 	endorse promote 
pager sigchain pop 	products derived 
getenv git 	software without 
config getenv strcmp 	specific 
argv push 	prior written 
getenv argv push 	permission software 
getenv argv 	provided copyright 
push git pager 	holders contributors 
isatty term 	express implied 
columns setenv prepare 	warranties 
pager args 	including limited 
argv push start 	implied warranties 
command dup 	merchantability fitness 
isatty dup 	particular purpose 
close sigchain push 	disclaimed shall 
common atexit 	copyright 
getenv git config 	owner contributors 
getenv atoi 	liable direct 
ioctl strbuf addf 	indirect incidental 
git config 	special exemplary 
key valid git 	consequential damages 
config git 	including 
config maybe xstrdup 	limited procurement 
strbuf release 	substitute goods 
split rest git 	services loss 
something different 	use data 
windows signal eof 	profits business 
pager force 	interruption 
computing width terminal 	however caused 
redirect standard 	theory liability 
output pager spawn 	whether contract 
pager original 	strict liability 
process continues 	tort including 
writes pipe makes 	negligence 
sure parent 	otherwise arising 
terminates pager cached 	way use 
columns environment 	software even 
variable positive ioctl 	advised possibility 
tiocgwinsz col 	damage create 
positive fails many 	sds 
columns need 	content specified 
show number returns 	init pointer 
pager use 	initlen used 
pager specified param.h 	init initialized 
intentionally empty 	zero bytes 
file support building 	always 
git msvc 	termined sds 
parse-options-cb.c opt arg 	always even 
unset opt 	create sds 
arg unset opt 	mystring sdsnewlen 
arg unset 	abc print 
opt arg 	end 
unset opt arg 	however binary 
unset target 	safe contain 
opt arg unset 	characters middle 
sha commit 	length stored 
opt arg unset 	sds header 
sha opt 	empty 
arg unset target 	usually created 
dst dst 	order append 
size src opt 	use type 
arg unset 	since type 
opt arg unset 	good flags 
opt arg 	pointer 
unset opt arg 	create empty 
unset opt 	zero length 
opt arg unset 	sds even 
opt strtol 	always term 
opterror approxidate parse 	create sds 
expiry date 	starting 
git config 	terminated duplicate 
colorbool opterror sha 	sds free 
error lookup 	sds operation 
commit reference error 	performed sds 
commit list 	length length 
insert sha clear 	obtained 
sha error 	strlen considering 
sha append list 	content first 
clear list 	term character 
append xstrdup strbuf 	function useful 
reset strbuf 	sds hacked 
addstr strbuf addstr 	manually 
strbuf addch 	way like 
strbuf addstr strbuf 	following example 
addch strbuf 	sdsnew foobar 
addch strbuf addstr 	sdsupdatelen sdslen 
recreate opt 	output comment 
free strbuf 	call 
detach recreate opt 	sdsupdatelen output 
argv push 	modified logical 
often used options 	length remains 
quiet verbose 	bytes modify 
recreates command line 	sds place 
option strbuf 	make 
option opt recreates 	empty zero 
command line 	length however 
option opt must 	existing buffer 
initialized useful 	discarded free 
need pass command 	space next 
line option 	append 
another command since 	operations require 
previous overwritten 	allocations number 
callback used options 	bytes previously 
last one 	available enlarge 
wins option opt 	free space 
recreate command 	end 
line option 	sds caller 
appending opt must 	sure calling 
argv useful 	function overwrite 
need pass command 	addlen bytes 
line option 	end plus 
specified multiple times 	one 
another command 	nul term 
parse-options.c opt reason 	note change 
opt flags 	length sds 
arg prefix file 	returned sdslen 
opt opts 	free buffer 
flags message name 	space 
opt opts 	asap enough 
flags arg unset 	space left 
err options 	use type 
opts numopt len 	user appending 
arg arg 	type able 
options opts arg 	remember 
end ambiguous 	empty space 
option ambiguous 	sds make 
flags rest name 	room must 
opt flags 	called every 
arg options opts 	appending operation 
arg options 	since 
opts err opts 	header size 
ctx argc 	changes need 
argv prefix options 	move forward 
flags parse 	use realloc 
opt ctx option 	reallocate sds 
ctx options 	free 
usagestr help err 	space end 
arg ctx 	contained remains 
argc argv prefix 	altered next 
options usagestr 	concatenation operations 
flags ctx opts 	require reallocation 
outfile ctx 	call 
usagestr opts full 	passed sds 
err outfile 	longer valid 
pos pad 	references must 
usagestr opts msg 	substituted pointer 
usagestr options 	returned call 
opt reason flags 	total 
error error 	size allocation 
error opterror absolute 	specifed sds 
path strcmp 	including sds 
xstrdup prefix filename 	header pointer 
strlen strbuf 	free buffer 
addf strbuf addf 	end 
strbuf addf 	term pointer 
strbuf release opterror 	actual sds 
strbuf release 	allocation normally 
opterror opterror opterror 	sds referenced 
opterror opt 	start buffer 
command mode error 	increment 
arg arg 	sds length 
fix filename callback 	decrements left 
callback callback 	free space 
arg callback 	end according 
arg strtol opterror 	incr also 
arg git 	term 
parse opterror die 	end function 
isdigit isdigit 	used order 
xmemdupz callback free 	fix length 
strchrnul skip 	user calls 
prefix opterror strncmp 	sds make 
starts starts 	room 
starts skip prefix 	writes something 
starts error 	end current 
strlen starts error 	needs length 
exit starts 	note possible 
error exit memset 	use negative 
optbug optbug 	increment 
optbug optbug optbug 	order right 
strcspn strlen 	trim usage 
optbug exit 	example sds 
memset die parse 	incr len 
options check 	sds make 
parse nodash opt 	room 
strcmp parse 	possible mount 
opt check typos 	following schema 
check typos 	cat bytes 
parse opt xstrdup 	coming kernel 
strcmp usage 	end sds 
options strcmp parse 	without 
opt usage 	copying intermediate 
options memmove parse 	buffer oldlen 
options start 	sdslen sds 
parse options step 	make room 
exit error 	buffer size 
isascii error error 	nread 
usage options 	read oldlen 
precompose argv parse 	buffer size 
options end 	check nread 
utf putchar 	handle sds 
fputc fputc utf 	incr len 
usage argh 	nread 
fputc fputc fputs 	avoid compilation 
usage options 	warnings grow 
exit usage options 	sds specified 
error error 	length bytes 
error find option 	part original 
used variable 	length 
already report compatible 	sds zero 
giving mode 	specified length 
option twice although 	smaller current 
unnecessary grave 	length operation 
error pass handle 	performed make 
numerical option 	sure 
later one digit 	added region 
options take 	doesn contain 
precedence abbreviated abbreviated 	garbage also 
ambiguous exact 	trailing append 
match later 	specified binary 
need error negation 	safe 
allowed negated 	pointed len 
abbreviated much negated 	bytes end 
abbreviated negated 	specified sds 
usually accepts argument 	call passed 
must reset 	sds longer 
opt unknown option 	valid 
dangling lone 	references must 
asks help fake 	substituted pointer 
option thing 	returned call 
hide fact may 	append specified 
started parse 	termianted sds 
aggregated stuff leaky 	call 
bad parse 	passed sds 
opt unknown translators 	longer valid 
colon align 	references must 
one usage translation 	substituted pointer 
parse-options.h name 	returned call 
name argh 	append 
help flags callback 	specified sds 
defval argc 	existing sds 
argv prefix options 	call modified 
usagestr flags 	sds longer 
usagestr options msg 	valid references 
usagestr options 	must 
opt reason opt 	substituted pointer 
reason flags 	returned call 
argv argc cpidx 	destructively modify 
total opt 	sds hold 
flags prefix ctx 	specified binary 
argc argv 	safe 
prefix options flags 	pointed length 
ctx options 	len bytes 
usagestr ctx dst 	like sdscpylen 
src option 	must termined 
option option 	length obtained 
option option option 	strlen 
option option 	helper sdscatlonglong 
option option option 	actual number 
option special 	conversion must 
types options arguments 	point room 
options arguments 	least sds 
usually type holds 	llstr 
type option 	size bytes 
must option end 	function returns 
last name 	length terminated 
character use option 	representation stored 
name none 	generate representation 
name option name 	method 
without leading 	produces reversed 
dashes none stores 	compute length 
pointers values 	term reverse 
filled argh token 	identical sdsll 
explain kind 	str 
argument option 	type generate 
wants keep homogeneous 	representation method 
across repository 	produces reversed 
wrapped translation help 	compute length 
help associated 	term reverse 
option must never 	create 
option end 	sds much 
option uses pointer 	faster sdscatprintf 
store header 	sdsempty lld 
wrapped translation flags 	like sdscatprintf 
mask parse 	gets list 
opt option flags 	instead 
parse opt 	variadic start 
optarg says argument 	buffer speed 
optional boolea 	possible revert 
parse opt noarg 	heap allocation 
says option 	buffers two 
take argument parse 	times 
opt noneg 	bigger every 
says option 	time fail 
cannot negated parse 	fit current 
opt hidden 	buffer size 
option skipped usage 	concat obtained 
shown full 	sds 
usage parse opt 	append sds 
lastarg says 	obtained alike 
option take argument 	format specifier 
given option 	call modified 
last command line 	sds longer 
option last 	valid 
require argument used 	references must 
parse opt 	substituted pointer 
optarg parse opt 	returned call 
nodash option 	example sdsnew 
doesn start dash 	sum sdscatprintf 
parse opt 	often 
arghelp says argh 	need create 
shouldn enclosed 	scratch alike 
brackets argh 	format need 
help message useful 	use sdsempty 
options multiple 	target sdscatprintf 
parameters callback pointer 	sdsempty 
callback use 	format args 
option callback option 	function similar 
lowlevel callback 	sdscatprintf much 
defval fill parse 	faster rely 
opt optarg 	sprintf family 
option bit store 	functions 
mask integer 	implemented libc 
put met callbacks 	often slow 
use like 	moreover directly 
want parse options 	handling sds 
filter processed 	data concatenated 
options non option 	provides 
arguments argv 	performance improvement 
usagestr marked 	however function 
translation returns number 	handles incompatible 
arguments left 	subset alike 
argv incremental advanced 	format specifiers 
okay caller 	sds 
consume argv argc 	bit integer 
usual way 	bit integer 
fields structure parse 	verbatim character 
options modified 	next format 
way often used 	specifier process 
options patch-delta.c 	position 
src buf src 	next write 
size delta 	dest str 
buf delta size 	make sure 
dst size 	always space 
data top dst 	least handle 
buf cmd 	generally 
size size delta 	unknown term 
hdr size 	part left 
delta hdr 	right composed 
size xmallocz overflows 	contiguous characters 
memcpy memcpy 	found cset 
error error free 	terminted 
patch delta 	call modified 
recreate buffer source 	sds longer 
delta produced 	valid references 
diff delta nicolas 	must substituted 
pitre nico 	pointer returned 
fluxnic net code 	call 
free software 	example sdsnew 
redistribute modify terms 	hello world 
gnu general 	sdstrim output 
license version published 	hello world 
free software 	turn smaller 
foundation make sure 	equal 
orig file 	containing substring 
size matches expect 	specified start 
result size 	end indexes 
cmd reserved 	start end 
future encoding extensions 	negative means 
mean time 	last 
must fail encountering 	character penultimate 
might data 	character forth 
corruption sanity check 	interval inclusive 
patch-id.c patchlen 	start end 
result name line 	characters part 
src dst 	resulting 
digits result ctx 	modified place 
hash carry 	example sdsnew 
next oid result 	hello world 
line buf 	sdsrange ello 
stable found next 	world apply 
ctx line 	tolower 
len stable oid 	every character 
result patchlen 	sds apply 
line buf patch 	toupper every 
usage stable 	character sds 
argc argv 	compare two 
prefix stable memcpy 	sds 
oid hex 	memcmp positive 
oid hex isspace 	negative exactly 
strspn strspn 	binary two 
strspn strspn atoi 	share exactly 
atoi git 	prefix one 
sha git sha 	two 
init git 	additional characters 
sha init oidclr 	longer considered 
strbuf getwholeline 	greater smaller 
memcmp memcmp memcmp 	one split 
memcmp strlen 	separator sep 
oid hex memcmp 	sds 
memcmp memcmp 	returned count 
isalpha memcmp scan 	reference number 
hunk header 	tokens returned 
memcmp flush one 	memory zero 
hunk space 	length zero 
git sha 	length 
update oidclr flush 	separator returned 
one hunk 	note sep 
oidclr feof one 	able split 
patchid flush 	multi character 
current oidcpy strbuf 	separator example 
release strcmp 	sdssplit 
git config git 	foo bar 
config git 	two elements 
config strcmp strcmp 	foo bar 
usage generate 	version function 
list sum carry 	binary safe 
ignore commit 	requires 
comments parsing diff 	length arguments 
header looking 	sdssplit function 
valid hunk header 	zero terminated 
parse next 	make sure 
hunk ignore 	room next 
line numbers split 	element 
end patch 	one search 
parsing another header 	separator skip 
inside hunk 	separator element 
compute sha without 	sure room 
whitespace nothing 	tokens free 
unstable patch-ids.c commit 	result 
options sha 	returned sdssplitlen 
index table table 	nothing tokens 
table next 	append sds 
bucket ids ids 	escaped representation 
next patches 	non printable 
commit ids bucket 	characters 
ent sha 	tested isprint 
pos commit ids 	turned escapes 
commit ids 	form hex 
diff sha diff 	number call 
root sha 	modified sds 
diffcore std 	longer 
diff flush patch 	valid references 
sha pos 	must substituted 
memset diff setup 	pointer returned 
diff opt 	call helper 
diff setup done 	function sdssplitargs 
free free 	returns 
commit patch patch 	non zero 
pos xcalloc 	valid hex 
hashcpy alloc grow 	digit helper 
memmove commit 	function sdssplitargs 
commit slop close 	converts hex 
enough patch-ids.h 	digit 
patch seen diffopts 	integer split 
alloc table 	line arguments 
patches patch ids 	every argument 
patch ids 	following programming 
commit patch ids 	language repl 
commit patch 	alike 
ids patch 	form foo 
ids path.c path 	bar newline 
mode bad 	supported xff 
path pathname index 	otherstuff number 
path path 	arguments stored 
buf fmt args 	argc 
len buf 	sds returned 
dir len buf 	caller free 
dir file 	resulting sds 
len buf len 	sdsfreesplitres note 
newdir newlen 	sdscatrepr able 
need sep dirname 	convert 
common list 	back quoted 
children len contents 	format sdssplitargs 
key node 	able parse 
root key child 	function returns 
old root 	allocated tokens 
key baton result 	success 
child common 	even input 
trie common 	empty input 
trie done setup 	contains unbalanced 
unmatched baton 	quotes closed 
dir buf git 	quotes followed 
dir len 	non 
common dir len 	space characters 
path buf 	foo bar 
git dir len 	foo skip 
buf fmt 	blanks token 
args gitdir len 	quotes single 
buf fmt 	quotes 
args fmt args 	closing quote 
fmt pathname 	must followed 
args fmt path 	space nothing 
args fmt 	unterminated quotes 
args fmt args 	closing quote 
pathname buf 	must 
path fmt 	followed space 
args git dir 	nothing unterminated 
git submodule 	quotes token 
common dir git 	vector even 
submodule dir 	empty input 
path fmt args 	something 
buf buf 	modify substituting 
path fmt args 	occurrences characters 
path buf 	specified corresponding 
buffer sha len 	character instance 
username len 	sdsmapchars mystring 
username path user 	effect 
path copy 	turning hello 
first slash username 	ell function 
username len 	returns sds 
home path strict 	pointer always 
validated path 	input pointer 
used path suffix 	since 
gitfile len 	resize needed 
newpath baselen 	specified separator 
gitfile mode tweak 	also returns 
path old 	result sds 
mode mode dir 	like sdsjoin 
share path 	joins 
path abs abs 	sds wrappers 
prefix len 	allocators used 
prefix len prefix 	sds note 
prefix buf 	sds actually 
dst src prefix 	use macros 
len dst 	defined 
dst src path 	sdsalloc order 
prefixes max 	avoid pay 
len ceil len 	overhead function 
path len 	calls define 
path suffix suffix 	wrappers programs 
len ndot 	sds 
path len skip 	linked want 
name len 	touch sds 
filename home 	internals even 
config home lstat 	use different 
strbuf reset 	allocator run 
memcmp cleanup path 	test 
strbuf start 	times order 
vsnprintf end strlcpy 	hit first 
cleanup path 	two sds 
strlen strncmp dir 	header types 
sep strlen 	sds lib 
strncmp dir sep 	library 
dir sep 	copyright salvatore 
strcmp strlen dir 	sanfilippo antirez 
sep dir 	gmail dot 
sep strbuf splice 	copyright oran 
xcalloc strlen 	agra copyright 
xmalloc memcpy malloc 	redis 
memcpy xstrndup 	labs inc 
memset make trie 	rights reserved 
node trie 	redistribution use 
make trie 	source binary 
node trie find 	forms without 
trie init 	modification 
common trie git 	permitted provided 
common dir 	following conditions 
trie find replace 	met redistributions 
dir strbuf 	source code 
addf git dir 	must retain 
strbuf setlen 	copyright 
strbuf addstr file 	notice list 
exists report 	conditions following 
garbage strbuf release 	disclaimer redistributions 
dir file 	binary form 
strbuf splice graft 	must reproduce 
file strlen 	copyright 
graft file strcmp 	notice list 
strbuf splice 	conditions following 
index file 	disclaimer documentation 
strlen index file 	materials provided 
dir prefix 	distribution neither 
replace dir directory 	name 
update common 	redis names 
dir strbuf addstr 	contributors may 
git dir 	used endorse 
dir sep strbuf 	promote products 
addch strbuf 	derived software 
vaddf adjust git 	without 
path strbuf 	specific prior 
cleanup path strbuf 	written permission 
reset start 	software provided 
git path end 	copyright holders 
start git 	contributors express 
path end pathname 	implied 
start git 	warranties including 
path end start 	limited implied 
git path 	warranties merchantability 
end strbuf 	fitness particular 
detach start strbuf 	purpose disclaimed 
vaddf end 	shall 
strbuf cleanup path 	copyright owner 
strbuf detach 	contributors liable 
pathname start strbuf 	direct indirect 
vaddf end 	incidental special 
cleanup path strbuf 	exemplary consequential 
addstr strbuf 	damages 
complete strbuf addstr 	including limited 
read gitfile 	procurement substitute 
strbuf reset strbuf 	goods services 
addstr strbuf 	loss use 
addch strbuf addstr 	data profits 
strbuf vaddf 	business 
common dir noenv 	interruption however 
update common 	caused theory 
dir strbuf cleanup 	liability whether 
path strbuf 	contract strict 
release strbuf 	liability tort 
release start submodule 	including 
path end 	negligence otherwise 
strbuf detach start 	arising way 
submodule path 	use software 
end lstat islnk 	even advised 
readlink memcmp 	possibility damage 
open read full 	create 
close memcmp 	sds content 
isspace memcmp sha 	specified init 
hex xmemdupz 	pointer initlen 
getpwnam free strchrnul 	used init 
getenv strbuf 	initialized zero 
addstr getpw str 	bytes 
strbuf addstr 	always termined 
strbuf addstr strbuf 	sds always 
detach strbuf 	even create 
release strlen strbuf 	sds mystring 
reset strbuf 	sdsnewlen abc 
reset strbuf 	print 
strbuf expand user 	end however 
path strbuf 	binary safe 
attach strlen strlen 	contain characters 
strbuf addstr 	middle length 
stat isreg isdir 	stored sds 
git directory 	header 
strbuf addstr strbuf 	empty usually 
setlen read 	created order 
gitfile strbuf reset 	append use 
strbuf addstr 	type since 
chdir read gitfile 	type good 
chdir git 	flags 
directory git dir 	pointer create 
check repository 	empty zero 
format mode bits 	length sds 
calc shared 	even always 
perm isdir chmod 	term create 
mkdir perror 	sds 
exit adjust 	starting terminated 
shared perm die 	duplicate sds 
absolute path 	free sds 
absolute path tolower 	operation performed 
tolower strlen 	sds length 
strlen root dos 	length 
drive prefix 	obtained strlen 
dir sep dir 	considering content 
sep dir 	first term 
sep dir sep 	character function 
dir sep 	useful sds 
dir sep dir 	hacked 
sep strbuf 	manually way 
reset strbuf grow 	like following 
dir sep 	example sdsnew 
strbuf addstr dir 	foobar sdsupdatelen 
sep dir 	sdslen output 
sep strbuf 	comment 
addstr strbuf addstr 	call sdsupdatelen 
dir sep 	output modified 
dir sep dir 	logical length 
sep dir 	remains bytes 
sep dir sep 	modify sds 
dir sep 	place 
dir sep strbuf 	make empty 
reset strbuf 	zero length 
addstr strbuf addstr 	however existing 
dos drive 	buffer discarded 
prefix dir sep 	free space 
dir sep 	next 
dir sep dir 	append operations 
sep dir 	require allocations 
sep dir sep 	number bytes 
dir sep 	previously available 
dir sep dir 	enlarge free 
sep normalize 	space 
path copy 	end sds 
len strcmp strlen 	caller sure 
strncmp dir 	calling function 
sep strlen dir 	overwrite addlen 
sep dir 	bytes end 
sep chomp trailing 	plus 
dir sep 	one nul 
chomp trailing dir 	term note 
sep dir 	change length 
sep xstrndup chomp 	sds returned 
trailing dir 	sdslen free 
sep dir sep 	buffer 
spaces periods 	space asap 
strncasecmp spaces periods 	enough space 
strncasecmp getenv 	left use 
mkpathdup getenv mkpathdup 	type user 
utilities paths 	appending type 
pathnames clean buf 	able 
dir file 	remember empty 
without regex 	space sds 
keep one replaced 	make room 
considered garbage 	must called 
report linked checkout 	every appending 
garbage common 	operation 
even though parent 	since header 
compressed trie 	size changes 
trie node consists 	need move 
zero characters 	forward use 
common elements prefix 	realloc 
optionally followed 	reallocate sds 
children trie node 	free space 
terminal node 	end contained 
example consider following 	remains altered 
abc def 	next concatenation 
definite definition trie 	operations 
would look 	require reallocation 
look like root 	call passed 
len children 	sds longer 
non len 	valid references 
contents data abc 	must substituted 
len contents 	pointer 
children non data 	returned call 
def len 	total size 
contents nit children 	allocation specifed 
non len 	sds including 
children data definite 	sds header 
len contents 	pointer 
children data definition 	free buffer 
key pair 	end term 
trie key assumed 	pointer actual 
terminated existing 	sds allocation 
key reached end 	normally sds 
key split 	referenced 
node child contain 	start buffer 
node existing 	increment sds 
children newly 	length decrements 
added child matched 	left free 
entire compressed 	space end 
section search trie 	according 
key find 	incr also 
longest terminated prefix 	term end 
key trie 	function used 
contains call unmatched 	order fix 
portion key 	length user 
found prefix key 	calls 
partially normalized 	sds make 
consecutive slashes skipped 	room writes 
example consider 	something end 
trie containing refs 	current needs 
refs worktree 	length note 
values key unmatched 	possible 
val node 	use negative 
called refs refs 	increment order 
per refs 	right trim 
refs per 	usage example 
refs refs per 	sds incr 
refs worktree 	len 
refs worktree per 	sds make 
refs worktree 	room possible 
refs worktree per 	mount following 
refs worktree 	schema cat 
refs worktree per 	bytes coming 
reached end 	kernel 
key path normalization 	end sds 
skip consecutive 	without copying 
slashes matched entire 	intermediate buffer 
compressed section 	oldlen sdslen 
end key path 	sds make 
normalization skip 	room 
consecutive slashes helper 	buffer size 
function update 	nread read 
common dir returns 	oldlen buffer 
dir prefix 	size check 
common make 	nread handle 
sure refs symlink 	sds 
anything open 	incr len 
see symbolic symbolic 	nread avoid 
detached head 	compilation warnings 
user expanded via 	grow sds 
getpw buf 	specified length 
newly allocated returns 	bytes 
getpw failure 	part original 
path first one 	length sds 
directory determined 	zero specified 
following algorithm strict 	length smaller 
given path 	current length 
used given dwim 	operation 
done otherwise 	performed make 
path mean path 	sure added 
running user 	region doesn 
home directory user 	contain garbage 
path mean 	also trailing 
path named 	append 
user home directory 	specified binary 
relative path 	safe pointed 
mean cwd relative 	len bytes 
directory absolute 	end specified 
path mean absolute 	sds call 
directory unless 	passed 
strict given check 	sds longer 
git git 	valid references 
git git order 	must substituted 
first one 	pointer returned 
valid git repository 	call append 
chdir none 	specified 
match fail chdir 	termianted sds 
goes well 	call passed 
directory used chdir 	sds longer 
user expanded 	valid references 
avoiding getcwd 	must substituted 
resolving symbolic links 	pointer 
user relative 	returned call 
paths also returned 	append specified 
given dwim 	sds existing 
suffixing handle arbitrary 	sds call 
sized buffers 	modified sds 
remains sanity check 	longer 
untrusted input 	valid references 
copy read bits 	must substituted 
execute bits 	pointer returned 
copy read bits 	call destructively 
execute bits 	modify sds 
give path relative 	hold 
prefix strbuf 	specified binary 
may may used 	safe pointed 
contains returned 	length len 
path bypass dos 	bytes like 
drive identical 	sdscpylen must 
prefix seems 	termined 
like prefix foo 	length obtained 
prefix foobar 	strlen helper 
prefix end prefix 	sdscatlonglong actual 
prefix bbb 	number conversion 
prefix prefix end 	must point 
prefix simpler 	room 
implementation relative path 	least sds 
relative path 	llstr size 
removing prefix function 	bytes function 
first appears 	returns length 
bbbc makes git 	terminated representation 
dir shorter 	stored 
increase performance traversing 	generate representation 
path work 	method produces 
foo prefix foo 	reversed compute 
foo prefix 	length term 
foobar okay dst 	reverse identical 
src overlap 	sdsll 
otherwise performs 	str type 
following normalizations src 	generate representation 
storing result 	method produces 
dst ensures components 	reversed compute 
separated windows 	length term 
squashes sequences removes 	reverse 
components removes 	create sds 
components components precede 	much faster 
returns failure 	sdscatprintf sdsempty 
non zero component 	lld like 
appears first 	sdscatprintf gets 
path component anytime 	list 
normalization otherwise 	instead variadic 
returns success note 	start buffer 
function purely 	speed possible 
textual follow symlinks 	revert heap 
verify existence 	allocation buffers 
path make system 	two 
calls prefix 	times bigger 
len specific 	every time 
prefix pathspec src 	fail fit 
dst src 	current buffer 
prefix len already 	size concat 
normalized time 	obtained 
eats prefix len 	sds append 
part prefix 	sds obtained 
len reduced end 	alike format 
prefix len 	specifier call 
remaining prefix overridden 	modified sds 
user pathspec 	longer 
needswork function doesn 	valid references 
perform normalization 	must substituted 
trailing everything root 	pointer returned 
folder normalized 	call example 
path end callers 	sdsnew sum 
need accordingly 	sdscatprintf 
path component begins 	often need 
could special 	create scratch 
ends ignore 	alike format 
terminate ignore eat 	need use 
slash ends 	sdsempty target 
strip one terminate 	sdscatprintf 
strip one 	sdsempty format 
eat slash copy 	args function 
next eat 	similar sdscatprintf 
dst dst prefix 	much faster 
portion dst 	rely sprintf 
one level trailing 	family 
windows dst 	functions implemented 
cannot backslash anymore 	libc often 
path canonical 	slow moreover 
absolute path prefixes 	directly handling 
list containing 	sds data 
normalized absolute paths 	concatenated 
without trailing 	provides performance 
slashes root 	improvement however 
directory denoted determines 	function handles 
path prefixes 	incompatible subset 
whether prefix ancestor 	alike format 
directory path 	specifiers 
returns length longest 	sds bit 
ancestor directory 	integer bit 
excluding trailing slashes 	integer verbatim 
prefix ancestor 	character next 
note means returned 	format specifier 
prefixes foo 	process 
considered ancestor foobar 	position next 
directories considered 	write dest 
ancestors path must 	str make 
canonical form 	sure always 
empty components components 	space least 
allowed root 	handle 
matches anything length 	generally unknown 
match length 	term part 
len match 	left right 
strip arbitrary amount 	composed contiguous 
directory separators 	characters found 
end path path 	cset 
ends suffix 	terminted call 
complete path components 	modified sds 
returns part 	longer valid 
suffix sans trailing 	references must 
directory separators 	substituted pointer 
otherwise returns resurrects 	returned 
belts suspenders 	call example 
paranoia check hpa 	sdsnew hello 
done zytor 	world sdstrim 
enter repo getcwd 	output hello 
path canonicalization 	world turn 
becomes immediately seeing 	smaller 
continues dots 	equal containing 
without intervening non 	substring specified 
dot character 	start end 
reject reject 	indexes start 
pathspec.c pathspec seen 	end negative 
pathspec seen 	means 
bit mnemonic name 	last character 
prefixlen magic 	penultimate character 
item magic raw 	forth interval 
flags prefix 	inclusive start 
prefixlen elt glob 	end characters 
noglob icase 	part 
magic magic end 	resulting modified 
match pathspec 	place example 
prefix nextat len 	sdsnew hello 
endptr len 	world sdsrange 
pattern magic magic 	ello world 
pathspec magic 	apply 
mask flags prefix 	tolower every 
argv item 	character sds 
entry prefixlen exclude 	apply toupper 
raw magic 	every character 
prefix pathspec 	sds compare 
dst src pathspec 	two 
path match 	sds memcmp 
xcalloc pathspec matches 	positive negative 
index strbuf 	exactly binary 
addstr size strbuf 	two share 
addch strbuf 	exactly prefix 
addstr strbuf addf 	one 
git env 	two additional 
git env git 	characters longer 
env die 	considered greater 
git env die 	smaller one 
strcspn size 	split separator 
strlen strncmp starts 	sep 
strtol die 	sds returned 
size die die 	count reference 
pathspec magic 	number tokens 
size size 	returned memory 
die die die 	zero length 
xstrdup xstrdup 	zero 
prefix path gently 	length separator 
die prefix 	returned note 
magic strbuf strbuf 	sep able 
addf strbuf 	split multi 
addf strbuf addstr 	character separator 
strbuf detach 	example 
strlen cache name 	sdssplit foo 
pos isgitlink 	bar two 
namelen isgitlink memcmp 	elements foo 
die simple 	bar version 
length wildcard strcmp 	function binary 
size strbuf 	safe 
addch strbuf addf 	requires length 
strbuf addf 	arguments sdssplit 
die memset die 	function zero 
die xcalloc 	terminated make 
strlen alloc 	sure room 
strlen prefix pathspec 	next 
unsupported magic 	element one 
symlink leading path 	search separator 
die die 	skip separator 
die qsort parse 	element sure 
pathspec alloc 	room tokens 
memcpy free finds 	free 
given pathspecs 	result returned 
match items index 	sdssplitlen nothing 
pathspec sets 	tokens append 
corresponding entry seen 	sds escaped 
specs items 	representation non 
size pathspec nature 	printable 
closest specific 	characters tested 
match found pathspec 	isprint turned 
index closer 	escapes form 
type match existing 	hex number 
entry optimization 	call modified 
matching skipped 	sds 
altogether seen already 	longer valid 
contains non 	references must 
zero entries seen 	substituted pointer 
already written 	returned call 
may make sense 	helper function 
use find 	sdssplitargs 
pathspecs matching index 	returns non 
instead since 	zero valid 
walking index walking 	hex digit 
directory mark 	helper function 
matched pathspec seen 	sdssplitargs converts 
otherwise mistakenly 	hex 
think user gave 	digit integer 
pathspec match 	split line 
anything finds given 	arguments every 
pathspecs match 	argument following 
items index one 	programming language 
shot wrapper 	repl 
around pathspec 	alike form 
matches index allocates 	foo bar 
populates returns 	newline supported 
seen indicating nature 	xff otherstuff 
closest specific 	number arguments 
matches given pathspecs 	stored 
achieves items 	argc sds 
index magic pathspec 	returned caller 
possible future 	free resulting 
magic semantics include 	sds sdsfreesplitres 
stuff like 	note sdscatrepr 
pathspec recursive recursive 	able 
pathspec regexp 	convert back 
regexp cannot take 	quoted format 
element pathspec 	sdssplitargs able 
check magic signatures 	parse function 
append result 	returns allocated 
prefix magic 	tokens 
bitmap parse syntax 	success even 
anything top 	input empty 
magic needswork needs 	input contains 
rewritten start 	unbalanced quotes 
migrating pathspec users 	closed quotes 
use pathspec 	followed 
example pathspec element 	non space 
may marked 	characters foo 
insensitive prefix part 	bar foo 
must always 	skip blanks 
match literally single 	token quotes 
stupid cannot 	single 
express nothing longhand 	quotes closing 
handle would 	quote must 
wrong matter shorthand 	followed space 
noglob pathspec 	nothing unterminated 
adds unless glob 	quotes closing 
specified glob 	quote 
pathspec overridden 	must followed 
prefix pathspec keep 	space nothing 
magic assign 	unterminated quotes 
original useful passing 	token vector 
another command 	even empty 
preserve actual prefix 	input 
length pattern 	something modify 
strip trailing slash 	substituting occurrences 
fixme enable 	characters specified 
onestar glob pattern 	corresponding character 
sanity checks 	instance sdsmapchars 
pathspec matchers sane 	mystring 
may want 	effect turning 
substitute command command 	hello ell 
name interactive 	function returns 
dies running checkout 	sds pointer 
given command 	always input 
line arguments prefix 	pointer 
convert input 	since resize 
pathspec die 	needed specified 
magic magic mask 	separator also 
used arguments 	returns result 
prefix pathspec arguments 	sds like 
prefix prefix 	sdsjoin 
pathspec pathspec deprecated 	joins sds 
favor pathspec 	wrappers allocators 
see pathspec parse 	used sds 
pathspec arguments 	note sds 
prefix path relative 	actually use 
root working 	macros 
pathspec list paths 	defined sdsalloc 
underneath prefix 	order avoid 
path iterates pathspec 	pay overhead 
prepending path 	function calls 
prefix resulting list 	define wrappers 
pathspec empty 	programs 
singleton list containing 	sds linked 
prefix pathspec 	want touch 
prefix empty 	sds internals 
empty list typically 	even use 
used built 	different allocator 
commands order normalize 	run 
argv arguments 	test times 
provided built list 	order hit 
paths process 	first two 
relative root working 	sds header 
pathspec.h raw 	types type 
magic max depth 	size 
match original 	init initlen 
magic len prefix 	type hdrlen 
nowildcard len 	init initlen 
flags pathspec magic 	reallen addlen 
mask flags 	newsh avail 
prefix args dst 	len 
src pathspec 	newlen type 
item item pathspec 	oldtype hdrlen 
pathspec seen 	newsh type 
path path 	oldtype hdrlen 
prefix strncasecmp strncmp 	len alloc 
strcasecmp strcmp 	incr 
pathspec magic pathspec 	flags len 
pattern satisfies 	oldlen len 
gfnm onestar pathspec 	curlen len 
result freed 	curlen len 
free pathspec parse 	aux aux 
pathspec flags 	buf 
args means match 	len fmt 
cwd args 	cpy staticbuf 
means match everything 	buflen fmt 
max depth 	fmt initlen 
field valid strip 	next str 
trailing slash 	num 
given path gitlink 	unum buf 
die symlink 	buf cset 
part given 	start end 
path directory like 	len start 
combination leading 	end 
path slash cheap 	newlen len 
strips trailing 	minlen cmp 
slash given path 	len sep 
gitlink also 	seplen count 
checks dies gitlink 	tokens newtokens 
part leading 	tokens 
path given path 	count len 
goes beyond 	line argc 
submodule safer slash 	current vector 
cheap also 	inq insq 
expensive callers need 	done setlen 
pure paths 	argv 
somewhere command line 	argc sep 
pathspecs options 	argv argc 
ignored magic parsed 	sep seplen 
pathspec either 	size ptr 
pathspec allowed 	size ptr 
automatically every pathspec 	oldfree 
pathspec pkt-line.c 	oldlen type 
packet buffer packet 	sds req 
trace prefix 	type sds 
trace packet trace 	hdr size 
pack prog 	malloc memset 
buf len sideband 	sds 
buf len 	hdr sds 
write pack sideband 	hdr sds 
buf fmt 	hdr sds 
args hexchar orig 	hdr memcpy 
len fmt 	sdsnewlen strlen 
buf args buf 	sdsnewlen 
fmt args 	sdsnewlen sdslen 
src buf src 	free sds 
size dst 	hdr size 
size options ret 	strlen sdssetlen 
linelen len 	sdssetlen sdsavail 
src buf 	sdslen 
src len buffer 	sds hdr 
size options 	size sds 
len ret linelen 	req type 
src src 	sds hdr 
len dst len 	size realloc 
len len 	malloc 
src src len 	memcpy free 
dst len 	sdssetlen sdssetalloc 
trace key init 	sdslen sds 
trace key 	hdr size 
init xstrdup trace 	sds req 
verbatim trace 	type 
verbatim trace want 	sds hdr 
trace want 	size realloc 
packet trace pack 	malloc memcpy 
starts starts 	free sdssetlen 
packet trace pack 	sdssetalloc sdsalloc 
strlen trace 	sds 
want strbuf 	hdr size 
init strbuf addf 	sds hdr 
trace prefix 	size sds 
strbuf addch strbuf 	type len 
addf strbuf 	sds hdr 
addch trace strbuf 	sds 
strbuf release 	hdr sds 
packet trace write 	hdr sds 
die packet 	hdr sdslen 
trace strbuf strbuf 	sds make 
addstr strbuf 	room memset 
vaddf die hex 	sdssetlen 
hex hex 	sdslen sds 
hex packet trace 	make room 
strbuf reset 	memcpy sdssetlen 
start format packet 	sdscatlen strlen 
end write 	sdscatlen sdslen 
die start 	sdsalloc 
format packet end 	sds make 
die memcpy 	room sdslen 
read full die 	memcpy sdssetlen 
errno die 	sdscpylen strlen 
packet data packet 	sdsll str 
length die 	sdsnewlen 
packet trace die 	strlen malloc 
packet data 	copy vsnprintf 
packet trace packet 	end free 
read packet 	malloc sdscat 
read line packet 	free start 
read line 	sdscatvprintf 
another non pack 	end sdslen 
sideband make 	start sdsavail 
note human readable 	sds make 
trace pack 	room arg 
data started guess 	strlen sdslen 
header quoting 	sdsavail 
xxx really 	sds make 
handle printable utf 	room memcpy 
suppress newlines 	sdsinclen arg 
buffered things flush 	sdsll str 
read size 	sdsavail sds 
bytes source whatever 	make 
complain didn 	room memcpy 
enough bytes satisfy 	sdsinclen sdsull 
read pkt-line.h 	str sdsavail 
attribute buf attribute 	sds make 
src buffer 	room memcpy 
src len buffer 	sdsinclen 
size options 	sdsinclen sdsinclen 
size src buf 	end sdslen 
src len 	strchr strchr 
size packet buffer 	memmove sdssetlen 
write packetized 	sdslen memmove 
stream line preceded 	sdssetlen 
length including 	sdslen tolower 
header hex 	sdslen toupper 
number length zero 	sdslen sdslen 
means end 	memcmp malloc 
stream length would 	realloc memcmp 
error pretty 	sdsnewlen 
stupid use packetized 	sdsnewlen sdsfree 
line format 	free sdsfree 
make streaming format 	free sdscatlen 
possible without 	sdscatprintf sdscatlen 
ever running read 	sdscatlen sdscatlen 
buffers way 	sdscatlen 
never read might 	sdscatlen isprint 
pack data 	sdscatprintf sdscatprintf 
another process entirely 	sdscatlen isspace 
writing side 	sdsempty hex 
could use stdio 	digit hex 
since reading 	digit 
side stay pure 	hex digit 
read write 	hex digit 
interfaces read 	sdscatlen sdscatlen 
packetized line buffer 	isspace sdscatlen 
must least 	sdscatlen isspace 
size bytes specifies 	sdscatlen 
number bytes 	sdscatlen realloc 
read buffer src 	malloc sdsfree 
buffer src 	free sdsfree 
buffer point buffer 	sdslen sdsempty 
containing packet 	sdscat sdscat 
data parse least 	sdsempty 
src len 	sdscatsds sdscatlen 
bytes function returns 	malloc realloc 
src buf 	free sdsnew 
incremented src len 	sdsfree sdsnewlen 
decremented number 	sdscat test 
bytes consumed src 	cond 
buffer src 	sdslen memcmp 
buffer data 	sdscpy sdscpy 
read descriptor options 	sdsfree sdscatprintf 
contain packet 	sdsempty sdsfree 
read gentle eof 	sdsnew sdscatfmt 
die following 	sdsfree 
conditions read error 	sdsnew sdscatfmt 
descriptor protocol 	sdsfree sdsnew 
error remote bogus 	sdstrim sdsfree 
length characters 	sdsnew sdstrim 
receiving packet larger 	sdsfree sdsnew 
size bytes 	sdstrim 
truncated output remote 	sdsdup sdsrange 
expected packet 	sdsfree sdsdup 
got eof got 	sdsrange sdsfree 
packet followed 	sdsdup sdsrange 
eof options contain 	sdsfree sdsdup 
packet read 	sdsrange 
gentle eof die 	sdsfree sdsdup 
condition truncated 	sdsrange sdsfree 
input instead 	sdsdup sdsrange 
however still die 	sdsfree sdsfree 
conditions options 	sdsnew sdsnew 
contains packet read 	sdsfree 
chomp newline 	sdsfree sdsnew 
trailing newline present 	sdsnew sdsfree 
removed buffer 	sdsfree sdsnew 
returning convenience wrapper 	sdsnew sdsfree 
packet read 	sdsfree sdsnewlen 
gentle sets chomp 	sdscatrepr 
newline option 	sdsempty sdslen 
flush packet otherwise 	sdsfree sdsfree 
points buffer 	sdsnew test 
may overwritten subsequent 	cond sdslen 
calls size 	sdsavail sdslen 
parameter length packet 	sds 
written packet 	make room 
read line read 	test cond 
buf rather 	sdslen test 
descriptor see 	cond sdsavail 
packet read details 	sdsavail sds 
src used 	incr 
poll.c sought ret 	len test 
happened irbuffer 	cond memcmp 
avail nbuffer ret 	test cond 
iosb fpli 	sdslen sdsfree 
query information file 	sds test 
sought network 	sds 
events happened error 	lib library 
data sought 	copyright salvatore 
rfds wfds efds 	sanfilippo antirez 
happened socket 	gmail dot 
errno data pfd 	copyright oran 
nfd timeout 	agra 
rfds wfds efds 	copyright redis 
ptv maxfd 	labs inc 
open max happened 	rights reserved 
handle ret 	redistribution use 
wait timeout 	source binary 
nhandles elapsed orig 	forms 
timeout rfds 	without modification 
wfds xfds poll 	permitted provided 
msg sought 	following conditions 
requested ret happened 	met redistributions 
sought console 	source code 
handle wsa network 	must 
events file 	retain copyright 
type proc address 	notice list 
module handle 	conditions following 
peek named pipe 	disclaimer redistributions 
last error 	binary form 
memset memset query 	must 
information file 	reproduce copyright 
wait single console 	notice list 
handle number 	conditions following 
console input events 	disclaimer documentation 
alloca peek 	materials provided 
console input 	distribution 
wait single wsa 	neither name 
last error 	redis names 
recv wsa last 	contributors may 
error wsa 	used endorse 
last error isset 	promote products 
recv ioctl 	derived 
recv isset isset 	software without 
sysconf zero 	specific prior 
zero zero compute 	written permission 
revents tick 	software provided 
count create zero 	copyright holders 
zero zero 	contributors 
osfhandle socket handle 	express implied 
wsa win 	warranties including 
compute revents msg 	limited implied 
wait multiple 	warranties merchantability 
objects peek 	fitness particular 
message translate message 	purpose 
dispatch message 	disclaimed shall 
osfhandle wsa network 	copyright owner 
events wsa 	contributors liable 
isset isset isset 	direct indirect 
win compute 	incidental special 
revents socket win 	exemplary 
compute revents 	consequential damages 
tick count sleep 	including limited 
emulation poll 	procurement substitute 
contributed paolo bonzini 	goods services 
copyright free 	loss use 
software foundation inc 	data 
file part 	profits business 
gnulib program free 	interruption however 
software redistribute 	caused theory 
modify terms gnu 	liability whether 
general license 	contract strict 
published free 	liability 
software foundation either 	tort including 
version option 	negligence otherwise 
later version program 	arising way 
distributed hope 	use software 
useful without warranty 	even advised 
without even 	possibility 
implied warranty merchantability 	damage create 
fitness particular 	sds content 
purpose see gnu 	specified init 
general license 	pointer initlen 
details received copy 	used init 
gnu general 	initialized 
license along program 	zero bytes 
write free 	always termined 
software foundation inc 	sds always 
franklin street 	even create 
fifth floor boston 	sds mystring 
usa tell 	sdsnewlen 
gcc warn 	abc print 
nfd tests specification 	end however 
msg peek 	binary safe 
wine seems getsockopt 	contain characters 
returns pipes 	middle length 
wsa network events 	stored 
instead distinguishes 	sds header 
two correctly declare 	empty usually 
data structures 	created order 
ntdll functions compute 	append use 
revents values 	type since 
file handle events 	type 
cannot happen 	good flags 
handle eliminate sought 	pointer create 
write end 	empty zero 
pipe check writable 	length sds 
query information 	even always 
file fails optimistically 	term 
pipe writable 	create sds 
could happen 	starting terminated 
win query information 	duplicate sds 
file available 	free sds 
inherit pipe doesn 	operation performed 
permit file 	sds 
read attributes access 	length length 
write end 	obtained strlen 
think happen since 	considering content 
win wine 	first term 
seems fine otherwise 	character function 
ensure enough 	useful 
space available atomic 	sds hacked 
writes input 	manually way 
buffer screen buffer 	like following 
convert sets 	example sdsnew 
returned revents values 	foobar sdsupdatelen 
distinguish hung 	sdslen 
sockets errors 	output comment 
min convert returned 	call sdsupdatelen 
sets poll 	output modified 
revents values bug 	logical length 
mac causes 	remains bytes 
ignore msg peek 	modify 
kinds descriptors 	sds place 
detect descriptor connected 	make empty 
socket server 	zero length 
socket something recv 	however existing 
use ioctl 	buffer discarded 
detect pollhup happened 	free 
unconnected server 	space next 
socket fine distinguish 	append operations 
hung sockets 	require allocations 
errors systems use 	number bytes 
recv non 	previously available 
socket including non 	enlarge 
stop min 	free space 
open max 	end sds 
open max check 	caller sure 
needed open 	calling function 
max efault necessary 	overwrite addlen 
implement simplest 	bytes 
convert timeout number 	end plus 
timeval structure 	one nul 
wait forever create 	term note 
sets determine 	change length 
max see exceptional 	sds returned 
condition detectable 	sdslen 
band data received 	free buffer 
socket hence 	space asap 
push pollwrband events 	enough space 
onto wfds 	left use 
instead efds examine 	type user 
sets establish 	appending 
results classify socket 	type able 
handles create 	remember empty 
sets see 	space sds 
socket handles mapped 	make room 
onto poll 	must called 
poll also screen 	every 
buffer handles 	appending operation 
waitable block character 	since header 
available win 	size changes 
compute revents eliminates 	need move 
bits wrong 	forward use 
direction msg wait 	realloc 
multiple objects 	reallocate sds 
anyway dispatch messages 	free space 
need call 	end contained 
input kind place 	remains altered 
sentinel end 	next concatenation 
socket lucky wsa 	operations 
network events 	require reallocation 
already provided way 	call passed 
distinguish read 	sds longer 
accept saves 	valid references 
recv later socket 	must substituted 
poll.h events 	pointer 
revents pfd nfd 	returned call 
timeout header 	total size 
poll emulation contributed 	allocation specifed 
paolo bonzini 	sds including 
copyright free software 	sds header 
foundation inc 	pointer 
file part gnulib 	free buffer 
program free 	end term 
software redistribute modify 	pointer actual 
terms gnu 	sds allocation 
general license published 	normally sds 
free software 	referenced 
foundation either version 	start buffer 
option later 	increment sds 
version program 	length decrements 
distributed hope useful 	left free 
without warranty 	space end 
without even implied 	according 
warranty merchantability 	incr also 
fitness particular purpose 	term end 
see gnu 	function used 
general license details 	order fix 
received copy 	length user 
gnu general license 	calls 
along program 	sds make 
write free software 	room writes 
foundation inc 	something end 
franklin street fifth 	current needs 
floor boston 	length note 
usa fake poll 	possible 
environment readable 	use negative 
data available oob 	increment order 
urgent readable 	right trim 
data file 	usage example 
descriptor writeable poll 	sds incr 
error occurred 	len 
file descriptor hung 	sds make 
requested events 	room possible 
invalid file descriptor 	mount following 
poll events 	schema cat 
interested events found 	bytes coming 
define inftim 	kernel 
conforms posix poll 	end sds 
pread.c buf 	without copying 
count offset current 	intermediate buffer 
offset lseek 	oldlen sdslen 
lseek read full 	sds make 
lseek precompose 	room 
utf8c repo encoding 	buffer size 
path encoding 	nread read 
maxlen strlen ptr 	oldlen buffer 
strlen chars 	size check 
ret path 	nread handle 
auml nfc auml 	sds 
nfd output 	incr len 
argc argv oldarg 	nread avoid 
newarg precompose 	compilation warnings 
namelen dirname prec 	grow sds 
dir ret 	specified 
errno prec dir 	length bytes 
res namelenz 	part original 
maxlen ret errno 	length sds 
len inleft 	zero specified 
outpos outsz prec 	length smaller 
dir ret 	current 
ret errno git 	length operation 
path buf 	performed make 
open close git 	sure added 
path buf 	region doesn 
access git config 	contain garbage 
git path 	also 
buf unlink 	trailing append 
die errno strbuf 	specified binary 
release iconv 	safe pointed 
open non ascii 	len bytes 
reencode iconv 	end specified 
iconv close xmalloc 	sds 
xmalloc opendir 	call passed 
free free iconv 	sds longer 
open readdir 	valid references 
strlen xrealloc non 	must substituted 
ascii die 	pointer returned 
iconv strlcpy closedir 	call 
iconv close 	append specified 
free free converts 	termianted sds 
filenames decomposed 	call passed 
unicode precomposed unicode 	sds longer 
used mac 	valid references 
found defined config 	must 
respect iconv 	substituted pointer 
open fails 	returned call 
die readdir needed 	append specified 
iconv failed 	sds existing 
errno could big 	sds call 
eilseq einval 	modified 
ebadf mac avoids 	sds longer 
illegal sequemces 	valid references 
occur mounted drive 	must substituted 
nfs worth 	pointer returned 
die rather user 	call destructively 
see original 	modify 
name trigger strlcpy 	sds hold 
precompose utf8h 	specified binary 
argc argv dirname 	safe pointed 
dirp dirp 	length len 
posix see available 	bytes like 
systems git 	sdscpylen 
runs see 	must termined 
http pubs opengroup 	length obtained 
onlinepubs basedefs 	strlen helper 
dirent html name 	sdscatlonglong actual 
max enough 	number conversion 
systems name max 	must 
strlen name 	point room 
may solution allocate 	least sds 
needed see 	llstr size 
precompose utf readdir 	bytes function 
precompose unicode 	returns length 
precompose unicode preload-index.c 	terminated 
index pathspec 	representation stored 
pthread index pathspec 	generate representation 
offset data 	method produces 
index cep cache 	reversed compute 
index pathspec 	length term 
threads work offset 	reverse 
data index 	identical sdsll 
pathspec retval 	str type 
stage isgitlink uptodate 	generate representation 
path match 	method produces 
threaded symlink leading 	reversed compute 
path namelen 	length 
lstat match stat 	term reverse 
mark uptodate 	create sds 
cache def clear 	much faster 
div round 	sdscatprintf sdsempty 
memset copy pathspec 	lld like 
pthread create 	sdscatprintf 
die pthread die 	gets list 
read index 	instead variadic 
preload index copyright 	start buffer 
linus torvalds 	speed possible 
nothing mostly randomly 	revert heap 
chosen maximum 	allocation 
counts cap parallelism 	buffers two 
threads want 	times bigger 
least lstat 	every time 
per worth starting 	fail fit 
pretty.c user 	current buffer 
format name tformat 	size 
user format 	concat obtained 
builtin formats len 	sds append 
commit formats 	sds obtained 
len commit formats 	alike format 
alloc sought 	specifier call 
commit format empty 	modified 
rev tformat 	sds longer 
commit format name 	valid references 
fmt builtin 	must substituted 
formats sought original 	pointer returned 
num redirections 	call example 
found found match 	sdsnew 
len match 	sum sdscatprintf 
len sought arg 	often need 
rev commit 	create scratch 
format msg 	alike format 
ret len len 	need use 
rfc special 	sdsempty 
needs rfc encoding 	target sdscatprintf 
rfc ident 	sdsempty format 
mode date line 	args function 
encoding ident 	similar sdscatprintf 
line end mailbuf 	much faster 
namebuf namelen 	rely 
maillen max length 	sprintf family 
buf quoted 	functions implemented 
line len len 	libc often 
msg linelen 	slow moreover 
commit parent hex 	directly handling 
msg key 	sds 
len buf encoding 	data concatenated 
tmp start 	provides performance 
len commit 	improvement however 
commit encoding output 	function handles 
encoding utf 	incompatible subset 
use encoding encoding 	alike 
msg email 	format specifiers 
email len name 	sds bit 
name len 	integer bit 
mail map part 	integer verbatim 
msg len 	character next 
dmode placeholder len 	format 
name mail 	specifier process 
maillen namelen len 	position next 
commit pretty 	write dest 
ctx signature check 	str make 
message commit 	sure always 
encoding width indent 	space 
indent color 	least handle 
padding author committer 	generally unknown 
message subject 	term part 
body abbrev 	left right 
commit hash abbrev 	composed contiguous 
hash abbrev 	characters 
parent hashes wrap 	found cset 
start chunk 	terminted call 
context msg name 	modified sds 
eol msg 	longer valid 
trimlen start len 	references must 
space msg 	substituted 
line separator first 	pointer returned 
line linelen 	call example 
msg start pos 	sdsnew hello 
width indent 	world sdstrim 
indent tmp width 	output hello 
indent indent 	world 
part log dmode 	turn smaller 
ident placeholder 	equal containing 
rest begin end 	substring specified 
color placeholder 	start end 
column start 	indexes start 
end next width 	end 
placeholder context 	negative means 
commit msg ret 	last character 
indent next 	penultimate character 
start end placeholder 	forth interval 
local len 	inclusive start 
padding start occupied 	end 
modifier consumed 	characters part 
offset placeholder context 	resulting modified 
consumed orig 	place example 
len placeholder context 	sdsnew hello 
fmt dummy 	world sdsrange 
commit format pretty 	ello 
ctx context 	world apply 
output enc utf 	tolower every 
outsz encoding 	character sds 
commit msg parents 	apply toupper 
shown name 	every character 
line linelen 	sds 
num msg encoding 	compare two 
need bit 	sds memcmp 
cte max length 	positive negative 
title header 	exactly binary 
fmt msg indent 	two share 
first line 	exactly 
linelen commit beginning 	prefix one 
body indent 	two additional 
msg reencoded encoding 	characters longer 
need bit 	considered greater 
cte body commit 	smaller one 
easy free 	split 
xstrdup skip prefix 	separator sep 
strcmp strcmp 	sds returned 
alloc grow memset 	count reference 
xstrdup git 	number tokens 
config skip 	returned memory 
prefix skip prefix 	zero 
strchr size 	length zero 
alloc grow memcpy 	length separator 
size git 	returned note 
config die starts 	sep able 
strlen find 	split multi 
commit format recursive 	character 
setup commit 	separator example 
formats find commit 	sdssplit foo 
format recursive 	bar two 
skip prefix save 	elements foo 
user format 	bar version 
skip prefix strchr 	function 
save user 	binary safe 
format find commit 	requires length 
format die 	arguments sdssplit 
save user format 	function zero 
isascii non 	terminated make 
ascii rfc 	sure 
special strbuf grow 	room next 
strbuf addch 	element one 
strbuf addch strbuf 	search separator 
addch strbuf 	skip separator 
addch strtoul date 	element sure 
overflows strtol 	room 
show date strchrnul 	tokens free 
split ident 	result returned 
line map user 	sdssplitlen nothing 
ident cmp 	tokens append 
strbuf addstr strbuf 	sds escaped 
strbuf addstr 	representation 
strbuf strbuf addstr 	non printable 
list append 	characters tested 
strbuf detach strbuf 	isprint turned 
addstr needs 	escapes form 
rfc encoding rfc 	hex number 
needs rfc 	call 
quoting rfc 	modified sds 
quoted strbuf wrapped 	longer valid 
bytes strbuf 	references must 
release strbuf wrapped 	substituted pointer 
bytes last 	returned call 
line length strlen 	helper 
strlen strbuf 	function sdssplitargs 
addch strbuf addf 	returns non 
strbuf addf 	zero valid 
strbuf addf show 	hex digit 
ident date 	helper function 
strbuf addf show 	sdssplitargs 
ident date 	converts hex 
date mode strbuf 	digit integer 
addf show 	split line 
ident date isspace 	arguments every 
one line 	argument following 
empty line strbuf 	programming 
addstr find 	language repl 
unique abbrev 	alike form 
oid hex strbuf 	foo bar 
addf strbuf 	newline supported 
addch find commit 	xff otherstuff 
header xmemdupz 	number 
starts strchr strchr 	arguments stored 
strbuf attach 	argc sds 
strlen strlen encoding 	returned caller 
utf strbuf 	free resulting 
strbuf splice strlen 	sds sdsfreesplitres 
strlen strlen 	note 
strbuf detach commit 	sdscatrepr able 
buffer header 	convert back 
header encoding cached 	quoted format 
commit buffer 	sdssplitargs able 
xstrdup reencode unuse 	parse function 
commit buffer 	returns 
replace encoding header 	allocated tokens 
free xcalloc 	success even 
read mailmap 	input empty 
map user split 	input contains 
ident line 	unbalanced quotes 
mailmap name strbuf 	closed 
strbuf strbuf 	quotes followed 
strbuf addstr show 	non space 
ident date 	characters foo 
strbuf addstr show 	bar foo 
ident date 	skip blanks 
date mode strbuf 	token 
addstr show 	quotes single 
ident date date 	quotes closing 
mode strbuf 	quote must 
addstr show ident 	followed space 
date date 	nothing unterminated 
mode strbuf addstr 	quotes 
show ident 	closing quote 
date date 	must followed 
mode strbuf adddup 	space nothing 
skip prefix 	unterminated quotes 
skip prefix istitlechar 	token vector 
strbuf addch 	even 
strbuf addch strbuf 	empty input 
one line 	something modify 
empty line strbuf 	substituting occurrences 
grow strbuf 	characters specified 
addstr strbuf skip 	corresponding character 
empty lines 	instance 
format subject skip 	sdsmapchars mystring 
empty lines 	effect turning 
strbuf strbuf wrapped 	hello ell 
text strbuf 	function returns 
swap strbuf release 	sds pointer 
strbuf wrap 	always 
reflog ident format 	input pointer 
person part 	since resize 
strlen strchr 	needed specified 
skip prefix want 	separator also 
color color 	returns result 
parse mem die 	sds 
strbuf addstr 	like sdsjoin 
skip prefix strbuf 	joins sds 
addstr skip 	wrappers allocators 
prefix strbuf addstr 	used sds 
skip prefix 	note sds 
strbuf addstr skip 	actually 
prefix strbuf 	use macros 
addstr strcspn strtoul 	defined sdsalloc 
strchr starts 	order avoid 
starts starts starts 	pay overhead 
parse color 	function calls 
strbuf addch strbuf 	define 
addch strchr 	wrappers programs 
strtoul strtoul strtoul 	sds linked 
rewrap message 	want touch 
tail parse 	sds internals 
padding placeholder parse 	even use 
strbuf addstr 	different 
diff color strbuf 	allocator run 
addstr oid 	test times 
hex strbuf addstr 	order hit 
diff color 	first two 
strbuf addstr diff 	sds header 
color strbuf 	types 
addstr diff color 	sds lib 
strbuf addstr 	library copyright 
find unique abbrev 	salvatore sanfilippo 
strbuf addstr 	antirez gmail 
diff color strbuf 	dot copyright 
addstr oid 	oran 
hex strbuf addstr 	agra copyright 
find unique 	redis labs 
abbrev strbuf addch 	inc rights 
strbuf addstr 	reserved redistribution 
oid hex 	use source 
strbuf addch strbuf 	binary 
addstr find 	forms without 
unique abbrev strbuf 	modification permitted 
addstr revision 	provided following 
mark load decorations 	conditions met 
format decorations 	redistributions source 
load decorations format 	code 
decorations extended 	must retain 
reflog selector reflog 	copyright notice 
message format 	list conditions 
reflog person strbuf 	following disclaimer 
addstr check 	redistributions binary 
commit signature strbuf 	form 
addstr strbuf 	must reproduce 
addch strbuf addstr 	copyright notice 
strbuf addstr 	list conditions 
parse commit 	following disclaimer 
header format person 	documentation materials 
part format 	provided 
person part strbuf 	distribution neither 
addstr strbuf 	name redis 
addstr parse commit 	names contributors 
message format 	may used 
subject format sanitized 	endorse promote 
subject strbuf 	products 
addstr strrchr utf 	derived software 
strnwidth format 	without specific 
commit one utf 	prior written 
strnwidth display 	permission software 
mode esc sequence 	provided copyright 
len strbuf 	holders 
insert strbuf setlen 	contributors express 
strbuf utf 	implied warranties 
replace strbuf utf 	including limited 
replace strbuf 	implied warranties 
utf replace 	merchantability fitness 
strbuf addbuf strbuf 	particular 
addchars memcpy 	purpose disclaimed 
strbuf release format 	shall copyright 
pad commit 	owner contributors 
format commit one 	liable direct 
strbuf setlen 	indirect incidental 
strbuf insert strbuf 	special 
insert strbuf 	exemplary consequential 
expand strbuf release 	damages including 
memset logmsg 	limited procurement 
reencode strbuf expand 	substitute goods 
rewrap message 	services loss 
tail encoding encoding 	use 
reencode len 	data profits 
strbuf attach free 	business interruption 
unuse commit 	however caused 
buffer one line 	theory liability 
strbuf starts 	whether contract 
die commit 	strict 
list count strbuf 	liability tort 
grow merge 	including negligence 
info skip prefix 	otherwise arising 
strbuf grow 	way use 
user info skip 	software even 
prefix strbuf 	advised 
grow user info 	possibility damage 
strbuf init 	create sds 
format subject strbuf 	content specified 
grow strbuf 	init pointer 
addstr needs rfc 	initlen used 
encoding rfc 	init 
strbuf wrapped bytes 	initialized zero 
last line 	bytes always 
length strbuf addbuf 	termined sds 
strbuf addch 	always even 
non ascii strbuf 	create sds 
addf strbuf 	mystring 
addstr strbuf 	sdsnewlen abc 
addch strbuf addstr 	print end 
free list 	however binary 
clear strbuf addch 	safe contain 
strbuf release 	characters middle 
one line empty 	length 
line strbuf 	stored sds 
grow strbuf addchars 	header empty 
strbuf strbuf 	usually created 
addch format commit 	order append 
message log 	use type 
output encoding logmsg 	since 
reencode non 	type good 
ascii header strbuf 	flags pointer 
addch skip 	create empty 
empty lines title 	zero length 
line remainder 	sds 
strbuf rtrim 	even always 
strbuf addch strbuf 	term create 
addch unuse 	sds starting 
commit buffer support 	terminated duplicate 
pretty printing 	sds free 
header high bit 	sds 
iso many 	operation performed 
bytes already used 	sds length 
last line 	length obtained 
guess may also 	strlen considering 
backslash quote 	content first 
fall rfc section 	term 
bit values 	character function 
correspond printable ascii 	useful sds 
characters underscore 	hacked manually 
may represented characters 	way like 
see section 	following example 
restrictions particular space 	sdsnew 
tab must 	foobar sdsupdatelen 
represented within 	sdslen output 
encoded words rule 	comment call 
non ascii 	sdsupdatelen output 
characters non printable 	modified logical 
characters non 	length 
ascii check redundant 	remains bytes 
isprint localized 	modify sds 
knows ascii defensive 	place make 
rule special 	empty zero 
printable characters whitespace 	length however 
character considered 	existing 
printable defensive use 	buffer discarded 
isspace rfc 	free space 
section replacement word 	next append 
entity within 	operations require 
phrase example one 	allocations number 
precedes address 	bytes 
header abnf definition 	previously available 
phrase rfc 	enlarge free 
thus becomes 	space end 
phrase encoded word 	sds caller 
word characters 	sure calling 
may used encoded 	function 
encoded word 	overwrite addlen 
restricted upper lower 	bytes end 
ascii letters 	plus one 
digits underscore ascii 	nul term 
encoded word 	note change 
appears within phrase 	length 
must separated 	sds returned 
adjacent word text 	sdslen free 
special linear 	buffer space 
white space special 	asap enough 
cases per 	space left 
rfc rfc section 	use 
encoded word 	type user 
must represent integral 	appending type 
number characters 	able remember 
multi octet 	empty space 
character may split 	sds make 
across adjacent 	room 
encoded word chrlen 	must called 
according rfc 	every appending 
could encode special 	operation since 
character space 	header size 
underscore readability many 	changes need 
programs understand 	move 
underscore place thus 	forward use 
nothing special 	realloc reallocate 
causes encoded avoiding 	sds free 
problem won 	space end 
fit trailing line 	contained remains 
plus per 	altered 
rfc per rfc 	next concatenation 
notin guess 	operations require 
encoding header happen 	reallocation call 
defensive coded 	passed sds 
utf drop 	longer valid 
header replaces xxxx 	references 
encoding xxxx 	must substituted 
encoding work done 	pointer returned 
encoding header 	call total 
nothing message verbatim 	size allocation 
whether newly 	specifed sds 
allocated otherwise still 	including 
want munge 	sds header 
encoding header result 	pointer free 
done modifying 	buffer end 
buffer fresh copy 	term pointer 
reuse cached 	actual sds 
copy commit buffer 	allocation 
need duplicate 	normally sds 
avoid munging cached 	referenced start 
copy actual 	buffer increment 
encoding work 	sds length 
reencoding still leaves 	decrements left 
header replaced 	free 
next step point 	space end 
done msg 	according incr 
allocated fresh copy 	also term 
free replacement 	end function 
actually consumes buffer 	used order 
hand worry 	fix 
freeing old encoding 	length user 
failed might 	calls sds 
commit message verbatim 	make room 
currently placeholders 	writes something 
length mailmap lookup 	end current 
name email 	needs 
date unix timestamp 	length note 
date date 	possible use 
rfc style date 	negative increment 
relative date 	order right 
iso like 	trim usage 
date iso strict 	example 
reading either 	sds incr 
bogus commit reflog 	len sds 
entry etc 	make room 
cannot updated still 	possible mount 
need compute 	following schema 
valid unknown placeholder 	cat 
offsets relative 	bytes coming 
start commit message 	kernel end 
following ones 	sds without 
relative result strbuf 	copying intermediate 
haven seen 	buffer oldlen 
chunk caller surely 	sdslen 
going hard 	sds make 
way remember likely 	room buffer 
start added 	size nread 
chunk current end 	read oldlen 
strbuf nothing 	buffer size 
trim trailing 	check 
characters utf next 	nread handle 
means wide 	sds incr 
enough column utf 	len nread 
independent commit 	avoid compilation 
consumed bytes otherwise 	warnings grow 
decided treat 	sds 
unknown previous still 	specified length 
valid newline 	bytes part 
nul etc depend 	original length 
commit commit 	sds zero 
hash abbreviated commit 	specified length 
hash hash 	smaller 
abbreviated hash parent 	current length 
hashes abbreviated 	operation performed 
parent hashes left 	make sure 
right bottom 	added region 
reflog info reflog 	doesn contain 
selector reflog 	garbage 
message unknown 	also trailing 
placeholder rest parse 	append specified 
commit header 	binary safe 
author committer encoding 	pointed len 
raw body 	bytes end 
message always left 	specified 
initial newline 	sds call 
need parse commit 	passed sds 
message subject 	longer valid 
sanitized subject body 	references must 
unknown placeholder 	substituted pointer 
utf check trailing 	returned 
ansi sequences 	call append 
got good ansi 	specified termianted 
sequence put 	sds call 
back local cutting 	passed sds 
calculate padding 	longer valid 
columns convert 	references 
back chars utf 	must substituted 
convert commit 	pointer returned 
message utf first 	call append 
far format 	specified sds 
commit item assumes 	existing sds 
utf convert 	call 
commit message actual 	modified sds 
output encoding 	longer valid 
end header enough 	references must 
slop medium 	substituted pointer 
shows author dates 	returned call 
full shows 	destructively 
authors dates fuller 	modify sds 
shows authors 	hold specified 
dates per rfc 	binary safe 
need check 	pointed length 
emit content type 	len bytes 
mark bit 	like 
haven done 	sdscpylen must 
author could non 	termined length 
bit ascii 	obtained strlen 
log may skip 	helper sdscatlonglong 
header part 	actual number 
first skip excess 	conversion 
blank lines 	must point 
beginning body formats 	room least 
treat title 	sds llstr 
line specially make 	size bytes 
sure eoln 	function returns 
non oneline caller 	length 
may append 	terminated representation 
additional body text 	stored generate 
mail format 	representation method 
make sure strip 	produces reversed 
blank line 	compute length 
header body prio-queue.c 	term 
queue cmp 	reverse identical 
queue tmp 	sdsll str 
queue queue queue 	type generate 
thing parent 	representation method 
queue result child 	produces reversed 
compare die 	compute 
swap free alloc 	length term 
grow compare 	reverse create 
swap compare compare 	sds much 
swap append 	faster sdscatprintf 
end lifo bubble 	sdsempty lld 
one lifo 	like 
push one root 	sdscatprintf gets 
left use 	list instead 
right child prio-queue.h 	variadic start 
ctr data 	buffer speed 
compare insertion ctr 	possible revert 
data alloc 	heap 
prio queue thing 	allocation buffers 
prio queue 	two times 
prio queue 	bigger every 
prio queue priority 	time fail 
queue implementation 	fit current 
primarily keeping track 	buffer 
commits date 	size concat 
order process old 	obtained sds 
discovered used 	append sds 
hold pointer caller 	obtained alike 
responsible supplying 	format specifier 
function compare two 	call 
things alternatively 	modified sds 
data structure also 	longer valid 
used lifo 	references must 
stack specifying comparison 	substituted pointer 
function compare 	returned call 
two things one 	example 
two third 	sdsnew sum 
parameter data 	sdscatprintf often 
prio queue structure 	need create 
result returned 	scratch alike 
sign sign result 	format need 
subtracting two 	use 
one negative one 	sdsempty target 
sorts earlier 	sdscatprintf sdsempty 
two thing queue 	format args 
extract thing 	function similar 
compares smallest queue 	sdscatprintf much 
compare function 	faster 
queue acts lifo 	rely sprintf 
stack reverse 	family functions 
lifo elements prio 	implemented libc 
queue progress.c 	often slow 
curr total prev 	moreover directly 
total prev 	handling 
avg bytes avg 	sds data 
misecs last 	concatenated provides 
bytes last 	performance improvement 
misecs idx display 	however function 
title last 	handles incompatible 
total last percent 	subset 
delay delayed 	alike format 
percent treshold throughput 	specifiers sds 
progress update 	bit integer 
signum tpgrp progress 	bit integer 
done eol 	verbatim character 
percent percent buf 	next 
total rate 	format specifier 
progress total misecs 	process position 
count rate 	next write 
progress title total 	dest str 
percent treshold 	make sure 
delay progress title 	always 
total progress 	space least 
progress msg progress 	handle generally 
buf bufp 	unknown term 
len rate 	part left 
memset sigemptyset sigaction 	right composed 
setitimer setitimer 	contiguous 
signal tcgetpgrp getpgid 	characters found 
clear progress 	cset terminted 
signal foreground fileno 	call modified 
fflush foreground 	sds longer 
fileno fflush strbuf 	valid references 
reset strbuf 	must 
addstr strbuf humanise 	substituted pointer 
bytes strbuf 	returned call 
addstr strbuf humanise 	example sdsnew 
bytes strbuf 	hello world 
addstr getnanotime calloc 	sdstrim output 
strbuf init 	hello 
throughput display display 	world turn 
malloc fflush 	smaller equal 
progress signal start 	containing substring 
progress delay 	specified start 
stop progress 	end indexes 
msg strlen xmallocz 	start 
throughput xsnprintf 	end negative 
display free clear 	means last 
progress signal 	character penultimate 
strbuf release free 	character forth 
free simple 	interval inclusive 
text progress display 	start 
module git 	end characters 
copyright nicolas pitre 	part resulting 
nico fluxnic 	modified place 
net code free 	example sdsnew 
software redistribute 	hello world 
modify terms gnu 	sdsrange 
general license 	ello world 
version published free 	apply tolower 
software foundation 	every character 
inhibit progress report 	sds apply 
entirely update 	toupper every 
throughput every 	character 
bytes nanosecs want 	sds compare 
simplify things 	two sds 
keep track misecs 	memcmp positive 
sec obtained 	negative exactly 
unlikely good fallback 	binary two 
force last 	share 
update progress.h progress 	exactly prefix 
total progress 	one two 
title total title 	additional characters 
total percent 	longer considered 
treshold delay progress 	greater smaller 
progress msg 	one 
prompt.c cmd prompt 	split separator 
pass args 	sep sds 
buffer err prompt 	returned count 
flags askpass 	reference number 
err start 	tokens returned 
command strbuf reset 	memory 
strbuf read 	zero length 
close finish command 	zero length 
error strbuf 	separator returned 
release strbuf setlen 	note sep 
strcspn getenv 	able split 
getenv askpass git 	multi 
env git 	character separator 
terminal prompt strerror 	example sdssplit 
die prompts 	foo bar 
already contain end 	two elements 
prompt.h prompt 	foo bar 
flags prompt prune-packed.c 	version 
prune packed 	function binary 
usage progress path 	safe requires 
data opts 	length arguments 
sha path data 	sdssplit function 
opts opts 	zero terminated 
argc argv 	make 
prefix opts prune 	sure room 
packed options 	next element 
display progress rmdir 	one search 
sha pack 	separator skip 
unlink warn start 	separator element 
progress delay 	sure 
loose file objdir 	room tokens 
directory display 	free result 
progress stop progress 	returned sdssplitlen 
isatty parse 	nothing tokens 
options prune packed 	append sds 
objects ensure 	escaped 
show finishing progress 	representation non 
prune.c prune 	printable characters 
usage show verbose 	tested isprint 
expire show 	turned escapes 
progress fullpath sha 	form hex 
fullpath data 	number 
basename path 	call modified 
data path data 	sds longer 
path dir 	valid references 
argc argv prefix 	must substituted 
revs progress 	pointer returned 
options sha name 	call 
lstat error 	helper function 
unlink warn lookup 	sdssplitargs returns 
lstat error 	non zero 
sha hex unlink 	valid hex 
warn starts 	digit helper 
prune tmp file 	function 
rmdir opendir 	sdssplitargs converts 
readdir starts prune 	hex digit 
tmp file 	integer split 
mkpath closedir init 	line arguments 
revisions parse 	every argument 
options die sha 	following 
parse die 	programming language 
pending die 	repl alike 
isatty start progress 	form foo 
delay mark 	bar newline 
reachable objects stop 	supported xff 
progress loose 	otherstuff 
file objdir directory 	number arguments 
prune packed 	stored argc 
objects temporary files 	sds returned 
directory mkpathdup 	caller free 
directory temporary files 	resulting sds 
free repository 	sdsfreesplitres 
shallow prune shallow 	note sdscatrepr 
know must 	able convert 
reachable report errors 	back quoted 
stop pruning 	format sdssplitargs 
write errors particularly 	able parse 
space result 	function 
failed temporary 	returns allocated 
packs rarely indexes 	tokens success 
files beginning 	even input 
tmp accumulating pack 	empty input 
directories pthread.c 	contains unbalanced 
arg unused start 	quotes 
routine arg 	closed quotes 
ptr result cond 	followed non 
unused cond 	space characters 
cond mutex last 	foo bar 
waiter cond 	foo skip 
waiters cond current 	blanks 
start routine 	token quotes 
beginthreadex wait single 	single quotes 
err win 	closing quote 
posix last error 	must followed 
current initialize 	space nothing 
critical section create 	unterminated 
semaphore die 	quotes closing 
create die 	quote must 
close handle close 	followed space 
handle critical 	nothing unterminated 
section enter critical 	quotes 
section critical 	token vector 
section critical section 	even empty 
wait single 	input something 
enter critical section 	modify substituting 
critical section 	occurrences characters 
enter critical section 	specified 
enter critical 	corresponding character 
section critical section 	instance sdsmapchars 
release semaphore 	mystring effect 
err win posix 	turning hello 
last error 	ell function 
enter critical section 	returns 
release semaphore 	sds pointer 
critical section wait 	always input 
single critical 	pointer since 
section copyright 	resize needed 
andrzej haczewski ahaczewski 	specified separator 
gmail disclaimer 	also 
implementation git specific 	returns result 
subset original 	sds like 
pthreads api without 	sdsjoin joins 
lots features 	sds wrappers 
git doesn use 	allocators used 
git also 	sds 
makes sure passed 	note sds 
arguments valid 	actually use 
need checking security 	macros defined 
reset signaled 	sdsalloc order 
name unlock external 	avoid pay 
mutex wait 	overhead 
signal note held 	function calls 
mutex locked 	define wrappers 
enough increment waiters 	programs sds 
count problem 	linked want 
leaving mutex 	touch sds 
unlocked wait semaphore 	internals 
wait ignore 	even use 
decrease waiters count 	different allocator 
last waiter 	run test 
must notify broadcasting 	times order 
continued due 	hit first 
cond signal signaling 	two 
knows one 	sds header 
waiter continued cond 	types sds.c 
broadcast issued 	type size 
mutex held means 	init initlen 
waiters continued 	type hdrlen 
contending mutex end 	init 
function broadcasting 	initlen reallen 
cond broadcast yet 	addlen newsh 
sure waiter 	avail len 
consumed exactly 	newlen type 
one slice semaphor 	oldtype hdrlen 
last waiter 	newsh 
must tell broadcasting 	type oldtype 
contend waiters 	hdrlen len 
mutex auf den 	alloc incr 
kampf external 	flags len 
mutex important implementation 	oldlen len 
requires pthread 	curlen 
cond signal called 	len curlen 
mutex held 	len aux 
used corresponding pthread 	aux buf 
cond wait 	len fmt 
calls signal waiters 	cpy staticbuf 
doubly important 	buflen 
implementation requires pthread 	fmt fmt 
cond broadcast 	initlen next 
called mutex held 	str num 
used corresponding 	unum buf 
pthread cond 	buf cset 
wait calls wake 	start 
waiters point 	end len 
waiters one takes 	start end 
slice semaphor 	newlen len 
turn wait since 	minlen cmp 
external mutex 	len sep 
held cond wait 	seplen 
yet reason 	count tokens 
sure gets chance 	newtokens tokens 
eat one 	count len 
slice otoh means 	line argc 
last waiter 	current vector 
must send wake 	inq 
since external 	insq done 
mutex held enter 	setlen argv 
cond wait 	argc sep 
hence safe reset 	argv argc 
flag without 	sep seplen 
cond waiters 	size 
held pthread.h cond 	ptr size 
unused cond 	ptr oldfree 
cond mutex cond 	oldlen type 
cond unused 	sds req 
start routine arg 	type sds 
ptr ret 	hdr 
keyp destructor key 	size malloc 
key key 	memset sds 
exit tls alloc 	hdr sds 
tls free 	hdr sds 
tls tls header 	hdr sds 
used adapt 	hdr 
pthread posix code 	memcpy sdsnewlen 
windows api 	strlen sdsnewlen 
threads copyright andrzej 	sdsnewlen sdslen 
haczewski ahaczewski 	free sds 
gmail defines adapt 	hdr size 
windows api 	strlen 
threads pthreads 	sdssetlen sdssetlen 
api implement simple 	sdsavail sdslen 
condition variable 	sds hdr 
windows threads ace 	size sds 
implementation see 	req type 
original implementation http 	sds 
bit djo 	hdr size 
ace homepage http 	realloc malloc 
www cse 	memcpy free 
wustl edu schmidt 	sdssetlen sdssetalloc 
ace html 	sdslen sds 
see also http 	hdr 
www cse 	size sds 
wustl edu schmidt 	req type 
win html 	sds hdr 
simple creation implementation 	size realloc 
pthread api 	malloc memcpy 
avoid need copying 	free 
use small 	sdssetlen sdssetalloc 
macro wrapper 	sdsalloc sds 
pass pointer win 	hdr size 
pthread instead 	sds hdr 
pthread pull.c opt 	size sds 
arg unset 	type 
pull usage opt 	len sds 
verbosity opt 	hdr sds 
progress opt diffstat 	hdr sds 
opt log 	hdr sds 
opt squash opt 	hdr sdslen 
commit opt 	sds 
edit opt opt 	make room 
verify signatures 	memset sdssetlen 
opt strategies opt 	sdslen sds 
strategy opts 	make room 
opt gpg sign 	memcpy sdssetlen 
opt opt 	sdscatlen 
append opt 	strlen sdscatlen 
upload pack opt 	sdslen sdsalloc 
force opt 	sds make 
tags opt prune 	room sdslen 
opt recurse 	memcpy sdssetlen 
submodules max children 	sdscpylen 
opt dry 	strlen sdsll 
run opt keep 	str sdsnewlen 
opt depth 	strlen malloc 
opt unshallow opt 	copy vsnprintf 
update shallow 	end free 
opt refmap pull 	malloc 
options arr 	sdscat free 
verbosity arr force 	start sdscatvprintf 
argc argv 	end sdslen 
msg prefix rev 	start sdsavail 
info result 	sds make 
prefix rev info 	room 
result prefix 	arg strlen 
file die 	sdslen sdsavail 
merge heads filename 	sds make 
sha remote 	room memcpy 
data remote name 	sdsinclen arg 
repo refspecs 	sdsll 
curr branch remote 	str sdsavail 
remote name 	sds make 
argc argv repo 	room memcpy 
refspecs repo 	sdsinclen sdsull 
refspecs args ret 	str sdsavail 
merge head 	sds 
curr head ret 	make room 
args remote 	memcpy sdsinclen 
curr branch curr 	sdsinclen sdsinclen 
branch remote 	end sdslen 
remote refspec spec 	strchr strchr 
spec src 	memmove 
merge branch fork 	sdssetlen sdslen 
point repo 	memmove sdssetlen 
refspec ret 	sdslen tolower 
curr branch remote 	sdslen toupper 
branch merge 	sdslen sdslen 
curr head merge 	memcmp 
head fork 	malloc realloc 
point result curr 	memcmp sdsnewlen 
head merge 	sdsnewlen sdsfree 
head fork point 	free sdsfree 
ret oct 	free sdscatlen 
merge args argc 	sdscatprintf 
argv prefix 	sdscatlen sdscatlen 
repo refspecs merge 	sdscatlen sdscatlen 
heads orig 	sdscatlen isprint 
head curr head 	sdscatprintf sdscatprintf 
rebase fork 	sdscatlen isspace 
point autostash die 	sdsempty 
error parse 	hex digit 
config rebase argv 	hex digit 
push argv 	hex digit 
push argv 	hex digit 
push strbuf addch 	sdscatlen sdscatlen 
strbuf addstr 	isspace 
setenv strbuf release 	sdscatlen sdscatlen 
git config 	isspace sdscatlen 
git config maybe 	sdscatlen realloc 
strcmp die 	malloc sdsfree 
git config parse 	free sdsfree 
config rebase 	sdslen 
init revisions diff 	sdsempty sdscat 
opt diff 	sdscat sdsempty 
opt diff setup 	sdscatsds sdscatlen 
done run 	malloc realloc 
diff files diff 	free sdsnew 
result code 	sdsfree 
cache unborn init 	sdsnewlen sdscat 
revisions diff 	test cond 
opt diff 	sdslen memcmp 
opt head pending 	sdscpy sdscpy 
diff setup 	sdsfree sdscatprintf 
done run diff 	sdsempty 
index diff 	sdsfree sdsnew 
result code xcalloc 	sdscatfmt sdsfree 
hold locked 	sdsnew sdscatfmt 
index refresh cache 	sdsfree sdsnew 
update index 	sdstrim sdsfree 
able rollback file 	sdsnew 
unstaged changes 	sdstrim sdsfree 
error uncommitted changes 	sdsnew sdstrim 
error error 	sdsdup sdsrange 
exit git path 	sdsfree sdsdup 
fopen die 	sdsrange sdsfree 
errno strbuf getline 	sdsdup 
sha hex 	sdsrange sdsfree 
starts sha append 	sdsdup sdsrange 
fclose strbuf 	sdsfree sdsdup 
release branch 	sdsrange sdsfree 
strcmp remote exit 	sdsdup sdsrange 
argv pushl 	sdsfree 
argv push verbosity 	sdsfree sdsnew 
argv push 	sdsnew sdsfree 
argv push argv 	sdsfree sdsnew 
push argv 	sdsnew sdsfree 
push argv push 	sdsfree sdsnew 
force argv 	sdsnew 
push argv push 	sdsfree sdsfree 
argv push 	sdsnewlen sdscatrepr 
argv push argv 	sdsempty sdslen 
push argv 	sdsfree sdsfree 
push argv push 	sdsnew test 
argv push 	cond 
argv push argv 	sdslen sdsavail 
push argv 	sdslen sds 
push argv pushv 	make room 
die run 	test cond 
command opt 	sdslen test 
argv clear checkout 	cond 
fast forward 	sdsavail sdsavail 
update argv pushl 	sds incr 
argv push 	len test 
verbosity argv push 	cond memcmp 
argv push 	test cond 
argv push argv 	sdslen 
push argv 	sdsfree sds 
push argv push 	test sds 
argv push 	lib library 
argv push argv 	copyright salvatore 
pushv argv 	sanfilippo antirez 
pushv argv push 	gmail 
argv push 	dot copyright 
run command opt 	oran agra 
argv clear 	copyright redis 
remote branch remote 	labs inc 
branch strcmp 	rights reserved 
branch upstream 	redistribution 
parse fetch refspec 	use source 
strcmp skip 	binary forms 
prefix skip prefix 	without modification 
starts starts 	permitted provided 
starts strcmp mkpath 	following conditions 
mkpath free 	met 
refspec branch tracking 	redistributions source 
branch upstream 	code must 
branch argv pushl 	retain copyright 
capture command 	notice list 
sha hex strbuf 	conditions following 
release commit 	disclaimer 
list insert lookup 	redistributions binary 
commit reference 	form must 
commit list insert 	reproduce copyright 
lookup commit 	notice list 
reference sha 	conditions following 
commit list insert 	disclaimer 
lookup commit 	documentation materials 
reference reduce heads 	provided distribution 
octopus merge 	neither name 
bases free commit 	redis names 
list hashcpy 	contributors may 
octopus merge sha 	used 
hashcmp argv 	endorse promote 
push argv push 	products derived 
verbosity argv 	software without 
push argv push 	specific prior 
argv push 	written permission 
argv pushv argv 	software 
pushv argv 	provided copyright 
push argv push 	holders contributors 
argv push 	express implied 
sha hex sha 	warranties including 
argv push 	limited implied 
sha hex 	warranties 
argv push sha 	merchantability fitness 
hex run 	particular purpose 
command opt argv 	disclaimed shall 
clear getenv 	copyright owner 
reflog message parse 	contributors liable 
options parse 	direct 
repo refspecs xstrdup 	indirect incidental 
config config 	special exemplary 
rebase git config 	consequential damages 
read cache 	including limited 
unmerged die resolve 	procurement substitute 
conflict file 	goods 
exists git path 	services loss 
die conclude 	use data 
merge sha hashclr 	profits business 
sha cache 	interruption however 
unborn die git 	caused theory 
config die 	liability 
unclean work 	whether contract 
rebase fork point 	strict liability 
hashclr run 	tort including 
fetch sha hashclr 	negligence otherwise 
sha sha 	arising way 
hashcmp warning sha 	use 
hex checkout 	software even 
fast forward die 	advised possibility 
sha hex 	damage create 
merge heads die 	sds content 
merge candidates 	specified init 
sha die pull 	pointer 
die run 	initlen used 
rebase run merge 	init initialized 
builtin git 	zero bytes 
pull git pull 	always termined 
junio hamano 	sds always 
fetch one remote 	even 
refs merge 	create sds 
current head 	mystring sdsnewlen 
parses rebase returns 	abc print 
rebase returns 	end however 
rebase preserve returns 	binary safe 
rebase preserve 	contain 
invalid dies fatal 	characters middle 
error fatal 	length stored 
otherwise returns rebase 	sds header 
invalid callback 	empty usually 
rebase parses arg 	created order 
parse config 	append 
rebase shared options 	use type 
options passed 	since type 
git merge git 	good flags 
rebase options 	pointer create 
passed git fetch 	empty zero 
shared options 	length 
options passed git 	sds even 
merge git 	always term 
rebase options 	create sds 
passed git fetch 	starting terminated 
pushes switches 	duplicate sds 
arr match opt 	free 
verbosity level 	sds operation 
pushes switches arr 	performed sds 
match opt 	length length 
force level sets 	obtained strlen 
git reflog 	considering content 
action environment variable 	first 
concatenation argv 	term character 
pull unset returns 	function useful 
pull returns 	sds hacked 
pull returns pull 	manually way 
returns otherwise 	like following 
pull invalid die 	example 
error returns 	sdsnew foobar 
configured rebase 	sdsupdatelen sdslen 
first looks branch 	output comment 
curr branch 	call sdsupdatelen 
rebase curr branch 	output modified 
current branch 	logical 
head detached configuration 	length remains 
key exist 	bytes modify 
looks pull rebase 	sds place 
configuration keys 	make empty 
exist returns rebase 	zero length 
returns unstaged 	however 
changes otherwise returns 	existing buffer 
uncommitted changes 	discarded free 
otherwise work unstaged 	space next 
uncommitted changes 	append operations 
dies appropriate message 	require allocations 
appends merge 	number 
candidates fetch head 	bytes previously 
marked merge 	available enlarge 
merge heads 	free space 
invalid line start 	end sds 
sha merge 	caller sure 
used die merge 	calling 
candidates remote 	function overwrite 
callback retrieve name 	addlen bytes 
remote repository 	end plus 
one remote dies 	one nul 
appropriate reason 	term note 
merge candidates fetched 	change 
specific remote 	length sds 
refspec given ended 	returned sdslen 
fetching anything 	free buffer 
usually user provided 	space asap 
wildcard refspec 	enough space 
matches remote end 	left 
fetched non 	use type 
remote didn specify 	user appending 
branch merge 	type able 
use configured 	remember empty 
one applies remote 	space sds 
thus user 	make 
must specify branches 	room must 
merge fetched 	called every 
branch repo remote 	appending operation 
branch never 	since header 
configured branch merge 	size changes 
branch configured 	need 
branch merge fetched 	move forward 
branch repo 	use realloc 
remote configured branch 	reallocate sds 
merge didn 	free space 
fetched either doesn 	end 
exist wasn 	contained remains 
part configured fetch 	altered next 
refspec parses 	concatenation operations 
argv repo refspecs 	require reallocation 
returning values 	call passed 
repo refspecs 	sds 
terminated repo provided 	longer valid 
argv runs 	references must 
git fetch returning 	substituted pointer 
exit status 	returned call 
repo refspecs repository 	total size 
refspecs fetch 	allocation 
provided shared options 	specifed sds 
options passed 	including sds 
git fetch pulls 	header pointer 
branching merge 	free buffer 
head two way 	end term 
merge treat 	pointer 
index empty fast 	actual sds 
forward head 	allocation normally 
ensures lose index 	sds referenced 
worktree changes 	start buffer 
user already 	increment sds 
made unborn branch 	length 
runs git 	decrements left 
merge returning exit 	free space 
status shared 	end according 
options options passed 	incr also 
git merge 	term end 
returns remote upstream 	function 
branch current 	used order 
branch remote current 	fix length 
branch configured 	user calls 
remote used returns 	sds make 
remote name 	room writes 
valid remote head 	something 
point branch 	end current 
remote branch configured 	needs length 
remote branch 	note possible 
configured upstream branch 	use negative 
derives remote 	increment order 
tracking branch 	right 
remote refspec fixme 	trim usage 
current implementation 	example sds 
assumes mapping refs 	incr len 
heads branch 	sds make 
name refs remotes 	room possible 
remote name 	mount 
branch name given 	following schema 
repo refspecs 	cat bytes 
sets fork point 	coming kernel 
point current 	end sds 
branch forked remote 	without copying 
tracking branch 	intermediate 
returns success failure 	buffer oldlen 
sets merge 	sdslen sds 
octopus merge curr 	make room 
head merge 	buffer size 
head fork point 	nread read 
returns merge 	oldlen 
found otherwise 	buffer size 
given current head 	check nread 
sha merge 	handle sds 
head returned git 	incr len 
fetch fork 	nread avoid 
point calculated rebase 	compilation 
fork point 	warnings grow 
runs git rebase 	sds specified 
appropriate arguments 	length bytes 
returns exit status 	part original 
shared options 	length sds 
options passed git 	zero 
rebase fetch 	specified length 
involved updating current 	smaller current 
branch working 	length operation 
index file still 	performed make 
orig head 	sure added 
commit merging curr 	region 
head update 	doesn contain 
working match 	garbage also 
curr head push.c 	trailing append 
push usage 	specified binary 
thin deleterefs receivepack 	safe pointed 
verbosity progress 	len 
recurse submodules cas 	bytes end 
refspec refspec 	specified sds 
refspec alloc remote 	call passed 
local refs 	sds longer 
matched query buf 	valid references 
branch buf 	must 
refs repo remote 	substituted pointer 
local refs 	returned call 
tagref delref remote 	append specified 
url branch 	termianted sds 
remote advice maybe 	call passed 
upstream message 	sds 
detached head 	longer valid 
die remote branch 	references must 
triangular simple 	substituted pointer 
refspec remote branch 	returned call 
remote fetch 	append specified 
remote remote branch 	sds 
triangular message 	existing sds 
advice pull push 	call modified 
message advice 	sds longer 
checkout pull push 	valid references 
message advice 	must substituted 
fetch first message 	pointer 
advice already 	returned call 
exists message advice 	destructively modify 
needs force 	sds hold 
transport flags err 	specified binary 
reject reasons 	safe pointed 
repo flags errs 	length 
remote url 	len bytes 
url transport 	like sdscpylen 
transport opt arg 	must termined 
unset recurse 	length obtained 
submodules flags flags 	strlen helper 
status argc 	sdscatlonglong 
argv prefix flags 	actual number 
tags push 	conversion must 
cert repo options 	point room 
alloc grow 	least sds 
count refspec match 	llstr size 
memset query 	bytes 
refspecs strbuf addf 	function returns 
strbuf detach 	length terminated 
starts branch strbuf 	representation stored 
addf strbuf 	generate representation 
detach strcmp die 	method produces 
strbuf addf 	reversed 
strbuf addf strbuf 	compute length 
detach strchr 	term reverse 
die strbuf 	identical sdsll 
addf strbuf detach 	str type 
strchr remote 	generate representation 
local heads map 	method 
refspec refspec 	produces reversed 
skip prefix die 	compute length 
die die 	term reverse 
die die strcmp 	create sds 
die push 	much faster 
simple strbuf addf 	sdscatprintf 
refspec die 	sdsempty lld 
refspec remote branch 	like sdscatprintf 
workflow triangular 	gets list 
refspec setup push 	instead variadic 
current setup 	start buffer 
push upstream setup 	speed 
push upstream 	possible revert 
setup push current 	heap allocation 
die advise 	buffers two 
advise advise 	times bigger 
advise advise transport 	every time 
verbosity transport 	fail 
option transport option 	fit current 
empty cas 	buffer size 
die transport push 	concat obtained 
error transport 	sds append 
disconnect advise pull 	sds obtained 
push advise 	alike 
checkout pull push 	format specifier 
advise already 	call modified 
exists advise fetch 	sds longer 
first advise 	valid references 
needs force pushremote 	must substituted 
die die 	pointer 
strcmp error error 	returned call 
strcmp error 	example sdsnew 
error error setup 	sum sdscatprintf 
push refspecs 	often need 
push url 	create scratch 
remote transport push 	alike 
options transport 	format need 
push options parse 	use sdsempty 
push recurse 	target sdscatprintf 
submodules arg die 	sdsempty format 
git gpg 	args function 
config strcmp git 	similar 
config strcmp 	sdscatprintf much 
git config git 	faster rely 
config maybe 	sprintf family 
push cert flags 	functions implemented 
push cert 	libc often 
flags strcasecmp push 	slow 
cert flags 	moreover directly 
error strcmp git 	handling sds 
config parse 	data concatenated 
push recurse 	provides performance 
submodules arg git 	improvement however 
config packet 	function 
trace identity git 	handles incompatible 
config parse 	subset alike 
options push cert 	format specifiers 
flags die 	sds bit 
die refspec refspecs 	integer bit 
push usage 	integer 
options git push 	verbatim character 
uniquely name 	next format 
lazily grab remote 	specifier process 
local refs 	position next 
point shorten unambiguous 	write dest 
ambiguity would 	str 
remote side locally 	make sure 
plus supposed 	always space 
simple mode user 	least handle 
something crazy 	generally unknown 
like setting 	term part 
upstream non branch 	left 
probably showing 	right composed 
big ugly fully 	contiguous characters 
qualified show 	found cset 
advice people explicitly 	terminted call 
push additional 	modified sds 
safety repository qsort.c 	longer 
cmp tmp 	valid references 
cmp size buf 	must substituted 
tmp msort 	pointer returned 
tmp msort tmp 	call example 
cmp memcpy 	sdsnew hello 
memcpy memcpy memcpy 	world 
mult msort 	sdstrim output 
tmp xmalloc msort 	hello world 
tmp free 	turn smaller 
merge sort implementation 	equal containing 
simplified qsort 	substring specified 
implementation mike 	start 
haertel part gnu 	end indexes 
library temporary 	start end 
fits small stack 	negative means 
buffer somewhat 	last character 
large malloc quote.c 	penultimate character 
quote path 	forth 
fully dst src 	interval inclusive 
free len 	start end 
dst argv maxlen 	characters part 
arg next 	resulting modified 
dst src arg 	place example 
arg argv 	sdsnew 
alloc next dequoted 	hello world 
arg argv 	sdsrange ello 
alloc arg lookup 	world apply 
maxlen len 	tolower every 
name maxlen len 	character sds 
count name 	apply 
nodq prefix 	toupper every 
path nodq name 	character sds 
terminator name 	compare two 
prefix terminator prefix 	sds memcmp 
rel quoted 	positive negative 
endp len src 	exactly 
src src 	binary two 
strbuf detach strbuf 	share exactly 
addch strcspn 	prefix one 
strbuf need quote 	two additional 
strbuf addstr 	characters longer 
strbuf addch strbuf 	considered 
addch strbuf 	greater smaller 
addch free strbuf 	one split 
grow strbuf 	separator sep 
addch quote buf 	sds returned 
die need 	count reference 
quote isspace 	number 
isspace dequote step 	tokens returned 
dequote step 	memory zero 
alloc grow argv 	length zero 
push dequote 	length separator 
argv dequote argv 	returned note 
must quote 	sep 
must quote next 	able split 
quote pos 	multi character 
emit emitbuf emit 	separator example 
emit emit 	sdssplit foo 
emit emit emitbuf 	bar two 
emit quote 	elements 
style counted quote 	foo bar 
style quote 	version function 
style strbuf addch 	binary safe 
quote style 	requires length 
quote style strbuf 	arguments sdssplit 
addch strbuf 	function 
addstr strbuf 	zero terminated 
addstr quote style 	make sure 
fputs fputc 	room next 
relative path write 	element one 
name quoted 	search separator 
strbuf release relative 	skip 
path strbuf 	separator element 
reset quote style 	sure room 
counted strlen 	tokens free 
strbuf release strcspn 	result returned 
strbuf strbuf 	sdssplitlen nothing 
addch strbuf setlen 	tokens 
strbuf addch 	append sds 
strbuf addch strbuf 	escaped representation 
addch strbuf 	non printable 
addch strbuf addch 	characters tested 
strbuf addch 	isprint turned 
strbuf addch strbuf 	escapes 
addch strbuf 	form hex 
addch strbuf 	number call 
addch strbuf addch 	modified sds 
strbuf addch 	longer valid 
strbuf addch strbuf 	references must 
addstr strbuf 	substituted 
addstr strbuf addstr 	pointer returned 
strbuf addstr 	call helper 
strbuf addstr strbuf 	function sdssplitargs 
addch help 	returns non 
copy thing properly 	zero valid 
quoted shell 	hex 
safety single quote 	digit helper 
replaced exclamation 	function sdssplitargs 
point replaced whole 	converts hex 
thing enclosed 	digit integer 
single quote pair 	split line 
original quote 	arguments 
result name name 	every argument 
name copy 	following programming 
destination buffer 	language repl 
stepped fallthrough means 	alike form 
quote octal 	foo bar 
means quote octal 	newline 
quote path 	supported xff 
fully means never 	otherstuff number 
quote quote 	arguments stored 
returns longest prefix 	argc sds 
needing quote 	returned caller 
maxlen positive stops 	free 
first marked 	resulting sds 
character needing escape 	sdsfreesplitres note 
style name 	sdscatrepr able 
quoting inspect input 	convert back 
name counts 	quoted format 
number bytes needed 	sdssplitargs 
hold style 	able parse 
quoted version 	function returns 
name counting quotes 	allocated tokens 
around terminating 	success even 
nul returns however 	input empty 
name need 	input 
style quoting returns 	contains unbalanced 
emits style 	quotes closed 
quoted version name 	quotes followed 
enclosed quotes 	non space 
asked needed ending 	characters foo 
quote needed 	bar 
quote path relative 	foo skip 
given prefix 	blanks token 
style name unquoting 	quotes single 
quoted point 	quotes closing 
opening quote returns 	quote must 
able unquote 	followed 
properly appends result 	space nothing 
strbuf returns 	unterminated quotes 
error doesn 	closing quote 
touch strbuf though 	must followed 
note function 	space nothing 
allocate memory strbuf 	unterminated 
calling strbuf 	quotes token 
release mandatory whichever 	vector even 
result unquote 	empty input 
style returns updates 	something modify 
endp pointer 	substituting occurrences 
point one past 	characters 
ending quote 	specified corresponding 
given verbatim octal 	character instance 
values first 	sdsmapchars mystring 
digit overflow quoting 	effect turning 
languages quote.h 	hello ell 
strbuf src strbuf 	function 
argv maxlen 	returns sds 
arg argv alloc 	pointer always 
arg argv 	input pointer 
strbuf quoted 	since resize 
endp name strbuf 	needed specified 
strbuf name 	separator 
terminator name prefix 	also returns 
terminator prefix 	result sds 
src src src 	like sdsjoin 
help copy 	joins sds 
thing properly quoted 	wrappers allocators 
shell safety 	used 
single quote replaced 	sds note 
exclamation point 	sds actually 
replaced whole thing 	use macros 
enclosed single 	defined sdsalloc 
quote pair example 	order avoid 
passing result 	pay 
system argument sprintf 	overhead function 
cmd foobar 	calls define 
quote arg quote 	wrappers programs 
arg would 	sds linked 
appropriate system 	want touch 
going call ssh 	sds 
run command 	internals even 
side sprintf cmd 	use different 
git diff 	allocator run 
quote arg quote 	test times 
arg sprintf 	order hit 
rcmd ssh quote 	first 
host quote 	two sds 
cmd note examples 	header types 
leak memory 	sds lib 
remember free result 	library copyright 
quote real 	salvatore sanfilippo 
application quote buf 	antirez 
writes existing 	gmail dot 
buffer specified size 	copyright oran 
number characters 	agra copyright 
would written excluding 	redis labs 
regardless buffer 	inc rights 
size unwraps 	reserved 
quote produces place 	redistribution use 
returns input 	source binary 
look like quote 	forms without 
would produced 	modification permitted 
used unwrap many 	provided following 
arguments separated 	conditions 
space like quote 	met redistributions 
works place 	source code 
modifying arg appending 	must retain 
pointers argv 	copyright notice 
store unquoted argv 	list conditions 
still modify 	following 
arg place unlike 	disclaimer redistributions 
dequote argv 	binary form 
argv duplicate take 	must reproduce 
ownership quote 	copyright notice 
path relative 	list conditions 
given prefix quoting 	following 
languages reachable.c 	disclaimer documentation 
progress count path 	materials provided 
oid flag 	distribution neither 
data revs obj 	name redis 
name data 	names 
data revs timestamp 	contributors may 
sha mtime 	used endorse 
data obj sha 	promote products 
path data 	derived software 
obj sha pos 	without specific 
data obj 	prior 
revs timestamp data 	written permission 
revs mark 	software provided 
reflog mark recent 	copyright holders 
progress display 	contributors express 
progress warning parse 	implied warranties 
die pending 	including 
update progress 	limited implied 
mark sha info 	warranties merchantability 
die sha 	fitness particular 
hex parse die 	purpose disclaimed 
lookup lookup 	shall copyright 
blob die sha 	owner 
hex die 	contributors liable 
sha hex pending 	direct indirect 
lookup stat 	incidental special 
error sha hex 	exemplary consequential 
strerror recent 	damages including 
lookup recent loose 	limited 
packed index 	procurement substitute 
objects pending head 	goods services 
reflogs pending 	loss use 
prepare revision walk 	data profits 
die traverse 	business interruption 
commit list unseen 	however 
recent objects 	caused theory 
traversal die 	liability whether 
prepare revision walk 	contract strict 
die traverse 	liability tort 
commit list display 	including negligence 
progress traversal 	otherwise 
already marked seen 	arising way 
need handle 	use software 
progress reporting want 	even advised 
call parse 	possibility damage 
inflating blobs trees 	create sds 
could expensive 	content 
however need know 	specified init 
correct type 	pointer initlen 
later processing revision 	used init 
machinery expects 	initialized zero 
commits tags parsed 	bytes always 
went away 	termined 
iteration could due 	sds always 
simultaneous repack 	even create 
anything abort 	sds mystring 
since might fail 	sdsnewlen abc 
mark objects 	print end 
pruned revision parsing 	however 
mark interested 	binary safe 
types commits refs 	contain characters 
index file 	middle length 
external refs detached 	stored sds 
head included 	header empty 
list reflog info 	usually 
revision walk 	created order 
move commits pending 	append use 
list commit 	type since 
walking list reachable.h 	type good 
revs timestamp 	flags pointer 
revs mark reflog 	create 
mark recent 	empty zero 
progress read-cache.c 	length sds 
options index alternate 	even always 
index output 	term create 
istate istate old 	sds starting 
istate name 	terminated 
namelen changed match 	duplicate sds 
sha expected 	free sds 
size match buffer 	operation performed 
size sha 	sds length 
changed istate istate 	length obtained 
istate istate 	strlen 
options changed ignore 	considering content 
valid ignore 	first term 
skip worktree racy 	character function 
modified istate 	useful sds 
options changed changed 	hacked manually 
name len 	way 
mode name len 	like following 
mode len 	example sdsnew 
cmp name 	foobar sdsupdatelen 
len mode name 	sdslen output 
len mode 	comment call 
cmp name len 	sdsupdatelen 
name len 	output modified 
min len cmp 	logical length 
name len 	remains bytes 
stage name len 	modify sds 
stage cmp 	place make 
istate name namelen 	empty 
stage first 	zero length 
last next cmp 	however existing 
istate name 	buffer discarded 
namelen istate pos 	free space 
istate istate 	next append 
path pos path 	operations 
namelen istate 	require allocations 
path namelen pos 	number bytes 
len istate 	previously available 
len sha 	enlarge free 
istate path flags 	space end 
size namelen 	sds 
mode option verbose 	caller sure 
pretend intent 	calling function 
option ent pos 	overwrite addlen 
istate path 	bytes end 
flags mode sha 	plus one 
path stage 	nul 
refresh options size 	term note 
len ret 	change length 
len rest path 	sds returned 
istate pos 	sdslen free 
replace retval len 	buffer space 
stage name 	asap 
istate pos replace 	enough space 
retval stage 	left use 
name slash len 	type user 
istate pos 	appending type 
replace retval 	able remember 
istate option pos 	empty 
replace skip 	space sds 
check istate option 	make room 
pos ret 	must called 
istate options err 	every appending 
changed ret 	operation since 
updated changed size 	header 
refresh ignore 	size changes 
valid ignore skip 	need move 
worktree ignore 	forward use 
missing fmt name 	realloc reallocate 
porcelain first 	sds free 
header msg istate 	space 
flags pathspec 	end contained 
seen header msg 	remains altered 
errors really 	next concatenation 
allow unmerged quiet 	operations require 
ignore submodules 	reallocation call 
first porcelain 	passed 
options modified fmt 	sds longer 
deleted fmt 	valid references 
typechange fmt added 	must substituted 
fmt unmerged 	pointer returned 
fmt cache errno 	call total 
changed filtered 	size 
fmt options envversion 	allocation specifed 
endp version 	sds including 
ctime mtime dev 	sds header 
ino mode 	pointer free 
uid gid size 	buffer end 
sha flags 	term 
name ctime mtime 	pointer actual 
dev ino 	sds allocation 
mode uid gid 	normally sds 
size sha 	referenced start 
flags flags 	buffer increment 
name hdr size 	sds 
sha hdr 	length decrements 
version istate ext 	left free 
data die 	space end 
error istate ondisk 	according incr 
flags name 	also term 
len name len 	end 
ondisk ent 	function used 
size previous name 	order fix 
len name 	length user 
flags ondisk extended 	calls sds 
flags consumed 	make room 
istate next name 	writes 
compare istate 	something end 
istate istate path 	current needs 
must exist 	length note 
src offset hdr 	possible use 
mmap mmap 	negative increment 
size previous 	order 
name disk consumed 	right trim 
extsize istate 	usage example 
path split index 	sds incr 
ret istate 	len sds 
istate istate write 	make room 
buffer write 	possible 
buffer len context 	mount following 
buffered context 	schema cat 
data len buffered 	bytes coming 
context ext 	kernel end 
context sha left 	sds without 
ondisk flags 	copying 
ondisk previous name 	intermediate buffer 
size ondisk 	oldlen sdslen 
saved namelen name 	sds make 
result common 	room buffer 
prefix size istate 	size nread 
path sha 	read 
istate istate 	oldlen buffer 
entries istate lockfile 	size check 
istate newfd 	nread handle 
strip extensions hdr 	sds incr 
err removed 	len nread 
extended hdr version 	avoid 
cache entries 	compilation warnings 
previous name msg 	grow sds 
allow name 	specified length 
istate flags ret 	bytes part 
istate flags 	original length 
ret temporary sharedindex 	sds 
istate flags 	zero specified 
ret istate flags 	length smaller 
ret istate 	current length 
unmerged size len 	operation performed 
istate name 	make sure 
namelen pos istate 	added 
path size 	region doesn 
pos len 	contain garbage 
data path name 	also trailing 
hash replace 	append specified 
index entry name 	binary safe 
hash free 	pointed 
index entry strlen 	len bytes 
xmalloc cache 	end specified 
entry size copy 	sds call 
cache entry 	passed sds 
memcpy cache invalidate 	longer valid 
path untracked 	references 
cache index index 	must substituted 
entry index 	pointer returned 
entry ctime nsec 	call append 
mtime nsec 	specified termianted 
mtime nsec ctime 	sds call 
nsec fill 	passed 
stat data 	sds longer 
isreg mark uptodate 	valid references 
open index 	must substituted 
hashcmp strbuf readlink 	pointer returned 
read sha 	call append 
file memcmp free 	specified 
strbuf release 	sds existing 
resolve gitlink hashcmp 	sds call 
compare data 	modified sds 
compare link xsize 	longer valid 
isgitlink compare 	references must 
gitlink isreg islnk 	substituted 
isreg isdir 	pointer returned 
compare gitlink die 	call destructively 
match stat 	modify sds 
data empty blob 	hold specified 
sha isgitlink 	binary safe 
racy stat racy 	pointed 
stat match 	length len 
stat data 	bytes like 
skip worktree intent 	sdscpylen must 
match stat 	termined length 
basic racy timestamp 	obtained strlen 
modified check 	helper 
match stat isgitlink 	sdscatlonglong actual 
modified check 	number conversion 
memcmp isdir isdir 	must point 
memcmp isdir 	room least 
isdir memcmp name 	sds llstr 
compare cache 	size 
name stage compare 	bytes function 
namelen stage 	returns length 
index name stage 	terminated representation 
pos record 	stored generate 
resolve undo name 	representation method 
hash save 	produces 
free index entry 	reversed compute 
memmove name 	length term 
hash save 	reverse identical 
free index entry 	sdsll str 
index name 	type generate 
pos strlen cache 	representation 
invalidate path 	method produces 
untracked cache index 	reversed compute 
strcmp index 	length term 
entry namelen memcmp 	reverse create 
index name 	sds much 
pos compare name 	faster 
stage stage 	sdscatprintf sdsempty 
compare name namelen 	lld like 
namelen memcmp 	sdscatprintf gets 
die namelen xcalloc 	list instead 
cache entry 	variadic start 
size memcpy copy 	buffer 
cache entry 	speed possible 
save free index 	revert heap 
entry write 	allocation buffers 
sha file 	two times 
die hashcpy isreg 	bigger every 
islnk isdir 	time 
error strlen isdir 	fail fit 
cache entry 	current buffer 
size xcalloc memcpy 	size concat 
fill stat 	obtained sds 
cache info create 	append sds 
mode index 	obtained 
name pos also 	alike format 
unmerged mode 	specifier call 
stat adjust dirname 	modified sds 
index file 	longer valid 
exists namelen stage 	references must 
match stat 	substituted 
isgitlink mark uptodate 	pointer returned 
free index 	call example 
path free 	sdsnew sum 
error name intent 	sdscatprintf often 
entry different 	need create 
name create stage 	scratch 
hashcmp free 	alike format 
index entry free 	need use 
error lstat 	sdsempty target 
die errno index 	sdscatprintf sdsempty 
verify path 	format args 
error strlen cache 	function 
entry size 	similar sdscatprintf 
xcalloc hashcpy memcpy 	much faster 
create flags 	rely sprintf 
create mode refresh 	family functions 
cache entry 	implemented libc 
free namelen namelen 	often 
memcmp dir 	slow moreover 
sep dir sep 	directly handling 
dos drive 	sds data 
prefix dir 	concatenated provides 
sep hfs dotgit 	performance improvement 
ntfs dotgit 	however 
verify dotfile dir 	function handles 
sep namelen 	incompatible subset 
stage namelen memcmp 	alike format 
stage index 	specifiers sds 
entry stage namelen 	bit integer 
index name 	bit 
stage pos index 	integer verbatim 
entry namelen 	character next 
memcmp stage file 	format specifier 
name dir 	process position 
name cache invalidate 	next write 
path index 	dest 
name stage pos 	str make 
namelen stage 	sure always 
replace index entry 	space least 
untracked cache 	handle generally 
index stage 	unknown term 
name index entry 	part 
verify path 	left right 
error check file 	composed contiguous 
directory conflict 	characters found 
error index name 	cset terminted 
stage pos 	call modified 
namelen stage index 	sds 
entry check 	longer valid 
alloc grow memmove 	references must 
index entry 	substituted pointer 
uptodate skip worktree 	returned call 
mark uptodate 	example sdsnew 
mark uptodate symlink 	hello 
leading path 	world sdstrim 
namelen lstat match 	output hello 
stat isgitlink 	world turn 
mark uptodate modified 	smaller equal 
size xmalloc 	containing substring 
memcpy fill 	specified 
stat cache info 	start end 
isgitlink path 	indexes start 
match stage strcmp 	end negative 
show file 	means last 
refresh cache ent 	character penultimate 
intent show 	character 
file replace index 	forth interval 
entry refresh 	inclusive start 
cache ent getenv 	end characters 
git config 	part resulting 
warning strtoul warning 	modified place 
htonl error 	example 
ntohl error git 	sdsnew hello 
sha init 	world sdsrange 
git sha update 	ello world 
git sha 	apply tolower 
hashcmp error cache 	every character 
ext cache 	sds 
read resolve 	apply toupper 
undo read read 	every character 
link extension 	sds compare 
read untracked extension 	two sds 
error hold 	memcmp positive 
file update index 	negative 
file read 	exactly binary 
index index file 	two share 
xmalloc cache 	exactly prefix 
entry size hashcpy 	one two 
memcpy decode 	additional characters 
varint die strbuf 	longer 
strbuf die 	considered greater 
strlen cache entry 	smaller one 
ondisk ondisk 	split separator 
size expand name 	sep sds 
field cache 	returned count 
entry ondisk 	reference 
strcmp die stage 	number tokens 
die stage 	returned memory 
stage die git 	zero length 
config untracked 	zero length 
cache untracked cache 	separator returned 
untracked cache 	note 
check order tweak 	sep able 
untracked cache 	split multi 
open die errno 	character separator 
fstat die 	example sdssplit 
errno xsize die 	foo bar 
xmmap die 	two 
errno close verify 	elements foo 
hdr hashcpy 	bar version 
ntohl ntohl alloc 	function binary 
xcalloc create 	safe requires 
disk index entry 	length arguments 
strbuf release 	sdssplit 
mtime nsec 	function zero 
memcpy ntohl read 	terminated make 
index extension 	sure room 
munmap munmap die 	next element 
read index 	one search 
sha post read 	separator 
index discard 	skip separator 
index xcalloc read 	element sure 
index git 	room tokens 
path sha hex 	free result 
hashcmp die 	returned 
sha hex git 	sdssplitlen nothing 
path sha 	tokens append 
hex sha hex 	sds escaped 
merge index 	representation non 
post read index 	printable characters 
free resolve 	tested 
undo clear index 	isprint turned 
free name 	escapes form 
hash cache 	hex number 
free free discard 	call modified 
split index 	sds longer 
free untracked cache 	valid 
stage git 	references must 
sha update write 	substituted pointer 
full memcpy 	returned call 
write flush htonl 	helper function 
htonl write 	sdssplitargs returns 
write git sha 	non 
update write 	zero valid 
full git sha 	hex digit 
hashcpy write 	helper function 
full lstat match 	sdssplitargs converts 
stat basic 	hex digit 
modified check htonl 	integer 
htonl htonl 	split line 
htonl htonl htonl 	arguments every 
htonl htonl 	argument following 
htonl htonl 	programming language 
hashcpy namelen namelen 	repl alike 
htons htons 	form 
namelen ondisk size 	foo bar 
xcalloc copy 	newline supported 
cache entry ondisk 	xff otherstuff 
memcpy namelen 	number arguments 
encode varint offsetof 	stored argc 
offsetof namelen 	sds 
xcalloc copy cache 	returned caller 
entry ondisk 	free resulting 
memcpy memcpy namelen 	sds sdsfreesplitres 
strbuf splice 	note sdscatrepr 
namelen write free 	able convert 
open fstat 	back 
pread full hashcmp 	quoted format 
close close 	sdssplitargs able 
verify index 	parse function 
index file racy 	returns allocated 
timestamp racy 	tokens success 
timestamp verify index 	even 
write locked 	input empty 
index rollback file 	input contains 
index format 	unbalanced quotes 
getenv init split 	closed quotes 
index htonl 	followed non 
htonl htonl git 	space 
sha init 	characters foo 
write uptodate racy 	bar foo 
timestamp smudge 	skip blanks 
racily clean entry 	token quotes 
sha git 	single quotes 
env warning error 	closing 
write entry 	quote must 
strbuf release write 	followed space 
link extension 	nothing unterminated 
write index 	quotes closing 
ext header write 	quote must 
strbuf release 	followed 
cache write write 	space nothing 
index ext 	unterminated quotes 
header write strbuf 	token vector 
release resolve 	even empty 
undo write write 	input something 
index ext 	modify 
header write strbuf 	substituting occurrences 
release write 	characters specified 
untracked extension write 	corresponding character 
index ext 	instance sdsmapchars 
header write strbuf 	mystring effect 
release flush 	turning 
fstat mtime nsec 	hello ell 
commit file 	function returns 
commit file write 	sds pointer 
index file 	always input 
commit locked 	pointer since 
index close file 	resize 
prepare write 	needed specified 
split index write 	separator also 
locked index 	returns result 
finish writing split 	sds like 
index mks 	sdsjoin joins 
tempfile git path 	sds 
hashclr write 	wrappers allocators 
locked index move 	used sds 
cache index 	note sds 
write index tempfile 	actually use 
rename tempfile 	macros defined 
git path sha 	sdsalloc 
hex hashcpy 	order avoid 
hashclr write locked 	pay overhead 
index getenv 	function calls 
write shared index 	define wrappers 
write split 	programs sds 
index read 	linked 
index stage namelen 	want touch 
cache entry 	sds internals 
size xcalloc memcpy 	even use 
create flags 	different allocator 
index entry error 	run test 
index name 	times 
pos namelen memcmp 	order hit 
strlen index 	first two 
name pos strcmp 	sds header 
stage read 	types type 
sha file free 	size init 
free stat 	initlen 
isreg match stat 	type hdrlen 
data fstat 	init initlen 
isreg stat validity 	reallen addlen 
clear xcalloc 	newsh avail 
fill stat 	len newlen 
data git information 	type 
manager hell 	oldtype hdrlen 
copyright linus torvalds 	newsh type 
mask name 	oldtype hdrlen 
length flags disk 	len alloc 
index index 	incr flags 
extensions first letter 	len 
extensions necessary 	oldlen len 
correct operation optimization 	curlen len 
data extensions 	curlen len 
added needs understood 	aux aux 
order correctly 	buf len 
interpret index file 	fmt 
pick character 	cpy staticbuf 
outside range cause 	buflen fmt 
reader abort 	fmt initlen 
reuc link untr 	next str 
changes kept 	num unum 
git dir 	buf 
index basically extensions 	buf cset 
dev breaks 	start end 
network filesystems different 	len start 
clients different 	end newlen 
views device filesystem 	len minlen 
updates non 	cmp 
critical parts directory 	len sep 
cache parts 	seplen count 
aren tracked git 	tokens newtokens 
used validate 	tokens count 
cache index closed 	len line 
file descriptor 	argc 
already actually require 	current vector 
git directory 	inq insq 
gitlink directory valid 	done setlen 
git directory 	argv argc 
might even missing 	sep argv 
nobody populated 	argc 
sub project 	sep seplen 
consider always match 	size ptr 
consider owner 	size ptr 
bit relevant mode 	oldfree oldlen 
changes ignore 	type sds 
xxx fields gitlinks 	req 
racily smudged 	type sds 
entry nanosecond timestamped 	hdr size 
files also 	malloc memset 
racy marked always 	sds hdr 
valid index 	sds hdr 
valid whatever copy 	sds 
says skip 	hdr sds 
worktree effect higher 	hdr memcpy 
precedence intent 	sdsnewlen strlen 
entries added index 	sdsnewlen sdsnewlen 
entry definition 	sdslen free 
never matches work 	sds 
actually gets 	hdr size 
added within 	strlen sdssetlen 
second sequence echo 	sdssetlen sdsavail 
xyzzy file 	sdslen sds 
git update index 	hdr size 
file running 	sds 
command echo frotz 	req type 
file would 	sds hdr 
give falsely clean 	size realloc 
cache entry 	malloc memcpy 
mtime length match 	free sdssetlen 
cache stat 	sdssetalloc 
fields change could 	sdslen sds 
detect update 	hdr size 
index time cache 	sds req 
entry registered 	type sds 
updated records time 	hdr size 
delay git 	realloc 
update index would 	malloc memcpy 
effectively mean 	free sdssetlen 
make one 	sdssetalloc sdsalloc 
commit per second 	sds hdr 
acceptable instead 	size sds 
check cache entries 	hdr 
whose mtime 	size sds 
index file timestamp 	type len 
carefully others 	sds hdr 
mode type changed 	sds hdr 
point trying 	sds hdr 
refresh entry going 	sds 
match immediately 	hdr sdslen 
read update index 	sds make 
cacheinfo length 	room memset 
field zero never 	sdssetlen sdslen 
even read 	sds make 
lstat information cannot 	room 
trust data 	memcpy sdssetlen 
changed returned 	sdscatlen strlen 
match stat turn 	sdscatlen sdslen 
returned match 	sdsalloc sds 
stat basic signal 	make room 
filesize blob 	sdslen 
changed actually filesystem 	memcpy sdssetlen 
see contents 	sdscpylen strlen 
match answer unchanged 	sdsll str 
logic apply 	sdsnewlen strlen 
gitlinks match stat 	malloc copy 
basic already 	vsnprintf 
actual head filesystem 	end free 
subproject match 	malloc sdscat 
stat already said 	free start 
different know 	sdscatvprintf end 
name compare identical 	sdslen start 
name compare 	sdsavail 
compares conflicting directory 	sds make 
file entries 	room arg 
equal note 	strlen sdslen 
directory name compares 	sdsavail sds 
equal regular 	make room 
file individually compare 	memcpy 
differently filename 	sdsinclen arg 
dot basename used 	sdsll str 
routines want 	sdsavail sds 
traverse git handle 	make room 
conflicting entries 	memcpy sdsinclen 
together possible directories 	sdsull 
files compare 	str sdsavail 
equal length name 	sds make 
entry entries 	room memcpy 
cache entries marked 	sdsinclen sdsinclen 
removal flags 	sdsinclen end 
much effective calling 	sdslen 
index entry 	strchr strchr 
entry removed maybe 	memmove sdssetlen 
unmerged order 	sdslen memmove 
preference stage 	sdssetlen sdslen 
filename aliases cache 	tolower sdslen 
use name 	toupper 
already want update 	sdslen sdslen 
twice implies 	memcmp malloc 
actually two different 	realloc memcmp 
files aliasing 	sdsnewlen sdsnewlen 
names use added 	sdsfree free 
flag verify 	sdsfree 
old one accept 	free sdscatlen 
create entry 	sdscatprintf sdscatlen 
name existing existing 	sdscatlen sdscatlen 
entry pick 	sdscatlen sdscatlen 
mode bits type 	isprint sdscatprintf 
otherwise unexecutable 	sdscatprintf 
regular file core 	sdscatlen isspace 
ignorecase determine 	sdsempty hex 
directory name differing 	digit hex 
already exists 	digit hex 
within git 	digit hex 
repository ensure directory 	digit 
file added 	sdscatlen sdscatlen 
repository matches folded 	isspace sdscatlen 
existing entry 	sdscatlen isspace 
directory nothing changed 	sdscatlen sdscatlen 
really suspected 	realloc malloc 
racily clean turns 	sdsfree 
fundamentally like 	free sdsfree 
paths want dot 	sdslen sdsempty 
dot dot 	sdscat sdscat 
anywhere obvious reasons 	sdsempty sdscatsds 
want recurse 	sdscatlen malloc 
git either also 	realloc 
want slashes 	free sdsnew 
slashes end make 	sdsfree sdsnewlen 
pathnames ambiguous 	sdscat test 
first character 	cond sdslen 
already discarded test 	memcmp sdscpy 
rest allowed 	sdscpy 
git followed nul 	sdsfree sdscatprintf 
slash bad 	sdsempty sdsfree 
shares path end 	sdsnew sdscatfmt 
test fallthrough 	sdsfree sdsnew 
another file beginning 	sdscatfmt sdsfree 
components proper 	sdsnew 
superset name trying 	sdstrim sdsfree 
another file 	sdsnew sdstrim 
pathname proper subset 	sdsfree sdsnew 
name trying 	sdstrim sdsdup 
found one fast 	sdsrange sdsfree 
could marker 	sdsdup 
says removed entry 	sdsrange sdsfree 
part resulting 	sdsdup sdsrange 
directory path trivial 	sdsfree sdsdup 
optimization find 	sdsrange sdsfree 
entry already 	sdsdup sdsrange 
matches sub directory 	sdsfree 
know exit 	sdsdup sdsrange 
subdirectory stage entry 	sdsfree sdsfree 
subdirectory looking 	sdsnew sdsnew 
cannot conflicts level 	sdsfree sdsfree 
anything shorter 	sdsnew sdsnew 
may situation already 	sdsfree 
path file 	sdsfree sdsnew 
path added already 	sdsnew sdsfree 
path path 	sdsfree sdsnewlen 
file added either 	sdscatrepr sdsempty 
one would 	sdslen sdsfree 
result nonsense path 	sdsfree 
twice git 	sdsnew test 
write tries write 	cond sdslen 
prevent replace 	sdsavail sdslen 
specified conflicting entries 	sds make 
cache caller 	room test 
recompute insert 	cond 
position happens non 	sdslen test 
zero going 	cond sdsavail 
away entry allow 	sdsavail sds 
added check 	incr len 
path sub path 	test cond 
subsequent pathname 	memcmp 
first since removing 	test cond 
change position 	sdslen sdsfree 
check path might 	sds test 
clashing sub 	sds lib 
directory existing match 	library copyright 
replace inserting 	salvatore 
merged entry stage 	sanfilippo antirez 
index always 	gmail dot 
replace non merged 	copyright oran 
entries make 	agra copyright 
sure big enough 	redis labs 
refresh calculate 	inc 
sha file 	rights reserved 
bring cache date 	redistribution use 
mode content 	source binary 
changes match stat 	forms without 
information file 	modification permitted 
cache refresh cache 	provided 
file hasn 	following conditions 
changed stat entry 	met redistributions 
date example 	source code 
want git read 	must retain 
link stat 	copyright notice 
cache details proper 	list 
files valid 	conditions following 
skip worktree means 	disclaimer redistributions 
user promised 	binary form 
change work matter 	must reproduce 
told worry 	copyright notice 
path unchanged 	list 
told ignore valid 	conditions following 
bit actual 	disclaimer documentation 
stat check found 	materials provided 
entry unmodified 	distribution neither 
entry marked valid 	name redis 
place mark 	names 
valid unchanged mode 	contributors may 
mark one 	used endorse 
valid mark index 	promote products 
modified uptodate 	derived software 
flag core going 	without specific 
write change 	prior 
ignore valid valid 	written permission 
bit alone 	software provided 
otherwise paths marked 	copyright holders 
unchanged things 	contributors express 
edited reacquire valid 	implied warranties 
bit automatically 	including 
really want 	limited implied 
istate cache changed 	warranties merchantability 
updated caller 	fitness particular 
really refresh means 	purpose disclaimed 
index valid 	shall copyright 
anymore must checks 	owner 
index file 	contributors liable 
dev ino uid 	direct indirect 
gid size 	incidental special 
also tracked low 	exemplary consequential 
bits strong 	damages including 
practice heuristic inode 	limited 
hasn changed 	procurement substitute 
save fields big 	goods services 
endian order 	loss use 
allow index file 	data profits 
nfs transparently 	business interruption 
used extended bit 	however 
must match 	caused theory 
ondisk cache 	liability whether 
entry exactly ctime 	contract strict 
till flags 	liability tort 
used lower adjacent 	including negligence 
cache entries 	otherwise 
tend share leading 	arising way 
paths makes 	use software 
sense store differences 	even advised 
later entries 	possibility damage 
disk format index 	create sds 
disk cache 	content 
entry stores number 	specified init 
bytes stripped 	pointer initlen 
end previous name 	used init 
bytes append 	initialized zero 
result come name 	bytes always 
find end 	termined 
disk flags bits 	sds always 
yet understand 	even create 
bit extended 	sds mystring 
flags earlier keep 	sdsnewlen abc 
nothing unknown 	print end 
nothing remember discard 	however 
cache reading 	binary safe 
different cache active 	contain characters 
index entries 	middle length 
arbitrary number extended 	stored sds 
sections prefixed 	header empty 
extension name section 	usually 
length network 	created order 
order istate initialized 	append use 
covers git 	type since 
index git sharedindex 	type good 
xxx flush 	flags pointer 
first enough space 	create 
sha signature 	empty zero 
append sha signature 	length sds 
end thing 	even always 
care function 	term create 
smudge falsely clean 	sds 
entry due 	starting terminated 
touch update touch 	duplicate sds 
race everything 	free sds 
called entries whose 	operation performed 
stat data 	sds length 
mtime match index 	length 
file mtime 	obtained strlen 
note actually much 	considering content 
gitlinks match 	first term 
stat basic always 	character function 
goes actual 	useful sds 
contents caller checks 	hacked 
racy timestamp 	manually way 
always says gitlinks 	like following 
called racily 	example sdsnew 
clean smudge 	foobar sdsupdatelen 
note tricky code 	sdslen output 
first glance 	comment 
may appear sequence 	call sdsupdatelen 
echo xyzzy 	output modified 
frotz git update 	logical length 
index frotz 	remains bytes 
frotz sleep echo 	modify sds 
filfre nitfol 	place 
git update index 	make empty 
nitfol second 	zero length 
update index runs 	however existing 
notices entry 	buffer discarded 
frotz timestamp index 	free space 
smudge resetting 	next 
size zero name 	append operations 
recorded index 	require allocations 
file cached stat 	number bytes 
information becomes 	previously available 
zero would 	enlarge free 
match would obtain 	space 
filesystem next 	end sds 
time stat frotz 	caller sure 
however second 	calling function 
update index calling 	overwrite addlen 
function notices 	bytes end 
cached size bytes 	plus 
filesystem empty 	one nul 
file never calls 	term note 
cached size 	change length 
information frotz stays 	sds returned 
match filesystem 	sdslen free 
copy miscellaneous fields 	buffer 
name compiler 	space asap 
workaround still matching 	enough space 
function verifies 	left use 
index state correct 	type user 
sha index 	appending type 
file die 	able 
failure opportunistically update 	remember empty 
index complain 	space sds 
reduce extended entries 	make room 
possible demote 	must called 
version version latter 	every appending 
suffices write 	operation 
extension data read 	since header 
index file 	size changes 
potentially unmerged given 	need move 
index state 	forward use 
dropping unmerged entries 	realloc reallocate 
returns index 	sds 
unmerged callers want 	free space 
refuse work 	end contained 
unmerged state call 	remains altered 
check instead 	next concatenation 
calling read cache 	operations require 
returns path 	reallocation 
path respect 	call passed 
index path mentioned 	sds longer 
index either 	valid references 
file directory files 	must substituted 
index unmerged 	pointer returned 
entry helpfully trailing 	call 
directories output 	total size 
read directory used 	allocation specifed 
exact match 	sds including 
yup one exists 	sds header 
unmerged might 	pointer free 
middle merge would 	buffer 
read stage 	end term 
read-tree.c trees read 	pointer actual 
empty trees 	sds allocation 
sha read usage 	normally sds 
opt arg 	referenced start 
unset opt 	buffer 
arg unset dir 	increment sds 
opts label 	length decrements 
stages buf file 	left free 
argc argv 	space end 
unused prefix stage 	according incr 
sha opts 	also 
prefix read options 	term end 
arg die 	function used 
parse indirect alternate 	order fix 
index output 	length user 
die xcalloc stage 	calls sds 
sha hex 	make 
debug stage xsnprintf 	room writes 
debug stage 	something end 
memset git config 	current needs 
parse options 	length note 
hold locked index 	possible use 
die read 	negative 
cache unmerged 	increment order 
die resolve undo 	right trim 
clear sha 	usage example 
die list die 	sds incr 
warning die 	len sds 
die die die 	make 
setup work 	room possible 
die cache unborn 	mount following 
cache free 	schema cat 
parse init desc 	bytes coming 
unpack trees 	kernel end 
prime cache write 	sds 
locked index 	without copying 
die git information 	intermediate buffer 
manager hell 	oldlen sdslen 
copyright linus torvalds 	sds make 
need want 	room buffer 
read directory merely 	size 
interested reusing 	nread read 
per directory 	oldlen buffer 
ignore stack mechanism 	size check 
needswork old 	nread handle 
index read anyway 	sds incr 
even going 	len 
destroy index entries 	nread avoid 
still need 	compilation warnings 
preserve certain information 	grow sds 
index version 	specified length 
split index mode 	bytes part 
write index 	original 
reading one either 	length sds 
basic form 	zero specified 
ent reset ent 	length smaller 
form obtain 	current length 
fully valid cache 	operation performed 
index must 	make 
match exactly came 	sure added 
receive-pack.c receive 	region doesn 
pack usage 	contain garbage 
deny deletes deny 	also trailing 
non fast 	append specified 
forwards receive fsck 	binary 
objects transfer 	safe pointed 
fsck objects fsck 	len bytes 
msg types 	end specified 
receive unpack limit 	sds call 
transfer unpack 	passed sds 
limit advertise atomic 	longer 
push unpack 	valid references 
limit report status 	must substituted 
use sideband 	pointer returned 
use atomic quiet 	call append 
prefer ofs 	specified termianted 
delta update server 	sds 
info fix 	call passed 
thin stateless 	sds longer 
rpc service dir 	valid references 
head name 	must substituted 
head name free 	pointer returned 
sent capabilities 	call 
shallow update alt 	append specified 
shallow file 	sds existing 
push cert push 	sds call 
cert sha 	modified sds 
sigcheck push cert 	longer valid 
nonce cert 	references 
nonce seed nonce 	must substituted 
unsolicited nonce 	pointer returned 
bad nonce missing 	call destructively 
nonce nonce 	modify sds 
slop nonce status 	hold specified 
nonce stamp 	binary 
slop nonce stamp 	safe pointed 
slop limit 	length len 
transaction status 	bytes like 
path path sha 	sdscpylen must 
cap path 	termined length 
full oid flag 	obtained 
unused path 	strlen helper 
sha unused data 	sdscatlonglong actual 
next error 	number conversion 
index old sha 	must point 
sha name 	room least 
err err prefix 	sds 
err msg 	llstr size 
err err arg 	bytes function 
data key 	returns length 
key len text 	terminated representation 
text len 	stored generate 
key ipad opad 	representation 
ctx path 	method produces 
stamp buf sha 	reversed compute 
msg len 	length term 
key key 	reverse identical 
len line eol 	sdsll str 
offset buf 	type 
len nonce stamp 	generate representation 
ostamp bohmac 	method produces 
expect retval proc 	reversed compute 
already done 	length term 
gpg output gpg 	reverse create 
status bogs 	sds 
hook name feed 	much faster 
feed state 	sdscatprintf sdsempty 
proc muxer argv 	lld like 
code buf 	sdscatprintf gets 
cmd skip broken 	list instead 
buf state 	variadic 
bufp sizep state 	start buffer 
cmd commands 	speed possible 
hook name skip 	revert heap 
broken state 	allocation buffers 
status cmd 	two times 
argv proc code 	bigger 
refuse unconfigured 	every time 
deny msg refuse 	fail fit 
unconfigured deny 	current buffer 
current msg data 	size concat 
sha cmd 	obtained sds 
shallow extra alt 	append 
file mask 	sds obtained 
sha sha env 	alike format 
work update 	specifier call 
refresh diff files 	modified sds 
diff index 	longer valid 
read child push 	references 
checkout hook 	must substituted 
sha env work 	pointer returned 
sha retval 	call example 
work env cmd 	sdsnew sum 
name namespaced 	sdscatprintf often 
name buf 	need 
namespaced name ret 	create scratch 
old sha 	alike format 
sha old old 	need use 
commit commit 	sdsempty target 
err err commands 	sdscatprintf sdsempty 
cmd argc 	format 
proc hook cmd 	args function 
list buf 	similar sdscatprintf 
dst name item 	much faster 
dst cmd 	rely sprintf 
sha cmd oldh 	family functions 
cmd newh 	implemented 
dst oldh dst 	libc often 
newh flag 	slow moreover 
commands cmd list 	directly handling 
item data 	sds data 
sha cmd 	concatenated provides 
list cmd commands 	performance 
cmd singleton 	improvement however 
cmds data sha 	function handles 
data cmd 	incompatible subset 
list cmd commands 	alike format 
refname full 	specifiers sds 
prefix len cmd 	bit 
cmd commands 	integer bit 
cmd connectivity commands 	integer verbatim 
cmd err 	character next 
commands cmd err 	format specifier 
reported error 	process position 
commands unpacker error 	next 
cmd sha 	write dest 
data tail line 	str make 
linelen old 	sure always 
sha sha cmd 	space least 
refname reflen 	handle generally 
tail push 	unknown 
cert boc eoc 	term part 
eol shallow 	left right 
commands line len 	composed contiguous 
linelen sha 	characters found 
feature list flush 	cset terminted 
certbuf hdr 	call 
pack lockfile err 	modified sds 
hdr hdr 	longer valid 
err status hdr 	references must 
arg child 	substituted pointer 
fsck objects hostname 	returned call 
muxer ret 	example 
commands bitmap size 	sdsnew hello 
commands cmd 	world sdstrim 
status commands unpack 	output hello 
status cmd 	world turn 
buf commands cmd 	smaller equal 
argc argv 	containing 
prefix advertise 	substring specified 
refs commands shallow 	start end 
arg unpack 	indexes start 
status argv opt 	end negative 
git config 	means last 
parse hide refs 	character 
config strcmp 	penultimate character 
git config strcmp 	forth interval 
git config 	inclusive start 
strcmp git config 	end characters 
strcmp git 	part resulting 
config strcmp git 	modified 
config pathname 	place example 
strbuf addf free 	sdsnew hello 
skip prefix 	world sdsrange 
valid msg type 	ello world 
strbuf addf 	apply tolower 
warning strcmp git 	every 
config strcmp 	character sds 
git config 	apply toupper 
strcmp parse deny 	every character 
action strcmp 	sds compare 
parse deny action 	two sds 
strcmp git 	memcmp 
config strcmp git 	positive negative 
config strcmp 	exactly binary 
git config strcmp 	two share 
git config 	exactly prefix 
strcmp git config 	one two 
strcmp git 	additional 
config strcmp git 	characters longer 
config git 	considered greater 
config packet write 	smaller one 
sha hex 	split separator 
strbuf addstr strbuf 	sep sds 
addstr strbuf 	returned 
addstr strbuf 	count reference 
addf strbuf addf 	number tokens 
git user 	returned memory 
agent sanitized packet 	zero length 
write sha 	zero length 
hex strbuf release 	separator 
strip hidden 	returned note 
show show sha 	sep able 
append alternate 	split multi 
sha unique sha 	character separator 
clear show 	example sdssplit 
advertise shallow grafts 	foo 
packet flush 	bar two 
xsnprintf vsnprintf send 	elements foo 
sideband xwrite 	bar version 
start report message 	function binary 
end start 	safe requires 
report message end 	length 
xread send 	arguments sdssplit 
sideband close 	function zero 
memset git sha 	terminated make 
init git 	sure room 
sha update git 	next element 
sha memcpy 	one 
git sha init 	search separator 
git sha 	skip separator 
update git sha 	element sure 
update git 	room tokens 
sha git sha 	free result 
init git 	returned 
sha update git 	sdssplitlen nothing 
sha update 	tokens append 
git sha strbuf 	sds escaped 
addf hmac 	representation non 
sha strlen strbuf 	printable characters 
release strbuf 	tested 
addf sha hex 	isprint turned 
strbuf detach 	escapes form 
strlen strchrnul 	hex number 
memcmp xmemdupz find 	call modified 
header strcmp 	sds longer 
strtoul prepare push 	valid 
cert nonce 	references must 
strcmp strtoul labs 	substituted pointer 
free xstrdup 	returned call 
free free write 	helper function 
sha file 	sdssplitargs returns 
hashclr memset parse 	non 
signature verify 	zero valid 
buffer parse gpg 	hex digit 
output strbuf 	helper function 
release strbuf release 	sdssplitargs converts 
check nonce 	hex digit 
sha argv pushf 	integer 
sha hex 	split line 
argv pushf argv 	arguments every 
pushf argv 	argument following 
pushf argv 	programming language 
pushf argv pushf 	repl alike 
argv pushf 	form 
find hook memset 	foo bar 
start prepare 	newline supported 
push cert sha 	xff otherstuff 
start command 	number arguments 
finish sigchain push 	stored argc 
feed write 	sds 
full close finish 	returned caller 
sigchain pop 	free resulting 
finish command strbuf 	sds sdsfreesplitres 
reset strbuf 	note sdscatrepr 
addf sha hex 	able convert 
sha hex 	back 
strbuf init feed 	quoted format 
receive hook 	sdssplitargs able 
run feed 	parse function 
hook strbuf release 	returns allocated 
find hook 	tokens success 
sha hex sha 	even 
hex start 	input empty 
command copy sideband 	input contains 
finish command 	unbalanced quotes 
bare repository strcmp 	closed quotes 
size error 	followed non 
size error trace 	space 
key delayed 	characters foo 
reachability test sha 	bar foo 
append setup 	skip blanks 
alternate shallow check 	token quotes 
shallow connected 	single quotes 
rollback file sha 	closing 
clear commit 	quote must 
file shallow sha 	followed space 
clear sha 	nothing unterminated 
run command 	quotes closing 
child process init 	quote must 
run command 	followed 
head history child 	space nothing 
process init 	unterminated quotes 
run command sha 	token vector 
hex child 	even empty 
process init run 	input something 
command argv 	modify 
pushf absolute path 	substituting occurrences 
run hook 	characters specified 
sha hex bare 	corresponding character 
repository argv 	instance sdsmapchars 
pushf absolute path 	mystring 
git dir 	effect turning 
find hook push 	hello ell 
deploy push 	function returns 
checkout argv clear 	sds pointer 
starts check 	always input 
refname format 	pointer 
error strbuf addf 	since resize 
git strbuf 	needed specified 
detach warning error 	separator also 
refuse unconfigured 	returns result 
deny update worktree 	sds like 
sha sha 	sdsjoin 
file error sha 	joins sds 
hex sha 	wrappers allocators 
sha starts error 	used sds 
strcmp warning 	note sds 
refuse unconfigured deny 	actually use 
current error 	macros 
sha sha starts 	defined sdsalloc 
parse parse 	order avoid 
error merge bases 	pay overhead 
error run 	function calls 
update hook error 	define wrappers 
sha parse 	programs 
exists warning 	sds linked 
warning transaction error 	want touch 
strbuf release 	sds internals 
strbuf release update 	even use 
shallow transaction 	different allocator 
update error strbuf 	run 
release strbuf 	test times 
release find hook 	order hit 
argv push 	first two 
argv push start 	sds header 
command copy 	types sds 
sideband finish command 	lib 
strbuf addf 	library copyright 
git resolve strbuf 	salvatore sanfilippo 
release strip 	antirez gmail 
error list lookup 	dot copyright 
hashcmp hashcmp 	oran agra 
find unique abbrev 	copyright 
find unique 	redis labs 
abbrev find 	inc rights 
unique abbrev find 	reserved redistribution 
unique abbrev 	use source 
error list append 	binary forms 
list sort 	without 
check aliased update 	modification permitted 
list clear 	provided following 
sha hashcpy check 	conditions met 
everything connected 	redistributions source 
sha hashcpy strbuf 	code must 
addstr git 	retain 
strbuf setlen strbuf 	copyright notice 
addstr hidden 	list conditions 
sha strbuf release 	following disclaimer 
process cmd 	redistributions binary 
error die process 	form must 
cmd transaction 	reproduce 
begin error 	copyright notice 
strbuf reset update 	list conditions 
transaction commit 	following disclaimer 
error strbuf reset 	documentation materials 
transaction free 	provided distribution 
strbuf release transaction 	neither 
begin error 	name redis 
strbuf reset process 	names contributors 
cmd update 	may used 
transaction commit error 	endorse promote 
transaction free 	products derived 
strbuf release check 	software 
everything connected 	without specific 
connectivity errors reject 	prior written 
updates hidden 	permission software 
run receive hook 	provided copyright 
check aliased 	holders contributors 
updates free resolve 	express 
refdup execute 	implied warranties 
commands atomic 	including limited 
execute commands non 	implied warranties 
atomic warn 	merchantability fitness 
skipped connectivity check 	particular purpose 
sha hex 	disclaimed 
sha hex die 	shall copyright 
xcalloc hashcpy 	owner contributors 
hashcpy memcpy die 	liable direct 
strstr die 	indirect incidental 
parse signature memchr 	special exemplary 
queue command 	consequential 
packet read line 	damages including 
starts sha 	limited procurement 
hex die sha 	substitute goods 
append strlen 	services loss 
parse feature request 	use data 
parse feature 	profits 
request parse feature 	business interruption 
request parse 	however caused 
feature request 	theory liability 
strcmp packet read 	whether contract 
strcmp strbuf 	strict liability 
addstr queue command 	tort 
queue commands 	including negligence 
cert read pack 	otherwise arising 
header parse 	way use 
pack header close 	software even 
snprintf ntohl 	advised possibility 
ntohl setup temporary 	damage 
shallow argv 	create sds 
push argv push 	content specified 
ntohl argv 	init pointer 
pushl argv push 	initlen used 
argv pushf 	init initialized 
run command argv 	zero 
pushl gethostname 	bytes always 
xsnprintf argv pushf 	termined sds 
getpid argv 	always even 
pushf argv 	create sds 
push start command 	mystring sdsnewlen 
index pack 	abc 
lockfile close finish 	print end 
command reprepare 	however binary 
packed git unpack 	safe contain 
memset start 	characters middle 
unpack finish alloc 	length stored 
assign shallow 	sds 
commits refs xcalloc 	header empty 
xcalloc xcalloc 	usually created 
setenv nonexistent shallow 	order append 
sha sha 	use type 
append prepare shallow 	since type 
update alloc 	good 
assign shallow commits 	flags pointer 
refs sha 	create empty 
free packet 	zero length 
buf write packet 	sds even 
buf write 	always term 
packet buf write 	create 
packet buf 	sds starting 
flush send sideband 	terminated duplicate 
write die 	sds free 
strbuf release sha 	sds operation 
packet trace 	performed sds 
identity strcmp strcmp 	length 
strcmp strcmp 	length obtained 
usage usage usage 	strlen considering 
setup path 	content first 
enter repo die 	term character 
git config 	function useful 
prepare push cert 	sds 
nonce time 	hacked manually 
write head info 	way like 
read head 	following example 
info prepare 	sdsnew foobar 
shallow info unpack 	sdsupdatelen sdslen 
sideband update 	output 
shallow info execute 	comment call 
commands unlink 	sdsupdatelen output 
warn report run 	modified logical 
receive hook 	length remains 
run update post 	bytes modify 
hook close 	sds 
packs run command 	place make 
opt update 	empty zero 
server info clear 	length however 
shallow info 	existing buffer 
packet flush sha 	discarded free 
clear sha 	space 
clear free advertise 	next append 
refs outside 	operations require 
current refs client 	allocations number 
use minimize 	bytes previously 
data transfer 	available enlarge 
otherwise ignore happens 	free 
cover thrown 	space end 
one alternate mark 	sds caller 
histories complete 	sure calling 
alternates well eof 	function overwrite 
rfc rfc 	addlen bytes 
rfc rfc rfc 	end 
hmac sha 	plus one 
needswork reuse find 	nul term 
commit header 	note change 
commit author parsing 	length sds 
dropping commit 	returned sdslen 
name possibly moving 	free 
commit returned 	buffer space 
nonce must match 	asap enough 
gave earlier 	space left 
stateless mode may 	use type 
receiving nonce 	user appending 
issued another 	type 
instance server serving 	able remember 
repository timestamps 	empty space 
may match nonce 	sds make 
seed dir 	room must 
match recompute report 	called every 
time slop 	appending 
addition nonce issued 	operation since 
another instance 	header size 
timestamp within receive 	changes need 
certnonceslop seconds 	move forward 
pretend issued nonce 	use realloc 
reporting hook 	reallocate 
nonce concat seconds 	sds free 
since epoch 	space end 
hmac would earlier 	contained remains 
many seconds 	altered next 
nonce stale 	concatenation operations 
negative would mean 	require 
issued another 	reallocation call 
server clock skewed 	passed sds 
future pretend 	longer valid 
received nonce passes 	references must 
hmac check 	substituted pointer 
forged third party 	returned 
issued beginning 	call total 
gpg sig error 	size allocation 
running gpg 	specifed sds 
eof make sure 	including sds 
setup alternate 	header pointer 
shallow next lose 	free 
roots needswork 	buffer end 
consolidate various implementions 	term pointer 
unborn branch 	actual sds 
test one make 	allocation normally 
unified one 	sds referenced 
robust sha 	start 
check used elsewhere 	buffer increment 
would allow 	sds length 
tell unborn branch 	decrements left 
corrupt example 	free space 
purpose fixing deploy 	end according 
update work 	incr 
pushing empty repository 	also term 
issue suffice 	end function 
run command clean 	used order 
completely reinitialize 	fix length 
diff index either 	user calls 
head empty 	sds 
refs allowed good 	make room 
good end 	writes something 
list returns one 	end current 
update shallow 	needs length 
update shallow end 	note possible 
list end 	use 
cert associated 	negative increment 
refs belong list 	order right 
aka step 	trim usage 
done yet keep 	example sds 
hooks happy 	incr len 
forcing temporary shallow 	sds 
file via 	make room 
env variable shallow 	possible mount 
file every 	following schema 
command check everything 	cat bytes 
connected done 	coming kernel 
git shallow though 	end 
ref-filter.c position 	sds without 
width name type 	copying intermediate 
color align 	buffer oldlen 
nlines used atom 	sdslen sds 
cnt need 	make room 
tagged need symref 	buffer 
need color 	size nread 
reset eol 	read oldlen 
atom color atom 	buffer size 
arg atom 	check nread 
arg atom arg 	handle sds 
atom arg 	incr 
atom arg atom 	len nread 
arg align 	avoid compilation 
width position name 	warnings grow 
cmp type 	sds specified 
atom arg prev 	length bytes 
output stack 	part 
end data quote 	original length 
style stack 	sds zero 
align atomv state 	specified length 
atom arg 	smaller current 
len len str 	length operation 
quote style 	performed 
state stack stack 	make sure 
current prev 	added region 
stack align 	doesn contain 
atomv state atomv 	garbage also 
state current 	trailing append 
format color sha 	specified 
obj eaten 	binary safe 
buf name sha 	pointed len 
atom val 	bytes end 
deref obj buf 	specified sds 
name val 	call passed 
deref obj buf 	sds 
tag name 	longer valid 
val deref obj 	references must 
buf commit 	substituted pointer 
name parents parent 	returned call 
wholen buf 	append specified 
eol buf eol 	termianted 
buf buf 	sds call 
email eoemail 	passed sds 
buf len buf 	longer valid 
atomname eoemail 	references must 
zone timestamp date 	substituted pointer 
mode formatp 	returned 
val deref obj 	call append 
buf wholen 	specified sds 
wholine name name 	existing sds 
buf sub 	call modified 
sublen body bodylen 	sds longer 
nonsiglen sig 	valid 
siglen eol buf 	references must 
size lines 	substituted pointer 
eol len val 	returned call 
deref obj 	destructively modify 
buf sigpos siglen 	sds hold 
atom name 	specified 
contents end val 	binary safe 
val deref 	pointed length 
obj buf 	len bytes 
dst src refname 	like sdscpylen 
arg end 	must termined 
remaining start atom 	length 
refname branch 	obtained strlen 
num num buf 	helper sdscatlonglong 
obj eaten 	actual number 
size tagged unused 	conversion must 
atom name 	point room 
deref refname formatp 	least 
branch branch 	sds llstr 
name branch name 	size bytes 
buf head 	function returns 
sha arg atom 	length terminated 
alloc commit 	representation stored 
parents want candidate 	generate 
contains stack 	representation method 
entry commit parents 	produces reversed 
filter commit 	compute length 
patterns refname 	term reverse 
pattern refname namelen 	identical sdsll 
plen filter 	str 
refname points sha 	type generate 
refname tagged 	representation method 
sha obj refname 	produces reversed 
objectname flag 	compute length 
filter refname prefix 	term reverse 
kind refname 	create 
oid flag data 	sds much 
cbdata filter 	faster sdscatprintf 
commit kind item 	sdsempty lld 
cbdata revs 	like sdscatprintf 
old filter clear 	gets list 
item item 	instead 
commit merged filter 	variadic start 
type cbdata 	buffer speed 
ret broken cmp 	possible revert 
cmp type 	heap allocation 
sorting cmp 	buffers two 
sorting state info 	times 
format quote 	bigger every 
style buf state 	time fail 
atomv resetv 	fit current 
color cstr name 	buffer size 
sorting opt 	concat obtained 
arg unset sorting 	sds 
tail len 	append sds 
opt arg unset 	obtained alike 
sha die 	format specifier 
color parse die 	call modified 
strcmp strcmp 	sds longer 
strcmp die die 	valid 
die strcmp 	references must 
strcmp strcmp skip 	substituted pointer 
prefix strtoul 	returned call 
die die 	example sdsnew 
strcmp die strcmp 	sum sdscatprintf 
strcmp strcmp 	often 
die list split 	need create 
skip prefix 	scratch alike 
parse align position 	format need 
die skip 	use sdsempty 
prefix strtoul die 	target sdscatprintf 
strtoul parse 	sdsempty 
align position die 	format args 
die list 	function similar 
clear die strlen 	sdscatprintf much 
memcmp size 	faster rely 
strlen memchr memcmp 	sprintf family 
size die 	functions 
realloc xmemdupz memset 	implemented libc 
parser strcmp 	often slow 
strbuf addstr quote 	moreover directly 
buf perl 	handling sds 
quote buf 	data concatenated 
python quote buf 	provides 
tcl quote 	performance improvement 
buf quote formatting 	however function 
strbuf addstr 	handles incompatible 
xcalloc strbuf init 	subset alike 
strbuf addbuf 	format specifiers 
strbuf release free 	sds 
strbuf utf 	bit integer 
align strbuf swap 	bit integer 
strbuf release 	verbatim character 
push stack element 	next format 
die end 	specifier process 
quote formatting strbuf 	position 
swap strbuf 	next write 
release pop stack 	dest str 
element find 	make sure 
next strchr error 	always space 
parse filter 	least handle 
atom skip 	generally 
prefix strcmp read 	unknown term 
sha file 	part left 
parse buffer starts 	right composed 
xstrdup find 	contiguous characters 
unique abbrev xstrdup 	found cset 
sha hex 	terminted 
die strcmp strcmp 	call modified 
xstrfmt grab 	sds longer 
objectname strcmp strcmp 	valid references 
strcmp xstrdup 	must substituted 
oid hex strcmp 	pointer returned 
xstrdup oid 	call 
hex strcmp commit 	example sdsnew 
list count 	hello world 
xstrfmt strcmp strbuf 	sdstrim output 
addch strbuf 	hello world 
addstr oid hex 	turn 
strbuf detach 	smaller equal 
strncmp strchr 	containing substring 
strchrnul xmemdupz strncmp 	specified start 
xmemdupz strchr 	end indexes 
strchr xmemdupz xmemdupz 	start end 
strstr strchr 	negative 
parse date format 	means last 
strtoul strtol 	character penultimate 
xstrdup show date 	character forth 
strlen strncmp 	interval inclusive 
strcmp strcmp starts 	start end 
find wholine 	characters 
copy line strcmp 	part resulting 
copy name 	modified place 
strcmp copy email 	example sdsnew 
starts grab 	hello world 
date strcmp strcmp 	sdsrange ello 
find wholine 	world 
starts grab 	apply tolower 
date strcmp copy 	every character 
line strchrnul 	sds apply 
parse signature strlen 	toupper every 
strlen strchrnul 	character sds 
strlen strbuf addstr 	compare 
memchr strbuf 	two sds 
strcmp strcmp starts 	memcmp positive 
find subpos 	negative exactly 
copy subject xmemdupz 	binary two 
xmemdupz xmemdupz 	share exactly 
append lines strbuf 	prefix 
detach xstrdup 	one two 
grab common values 	additional characters 
grab tag 	longer considered 
values grab sub 	greater smaller 
body contents 	one split 
grab person grab 	separator 
commit values 	sep sds 
grab sub 	returned count 
body contents grab 	reference number 
person grab 	tokens returned 
person die strtol 	memory zero 
die die 	length 
shorten unambiguous stat 	zero length 
tracking info 	separator returned 
xstrfmt xstrfmt xstrfmt 	note sep 
stat tracking 	able split 
info xcalloc resolve 	multi character 
refdup starts 	separator 
starts starts skip 	example sdssplit 
prefix branch 	foo bar 
branch upstream fill 	two elements 
remote details 	foo bar 
starts skip prefix 	version function 
branch branch 	binary 
push fill remote 	safe requires 
details starts 	length arguments 
strcmp copy 	sdssplit function 
advance copy advance 	zero terminated 
xstrdup grab 	make sure 
objectname strcmp resolve 	room 
strcmp starts 	next element 
strcmp strchr strcmp 	one search 
shorten unambiguous 	separator skip 
skip prefix strip 	separator element 
components die 	sure room 
xstrfmt obj die 	tokens 
sha hex 	free result 
die sha hex 	returned sdssplitlen 
grab values 	nothing tokens 
free obj die 	append sds 
sha hex 	escaped representation 
die sha hex 	non 
grab values 	printable characters 
free populate fill 	tested isprint 
missing values 	turned escapes 
oidcmp commit 	form hex 
list parse commit 	number call 
alloc grow 	modified 
contains test push 	sds longer 
contains stack 	valid references 
free contains test 	must substituted 
contains tag 	pointer returned 
algo descendant skip 	call helper 
prefix skip 	function 
prefix skip prefix 	sdssplitargs returns 
skip prefix 	non zero 
wildmatch strlen strlen 	valid hex 
strncmp wildmatch 	digit helper 
match name path 	function sdssplitargs 
match pattern 	converts 
sha lookup parse 	hex digit 
die sha 	integer split 
lookup flex alloc 	line arguments 
str hashcpy 	every argument 
strcmp size 	following programming 
starts warning warning 	language 
filter kind 	repl alike 
filter pattern match 	form foo 
match points 	bar newline 
lookup commit reference 	supported xff 
gently commit 	otherstuff number 
contains item realloc 	arguments 
free free 	stored argc 
free item free 	sds returned 
xcalloc init 	caller free 
revisions pending pending 	resulting sds 
prepare revision 	sdsfreesplitres note 
walk die free 	sdscatrepr 
item clear 	able convert 
commit marks clear 	back quoted 
commit marks 	format sdssplitargs 
free die 	able parse 
fullref fullref fullref 	function returns 
fullref head 	allocated 
merge filter atom 	tokens success 
atom versioncmp 	even input 
strcmp strcmp cmp 	empty input 
sorting qsort 	contains unbalanced 
hex hex hex 	quotes closed 
strbuf addch 	quotes 
strbuf addch push 	followed non 
stack element 	space characters 
find next strchr 	foo bar 
append atom 	foo skip 
parse filter atom 	blanks token 
handler strlen 	quotes 
append color parse 	single quotes 
die append 	closing quote 
atom die fwrite 	must followed 
pop stack 	space nothing 
element putchar 	unterminated quotes 
xcalloc parse filter 	closing 
atom strlen 	quote must 
xcalloc skip prefix 	followed space 
skip prefix 	nothing unterminated 
strlen parse filter 	quotes token 
atom starts 	vector even 
sha die lookup 	empty 
commit reference 	input something 
gently opterror atom 	modify substituting 
valid field 	occurrences characters 
atom listed possibly 	specified corresponding 
prefixed denote 	character instance 
deref tag parse 	sdsmapchars 
given format 	mystring effect 
sort specifiers make 	turning hello 
list properties 	ell function 
need extract objects 	returns sds 
item structure 	pointer always 
hold values 	input 
extracted indexed atom 	pointer since 
number index 	resize needed 
used sorting field 	specified separator 
str used 	also returns 
parse format sort 	result sds 
specifiers deref 	like 
atom already used 	sdsjoin joins 
elsewhere atom 	sds wrappers 
valid one atom 	allocators used 
name colon 	sds note 
strip everything specifies 	sds actually 
format entry 	use 
shouldn used checking 	macros defined 
valid atom 	sdsalloc order 
table including deref 	avoid pay 
prefix quote 	overhead function 
formatting done stack 	calls define 
single element 	wrappers 
otherwise quote 	programs sds 
formatting done element 	linked want 
entire output 	touch sds 
strbuf end atom 	internals even 
encountered perform 	use different 
quote formatting stack 	allocator 
element supporting 	run test 
atom nested perform 	times order 
quote formatting 	hit first 
topmost supporting atom 	two sds 
format find 	header types 
next occurrence atom 	sds.h 
start atom 	flags buf 
quoted per cent 	len alloc 
skip two 	flags buf 
otherwise singleton make 	len alloc 
sure format 	flags buf 
well formed 	len 
parse used atoms 	alloc flags 
points points 	buf len 
closing given name 	alloc flags 
read data 	buf flags 
size data returning 	flags newlen 
also borrowed 	flags 
representation eaten well 	inc flags 
signal parse 	newlen flags 
buffer free buffer 	newlen flags 
see grab 	init initlen 
values see grab 	init len 
values see 	len 
grab values end 	len fmt 
header got 	attribute fmt 
atomname ends date 	fmt cset 
date something 	start end 
possible something format 	len sep 
parse filter 	seplen 
atom wouldn 	count tokens 
allowed means format 	count len 
specified use 	line argc 
see grab values 	setlen argv 
point looking 	argc sep 
tag commit creator 	argv 
creatordate requested 	argc sep 
something special author 	seplen addlen 
commit wanted 	incr size 
skip past header 	ptr size 
hit empty 	ptr argc 
line skip empty 	argv 
lines parse 	sds type 
signature first might 	len sds 
even subject 	hdr sds 
line subject first 	hdr sds 
non empty 	hdr sds 
line subject goes 	hdr 
first empty 	sds hdr 
line drop 	sds hdr 
trailing newline present 	sds hdr 
skip empty 	sds hdr 
lines lines greater 	sds hdr 
append many 	sds 
lines given buf 	hdr sds 
length size 	hdr sds 
given strbuf see 	hdr sds 
grab values 	type len 
size length message 	sds hdr 
removing signature 	sds 
want empty print 	hdr sds 
field requests 	hdr sds 
apply authordate tag 	hdr sds 
val list 	type len 
atom hold returned 	sds hdr 
values extract 	sds 
values atoms used 	hdr sds 
atom obj 	hdr sds 
buf deref 	hdr sds 
obj buf pointed 	hdr sds 
otherwise tag 	hdr sds 
refers grab values 	hdr 
val deref 	sds hdr 
obj buf grab 	sds lib 
blob values 	library copyright 
val deref obj 	salvatore sanfilippo 
buf normal 	antirez gmail 
parse referred grab 	dot 
needed fill 	copyright oran 
specials first local 	agra copyright 
branches may 	redis labs 
upstream atom wants 	inc rights 
know tagged 	reserved redistribution 
done tag see 	use 
use derefs 	source binary 
grab refers 	forms without 
needswork derefs tag 	modification permitted 
good deal 	provided following 
chains trust consistent 	conditions met 
deref tag 	redistributions 
peels onion core 	source code 
given atom 	must retain 
lazily gets calling 	copyright notice 
populate mimicking 	list conditions 
real stack stack 	following disclaimer 
lives heap 	redistributions 
avoiding stack overflows 	binary form 
recursion step 	must reproduce 
stack items points 	copyright notice 
commits whose 	list conditions 
ancestors inspected test 	following disclaimer 
whether candidate 	documentation 
one parents contained 	materials provided 
list recurse 	distribution neither 
find though 	name redis 
inconclusive previously marked 	names contributors 
containing want 	may used 
commit marked possibly 	endorse 
containing want 	promote products 
commit popped stack 	derived software 
parents item 	without specific 
marked therefore contains 	prior written 
test meaningful 	permission software 
refname matches one 	provided 
patterns otherwise 	copyright holders 
pattern prefix refname 	contributors express 
refs heads 	implied warranties 
master matches pattern 	including limited 
refs heads 	implied warranties 
mas wildcard matches 	merchantability 
refs heads 	fitness particular 
mas format option 	purpose disclaimed 
given need 	shall copyright 
skip prefix 	owner contributors 
matching refs tags 	liable direct 
branches refname 	indirect 
matches one patterns 	incidental special 
otherwise pattern 	exemplary consequential 
path prefix refname 	damages including 
refs heads 	limited procurement 
master matches pattern 	substitute goods 
refs heads 	services 
refs heads wildcard 	loss use 
matches refs 	data profits 
heads refname matches 	business interruption 
one patterns 	however caused 
otherwise pattern always 	theory liability 
matches given 	whether 
sha refname check 	contract strict 
belongs sha 	liability tort 
given tag check 	including negligence 
given tag 	otherwise arising 
points one 	way use 
sha given sha 	software 
given sha 	even advised 
needswork single level 	possibility damage 
inderection obtained 	note sdshdr 
might want change 	never used 
account multiple 	access flags 
levels annotated tags 	directly 
pointing annotated 	however document 
tags pointing commit 	layout type 
refs cached 	sds lsb 
might know refname 	type msb 
peels without 	length used 
need parse via 	excluding 
parse peel 	header terminator 
might efficient alternative 	lsb type 
obtain pointee 	unused bits 
allocate space item 	used excluding 
copy objectname 	header terminator 
flag call 	lsb 
back given filter 	type unused 
refs keep 	bits used 
later processing obtain 	excluding header 
current kind 	terminator lsb 
filter kind ignore 	type unused 
unwanted refs 	bits 
merge filter applied 	used excluding 
refs pointing 	header terminator 
commits hence obtain 	lsb type 
commit oid 	unused bits 
available discard non 	sdsalloc sdsavail 
commits early 	sdslen 
actual filtering done 	nothing type 
later perform 	total allocation 
filtering contains option 	info low 
open yet 	level functions 
sort may 	exposed user 
need refname job 	api 
resulting list 	export allocator 
may yet pruned 	used sds 
maxcount logic 	program sds 
free memory allocated 	sometimes program 
item free 	sds linked 
memory allocated api 	may 
filtering refs 	use different 
type refs user 	allocators may 
requested iterate 	want allocate 
refs apply filters 	free things 
per given 	sds respectively 
filter structure store 	free 
filtered refs 	allocate sds 
structure simple per 	lib library 
filtering common 	copyright salvatore 
cases need branches 	sanfilippo antirez 
remotes tags 	gmail dot 
iterate refs 	copyright 
mix refs needed 	oran agra 
iterate refs 	copyright redis 
filter required refs 	labs inc 
help filter 	rights reserved 
kind filters need 	redistribution use 
revision walking 	source 
sorting option given 	binary forms 
use refname 	without modification 
sort sort list 	permitted provided 
ref-filter.h next 	following conditions 
atom objectname flag 	met redistributions 
kind symref 	source 
commit refname alloc 	code must 
items revs 	retain copyright 
name patterns points 	notice list 
commit merge 	conditions following 
commit kind lines 	disclaimer redistributions 
abbrev verbose 	binary 
filter filter 	form must 
type atom format 	reproduce copyright 
sort info 	notice list 
format quote style 	conditions following 
opt arg 	disclaimer documentation 
unset opt arg 	materials 
unset quoting 	provided distribution 
styles index used 	neither name 
atom macros 	redis names 
checking merged merged 	contributors may 
options api 	used endorse 
filtering refs type 	promote 
refs user 	products derived 
requested iterate refs 	software without 
apply filters 	specific prior 
per given filter 	written permission 
structure store 	software provided 
filtered refs structure 	copyright 
clear memory 	holders contributors 
allocated parse 	express implied 
format sort specifiers 	warranties including 
used verify 	limited implied 
given format correct 	warranties merchantability 
parse used 	fitness 
atoms sort given 	particular purpose 
per sorting 	disclaimed shall 
provided print given 	copyright owner 
format quote 	contributors liable 
style callback function 	direct indirect 
parsing sort 	incidental 
option sort option 	special exemplary 
refname function 	consequential damages 
parse merged merged 	including limited 
options filter 	procurement substitute 
reflog-walk.c osha nsha 	goods services 
email timestamp 	loss 
message alloc 	use data 
osha nsha email 	profits business 
timestamp message 	interruption however 
data item reflogs 	caused theory 
sha name 	liability whether 
name free refname 	contract 
timestamp commit 	strict liability 
alloc commit lifo 	tort including 
pop result 	negligence otherwise 
commit lifo info 	arising way 
recno reflogs 	use 
reflogs complete reflogs 	software even 
last commit 	advised possibility 
reflog info info 	damage note 
commit name 	sdshdr never 
timestamp recno item 	used access 
reflogs branch 	flags 
commit reflog sha 	directly however 
sha info 	document layout 
commit commit 	type sds 
info commit reflog 	lsb type 
logobj reflog 	msb length 
reflog info dmode 	used 
force date 	excluding header 
shorten commit reflog 	terminator lsb 
info printed 	type unused 
reflog info commit 	bits used 
reflog info 	excluding header 
len reflog info 	terminator 
commit reflog 	lsb type 
info reflog info 	unused bits 
oneline dmode 	used excluding 
force date commit 	header terminator 
reflog info 	lsb type 
selector alloc grow 	unused 
hashcpy hashcpy 	bits used 
xstrdup xstrdup xcalloc 	excluding header 
xstrdup reflog 	terminator lsb 
ent resolve 	type unused 
refdup reflog ent 	bits sdsalloc 
free xstrfmt 	sdsavail 
reflog ent free 	sdslen nothing 
xstrfmt reflog 	type total 
ent free memmove 	allocation info 
alloc grow 	low level 
xcalloc strchr die 	functions exposed 
xstrdup strtoul 	user 
approxidate list lookup 	api export 
free resolve 	allocator used 
refdup die read 	sds program 
complete reflog 	sds sometimes 
dwim log strlen 	program sds 
free free 	linked 
free read complete 	may use 
reflog list 	different allocators 
insert xcalloc reflog 	may want 
recno time 	allocate free 
free free 	things sds 
commit info commit 	respectively 
info parse 	free allocate 
xcalloc shorten unambiguous 	flags buf 
strbuf addf 	len alloc 
strbuf addstr show 	flags buf 
date strbuf 	len alloc 
addf strbuf addch 	flags 
strlen strbuf 	buf len 
reflog selector strbuf 	alloc flags 
release strip 	buf len 
away trailing newline 	alloc flags 
reflog-walk.h info 	buf flags 
info commit name 	flags 
info commit 	newlen flags 
info date mode 	inc flags 
force date 	newlen flags 
reflog info 	newlen flags 
reflog info reflog 	init initlen 
info dmode 	init 
force date shorten 	len len 
reflog.c reflog 	len fmt 
expire usage reflog 	attribute fmt 
usage reflog 	fmt cset 
exists usage reflog 	start end 
expire reflog 	len 
expire unreachable revs 	sep seplen 
stalefix expire 	count tokens 
total expire unreachable 	count len 
recno mark 	line argc 
list mark limit 	setlen argv 
cmd tip 	argc 
commit tips sha 	sep argv 
reflog alloc 	argc sep 
sha desc entry 	seplen addlen 
complete size 	incr size 
data commit 	ptr size 
study found incomplete 	ptr 
parent sha 	argc argv 
commit pending expire 	sds type 
limit leftover 	len sds 
parent commit commit 	hdr sds 
sha osha 	hdr sds 
nsha email timestamp 	hdr 
message data 	sds hdr 
old refname oid 	sds hdr 
flags data 	sds hdr 
list tip commit 	sds hdr 
refname sha 	sds hdr 
data elem data 	sds 
elem oid 	hdr sds 
unused data next 	hdr sds 
expire total 	hdr sds 
expire unreachable pattern 	hdr sds 
pattern len 	type len 
ent expire 	sds 
pattern key pattern 	hdr sds 
len expire 	hdr sds 
slot ent slot 	hdr sds 
ent argc 	hdr sds 
argv prefix status 	type len 
expiry flags 	sds 
arg collected sha 	hdr sds 
osha nsha 	hdr sds 
email timestamp message 	hdr sds 
data argc 	hdr sds 
argv prefix status 	hdr sds 
flags arg 	hdr 
spec sha recno 	sds hdr 
argc argv 	sds hdr 
prefix start arg 	sds lib 
reflog usage 	library copyright 
argc argv prefix 	salvatore sanfilippo 
lookup read 	antirez 
sha file 	gmail dot 
init desc entry 	copyright oran 
sha file 	agra copyright 
isdir complete free 	redis labs 
buffer memset 	inc rights 
memset parse complete 	reserved 
free free 	redistribution use 
sha lookup commit 	source binary 
reference gently 	forms without 
commit complete pop 	modification permitted 
commit parse 	provided following 
commit commit list 	conditions 
insert commit 	met redistributions 
list insert sha 	source code 
lookup commit 	must retain 
reference gently mark 	copyright notice 
reachable keep 	list conditions 
entry keep entry 	following 
unreachable unreachable 	disclaimer redistributions 
lookup commit 	binary form 
reference gently commit 	must reproduce 
list insert 	copyright notice 
strcmp lookup commit 	list conditions 
reference gently 	following 
commit list insert 	disclaimer documentation 
commit list 	materials provided 
insert mark reachable 	distribution neither 
clear commit 	name redis 
marks free commit 	names contributors 
list clear 	may 
commit marks flex 	used endorse 
alloc str 	promote products 
hashcpy alloc grow 	derived software 
strncmp flex 	without specific 
alloc mem config 	prior written 
error nonbool 	permission 
parse expiry 	software provided 
date error parse 	copyright holders 
config key 	contributors express 
git config strcmp 	implied warranties 
parse expire 	including limited 
cfg strcmp parse 	implied 
expire cfg 	warranties merchantability 
git config find 	fitness particular 
cfg ent 	purpose disclaimed 
wildmatch strcmp time 	shall copyright 
git config 	owner contributors 
memset strcmp strcmp 	liable 
starts parse 	direct indirect 
expiry date die 	incidental special 
starts parse 	exemplary consequential 
expiry date die 	damages including 
strcmp strcmp 	limited procurement 
strcmp strcmp strcmp 	substitute 
strcmp usage 	goods services 
init revisions 	loss use 
mark reachable objects 	data profits 
putchar memset 	business interruption 
reflog reflog expiry 	however caused 
param reflog 	theory 
expire free free 	liability whether 
dwim log 	contract strict 
strlen error reflog 	liability tort 
expiry param 	including negligence 
reflog expire memset 	otherwise arising 
strcmp strcmp 	way 
strcmp strcmp strcmp 	use software 
strcmp usage 	even advised 
error strstr error 	possibility damage 
dwim log 	note sdshdr 
error strtoul reflog 	never used 
ent approxidate 	access 
reflog ent reflog 	flags directly 
expire free 	however document 
strcmp usage 	layout type 
usage check refname 	sds lsb 
format die 	type msb 
reflog exists strcmp 	length 
usage cmd 	used excluding 
log reflog strcmp 	header terminator 
cmd log 	lsb type 
reflog strcmp cmd 	unused bits 
reflog expire 	used excluding 
strcmp cmd reflog 	header 
strcmp cmd 	terminator lsb 
reflog exists cmd 	type unused 
log reflog 	bits used 
needswork parse options 	excluding header 
early find 	terminator lsb 
commits reachable marked 	type 
seen make 	unused bits 
sure trees blobs 	used excluding 
contained complete 	header terminator 
mark commits 	lsb type 
also seen objects 	unused bits 
needed complete 	sdsalloc 
commit missing mark 	sdsavail sdslen 
commit incomplete 	nothing type 
make sure commits 	total allocation 
found necessary 	info low 
objects mark found 	level functions 
commits complete 	exposed 
iow seen clear 	user api 
flags objects 	export allocator 
traversed come traversed 	used sds 
ancestry chain 	program sds 
commit reach seen 	sometimes program 
commits known 	sds 
complete made sure 	linked may 
commits encountered 	use different 
traversal refer 	allocators may 
trees complete means 	want allocate 
know commits 	free things 
seen process complete 	sds 
free arrays 	respectively free 
make sure everything 	allocate sds 
commit exists 	lib library 
walked objects reachable 	copyright salvatore 
refs cache 	sanfilippo antirez 
earlier commits reachable 	gmail 
commit must 	dot copyright 
meet seen commits 	oran agra 
mark seen 	copyright redis 
well starting commits 	labs inc 
mark list 	rights reserved 
mark commits reachable 	redistribution 
stop traversal 	use source 
commits older expire 	binary forms 
limit queue 	without modification 
back caller 	permitted provided 
call restart traversal 	following conditions 
longer expire 	met 
limit may may 	redistributions source 
commit yet 	code must 
look supplied sha 	retain copyright 
commit keep 	notice list 
reachable current prune 	conditions following 
dig root 	disclaimer 
iff specified reflog 	redistributions binary 
entry expired 	form must 
expiry timer slot 	reproduce copyright 
given explicitly 	notice list 
nothing tweak unconfigured 	conditions following 
make stash 	disclaimer 
never expire nothing 	documentation materials 
matched use 	provided distribution 
trust commits objects 	neither name 
reachable refs 	redis names 
even older 	contributors may 
repository cannot trust 	used 
reachable reflog 	endorse promote 
repository pruned older 	products derived 
git main 	software without 
reflog command showing 	specific prior 
refs-internal.h refname 	written permission 
newname extras skip 	software 
err buf 	provided copyright 
msg refname sha 	holders contributors 
old sha 	express implied 
flags type msg 	warranties including 
refname updates 	limited implied 
alloc refname old 	warranties 
sha sha 	merchantability fitness 
msg flags err 	particular purpose 
dirname extras 	disclaimed shall 
skip oldname newname 	copyright owner 
data structures 	contributors liable 
functions use 	direct 
refs module code 	indirect incidental 
outside refs 	special exemplary 
module use functions 	consequential damages 
defined refs 	including limited 
include file flag 	procurement substitute 
passed sha 	goods 
basic telling tolerate 	services loss 
broken refs 	use data 
reference deleted anyway 	profits business 
used flag 	interruption however 
update flags loose 	caused theory 
pruned used 	liability 
flag update flags 	whether contract 
reference updated 	strict liability 
sha used flag 	tort including 
update flags 	negligence otherwise 
old sha 	arising way 
used flag update 	use 
flags lockfile 	software even 
needs committed force 	advised possibility 
create reflog 	damage note 
skip adding update 	sdshdr never 
flags iff 	used access 
refname minimally safe 	flags 
safe means 	directly however 
deleting loose reference 	document layout 
name damage 	type sds 
example causing file 	lsb type 
reference deleted 	msb length 
function check reference 	used 
name legal 	excluding header 
use check refname 	terminator lsb 
format consider 	type unused 
refname starts refs 	bits used 
safe components 	excluding header 
might contain 	terminator 
escape refs names 	lsb type 
start refs 	unused bits 
considered safe iff 	used excluding 
consist entirely 	header terminator 
upper characters like 	lsb type 
head merge 	unused 
head config foo 	bits used 
bar peeled 	excluding header 
successfully cannot peeled 	terminator lsb 
named referred 	type unused 
tag peel chain 	bits sdsalloc 
exist cannot 	sdsavail 
peeled tag entry 	sdslen nothing 
contains peeled 	type total 
symref entry cannot 	allocation info 
peeled broken 	low level 
symbolic reference cannot 	functions exposed 
even resolved 	user 
name peel 	api export 
named tag resolve 	allocator used 
tag recursively 	sds program 
non tag found 	sds sometimes 
successful store 	program sds 
result sha peel 	linked 
peeled tag 	may use 
valid peel non 	different allocators 
tag peel 	may want 
invalid respectively sha 	allocate free 
unchanged reference 	things sds 
named refname could 	respectively 
created without 	free allocate 
conflicting name existing 	sds.h flags 
reference otherwise 	buf len 
negative write explanation 	alloc flags 
err extras 	buf len 
non list additional 	alloc 
refnames refname 	flags buf 
allowed conflict 	len alloc 
skip non ignore 	flags buf 
potential conflicts 	len alloc 
refs skip scheduled 	flags buf 
deletion operation 	flags 
behavior undefined name 	flags newlen 
listed extras 	flags inc 
skip two reference 	flags newlen 
names conflict 	flags newlen 
one exactly matches 	flags init 
leading components 	initlen 
foo bar conflicts 	init len 
foo foo 	len len 
bar baz foo 	fmt attribute 
bar foo 	fmt fmt 
barbados extras skip 	cset start 
must sorted 	end 
copy reflog message 	len sep 
msg buf 	seplen count 
allocated sufficiently 	tokens count 
large cleaning whitespaces 	len line 
especially convert 	argc setlen 
space reflog file 	argv 
one line 	argc sep 
per entry information 	argv argc 
needed single 	sep seplen 
update sha sha 	addlen incr 
check old 	size ptr 
locked flags old 	size 
old sha 	ptr argc 
old sha ensure 	argv sds 
exist update 	type len 
flags reference flags 	sds hdr 
old check 	sds hdr 
reference previously one 	sds 
old noderef 	hdr sds 
deleting ispruning 	hdr sds 
transaction states open 	hdr sds 
transaction valid 	hdr sds 
state accept updates 	hdr sds 
open transaction 	hdr 
committed closed closed 	sds hdr 
transaction longer 	sds hdr 
active operations free 	sds hdr 
used state 	sds hdr 
transaction either become 	sds type 
closed successfully 	len 
committing active transaction 	sds hdr 
failure building 	sds hdr 
transaction thus rendering 	sds hdr 
failed inactive 	sds hdr 
data structure holding 	sds type 
reference transaction 	len 
consist checks updates 	sds hdr 
multiple references 	sds hdr 
carried atomically 	sds hdr 
possible structure opaque 	sds hdr 
callers check 	sds hdr 
entries extras within 	sds 
specified directory 	hdr sds 
dirname reference directory 	hdr sds 
name including 	hdr sds 
trailing slash refs 	lib library 
heads foo 	copyright salvatore 
ignore conflicting references 	sanfilippo 
found skip 	antirez gmail 
conflicting reference name 	dot copyright 
extras skip 	oran agra 
must sorted lists 	copyright redis 
reference names 	labs inc 
either one signifying 	rights 
empty list 	reserved redistribution 
refs refs refs.c 	use source 
refname disposition 	binary forms 
refname flags 	without modification 
last disp refname 	permitted 
flags component 	provided following 
len component count 	conditions met 
refname buf 	redistributions source 
result refname resolve 	code must 
flags sha 	retain copyright 
flags pattern data 	notice 
refname resolve 	list conditions 
flags sha flags 	following disclaimer 
refname sha 	redistributions binary 
refname sha refname 	form must 
oid flags 	reproduce copyright 
data filter refname 	notice 
refnames msg 	list conditions 
fmt refname oid 	following disclaimer 
flags data 	documentation materials 
resolves junk msg 	provided distribution 
fmt refname 	neither name 
data msg 	redis 
fmt refnames data 	names contributors 
data submodule 	may used 
data data submodule 	endorse promote 
data data 	products derived 
submodule data data 	software without 
buf ret 	specific 
oid flag pattern 	prior written 
prefix data 	permission software 
real pattern filter 	provided copyright 
ret pattern 	holders contributors 
data name rev 	express implied 
parse rules 	warranties 
abbrev name full 	including limited 
name abbrev 	implied warranties 
name len len 	merchantability fitness 
buf ret 	particular purpose 
size str 	disclaimed shall 
len sha last 	copyright 
branch refs 	owner contributors 
found fullref sha 	liable direct 
result flag 	indirect incidental 
str len sha 	special exemplary 
log last 	consequential damages 
branch logs found 	including 
hash path 	limited procurement 
refname refname pseudoref 	substitute goods 
sha old 	services loss 
sha err filename 	use data 
buf ret 	profits business 
actual old sha 	interruption 
pseudoref old 	however caused 
sha filename actual 	theory liability 
old sha 	whether contract 
refname old sha 	strict liability 
flags transaction 	tort including 
err buf 	negligence 
msg wasspace refname 	otherwise arising 
refname refname 	way use 
time cnt reccnt 	software even 
sha found 	advised possibility 
osha nsha date 	damage note 
msg cutoff 	sdshdr 
time cutoff cutoff 	never used 
cnt osha 	access flags 
nsha email timestamp 	directly however 
message data 	document layout 
osha nsha email 	type sds 
timestamp message 	lsb 
data refname flags 	type msb 
time cnt 	length used 
sha msg cutoff 	excluding header 
time cutoff 	terminator lsb 
cutoff cnt err 	type unused 
transaction transaction 	bits 
refname update 	used excluding 
transaction refname sha 	header terminator 
old sha 	lsb type 
flags msg err 	unused bits 
update transaction 	used excluding 
refname sha flags 	header 
msg err 	terminator lsb 
transaction refname old 	type unused 
sha flags 	bits used 
msg err transaction 	excluding header 
refname old 	terminator lsb 
sha flags err 	type 
update refname 	unused bits 
strict scanf fmts 	sdsalloc sdsavail 
rules name 	sdslen nothing 
total len offset 	type total 
rules fail 	allocation info 
name len rule 	low 
refname hide 	level functions 
refs section 	exposed user 
len refname refname 	api export 
full match 	allocator used 
subject neg len 	sds program 
dirname extras 	sds 
skip pos extra 	sometimes program 
refname oldname 	sds linked 
newname skip err 	may use 
ret memcmp 	different allocators 
strcmp check refname 	may want 
component starts 	allocate 
xmallocz strlen normalize 	free things 
path copy 	sds respectively 
strlen free isupper 	free allocate 
xstrdup resolve 	sds lib 
resolve read full 	library copyright 
resolve wildmatch 	salvatore 
deref tag 	sanfilippo antirez 
noverify hashcpy resolve 	gmail dot 
strcmp list 	copyright oran 
fputc rawref rawref 	agra copyright 
submodule submodule 	redis labs 
submodule strbuf addf 	inc 
git read 	rights reserved 
full strbuf release 	redistribution use 
starts strbuf 	source binary 
addstr strbuf addstr 	forms without 
strbuf addstr 	modification permitted 
glob specials strbuf 	provided 
complete strbuf 	following conditions 
addch strbuf release 	met redistributions 
glob starts 	source code 
starts starts strlen 	must retain 
strcmp mkpath 	copyright notice 
interpret branch name 	list 
strbuf detach 	conditions following 
substitute branch 	disclaimer redistributions 
name mksnpath resolve 	binary form 
xstrdup strcmp 	must reproduce 
warning strchr warning 	copyright notice 
free substitute 	list 
branch name mksnpath 	conditions following 
resolve reflog 	disclaimer documentation 
exists strcmp reflog 	materials provided 
exists xstrdup 	distribution neither 
hashcpy free strcmp 	name redis 
starts isupper 	names 
pseudoref syntax strbuf 	contributors may 
addf sha 	used endorse 
hex git path 	promote products 
hold file 	derived software 
update strbuf addf 	without specific 
strerror read 	prior 
die hashcmp strbuf 	written permission 
addf rollback 	software provided 
file write 	copyright holders 
full strbuf addf 	contributors express 
rollback file 	implied warranties 
commit file strbuf 	including 
release git 	limited implied 
path sha hold 	warranties merchantability 
file update 	fitness particular 
die errno read 	purpose disclaimed 
die hashcmp 	shall copyright 
warning rollback file 	owner 
unlink rollback 	contributors liable 
file unlink type 	direct indirect 
pseudoref transaction 	incidental special 
begin transaction transaction 	exemplary consequential 
commit error 	damages including 
transaction free strbuf 	limited 
release transaction 	procurement substitute 
free strbuf release 	goods services 
isspace isspace 	loss use 
isspace starts 	data profits 
starts starts strcmp 	business interruption 
strcmp starts 	however 
xstrdup sha hashcpy 	caused theory 
hashcmp warning 	liability whether 
show date date 	contract strict 
mode hashcpy 	liability tort 
hashcmp warning show 	including negligence 
date date 	otherwise 
mode hashcpy hashcpy 	arising way 
hashcpy hashcpy 	use software 
xstrdup hashcpy sha 	even advised 
hashcpy memset 	possibility damage 
reflog ent reverse 	note sdshdr 
exit die 	never 
reflog ent xcalloc 	used access 
free free 	flags directly 
free free flex 	however document 
alloc str 	layout type 
alloc grow 	sds lsb 
die sha check 	type 
refname format 	msb length 
strbuf addf update 	used excluding 
hashcpy hashcpy 	header terminator 
xstrdup sha die 	lsb type 
transaction update 	unused bits 
sha die transaction 	used 
update die 	excluding header 
transaction update strlen 	terminator lsb 
xmalloc mult 	type unused 
snprintf xstrdup xstrdup 	bits used 
sscanf strlen 	excluding header 
mksnpath exists free 	terminator 
xstrdup strcmp 	lsb type 
starts strlen strcmp 	unused bits 
strlen config 	used excluding 
error nonbool 	header terminator 
xstrdup strlen xcalloc 	lsb type 
list append 	unused 
starts strlen list 	bits sdsalloc 
find insert 	sdsavail sdslen 
index starts list 	nothing type 
list insert 	total allocation 
verify refname available 	info low 
error list 	level 
clear strbuf release 	functions exposed 
backend independent 	user api 
part reference module 	export allocator 
handle various 	used sds 
characters refnames acceptable 	program sds 
character refs 	sometimes 
end component look 	program sds 
preceding reject 	linked may 
refs look preceding 	use different 
reject refs 	allocators may 
bad character 	want allocate 
ascii control characters 	free 
tab reject 	things sds 
unless refname refspec 	respectively free 
pattern read 	allocate flags 
one refname component 	buf len 
front refname 	alloc flags 
length component found 	buf 
component legal 	len alloc 
legal something reasonable 	flags buf 
git refs 	len alloc 
like path component 	flags buf 
begins dots 	len alloc 
ascii control characters 	flags 
tab anywhere 	buf flags 
anywhere unless refname 	flags newlen 
refspec pattern 	flags inc 
ends ends contains 	flags newlen 
portion refname 	flags newlen 
contains refname 	flags 
contains refspec pattern 	init initlen 
unset pattern 	init len 
flag accept single 	len len 
asterisk one 	fmt attribute 
side refspec component 	fmt fmt 
zero length 	cset 
component starts refname 	start end 
ends refname 	len sep 
single character start 	seplen count 
path component 	tokens count 
skip next component 	len line 
refname ends 	argc 
refname one component 	setlen argv 
refname escape 	argc sep 
refs example refs 	argv argc 
foo bar 	sep seplen 
safe refs foo 	addlen incr 
bar argument 	size 
filter refs 	ptr size 
append implied present 	ptr argc 
need check 	argv sds 
none len substituted 	type len 
returned later 	sds hdr 
free ing passed 	sds 
magic hand 	hdr sds 
form name branch 	hdr sds 
yet updated 	hdr sds 
sha still hold 	hdr sds 
values previous 	hdr sds 
record want first 	hdr 
entry pre 	sds hdr 
generate scanf formats 	sds hdr 
rev parse 	sds hdr 
rules generate format 	sds hdr 
suitable scanf 	sds hdr 
rev parse 	sds 
rules rule interpolating 	type len 
location rule 	sds hdr 
list terminated count 	sds hdr 
first strlen 	sds hdr 
strlen nul bail 	sds hdr 
rules buffer 	sds 
scanf result refname 	type len 
must fit 	sds hdr 
skip first rule 	sds hdr 
always match 	sds hdr 
strict mode matched 	sds hdr 
one rules 	sds 
must fail resolve 	hdr sds 
valid non 	hdr sds 
ambiguous check name 	hdr sds 
resolves valid 	hdr sds 
use rules prior 	lib library 
matched one 	copyright 
skip matched 	salvatore sanfilippo 
rule name ambiguous 	antirez gmail 
resolves previous 	dot copyright 
rule valid read 	oran agra 
returns success 	copyright redis 
name non ambiguous 	labs 
previous rules 	inc rights 
haven resolved valid 	reserved redistribution 
needswork use 	use source 
parse config key 	binary forms 
merged refname 	without modification 
namespaces used look 	permitted 
place dirname 	provided following 
would inserted extras 	conditions met 
entry position 	redistributions source 
starts dirname remember 	code must 
dirname includes 	retain copyright 
trailing slash skip 	notice 
conflict refs.h 	list conditions 
refname resolve 	following disclaimer 
flags sha flags 	redistributions binary 
refname resolve 	form must 
flags sha flags 	reproduce copyright 
refname resolve 	notice 
flags sha flags 	list conditions 
refname sha 	following disclaimer 
refname refname refname 	documentation materials 
sha path 	provided distribution 
refname sha abbrev 	neither name 
name full 	redis 
name str len 	names contributors 
sha str 	may used 
len sha data 	endorse promote 
data prefix 	products derived 
data prefix data 	software without 
broken data 	specific 
data data data 	prior written 
pattern data 	permission software 
pattern prefix 	provided copyright 
data submodule data 	holders contributors 
submodule data 	express implied 
submodule prefix data 	warranties 
submodule data 	including limited 
submodule data submodule 	implied warranties 
data data 	merchantability fitness 
data data pattern 	particular purpose 
msg fmt 	disclaimed shall 
refname msg fmt 	copyright 
refnames flags 	owner contributors 
refname force create 	liable direct 
err refname 	indirect incidental 
flags time cnt 	special exemplary 
sha msg 	consequential damages 
cutoff time cutoff 	including 
cutoff cnt 	limited procurement 
refname refname 	substitute goods 
old sha flags 	services loss 
refnames refname 	use data 
refname data refname 	profits business 
data refname 	interruption 
flags refname refname 	however caused 
strict oldref 	theory liability 
newref logmsg refname 	whether contract 
target logmsg 	strict liability 
err transaction refname 	tort including 
sha old 	negligence 
sha flags msg 	otherwise arising 
err transaction 	way use 
refname sha flags 	software even 
msg err 	advised possibility 
transaction refname old 	damage note 
sha flags 	sdshdr 
msg err transaction 	never used 
refname old 	access flags 
sha flags 	directly however 
err transaction err 	document layout 
transaction err 	type sds 
transaction update refname 	lsb 
sha flags 	type msb 
prepare prune cleanup 	length used 
policy data 	excluding header 
strpbrk resolve reference 	terminator lsb 
recursively following 	type unused 
symbolic refererences store 	bits 
referred name 	used excluding 
sha name non 	header terminator 
symbolic reference 	lsb type 
ultimately pointed pointer 	unused bits 
either buffer 	used excluding 
input reference cannot 	header 
resolved behavior 	terminator lsb 
depends resolve reading 	type unused 
flag resolve 	bits used 
reading resolve 	excluding header 
reading clear sha 	terminator lsb 
name last 	type 
reference name chain 	unused bits 
either non 	sdsalloc sdsavail 
symbolic reference undefined 	sdslen nothing 
reference prelude 	type total 
writing name actually 	allocation info 
created changed 	low 
resolve recurse flag 	level functions 
passed resolves 	exposed user 
one level symbolic 	api export 
reference stored 	allocator used 
sha symbolic reference 	sds program 
always sha 	sds 
reference symref refers 	sometimes program 
directly flags 	sds linked 
non points combination 	may use 
ispacked reference 	different allocators 
found among 	may want 
packed references issymref 	allocate 
initial reference 	free things 
symbolic reference bad 	sds respectively 
name reference 	free allocate 
name ill formed 	sds lib 
see resolve 	library copyright 
allow bad name 	salvatore 
isbroken malformed 	sanfilippo antirez 
bad name see 	gmail dot 
refs detail 	copyright oran 
flag properly formatted 	agra copyright 
normalized reference 	redis labs 
maxdepth recursive symbolic 	inc 
lookups needed 	rights reserved 
give resolve allow 	redistribution use 
bad name 	source binary 
allows resolving refs 	forms without 
even name 	modification permitted 
invalid according 	provided 
git check format 	following conditions 
name bad 	met redistributions 
stored sha sha 	source code 
two flags 	must retain 
isbroken bad name 	copyright 
even resolve 	notice list 
allow bad name 	conditions following 
names escape 	disclaimer redistributions 
refs directory consist 	binary form 
caps underscores 	must reproduce 
cannot resolved function 	copyright 
returns names 	notice list 
caps underscores refers 	conditions following 
special refs 	disclaimer documentation 
head fetch head 	materials provided 
friends live 	distribution neither 
outside refs 	name 
directory refname non 	redis names 
symbolic reference 	contributors may 
refers tag tag 	used endorse 
recursively dereferenced 	promote products 
non tag store 	derived software 
sha referred 	without 
sha conditions met 	specific prior 
non zero 	written permission 
symbolic references considered 	software provided 
unpeelable even 	copyright holders 
ultimately resolve peelable 	contributors express 
tag resolve 	implied 
refname nested gitlink 	warranties including 
repository located 	limited implied 
path resolution successful 	warranties merchantability 
sha name 	fitness particular 
otherwise non zero 	purpose disclaimed 
iff abbrev 	shall 
name possible 	copyright owner 
abbreviation full name 	contributors liable 
according rules 	direct indirect 
defined rev parse 	incidental special 
rules refs 	exemplary consequential 
transaction represents collection 	damages 
updates succeed 	including limited 
fail together calling 	procurement substitute 
sequence allocate 	goods services 
initialize transaction calling 	loss use 
transaction begin 	data profits 
list intended updates 	business 
calling functions 	interruption however 
like transaction update 	caused theory 
transaction create 	liability whether 
call transaction commit 	contract strict 
execute transaction 	liability tort 
succeeds updates taken 	including 
place transaction 	negligence otherwise 
cannot rolled 	arising way 
back instead transaction 	use software 
commit use 	even advised 
initial transaction commit 	possibility damage 
database known 	note 
empty clone likely 	sdshdr never 
much faster 	used access 
time call transaction 	flags directly 
free discard 	however document 
transaction free associated 	layout type 
resources particular 	sds 
rolls back transaction 	lsb type 
successfully committed 	msb length 
error handling error 	used excluding 
transaction functions 	header terminator 
append message went 	lsb type 
wrong err 	unused 
argument message mentions 	bits used 
updated error 	excluding header 
occurred passed 	terminator lsb 
die error message 	type unused 
appended err 	bits used 
without first clearing 	excluding 
err err 	header terminator 
terminated caveats note 	lsb type 
locks taken 	unused bits 
refs read transaction 	used excluding 
commit called 	header terminator 
transaction verify won 	lsb 
report verification 	type unused 
failure commit attempted 	bits sdsalloc 
bit values 	sdsavail sdslen 
flags argument passed 	nothing type 
reference symbolic 	total allocation 
reference reference packed 	info 
reference reference 	low level 
cannot resolved 	functions exposed 
name dangling symbolic 	user api 
reference directly 	export allocator 
indirectly corrupt reference 	used sds 
file reference 	program 
exists name bad 	sds sometimes 
symbolic reference 	program sds 
refers ill formatted 	linked may 
reference name 	use different 
reference name well 	allocators may 
formed see 	want 
git check format 	allocate free 
definition well 	things sds 
formed names signature 	respectively free 
callback function 	allocate sdsalloc.h 
functions memory pointed 	sds lib 
refname sha 	library 
arguments guaranteed valid 	copyright salvatore 
duration single 	sanfilippo antirez 
callback invocation 	gmail dot 
following functions invoke 	copyright redis 
specified callback 	labs inc 
function reference indicated 	rights 
function ever 	reserved redistribution 
returns nonzero stop 	use source 
iteration please 	binary forms 
note safe modify 	without modification 
references iteration 	permitted provided 
progress unless callback 	following 
function invocation 	conditions met 
modifies reference also 	redistributions source 
returns nonzero 	code must 
immediately stop iteration 	retain copyright 
used learn 	notice list 
broken symref flags 	conditions 
controlling behaviour 	following disclaimer 
pack refs pack 	redistributions binary 
refs prune 	form must 
prune loose 	reproduce copyright 
refs packing pack 	notice list 
refs pack 	conditions 
refs tags already 	following disclaimer 
packed refs 	documentation materials 
write packed refs 	provided distribution 
file current 	neither name 
repository flags combination 	redis names 
pack refs 	contributors 
flags flags controlling 	may used 
transaction update 	endorse promote 
transaction create etc 	products derived 
noderef act 	software without 
directly instead dereferencing 	specific prior 
symbolic references 	written 
flags reserved use 	permission software 
setup reflog 	provided copyright 
fill err failure 	holders contributors 
reads log 	express implied 
time check 	warranties including 
particular reflog exists 	limited 
specified reference 	implied warranties 
old sha non 	merchantability fitness 
verify current 	particular purpose 
reference old sha 	disclaimed shall 
deleting old 	copyright owner 
sha reference exists 	contributors 
regardless old 	liable direct 
error old sha 	indirect incidental 
sha flags 	special exemplary 
passed transaction specified 	consequential damages 
references problems 	including limited 
emit errors attempt 	procurement 
keep going 	substitute goods 
deletes done nothing 	services loss 
transaction reflog 	use data 
iterate reflog 	profits business 
entries calls specified 	interruption however 
function reflog 	caused 
file returns nonzero 	theory liability 
returns iff 	whether contract 
refname correct format 	strict liability 
refname according 	tort including 
rules described documentation 	negligence otherwise 
git check 	arising 
format txt refname 	way use 
allow onelevel 	software even 
flags accept one 	advised possibility 
level reference 	damage sds 
names refname refspec 	allocator selection 
pattern flags 	file 
allow single wildcard 	used order 
character refspec 	change sds 
leading repeated slashes 	allocator compile 
accepted rename 	time define 
success begin 	following defines 
reference transaction reference 	want 
transaction must 	use also 
freed calling transaction 	include alternate 
free reference 	allocator needed 
transaction updates following 	needed order 
four functions 	use libc 
reference check update 	allocator 
transaction common 	sds lib 
similar parameters transaction 	library copyright 
pointer open 	salvatore sanfilippo 
transaction obtained transaction 	antirez gmail 
begin refname 	dot copyright 
name reference affected 	redis 
flags flags 	labs inc 
affecting update passed 	rights reserved 
update noderef 	redistribution use 
means symbolic references 	source binary 
followed msg 	forms without 
message describing 	modification 
change reflog err 	permitted provided 
strbuf receiving 	following conditions 
description error might 	met redistributions 
occured functions 	source code 
make copies refname 	must retain 
msg caller 	copyright 
retains ownership parameters 	notice list 
functions success 	conditions following 
non zero failure 	disclaimer redistributions 
failure means 	binary form 
transaction whole failed 	must reproduce 
needs rolled 	copyright 
back reference update 	notice list 
transaction sha 	conditions following 
reference update sha 	disclaimer documentation 
deleted sha 	materials provided 
reference changed old 	distribution neither 
sha reference 	name 
must update 	redis names 
sha must existed 	contributors may 
beforehand old 	used endorse 
taken prevent races 	promote products 
old doesn 	derived software 
agree old sha 	without 
whole transaction 	specific prior 
fails old sha 	written permission 
previous see 	software provided 
comment reference transaction 	copyright holders 
updates information 	contributors express 
reference creation transaction 	implied 
sha reference 	warranties including 
update must sha 	limited implied 
verified reference 	warranties merchantability 
exist already see 	fitness particular 
comment reference 	purpose disclaimed 
transaction updates information 	shall 
reference deletion 	copyright owner 
transaction old 	contributors liable 
sha non holds 	direct indirect 
reference update 	incidental special 
must sha see 	exemplary consequential 
comment reference 	damages 
transaction updates information 	including limited 
verify within 	procurement substitute 
transaction refname old 	goods services 
sha old 	loss use 
sha sha verify 	data profits 
reference doesn 	business 
exist old sha 	interruption however 
must non 	caused theory 
see comment reference 	liability whether 
transaction updates 	contract strict 
information commit changes 	liability tort 
queued transaction 	including 
atomically possible 	negligence otherwise 
returns success one 	arising way 
error codes 	use software 
errors naming conflict 	even advised 
example names 	possibility damage 
conflict errors like 	sds 
transaction commit 	allocator selection 
optimized creating references 	file used 
originally initializing 	order change 
repository git clone 	sds allocator 
writes references 	compile time 
directly packed refs 	define 
without locking 	following defines 
individual references bug 	want use 
call function 	also include 
might processes accessing 	alternate allocator 
repository existing 	needed needed 
references might conflict 	order 
ones created 	use libc 
old sha 	allocator sds 
values must either 	lib library 
absent sha 	copyright salvatore 
free existing transaction 	sanfilippo antirez 
associated data 	gmail 
update unlock single 	dot copyright 
reference function 	redis labs 
basically transaction containing 	inc rights 
single call 	reserved redistribution 
transaction update parameters 	use source 
function meaning 	binary 
corresponding parameters transaction 	forms without 
update handle 	modification permitted 
errors requested onerr 	provided following 
argument check 	conditions met 
whether hidden first 	redistributions source 
second parameter 	code 
point full name 	must retain 
inside first 	copyright notice 
parameter pointer 	list conditions 
name prefix removed 	following disclaimer 
outside first 	redistributions binary 
parameter second parameter 	form 
always points 	must reproduce 
full name following 	copyright notice 
used reflog 	list conditions 
expiration caller calls 	following disclaimer 
reflog expire 	documentation materials 
supplying three callback 	provided 
functions following 	distribution neither 
types callback functions 	name redis 
define expiration 	names contributors 
policy desired reflog 	may used 
expiry prepare 	endorse promote 
called reference locked 	products 
reflog expiry 	derived software 
prune called entry 	without specific 
existing reflog 	prior written 
iff entry 	permission software 
pruned reflog expiry 	provided copyright 
cleanup called 	holders 
reference unlocked expire 	contributors express 
reflog entries 	implied warranties 
specified reference sha 	including limited 
old reference 	implied warranties 
flags combination constants 	merchantability fitness 
expire reflog 	particular 
flags three function 	purpose disclaimed 
pointers described 	shall copyright 
success zero refs 	owner contributors 
regcomp.c preg 	liable direct 
pattern length syntax 	indirect incidental 
bufp init 	special 
state fastmap dfa 	exemplary consequential 
pat len 	damages including 
cset preg 	limited procurement 
dfa dfa preg 	substitute goods 
preorder postorder 	services loss 
extra node extra 	use 
node err 	data profits 
preg node extra 	business interruption 
node extra 	however caused 
node extra node 	theory liability 
dfa idx 	whether contract 
constraint dfa node 	strict 
constraint dfa 	liability tort 
dfa node root 	including negligence 
dfa input 	otherwise arising 
token syntax function 	way use 
regexp preg 	software even 
syntax err regexp 	advised 
preg token 	possibility damage 
syntax nest err 	sds allocator 
regexp preg 	selection file 
token syntax 	used order 
nest err regexp 	change sds 
preg token 	allocator 
syntax nest err 	compile time 
regexp preg 	define following 
token syntax nest 	defines want 
err dup 	use also 
elem regexp dfa 	include alternate 
token syntax 	allocator 
err regexp dfa 	needed needed 
token syntax 	order use 
err elem regexp 	libc allocator 
token token 	sds lib 
len dfa syntax 	library copyright 
accept hyphen 	salvatore 
elem regexp token 	sanfilippo antirez 
sbcset mbcset 	gmail dot 
equiv alloc name 	copyright redis 
trans sbcset 	labs inc 
mbcset alloc 	rights reserved 
name syntax sbcset 	redistribution 
name trans 	use source 
sbcset name syntax 	binary forms 
dfa trans 	without modification 
name extra non 	permitted provided 
match err 	following conditions 
dfa left right 	met 
type dfa 	redistributions source 
left right token 	code must 
src dfa 	retain copyright 
node extra node 	notice list 
extra node 	conditions following 
attribute hidden attribute 	disclaimer 
hidden wtmp 	redistributions binary 
tmp pattern length 	form must 
bufp ret 	reproduce copyright 
syntax options syntax 	notice list 
ret bufp 	conditions following 
dfa fastmap 	disclaimer 
fastmap bufp init 	documentation materials 
state fastmap 	provided distribution 
dfa node cnt 	neither name 
icase node 	redis names 
type state cset 	contributors may 
table mbs 	used 
buf state preg 	endorse promote 
pattern cflags 	products derived 
ret syntax errcode 	software without 
preg errbuf 	specific prior 
errbuf size msg 	written permission 
msg size 	software 
utf map utf 	provided copyright 
map dfa 	holders contributors 
entry state preg 	express implied 
dfa comp 	warranties including 
buf ret 	limited implied 
fastmap preg pattern 	warranties 
length syntax 	merchantability fitness 
err dfa regexp 	particular purpose 
dfa pat 	disclaimed shall 
len table size 	copyright owner 
codeset name 	contributors liable 
utf map inited 	direct 
wch dfa 	indirect incidental 
preg dfa storage 	special exemplary 
next dfa 	consequential damages 
first err init 	including limited 
nodes node 	procurement substitute 
idx type clexp 	goods 
idx clexp 	services loss 
node dest idx 	use data 
err dfa 	profits business 
node period preg 	interruption however 
dfa ret 	caused theory 
postorder preorder 	liability 
extra node dfa 	whether contract 
idx idx 	strict liability 
extra node preg 	tort including 
err err 	negligence otherwise 
preg node dfa 	arising way 
body cls 	use 
extra node dfa 	software even 
extra node 	advised possibility 
extra node dfa 	damage sds 
idx err 	allocator selection 
left right dfa 	file used 
top node 	order 
top clone node 	change sds 
root node 	allocator compile 
init constraint node 	time define 
clone node 	following defines 
ret constraint dest 	want 
clone dest 	use also 
err dfa 	include alternate 
node constraint idx 	allocator needed 
dfa idx 	needed order 
constraint dup idx 	use libc 
dfa src 	allocator 
idx ret elems 	sdsalloc.h sds 
dfa node 	lib library 
idx incomplete err 	copyright salvatore 
eclosure elem 	sanfilippo antirez 
dfa node root 	gmail dot 
err eclosure 	copyright 
ret incomplete eclosure 	redis labs 
elem edest 	inc rights 
result input syntax 	reserved redistribution 
token input 	use source 
syntax prev next 	binary forms 
token input 	without 
syntax token len 	modification permitted 
regexp preg 	provided following 
syntax err 	conditions met 
dfa eor root 	redistributions source 
current token 	code must 
regexp preg token 	retain 
syntax nest 	copyright notice 
err dfa branch 	list conditions 
regexp preg 	following disclaimer 
token syntax nest 	redistributions binary 
err exp 	form must 
dfa regexp preg 	reproduce 
token syntax 	copyright notice 
nest err dfa 	list conditions 
mbc remain 	following disclaimer 
first last regexp 	documentation materials 
preg token 	provided distribution 
syntax nest err 	neither 
dfa cur 	name redis 
nsub elem regexp 	names contributors 
dfa token 	may used 
syntax err 	endorse promote 
old start end 	products derived 
start idx 	software 
start token start 	without specific 
token sbcset 	prior written 
mbcset range alloc 	permission software 
start elem 	provided copyright 
end elem start 	holders contributors 
end start 	express 
end cmp buf 	implied warranties 
start end 	including limited 
nranges sbcset mbcset 	implied warranties 
coll sym 	merchantability fitness 
alloc name name 	particular purpose 
len regexp 	disclaimed 
dfa token syntax 	shall copyright 
err collseqmb 	owner contributors 
collseqwc nrules 	liable direct 
table size symb 	indirect incidental 
table extra 	special exemplary 
name name len 	consequential 
hash elem 	damages including 
second elem sym 	limited procurement 
name len 	substitute goods 
elem idx mbcset 	services loss 
range alloc 	use data 
sbcset start elem 	profits 
end elem 	business interruption 
start collseq end 	however caused 
collseq start 	theory liability 
end nranges collseq 	whether contract 
mbcset coll 	strict liability 
sym alloc sbcset 	tort 
name elem 	including negligence 
idx name len 	otherwise arising 
coll sym 	way use 
alloc coll 	software even 
syms token sbcset 	advised possibility 
mbcset mbchar 	damage 
alloc alloc non 	sds allocator 
match work 	selection file 
token len first 	used order 
round start 	change sds 
elem end elem 	allocator compile 
start name 	time 
buf end name 	define following 
buf ret 	defines want 
range exp token 	use also 
mbchars mbc 	include alternate 
sbc idx elem 	allocator needed 
regexp token 	needed 
token len dfa 	order use 
syntax accept 	libc allocator 
hyphen cur size 	sds lib 
token elem 	library copyright 
regexp token 	salvatore sanfilippo 
delim sbcset mbcset 	antirez 
equiv alloc 	gmail dot 
name nrules table 	copyright redis 
indirect weights 	labs inc 
extra buf idx 	rights reserved 
idx len 	redistribution use 
cnt equiv alloc 	source 
equiv classes 	binary forms 
trans sbcset mbcset 	without modification 
alloc name 	permitted provided 
syntax alloc classes 	following conditions 
dfa trans 	met redistributions 
name extra non 	source 
match err 	code must 
sbcset mbcset alloc 	retain copyright 
ret token 	notice list 
mbc input token 	conditions following 
syntax num 	disclaimer redistributions 
cset dfa 	binary 
left right type 	form must 
dfa left 	reproduce copyright 
right token storage 	notice list 
extra node 	conditions following 
idx node extra 	disclaimer documentation 
node root 	materials 
dfa node dup 	provided distribution 
root dup 	neither name 
node prev mbtowc 	redis names 
compile gettext 	contributors may 
memset compile fastmap 	used endorse 
iter compile 	promote 
fastmap iter compile 	products derived 
fastmap iter 	software without 
compile fastmap iter 	specific prior 
fastmap memset 	written permission 
mbrtowc wcrtomb 	software provided 
towlower fastmap free 	copyright 
fastmap current 	holders contributors 
word current fastmap 	express implied 
memset mbrtowc 	warranties including 
fastmap memset wcrtomb 	limited implied 
fastmap wcrtomb 	warranties merchantability 
towlower fastmap memset 	fitness 
malloc compile 	particular purpose 
strlen compile fastmap 	disclaimed shall 
free abort 	copyright owner 
gettext strlen memcpy 	contributors liable 
memcpy free 	direct indirect 
token free node 	incidental 
free node 	special exemplary 
free node free 	consequential damages 
free free 	including limited 
free free free 	procurement substitute 
state free 	goods services 
free free 	loss 
free free free 	use data 
free dfa 	profits business 
content free free 	interruption however 
gettext regfree 	caused theory 
memset malloc gettext 	liability whether 
compile strlen 	contract 
gettext regfree realloc 	strict liability 
init dfa 	tort including 
free dfa content 	negligence otherwise 
malloc strncpy 	arising way 
libc init construct 	use software 
free workarea 	even 
compile destruct free 	advised possibility 
dfa content 	damage sds 
parse analyze optimize 	allocator selection 
utf create 	file used 
initial state free 	order change 
workarea compile 	sds 
destruct free 	allocator compile 
dfa content memset 	time define 
malloc calloc 	following defines 
strcmp current current 	want use 
word langinfo 	also include 
getenv getenv getenv 	alternate 
strchr strchr 	allocator needed 
calloc btowc isascii 	needed order 
isalnum free 	use libc 
free node init 	allocator sds 
copy node 	lib library 
contains node merge 	copyright 
acquire state 	salvatore sanfilippo 
context acquire state 	antirez gmail 
context acquire 	dot copyright 
state context acquire 	redis labs 
state context 	inc rights 
node free abort 	reserved 
malloc malloc 	redistribution use 
malloc malloc 	source binary 
malloc preorder free 	forms without 
postorder postorder 	modification permitted 
preorder preorder calc 	provided following 
eclosure malloc 	conditions 
calc inveclosure lower 	met redistributions 
subexp lower 	source code 
subexp create create 	must retain 
create create 	copyright notice 
dfa node node 	list conditions 
init node 	following 
init node init 	disclaimer redistributions 
epsilon node 	binary form 
node empty duplicate 	must reproduce 
node node 	copyright notice 
insert node empty 	list conditions 
node insert 	following 
duplicate node 	disclaimer documentation 
node insert node 	materials provided 
empty search 	distribution neither 
duplicated node duplicate 	name redis 
node node 	names contributors 
insert duplicate node 	may 
closure node 	used endorse 
insert duplicate node 	promote products 
node insert 	derived software 
dfa node node 	without specific 
init empty 	prior written 
node insert last 	permission 
calc eclosure 	software provided 
iter node free 	copyright holders 
node alloc 	contributors express 
duplicate node closure 	implied warranties 
epsilon node 	including limited 
calc eclosure iter 	implied 
node merge 	warranties merchantability 
node free 	fitness particular 
node insert skip 	purpose disclaimed 
bytes peek 	shall copyright 
token eoi peek 	owner contributors 
first cur 	liable 
idx cur idx 	direct indirect 
length peek 	incidental special 
wchar cur idx 	exemplary consequential 
wide word 	damages including 
word wchar cur 	limited procurement 
idx wide 	substitute 
word word cur 	goods services 
idx peek 	loss use 
cur idx length 	data profits 
skip bytes 	business interruption 
peek token skip 	however caused 
bytes eoi 	theory 
peek first cur 	liability whether 
idx cur 	contract strict 
idx length 	liability tort 
skip bytes peek 	including negligence 
cur idx 	otherwise arising 
length peek fetch 	way 
token parse 	use software 
reg exp create 	even advised 
create parse 	possibility damage 
branch fetch token 	sds allocator 
parse branch 	selection file 
create parse expression 	used 
parse expression 	order change 
create create token 	sds allocator 
eoi first 	compile time 
cur idx fetch 	define following 
token create 	defines want 
token create parse 	use 
sub exp 	also include 
parse bracket exp 	alternate allocator 
create token 	needed needed 
fetch token 	order use 
parse expression create 	libc allocator 
token init 	sds 
word create token 	lib library 
create token 	copyright salvatore 
create token create 	sanfilippo antirez 
create token 	gmail dot 
fetch token create 	copyright redis 
token build 	labs 
charclass build charclass 	inc rights 
fetch token 	reserved redistribution 
parse dup fetch 	use source 
token parse 	binary forms 
reg exp create 	without modification 
cur idx 	permitted 
memcpy fetch number 	provided following 
fetch number 	conditions met 
index fetch token 	redistributions source 
postorder duplicate 	code must 
create duplicate 	retain copyright 
postorder create duplicate 	notice 
create create 	list conditions 
create strlen strlen 	following disclaimer 
btowc btowc 	redistributions binary 
wcscoll realloc realloc 	form must 
wcscoll wcscoll 	reproduce copyright 
bitset bitset strlen 	notice 
bitset elem 	list conditions 
hash memcmp btowc 	following disclaimer 
collseq table 	documentation materials 
lookup collseq table 	provided distribution 
lookup strlen 	neither name 
seek collating symbol 	redis 
entry lookup 	names contributors 
collation sequence lookup 	may used 
collation sequence 	endorse promote 
realloc realloc 	products derived 
collseq table lookup 	software without 
btowc bitset 	specific 
strlen seek collating 	prior written 
symbol entry 	permission software 
bitset realloc bitset 	provided copyright 
current current 	holders contributors 
word current current 	express implied 
word current 	warranties 
current calloc calloc 	including limited 
peek token 	implied warranties 
bracket bitset skip 	merchantability fitness 
bytes peek 	particular purpose 
token bracket parse 	disclaimed shall 
bracket element 	copyright 
peek token bracket 	owner contributors 
skip bytes 	liable direct 
peek token bracket 	indirect incidental 
skip bytes 	special exemplary 
parse bracket 	consequential damages 
element peek token 	including 
bracket build 	limited procurement 
range exp build 	substitute goods 
range exp 	services loss 
build range exp 	use data 
bitset realloc 	profits business 
build equiv build 	interruption 
collating symbol 	however caused 
build charclass skip 	theory liability 
bytes bitset 	whether contract 
bitset mask create 	strict liability 
token create 	tort including 
token create free 	negligence 
free charset 	otherwise arising 
create token free 	way use 
free charset 	software even 
size cur idx 	advised possibility 
wchar cur 	damage sds 
idx skip 	allocator 
bytes skip bytes 	selection file 
parse bracket 	used order 
symbol peek token 	change sds 
bracket eoi 	allocator compile 
fetch fetch eoi 	time define 
peek skip 	following 
bytes current word 	defines want 
current current 	use also 
current current findidx 	include alternate 
strlen findidx 	allocator needed 
bitset realloc strlen 	needed order 
bitset strcmp 	use 
strcmp realloc wctype 	libc allocator 
strcmp build 	sentinel.c environ 
charclass loop strcmp 	myid current 
build charclass 	epoch masters 
loop strcmp build 	tilt running 
charclass loop 	scripts 
strcmp build 	tilt start 
charclass loop strcmp 	time previous 
build charclass 	time scripts 
loop strcmp build 	queue announce 
charclass loop 	announce port 
strcmp build charclass 	simfailure 
loop strcmp 	flags privdata 
build charclass loop 	mask privdata 
strcmp build 	mask privdata 
charclass loop build 	loop privdata 
charclass loop 	loop privdata 
calloc calloc build 	loop 
charclass free 	privdata loop 
free charset bitset 	privdata loop 
bitset bitset 	status status 
mask create token 	reply privdata 
create token 	name master 
create free 	master 
charset free free 	level type 
charset fetch 	fmt master 
token free free 	path master 
free free 	reply privdata 
free free free 	host port 
create token 	master 
malloc free charset 	req epoch 
free free 	req runid 
token create token 	leader epoch 
extended regular 	master instances 
expression matching search 	port runid 
library copyright 	key 
free software foundation 	privdata key 
inc file 	key privdata 
part gnu library 	obj instances 
contributed isamu 	dict type 
hasegawa isamu yamato 	leader votes 
ibm gnu 	dict 
library free 	type sentinelcmds 
software redistribute modify 	retval cmd 
terms gnu 	hostname port 
lesser general license 	src level 
published free 	type fmt 
software foundation either 	msg 
version license 	channel payload 
option later version 	master master 
gnu library 	path argv 
distributed hope useful 	argc pid 
without warranty 	pid retry 
without even implied 	num 
warranty merchantability 	delay statloc 
fitness particular purpose 	pid exitcode 
see gnu 	bysignal delay 
lesser general license 	master role 
details received 	state fromport 
copy gnu lesser 	toport 
general license 	link link 
along gnu 	link callbacks 
library write free 	match reconfigured 
software foundation 	match link 
inc franklin street 	pubsub status 
fifth floor 	status 
boston usa enable 	name flags 
enable enable 	hostname port 
table gives error 	quorum master 
message error 	addr table 
codes listed regex 	slavename sdsname 
obviously order 	port 
posix doesn require 	key slave 
anything reg 	buf master 
noerror nice reg 	runid removed 
noerror reg 	instances port 
nomatch reg badpat 	runid instance 
reg ecollate 	name 
reg ectype reg 	sdsname instances 
eescape reg 	flags instances 
esubreg reg 	flags flags 
ebrack reg eparen 	pattern flags 
reg ebrace 	reset 
reg badbr reg 	master port 
erange reg 	oldaddr newaddr 
espace reg badrpt 	slaves slave 
reg eend 	slave recent 
reg esize reg 	master master 
erparen entry 	argv 
points gnu code 	argc quorum 
zos uss 	current epoch 
must define btowc 	slave state 
compile pattern 	line master 
gnu regular expression 	master addr 
compiler compiles 	slave 
pattern length length 	addr saved 
puts result 	rewrite status 
bufp returns 	auth pass 
pattern valid otherwise 	type name 
error assumes 	link retval 
allocated perhaps buffer 	master 
translate fields 	info lines 
bufp entry gnu 	numlines role 
code determines 	slave port 
whether information passing 	end slave 
regs argument 	master port 
match etc setting 	wait 
sub unless 	time retval 
sub match anchors 	wait time 
newline syntax 	retval reply 
current regexp syntax 	privdata link 
recognize also 	reply privdata 
assigned arbitrarily pattern 	link 
buffer stores 	reply privdata 
syntax changed regex 	link reply 
compilations initializer 	privdata link 
initialized variables 	hello hello 
emacs become read 	len numtokens 
dumping specify 	port 
precise syntax regexps 	removed master 
compilation provides 	port current 
compatibility various utilities 	epoch master 
historically different 	config epoch 
incompatible syntaxes argument 	token master 
syntax bit 	old 
mask comprised various 	addr reply 
bits defined 	privdata payload 
regex old syntax 	retval announce 
helper function 	announce port 
compile fastmap compile 	master master 
fastmap initial 	addr 
state init state 	instances master 
see bytes 	retval info 
start multiple collation 	period ping 
elements want 	period retval 
since valid 	state flags 
collation element since 	mbl 
collation element 	fields instances 
starts caught simple 	name master 
bracket libc 	usableptr usable 
see start match 	result voters 
multibyte characters 	req epoch 
would find invalid 	leader 
sequence applies 	epoch leader 
multibyte character sets 	port isdown 
single character 	addr quorum 
sets simple bracket 	port usable 
suffices libc 	result copy 
bytes start mbchars 	keeper 
enable enable 	masters local 
entry point posix 	sdi sde 
code regcomp 	sri allsections 
takes regular expression 	section sections 
compiles preg 	info master 
regex expect 	status 
fields initialized since 	changes option 
posix says 	elapsed master 
shouldn thus buffer 	odown reply 
compiled pattern 	privdata link 
used length compiled 	master flags 
pattern syntax 	elapsed 
syntax posix extended 	port retval 
reg extended 	master req 
bit cflags otherwise 	epoch req 
syntax posix 	runid leader 
basic newline anchor 	epoch runid 
reg newline 	votes 
cflags fastmap allocated 	counters runid 
space fastmap 	oldval master 
fastmap accurate zero 	epoch counters 
nsub number 	voters quorum 
subexpressions pattern pattern 	myvote winner 
address pattern 	leader 
cflags series 	epoch max 
bits affect compilation 	votes votes 
reg extended 	votes host 
use posix extended 	port portstr 
syntax otherwise 	retval master 
use posix basic 	master 
syntax reg 	clock ctimebuf 
newline match newline 	runid runid 
also regexec 	master instance 
match beginning every 	selected instances 
newline reg 	max master 
icase considers upper 	time 
lowercase versions 	slave info 
letters equivalent matching 	validity time 
reg nosub 	leader isleader 
preg passed regexec 	election timeout 
routine report 	slave retval 
success failure 	master 
nothing registers returns 	timeout elapsed 
succeeds nonzero 	slave slave 
doesn see regex 	retval master 
codes meanings 	progress slave 
allocate space fastmap 	slave retval 
reg newline 	master 
newlines treated differently 	instances promoted 
reg newline 	delta redis 
implies neither match 	handle read 
newline also 	redis handle 
changes matching behavior 	write create 
posix doesn 	file 
distinguish unmatched open 	file create 
unmatched close 	file file 
reg eparen already 	redis del 
preg fastmap 	read redis 
compute fastmap since 	del write 
regexec cannot 	zfree 
modify pattern 	zmalloc unused 
buffer function never 	release sentinel 
fails implementation 	redis instance 
error occurred compiling 	dict empty 
expression returns 	dict sdsnew 
message corresponding error 	server 
code errcode 	dict create 
returned either regcomp 	mstime list 
regexec use 	create memset 
preg error codes 	server log 
returned rest 	exit access 
code passed routine 	server 
given anything 	log strerror 
regex code generates 	exit random 
invalid error 	hex chars 
code program bug 	sentinel flush 
dump core 	config server 
fix includes used 	log 
map single 	sentinel generate 
characters utf 	initial monitor 
used otherwise would 	events anet 
allocate memory 	resolve zmalloc 
initialize time utf 	sdsnew zmalloc 
preferred encoding 	sdsnew 
worthwhile optimization first 	sdsfree zfree 
bits gnuc 	strcasecmp snprintf 
gnuc enable free 	sentinel redis 
dynamically allocated 	instance type 
space used preg 	str snprintf 
entry points 	sentinel 
compatible bsd regex 	redis instance 
library define 	type str 
unless specifically requested 	start vsnprintf 
bsd one 	strlen strlen 
one pattern buffer 	end server 
make definitions 	log 
weak libc posix 	create strlen 
programs redefine 	create strlen 
names use 	pubsub publish 
functions still use 	message decr 
regcomp regexec 	count decr 
without link errors 	count 
since exec 	sentinel schedule 
always passes regs 	script execution 
argument need 	dict iterator 
initialize pattern buffer 	dict next 
fields affect 	dict val 
match anchors newlines 	sentinel 
yes discarding 	dict release 
libintl regex comp 	iterator sdsfree 
entry point 	zfree zfree 
compile regular expression 	start arg 
pattern whose 	sdsnew end 
length length syntax 	sdsnew 
indicate regular 	zmalloc zmalloc 
expression syntax 	memcpy list 
initialize pattern buffer 	node tail 
initialize dfa 	list length 
zero allocated buffer 	list rewind 
non realloc 	list 
enough space loses 	next list 
buffer address 	del node 
bogus user responsibility 	sentinel release 
buffer simple 	script job 
allocation note length 	server list 
overflow since 	length 
init dfa parse 	list rewind 
regular expression 	list next 
build structure analyze 	mstime list 
create nfa 	rewind list 
possible searching single 	next mstime 
encoding speed 	fork 
things create initial 	sentinel execve 
state dfa 	exit sentinel 
release work 	wait wexitstatus 
areas initialize dfa 	wifsignaled wtermsig 
use length 	sentinel sentinel 
regular expression pat 	script 
len initial 	list node 
length arrays force 	pid server 
allocation str 	log mstime 
storage first time 	sentinel script 
avoid overflows 	retry delay 
table size ceil 	sentinel 
log pat 	list del 
len strcasecmp isn 	node sentinel 
standard brute 	release script 
force check check 	job mstime 
exhaustively loop 	list rewind 
charset superset ascii 	list 
bits corresponding 	next sentinel 
single chars initialize 	kill reply 
word table 	multi bulk 
indicate character 	len list 
word word means 	length list 
word construction 	rewind 
character used operators 	list next 
like etc 	reply multi 
free work area 	bulk len 
used compiling 	reply bulk 
create initial states 	reply multi 
contexts initial 	bulk 
states epsilon closure 	len reply 
node first 	bulk reply 
node regular expression 	bulk reply 
back references 	bulk reply 
initial states epsilon 	bulk reply 
transit since 	bulk 
subexpressions epsilon closures 	reply bulk 
nodes next 	reply bulk 
nodes back references 	mstime mstime 
must first 	reply bulk 
time invoke 	reply bulk 
acquire state check 	reply 
err since 	bulk reply 
initial state must 	bulk sentinel 
possible searching 	schedule script 
single encoding instead 	execution zmalloc 
utf speed 	mstime mstime 
things dfa cur 	mstime 
max clear 	redis free 
utf change dfa 	server instance 
nodes needed 	link close 
word anchors etc 	connection instance 
cannot handled 	link close 
okay test opr 	connection 
ctx type 	zfree server 
since constraints dfa 	dict iterator 
nodes created 	dict next 
ring one 	dict val 
opr ctx type 	sentinel redis 
values check 	instance 
non ascii range 	addr run 
starts search 	release instance 
single locale analyze 	link dict 
structure calculate 	release iterator 
first next edest 	server dict 
eclosure inveclosure 	iterator 
allocate arrays need 	dict next 
prune impossible 	dict val 
nodes pass regexec 	sentinel redis 
skip run 	instance addr 
calc inveclosure quadratic 	run instance 
parse trees 	link 
unbalanced cannot use 	close connection 
stack implement 	instance link 
parse visits instead 	close connection 
use parent 	release sentinel 
pointers hairy 	addr dup 
code two functions 	sentinel 
descend preferably 	addr dict 
left right child 	release iterator 
node reached 	sentinel instance 
right left node 	link connection 
right optimization 	error unused 
pass subexp entirely 	instance 
contained strip 	link connection 
tell search map 	error server 
inner one 	server create 
opr idx one 	sentinel addr 
adjust backreferences 	anet format 
well requires preorder 	addr 
visit lowering 	sdsnew dict 
pass turn subexp 	find release 
node appropriate 	sentinel addr 
concatenation open subexp 	sdsfree zmalloc 
body subexp 	create instance 
close subexp 	link 
optimize empty subexpressions 	mstime mstime 
otherwise may 	mstime dict 
bad concat nodes 	create dict 
children obviously 	create mstime 
common lose much 	mstime dict 
example triggers 	dict 
sed script convert 	release dict 
subexp node 	release release 
concatenation open subexp 	instance link 
contents close 	sdsfree sdsfree 
subexp pass building 	sdsfree sdsfree 
nfa compute 	sdsfree 
first create unlinked 	sdsfree sdsfree 
automaton nodes 	sdsfree release 
requires postorder visit 	sentinel addr 
pass compute 	zfree server 
next preorder visit 	anet format 
pass link 	addr 
dfa nodes 	sdsnew dict 
next node order 	fetch sdsfree 
duplicate epsilon 	dict safe 
closure node root 	iterator dict 
node note 	next dict 
duplicated nodes constraint 	val 
init constraint 	strcmp dict 
addition constraint back 	dict release 
reference epsilon 	iterator server 
transit destination must 	dict iterator 
also constraint 	dict next 
duplicate epsilon closure 	dict 
destination back 	val strcmp 
reference store edests 	strcmp dict 
back reference 	release iterator 
node epsilon transit 	sdsnew dict 
duplicate destination 	fetch sdsfree 
store original destination 	dict 
destination node 	iterator dict 
node epsilon 	next dict 
transit one destination 	val dict 
node root 	release iterator 
node means epsilon 	dict iterator 
clsoure loop 	dict 
tie destination root 	next dict 
node node 	val dict 
another constraint dfa 	release iterator 
edests node 	server dict 
nelem node epsilon 	release dict 
transit two 	create 
destinations bin dfa 	dict release 
search duplicated 	dict create 
node satisfies constraint 	instance link 
duplicated node 	close connection 
create one duplicated 	instance link 
node satisfies 	close 
constraint use 	connection sdsfree 
avoid infinite loop 	sdsfree sdsfree 
search node 	mstime mstime 
duplicated node node 	mstime mstime 
satisfies constraint 	sentinel dict 
constraint found found 	iterator 
duplicate node 	dict next 
whose index idx 	dict val 
constraint constraint 	stringmatch sentinel 
index node insufficient 	reset master 
storage available 	dict release 
store index original 	iterator 
node calculate 	create sentinel 
eclosure node dfa 	addr dict 
nodes calculate 	iterator dict 
epsilon closure already 	next dict 
calculated skip 	val sentinel 
calculate epsilon closure 	addr 
node idx 	equal zrealloc 
calculate epsilon 	create sentinel 
closure node indicates 	addr dict 
calculating node 	release iterator 
reference avoid infinite 	sentinel addr 
loop current 	equal 
node constraints duplicate 	zrealloc create 
nodes since 	sentinel addr 
must inherit constraints 	sentinel reset 
expand epsilon 	master create 
destination nodes calculating 	sentinel redis 
epsilon closure 	instance 
edest progress intermediate 	release sentinel 
result haven 	addr sentinel 
calculated epsilon closure 	zfree release 
edest yet 	sentinel addr 
calculate otherwise use 	sentinel flush 
calculated epsilon 	config 
closure merge epsilon 	mstime dict 
closure edest 	iterator dict 
epsilon closure 	next dict 
edest incomplete epsilon 	val dict 
closure node 	release iterator 
also incomplete epsilon 	strcasecmp 
closure includes 	atoi create 
functions token used 	sentinel redis 
parser fetch 	instance atoi 
token input must 	strcasecmp sentinel 
use function 	master name 
inside bracket expressions 	atoi 
peek token 	sentinel propagate 
input length token 	period strcasecmp 
must use 	sentinel master 
function inside bracket 	name atoi 
expressions peek 	strcasecmp sentinel 
token input length 	master 
token must 	name atoi 
use function bracket 	strcasecmp sentinel 
expressions enable 	master name 
escape character 	access sdsnew 
special bracket exps 	strcasecmp sentinel 
fall functions 	master 
parser entry point 	name access 
parser parse 	sdsnew strcasecmp 
regular expression regexp 	sentinel master 
structure error 	name sdsnew 
occurred err error 	strcasecmp strtoull 
code function 	strcasecmp 
build following regular 	strlen memcpy 
expression reg 	strcasecmp sentinel 
exp cat reg 	master name 
exp eor 	strtoull strcasecmp 
cat means concatenation 	sentinel master 
eor means 	name 
end regular expression 	strtoull strcasecmp 
function build 	sentinel master 
following regular 	name create 
expression branch branch 	sentinel redis 
alt branch 	instance atoi 
branch alt means 	strcasecmp 
alternative represents 	sentinel master 
function build following 	name create 
regular expression 	sentinel redis 
exp exp cat 	instance atoi 
exp exp 	sdsnew sentinel 
cat means concatenation 	connection 
otherwise exp 	sharing strcasecmp 
need create function 	strlen sdsnew 
build following 	strcasecmp atoi 
regular expression fallthrough 	sdscatprintf sdsempty 
fall fall 	rewrite 
treat normal character 	config rewrite 
characters normal 	line dict 
characters word bits 	iterator dict 
initialized already 	next dict 
peek token 	val sentinel 
must since ancho 	current 
followed repetition 	master address 
operators invalid anchor 	sdscatprintf sdsempty 
must anchor 	rewrite config 
repeat must happen 	rewrite line 
bre consecutive 	sdscatprintf sdsempty 
duplications allowed function 	rewrite 
build following 	config rewrite 
regular expression reg 	line sdscatprintf 
exp subexp 	sdsempty rewrite 
reg exp subexpression 	config rewrite 
may function 	line sdscatprintf 
parse repetition operators 	sdsempty 
like etc 	rewrite config 
treat invalid treat 	rewrite line 
invalid sequence 	sdscatprintf sdsempty 
syntax bit rollback 	rewrite config 
word bits 	rewrite line 
already initialized 	sdscatprintf 
peek token first 	sdsempty rewrite 
number greater 	config rewrite 
second extract duplicate 	line sdscatprintf 
elem marked 	sdsempty rewrite 
optional loop actually 	config rewrite 
executed end 	line 
rewrite already created 	sdscatprintf sdsempty 
start copy 	rewrite config 
size names collating 	rewrite line 
symbol equivalence 	sdscatprintf sdsempty 
character sure maybe 	rewrite config 
enough local 	rewrite 
function parse bracket 	line dict 
exp used 	iterator dict 
libc build range 	next dict 
expression starts 	val sentinel 
start elem ends 	addr equal 
end elem 	sdscatprintf 
result written 	sdsempty rewrite 
mbcset sbcset range 	config rewrite 
alloc allocated 	line dict 
size mbcset range 	release iterator 
starts mbcset 	dict iterator 
range ends pointer 	dict 
argument since 	next dict 
may update enable 	val sdscatprintf 
enable equivalence 	sdsempty rewrite 
classes character classes 	config rewrite 
range start 	line dict 
end handle multi 	release 
character collating 	iterator sdscatprintf 
elements without libc 	sdsempty rewrite 
support fedora 	config rewrite 
core maybe others 	line sdsnew 
broken btowc 	sdscatrepr sdslen 
returns sigh note 	rewrite 
start end 	config rewrite 
sign extension 	line sdscatprintf 
problems got valid 	sdsempty rewrite 
collation sequence 	config rewrite 
values entry however 	line dict 
libc collation 	release 
elements character single 	iterator rewrite 
single character 	config open 
build suffices parse 	fsync close 
bracket exp 	close server 
passes mbcset dfa 	log strerror 
cur max 	redis 
check space arrays 	command snprintf 
enough space 	redis command 
need realloc mbcset 	mstime redis 
nranges use 	connect bind 
realloc since mbcset 	sentinel instance 
range starts 	link 
mbcset range 	close connection 
ends range alloc 	mstime redis 
build table 	attach redis 
single characters enable 	connect callback 
build table 	redis disconnect 
single characters enable 	callback 
libc helper 	sentinel send 
function parse bracket 	auth needed 
exp used 	sentinel client 
libc build collating 	name sentinel 
element represented 	send ping 
name result written 	redis 
mbcset sbcset 	connect bind 
coll sym alloc 	sentinel instance 
allocated size 	link close 
mbcset coll sym 	connection mstime 
pointer argument 	redis attach 
since may update 	redis 
enable enable 	connect callback 
libc function 	redis disconnect 
parse bracket expression 	callback sentinel 
like abc 	send auth 
etc local function 	needed sentinel 
parse bracket 	client 
exp used libc 	name redis 
environment seek 	command instance 
collating symbol entry 	link close 
correspondings name 	connection mstime 
index symbol symb 	sdsfree sdsnew 
table first 	sdssplitlen 
compare hashing compare 	strlen sdslen 
length name 	memcmp sdsnewlen 
compare name yep 	strncmp sentinel 
entry next 	sdsfree sdsnewlen 
entry local function 	sdslen memcmp 
parse bracket 	isdigit 
exp used libc 	strstr strchr 
environment look 	strchr strchr 
collation sequence 	strstr strstr 
elem succeeded max 	strchr strchr 
otherwise cur 	sentinel redis 
max found entry 	instance 
skip name 	lookup slave 
collating element name 	atoi create 
skip sequence 	sentinel redis 
collating element adjust 	instance atoi 
alignment skip 	sentinel sentinel 
multibyte collation sequence 	flush 
skip wide 	config sdslen 
sequence collating element 	memcmp strtoll 
collation sequence 	memcmp memcmp 
valid character match 	sdslen memcmp 
single character 	strcasecmp sdsfree 
local function parse 	sdsnew 
bracket exp 	mstime sdslen 
used libc environment 	memcmp atoi 
build range 	mstime sdslen 
expression starts 	memcmp strcasecmp 
start elem ends 	sdslen memcmp 
end elem 	atoi 
result written mbcset 	sdslen memcmp 
sbcset range 	strtoull mstime 
alloc allocated size 	sdsfreesplitres mstime 
mbcset range 	mstime sentinel 
starts mbcset range 	mstime sentinel 
ends pointer 	flush 
argument since may 	config sentinel 
update equivalence 	sentinel sim 
classes character classes 	failure crash 
range start 	sentinel sentinel 
end check start 	call client 
end collation 	reconf 
sequence values got 	script sentinel 
valid collation 	force hello 
sequence values 	update master 
entry however collation 	sentinel master 
elements character 	looks sane 
single single character 	sentinel 
build suffices 	redis instance 
check space arrays 	mstime sentinel 
enough space 	send slave 
need realloc mbcset 	sentinel strcasecmp 
nranges build 	sentinel master 
table single characters 	looks 
cur max 	sane sentinel 
local function parse 	redis instance 
bracket exp 	mstime sentinel 
used libc environment 	send slave 
build collating 	sentinel strcmp 
element represented name 	sentinel 
result written 	sentinel sentinel 
mbcset sbcset coll 	refresh instance 
sym alloc 	info unused 
allocated size 	unused strncmp 
mbcset coll sym 	strncmp strncmp 
pointer argument 	mstime 
since may update 	strncmp redis 
found entry 	command mstime 
skip name collating 	mstime sdssplitlen 
element name 	sentinel master 
valid character treat 	name atoi 
normal character 	atoi 
got valid collation 	sentinel redis 
sequence entry 	instance addr 
check space arrays 	run strtoull 
enough realloc 	strtoull matching 
mbcset ncoll syms 	sentinel master 
use realloc 	sentinel 
since mbcset coll 	sentinel redis 
syms alloc 	instance addr 
enable cur max 	run sentinel 
enable enable 	sentinel update 
enable skip 	sentinel address 
token treat first 	masters 
normal character 	create sentinel 
information next token 	redis instance 
need check 	sentinel sdsnew 
ranges know allowed 	sentinel connection 
skip treat 	sharing sentinel 
last normal character 	update 
enable check 	sentinel address 
whether enough space 	masters sentinel 
enough realloc 	flush config 
mbcset nmbchars use 	sentinel flush 
realloc since 	config sentinel 
alloc enable enable 	strcmp 
enable enable 	sentinel sentinel 
skip token non 	dup sentinel 
matching list 	addr sentinel 
ensure single characters 	reset master 
build complex 	change address 
bracket bits 	sentinel 
sbcset point simple 	call client 
bracket complex 	reconf script 
bracket build simple 	release sentinel 
bracket alt 	addr mstime 
node enable build 	sdsfreesplitres unused 
simple bracket 	mstime 
enable parse element 	strcmp strstr 
bracket expression 	sentinel process 
enable skip token 	hello message 
must appear 	sentinel current 
anything range indicator 	master address 
closing bracket 	anet 
everything error actual 	sock name 
error standardized 	snprintf redis 
since whole undefined 	command dict 
erange makes 	safe iterator 
good sense 	dict next 
parse bracket symbol 	dict 
bracket expression 	val dict 
bracket symbols character 	release iterator 
collating element 	sentinel force 
equivalent helper function 	hello update 
parse bracket 	dict redis 
exp build equivalence 	instances 
represented name 	sentinel force 
result written mbcset 	hello update 
sbcset equiv 	dict redis 
alloc allocated size 	instances redis 
mbcset equiv 	command mstime 
classes pointer argument 	mstime 
since may 	redis command 
update enable enable 	sentinel send 
include defines 	ping sentinel 
local function calculate 	send hello 
index equivalence 	sdsempty deferred 
isn valid 	multi 
character build single 	bulk length 
matcing table 	reply bulk 
equivalence idx table 	reply bulk 
isn valid 	reply bulk 
character compare length 	reply bulk 
matches collation 	reply 
rule index check 	bulk reply 
whether enough 	bulk reply 
space enough realloc 	bulk reply 
mbcset nequiv 	bulk reply 
classes use realloc 	bulk sdscat 
since alloc 	sdscat 
libc helper function 	sdscat sdscat 
parse bracket 	sdscat sdscat 
exp build character 	sdscat sdscat 
represented name 	sdscat sdscat 
result written mbcset 	sdscat sdscat 
sbcset alloc 	sdslen 
allocated size 	sdsrange reply 
mbcset classes pointer 	bulk sdsfree 
argument since 	reply bulk 
may update enable 	reply bulk 
enable reg 	reply bulk 
icase upper lower 	reply 
match upper 	bulk reply 
lower cases check 	bulk reply 
space arrays 	bulk sentinel 
enough realloc mbcset 	failover state 
nchar classes 	str reply 
use realloc since 	bulk 
alloc enable 	reply bulk 
see comments enable 	mstime reply 
enable enable 	bulk reply 
enable enable care 	bulk mstime 
syntax enable 	reply bulk 
enable match also 	reply 
non matching 	bulk mstime 
list ensure 	reply bulk 
single characters build 	reply bulk 
simple bracket 	mstime reply 
build complex bracket 	bulk reply 
alt node 	bulk 
enable enable enable 	mstime reply 
intended expressions 	bulk reply 
like fetch number 	bulk reply 
input number 	bulk reply 
number field empty 	bulk mstime 
like error 	reply 
occurred enable functions 	bulk reply 
binary operation 	bulk reply 
create node mark 	bulk reply 
src optional 	bulk mstime 
subexpression called preorder 	reply bulk 
postorder free 	reply 
allocated memory inside 	bulk reply 
node enable 	bulk reply 
worker function 	bulk dict 
walking free allocated 	size reply 
memory inside 	bulk reply 
node children duplicate 	bulk 
node src 	dict size 
node preorder visit 	reply bulk 
similar one 	reply bulk 
implemented visitor need 	reply bulk 
infrastructure maintain 	reply bulk 
two parallel trees 	reply 
easier duplicate 	bulk reply 
create link back 	bulk reply 
current parent 	bulk reply 
left node right 	bulk reply 
regex.c max 	bulk reply 
failures extended regular 	bulk 
expression matching 	reply bulk 
search library 	reply bulk 
copyright free software 	reply bulk 
foundation inc 	reply bulk 
file part gnu 	reply bulk 
library contributed 	reply 
isamu hasegawa isamu 	bulk reply 
yamato ibm 	bulk reply 
gnu library free 	bulk reply 
software redistribute 	bulk reply 
modify terms gnu 	bulk reply 
lesser general 	bulk 
license published free 	reply bulk 
software foundation 	reply bulk 
either version license 	reply bulk 
option later 	mstime reply 
version gnu library 	bulk reply 
distributed hope 	bulk 
useful without warranty 	reply bulk 
without even 	reply bulk 
implied warranty 	deferred multi 
merchantability fitness particular 	bulk length 
purpose see 	dict iterator 
gnu lesser general 	reply 
license details 	multi bulk 
received copy gnu 	len dict 
lesser general 	size dict 
license along gnu 	next dict 
library write 	val reply 
free software foundation 	sentinel 
inc franklin 	redis instance 
street fifth floor 	dict release 
boston usa 	iterator dict 
make sure one 	fetch reply 
compiles code 	error dict 
compiler keep clean 	size 
size systems 	dict iterator 
limits sets dup 	dict next 
max lower 	dict val 
gnu regex 	dict release 
allows include regex 	iterator strcasecmp 
correctly undefs 	reply 
dup max sets 	dict redis 
right binary 	instances strcasecmp 
backward compatibility regex.h 	sentinel master 
syntax options 	name reply 
nsub num regs 	error reply 
start end 	sentinel 
syntax pattern length 	redis instance 
buffer buffer 	strcasecmp sentinel 
buffer cstring length 	master name 
start range 	reply error 
regs buffer length 	reply dict 
length start 	redis 
range regs stop 	instances strcasecmp 
buffer cstring 	sentinel master 
length start regs 	name reply 
buffer length 	error reply 
length start 	dict redis 
regs stop buffer 	instances 
regs num 	strcasecmp reply 
regs starts ends 	reply sentinel 
preg pattern 	redis instance 
cflags preg cstring 	addr run 
nmatch pmatch 	strcasecmp sentinel 
eflags errcode preg 	vote 
errbuf errbuf 	leader reply 
size preg definitions 	multi bulk 
data structures 	len reply 
routines regular expression 	reply bulk 
library copyright 	reply sdsfree 
free software foundation 	strcasecmp 
inc file 	reply sentinel 
part gnu library 	reset masters 
gnu library 	pattern strcasecmp 
free software 	sentinel master 
redistribute modify terms 	name reply 
gnu lesser 	sentinel 
general license published 	current master 
free software 	address reply 
foundation either version 	multi bulk 
license option 	len reply 
later version gnu 	bulk reply 
library distributed 	bulk 
hope useful without 	strcasecmp sentinel 
warranty without 	master name 
even implied warranty 	reply error 
merchantability fitness 	reply sds 
particular purpose see 	sdsnew sentinel 
gnu lesser 	slave 
general license details 	reply sds 
received copy 	sdsnew server 
gnu lesser general 	log sentinel 
license along 	start failover 
gnu library 	reply strcasecmp 
write free software 	sentinel 
foundation inc 	pending scripts 
franklin street fifth 	command strcasecmp 
floor boston 	reply reply 
usa allow use 	reply error 
code following 	anet resolve 
two types integer 	reply 
type wide 	error create 
enough hold pointer 	sentinel redis 
ansi compilers 	instance reply 
ptrdiff size likely 	error reply 
still size 	error reply 
two types microsoft 	error 
ugh following 	sentinel flush 
bits used determine 	config sentinel 
regexp syntax 	reply strcasecmp 
recognize meanings chosen 	sentinel flush 
emacs syntax 	config reply 
remains bits 	strcasecmp 
given alphabetical order 	sentinel master 
definitions shifted 	name reply 
one previous bit 	error sentinel 
thus bit 	dict sentinel 
one definition need 	flush 
change bit 	config reply 
inside bracket expression 	strcasecmp sentinel 
quotes following 	master name 
character bit operators 	reply error 
literals operators 	sentinel quorum 
literals bit character 	reachable 
classes supported 	reply sds 
alpha upper lower 	sdscatfmt sdsempty 
digit alnum 	sdscatfmt sdsempty 
xdigit space print 	sdscat sdscat 
punct graph 	sdscat sdscat 
cntrl character classes 	reply 
supported bit 	sds strcasecmp 
always anchors 	sentinel command 
outside bracket expressions 	strcasecmp mstime 
course bit 	dict create 
depends anchor beginning 	sentinel master 
regular expression 	name 
open alternation anchor 	dict reply 
end regular 	multi bulk 
expression close alternation 	len dict 
bit could 	size dict 
combined context indep 	iterator dict 
ops posix 	next 
draft says etc 	dict val 
leading positions 	reply bulk 
undefined already implemented 	buffer strlen 
previous draft 	reply multi 
made constructs invalid 	bulk len 
though haven 	dict 
changed code 	size reply 
back bit special 	multi bulk 
characters always 	len reply 
special regardless pattern 	reply bulk 
bit special 	buffer sdslen 
characters special contexts 	reply 
otherwise ordinary 	dict iterator 
specifically intervals special 	dict next 
beginning open 	dict val 
alternation bit cannot 	reply multi 
first immediately 	bulk len 
alternation begin bit 	reply 
matches newline 	reply bulk 
doesn bit doesn 	buffer sdslen 
match nul 	reply dict 
bit nonmatching lists 	release iterator 
match newline 	dict release 
bit either defines 	iterator 
interval depending 	dict release 
braces literals 	strcasecmp strcasecmp 
bit aren recognized 	server log 
operators bit 	strcasecmp server 
newline alternation newline 	log strcasecmp 
bit defines 	reply 
interval literals defines 	multi bulk 
interval bit 	len reply 
defines literals defines 	bulk reply 
literals bit 	bulk reply 
digit matches digit 	error reply 
digit back 	reply 
reference bit alternation 	error format 
alternation bit 	reply error 
ending range point 	format reply 
collating higher 	strcasecmp strcasecmp 
starting range point 	sdsempty info 
invalid ending 	section 
range point collates 	redis info 
higher starting 	section redis 
range point 	info section 
range ignored bit 	redis info 
unmatched ordinary 	section redis 
unmatched invalid bit 	strcasecmp 
succeed soon 	sdscat sdscatprintf 
match whole pattern 	dict size 
without backtracking 	list length 
bit process gnu 	dict iterator 
regex operators 	dict next 
gnu regex operators 	dict 
recognized bit 	val sdscatprintf 
syntactically invalid interval 	dict size 
treated ordinary 	dict size 
characters example ere 	dict release 
treated bit 	iterator reply 
ignore matching significant 	bulk 
bit used 	sds reply 
internally like context 	multi bulk 
indep anchors 	len reply 
difficult scan 	bulk buffer 
regex backwards find 	reply multi 
whether special 	bulk 
bit cannot first 	len dict 
bre immediately 	size dict 
alternation begin bit 	iterator dict 
sub compile 	next dict 
pattern variable defines 	val reply 
particular regexp 	bulk 
syntax use interfaces 	dict release 
regexp compiled 	iterator sentinel 
syntax used stored 	master name 
pattern buffer 	reply error 
changing affect already 	strcasecmp sentinel 
compiled regexps 	propagate 
define combinations bits 	period strcasecmp 
standard possibilities 	strcasecmp strcasecmp 
comments delimit gets 	strlen access 
put texinfo 	reply error 
file begin 	sentinel flush 
syntaxes section lines 	config 
syntax bits 	sdsfree strlen 
common basic extended 	sdsnew strcasecmp 
posix regex 	strlen access 
syntax differs posix 	reply error 
basic plus 	sentinel flush 
becomes limited ops 	config 
recognized actually 	sdsfree strlen 
isn minimal since 	sdsnew strcasecmp 
operators aren 	sdsfree strlen 
disabled differs posix 	sdsnew strcasecmp 
extended context 	reply error 
indep ops removed 	format 
refs added 	sentinel flush 
end syntaxes maximum 	config sentinel 
number duplicates 	sentinel flush 
interval allow 	config reply 
systems erroneously define 	sentinel flush 
header files 	config 
want previous define 	reply error 
overflows posix 	format strcmp 
cflags bits information 	reply error 
regcomp bit 	sentinel process 
use extended regular 	hello message 
expression syntax 	sdslen 
use basic regular 	reply mstime 
expression syntax 	mstime mstime 
bit ignore matching 	mstime instance 
significant bit 	link close 
anchors match newline 	connection mstime 
characters anchors 	mstime 
match newlines bit 	instance link 
report success 	close connection 
fail regexec returns 	mstime sentinel 
differ matching 	mstime sentinel 
errors posix 	dict iterator 
eflags bits information 	dict 
regexec bit 	next dict 
beginning line doesn 	val dict 
match beginning 	release iterator 
presumably beginning line 	sentinel mstime 
beginning line 	sentinel mstime 
match beginning like 	strcmp 
reg notbol 	sdsfree server 
end line use 	log sdsnew 
pmatch delimit 	dict iterator 
start end search 	dict next 
buffer error 	dict val 
codes removed changed 	mstime 
added update 	sdsfree mstime 
error msg table 	redis command 
regex never 	dict release 
happen implementation success 	iterator server 
didn find 	log exit 
match regexec 	sentinel 
posix regcomp error 	flush config 
codes order 	sentinel sdsfree 
listed standard invalid 	sdsnew sentinel 
pattern inalid 	flush config 
collating element invalid 	sentinel strcasecmp 
character name 	mstime 
trailing backslash invalid 	rand sdsnew 
back reference 	dict find 
unmatched left bracket 	dict integer 
parenthesis imbalance 	val dict 
unmatched invalid contents 	integer val 
invalid range 	dict 
end ran memory 	raw server 
preceding repetition 	dict integer 
error codes added 	val server 
premature end 	dict create 
compiled pattern bigger 	dict size 
bytes unmatched 	dict 
returned regcomp 	iterator dict 
data structure represents 	next dict 
compiled pattern 	val sentinel 
calling pattern compiler 	leader incr 
fields buffer 	dict release 
allocated fastmap translate 	iterator 
sub pattern 	dict iterator 
compiled nsub field 	dict next 
available fields 	dict integer 
regex routines space 	val dict 
holds compiled 	key dict 
pattern declared elements 	release 
sometimes used 	iterator sentinel 
indexes number bytes 	vote leader 
buffer points 	sentinel vote 
number bytes actually 	leader sentinel 
used buffer 	leader incr 
syntax setting 	sdsnew 
pattern compiled pointer 	sdsfree dict 
fastmap otherwise 	release memcpy 
zero search uses 	redis command 
fastmap one 	redis command 
skip impossible starting 	redis command 
points matches 	redis 
either translate table 	command redis 
apply characters 	command server 
comparing zero translation 	sentinel sentinel 
translation applied 	mstime rand 
pattern compiled matched 	mstime mstime 
number subexpressions 	ctime 
found compiler zero 	server log 
pattern cannot 	sentinel start 
match empty one 	failover strcasecmp 
well truth 	zmalloc dict 
used search see 	size mstime 
whether use 	dict 
fastmap absolutely 	iterator dict 
perfectly see compile 	next dict 
fastmap duplicate 	val mstime 
regs unallocated allocate 	mstime dict 
space regs 	release iterator 
structure max nregs 	qsort 
nsub groups 	zfree sentinel 
regs reallocate reallocate 	leader strcasecmp 
space necessary 	sdsfree mstime 
regs use zero 	sentinel sentinel 
regex compile 	abort failover 
compiles pattern one 	sentinel 
compile fastmap 	sentinel sim 
updates fastmap match 	failure crash 
information subexpressions 	mstime sentinel 
beginning line anchor 	sentinel slave 
doesn match 	sentinel sentinel 
beginning similarly end 	abort 
line anchor 	failover sentinel 
anchor newline 	mstime sentinel 
matches type offsets 	mstime sentinel 
within posix 	sentinel abort 
mandates structure store 	failover sentinel 
match data 	send 
see regex texinfo 	slave sentinel 
full description 	mstime mstime 
registers match regs 	sentinel sentinel 
allocated regs 	abort failover 
unallocated pattern buffer 	mstime dict 
match returns 	iterator 
information least many 	dict next 
registers first 	dict val 
time regs structure 	dict release 
passed posix 	iterator sentinel 
specification registers aside 	sentinel mstime 
different names 	dict 
registers posix uses 	iterator dict 
structures instead 	next dict 
structure arrays 	val sentinel 
offset start substring 	send slave 
start offset 	sentinel dict 
start substring end 	release 
declarations routines 	iterator dict 
sets current syntax 	iterator dict 
syntax old 	next dict 
syntax also simply 	val dict 
assign syntax 	release iterator 
options variable compile 	dict 
regular expression 	iterator dict 
pattern length length 	next dict 
syntax given 	val mstime 
syntax options buffer 	sentinel sentinel 
buffer successful 	send slave 
error compile fastmap 	mstime 
compiled pattern 	sentinel dict 
buffer used 	release iterator 
accelerate searches successful 	sentinel failover 
error search 	detect end 
length length pattern 	sentinel sentinel 
compiled buffer 	reset 
start searching position 	master change 
start range 	address server 
characters starting position 	sentinel failover 
match match 	wait start 
error also information 	sentinel failover 
regs regs 	slave 
buffer sub nonzero 	sentinel failover 
like search 	send slave 
search concatenation also 	one sentinel 
stop searching 	failover wait 
index start stop 	promotion sentinel 
like search 	failover 
many characters regexp 	reconf next 
buffer matched 	slave server 
starting position 	server mstime 
start relates match 	sentinel reconnect 
search relates 	instance sentinel 
search regs hold 	send 
num regs 	periodic commands 
registers storing starts 	mstime sentinel 
ends subsequent 	sentinel check 
matches buffer regs 	subjectively sentinel 
use memory 	check objectively 
recording information starts 	sentinel 
ends must 	start failover 
allocated malloc must 	needed sentinel 
least num 	ask master 
regs regoff bytes 	state sentinels 
num regs 	sentinel failover 
subsequent matches allocate 	state 
data unless 	machine sentinel 
function called first 	ask master 
search match 	state sentinels 
pattern buffer 	dict iterator 
allocate data without 	dict next 
freeing old 	dict 
data use gnu 	val sentinel 
bsd compatibility 	handle redis 
gcc later restrict 	instance sentinel 
compilers restrict 	handle dict 
configure may defined 	redis instances 
restrict gcc 	sentinel 
support restrict syntax 	handle dict 
posix compatibility 	redis instances 
regex regexec.c function 	sentinel failover 
function function 	promoted slave 
function function function 	dict release 
function function 	iterator 
preg length start 	mstime mstime 
range stop 	sentinel mstime 
nmatch pmatch eflags 	sentinel check 
bufp length 	tilt condition 
length start 	sentinel handle 
range regs stop 	dict 
ret len 	redis instances 
bufp length start 	sentinel run 
range stop 	pending scripts 
regs ret len 	sentinel collect 
regs pmatch 	terminated scripts 
nregs regs allocated 	sentinel 
mctx function 	kill timedout 
function function function 	scripts rand 
function function 	redis sentinel 
function function function 	implementation copyright 
function function 	salvatore sanfilippo 
function function function 	antirez 
function function 	gmail dot 
function function function 	rights reserved 
function function 	redistribution use 
function function function 	source binary 
function function 	forms without 
function function 	modification 
function function function 	permitted provided 
function function 	following conditions 
function function function 	met redistributions 
function preg 	source code 
nmatch pmatch eflags 	must retain 
err start 	copyright 
length preg nmatch 	notice list 
pmatch eflags 	conditions following 
bufp length start 	disclaimer redistributions 
regs bufp 	binary form 
length start range 	must reproduce 
regs bufp 	copyright 
length length start 	notice list 
regs stop 	conditions following 
bufp length length 	disclaimer documentation 
start range 	materials provided 
regs stop 	distribution neither 
bufp length length 	name 
start range 	redis names 
regs stop ret 	contributors may 
len str 	used endorse 
rval len free 	promote products 
str bufp 	derived software 
length start range 	without 
stop regs 	specific prior 
ret len result 	written permission 
pmatch nregs 	software provided 
rval eflags regs 	copyright holders 
pmatch nregs 	contributors express 
regs allocated rval 	implied 
need regs 	warranties including 
start end bufp 	limited implied 
regs num 	warranties merchantability 
regs starts ends 	fitness particular 
preg length 	purpose disclaimed 
start range 	shall 
stop nmatch pmatch 	copyright owner 
eflags err 	contributors liable 
dfa left lim 	direct indirect 
right lim 	incidental special 
incr longest match 	exemplary consequential 
match first 	damages 
match kind match 	including limited 
last extra 	procurement substitute 
nmatch mctx mctx 	goods services 
fastmap offset 	loss use 
pstate reg idx 	data profits 
mctx dfa 	business 
halt node match 	interruption however 
last ret 	caused theory 
sifted states lim 	liability whether 
states sctx 	contract strict 
acquire init state 	liability tort 
context mctx 	including 
longest match 	negligence otherwise 
match first dfa 	arising way 
err match 	use software 
match last cur 	even advised 
str idx 	possibility damage 
cur state init 	sentinel 
state next 	state address 
start idx old 	used describe 
state next 	port pair 
idx dfa node 	sentinel redis 
context type 	instance monitoring 
constraint mctx state 	subjectively 
idx context 	quorum objectively 
mctx nregs regs 	confirmed others 
pidx node 	sentinel flag 
eps via nodes 	thinks master 
dfa err 	failover progress 
cur nodes edests 	master 
dest node 	slave selected 
candidate naccepted 	promotion slaveof 
type subexp idx 	newmaster sent 
buf dest 	slave synchronization 
node dest node 	progress slave 
str idx 	master 
dest node nregs 	force failover 
regs eps 	master script 
via nodes err 	kill already 
num pidx 	sent busy 
nregs regs eps 	note 
via nodes 	times milliseconds 
num preg mctx 	failover machine 
nmatch pmatch 	different states 
backtrack dfa idx 	failover progress 
cur node 	wait failover 
eps via nodes 	start 
body prev 	time slave 
idx match 	promote slave 
prev idx match 	master wait 
malloced reg 	slave change 
idx idx dfa 	role slaveof 
pmatch prev 	newmaster 
idx match cur 	monitor promoted 
node cur 	slave flags 
idx nmatch type 	used different 
reg num 	functions use 
reg num mctx 	higher bits 
sctx err 	avoid 
cnt str idx 	colliding function 
cur dest 	specific flags 
mctx sctx str 	script execution 
idx cur 	flags limits 
dest dfa cur 	seconds max 
src prev 	exec 
node naccepted ret 	time seconds 
type idx 	retries sentinel 
mctx next 	simulate failure 
state log idx 	command flags 
top err 	link sentinel 
dfa dst src 	redis 
num idx 	instance sentinels 
err merged mctx 	monitoring many 
sctx str 	masters different 
idx dest nodes 	instances representing 
dfa err 	sentinels one 
candidates dfa dest 	per 
nodes candidates 	master need 
err state dfa 	share hiredis 
node dest 	connections among 
nodes candidates ecl 	oherwise sentinels 
idx err 	monitoring masters 
inv eclosure nodes 	create 
cur node 	outgoing connections 
edst edst cur 	instead structure 
node idx 	represents reference 
mctx limits 	counted link 
dst node dst 	terms two 
idx src 	hiredis 
node src idx 	connections commands 
dfa lim 	pub sub 
idx src pos 	fields needed 
dst pos 	failure detection 
dst bkref idx 	since ping 
src bkref 	pong 
idx subexp idx 	time local 
ent mctx 	link link 
boundaries subexp idx 	available instance 
node bkref 	avaialbe way 
idx dfa eclosures 	connections instead 
node idx 	also 
node ent dst 	send pings 
cpos mctx 	instead links 
limit subexp idx 	shared sentinels 
node str 	master slave 
idx bkref 	instances link 
idx lim boundaries 	refcount 
dfa dest 	always number 
nodes candidates limits 	sentinel redis 
bkref ents 	instance owners 
str idx err 	non zero 
node idx 	need reconnect 
lim idx subexp 	number 
idx ent 	commands sent 
ops node cls 	waiting reply 
node node 	hiredis context 
type node node 	commands hiredis 
type mctx 	context pub 
sctx str idx 	sub 
candidates dfa 	connection time 
err node idx 	connection time 
node local 	last time 
sctx first 	received message 
idx enabled idx 	last time 
type entry 	instance 
subexp len idx 	replied ping 
dst node 	reply consider 
ret cur state 	valid time 
mctx sctx 	last pending 
node idx str 	ping pong 
idx max 	received 
str idx dfa 	sent field 
naccepted err 	pong received 
mctx state trtable 	current time 
context err 	ping sent 
mctx next state 	time sent 
dfa cur 	last 
idx pstate context 	ping used 
next nodes 	avoid sending 
log nodes table 	many pings 
nodes err 	failure idle 
mctx cur 	time computed 
state max cur 	act 
str idx 	ping time 
mctx cur nodes 	field last 
str idx 	time instance 
dfa node idx 	replied ping 
err node 	whatever reply 
mctx pstate dfa 	used 
err dest 	check link 
nodes nodes cur 	idle must 
node idx 	reconnected last 
naccepted dest idx 	reconnection attempt 
context dest 	performed link 
state mctx nodes 	see 
dfa err 	sri defines 
cur str idx 	master name 
dest str 	point view 
idx prev nelem 	sentinel run 
bkc idx 	instance unique 
node idx 	sentinel 
context node dest 	configuration epoch 
nodes subexp 	master host 
len dest state 	link instance 
bkref ent 	may shared 
dest nodes mctx 	sentinels last 
bkref node 	time 
bkref str idx 	sent hello 
dfa subexp 	via pub 
num sub top 	sub used 
idx buf 	sri sentinel 
cache idx entry 	last time 
err sub 	received 
top sub last 	hello sentinel 
sub last 	via pub 
idx str bkref 	sub time 
str str 	last reply 
diff cls node 	sentinel master 
str nodes 	command 
mctx sub 	subjectively since 
top sub last 	time objectively 
bkref node 	since time 
bkref str err 	consider period 
idx dfa 	time received 
nodes subexp idx 	info 
type cls 	output role 
idx cls node 	first time 
node mctx 	observed useful 
path top node 	order delay 
top str 	replacing instance 
last node last 	reports 
str type 	configuration need 
dfa err subexp 	always wait 
num backup 	time order 
cur idx str 	give chance 
idx cnt 	leader report 
cur state cur 	configuration 
nodes next 	silly things 
nodes backup 	last time 
state log context 	slave master 
old alloc 	addr changed 
mctx str idx 	master specific 
cur nodes 	sentinels 
next nodes dfa 	monitoring master 
result cur 	slaves master 
idx err naccepted 	instance number 
cur node 	sentinels need 
type dest state 	agree failure 
next node 	many 
next idx dfa 	slaves reconfigure 
cur nodes 	time password 
subexp type err 	use auth 
idx outside 	master slaves 
node nodes cur 	slave specific 
node eclosure 	slave 
dfa dst 	replication link 
nodes target subexp 	time slave 
type cur 	priority according 
node err mctx 	info output 
cur nodes 	time sent 
cur str subexp 	slave 
num type 	master instance 
dfa err cache 	slave master 
idx start 	host reported 
ent idx next 	info master 
node dests 	port reported 
err err ret 	info 
dfa state 	master link 
err need word 	status reported 
trtable elem 	info slave 
mask dests node 	replication offset 
malloced dest 	failover master 
states malloced ndests 	instance 
trtable dest 	runid sentinel 
states word 	perform failover 
dest states follows 	sentinel runid 
dests node 	sentinel sentinel 
dests acceptable dests 	voted leader 
node dests 	epoch 
next node dfa 	leader field 
state dests 	epoch currently 
node dests err 	started failover 
result ndests 	see sentinel 
accepts cur nodes 	failover state 
node type 	defines 
constraint accepts newline 	last failover 
intersec remains 	attempt start 
intersec subset consumed 	time max 
dfa node 	time refresh 
idx input str 	failover state 
idx node 	failover 
len elem len 	start time 
cset pin 	logged failover 
nrules match 	delay promoted 
len collseq table 	slave instance 
indirect weights 	scripts executed 
extra collseqwc coll 	notify 
sym idx 	admin reconfigure 
equiv idx weight 	clients script 
len cnt 	executed cached 
cmp buf cmp 	info output 
buf mbs 	main state 
mbs len nrules 	sentinel 
collseq idx 	current epoch 
extra extrasize mbs 	dictionary master 
cnt found 	sentinel redis 
elem mbs len 	instances key 
mctx node 	instance name 
idx context mctx 	sentinel 
ret pstr 	redis instance 
mctx eflags mctx 	structure pointer 
idx idx 	tilt mode 
top last 	number scripts 
mctx mctx node 	execution right 
str idx 	titl 
entry mctx str 	started last 
idx left 	time ran 
right mid last 	time handler 
mctx node 	queue user 
str idx asub 	scripts execute 
tops subtop 	addr 
node str idx 	gossiped sentinels 
entry alasts 	port gossiped 
sctx sifted sts 	sentinels non 
limited sts 	zero failures 
last node last 	simulation script 
str idx 	execution 
strlen libc search 	job script 
search libc 	job flags 
unlock versioned 	sentinel script 
symbol regexec compat 	number times 
symbol search 	tried execute 
stub search stub 	arguments 
search stub 	call script 
search stub malloc 	script execution 
memcpy memcpy 	time script 
search stub free 	running otherwise 
libc compile 	allowed retry 
fastmap malloc search 	execution 
copy regs 	time script 
free libc unlock 	running means 
malloc malloc 	run specified 
free realloc realloc 	time script 
free regexec 	execution pid 
memset allocate match 	hiredis 
ctx init 	adapters note 
malloc reconstruct reconstruct 	implementation taken 
first check 	hiredis adapters 
matching check 	however modified 
halt state context 	copy sentinel 
prune impossible 	order 
nodes match ctx 	use allocator 
clean regs 	full control 
free match ctx 	adapter works 
free destruct 	nothing attached 
malloc malloc memset 	something already 
sift ctx 	attached 
init sift states 	create container 
backward node 	context events 
free check halt 	functions start 
state context 	stop listening 
merge state free 	events prototypes 
sift ctx 	dictionary 
init sift states 	types instance 
backward node 	name sds 
free free free 	instance sentinel 
free cur 	redis instance 
idx acquire 	pointer also 
init state context 	used 
check subexp 	sentinel redis 
matching top transit 	instance sentinels 
state bkref 	dictionary maps 
check halt state 	sentinels port 
context eoi 	last seen 
cur idx extend 	time 
buffers transit 	pub sub 
state merge state 	hello message 
log find 	hash function 
recover state check 	key dup 
halt state 	val dup 
context cur idx 	key 
cur idx 	compare key 
satisfy next constraint 	destructor val 
context check 	destructor instance 
halt node context 	runid sds 
epsilon node 	votes casted 
node insert 	useful 
node contains node 	sentinel objective 
contains push 	leader function 
fail stack check 	order count 
node accept 	votes understand 
bytes buffer memcmp 	leader hash 
node insert 	function 
node contains check 	key dup 
node accept 	val dup 
node contains node 	key compare 
empty realloc 	key destructor 
malloc memcpy node 	val destructor 
init copy 	initialization 
memcpy node free 	function overwrites 
free malloc 	normal redis 
node init empty 	config sentinel 
libc use 	specific defaults 
alloca alloca 	perform sentinel 
malloc free fail 	mode 
stack memcpy 	initialization usual 
update regs node 	redis commands 
free free 	command table 
free fail stack 	sentinel command 
pop fail 	initialize various 
stack node free 	data 
free proceed 	structures function 
next node node 	gets called 
free free 	server sentinel 
free fail stack 	mode started 
pop fail 	loaded configuration 
stack node free 	ready 
free node 	normal operations 
free free free 	sentinel yet 
fail stack 	configuration file 
node free free 	pick random 
free memcpy 	one persist 
memcpy node 	config 
init update cur 	disk sentinel 
sifted state 	across restarts 
memset node free 	pick presist 
node empty 	config log 
build sifted states 	make debugging 
update cur 	issues 
sifted state node 	simpler want 
free epsilon 	generate monitor 
node sift states 	every configured 
iter check 	master startup 
node accept state 	sentinel addr 
node contains 	create 
check dst limits 	sentinel addr 
node insert 	success error 
extend buffers memset 	returned errno 
node init 	enoent resolve 
acquire state node 	hostname einval 
free epsilon 	invalid 
src nodes 	port number 
check subexp limits 	duplicate source 
acquire state 	address free 
sift states bkref 	sentinel address 
acquire state 	fail non 
node alloc node 	zero 
merge node 	two addresses 
intersect node init 	equal events 
empty epsilon 	notification send 
node node contains 	log pub 
node contains 	sub user 
node contains node 	notification 
contains node 	script level 
intersect node free 	log level 
node contains 	logging warning 
node contains node 	events trigger 
node free 	execution user 
search cur bkref 	notification 
entry search 	script type 
cur bkref 	message type 
entry check dst 	also used 
limits calc 	pub sub 
pos check dst 	channel name 
limits calc 	redis 
pos check dst 	instance target 
limits calc 	applicable used 
pos check dst 	obtain path 
limits calc 	notification script 
pos sub epsilon 	execute remaining 
src nodes 	arguments 
node contains node 	alike format 
contains sub 	specifier starts 
epsilon src nodes 	two characters 
sub epsilon 	message prefixed 
src nodes search 	instance following 
cur bkref 	format 
entry state node 	instance type 
contains check 	instance name 
dst limits 	port instance 
node init copy 	type master 
node insert 	additional added 
sift states backward 	specify 
merge state 	originating master 
node node free 	master name 
check node 	master master 
accept bytes state 	port specifier 
node contains 	processed handle 
transit state fetch 	use 
context cur 	vsprintf rest 
idx word context 	formatting log 
build trtable 	message log 
cur idx node 	level allows 
init context 	logged publish 
cur idx acquire 	message 
state context 	via pub 
node free 	sub debugging 
check subexp matching 	one call 
top transit 	notification script 
state bkref cur 	applicable function 
idx skip 	called 
bytes merge state 	startup used 
log match 	generate monitor 
ctx subtop context 	every configured 
cur idx 	master events 
satisfy next constraint 	also generated 
check node 	master 
accept bytes cur 	monitor added 
idx cur 	runtime via 
idx clean state 	sentinel monitor 
log needed 	command script 
node init context 	execution release 
acquire state 	script 
context node free 	job structure 
cur idx 	associated data 
context satisfy 	copy oldest 
next constraint subexp 	non running 
context acquire 	script 
state context node 	already hit 
init node 	limit first 
free acquire state 	node oldest 
context node 	tail lookup 
free check subexp 	script scripts 
matching top 	queue 
transit state bkref 	via pid 
buffer search 	returns list 
cur bkref entry 	node easily 
clean state 	queue needed 
log needed buffer 	run pending 
memcmp subexp 	scripts 
sub buffer extend 	already max 
buffers buffer 	number running 
find subexp node 	scripts find 
calloc check 	jobs running 
arrival match 	run top 
ctx sublast subexp 	tail 
sub check 	queue run 
arrival match ctx 	older jobs 
entry clean 	first skip 
state log needed 	already running 
realloc memset 	skip retry 
context node init 	enough 
check arrival 	time elapsed 
expand ecl node 	parent fork 
free node 	error report 
init copy node 	fork errors 
init empty 	signal order 
expand bkref cache 	unify 
node free 	reporting kind 
acquire state context 	errors child 
node free 	error occurred 
node empty node 	retry execution 
merge node 	much delay 
free check 	execution 
arrival next nodes 	script need 
node free 	retry error 
check arrival expand 	retry delay 
ecl node 	every retry 
free expand bkref 	instance retry 
cache node 	delay 
free context acquire 	seconds max 
state context 	number retries 
node free node 	starting second 
free node 	attempt execute 
contains node init 	script delays 
empty epsilon 	sec 
node check node 	sec min 
accept bytes 	min min 
node empty node 	min min 
merge node 	min min 
free node 	check scripts 
insert node free 	terminated 
acquire state 	queue script 
node free check 	terminated successfully 
node accept 	instead script 
node insert node 	terminated signal 
free node 	returned exit 
free node alloc 	code 
find subexp 	scheduled run 
node node merge 	max number 
node free 	retries already 
check arrival expand 	elapsed script 
ecl sub 	terminated signal 
node free node 	returns 
free node 	exit code 
contains node insert 	means please 
node insert 	retry reschedule 
check arrival expand 	max number 
ecl sub 	retries already 
search cur 	reached 
bkref entry node 	otherwise script 
contains node 	log execution 
contains node init 	terminated best 
check arrival 	ways kill 
expand ecl node 	scripts timeout 
merge node 	collected 
free node contains 	sentinel collect 
node init 	terminated scripts 
copy node insert 	function sentinel 
node free 	pending scripts 
node init acquire 	command function 
state node 	calls 
free libc use 	client reconfiguration 
alloca alloca 	script following 
malloc nodes astates 	parameters master 
free calloc 	name role 
node alloc libc 	state port 
use alloca 	port 
alloca malloc 	called every 
free node free 	time failover 
node free 	performed state 
free bitset empty 	currently always 
node empty 	failover role 
node merge acquire 	either 
state context 	leader observer 
acquire state context 	fields respectively 
acquire state 	master promoted 
context bitset merge 	slave addresses 
calloc calloc 	start end 
bitset contain bitset 	instance 
contain free 	link create 
node free node 	yet connected 
free free 	link act 
bitset empty bitset 	ping time 
bitset merge 	even actually 
bitset merge bitset 	yet 
bitset clear 	connection node 
bitset clear 	sent ping 
memset bitset clear 	useful detect 
bitset clear 	timeout able 
bitset contain bitset 	connect node 
empty bitset 	disconnect 
bitset empty bitset 	hiredis connection 
empty bitset 	context instance 
empty bitset contain 	link decrement 
bitset copy 	refcount link 
bitset copy node 	drops zero 
init copy 	actually 
node insert bitset 	free otherwise 
copy node 	anything pointer 
init bitset empty 	going free 
node free 	link rebind 
size elem size 	pending requests 
btowc buffer 	link 
wchar iswctype 	hiredis connection 
current word current 	commands callback 
current collseq 	ignore useful 
table lookup find 	avoid processing 
collation sequence 	replies instance 
current current current 	longer 
current findidx 	exists instance 
wcscoll wcscoll current 	may pending 
word current 	callbacks hiredis 
current current bitset 	context privdata 
contain context 	instance going 
satisfy next constraint 	free 
realloc buffers 	rewrite callback 
realloc build wcs 	list directly 
upper buffer 	exploiting hiredis 
build upper buffer 	data structures 
build wcs 	order bind 
buffer translate buffer 	callback 
malloc malloc 	ignore reply 
free free 	strictly needed 
free free free 	active users 
free match 	function attempt 
ctx clean free 	share instance 
free realloc 	link 
free memset realloc 	already sentinel 
calloc realloc 	context different 
calloc node init 	master instance 
empty extended 	passing argument 
regular expression matching 	way multiple 
search library 	sentinel 
copyright free software 	objects refer 
foundation inc 	physical sentinel 
file part gnu 	instance context 
library contributed 	different masters 
isamu hasegawa isamu 	use single 
yamato ibm 	connection 
gnu library free 	send single 
software redistribute 	ping per 
modify terms 	second failure 
gnu lesser general 	detection forth 
license published 	matching sentinel 
free software foundation 	found 
either version 	context different 
license option later 	master sharing 
version gnu 	performed otherwise 
library distributed hope 	err returned 
useful without 	way identify 
warranty without even 	already 
implied warranty 	shared want 
merchantability fitness particular 	share physical 
purpose see 	sentinel referenced 
gnu lesser general 	masters skip 
license details 	master match 
received copy gnu 	never 
lesser general 	happen safer 
license along gnu 	identified matching 
library write 	sentinel great 
free software 	free link 
foundation inc franklin 	use one 
street fifth 	matching 
floor boston usa 	sentinel detect 
enable enable 	sentinel address 
libc enable entry 	reporting different 
point posix 	port pair 
code regexec searches 	hello messages 
given pattern 	update 
specified preg nmatch 	matching sentinels 
zero reg 	context masters 
nosub cflags argument 	well disconnect 
regcomp ignore 	links everybody 
pmatch otherwise pmatch 	updated number 
least nmatch 	updated 
elements offsets corresponding 	sentinel addresses 
matched substrings 	address already 
eflags specifies execution 	updated update 
flags affect 	address matching 
matching reg 	sentinel copying 
notbol match beginning 	address 
reg noteol 	sentinel received 
match end find 	address update 
match reg 	function called 
nomatch entry points 	hiredis connection 
gnu code 	reported error 
match search match 	mark 
search former 	link disconnected 
two functions operate 	reconnected note 
length length 	free hiredis 
later two operate 	context hiredis 
concatenation lengths 	connections hiredis 
length length respectively 	connection 
match matches 	established disconnected 
compiled pattern bufp 	callbacks need 
starting index 	cleanup link 
start search 	state sentinel 
first tries matching 	redis instance 
index start 	create 
tries match starting 	redis instance 
index start 	following fields 
last start position 	must populated 
tried start 	caller needed 
range thus range 	runid populated 
forces search 	info 
operate way match 	output received 
parameter stop 	info refresh 
match search specifies 	mean never 
match exceeding 	received info 
first stop characters 	far sri 
concatenation concerned 	master 
regs bufp sub 	initial flags 
offsets match 	instance added 
groups stroed regs 	sentinel masters 
variants offsets 	table sri 
computed relative 	slave sri 
concatenation relative individual 	sentinel 
success match 	master must 
functions length match 	instance added 
search position 	master slaves 
start match means 	master sentinels 
match found 	table instance 
indicates error concatenate 	slave 
parameters meaning 	sentinel name 
search additional parameters 	parameter ignored 
ret len 	created automatically 
nonzero length match 	hostname port 
returned match 	function fails 
style otherwise position 	hostname 
match returned 	resolved port 
check range compile 	range happens 
fastmap haven 	returned errno 
yet need least 	accordingly create 
nothing copied 	sentinel addr 
regs hope 	function 
needn fill regs 	function may 
match found 	also fail 
caller wants contents 	errno ebusy 
data back 	master name 
copy need one 	slave address 
extra element 	sentinel 
beyond num regs 	already exists 
marker gnu 	check address 
code uses data 	validity slaves 
arrays allocated 	use port 
allocate malloc yes 	name make 
need elements 	sure 
already allocated reallocate 	entry duplicated 
need fewer 	may happen 
alone function may 	name master 
called regs 	used multiple 
nregs big copy 	times inside 
regs regs 	configuration 
hold num 	multiple times 
regs registers storing 	slave sentinel 
starts ends 	port master 
subsequent matches pattern 	create instance 
buffer regs 	note instances 
use memory recording 	started 
information starts 	disconnected state 
ends must allocated 	loop take 
malloc library 	care connecting 
routine must least 	failover state 
num regs 	role right 
regoff bytes num 	table 
regs subsequent 	release instance 
matches allocate data 	slaves sentinels 
unless function 	hiredis connections 
called first search 	function take 
match pattern 	care unlinking 
buffer allocate 	instance 
data without freeing 	main masters 
old data 	table master 
entry points compatible 	master sentinels 
bsd regex 	slaves table 
library define unless 	slave sentinel 
specifically requested 	release 
regex comp entry 	slaves sentinels 
point searches 	disconnect instance 
compiled pattern preg 	free resources 
whose length 	clear state 
length nmatch pmatch 	master needed 
eflags mingings 	lookup 
regexec start range 	slave master 
meanings search 	redis instance 
reg noerror find 	port name 
match reg 	type instance 
nomatch otherwise error 	function sentinel 
code note 	specified 
front end 	specified master 
functions already check 	runid function 
ranges start 	returns asap 
range start range 	function useful 
length check 	sentinels address 
dfa haven compiled 	want 
front end 	old entry 
functions already check 	one address 
initial states 	function returns 
non begbuf contexts 	matching sentinel 
elements regex 	removed otherwise 
must anchored preg 	sentinel 
newline anchor 	search instance 
never use init 	runid port 
state check 	dictionary instances 
must check longest 	found otherwise 
matching nmatch 	instance pointer 
log dfa states 	runid 
dfa pass 	search performed 
nmatch dfa 	non field 
multibyte node back 	user must 
reference node 	pass least 
accept multibyte character 	one search 
multi character 	param 
collating element avoid 	master lookup 
overflow check 	name specified 
incrementally whether input 	flags instances 
match advance 	specified dictionary 
rapidly possible find 	specified flags 
plausible place 	instances 
start matching may 	specified dictionary 
done varying 	reset state 
efficiency various possibilities 	monitored master 
common specialized 	slaves sentinels 
order save code 	flags resulting 
size use 	runtime 
statement speed fastmap 	operations reset 
fastmap single 	timers example 
translation match 	reset possible 
forward fastmap without 	failover master 
translation match 	asap without 
forward fastmap without 	waiting 
multi translation 	failover timeout 
match backwards determine 	delay process 
easily current 	undo failover 
since might component 	progress disconnect 
multibyte character 	connections master 
use constructed buffer 	reconnect 
instead match 	automatically failover 
first valid range 	asap call 
reconstruct buffers 	sentinel reset 
match first buffer 	master every 
note match 	master name 
first must smaller 	matching 
reconstruct buffers 	specified pattern 
matcher matching 	reset specified 
starts beginning buffer 	master sentinel 
consider possible 	reset master 
match start part 	also change 
yet isn 	port 
head multibyte character 	address take 
seems appropriate 	name instance 
one use matcher 	unmodified used 
matching starts 	handle master 
found match pmatch 	function returns 
need initialize 	err 
registers points matching 	address resolved 
start end 	reason otherwise 
last offset registers 	returned make 
since slided 	list slaves 
buffers could matching 	back reset 
starts avoid 	include 
overflow acquire initial 	one address 
state must 	switching switching 
appropriate initial 	different address 
state depending context 	include old 
since initial 	address slave 
states may constraints 	well 
like etc 	able sense 
relatively rare calculate 	reconfigure old 
demand must 	master reset 
happen check whether 	address slaves 
regular expression 	back release 
match input input 	old 
index matching 	address end 
end match error 	safe even 
longest match 	function gets 
means want posix 	master addr 
longest matching 	master addr 
match first match 	port 
fails next 	arguments non 
place may want 	zero sdown 
matching note 	odown error 
matcher matching 	associated instance 
starts current index 	latest milliseconds 
buffer initial 	current 
state must invalid 	master address 
check open 	address address 
subexp initial state 	promoted slave 
use later 	already operational 
processing back references 	failing master 
accepts reached 	state 
invalid state error 	already sentinel 
recover valid 	failover state 
state state log 	reconf slaves 
available already 	greater means 
found valid even 	already configuration 
longest match 	epoch 
reached halt state 	master slave 
check halt 	acknowledged configuration 
state satisfy current 	advertise address 
context found 	function sets 
appropriate halt 	period field 
state found match 	master 
modify match 	slaves sentinel 
first check node 	instances connected 
match current 	master config 
context check halt 	handling monitor 
state state 	name host 
match current context 	port 
match node 	quorum milliseconds 
state halt node 	name milliseconds 
match context 	failover timeout 
node compute next 	name milliseconds 
node nfa 	parallel 
transit node nfa 	syncs name 
nfa corresponding 	milliseconds notification 
dfa destination node 	script name 
update eps 	path client 
via nodes errors 	reconfig script 
pick valid 	name 
destination none 	path auth 
found order avoid 	pass name 
infinite loop 	password current 
like second epsilon 	epoch epoch 
transition first 	config epoch 
already considered otherwise 	name 
push second 	epoch following 
epsilon transition fail 	update current 
stack know 	epoch really 
going exit enable 	useful current 
positions subexpressions 	epoch persisted 
starts ends registers 	config 
pmatch note 	file check 
pmatch already pmatch 	redundancy leader 
pmatch nmatch 	epoch name 
proceed next node 	epoch known 
first node 	slave name 
sub expression 	port 
last node sub 	ignore old 
expression non 	form without 
empty match inside 	runid known 
optional subexpression 	sentinel name 
accept right away 	port runid 
transited empty 	announce 
match optional subexpression 	address announce 
like subexp 	port port 
first match copy 	config rewrite 
back old 	sentinel option 
content registers matches 	used rewrite 
inner subexpression 	configuration 
undone well like 	given user 
completed subexpression 	configured masters 
may part optional 	also order 
one update 	retain state 
prev idx match 	sentinel across 
function checks 	restarts 
state log 	config epoch 
sctx last str 	masters associated 
idx sift 	slaves sentinel 
nodes states according 	instances forth 
following rules 	sentinel unique 
updated state log 	every 
wrote state 	master emit 
log rules away 	sentinel monitor 
node state 	config entry 
log str idx 	sentinel monitor 
str idx 	sentinel milliseconds 
match last last 	sentinel 
index state 	failover timeout 
log isn last 	sentinel parallel 
node epsilon 	syncs sentinel 
transit last node 	notification script 
away node 	sentinel client 
str idx match 	reconfig 
last accepts 	script sentinel 
transit isn 	auth pass 
state log str 	sentinel config 
idx strlen 	epoch sentinel 
away node state 	leader epoch 
log str 	sentinel 
idx strlen thrown 	known slave 
away away 	master addr 
node str idx 	obtained sentinel 
match last 	current master 
epsilon transit isn 	address may 
state log 	address 
str idx away 	promoted slave 
node state 	equal slave 
log str idx 	address failover 
thrown away 	progress slave 
away node build 	already successfully 
sifted state 	promoted 
log str idx 	address slave 
nodes epsilon 	use old 
transit last 	master address 
node last node 	instead sentinel 
check states 	known sentinel 
state log update 	sentinel 
counters nodes 	current epoch 
satisfy following conditions 	state valid 
epsilon transit 	masters sentinel 
node cur dest 	announce sentinel 
cur src 	announce port 
update state log 	function 
build next 	uses config 
sifted state build 	rewriting redis 
next sifted 	engine order 
state cur dest 	persist state 
update sifted 	sentinel current 
states str idx 	configuration 
cur dest 	file returning 
note cur 	function calls 
dest sifted state 	fsync generated 
state log 	configuration file 
str idx cur 	make sure 
src points 	changes 
node old state 	committed disk 
log str 	failure function 
idx epsilon nodes 	logs warning 
pre filtered 	redis log 
node may accept 	hiredis connection 
multi enable 	handling 
check backreferences see 	send auth 
update cur 	command specified 
sifted state helper 	master password 
functions first 	needed note 
nodes epsilon transit 	slaves password 
node dest 	master 
node check limitations 	used check 
current sift 	command successfully 
context src 	transmitted instance 
dst subexp subexp 	fails sentinel 
src dst 	detect instance 
subexp src subexp 	disconnect 
dst subexp 	reconnect link 
unrelated limitation boundary 	forth use 
examine nodes 	client setname 
epsilon closure recurse 	name connection 
trying reach 	redis instance 
open subexp close 	sentinel 
subexp cases 	first chars 
destination node node 	runid connection 
source node 	type connection 
recurse would cause 	type cmd 
infinite loop 	pubsub specified 
regex exhibits behavior 	type 
boundaries boundaries 	makes possible 
outside range subexpression 	list sentinel 
within subexpression 	instances connected 
examine epsilon 	redis servewr 
closure check limitations 	client list 
sub expressions 	grepping 
limits nodes limitations 	specific name 
dest nodes 	format create 
unrelated limitation check 	connections instance 
limitation open 	link link 
subexpression note ent 	disconnected note 
subexp str 	link 
idx ent subexp 	disconnected even 
check limitation 	one two 
close subexpression limitation 	links commands 
form current 	pub sub 
sifted state ent 	missing port 
subexp str 	means 
idx limitation form 	invalid address 
current sifted 	commands connection 
state mark hasn 	send ping 
initialized avoid 	asap reconnecting 
infinite loop 	pub sub 
like mctx bkref 	subscribe 
ents may 	sentinels hello 
changed reload pointer 	channel subscribe 
check node 	pub sub 
accept multi node 	connection useless 
accept multi 	simply disconnect 
destination already thrown 	clear 
away node 	disconnected status 
couldn accept current 	connections commands 
input multi 	connection sentinel 
otherwise sure node 	instance redis 
could accept 	instances pinging 
naccepted bytes input 	master 
enable functions 	looks sane 
state transition next 	actually master 
state current 	current configuration 
state state 	reports master 
transit accepting current 	sdown odown 
input update 	obtained 
state log necessary 	last info 
state accept 	two times 
multibyte collating element 	info period 
back reference 	time ago 
update destination state 	process info 
log current 	output 
state accept multibyte 	masters cache 
enable decide 	full info 
next state single 	output instance 
use transition 	following fields 
table use transition 	must reset 
table retry 	given 
transition table update 	found info 
state log 	output process 
need state log 	line line 
cur idx 	run hex 
implies cur 	chars old 
idx destination multibyte 	versions 
collating element 	slave port 
back reference next 	state versions 
state destinations 	slave port 
results transition table 	old format 
note already 	points start 
nodes initial state 	address 
need need 	nul term 
check errors since 	easy access 
function next 	port points 
state err already 	start port 
check open 	number nul 
subexp current state 	term 
use later 	easy access 
must check since 	format points 
back references 	start address 
next state might 	port points 
use next 	start port 
state back 	number 
references skip bytes 	nul term 
input correspond 	fields easy 
part multi match 	access check 
look log 	already slave 
state restart matching 	table otherwise 
helper functions 	master 
transit state node 	link since 
cur nodes 	seconds seconds 
pick nodes whose 	role role 
types open 	master host 
subexp corresponding back 	host master 
references regular 	port 
expression use later 	port master 
evaluating correspoding 	link status 
back references todo 	status slave 
isn efficient 	priority priority 
might one nodes 	slave repl 
whose types 	offset 
open subexp 	offset acting 
whose index subexp 	half things 
idx must 	happen sentinel 
check nodes next 	tilt still 
state current 	processed remember 
state state transit 	role 
accepting current 	changed log 
input need check 	role change 
errors since 	role coherent 
function next state 	role change 
err already 	mismatch current 
many bytes node 	config 
accept node 	none following 
accepts naccepted bytes 	conditions processed 
enable check 	tilt mode 
whether node backreference 	asap handle 
node backreference 	master slave 
check substring substring 	role 
matched epsilon 	nothing masters 
closures dest 	claiming slaves 
nodes backreference appropriate 	considered unreachable 
state log 	sentinel eventually 
dest node state 	failover triggered 
log need 	handle 
check recursively backreference 	slave master 
epsilon transit 	role promoted 
enumerate candidates backreference 	slave change 
bkref node 	state failover 
match bkref str 	state machine 
idx match 	sure 
ctx entry note 	slave reconfigured 
might collect 	master master 
inappropriate candidates however 	configuration epoch 
cost checking 	epoch won 
strictly high delay 	election perform 
checking prune 	failover 
impossible nodes 	force sentinels 
already bkref node 	update config 
bkref str 	assuming newer 
idx already sub 	one already 
expression isn 	available slave 
related first check 	turned 
last node 	master want 
sub expressions already 	force view 
evaluated matched 	reconfigure slave 
sub expression match 	wait time 
substring back 	change going 
reference enough chars 	forward 
successful match 	receive configs 
need search sub 	handle slaves 
expression reload 	replicating different 
buf since preceding 	master address 
call might 	make sure 
reallocated buffer search 	master 
last nodes 	sane reconfiguring 
sub expression 	instance slave 
matched sub expression 	detect slave 
match substring 	process reconfigured 
back reference end 	changed state 
input cannot 	sri 
match need search 	reconf sent 
sub expression 	sri reconf 
state sub expression 	inprog sri 
open subexp 	reconf inprog 
node arrive close 	sri reconf 
subexp node 	done 
current context helper 	discard reply 
functions subexp 	use monitoring 
check sub last 	command effects 
arrive back 	directly update 
reference bkref node 	instance available 
bkref str 	field 
arrive sub expression 	acceptable reply 
expressed sub 	flag pong 
top sub 	received send 
last subexpression arrive 	script kill 
back reference 	command instance 
find first node 	appears 
whose index 	busy script 
subexp idx search 	called reply 
open search 	publish command 
otherwise todo function 	send master 
isn efficient 	advertise sentinel 
might one nodes 	update 
whose types 	pub time 
open subexp whose 	actually published 
index subexp 	message otherwise 
idx must check 	retry milliseconds 
nodes check 	process hello 
whether node top 	message 
node top 	received via 
str arrive node 	pub sub 
last node 	master slave 
last str 	instance sent 
record path onto 	directly sentinel 
path since 	via 
heavily reused reg 	fake publish 
noerror arrive 	command sentinel 
reg nomatch otherwise 	master name 
extend buffer 	specified message 
need temporary modify 	known message 
mctx setup 	discarded 
initial node fix 	format composed 
mctx check 	tokens port 
current node node 	runid current 
last node 	epoch master 
helper functions check 	name master 
arrival calculate 	master 
destination nodes cur 	port master 
nodes str 	config epoch 
idx append 	obtain reference 
next nodes todo 	master hello 
function similar 	message unknown 
functions transit state 	master 
however function 	skip message 
many additional works 	first see 
unify node 	already sentinel 
may accept multi 	sentinels runid 
enable nodes 	address change 
cur nodes epsilon 	sentinel 
closures cur 	address back 
nodes however exclude 	check another 
nodes inside 	sentinel address 
sub expression whose 	one reporting 
number subexp 	happens port 
open sub expression 	signal 
whose number 	address invalid 
subexp open create 	update later 
node nodes 	hello message 
nodes epsilon 	means invalid 
closures node cur 	address sentinel 
nodes problematic 	runid 
nodes merge problematic 	instance creation 
nodes calculate 	sentinels later 
incrementally helper function 	chance fill 
check arrival 	update local 
expand ecl check 	current epoch 
incrementally epsilon 	received 
closure target isn 	current epoch 
problematic append 	greater update 
dst nodes back 	master info 
references current 	received configuration 
state calculate destination 	newer update 
back references 	state 
appropriate entry mctx 	sentinel pub 
bkref ents 	sub callback 
entry ent appropriate 	hello channel 
calculate destination 	useful order 
back reference 	discover sentinels 
append mctx state 	attached 
log backreference 	master update 
epsilon transit must 	last activity 
check node 	pubsub channel 
current state todo 	note since 
still inefficient 	receive messages 
build transition table 	well 
state succeeded 	timestamp used 
otherwise number destination 	detect link 
states state 	probably disconnected 
build dfa states 	even seems 
corresponds destination 	otherwise sanity 
nodes state dests 	check 
node represents 	reply expect 
nodes destination state 	code follows 
contains dests 	avoid check 
represents characters destination 	details interested 
state accepts 	meeting send 
initialize transiton 	hello 
table first nodes 	message via 
belonging state 	pub sub 
several destinations error 	specified redis 
otherwise avoid 	instance order 
arithmetic overflow size 	broadcast current 
calculation build 	configuraiton 
states destinations merge 	master advertise 
follows destination 	existence sentinel 
states state context 	time message 
constraint build 	following format 
appropriate states contexts 	sentinel sentinel 
care whether 	port 
following character word 	sentinel runid 
character single 	current epoch 
character discern looking 	master name 
character code 	master master 
allocate entry 	port master 
transition table characters 	config 
must exactly 	epoch returns 
one destination accepts 	publish queued 
character see 	correctly otherwise 
nodes astates destination 	err returned 
accepts word 	use specified 
character care whether 	announce 
following character 	address specified 
word character multi 	otherwise obtain 
character discern 	address format 
looking character code 	send hello 
build two 	message info 
entry transition tables 	sentinel 
one starting 	info current 
trtable one starting 	master reset 
trtable sbc 	last pub 
max characters must 	time instances 
exactly one 	specified 
destination accepts 	dictionary order 
character see nodes 	force delivery 
astates destination 	hello update 
accepts word character 	asap function 
line current 	forces delivery 
state accepts newline 	hello 
character destination 	message see 
accepts newline character 	sentinel send 
must one 	hello top 
destination accepts newline 	comment information 
see nodes 	redis sentinel 
astates nodes belonging 	instances 
state several 	related specified 
destinations destinations nodes 	master technically 
belonging destination 	needed since 
dests node characters 	send update 
accepted destination 	every instance 
dest function number 	period 
destinations number 	sentinel publish 
destinations state 	period milliseconds 
characters node accept 	however sentinel 
nodes belonging 	upgrades configuration 
state enumerate single 	good idea 
character node 	deliever 
accept check accepts 	update sentinels 
sift characters 	asap send 
match context divide 	ping specified 
accepts dfa 	instance refresh 
states create state 	act ping 
make sure 	time 
accepts empty intersection 	zero received 
sets see 	pong previous 
flags see optimization 	ping error 
skip state 	zero returned 
doesn accept character 	consider ping 
enumerate intersection 	command 
state accepts skip 	queued connection 
intersection empty 	update active 
check state 	ping time 
subset accepts state 	received pong 
isn subset 	previous ping 
accepts create state 	otherwise 
remains put 	technically waiting 
position current characters 	since first 
consumed next 	ping received 
node characters remain 	reply send 
create check 	periodic ping 
many bytes node 	info 
dfa nodes 	publish hello 
node idx accepts 	channel specified 
number bytes 	master slave 
node accepts str 	instance asap 
idx current 	already ping 
index input function 	info 
handles nodes 	already pending 
accept one character 	instance properly 
one collating 	connected info 
element like 	ping publish 
opposite nodes accept 	critical commands 
one fixme 	send 
think needed len 	also limit 
accepts one 	sentinel max 
character following two 	pending commands 
cases libc 	want use 
match multibyte character 	lot memory 
match character 	link 
include defines local 	working properly 
function match 	note anyway 
collating symbol compare 	redundant protection 
length input 	link disconnected 
collating element length 	reconnected timeout 
current collating 	condition 
element compare bytes 	detected slave 
match every 	master condition 
bytes equal 	start sending 
match range expression 	info every 
match equivalence 	second instead 
libc match range 	usual 
expression valid 	sentinel info 
character match single 	period period 
character skip 	state want 
name collating element 	closely monitor 
name found 	slaves turned 
entry skip sequence 	masters 
collating element 	another sentinel 
adjust alignment skip 	sysadmin ping 
collation sequence 	instances every 
skip wide sequence 	time last 
collating element 	received pong 
found entry sequence 	older 
skip collation 	configured milliseconds 
sequence libc enable 	time every 
check whether 	second anyway 
node accepts 	milliseconds greater 
idx input fallthrough 	second send 
node constraints 	info 
check whether current 	masters slaves 
context satisfies 	sentinels send 
constraints extend buffers 	ping three 
buffers run 	kinds instances 
avoid overflow lengthes 	publish hello 
buffers length 	messages 
state log xxx 	three kinds 
indication size 	instances sentinel 
buffer allocation fail 	command redis 
indication state 	instance redis 
log right size 	protocol representation 
reconstruct buffers 	last 
enable enable functions 	masters slaves 
matching context 	masters slaves 
initialize mctx already 	sentinels output 
zero caller 	number instances 
mctx bkref 	contained inside 
ents mctx nbkref 	dictionary 
ents mctx 	redis protocol 
nsub tops clean 	lookup named 
entries depend 	master sentinel 
current input mctx 	masters master 
function must 	found reply 
invoked matcher changes 	client 
start index 	error returns 
input changes input 	number usable 
free memory 	sentinels init 
associated mctx first 	count known 
free memory 	sentinels sentinel 
associated mctx sub 	masters 
tops backreference 	sentinel master 
entry mctx note 	name sentinel 
caller never 	slaves master 
call function duplicate 	name sentinel 
entry call 	sentinels master 
str idx 	name 
isn smaller existing 	sentinel master 
entry cache 	addr port 
saves negative results 	current epoch 
check dst 	runid arguments 
limits calc pos 	port port 
bit clear 	master 
means entry won 	want sentinel 
epsilon transition 	note command 
open subexp close 	check name 
subexp subexpression 	master theory 
check dst limits 	different sentinels 
calc pos 	may 
recurse find one 	monitor differnet 
node backreference 	masters name 
epsilon transition unless 	current epoch 
empty zeros 	needed order 
search first 	understand allowed 
entry str idx 	vote 
none found 	failover leader 
note mctx bkref 	sentinel vote 
ents already 	one time 
sorted mctx str 	per epoch 
idx node 	runid seeking 
node whose type 	vote 
open subexp 	sentinel order 
matches str idx 	elect failover 
node node 	leader otherwise 
whose type close 	runid want 
subexp matches 	sentinel vote 
str idx whose 	already 
corresponding open 	voted exists 
subexp sub top 	actually master 
regex internalc 	subjectively note 
function function function 	tilt mode 
pstr str 	always reply 
len init 	vote 
len trans icase 	master fetch 
dfa ret 	previous vote 
init buf len 	request includes 
pstr str 	runid otherwise 
len trans icase 	sender seeking 
dfa ret 	vote 
pstr buf len 	reply three 
wcs max 	elements multi 
size offsets mbs 	bulk reply 
str len 	state leader 
pstr trans icase 	vote epoch 
dfa pstr 	sentinel 
buf buf prev 	reset pattern 
idx end 	sentinel master 
idx remain len 	addr name 
mbclen pstr 	master name 
prev src idx 	sentinel failover 
idx end 	master 
idx remain 	name sentinel 
len mbclen buf 	pending scripts 
buf wcu 	sentinel monitor 
mbcdlen wcu mbcdlen 	name port 
pstr raw 	quorum make 
idx last prev 	sure 
rawbuf idx 	field actually 
mbclen remain len 	valid passing 
pstr idx 	create sentinel 
end idx pstr 	redis instance 
buf idx 	otherwise may 
end idx pstr 	trigger 
idx eflags 	dns lookup 
offset mid prev 	runtime parameters 
valid len 	valid create 
wcs idx raw 	master instance 
end cur 	sentinel name 
state mlen buf 	sentinel 
mbclen ret 	ckquorum name 
peek fetch 	sentinel info 
pstr input idx 	cache name 
eflags idx 	create hoc 
size elem elem 	dictionary type 
elem dest 	iterate 
src dest src 	dictionary composed 
src delta 	master groups 
sbase alloc elems 	user requested 
dest src 	ignore non 
src dest src 	existing names 
sbase delta 	reply 
alloc buffer elem 	format master 
idx elems 	name info 
elem elems node 	master info 
compare node 	replica master 
contains idx dfa 	name self 
token nodes 	sentinel 
alloc nexts 	simulate failure 
indices edests eclosures 	flag flag 
nodes max 	flag sentinel 
size nodes context 	info section 
hash err 	sentinel verison 
dfa nodes hash 	role 
state spot 	command output 
state err dfa 	sentinel list 
nodes context 	currently monitored 
hash state spot 	master names 
state dfa 	sentinel mastername 
newstate hash spot 	option 
err elem 	process option 
alloc state dfa 	pairs millisecodns 
nodes hash 	milliseconds failover 
err newstate node 	timeout milliseconds 
type dfa 	parallel syncs 
nodes context hash 	milliseconds 
nctx nodes 	notification script 
err newstate 	path client 
node type constraint 	reconfig script 
construct common 	path auth 
realloc buffers memset 	pass password 
construct common 	quorum 
realloc buffers build 	count bad 
wcs upper 	format errors 
buffer realloc buffers 	fake publish 
build upper 	command actually 
buffer build wcs 	useful receive 
buffer translate 	hello 
buffer max realloc 	messages sentinel 
realloc mbrtowc 	instances publishing 
isascii mbsinit toupper 	channel sentinel 
mbrtowc iswlower 	hello channel 
towupper wcrtomb memcpy 	forbidden sentinel 
memcpy mbrtowc 	publish 
iswlower towupper wcrtomb 	code send 
memcpy malloc 	hello messages 
memcpy memcpy 	three kind 
memcpy mbrtowc islower 	instances masters 
toupper memset 	slaves sentinels 
context memmove memmove 	sentinel 
memset context 	availability checks 
memmove memmove isascii 	instance point 
memset memset 	view check 
mbrtowc memset skip 	need reconnection 
chars context 	one links 
wide word wide 	detecting 
newline memset 	low activity 
bitset contain newline 	check command 
build wcs 	link seems 
upper buffer build 	connected connected 
wcs buffer 	less sentinel 
build upper buffer 	min 
translate buffer 	link reconnect 
free free free 	period still 
wide word 	pending ping 
wide newline 	half timeout 
bitset contain newline 	ther pending 
memset malloc 	ping 
malloc malloc malloc 	pending ping 
memcpy node 	delayed received 
init empty realloc 	error replies 
memcpy malloc 	well check 
node init copy 	pubsub link 
node init 	seems 
copy node init 	connected connected 
empty memcpy 	less sentinel 
memcpy realloc memcpy 	min link 
memcpy memcpy 	reconnect period 
node init realloc 	still activity 
realloc max 	pub 
max realloc realloc 	sub channel 
realloc realloc 	sentinel publish 
realloc node init 	period update 
empty node 	sdown flag 
init empty 	believe instance 
calc state hash 	sdown 
node compare 	replying believe 
create newstate calc 	master reports 
state hash 	slave enough 
node compare create 	time meet 
newstate node 	period plus 
alloc epsilon node 	enough 
node insert 	time two 
last realloc node 	times info 
free node 	report instance 
free node free 	subjectively subjectively 
free node 	instance according 
free free free 	configured 
free calloc 	quorum note 
node init copy 	odown weak 
free state 	quorum means 
free state 	enough sentinels 
calloc node init 	reported given 
copy free 	time 
malloc free state 	range instance 
node init 	reachable however 
copy satisfy prev 	messages delayed 
constraint node 	strong guarantees 
state free state 	instances agreeing 
extended regular 	time 
expression matching search 	state enough 
library copyright 	sentinels current 
free software foundation 	sentinel count 
inc file 	sentinels flag 
part gnu library 	accordingly outcome 
contributed isamu 	receive 
hasegawa isamu yamato 	sentinel master 
ibm gnu 	addr reply 
library free software 	see sentinel 
redistribute modify 	ask master 
terms gnu 	state sentinels 
lesser general license 	function 
published free 	information ignore 
software foundation either 	every error 
version license 	unexpected reply 
option later version 	note command 
gnu library 	returns error 
distributed hope useful 	reason 
without warranty 	end clearing 
without even implied 	sri master 
warranty merchantability 	flag timeout 
fitness particular purpose 	anyway runid 
see gnu 	reply sentinel 
lesser general license 	actually 
details received 	replied vote 
copy gnu lesser 	think master 
general license 	start sending 
along gnu library 	sentinel master 
write free 	addr requests 
software foundation 	sentinels 
inc franklin street 	order replies 
fifth floor 	allow reach 
boston usa safety 	quorum needed 
functions operation 	mark master 
function allocate buffers 	odown state 
necessary call 	trigger 
reconstruct ensure least 	failover master 
one character 	state sentinel 
fits buffers function 	old clear 
allocate buffers 	ask master 
initialize enable enable 	sentinels believe 
helper functions 	failover 
allocate construct avoid 	progress sentinel 
overflow realloc 	connected received 
enable build wide 	info within 
character buffer 	sentinel ask 
pstr wcs sequence 	period ask 
wide character 	failover 
buffer weof 	crash user 
weof use weof 	request via 
padding indicate 	sentinel simulate 
position isn first 	failure command 
multibyte character 	vote sentinel 
note function assumes 	req 
pstr valid 	runid old 
len elements already 	vote already 
built starts 	voted specifed 
pstr valid len 	req epoch 
build buffers 	one greater 
pstr valid len 	vote 
either pstr 	available returns 
len pstr bufs 	otherwise sentinel 
len apply 	runid populate 
translation need buffer 	leader epoch 
doesn enough 	epoch vote 
space finish 	voted 
build treat cases 	master failover 
singlebyte character 	start time 
write wide character 	order force 
padding write 	delay start 
paddings build wide 	failover master 
character buffer 	helper 
pstr wcs like 	function sentinel 
build wcs 	leader increment 
buffer reg icase 	counter relative 
following optimization 	specified runid 
assumes ascii characters 	scan sentinels 
mapped wide 	attached 
characters simple cast 	master check 
singlebyte character 	leader specified 
next step uses 	epoch leader 
assumption wchar 	given epoch 
encoded ascii safe 	majority sentinels 
ascii values 	know 
converted like 	ever seen 
write paddings invalid 	since last 
character use 	sentinel reset 
also cast wide 	reported instance 
buffer doesn 	leader epoch 
enough space finish 	sentinels 
build write 	count sentinels 
paddings invalid character 	votes check 
use also 	winner winner 
cast wide buffer 	win needs 
doesn enough 	two conditions 
space finish build 	absolute 
skip characters 	majority voters 
index becomes greater 	anyway least 
raw idx 	master quorum 
index skip characters 	votes count 
necessary check 	sentinel vote 
treat cases single 	sentinel 
character proceed 	voted yet 
next character 	either vote 
enable build buffer 	common voted 
pstr mbs 	sentinel vote 
apply translation need 	exists send 
function used 	slaveof 
reg icase apply 	specified instance 
trans buffer 	always followed 
pstr function construct 	config rewrite 
buffers concretely 	command order 
convert wide character 	store 
pstr cur 	configuration disk 
max convert upper 	possible redis 
reg icase 	instance recent 
apply translation reset 	enough support 
buffer enable 	config rewriting 
already characters kept 	server 
yes move 	started configuration 
front buffer quite 	file host 
complicated handle 	function sends 
specially common 	slaveof one 
easy character different 	command returns 
length representation 	slaveof 
lower upper present 	command accepted 
offset otherwise 	later delivery 
find multibyte character 	otherwise err 
offset fill 	command replies 
weof enable skip 	discarded host 
characters idx 	send 
special utf multi 	slaveof one 
chars start 	turn instance 
xbf know wchar 	master order 
encoding ucs 	send slaveof 
simple ascii characters 	safe way 
skip conversion 	send 
step pstr valid 	transaction performing 
len xxx 	following tasks 
use mbrtowc 	reconfigure instance 
know conversion use 	according specified 
utf ucs 	host port 
enable build buffers 	rewrite 
enable handle 	configuraiton disconnect 
common easiest cases 	clients one 
first ensure 	sending commnad 
utf backslash dotless 	order trigger 
small letter 	ask master 
function returns capital 	reconnection 
letter instead 	protocol connected 
first dotless small 	clients note 
letter latter 	check replies 
would confuse parser 	returned commands 
since peek 	since observe 
doesn advance cur 	instead 
idx way 	effects next 
utf islower capital 	info output 
letter dot 	client kill 
lower mbs 	type type 
skip whole multi 	supported starting 
character original 	redis 
letter side dotless 	however sending 
small letter 	instance understanding 
anything would complicate 	command issue 
things much 	client variadic 
enable context idx 	command redis 
input use 	recognized 
stored input tip 	syntax error 
context since 	transaction fail 
know character input 	unsupported command 
mbs must 	fail setup 
happen functions operation 	master state 
adr valgrind 	start 
says size doesn 	failover function 
free block 	checks conditions 
size harumph seems 	start failover 
work though 	master must 
calculate intersection 	odown condition 
sets src src 	failover 
merge dest 	already progress 
indicate error code 	failover already 
reg noerror 	attempted recently 
succeeded note dest 	still know 
elems dest 	win election 
alloc need dest 	possible 
nelem elems 	start failover 
intersection conservative estimate 	able act 
find items 	non zero 
intersection src src 	failover started 
copy top 	failover master 
dest already dest 	state 
find item 	failover already 
dest maybe could 	progress last 
binary search 	failover attempt 
lower highest two 	started little 
items copy 	time ago 
delta becomes 	newline 
zero remaining dest 	suitable slave 
elements already 	promote current 
place less loop 	algorithm uses 
node merge 	following parameters 
copy top slide 	none following 
bottom copy 	conditions 
remaining src elements 	disconnected last 
calculate sets 	time slave 
src src store 	replied ping 
dest indicate 	times ping 
error code reg 	period info 
noerror succeeded 	refresh 
calculate sets dest 	older times 
src store 	info refresh 
dest indicate error 	period master 
code reg 	link time 
noerror succeeded copy 	master since 
top dest 	time 
items src 	master period 
found dest maybe 	basically since 
could binary 	master pov 
search dest dest 	slave reports 
elems src 	disconnected times 
elems dest exhausted 	configured 
remaining items 	period pretty 
src must unique 	much black 
copy delta 	magic idea 
becomes zero remaining 	master available 
dest elements 	slave may 
already place copy 	lagging 
top slide 	certain time 
bottom copy remaining 	anyway best 
src elements 	slave according 
insert element elem 	replication offset 
node already 	slave priority 
elem error 	zero 
occurred otherwise empty 	otherwise slave 
already guaranteed 	discarded among 
alloc realloc need 	slaves matching 
move elements 	conditions slave 
follows element test 	order sorting 
first element 	key 
separately skip check 	lower slave 
inner loop 	priority bigger 
insert element insert 	processed replication 
element elem 	offset lexicographically 
node already element 	smaller runid 
greater equal 	basically 
elem error occurred 	runid slave 
otherwise realloc 	processed commands 
need insert element 	master selected 
compare two 	function returns 
node sets equivalent 	pointer selected 
otherwise idx 	slave 
contains element 	otherwise suitable 
elem otherwise binary 	slave found 
search element 	helper sentinel 
token token dfa 	slave used 
nodes index 	qsort order 
token error occurred 	sort 
avoid overflows 	suitable slaves 
realloc search state 	better first 
whose node 	order take 
equivalent nodes pointer 	first list 
state found 	priority slave 
dfa otherwise create 	greater 
one error 	replication offset 
error code err 	processed data 
note invalid 	frmo master 
state possible err 	replication offset 
reg noerror 	slave lexicographically 
never non errors 	smaller 
optimization appropriate 	runid note 
state dfa 	handle runid 
create one search 	old redis 
state whose 	versions publish 
node equivalent nodes 	runid info 
whose context 	runid 
equivalent context pointer 	considered bigger 
state found 	runid master 
dfa otherwise create 	sdown state 
one error 	info slaves 
error code err 	every second 
note invalid 	otherwise 
state possible err 	usual period 
reg noerror 	need account 
never non errors 	larger delay 
optimization appropriate 	failover state 
state dfa create 	machine implementation 
one finish 	check 
initialization state newstate 	leader failover 
hash hash 	epoch leader 
put appropriate 	forced failover 
bucket dfa state 	via sentinel 
table indicates 	failover failover 
error code failed 	election 
create state 	timeout min 
independ contexts state 	sentinel election 
succeeded otherwise 	timeout configured 
enable state halt 	failover timeout 
node state 	abort failover 
halt state create 	leader 
state depend 	time handle 
context context state 	timeout state 
succeeded otherwise 	function aborts 
enable state halt 	failover forward 
node state 	next state 
halt state regex 	send 
internalh attribute 	command promoted 
hidden attribute 	slave disconnected 
hidden raw mbs 	retry state 
mbs wcs 	timeout reached 
offsets cur state 	abort failover 
raw mbs 	send 
idx valid len 	slaveof one 
valid raw 	command turn 
len bufs len 	slave master 
cur idx 	actually callback 
raw len len 	command really 
raw stop 	care 
stop tip context 	reply check 
trans word 	worked indirectly 
icase utf map 	observing info 
notascii mbs 	returns different 
allocated offsets needed 	role master 
newline anchor 	instead 
word ops used 	slave actually 
cur max 	wait promotion 
pstr buf 	indirectly checking 
len pstr pstr 	info slave 
pstr pstr 	turns master 
attribute parent left 	handle 
right first 	timeout switching 
next token node 	next state 
idx next 	handled function 
data hash nodes 	parsing info 
non eps 	command promoted 
nodes inveclosure entrance 	slave 
nodes trtable 	consider failover 
word trtable num 	finished promoted 
alloc node 	slave reachable 
str idx subexp 	failover terminates 
subexp unused 	reachable slaves 
eps reachable subexps 	properly 
map idx 	configured force 
node regs eps 	end failover 
via nodes 	timeout leader 
num alloc 	good idea 
stack nodes nodes 	send best 
alloc nodes 	effort 
len nexts indices 	slaveof command 
edests eclosures 	slaves still 
inveclosures state table 	reconfigured replicate 
init state 	master send 
init state word 	slave master 
init state 	address 
init state begbuf 	remaining slaves 
str str 	still appear 
storage str storage 	configuration updated 
idx state 	skip promoted 
hash mask init 	slave already 
node nbackref 	configured 
used bkref map 	slaves much 
completed bkref 	time elapsed 
map cur max 	without slave 
word syntax 	moving forward 
subexp map 	next state 
str bitset dest 	consider 
src bitset 	reconfigured even 
dest src bitset 	sentinels detect 
size wchar 	slave misconfigured 
elem size extended 	fix configuration 
regular expression 	later nothing 
matching search library 	instances 
copyright free 	disconnected already 
software foundation inc 	reconf sent 
file part 	state send 
gnu library contributed 	slaveof master 
isamu hasegawa 	check slaves 
isamu yamato ibm 	reconfigured 
gnu library 	handle timeout 
free software redistribute 	function called 
modify terms 	slave sentinel 
gnu lesser 	failover state 
general license published 	update config 
free software 	state 
foundation either version 	state need 
license option 	master table 
later version gnu 	promoted slave 
library distributed 	instead abort 
hope useful without 	failover progress 
warranty without 	function 
even implied warranty 	called promoted 
merchantability fitness 	slave acknowledged 
particular purpose see 	slave master 
gnu lesser 	otherwise failover 
general license details 	aborted reach 
received copy 	end 
gnu lesser general 	possibly timeout 
license along 	sentinel timer 
gnu library write 	handler main 
free software 	sentinel sentinel 
foundation inc 	completely non 
temple place suite 	blocking 
boston usa 	design function 
wchar libc wctype 	called every 
libc stdbool 	second perform 
libc stdint libc 	scheduled operations 
zos uss 	specified redis 
system doesn isblank 	instance 
gawk freaking 	monitoring half 
mess glibc systems 	every kind 
define magic 	instance acting 
constant isblank ctype 	half proceed 
since function 	acting half 
heck borrow page 	tilt 
dfa book 	mode tilt 
gawk gnu distributions 	happens find 
internationalized messages 	something odd 
define xgettext find 	time like 
internationalizable loser 	sudden change 
systems without 	clock 
definition gawk number 	every kind 
single character 	instance masters 
character represents newline 	slaves nothing 
rename standard 	far masters 
api glibc gawk 	perform scheduled 
libc integer 	operations 
used represent bits 	instances dictionary 
must must 	recursively call 
least wide bits 	function dictionaries 
bitset word 	slaves number 
number bits bitset 	things need 
word number 	perform 
bitset word bit 	every master 
node type 	function checks 
used token node 	need enter 
enable define 	titl mode 
epsilon bit macro 	tilt mode 
open subexp 	entered 
used debugger 	detect two 
shows values type 	invocations timer 
type used 	interrupt negative 
token type used 	amount time 
token multibyte 	much time 
characters collating symbols 	passed 
equivalence classes 	note expect 
range expressions libc 	less milliseconds 
libc character 	pass everything 
classes character non 	fine however 
matching list 	see negative 
multibyte characters collating 	number 
symbols equivalence 	difference bigger 
classes range expressions 	sentinel tilt 
character classes 	trigger milliseconds 
enable character simple 	one following 
bracket complex 	conditions happen 
bracket enable back 	sentiel 
anchor context 	process time 
constraint bits 	blocked every 
moved needed running 	kind random 
bits move 	reason load 
opr opr move 	huge computer 
flags opr 	frozen 
flags indicate raw 	time alike 
buffer original 	process stopped 
passed argument regexec 	signal everything 
search etc 	system clock 
store multibyte insensitive 	altered significantly 
mode like 	conditions 
reg icase upper 	see everything 
cases stored 	timed failing 
otherwise mbs points 	without good 
address raw 	reasons instead 
mbs points store 	enter tilt 
wide character 	mode 
corresponding mbs 	wait sentinel 
index raw mbs 	tilt period 
character mbs 	elapse starting 
corresponds raw mbs 	act tilt 
raw mbs 	time still 
idx length valid 	collect 
characters buffers 	information act 
corresponding number bytes 	continuously change 
raw mbs 	frequency redis 
length buffers mbs 	timer interrupt 
wcs index 	order desynchronize 
mbs updated fetch 	every 
length raw 	sentinel every 
mbs raw len 	non determinism 
raw mbs 	avoids sentinels 
idx valid len 	started time 
valid raw 	exactly stay 
len end buffer 	asking 
may shorter 	voted time 
length cases 	resulting nobody 
match search use 	likely winning 
stop end 	election split 
buffer instead len 	brain voting 
raw stop 	server.c 
raw mbs idx 	shared zero 
adjusted offsets 	pos inf 
context mbs store 	neg inf 
context independently 	nan server 
since context mbs 	redis command 
may different 	table 
raw mbs beginning 	level msg 
input translation 	syslog level 
passed part argument 	map buf 
compile pattern 	rawmode log 
copy dfa word 	stdout role 
reg icase 	pid 
enable usually guarantees 	level fmt 
one guard 	msg level 
page bottom 	msg log 
stack page size 	stdout buf 
small bytes 	ust retcode 
cannot safely allocate 	privdata 
anything larger 	val privdata 
bytes also care 	val privdata 
possibility compiler 	key key 
allocated temporary stack 	privdata key 
slots alloca 	key privdata 
implemented malloc use 	val 
malloc sun 	privdata val 
realloc doesn accept 	privdata key 
pointers pre 	key key 
standard sigh node 	key key 
idx index 	privdata key 
dfa nodes type 	key 
otherwise type 	cmp key 
indicate type node 	buf len 
state accept 	hash dict 
multi note 	type zset 
refer multibyte characters 	dict type 
multi character 	dict 
collating elements multi 	type sha 
state backreference 	script dict 
node type used 	type keyptr 
sub match 	dict type 
last sub match 	command table 
top store 	dict 
information node node 	type hash 
whose type 	dict type 
close subexp position 	keylist dict 
node match 	type cluster 
store information node 	nodes 
node whose 	dict type 
type open subexp 	cluster nodes 
information node 	black list 
whose type 	dict type 
close subexp corresponding 	migrate cache 
node stored 	dict 
lasts allocation size 	type repl 
lasts number 	script cache 
lasts corresponding input 	dict type 
eflags argument 	dict size 
regexec matching ends 	used dbid 
state log 	dbid 
used matcher back 	key keyobj 
reference cache 	type current 
number subexpressions nsub 	timelimit exit 
regex number 	last fast 
backreference dfa bitmap 	cycle iteration 
expressing backreference 	dbs 
used dfa multibyte 	per call 
node backreference 	timelimit expired 
node accept multibyte 	num slots 
character multi 	ttl sum 
character collating 	ttl samples 
element functions bitset 	ttl 
operation functions 	avg ttl 
libc enable regex 	elapsed metric 
remote-curl.c remote 	current reading 
url verbosity depth 	ops ops 
options cas 	sec metric 
options name end 	sum 
end val 	querybuf size 
service buf alloc 	idletime numclients 
buf len 	iterations head 
refs shallow last 	resize rehash 
discovery heads 	dbs per 
push list heads 	call 
data start 	work done 
mid name refs 	loop client 
last type 	data size 
charset msg eol 	used vkeys 
service push 	statloc pid 
exp type 	exitcode 
charset buffer refs 	bysignal growth 
url effective 	loop argv 
url last http 	dictid str 
ret maybe 	dictid len 
smart options line 	environ flags 
push heads 	delay 
refs posn service 	maxfiles limit 
name argv 	oldlimit bestlimit 
stdin preamble service 	setrlimit error 
url hdr 	decr step 
content type hdr 	old maxclients 
accept buf 	buf 
alloc len pos 	somaxconn port 
result ptr 	fds count 
eltsize nmemb buffer 	numcommands retval 
max rpc 	retval numcommands 
avail handle cmd 	cmd dbid 
clientp rpc 	argv 
ptr eltsize 	argc target 
nmemb buffer size 	name cmd 
rpc slot 	name name 
results err results 	cmd cmd 
buf msg 	dbid argv 
rpc results slot 	argc 
headers buf 	flags cmd 
err rpc slot 	dbid argv 
headers use 	argc target 
gzip gzip body 	argvcopy flags 
gzip size 	flags dirty 
err large request 	start 
needs left 	duration client 
buf results stream 	old flags 
ret rpc 	latency propagate 
heads svc buf 	flags rop 
preamble client 	target hashslot 
err buf 	error 
heads fetch walker 	code retval 
targets ret 	unlink unix 
heads heads fetch 	socket flags 
rpc preamble 	save nosave 
depth arg err 	bufa bufb 
argv buf 	alen 
heads fetch buf 	blen diff 
fetch list 	cmd reply 
head list heads 	cmd flagcount 
name old 	flaglen cmd 
oid spec specs 	keys numkeys 
child heads 	section 
spec specs rpc 	info uptime 
err args 	numcommands self 
cas option preamble 	lol bib 
spec specs 	defsections sections 
heads ret buf 	call uname 
specs ret 	name 
argc argv 	mode hmem 
buf nongit arg 	peak hmem 
push result 	total system 
strcmp strtol strcmp 	hmem used 
strcmp strcmp 	memory lua 
strcmp strtoul strcmp 	hmem 
strcmp strcmp 	used memory 
strcmp strcmp strcmp 	rss hmem 
strcmp strcmp 	maxmemory hmem 
strcmp strcmp strbuf 	zmalloc used 
addf list 	total system 
append strbuf release 	mem 
strcmp strcmp 	evict policy 
strcmp strcmp strcmp 	memory lua 
strcmp strcmp 	perc eta 
strcmp strcmp strcmp 	elapsed remaining 
strcmp strcmp 	bytes slave 
strcmp strcmp remote 	repl 
heads die 	offset slaveid 
alloc oid 	slave state 
hex alloc http 	port lag 
fetch resolve 	keys vkeys 
remote symref free 	section sampledict 
free free 	keydict 
free refs free 	pool count 
strcmp strbuf 	samples samples 
reencode log output 	idle key 
encoding strbuf 	mem used 
trim strchrnul strcmp 	mem tofree 
free discovery 	mem 
strbuf addf starts 	freed slaves 
starts git 	latency eviction 
env strchr strbuf 	latency slave 
addch strbuf 	obuf bytes 
addch strbuf addf 	keys freed 
memset http 	bestval 
strbuf show http 	bestkey dict 
message die 	pool thiskey 
show http 	thisval delta 
message die show 	keyobj buf 
http message 	buf mode 
die xcalloc strbuf 	sig 
detach strbuf 	msg act 
addf strbuf cmp 	megabytes passes 
packet read 	argc argv 
line buf strbuf 	start allocation 
reset strbuf 	size title 
addf strcmp die 	server 
strbuf release 	mode upstart 
packet read line 	job notify 
buf parse 	socket iov 
git refs parse 	hdr sendto 
info refs 	flags mode 
strbuf release strbuf 	upstart 
release strbuf 	job notify 
release strbuf release 	socket argc 
strbuf release 	argv options 
strbuf release 	configfile background 
discover refs discover 	fopen getpid 
refs oid 	gettimeofday 
hex fflush packet 	strftime localtime 
read memcpy 	snprintf getpid 
error write die 	fflush fclose 
run one 	syslog start 
slot strbuf addf 	vsnprintf end 
strbuf addch 	server 
strbuf addf strbuf 	log raw 
addch strbuf 	open getpid 
addstr error strbuf 	write strlen 
release active 	write time 
slot curl slist 	write strlen 
append curl 	write 
slist append curl 	write strlen 
easy setopt 	write close 
curl easy 	gettimeofday ustime 
setopt curl easy 	exit exit 
setopt curl 	dict notused 
easy setopt curl 	zfree 
easy setopt 	dict notused 
curl easy setopt 	list release 
curl easy 	dict notused 
setopt curl easy 	sdslen sdslen 
setopt curl 	memcmp dict 
easy setopt run 	notused 
slot curl 	strcasecmp dict 
slist free strbuf 	notused decr 
release packet 	count dict 
read probe rpc 	notused sdsfree 
credential fill 	dict sds 
curl slist append 	key 
curl slist 	compare dict 
append curl slist 	gen hash 
append active 	function sdslen 
slot curl 	dict gen 
easy setopt curl 	hash function 
easy setopt 	sdslen 
curl easy setopt 	dict gen 
curl easy 	hash function 
setopt curl slist 	sdslen decoded 
append curl 	decoded dict 
easy setopt curl 	sds key 
easy setopt 	compare 
curl easy setopt 	decr count 
curl easy 	decr count 
setopt fflush curl 	sds encoded 
easy setopt 	dict gen 
curl easy setopt 	hash function 
git deflate 	sdslen 
init gzip git 	dict gen 
deflate bound 	hash function 
xmalloc git deflate 	decoded dict 
die git 	gen hash 
deflate end 	function sdslen 
gently die curl 	decr 
slist append 	count dict 
curl easy setopt 	slots dict 
curl easy 	size needs 
setopt fflush curl 	resize dict 
easy setopt 	resize needs 
curl easy setopt 	resize 
fflush curl 	dict resize 
easy setopt curl 	dict rehashing 
easy setopt 	dict rehash 
curl easy setopt 	milliseconds dict 
run slot 	rehashing dict 
credential fill curl 	rehash 
slist free 	milliseconds dict 
free start command 	enable resize 
exit write 	dict disable 
die write die 	resize dict 
xmalloc strbuf 	integer val 
init strbuf 	dict 
addf strbuf detach 	key create 
strbuf addf 	sdslen propagate 
strbuf detach strbuf 	expire notify 
addf strbuf 	keyspace decr 
detach packet read 	count ustime 
post rpc 	dict 
close strbuf read 	size dict 
xread close 	slots mstime 
finish command free 	dict random 
free free 	key dict 
free strbuf release 	integer val 
alloc die 	active 
xstrdup oid hex 	expire cycle 
http walker 	expire ustime 
walker fetch walker 	latency sample 
free free 	needed mstime 
free error 	mstime mstime 
strbuf addf strbuf 	server 
detach die 	log free 
packet buf write 	client reply 
oid hex 	blocked client 
packet buf flush 	timed unblock 
memset rpc 	client cluster 
service write die 	redirect 
strbuf release 	blocked client 
strbuf release free 	needed unblock 
discover refs 	client sds 
fetch git fetch 	alloc size 
dumb skip 	sdsavail sds 
prefix oid hex 	free 
die die 	space list 
alloc oidcpy alloc 	length mstime 
grow die 	list length 
strbuf reset strbuf 	list rotate 
getline fetch 	list first 
exit free 	list 
refs free fflush 	node clients 
strbuf reset 	cron handle 
argv push argv 	timeout clients 
push argv 	cron resize 
push argv push 	query buffer 
argv push 	active 
argv push run 	expire cycle 
command die 	resize hash 
argv init argv 	tables incrementally 
pushl argv 	rehash time 
push argv push 	mstime unused 
argv push 	unused 
argv push argv 	unused watchdog 
push argv 	schedule signal 
push argv push 	update cached 
argv push 	time track 
argv push argv 	instantaneous metric 
push packet 	track 
buf write 	instantaneous metric 
packet buf flush 	track instantaneous 
memset rpc 	metric lru 
service write die 	clock zmalloc 
strbuf release 	used memory 
strbuf release argv 	zmalloc 
clear discover 	used memory 
refs push git 	zmalloc rss 
push dav 	prepare shutdown 
free discovery starts 	exit server 
alloc grow 	log dict 
xstrdup die strbuf 	slots 
reset strbuf 	dict size 
getline push fflush 	dict size 
exit free 	server log 
free git setup 	server log 
gettext git 	list length 
extract argv path 	list 
setup git 	length list 
directory gently 	length zmalloc 
error isatty remote 	used memory 
end url 	clients cron 
slash end url 	databases cron 
slash http 	rewrite 
init strbuf getline 	append file 
ferror error 	background ldb 
starts die parse 	pending children 
fetch strcmp 	wait wexitstatus 
starts strstr output 	wifsignaled wtermsig 
refs refs 	server 
starts parse push 	log strerror 
skip prefix 	background save 
strchr option fflush 	done handler 
strcmp fflush 	background rewrite 
error strbuf reset 	done handler 
http cleanup 	ldb 
always ends 	child server 
trailing slash one 	log update 
send pack 	dict resize 
push cert constants 	policy server 
libcurl version 	log rdb 
num unsupported show 	save 
text plain 	background server 
parts types likely 	log rewrite 
ugly look 	append file 
user terminal smart 	background flush 
http response 	append file 
validate service pkt 	flush 
line matches 	append file 
request header include 	free clients 
additional metadata 	free queue 
lines packet flush 	clients paused 
marker ignore 	replication cron 
future might start 	cluster 
scan load 	cron sentinel 
entire request 	timer migrate 
fit allocated buffer 	close timedout 
space use 	sockets unused 
http avoid chunked 	cluster sleep 
encoding mess 	active 
request body large 	expire cycle 
size cannot 	create create 
predicted must use 	create replication 
chunked encoding 	feed slaves 
send looping retry 	decr count 
authentication previous 	decr 
run headers gzip 	count decr 
buffer already 	count list 
need send client 	length process 
backend isn 	clients waiting 
giving compressed data 	replicas list 
deflate may 	length 
save transfer time 	process unblocked 
know complete 	clients flush 
request size 	append file 
advance use normal 	handle clients 
content length 	pending writes 
approach error already 	create 
reported error 	sdsnew create 
already reported remote-ext.c 	sdsnew create 
git req 	sdsnew create 
git req vhost 	sdsnew create 
str service 	sdsnew create 
next rpos escape 	sdsnew 
special service 	create sdsnew 
noprefix ret arg 	create sdsnew 
service expanded 	create sdsnew 
stdin serv repo 	create sdsnew 
vhost arg 	create sdsnew 
service child child 	create 
buffer argc 	sdsnew create 
argv prefix skip 	sdsnew create 
prefix setenv 	sdsnew create 
setenv die 	sdsnew create 
die strbuf addch 	sdsnew create 
strbuf addstr 	sdsnew 
strbuf addstr strbuf 	create sdsnew 
addch strbuf 	create sdsnew 
detach strbuf detach 	create sdsnew 
strbuf detach 	create sdsnew 
strip escapes argv 	create sdsnew 
push free 	create 
packet write packet 	sdsnew create 
write parse 	sdsnew create 
argv start command 	sdsnew create 
die send 	sdsnew create 
git request bidirectional 	sdsnew create 
transfer loop 	sdsnew 
finish command finish 	create sdsnew 
command fgets 	create sdsnew 
ferror die exit 	create sdsnew 
strlen isspace 	create sdsnew 
strcmp fflush 	create sdscatprintf 
strncmp fflush run 	sdsempty 
child die 	create create 
command loop url 	create create 
syntax command 	create create 
arg arg invoke 	create create 
command given 	create create 
arguments special characters 	create 
space argument 	create sdscatprintf 
percent sign name 	sdsempty create 
service git 	sdscatprintf sdsempty 
upload pack git 	create create 
upload archive 	random hex 
git receive pack 	chars 
possible git 	zstrdup zstrdup 
prefix stripped allowed 	time zstrdup 
first character 	zstrdup zstrdup 
argument pass 	dict create 
argument command instead 	lru clock 
send name 	reset 
repository line git 	server save 
style request 	append server 
also activates sending 	save append 
style request 	server save 
allowed first character 	append server 
argument used 	save 
conjunction pass argument 	time dict 
command instead 	create dict 
send vhost git 	create populate 
style request 	command table 
note activate sending 	lookup command 
git style 	lookup 
request pass service 	command lookup 
command scan 	command lookup 
length argument fall 	command lookup 
error skip 	command lookup 
space actual 	command lookup 
placeholder substitution enough 	command 
overflow integers 	access rewrite 
skip first bytes 	config prepare 
specials strip 	shutdown close 
end line characters 	usleep execve 
remote-fd.c input 	exit 
output buffer argc 	getrlimit server 
argv prefix 	log strerror 
input output end 	setrlimit server 
end fgets 	log exit 
ferror die strlen 	server log 
isspace strcmp 	server 
fflush strncmp fflush 	log strerror 
bidirectional transfer 	server log 
loop die die 	server log 
die strtoul 	fopen fgets 
die strtoul die 	atoi server 
command loop 	log 
url syntax 	fclose anet 
inoutfd anything read 	tcp server 
write socket 	anet non 
pair inoutfd infd 	block anet 
outfd anything 	tcp server 
read pipe infd 	anet 
write pipe 	non block 
outfd foo indicates 	strchr anet 
foo optional 	tcp server 
anything data output 	anet tcp 
outfd inoutfd 	server server 
passed unmolested git 	log 
receive pack 	anet non 
git upload pack 	block mstime 
git upload 	memset signal 
archive output git 	signal setup 
receive pack 	signal handlers 
git upload pack 	openlog 
git upload 	getpid list 
archive passed 	create list 
unmolested infd inoutfd 	create list 
strip end 	create list 
line characters remote-testsvn.c 	create list 
url dump 	create 
file remote marksfilename 	list create 
notes rev 	list create 
line line line 	list create 
name batchable 	zmalloc memory 
input command list 	size create 
line sha 	shared 
note sha msg 	objects adjust 
msglen msg 	open files 
res key end 	limit create 
len end 	loop zmalloc 
sha note sha 	listen port 
note path 	exit 
data file 	unlink anet 
msg msglen note 	unix server 
ret marksfile 	server log 
latestrev marksfile line 	exit anet 
found line 	non block 
code dumpin note 	server 
msg head 	log exit 
sha startrev svndump 	dict create 
proc command 	dict create 
note line line 	dict create 
batchlines batch 	dict create 
cmd item argc 	dict 
argv notes 	create eviction 
remote url fflush 	pool alloc 
fflush init 	dict create 
notes note read 	list create 
sha file 	list free 
error error free 	method 
free notes 	list match 
strchrnul starts 	method aof 
strlen strtol read 	rewrite buffer 
sha file 	reset sdsempty 
free parse rev 	time reset 
note sha 	server 
hex fopen die 	stats time 
errno note 	update cached 
die fclose init 	time create 
notes fopen 	time server 
regenerate marks fopen 	panic exit 
die errno 	create 
fclose strbuf addf 	file server 
strbuf getline 	panic create 
starts fclose regenerate 	file server 
marks free 	panic open 
notes strbuf release 	server log 
strbuf release 	strerror 
read read note 	exit server 
warning parse 	log cluster 
rev note 	init replication 
die free check 	script cache 
regenerate marks 	init scripting 
open die errno 	init 
argv push 	slowlog init 
argv push argv 	latency monitor 
push argv 	init bio 
pushf start command 	init server 
die svndump 	panic dict 
init svndump read 	sdsnew 
svndump deinit 	dict sdsnew 
svndump reset close 	server zrealloc 
finish command 	decr count 
warning fflush terminate 	zfree zfree 
batch list 	dict fetch 
clear starts die 	sdsnew 
list append 	dict fetch 
starts strlen strlen 	sdsfree dict 
list append 	fetch dict 
die git 	fetch feed 
extract argv path 	append file 
setup git 	replication 
directory usage remote 	feed slaves 
starts url 	zmalloc incr 
decode end url 	count redis 
slash strbuf 	append list 
addf strbuf addf 	length replication 
strbuf addf 	feed 
git dir strbuf 	monitors redis 
getline ferror 	init ustime 
die die command 	proc ustime 
strbuf reset 	latency sample 
strbuf release strbuf 	needed slowlog 
release strbuf 	push 
release strbuf release 	entry needed 
strbuf release 	propagate propagate 
whether command 	redis free 
starts part batch 	strcasecmp reply 
terminate current 	lookup command 
batch fast stream 	flag 
note refers 	transaction reply 
git reference rev 	error format 
refers svn 	flag transaction 
revision note found 	reply error 
didn find 	format flag 
setup marks file 	transaction 
export commands 	reply flag 
grouped together batch 	transaction cluster 
batches ended 	redirect client 
batch active program 	node query 
ends batch 	flag transaction 
lines buffered passed 	cluster 
handler function 	redirect client 
batch terminated end 	free memory 
batch reading 	needed flag 
commands end 	transaction reply 
command stream quit 	flag transaction 
buffer batch 	reply 
lines remote.c tag 	reply sds 
refspec tag 	sdscatprintf sdsempty 
refspec len baselen 	strerror flag 
instead instead 	transaction reply 
instead alloc rewrite 	reply reply 
rewrite alloc 	error 
rewrite remotes remotes 	flag transaction 
alloc remotes 	reply reply 
remotes hash branches 	tolower tolower 
branches alloc 	flag transaction 
branches current branch 	reply queue 
pushremote name 	multi 
rewrites rewrites push 	command reply 
remote url 	call list 
longest longest remote 	length handle 
remote remote 	clients blocked 
url remote 	lists close 
pushurl remote url 	close 
pushurl remote 	close server 
url str len 	log unlink 
key name 	server log 
len ret replaced 	ldb kill 
lookup lookup 	forked sessions 
entry branch name 	server 
name len 	log kill 
ret len ret 	rdb temp 
rewrite instead 	file server 
remote buf remote 	log server 
frag buf 	log kill 
key name namelen 	server 
subkey remote 	log aof 
branch rewrite pushurl 	fsync server 
aliases loaded 	log rdb 
oid head flag 	save server 
refspec refspec 	log server 
refspec refspec 	log 
fetch verify llen 	unlink flush 
glob lhs 	slaves output 
rhs flags rlen 	buffers close 
unused fetch 	listening sockets 
refspec str refspec 	server log 
refspec refspec 	strlen 
refspec refspec refspec 	strlen memset 
refspec name 	memset memcpy 
branch branch name 	memcpy reply 
ret name 	error time 
given name name 	independent strcmp 
remote priv 	reply 
result map refs 	reply error 
retval item 	reply error 
remote url key 	format reply 
name result 	reply bulk 
kstar klen ksuffixlen 	buffer reply 
namelen ret 	bulk 
vstar refs 	buffer reply 
count query results 	bulk reply 
find src 	reply bulk 
refspec key needle 	reply bulk 
result refs 	gettimeofday reply 
count query find 	multi 
src needle 	bulk len 
result refspec key 	reply bulk 
refspecs refspec 	reply bulk 
name query remote 	reply status 
refspec prefix 	reply reply 
prefixlen name len 	multi 
name cpy 	bulk len 
len ret tail 	reply bulk 
next next 	reply deferred 
cmp pattern refs 	multi bulk 
matched patlen 	length reply 
matched weak 	command 
matched weak match 	flag reply 
match name 	command flag 
namelen tail name 	reply command 
match oid 	flag reply 
name tail ret 	command flag 
name peer 	reply 
buf oid src 	command flag 
match allocated 	reply command 
match src dst 	flag reply 
dst tail 	command flag 
matched src matched 	reply command 
dst allocated 	flag 
src dst dst 	reply command 
guess oid 	flag reply 
flag src dst 	command flag 
dst tail 	reply command 
errs send mirror 	flag reply 
direction ret 	command 
pat pat 	flag reply 
name matching refs 	command flag 
dst side 	reply status 
match head tail 	deferred multi 
tip alloc 	bulk length 
tips oid commit 	reply 
src dst 	reply reply 
dst tail dst 	reply multi 
tag src 	bulk len 
tag item sent 	dict size 
tips dst 	dict iterator 
commit list name 	dict 
index src 	next reply 
refspec refspec names 	command dict 
refspec ret 	val dict 
src dst refspec 	release iterator 
refspec flags 	strcasecmp reply 
send send mirror 	multi 
send prune 	bulk len 
errs refspec 	reply command 
dst tail dst 	dict fetch 
index dst 	strcasecmp reply 
item dst peer 	dict size 
pat dst 	strcasecmp 
name src index 	lookup command 
src name 	reply error 
remote refs send 	format reply 
mirror force 	error keys 
update force update 	command reply 
reject reason 	multi 
ret remote oid 	bulk len 
name ret 	reply bulk 
branch branch refname 	keys free 
err fmt 	result reply 
branch err remote 	error sprintf 
refname err 	sprintf 
ret branch err 	sprintf sprintf 
remote dst 	sprintf sprintf 
ret cur 	sprintf sdsempty 
branch err refname 	strcasecmp strcasecmp 
oid flag 	getrusage getrusage 
remote refs refspec 	clients 
ret tail 	max buffers 
expn name cpy 	strcasecmp sdscat 
refs name 	uname sdscatprintf 
remote refs name 	redis git 
name remote 	sha strtol 
refs refspec tail 	redis 
missing map 	git dirty 
rmp name ignore 	redis build 
list list 	api name 
mark commit oid 	getpid intmax 
old oid 	strcasecmp sdscat 
old list used 	sdscatprintf 
found branch 	list length 
num num 	list length 
upstream name oid 	strcasecmp zmalloc 
revs argv 	used memory 
branch full upstream 	maxmemory lua 
gone refname 	bytes 
oid flag data 	human bytes 
local tail 	human bytes 
local tail head 	human bytes 
refs list 	human bytes 
tail names stale 	human bytes 
refs tail 	human 
refs count refname 	sdscat sdscatprintf 
oid flags 	zmalloc fragmentation 
data info matches 	ratio strcasecmp 
query stale 	sdscat sdscatprintf 
refs count fetch 	intmax time 
map stale 	intmax 
refs names info 	time sdscatprintf 
cas cas 	sdslen aof 
refname refnamelen 	rewrite buffer 
entry cas arg 	size bio 
unset colon 	pending jobs 
entry opt arg 	type 
unset cas 	time sdscatprintf 
remote refname oid 	strcasecmp sdscat 
dst cas 	sdscatprintf instantaneous 
remote entry cas 	metric instantaneous 
remote remote 	metric instantaneous 
refs starts xstrfmt 	metric 
alloc grow 	dict size 
alloc grow alloc 	list length 
grow alloc 	dict size 
grow url pushurl 	strcasecmp sdscat 
url url 	sdscatprintf sdscatprintf 
pushurl strncmp strcmp 	sdscatprintf 
hashmap init 	sdscatprintf sdscatprintf 
strlen init remotes 	sdscatprintf list 
hash hashmap 	length sdscatprintf 
entry init 	list length 
memhash hashmap xcalloc 	list rewind 
alloc grow 	list 
xstrndup hashmap entry 	next list 
init hashmap 	node anet 
put alloc grow 	peer time 
strncmp strcmp 	sdscatprintf sdscatprintf 
alloc grow xcalloc 	strcasecmp sdscat 
xstrndup xstrdup 	sdscatprintf 
xstrfmt strncmp strcmp 	strcasecmp sdscat 
alloc grow 	sdscatprintf sdscatprintf 
xcalloc xstrndup xstrdup 	strcasecmp sdscat 
strlen alloc 	sdscatprintf strcasecmp 
grow strlen isspace 	sdscat sdscatprintf 
fopen git 	dict 
path strbuf getline 	size dict 
strbuf rtrim 	size sdscatprintf 
skip prefix url 	reply reply 
xstrdup skip 	bulk sds 
spaces skip 	gen redis 
prefix push refspec 	info 
xstrdup skip 	list node 
spaces skip prefix 	tail reply 
fetch refspec 	zmalloc zmalloc 
xstrdup skip spaces 	dict keys 
strbuf release 	dict key 
fclose fopen git 	dict 
path strbuf 	find dict 
getline fclose strbuf 	val estimate 
trim strbuf 	idle time 
release strchr url 	memmove sdsfree 
strbuf detach 	memmove sdsdup 
fetch refspec xstrfmt 	zfree 
push refspec 	list length 
xstrfmt parse config 	zmalloc used 
key make 	memory list 
branch strcmp 	rewind list 
git config strcmp 	next list 
git config 	node 
strcmp config error 	client output 
nonbool merge 	buffer memory 
xstrdup parse config 	usage sdslen 
key strcmp 	aof rewrite 
make rewrite config 	buffer size 
error nonbool 	latency 
instead xstrdup strcmp 	start monitor 
make rewrite 	dict size 
config error nonbool 	dict random 
instead xstrdup 	key dict 
parse config key 	key eviction 
strcmp git 	pool 
config warning make 	populate dict 
remote strcmp 	find sdsfree 
git config strcmp 	memmove dict 
git config 	key dict 
strcmp git 	random key 
config strcmp git 	dict 
config strcmp 	key dict 
git config url 	val create 
strcmp git 	sdslen propagate 
config pushurl strcmp 	expire zmalloc 
git config 	used memory 
push refspec strcmp 	latency 
git config 	start monitor 
fetch refspec strcmp 	latency end 
git config 	monitor latency 
error strcmp git 	sample needed 
config error 	latency nested 
strcmp strcmp strcmp 	zmalloc 
strcmp git 	used memory 
config strcmp git 	notify keyspace 
config strcmp 	decr count 
git config url 	flush slaves 
pushurl url 	output buffers 
resolve skip 	latency 
prefix make branch 	end monitor 
git config 	latency sample 
urls free free 	needed latency 
free xcalloc 	end monitor 
strrchr strlen strchr 	latency sample 
xstrndup strlen 	needed 
memchr xstrndup oid 	fopen fgets 
hex check 	fclose fclose 
refname format check 	atoi linux 
refname format 	overcommit memory 
check refname format 	server log 
check refname 	thp 
format check refname 	enabled server 
format free 	log zstrdup 
refspecs die parse 	fopen getpid 
refspec free 	fclose fork 
refspecs parse refspec 	exit setsid 
parse refspec 	open 
free free 	dup dup 
free dot dotdot 	dup close 
strchr remote 	redis git 
branch read config 	sha atoi 
make remote 	redis git 
valid remote nick 	dirty 
valid remote 	redis build 
read remotes file 	exit exit 
valid remote 	zmalloc server 
read branches file 	log redis 
valid remote 	git sha 
url valid remote 	strtol 
parse fetch 	redis git 
refspec parse push 	dirty getpid 
refspec remote 	snprintf redis 
remote read config 	git sha 
parse fetch 	strtol 
refspec parse push 	redis git 
refspec strcmp 	dirty getpid 
die warning 	server log 
die die free 	raw zfree 
free list 	server log 
insert handle duplicate 	handler 
list clear 	rdb temp 
strcmp strchr die 	file getpid 
strlen strlen 	exit exit 
strncmp memcmp strchr 	server log 
die strbuf 	handler sigemptyset 
strbuf strbuf addstr 	sigaction 
strbuf detach 	sigaction sigemptyset 
error match name 	sigaction sigaction 
pattern list 	sigaction sigaction 
append nodup strcmp 	strstr strcmp 
list append 	ustime load 
error match name 	append 
pattern strcmp 	file server 
xstrdup memset 	log ustime 
query refspecs query 	rdb load 
refspecs strlen 	server log 
xcalloc memcpy memcpy 	ustime server 
alloc prefix 	log 
strlen xmalloc memcpy 	strerror exit 
xstrdup xstrdup 	server log 
copy copy free 	server panic 
free free 	setproctitle unused 
free free strcmp 	getenv server 
llist mergesort 	log 
strlen strlen refname 	server log 
match starts 	unsetenv getenv 
starts alloc oidclr 	server log 
alloc sha 	strchr strlen 
alloc oidcpy alloc 	server log 
tail link 	socket 
resolve starts strbuf 	server log 
addstr starts 	memset strncpy 
strbuf addstr 	memset strlen 
strbuf addstr strbuf 	memset offsetof 
detach count 	strlen unsetenv 
refspec match name 	sendmsg 
error error 	server log 
match lhs resolve 	close close 
starts die 	getenv getenv 
count refspec match 	redis supervised 
starts make 	upstart redis 
linked oid error 	supervised 
guess make 	systemd redis 
linked error error 	supervised upstart 
error copy 	redis supervised 
match match name 	systemd strcasecmp 
pattern match 	strcasecmp ziplist 
name pattern starts 	test 
xstrdup oid 	strcasecmp quicklist 
lookup commit reference 	test strcasecmp 
gently alloc 	intset test 
grow memset 	strcasecmp zipmap 
oid tips tips 	test strcasecmp 
starts list 	sha 
append clear commit 	test strcasecmp 
marks many 	test strcasecmp 
list sort starts 	sds test 
list sha 	strcasecmp endianconv 
info list append 	test strcasecmp 
list clear 	crc 
oid lookup commit 	test spt 
reference gently 	init setlocale 
merge bases many 	zmalloc enable 
make linked 	safeness zmalloc 
oidcpy copy list 	oom handler 
clear free 	srand 
strcmp list append 	time getpid 
nodup list 	gettimeofday dict 
sort parse push 	hash function 
refspec match 	seed getpid 
lhs free 	check sentinel 
refspec tail parse 	mode 
push refspec 	init server 
match refs match 	config absolute 
prepare index 	path zmalloc 
list lookup make 	zstrdup init 
linked oidcpy 	sentinel config 
list insert copy 	init 
free list 	sentinel strstr 
clear missing tags 	exit redis 
match prepare 	check rdb 
index list alloc 	main sdsempty 
free list 	strcmp strcmp 
clear oidcpy oid 	version 
oidcmp oidcmp 	strcmp strcmp 
oid starts file 	usage strcmp 
lookup commit 	memtest atoi 
reference gently 	exit exit 
lookup commit reference 	absolute path 
gently newer 	zfree 
remote xcalloc xcalloc 	zstrdup strcmp 
xstrdup remote 	sdslen sdscat 
find tracking strcmp 	sdscat sdscat 
dwim strlen 	sdscatrepr strlen 
xstrdup read config 	sdscat server 
strcmp make 	log 
branch merge refname 	server log 
match start 	exit reset 
strbuf vaddf end 	server save 
error buf 	load server 
exists error buf 	config sdsfree 
error buf 	server 
error buf apply 	log redis 
refspecs error 	supervised daemonize 
buf error buf 	init server 
remote pushremote 	create pid 
branch error 	file redis 
buf apply refspecs 	proc 
error buf 	title redis 
tracking push dest 	ascii art 
free tracking 	check tcp 
push dest error 	backlog settings 
buf tracking 	server log 
push dest branch 	linux 
upstream branch 	memory warnings 
upstream tracking push 	load data 
dest strcmp 	disk verify 
error buf die 	cluster config 
branch push 	data server 
resolve strchr match 	log 
name pattern 	exit server 
ignore symref update 	log server 
copy alloc 	log sentinel 
free refname match 	running server 
find name 	log sleep 
abbrev copy 	proc 
starts alloc starts 	main loop 
starts starts 	copyright salvatore 
alloc prefix alloc 	sanfilippo antirez 
prefix expanded 	gmail dot 
map alloc oid 	rights reserved 
hex remote 	redistribution 
die local starts 	use source 
check refname 	binary forms 
format error free 	without modification 
free tail 	permitted provided 
link strcmp oidcpy 	following conditions 
pop commit 	met 
deref tag parse 	redistributions source 
deref tag 	code must 
parse parse commit 	retain copyright 
commit list 	notice list 
insert pop recent 	conditions following 
commit commit 	disclaimer 
list insert 	redistributions binary 
unmark free unmark 	form must 
free branch 	reproduce copyright 
upstream read lookup 	notice list 
commit reference 	conditions following 
read lookup commit 	disclaimer 
reference argv 	documentation materials 
push argv push 	provided distribution 
argv pushf 	neither name 
oid hex oid 	redis names 
hex argv 	contributors may 
push init revisions 	used 
setup revisions 	endorse promote 
prepare revision walk 	products derived 
die revision 	software without 
clear commit marks 	specific prior 
clear commit 	written permission 
marks argv 	software 
clear stat tracking 	provided copyright 
info shorten 	holders contributors 
unambiguous strbuf addf 	express implied 
strbuf addf 	warranties including 
strbuf addf strbuf 	limited implied 
addf strbuf 	warranties 
addf strbuf addf 	merchantability fitness 
strbuf addf 	particular purpose 
strbuf addf strbuf 	disclaimed shall 
addf free 	copyright owner 
check refname format 	contributors liable 
alloc oidcpy 	direct 
copy find name 	indirect incidental 
find name 	special exemplary 
oidcmp copy starts 	consequential damages 
oidcmp copy 	including limited 
memset query refspecs 	procurement substitute 
multiple list 	goods 
make linked 	services loss 
oidcpy list clear 	use data 
list append 	profits business 
list sort list 	interruption however 
clear free 	caused theory 
free memset alloc 	liability 
grow memset 	whether contract 
xmemdupz clear cas 	strict liability 
option strchrnul 	tort including 
cas entry sha 	negligence otherwise 
error parse 	arising way 
push cas option 	use 
apply refspecs 	software even 
read refname match 	advised possibility 
hashcpy remote 	damage shared 
tracking remote tracking 	common objects 
apply cas 	vars actually 
unspecified previous entry 	used 
overwritten branches 	constants following 
file would 	values used 
url optionally branch 	disk serialization 
specified master 	initialized runtime 
specified branch fetched 	avoid strange 
stored local 	compiler 
branch matching remote 	optimizations globals 
name cogito 	vars server 
compatible push push 	state command 
current head 	table every 
remote branch master 	entry composed 
missing always 	following 
follow handle remote 	fields name 
variables handle 	representing command 
remote name variables 	name function 
function frees 	pointer function 
refspec warning code 	implementing command 
paths ensure 	arity 
src dst pointers 	number arguments 
always freeable 	possible use 
pointers well 	say sflags 
refspec pointer going 	command flags 
special refspec 	see table 
pushing matching refs 	flags 
lhs empty 	flags flags 
means head valid 	bitmask computed 
looking rhs 	redis sflags 
missing empty empty 	field keys 
means store 	proc optional 
valid looking lhs 	function 
empty allowed 	key arguments 
means wildcarded must 	command used 
valid looking 	following three 
otherwise must extended 	fields enough 
sha existing 	specify arguments 
way validate empty 	keys 
anything goes 	first key 
rhs missing allowed 	index first 
lhs must 	argument key 
valid looking 	last key 
empty allowed otherwise 	index last 
must valid 	argument 
looking refspec must 	key key 
greater zero 	step step 
must valid since 	keys first 
possible reach 	last argument 
point within loop 	instance mset 
slash last 	step 
possibility doesn occur 	two since 
fetch head 	arguments key 
ignore entries always 	val key 
appear end 	val microseconds 
list entry already 	microseconds total 
existed match 	execution 
weak refs outside 	time command 
heads tags 	calls total 
specify pattern 	number calls 
full refs remotes 	command flags 
origin master 	microseconds calls 
least toplevel remotes 	fields 
origin master 	computed redis 
otherwise git push 	always zero 
url master 	command flags 
would result ambiguity 	expressed every 
remotes origin 	character represents 
master heads master 	flag 
remote site 	later populate 
want weak matches 	command table 
found multiple 	function take 
matches one strong 	care populating 
matches found 	real flags 
ambiguous one strong 	field 
match zero 	characters meaning 
weak matches acceptable 	flags write 
unique match 	command may 
source could 	modify key 
sha format reference 	space read 
name refs 	command 
way remote end 	never modify 
matching refs 	key space 
traditionally pushed everything 	may increase 
including refs 	memory usage 
outside refs heads 	called allow 
hierarchy make 	memory 
much sense days 	admin command 
collect everything 	like save 
know would end 	shutdown pub 
push collect 	sub related 
tags collect tags 	command force 
tag already 	replication 
conservative point src 	command regardless 
tag lists 	server dirty 
tags missing dst 	command allowed 
sent tips 	scripts random 
lists tips 	command command 
pushing know already 	deterministic 
element src 	command arguments 
tag ancestor sent 	key space 
tips needs 	may different 
sent side pushing 	results instance 
commit error 	spop randomkey 
tag reachable commits 	two 
sending given 	random commands 
local refs sanity 	sort command 
check push 	output called 
refspecs errors match 	script output 
push refs 	deterministic allow 
would errors early 	command 
even talking 	loading database 
remote side given 	allow command 
refs local 	slave stale 
repository refs remote 	data allowed 
repository refspec 	server data 
used push 	normally 
determine remote refs 	command accepted 
update setting 	condition automatically 
peer pushed force 	propagate command 
push forced 	monitor perform 
elements dst function 	asking command 
may elements 	command 
dst pushing branch 	accepted cluster 
done match 	mode slot 
refs pick remainder 	marked importing 
already sending 	fast command 
something remote doesn 	log command 
pattern mirror 	never 
create one link 	delay execution 
check missing 	kernel scheduler 
refs remote already 	giving time 
sending something 	note commands 
remote moved 	may trigger 
different expect reject 	del 
push also 	side effect 
error user told 	like fast 
check remote 	commands utility 
tracking branch find 	functions low 
expect tracking 	level logging 
branch isn stale 	use 
force update 	big messages 
update isn already 	otherwise server 
rejected check 	log prefer 
usual must fast 	clear flags 
forward rules 	sentinel rdb 
decide whether individual 	aof 
refspec pushed 	writing child 
push succeed following 	slave master 
remote reference 	like server 
exist remote reference 	log raw 
removed pushing 	alike support 
source specified 	function 
destination refs tags 	used across 
old commit 	code raw 
descendant old forced 	version used 
notation passing 	order dump 
force argument force 	info output 
defeat rejection 	crash 
implemented rules branch 	log message 
already run 	without alike 
merge config make 	capabilities way 
sure confuse 	safe call 
callers non zero 	signal handler 
merge merge 	actually 
merge config user 	use signals 
didn define 	fatal point 
real branch branch 	view redis 
vivified non 	signals going 
existing refs create 	kill server 
list consisting 	anyway 
copies remote 	need alike 
matches refspec refspec 	features served 
must pattern 	server log 
fill copies peer 	unix time 
describe local 	microseconds unix 
tracking refs map 	time 
omit references 	milliseconds rdb 
would map existing 	dump aof 
local symbolic 	rewrite exit 
dereference item old 	children exit 
must commit 	instead exit 
ish descendant old 	latter 
otherwise require 	may interact 
force compare branch 	file objects 
upstream save 	used parent 
differences number commits 	process however 
num num 	testing coverage 
name upstream branch 	normal 
upstream defined 	exit used 
returned via 	order obtain 
upstream name returns 	right coverage 
num num 	information hash 
could filled upstream 	table type 
defined exist 	implementation 
otherwise cannot stat 	hash table 
unless marked 	type uses 
build top somebody 	sds library 
cannot stat 	keys redis 
used build longer 	objects values 
exists run 	objects 
rev list left 	hold sds 
right internally 	lists sets 
ignored count commits 	insensitive version 
side clear 	used command 
flags smudged traversal 	lookup table 
anything report 	places 
otherwise already 	insensitive non 
know starts refs 	binary safe 
transports support 	comparison needed 
directly peeking head 	values swapped 
points guess 	keys sets 
refs heads master 	type 
could right 	hash table 
look another points 	hash function 
matches find 	key dup 
suitable refspec symref 	val dup 
list refs 	key compare 
currently exist remote 	key 
consider stale 	destructor val 
order deal overlapping 	destructor sorted 
refspecs need 	sets hash 
matching refs compare 	note skiplist 
swap option 	used addition 
option option refname 	hash 
option refname 	table hash 
look remote 	function key 
fetch refspec see 	dup val 
remote tracking 	dup key 
branch refname fill 	compare 
current sha 	key destructor 
cannot negative signal 	val destructor 
error tracking 	dict keys 
refname remote know 	sds vals 
tracking cannot 	redis objects 
read find option 	hash 
name entry 	function key 
option cover branch 	dup val 
another remote 	dup key 
also uses non 	compare key 
remote tracking 	destructor val 
refs advise user 	destructor 
local branches 	server lua 
silently skip non 	scripts sha 
remote refs 	sds scripts 
make sure 	robj cache 
symrefs deleted first 	hash function 
symrefs rename 	key 
rest create symrefs 	dup val 
cannot pass 	dup key 
function deletes branches 	compare key 
one one 	destructor val 
since relies cached 	destructor expires 
refs invalidated 	hash 
deleting branch sorting 	function key 
comparison list 	dup val 
push info structs 	dup key 
field remote 	compare key 
branch info git 	destructor val 
pull info 	destructor 
git push info 	command table 
make sure 	sds command 
valid fetch mode 	pointer hash 
use fetch 	function key 
url push 	dup val 
found requested special 	dup 
cases entry 	key compare 
old url specified 	key destructor 
demand one 	val destructor 
matches builtin remote 	hash type 
usage builtin 	hash table 
remote usage builtin 	note 
remote rename 	small hashes 
usage builtin remote 	represented ziplists 
usage builtin 	hash function 
remote sethead usage 	key dup 
builtin remote 	val dup 
setbranches usage builtin 	key 
remote show 	compare key 
usage builtin remote 	destructor val 
prune usage 	destructor keylist 
builtin remote update 	hash table 
usage builtin 	type unencoded 
remote geturl 	redis 
usage builtin remote 	objects keys 
seturl usage 	lists values 
verbose name argv 	used blocking 
key branchname 	operations blpop 
remotename mirror tmp 	map swapped 
mirror advice 	keys 
opt arg mirror 	list clients 
argc argv 	waiting keys 
fetch tags mirror 	loaded hash 
track master 	function key 
remote buf name 	dup val 
url options 	dup 
remote name merge 	key compare 
branch list 	key destructor 
name prefix key 	val destructor 
orig key 	cluster nodes 
name item 	hash table 
info key len 	mapping 
space merge 	nodes addresses 
remote stale tracked 	cluster node 
heads push 	structures hash 
queried remote refs 	function key 
states tail 	dup val 
stale refs item 	dup 
dest forced 	key compare 
remote refs states 	key destructor 
remote local 	val destructor 
refs push map 	cluster addition 
item info 	blacklist maps 
states remote item 	node 
info spec 	time node 
remote refs states 	goal avoid 
matches fetch 	readding removed 
map tail refspec 	node time 
next remote 	hash function 
list remote 	key 
data remote branches 	dup val 
skipped keep 	dup key 
refname oid flags 	compare key 
data branches 	destructor val 
refspec old remote 	destructor migrate 
branches refname 	cache 
oid flags data 	dict type 
rename buf 	hash function 
item flag orig 	key dup 
oid symref 	val dup 
remote buf argc 	key compare 
argv options 	key 
oldremote newremote old 	destructor val 
remote context 	destructor replication 
remote branches rename 	cached script 
refspec updated 	dict server 
ptr item info 	repl scriptcache 
item flag 	dict 
oid item 	keys sds 
item argc argv 	sha values 
options remote 	used current 
buf known remotes 	implementation hash 
branches skipped 	function key 
data result item 	dup 
info info 	val dup 
states refname oid 	key compare 
flags data 	key destructor 
states refspec name 	val destructor 
states query 	percentage used 
transport remote refs 	slots 
list states 	reaches hashtable 
width width rebase 	min fill 
item data 	resize hash 
info item data 	table save 
info states 	memory hash 
name fmt arg 	table 
branch item 	implementation performs 
data show 	rehashing incrementally 
info states branch 	write read 
info item 	hash table 
item data show 	still server 
info branch 	idle 
info merge also 	hash table 
push item 	use two 
data show info 	tables time 
push info 	use millisecond 
item push push 	cpu time 
cmp item 	every 
data show info 	call function 
push info 	perform rehahsing 
status remote priv 	function returns 
list url 	rehashing performed 
buf url url 	otherwise returned 
list result 	keys 
item argc 	dictionary already 
argv query flag 	used millisecond 
options states 	loop expires 
info list info 	already used 
url url 	millisecond loop 
argc argv result 	function 
buf head 	called background 
name options states 	process kind 
remote dry 	terminates want 
run result states 	avoid resizing 
refs prune 	hash tables 
item dangling msg 	child 
refname argc 	order play 
argv result options 	well copy 
key priv 	write otherwise 
found argc argv 	resize happens 
prune options 	lots memory 
fetch argv defined 	pages 
retval remote 	copied goal 
key remote 	function update 
branches key remotename 	ability dict 
mirror refspec 	resize hash 
remotename branches mode 	tables accordingly 
key remote 	fact 
argc argv mode 	running childs 
options argc 	cron called 
argv mode remotename 	every helper 
remote url 	function active 
url options argc 	expire cycle 
argv mode 	function 
negative matches remotename 	function expire 
newurl oldurl 	key stored 
remote old regex 	hash table 
urlset urlset 	entry expires 
name buf options 	hash table 
argc argv 	redis 
prefix options result 	database key 
run command 	found expired 
opt error 	removed database 
strbuf reset strbuf 	returned otherwise 
addch strbuf 	operation performed 
addf strbuf addf 	returned 
git config 	key expired 
multivar warning strcmp 	server stat 
strcmp error 	expiredkeys incremented 
parse options usage 	parameter current 
options die 	time milliseconds 
die remote remote 	passed 
configured die 	function avoid 
strbuf addf valid 	many gettimeofday 
fetch refspec 	syscalls expire 
die strbuf addf 	timed keys 
git config 	algorithm used 
strbuf reset strbuf 	adaptive 
addf list 	use cpu 
append branch strbuf 	cycles expiring 
reset strbuf 	keys otherwise 
addf git 	aggressive avoid 
config strbuf reset 	much memory 
strbuf addf 	used 
git config fetch 	keys removed 
remote strbuf 	keyspace cron 
reset strbuf addf 	dbs per 
strbuf reset 	call databases 
strbuf addf create 	tested every 
symref error 	iteration 
strbuf release strbuf 	kind call 
release list 	used redis 
clear skip prefix 	detects timelimit 
starts strip 	exit work 
suffix xmemdupz strip 	incrementally sleep 
suffix xmemdupz 	function 
strip suffix xmemdupz 	loop expire 
list insert 	cycle type 
xcalloc warning xstrdup 	type active 
strchr abbrev 	expire cycle 
branch xstrndup 	fast function 
list append abbrev 	run 
branch strchr 	fast expire 
list append xstrdup 	cycle takes 
git config 	longer expire 
maybe strcmp strcmp 	fast cycle 
git config 	duration microseconds 
fetch map die 	repeated 
exists list 	amount time 
append abbrev branch 	type active 
list append 	expire cycle 
abbrev branch stale 	slow normal 
heads list 	expire cycle 
append abbrev branch 	executed 
xstrdup free 	time limit 
refs free refs 	percentage redis 
list sort 	period specified 
list sort 	redis expirelookups 
list sort local 	time perc 
heads copy 	define 
list match push 	function state 
refs oidcpy 	order work 
list append abbrev 	incrementally across 
branch xcalloc 	calls last 
xstrdup abbrev branch 	tested time 
oid oidcmp 	limit 
oid file newer 	hit previous 
free refs 	call last 
free refs list 	fast cycle 
append xcalloc 	ran start 
xstrdup list append 	fast cycle 
strlen list 	previous 
append list append 	cycle exited 
xcalloc xstrdup 	time limt 
fetch map guess 	also repeat 
remote head 	fast cycle 
find name 	period fast 
list append abbrev 	cycle 
branch free 	total duration 
refs free refs 	usually test 
strcmp xmalloc 	cron dbs 
memset remote find 	per call 
tracking memset 	per iteration 
remote find tracking 	two 
starts starts 	exceptions test 
list append abbrev 	last time 
branch unlink 	hit time 
git path list 	limit want 
append strbuf 	scan iteration 
addf starts list 	work 
append xstrdup 	want expired 
resolve xstrdup strbuf 	keys use 
addf git 	memory much 
config multivar strbuf 	time use 
reset strbuf 	max active 
addf git 	expire 
config multivar strbuf 	cycle slow 
reset strbuf 	time perc 
addf git config 	percentage cpu 
multivar unlink 	time per 
warn git path 	iteration since 
unlink warn 	function 
git path usage 	gets called 
options remote 	frequency server 
remote configured die 	times per 
strcmp migrate 	second following 
file remote remote 	max amount 
configured die 	microseconds 
strbuf addf valid 	spend function 
fetch refspec 	microseconds increment 
die strbuf reset 	sure run 
strbuf addf 	time current 
strbuf addf git 	restart next 
config rename 	allows 
section error 	distribute time 
strbuf reset strbuf 	evenly across 
addf git 	expire end 
config multivar strbuf 	cycle keys 
addf strbuf 	expired nothing 
reset strbuf addstr 	expire 
strstr strbuf 	next asap 
splice strlen strlen 	less filled 
strlen warning 	slots getting 
git config multivar 	random keys 
read branches 	expensive stop 
strcmp strbuf reset 	waiting 
strbuf addf 	better times 
git config read 	dictionary resized 
full die 	asap main 
strbuf reset strbuf 	collection cycle 
addstr strbuf 	sample random 
splice strlen 	keys 
strlen strlen strbuf 	among keys 
reset strbuf 	expire checking 
addf rename die 	expired ones 
strbuf reset 	want average 
strbuf addstr strbuf 	ttl keys 
splice strlen 	yet 
strlen strlen strbuf 	expired update 
reset strbuf 	average ttl 
addstr strbuf splice 	stats database 
strlen strlen 	simple running 
strlen strbuf reset 	average samples 
strbuf addf 	use 
create symref die 	current estimate 
memset usage 	weight previous 
options remote remote 	estimate weight 
configured die 	block forever 
remote read branches 	even many 
strcmp strbuf 	keys 
reset strbuf 	expire given 
addf git config 	amount milliseconds 
strbuf release 	caller waiting 
refs list clear 	active expire 
list clear 	cycle check 
strbuf addf git 	every 
config rename 	iterations repeat 
section error free 	cycle less 
free list 	keys found 
clear list clear 	expired current 
list clear 	sample operations 
list clear list 	per 
clear func 	second samples 
memset remote find 	mean samples 
tracking list 	check timeouts 
append abbrev branch 	returns non 
remote error 	zero client 
read branches transport 	terminated 
transport remote 	function gets 
refs transport 	current time 
disconnect states head 	milliseconds argument 
names push 	since gets 
states list sort 	called multiple 
push states 	times 
noquery strlen list 	loop calling 
insert list 	gettimeofday iteration 
list list strcmp 	would costly 
strlen list 	without actual 
insert error strlen 	gain timeout 
strlen list 	slaves 
append strcmp strcmp 	timeout masters 
strbuf addf 	timeout blpop 
list append strbuf 	timeout pub 
detach list 	sub clients 
append strbuf addf 	blocked ops 
list append 	timeout 
strbuf detach remote 	handled milliseconds 
list sort 	resolution however 
strcmp list 	note actual 
clear parse options 	resolution limited 
show memset 	server handle 
memset remote states 	blocking 
list list 	operation specific 
list list list 	timeout cluster 
clear list 	handle unblock 
list list clear 	redirect clients 
list qsort 	blocked keys 
list list clear 	longer 
free remote 	served server 
states parse options 	client query 
strbuf addf 	buffer sds 
xstrdup memset remote 	end lot 
states error 	free space 
error xstrdup free 	used 
remote states 	function reclaims 
error usage 	space needed 
options strbuf addf 	function always 
exists error 	returns never 
create symref error 	terminates client 
free strbuf 	two 
release strbuf release 	conditions resize 
memset remote 	query buffer 
states free remote 	query buffer 
states list 	big arg 
append list sort 	big latest 
refs abbrev 	peak 
abbrev warn dangling 	client inactive 
symrefs list 	buffer bigger 
clear free remote 	resize query 
states parse 	buffer actually 
options usage options 	wasting space 
prune remote 	reset 
strcmp parse options 	peak capture 
argv push 	peak memory 
argv push 	usage next 
argv push argv 	cycle make 
push argv 	sure process 
push argv push 	least 
strcmp git 	numclients server 
config argv pop 	clients per 
argv push 	call since 
run command opt 	function called 
argv clear 	server times 
git config multivar 	per 
gently branch 	second sure 
strbuf release strbuf 	worst process 
addf remote 	clients second 
remote configured die 	process least 
fetch refspecs 	clients even 
strbuf release branches 	need 
strbuf release 	process less 
parse options error 	clients cron 
usage options 	min iterations 
remote branches 	meet contract 
parse options usage 	processing client 
options remote 	per 
remote configured die 	second rotate 
die parse 	list take 
options die usage 	current head 
options remote 	process way 
remote configured die 	client must 
strbuf addf 	removed 
strbuf addf git 	list first 
config multivar 	element incur 
git config strbuf 	computation following 
release regcomp 	functions different 
die regexec die 	service 
die regfree 	checks client 
git config multivar 	protocol non 
git config 	zero client 
multivar parse options 	terminated function 
show strcmp 	handles background 
strcmp strcmp 	operations 
strcmp strcmp head 	required incrementally 
strcmp branches 	redis databases 
strcmp url strcmp 	active key 
url strcmp 	expiring resizing 
show strcmp prune 	rehashing expire 
strcmp update 	keys 
error usage options 	random sampling 
unspecified previous 	required slaves 
entry overwritten branches 	master synthesize 
file would 	perform hash 
url optionally branch 	tables rehashing 
specified master 	needed 
specified branch fetched 	processes saving 
stored local 	disk otherwise 
branch matching remote 	rehashing bad 
name cogito 	cause lot 
compatible push push 	copy write 
current head 	memory 
remote branch 	pages use 
master missing always 	counters stop 
follow handle 	computation given 
remote variables handle 	able start 
remote name 	successive next 
variables function frees 	cron 
refspec warning 	loop iteration 
code paths ensure 	test resize 
src dst 	rehash function 
pointers always freeable 	work stop 
pointers well 	next cron 
refspec pointer going 	loop 
special refspec 	take cached 
pushing matching refs 	unix time 
lhs empty 	state memory 
means head valid 	aging store 
looking rhs 	current time 
missing empty 	objects 
empty means store 	every access 
valid looking 	accuracy needed 
lhs empty allowed 	access lot 
means wildcarded 	faster calling 
must valid looking 	time timer 
otherwise must 	interrupt 
extended sha existing 	called server 
way validate 	times per 
empty anything goes 	second number 
rhs missing 	things need 
allowed lhs must 	done asynchronously 
valid looking 	instance 
empty allowed otherwise 	active expired 
must valid 	keys collection 
looking refspec must 	also performed 
greater zero 	lazy way 
must valid since 	lookup software 
possible reach 	watchdog 
point within 	update statistic 
loop slash last 	incremental rehashing 
possibility doesn 	hash tables 
occur fetch head 	triggering bgsave 
ignore entries 	aof rewrite 
always appear end 	handling 
list entry 	terminated children 
already existed match 	clients timeout 
weak refs 	different kinds 
outside heads tags 	replication reconnection 
specify pattern 	many everything 
full refs remotes 	directly 
origin master 	called called 
least toplevel remotes 	server times 
origin master 	per second 
otherwise git push 	order throttle 
url master 	execution things 
would result ambiguity 	want 
remotes origin 	less frequently 
master heads 	macro used 
master remote site 	run period 
want weak 	milliseconds software 
matches found multiple 	watchdog deliver 
matches one 	sigalrm 
strong matches found 	reach signal 
ambiguous one 	handler fast 
strong match zero 	enough update 
weak matches 	time cache 
acceptable unique match 	lru bits 
source could 	bits 
sha format reference 	per lru 
name refs 	information use 
way remote end 	eventually wrapping 
matching refs 	lru clock 
traditionally pushed everything 	note even 
including refs 	counter 
outside refs heads 	wraps big 
hierarchy make 	problem everything 
much sense 	still work 
days collect everything 	appear younger 
know would 	redis however 
end push collect 	happen 
tags collect 	given never 
tags tag already 	touched time 
conservative point 	needed counter 
src tag lists 	wrap likely 
tags missing 	note change 
dst sent tips 	resolution 
lists tips 	altering lru 
pushing know already 	clock resolution 
element src 	define record 
tag ancestor sent 	max memory 
tips needs 	used since 
sent side pushing 	server 
commit error 	started sample 
tag reachable 	rss since 
commits sending given 	relatively slow 
local refs 	call received 
sanity check push 	sigterm shutting 
refspecs errors 	safe 
match push refs 	way inside 
would errors 	signal handler 
early even talking 	show info 
remote side 	non empty 
given refs local 	databases dict 
repository refs 	print 
remote repository refspec 	stats server 
used push 	dict show 
determine remote refs 	information connected 
update setting 	clients need 
peer pushed force 	operations clients 
push forced 	asynchronously 
elements dst function 	handle background 
may elements 	operations redis 
dst pushing 	databases start 
branch done match 	scheduled aof 
refs pick 	rewrite requested 
remainder already sending 	user 
something remote 	bgsave progress 
doesn pattern mirror 	check background 
create one 	saving aof 
link check missing 	rewrite progress 
refs remote 	terminated background 
already sending something 	saving 
remote moved 	rewrite progress 
different expect reject 	check save 
push also 	rewrite save 
error user told 	reached given 
check remote 	amount changes 
tracking branch find 	given 
expect tracking 	amount seconds 
branch isn stale 	latest bgsave 
force update 	successful error 
update isn 	least config 
already rejected check 	bgsave retry 
usual must 	delay 
fast forward rules 	seconds already 
decide whether 	elapsed trigger 
individual refspec pushed 	aof rewrite 
push succeed 	needed aof 
following remote reference 	postponed flush 
exist remote 	every 
reference removed pushing 	cron cycle 
source specified 	slow fsync 
destination refs tags 	completed aof 
old commit 	write errors 
descendant old forced 	buffer flush 
notation passing 	well 
force argument force 	clear aof 
defeat rejection 	error success 
implemented rules branch 	make writable 
already run 	however every 
merge config 	second enough 
make sure confuse 	higher 
callers non 	frequency close 
zero merge merge 	clients need 
merge config 	closed asynchronous 
user didn define 	clear paused 
real branch 	clients flag 
branch vivified non 	needed 
existing refs 	check use 
create list consisting 	side effect 
copies remote 	replication cron 
matches refspec refspec 	function used 
must pattern 	reconnect master 
fill copies peer 	detect 
describe local 	transfer failures 
tracking refs map 	run redis 
omit references 	cluster cron 
would map 	run sentinel 
existing local symbolic 	timer sentinel 
dereference item 	mode 
old must commit 	cleanup expired 
ish descendant 	migrate cached 
old otherwise require 	sockets function 
force compare 	gets called 
branch upstream save 	every time 
differences number 	redis 
commits num num 	entering main 
name upstream 	loop driven 
branch upstream defined 	library sleep 
returned via 	ready file 
upstream name returns 	descriptors call 
num num 	redis 
could filled upstream 	cluster sleep 
defined exist 	function note 
otherwise cannot stat 	function may 
unless marked 	change state 
build top 	redis cluster 
somebody cannot stat 	fail 
used build 	vice versa 
longer exists run 	good idea 
rev list 	call serving 
left right internally 	unblocked clients 
ignored count 	later function 
commits side clear 	run 
flags smudged 	fast expire 
traversal anything report 	cycle called 
otherwise already 	function asap 
know starts refs 	fast cycle 
transports support 	needed send 
directly peeking head 	slaves 
points guess 	ack request 
refs heads master 	least one 
could right 	client blocked 
look another points 	previous loop 
matches find 	iteration used 
suitable refspec 	argument 
symref list refs 	unblock clients 
currently exist 	blocked synchronous 
remote consider stale 	replication wait 
order deal 	process pending 
overlapping refspecs need 	commands clients 
matching refs 	unblocked 
compare swap option 	write aof 
option option 	buffer disk 
refname option refname 	handle writes 
look remote 	pending output 
fetch refspec see 	buffers server 
remote tracking 	initialization 
branch refname fill 	following two 
current sha 	shared objects 
cannot negative signal 	minstring maxstrings 
error tracking 	actually used 
refname remote know 	special meaning 
tracking cannot 	respectively 
read find 	minimum possible 
option name entry 	maximum possible 
option cover 	comparisons zrangebylex 
branch another remote 	command make 
also uses 	sure first 
non remote tracking 	time 
refs advise 	match client 
user local branches 	start save 
silently skip 	hour change 
non remote refs 	save minutes 
make sure 	changes save 
symrefs deleted first 	minute 
symrefs rename 	changes replication 
rest create symrefs 	related never 
cannot pass 	connected repl 
function deletes branches 	since ever 
one one 	replication resync 
since relies cached 	backlog 
refs invalidated 	client output 
deleting branch 	buffer limits 
sorting comparison list 	constants initialization 
push info 	command table 
structs field remote 	initiialize part 
branch info 	initial 
git pull info 	configuration since 
git push 	command names 
info make sure 	may changed 
valid fetch 	via redis 
mode use fetch 	conf rename 
url push 	command 
found requested special 	directive slow 
cases entry 	log latency 
old url specified 	monitor debugging 
demand one 	restart server 
matches remote.c tag 	executing executable 
refspec tag 	started 
refspec len 	instance arguments 
baselen instead instead 	configuration file 
instead alloc 	function designed 
rewrite rewrite alloc 	directly call 
rewrite remotes 	execve server 
remotes alloc remotes 	instance 
remotes hash 	retain pid 
branches branches alloc 	previous one 
branches current 	list flags 
branch pushremote name 	may bitwise 
rewrites rewrites 	red together 
push remote url 	alter 
longest longest 	behavior function 
remote remote remote 	restart server 
url remote 	none flags 
pushurl remote url 	restart server 
pushurl remote 	gracefully proper 
url str len 	shutdown 
key name 	restarting restart 
len ret 	server config 
replaced lookup lookup 	rewrite rewrite 
entry branch 	config file 
name name len 	restarting success 
ret len 	function 
ret rewrite instead 	process turns 
remote buf 	different process 
remote frag buf 	error err 
key name 	returned check 
namelen subkey remote 	still accesses 
branch rewrite 	executable 
pushurl aliases loaded 	started server 
oid head 	instance config 
flag refspec refspec 	rewriting perform 
refspec refspec 	proper shutdown 
fetch verify llen 	close file 
glob lhs 	descriptors 
rhs flags rlen 	stdin stdout 
unused fetch 	strerr useful 
refspec str 	restart redis 
refspec refspec refspec 	server daemonized 
refspec refspec 	execute server 
refspec refspec name 	original 
branch branch 	command line 
name ret name 	error occurred 
given name 	nothing exit 
name remote priv 	never reached 
result map 	function max 
refs retval item 	number 
remote url 	open files 
key name result 	accordingly configured 
kstar klen 	max number 
ksuffixlen namelen ret 	clients also 
vstar refs 	reserves number 
count query results 	file 
find src 	descriptors config 
refspec key needle 	min reserved 
result refs 	fds extra 
count query 	operations persistence 
find src needle 	listening sockets 
result refspec 	log 
key refspecs refspec 	files forth 
name query 	possible limit 
remote refspec prefix 	accordingly configured 
prefixlen name 	max number 
len name cpy 	clients function 
len ret 	reverse 
tail next next 	setting server 
cmp pattern 	maxclients actually 
refs matched patlen 	handle max 
matched weak 	number files 
matched weak match 	current limit 
match name 	enough 
namelen tail name 	needs file 
match oid 	limit match 
name tail 	maxfiles least 
ret name peer 	higher supported 
buf oid 	less maxfiles 
src match allocated 	failed 
match src 	file limit 
dst dst tail 	bestlimit smaller 
matched src 	limit decrementing 
matched dst allocated 	per iteration 
src dst 	limit initially 
dst guess oid 	still 
flag src 	valid last 
dst dst tail 	even lower 
errs send 	check server 
mirror direction ret 	tcp backlog 
pat pat 	actually enforced 
name matching refs 	linux 
dst side 	according proc 
match head tail 	sys net 
tip alloc 	core somaxconn 
tips oid 	warn initialize 
commit src dst 	file descriptors 
dst tail 	listen 
dst tag src 	specified port 
tag item 	binding addresses 
sent tips dst 	specified redis 
commit list 	server configuration 
name index src 	listening file 
refspec refspec 	descriptors 
names refspec ret 	stored integer 
src dst 	fds number 
refspec refspec flags 	count addresses 
send send 	bind specified 
mirror send prune 	server bindaddr 
errs refspec 	number 
dst tail dst 	server bindaddr 
index dst 	count server 
item dst peer 	configuration contains 
pat dst 	specific addresses 
name src 	bind function 
index src name 	bind 
remote refs 	addresses protocols 
send mirror force 	success function 
update force 	returns error 
update reject reason 	function returns 
ret remote 	err function 
oid name ret 	error 
branch branch 	least one 
refname err fmt 	server bindaddr 
branch err 	addresses impossible 
remote refname err 	bind bind 
ret branch 	addresses specified 
err remote dst 	server 
ret cur 	configuration function 
branch err refname 	able bind 
oid flag 	least one 
remote refs refspec 	protocols force 
ret tail 	binding bind 
expn name 	address 
cpy refs name 	specified always 
remote refs 	entering loop 
name name remote 	bind enter 
refs refspec 	server bindaddr 
tail missing map 	count exit 
rmp name 	loop 
ignore list list 	able bind 
mark commit 	otherwise fds 
oid old oid 	count anet 
old list 	err print 
used found branch 	error caller 
num num 	error 
upstream name oid 	bind address 
revs argv 	bind address 
branch full upstream 	resets stats 
gone refname 	expose via 
oid flag 	info means 
data local tail 	want 
local tail 	reset via 
head refs list 	config resetstat 
tail names 	function also 
stale refs tail 	used order 
refs count 	initialize 
refname oid flags 	fields init 
data info 	server server 
matches query stale 	startup force 
refs count 	emit first 
fetch map stale 	command open 
refs names 	tcp 
info cas cas 	listening socket 
refname refnamelen 	user commands 
entry cas arg 	open listening 
unset colon 	unix domain 
entry opt arg 	socket care 
unset cas 	fails 
remote refname 	abort listening 
oid dst cas 	sockets create 
remote entry 	redis databases 
cas remote remote 	initialize state 
refs starts 	startup consider 
xstrfmt alloc grow 	saved 
alloc grow 	startup never 
alloc grow alloc 	tried bgsave 
grow url 	stats want 
pushurl url url 	reset server 
pushurl strncmp 	startup time 
strcmp hashmap init 	peak 
strlen init 	mem create 
remotes hash hashmap 	server cron 
entry init 	time main 
memhash hashmap xcalloc 	way process 
alloc grow 	background operations 
xstrndup hashmap entry 	create 
init hashmap 	handler accepting 
put alloc 	connections tcp 
grow strncmp strcmp 	unix domain 
alloc grow 	sockets open 
xcalloc xstrndup xstrdup 	aof file 
xstrfmt strncmp 	needed 
strcmp alloc grow 	bit instances 
xcalloc xstrndup 	limited address 
xstrdup strlen alloc 	space limit 
grow strlen 	user provided 
isspace fopen git 	configuration limit 
path strbuf 	maxmemory 
getline strbuf rtrim 	noeviction policy 
skip prefix 	avoids useless 
url xstrdup skip 	crashes redis 
spaces skip 	instance memory 
prefix push refspec 	populates redis 
xstrdup skip 	command 
spaces skip prefix 	table starting 
fetch refspec 	hard coded 
xstrdup skip 	list top 
spaces strbuf release 	redis file 
fclose fopen 	populate additional 
git path strbuf 	dictionary 
getline fclose 	unaffected rename 
strbuf trim strbuf 	command statements 
release strchr 	redis conf 
url strbuf detach 	redis api 
fetch refspec 	commands lookup 
xstrfmt push refspec 	execution 
xstrfmt parse 	lookup command 
config key make 	current table 
branch strcmp 	found also 
git config strcmp 	check original 
git config 	table containing 
strcmp config error 	original 
nonbool merge 	command names 
xstrdup parse config 	unaffected redis 
key strcmp 	conf rename 
make rewrite 	command statement 
config error nonbool 	used functions 
instead xstrdup 	rewriting 
strcmp make rewrite 	argument vector 
config error 	rewrite client 
nonbool instead xstrdup 	command vector 
parse config 	order client 
key strcmp git 	cmd pointer 
config warning 	correctly 
make remote strcmp 	even command 
git config 	renamed propagate 
strcmp git config 	specified command 
strcmp git 	context specified 
config strcmp git 	database aof 
config strcmp 	slaves 
git config url 	flags xor 
strcmp git 	propagate none 
config pushurl 	propagation command 
strcmp git config 	propagate aof 
push refspec 	propagate aof 
strcmp git config 	file 
fetch refspec 	enabled propagate 
strcmp git config 	repl propagate 
error strcmp 	replication link 
git config error 	used inside 
strcmp strcmp 	commands implementation 
strcmp strcmp git 	use 
config strcmp 	instead also 
git config strcmp 	propagate prevent 
git config 	command propagation 
url pushurl url 	force command 
resolve skip 	propagation used 
prefix make branch 	inside 
git config 	commands schedule 
urls free free 	propagation additional 
free xcalloc 	commands current 
strrchr strlen 	command propagated 
strchr xstrndup strlen 	aof replication 
memchr xstrndup 	cmd 
oid hex check 	must pointer 
refname format 	redis command 
check refname format 	replicate dbid 
check refname 	database command 
format check refname 	propagated arguments 
format check 	command 
refname format free 	propagte passed 
refspecs die 	redis objects 
parse refspec free 	pointers len 
refspecs parse 	argc argv 
refspec parse refspec 	vector function 
free free 	take 
free dot dotdot 	reference passed 
strchr remote 	argv vector 
branch read config 	caller release 
make remote 	passed argv 
valid remote 	usually stack 
nick valid remote 	allocated 
read remotes 	function autoamtically 
file valid remote 	increments count 
read branches 	passed objects 
file valid remote 	caller need 
url valid 	propagation loading 
remote parse fetch 	possible 
refspec parse 	call function 
push refspec remote 	force command 
remote read 	propagation inside 
config parse fetch 	redis command 
refspec parse 	implementation order 
push refspec strcmp 	force 
die warning 	propagation specific 
die die free 	command execution 
free list 	aof replication 
insert handle duplicate 	avoid executed 
list clear 	command propagated 
strcmp strchr 	way 
die strlen strlen 	free propagate 
strncmp memcmp 	want also 
strchr die strbuf 	propagate api 
strbuf strbuf 	aof specific 
addstr strbuf detach 	version prevent 
error match 	command 
name pattern list 	propagation replication 
append nodup 	specific version 
strcmp list append 	prevent command 
error match 	propagation call 
name pattern strcmp 	core redis 
xstrdup memset 	execution 
query refspecs query 	command following 
refspecs strlen 	flags passed 
xcalloc memcpy memcpy 	cmd call 
alloc prefix 	none flags 
strlen xmalloc 	cmd call 
memcpy xstrdup xstrdup 	slowlog 
copy copy 	check command 
free free free 	speed log 
free free 	slow log 
strcmp llist mergesort 	needed cmd 
strlen strlen 	call stats 
refname match starts 	populate 
starts alloc 	command stats 
oidclr alloc sha 	cmd call 
alloc oidcpy 	propagate aof 
alloc tail link 	append command 
resolve starts 	aof modified 
strbuf addstr starts 	dataset 
strbuf addstr 	client flags 
strbuf addstr strbuf 	forcing propagation 
detach count 	cmd call 
refspec match name 	propagate repl 
error error 	send command 
match lhs 	salves 
resolve starts die 	modified dataset 
count refspec 	client flags 
match starts make 	forcing propagation 
linked oid 	cmd call 
error guess make 	propagate propagate 
linked error 	aof 
error error copy 	propagate repl 
match match 	cmd call 
name pattern match 	full slowlog 
name pattern 	stats propagate 
starts xstrdup oid 	exact propagation 
lookup commit 	behavior 
reference gently alloc 	depends client 
grow memset 	flags specifically 
oid tips tips 	client flags 
starts list 	client force 
append clear commit 	aof client 
marks many 	force 
list sort 	repl assuming 
starts list sha 	corresponding cmd 
info list 	call propagate 
append list clear 	aof repl 
oid lookup 	call flags 
commit reference gently 	command 
merge bases 	propagated even 
many make linked 	dataset affected 
oidcpy copy 	command client 
list clear free 	flags client 
strcmp list 	prevent repl 
append nodup list 	prop 
sort parse 	client prevent 
push refspec match 	aof prop 
lhs free 	propagation aof 
refspec tail parse 	slaves performed 
push refspec 	even command 
match refs match 	modified 
prepare index 	dataset note 
list lookup 	regardless client 
make linked oidcpy 	flags cmd 
list insert 	call propagate 
copy free list 	aof cmd 
clear missing 	call 
tags match prepare 	propagate repl 
index list 	respectively aof 
alloc free list 	slaves propagation 
clear oidcpy 	never occur 
oid oidcmp oidcmp 	client flags 
oid starts 	modified 
file lookup commit 	implementation given 
reference gently 	command following 
lookup commit reference 	api force 
gently newer 	command propagation 
remote xcalloc xcalloc 	client flags 
xstrdup remote 	prevent 
find tracking 	command propagation 
strcmp dwim strlen 	client prevent 
xstrdup read 	command aof 
config strcmp make 	client prevent 
branch merge 	command replication 
refname match start 	client 
strbuf vaddf 	sent command 
end error buf 	clients monitor 
exists error 	mode commands 
buf error buf 	generated reading 
error buf 	aof initialization 
apply refspecs error 	clear 
buf error 	flags must 
buf remote pushremote 	command demand 
branch error 	initialize additional 
buf apply refspecs 	commands propagation 
error buf 	call command 
tracking push dest 	eval 
free tracking 	called loading 
push dest 	aof want 
error buf tracking 	commands called 
push dest 	lua slowlog 
branch upstream branch 	populate statistics 
upstream tracking 	caller 
push dest strcmp 	lua want 
error buf 	force eval 
die branch push 	caller propagate 
resolve strchr 	script command 
match name pattern 	flag client 
ignore symref 	flag 
update copy alloc 	forcing propagation 
free refname 	log command 
match find name 	slow log 
abbrev copy 	needed populate 
starts alloc starts 	per command 
starts starts 	statistics 
alloc prefix alloc 	show info 
prefix expanded 	commandstats propagate 
map alloc 	command aof 
oid hex remote 	replication link 
die local 	check command 
starts check refname 	operated 
format error 	changes data 
free free tail 	replication aof 
link strcmp 	propagation client 
oidcpy pop commit 	forced aof 
deref tag 	replication command 
parse deref tag 	flags 
parse parse 	regardless command 
commit commit list 	effects data 
insert pop 	however prevent 
recent commit commit 	aof replication 
list insert 	propagation command 
unmark free unmark 	implementatino 
free branch 	called prevent 
upstream read lookup 	command propagation 
commit reference 	similar call 
read lookup 	flags call 
commit reference argv 	propagate least 
push argv 	one 
push argv pushf 	aof replication 
oid hex 	propagation needed 
oid hex argv 	restore old 
push init 	replication flags 
revisions setup revisions 	since call 
prepare revision 	executed 
walk die revision 	recursively handle 
clear commit 	also propagate 
marks clear commit 	api handle 
marks argv 	commands want 
clear stat tracking 	propagate multiple 
info shorten 	separated 
unambiguous strbuf addf 	commands note 
strbuf addf 	also propagate 
strbuf addf strbuf 	affected client 
addf strbuf 	prevent prop 
addf strbuf 	flag whatever 
addf strbuf addf 	command 
strbuf addf 	wish honor 
strbuf addf free 	call flags 
check refname 	function gets 
format alloc oidcpy 	called already 
copy find 	read whole 
name find name 	command 
oidcmp copy 	arguments client 
starts oidcmp copy 	argv argc 
memset query 	fields process 
refspecs multiple list 	command execute 
make linked 	command prepare 
oidcpy list clear 	server 
list append 	bulk read 
list sort list 	client returned 
clear free 	client still 
free memset 	alive valid 
alloc grow memset 	operations performed 
xmemdupz clear 	caller 
cas option strchrnul 	otherwise err 
cas entry 	returned client 
sha error parse 	destroyed quit 
push cas 	quit command 
option apply refspecs 	handled separately 
read refname 	normal 
match hashcpy remote 	command procs 
tracking remote 	checking replication 
tracking apply cas 	quit cause 
unspecified previous 	trouble force 
entry overwritten branches 	replication enabled 
file would 	would 
url optionally branch 	implemented regular 
specified master 	command proc 
specified branch fetched 	lookup command 
stored local 	check asap 
branch matching 	trivial error 
remote name cogito 	conditions 
compatible push 	wrong arity 
push current head 	bad command 
remote branch 	name forth 
master missing always 	check user 
follow handle 	authenticated cluster 
remote variables handle 	enabled 
remote name 	perform cluster 
variables function frees 	redirection however 
refspec warning 	perform redirection 
code paths ensure 	sender command 
src dst 	master command 
pointers always freeable 	key 
pointers well 	arguments handle 
refspec pointer going 	maxmemory directive 
special refspec 	first free 
pushing matching refs 	memory possible 
lhs empty 	keys dataset 
means head 	thing 
valid looking rhs 	returning error 
missing empty 	free memory 
empty means store 	needed may 
valid looking 	flush slave 
lhs empty allowed 	output buffers 
means wildcarded 	may 
must valid looking 	result slave 
otherwise must 	may active 
extended sha existing 	client freed 
way validate 	impossible free 
empty anything goes 	enough memory 
rhs missing 	command 
allowed lhs must 	client trying 
valid looking 	execute denied 
empty allowed otherwise 	oom conditions 
must valid 	error accept 
looking refspec must 	write commands 
greater zero 	problems 
must valid 	persisting disk 
since possible reach 	master instance 
point within 	accept write 
loop slash last 	commands enough 
possibility doesn 	good slaves 
occur fetch head 	user 
ignore entries 	configured min 
always appear end 	slaves write 
list entry 	option accept 
already existed match 	write commands 
weak refs 	read slave 
outside heads tags 	accept 
specify pattern 	write commands 
full refs remotes 	master allow 
origin master 	subscribe unsubscribe 
least toplevel remotes 	context pub 
origin master 	sub allow 
otherwise git 	info 
push url master 	slaveof slave 
would result 	serve stale 
ambiguity remotes origin 	data slave 
master heads 	broken link 
master remote site 	master loading 
want weak 	error 
matches found multiple 	command cmd 
matches one 	loading flag 
strong matches found 	lua script 
ambiguous one 	slow allow 
strong match zero 	limited number 
weak matches 	commands 
acceptable unique match 	exec command 
source could 	shutdown close 
sha format reference 	listening sockets 
name refs 	also unlink 
way remote end 	unix domain 
matching refs 	socket 
traditionally pushed 	unlink unix 
everything including refs 	socket non 
outside refs 	zero care 
heads hierarchy make 	fails kill 
much sense 	lua debugger 
days collect everything 	forked 
know would 	sessions kill 
end push collect 	saving child 
tags collect 	background saving 
tags tag already 	progress want 
conservative point 	avoid 
src tag lists 	race conditions 
tags missing 	instance saving 
dst sent tips 	child may 
lists tips 	overwrite synchronous 
pushing know already 	saving shutdown 
element src 	kill 
tag ancestor sent 	aof saving 
tips needs 	child aof 
sent side 	already may 
pushing commit error 	longer contains 
tag reachable 	full dataset 
commits sending given 	anyway 
local refs 	aof enabled 
sanity check push 	haven written 
refspecs errors 	aof yet 
match push refs 	shutdown dataset 
would errors 	lost append 
early even talking 	file 
remote side 	fsync aof 
given refs local 	exit create 
repository refs 	rdb file 
remote repository refspec 	exiting snapshotting 
used push 	perform sync 
determine remote refs 	save 
update setting 	exit ooops 
peer pushed force 	error saving 
push forced 	best operating 
elements dst 	note background 
function may elements 	saving process 
dst pushing 	next 
branch done match 	cron redis 
refs pick 	notified background 
remainder already sending 	saving aborted 
something remote 	handling special 
doesn pattern mirror 	stuff like 
create one 	slaves 
link check missing 	pending synchronization 
refs remote 	pid file 
already sending something 	possible needed 
remote moved 	best effort 
different expect reject 	flush slave 
push also 	output 
error user told 	buffers hopefully 
check remote 	send pending 
tracking branch 	writes close 
find expect tracking 	listening sockets 
branch isn 	apparently allows 
stale force update 	faster 
update isn 	restarts commands 
already rejected check 	zero non 
usual must 	zero comparison 
fast forward rules 	performed way 
decide whether 	prevents attacker 
individual refspec pushed 	obtain 
push succeed 	information nature 
following remote reference 	monitoring execution 
exist remote 	time function 
reference removed pushing 	note limiting 
source specified 	comparison length 
destination refs tags 	bytes 
old commit 	avoid leaking 
descendant old forced 	information password 
notation passing 	length possible 
force argument 	branch misprediction 
force defeat rejection 	related leak 
implemented rules 	two 
branch already run 	strlen perform 
merge config 	len len 
make sure confuse 	operations either 
callers non 	password length 
zero merge merge 	difference relative 
merge config 	length 
user didn define 	user provided 
real branch 	information leak 
branch vivified non 	possible following 
existing refs 	two lines 
create list consisting 	code compare 
copies remote 	longer 
matches refspec refspec 	buffers note 
must pattern 	never pass 
fill copies peer 	first test 
describe local 	practical circumstances 
tracking refs 	info leak 
map omit references 	constant 
would map 	time constant 
existing local symbolic 	time time 
dereference item 	following two 
old must commit 	copies proportional 
ish descendant 	len len 
old otherwise require 	info 
force compare 	leaked always 
branch upstream save 	compare chars 
differences number 	two buffers 
commits num num 	without conditional 
name upstream 	expressions length 
branch upstream defined 	must 
returned via 	equal well 
upstream name returns 	zero ping 
num num 	command works 
could filled upstream 	different way 
defined exist 	client pub 
otherwise cannot 	sub 
stat unless marked 	mode command 
build top 	takes zero 
somebody cannot stat 	one arguments 
used build 	gettimeofday fail 
longer exists run 	bad address 
rev list 	check 
left right internally 	errors helper 
ignored count 	function reply 
commits side clear 	command output 
flags smudged 	flags output 
traversal anything report 	representation redis 
otherwise already 	command 
know starts refs 	used command 
transports support 	command adding 
directly peeking head 	command name 
points guess 	arg count 
refs heads master 	flags first 
could right 	last 
look another 	offset command 
points matches find 	subcommand args 
suitable refspec 	convert amount 
symref list refs 	bytes human 
currently exist 	readable form 
remote consider stale 	forth 
order deal 	bytes hope 
overlapping refspecs need 	never need 
matching refs 	create returned 
compare swap option 	info command 
option option 	decoupled info 
refname option refname 	command 
look remote 	need report 
fetch refspec see 	information memory 
remote tracking 	corruption problems 
branch refname fill 	server uname 
current sha 	slow always 
cannot negative 	output 
signal error tracking 	cache clients 
refname remote 	memory peak 
know tracking cannot 	memory updated 
read find 	time time 
option name entry 	server cron 
option cover 	may 
branch another remote 	happen instantaneous 
also uses 	slightly bigger 
non remote tracking 	peak may 
refs advise 	confuse users 
user local branches 	update peak 
silently skip 	found 
non remote refs 	smaller current 
make sure 	memory usage 
symrefs deleted first 	persistence fake 
symrefs rename 	second figure 
rest create symrefs 	enough info 
cannot pass 	stats 
function deletes 	replication min 
branches one one 	slaves write 
since relies 	active write 
cached refs invalidated 	number slaves 
deleting branch 	currently considered 
sorting comparison list 	good 
push info 	cpu cmdtime 
structs field remote 	cluster key 
branch info 	space ignore 
git pull info 	monitor already 
git push 	slave monitor 
info make sure 	mode 
valid fetch 	maxmemory directive 
mode use fetch 	free memory 
url push 	needed gets 
found requested special 	called maxmemory 
cases entry 	config file 
old url specified 	limit 
demand one 	max memory 
matches builtin 	used server 
remote usage builtin 	processing command 
remote usage 	goal function 
builtin remote rename 	free enough 
usage builtin 	memory 
remote usage builtin 	keep redis 
remote sethead 	configured memory 
usage builtin remote 	limit function 
setbranches usage 	starts calculating 
builtin remote show 	many bytes 
usage builtin 	freed 
remote prune usage 	keep redis 
builtin remote 	limit enters 
update usage builtin 	loop selecting 
remote geturl 	best keys 
usage builtin remote 	evict accordingly 
seturl usage 	configured 
verbose name argv 	policy bytes 
key branchname 	needed back 
remotename mirror 	limit freed 
tmp mirror advice 	function returns 
opt arg 	otherwise err 
mirror argc argv 	returned 
fetch tags 	caller block 
mirror track master 	execution commands 
remote buf 	result memory 
name url options 	used server 
remote name 	lru approximation 
merge branch list 	algorithm 
name prefix 	redis uses 
key orig key 	approximation lru 
name item 	algorithm runs 
info key len 	constant memory 
space merge 	every time 
remote stale tracked 	key 
heads push 	expire sample 
queried remote 	keys small 
refs states tail 	usually around 
stale refs 	populate pool 
item dest forced 	best keys 
remote refs 	evict 
states remote local 	keys pool 
refs push 	size defined 
map item info 	maxmemory eviction 
states remote 	pool size 
item info spec 	keys sampled 
remote refs 	added 
states matches fetch 	pool good 
map tail 	keys expire 
refspec next remote 	one old 
list remote 	access time 
data remote branches 	better one 
skipped keep 	current 
refname oid flags 	keys pool 
data branches 	pool populated 
refspec old 	best key 
remote branches refname 	pool expired 
oid flags 	however note 
data rename buf 	keys 
item flag 	pool deleted 
orig oid symref 	pool may 
remote buf 	contain keys 
argc argv options 	longer exist 
oldremote newremote 	evict key 
old remote context 	entries 
remote branches 	pool exist 
rename refspec updated 	populate time 
ptr item 	sure pool 
info item flag 	least one 
oid item 	key evicted 
item argc argv 	least 
options remote 	one key 
buf known remotes 	evicted whole 
branches skipped 	database create 
data result 	eviction pool 
item info info 	helper function 
states refname 	free 
oid flags data 	memory needed 
states refspec 	used order 
name states query 	populate eviction 
transport remote 	pool entries 
refs list states 	every time 
width width 	want 
rebase item data 	expire key 
info item 	keys idle 
data info states 	time smaller 
name fmt 	one current 
arg branch item 	keys added 
data show 	keys 
info states branch 	always added 
info item 	free entries 
item data show 	insert keys 
info branch 	place order 
info merge 	keys smaller 
also push item 	idle 
data show 	time left 
info push info 	keys higher 
item push 	idle time 
push cmp item 	right use 
data show 	buffer function 
info push info 	big 
status remote 	hit note 
priv list url 	actually measured 
buf url 	helps dictionary 
url list result 	sampling main 
item argc 	dictionary expires 
argv query flag 	one 
options states 	need lookup 
info list info 	key key 
url url 	dictionary obtain 
argc argv 	insert element 
result buf head 	inside pool 
name options 	first 
states remote dry 	find first 
run result 	empty bucket 
states refs prune 	first populated 
item dangling 	bucket idle 
msg refname argc 	time smaller 
argv result 	idle 
options key priv 	time insert 
found argc 	element worst 
argv prune options 	element empty 
fetch argv 	buckets inserting 
defined retval remote 	empty position 
key remote 	setup 
branches key remotename 	needed insert 
mirror refspec 	inserting middle 
remotename branches mode 	points first 
key remote 	element greater 
argc argv 	element insert 
mode options argc 	free 
argv mode 	space right 
remotename remote url 	insert shifting 
url options 	elements end 
argc argv mode 	right free 
negative matches 	space right 
remotename newurl oldurl 	insert 
remote old 	shift elements 
regex urlset urlset 	left included 
name buf 	left discard 
options argc argv 	element smaller 
prefix options 	idle time 
result run command 	size 
opt error 	slaves output 
strbuf reset strbuf 	buffers aof 
addch strbuf 	buffer count 
addf strbuf addf 	used memory 
git config 	check memory 
multivar warning 	limit 
strcmp strcmp error 	need free 
parse options 	memory policy 
usage options die 	forbids compute 
die remote 	much memory 
remote configured die 	need free 
strbuf addf 	prevent 
valid fetch refspec 	warning random 
die strbuf 	allkeys random 
addf git config 	policy lru 
strbuf reset 	allkeys lru 
strbuf addf list 	policy backward 
append branch 	best 
strbuf reset strbuf 	worst element 
addf git 	evict entry 
config strbuf reset 	pool shift 
strbuf addf 	elements right 
git config fetch 	left clear 
remote strbuf 	element 
reset strbuf 	right empty 
addf strbuf reset 	since shifted 
strbuf addf 	one position 
create symref error 	left key 
strbuf release 	exists pick 
strbuf release list 	otherwise 
clear skip 	ghost need 
prefix starts strip 	next element 
suffix xmemdupz 	ghost ttl 
strip suffix xmemdupz 	expire sooner 
strip suffix 	minor expire 
xmemdupz list insert 	unix 
xcalloc warning 	timestamp better 
xstrdup strchr abbrev 	candidate deletion 
branch xstrndup 	selected key 
list append abbrev 	compute amount 
branch strchr 	memory freed 
list append xstrdup 	alone 
git config 	possible actually 
maybe strcmp 	memory needed 
strcmp git config 	propagate del 
fetch map 	aof replication 
die exists list 	link greater 
append abbrev 	one 
branch list append 	freeing removing 
abbrev branch 	key account 
stale heads list 	otherwise would 
append abbrev 	never exit 
branch xstrdup free 	loop aof 
refs free 	output 
refs list sort 	buffer memory 
list sort 	freed eventually 
list sort local 	care memory 
heads copy 	used key 
list match push 	space memory 
refs oidcpy 	free 
list append 	starts big 
abbrev branch xcalloc 	enough may 
xstrdup abbrev 	start spending 
branch oid oidcmp 	much time 
oid file 	impossible deliver 
newer free refs 	data 
free refs 	slaves fast 
list append xcalloc 	enough force 
xstrdup list 	transmission inside 
append strlen list 	loop nothing 
append list 	free main 
append xcalloc xstrdup 	linux 
fetch map 	pidfile requested 
guess remote head 	pidfile defined 
find name 	use pidfile 
list append abbrev 	path write 
branch free 	pid file 
refs free refs 	best 
strcmp xmalloc 	effort way 
memset remote 	parent exits 
find tracking memset 	create session 
remote find 	every output 
tracking starts starts 	goes dev 
list append 	redis 
abbrev branch unlink 	daemonized logfile 
git path 	stdout configuration 
list append strbuf 	file log 
addf starts 	sigint often 
list append xstrdup 	delivered via 
resolve xstrdup 	ctrl 
strbuf addf git 	interactive session 
config multivar 	receive signal 
strbuf reset strbuf 	second time 
addf git 	interpret user 
config multivar strbuf 	really wanting 
reset strbuf 	quit 
addf git config 	asap without 
multivar unlink 	waiting persist 
warn git 	disk exit 
path unlink warn 	error since 
git path 	clean shutdown 
usage options remote 	siginfo 
remote configured 	flag flags 
die strcmp migrate 	sigaction used 
file remote 	otherwise handler 
remote configured die 	used returns 
strbuf addf 	sentinel among 
valid fetch refspec 	arguments 
die strbuf 	argv exactly 
reset strbuf addf 	redis sentinel 
strbuf addf 	function called 
git config rename 	startup load 
section error 	rdb aof 
strbuf reset strbuf 	file 
addf git 	memory check 
config multivar strbuf 	whether systemd 
addf strbuf 	upstart used 
reset strbuf 	start redis 
addstr strstr strbuf 	test 
splice strlen 	found need 
strlen strlen warning 	initialize libraries 
git config 	server configuration 
multivar read branches 	store executable 
strcmp strbuf 	path arguments 
reset strbuf addf 	safe 
git config 	place order 
read full die 	able restart 
strbuf reset 	server later 
strbuf addstr strbuf 	need init 
splice strlen 	sentinel right 
strlen strlen strbuf 	parsing 
reset strbuf 	configuration file 
addf rename die 	sentinel mode 
strbuf reset 	effect populating 
strbuf addstr 	sentinel data 
strbuf splice strlen 	structures master 
strlen strlen 	nodes 
strbuf reset strbuf 	monitor check 
addstr strbuf 	need start 
splice strlen strlen 	redis check 
strlen strbuf 	rdb mode 
reset strbuf addf 	execute program 
create symref 	main 
die memset usage 	however program 
options remote 	part redis 
remote configured die 	executable easily 
remote read 	execute rdb 
branches strcmp strbuf 	check loading 
reset strbuf 	errors 
addf git config 	first option 
strbuf release 	parse argv 
refs list clear 	handle special 
list clear 	options help 
strbuf addf 	version first 
git config rename 	argument 
section error 	config file 
free free list 	name replace 
clear list 	config file 
clear list clear 	server exec 
list clear 	argv absoulte 
list clear func 	path 
memset remote 	options parsed 
find tracking list 	conceptually appended 
append abbrev 	configuration file 
branch remote error 	instance port 
read branches 	generate port 
transport transport remote 	parsed 
refs transport 	actual file 
disconnect states head 	name parsed 
names push 	option name 
states list sort 	argument options 
push states 	need skip 
noquery strlen 	parsing 
list insert list 	option argument 
list list 	things needed 
strcmp strlen list 	running sentinel 
insert error 	mode warning 
strlen strlen list 	user suspicious 
append strcmp 	maxmemory 
strcmp strbuf addf 	setting end 
list append 	server.h idle 
strbuf detach list 	key seconds 
append strbuf 	changes crlf 
addf list append 	err emptybulk 
strbuf detach 	czero 
remote list sort 	cone cnegone 
strcmp list 	pong space 
clear parse options 	colon nullbulk 
show memset 	nullmultibulk queued 
memset remote states 	emptymultibulk wrongtypeerr 
list list 	nokeyerr 
list list 	syntaxerr sameobjecterr 
list clear list 	outofrangeerr noscripterr 
list list 	loadingerr slowscripterr 
clear list qsort 	bgsaveerr masterdownerr 
list list 	roslaveerr execaborterr 
clear free remote 	noautherr 
states parse 	noreplicaserr busykeyerr 
options strbuf addf 	oomerr plus 
xstrdup memset 	messagebulk pmessagebulk 
remote states error 	subscribebulk unsubscribebulk 
error xstrdup 	psubscribebulk punsubscribebulk 
free remote states 	del 
error usage 	rpop lpop 
options strbuf addf 	lpush emptyscan 
exists error 	minstring maxstring 
create symref error 	integers mbulkhdr 
free strbuf 	bulkhdr client 
release strbuf 	buffer 
release memset remote 	limits defaults 
states free 	pid configfile 
remote states list 	executable exec 
append list 	argv commands 
sort refs abbrev 	orig commands 
abbrev warn 	shutdown 
dangling symrefs list 	asap activerehashing 
clear free 	requirepass pidfile 
remote states parse 	arch bits 
options usage 	cronloops runid 
options prune remote 	sentinel mode 
strcmp parse 	port 
options argv push 	tcp backlog 
argv push 	bindaddr bindaddr 
argv push argv 	count unixsocket 
push argv 	unixsocketperm ipfd 
push argv push 	ipfd count 
strcmp git 	sofd 
config argv 	cfd cfd 
pop argv push 	count clients 
run command 	clients close 
opt argv clear 	clients pending 
git config 	write slaves 
multivar gently branch 	monitors 
strbuf release 	current client 
strbuf addf remote 	clients paused 
remote configured 	clients pause 
die fetch refspecs 	end time 
strbuf release 	neterr migrate 
branches strbuf release 	cached 
parse options 	sockets next 
error usage options 	client mode 
remote branches 	loading loading 
parse options usage 	total bytes 
options remote 	loading loaded 
remote configured die 	bytes 
die parse 	loading start 
options die 	time loading 
usage options remote 	process events 
remote configured 	interval bytes 
die strbuf addf 	del command 
strbuf addf 	multi 
git config multivar 	command lpush 
git config 	command lpop 
strbuf release regcomp 	command rpop 
die regexec 	command srem 
die die regfree 	command exec 
git config 	command 
multivar git config 	stat starttime 
multivar parse 	stat numcommands 
options show strcmp 	stat numconnections 
strcmp strcmp 	stat expiredkeys 
strcmp strcmp head 	stat evictedkeys 
strcmp branches 	stat 
strcmp url strcmp 	keyspace hits 
url strcmp 	stat keyspace 
show strcmp 	misses stat 
prune strcmp update 	peak memory 
error usage 	stat fork 
options unspecified previous 	time 
entry overwritten 	stat fork 
branches file would 	rate stat 
url optionally 	rejected conn 
branch specified master 	stat sync 
specified branch 	full stat 
fetched stored local 	sync 
branch matching 	stat sync 
remote name cogito 	err slowlog 
compatible push 	slowlog entry 
push current head 	slowlog log 
remote branch 	slower slowlog 
master missing always 	max 
follow handle 	len resident 
remote variables handle 	size stat 
remote name 	net input 
variables function 	bytes stat 
frees refspec warning 	net output 
code paths 	bytes 
ensure src dst 	last sample 
pointers always 	time last 
freeable pointers well 	sample count 
refspec pointer 	samples idx 
going special refspec 	verbosity maxidletime 
pushing matching 	tcpkeepalive 
refs lhs empty 	active expire 
means head 	enabled client 
valid looking rhs 	max querybuf 
missing empty 	len dbnum 
empty means store 	supervised supervised 
valid looking 	mode 
lhs empty allowed 	daemonize client 
means wildcarded 	obuf limits 
must valid 	aof state 
looking otherwise must 	aof fsync 
extended sha 	aof filename 
existing way validate 	aof 
empty anything 	fsync rewrite 
goes rhs missing 	aof rewrite 
allowed lhs 	perc aof 
must valid looking 	rewrite min 
empty allowed 	size aof 
otherwise must valid 	rewrite 
looking refspec 	size aof 
must greater zero 	current size 
must valid 	aof rewrite 
since possible reach 	scheduled aof 
point within 	child pid 
loop slash last 	aof 
possibility doesn 	rewrite buf 
occur fetch head 	blocks aof 
ignore entries 	buf aof 
always appear 	aof selected 
end list entry 	aof flush 
already existed 	postponed 
match weak refs 	start aof 
outside heads 	last fsync 
tags specify pattern 	aof rewrite 
full refs 	time last 
remotes origin master 	aof rewrite 
least toplevel 	time 
remotes origin master 	start aof 
otherwise git 	lastbgrewrite status 
push url master 	aof delayed 
would result 	fsync aof 
ambiguity remotes origin 	rewrite incremental 
master heads 	fsync 
master remote site 	aof last 
want weak 	write status 
matches found multiple 	aof last 
matches one 	write errno 
strong matches 	aof load 
found ambiguous one 	truncated 
strong match 	aof pipe 
zero weak matches 	write data 
acceptable unique 	child aof 
match source could 	pipe read 
sha format 	data parent 
reference name refs 	aof 
way remote 	pipe write 
end matching refs 	ack parent 
traditionally pushed 	aof pipe 
everything including refs 	read ack 
outside refs 	child aof 
heads hierarchy make 	pipe 
much sense 	write ack 
days collect everything 	child aof 
know would 	pipe read 
end push collect 	ack parent 
tags collect 	aof stop 
tags tag 	sending 
already conservative point 	diff aof 
src tag 	child diff 
lists tags missing 	dirty dirty 
dst sent 	bgsave rdb 
tips lists tips 	child pid 
pushing know 	saveparams 
already element src 	saveparamslen rdb 
tag ancestor 	filename rdb 
sent tips needs 	compression rdb 
sent side 	checksum lastsave 
pushing commit error 	lastbgsave rdb 
tag reachable 	save 
commits sending given 	time last 
local refs 	rdb save 
sanity check push 	time start 
refspecs errors 	rdb child 
match push 	type lastbgsave 
refs would errors 	status 
early even 	stop writes 
talking remote side 	bgsave err 
given refs 	rdb pipe 
local repository refs 	write result 
remote repository 	parent rdb 
refspec used push 	pipe 
determine remote 	read result 
refs update setting 	child also 
peer pushed 	propagate logfile 
force push forced 	syslog enabled 
elements dst 	syslog ident 
function may elements 	syslog 
dst pushing 	facility slaveseldb 
branch done match 	master repl 
refs pick 	offset repl 
remainder already sending 	ping slave 
something remote 	period repl 
doesn pattern 	backlog 
mirror create one 	repl backlog 
link check 	size repl 
missing refs remote 	backlog histlen 
already sending 	repl backlog 
something remote moved 	idx repl 
different expect 	backlog 
reject push also 	repl backlog 
error user 	time limit 
told check remote 	repl slaves 
tracking branch 	since repl 
find expect tracking 	min slaves 
branch isn 	write 
stale force update 	repl min 
update isn 	slaves max 
already rejected check 	lag repl 
usual must 	good slaves 
fast forward rules 	count repl 
decide whether 	diskless 
individual refspec 	sync repl 
pushed push succeed 	diskless sync 
following remote 	delay masterauth 
reference exist remote 	masterhost masterport 
reference removed 	repl timeout 
pushing source specified 	master 
destination refs 	cached master 
tags old commit 	repl syncio 
descendant old 	timeout repl 
forced notation passing 	state repl 
force argument 	transfer size 
force defeat rejection 	repl 
implemented rules 	transfer read 
branch already run 	repl transfer 
merge config 	last fsync 
make sure confuse 	repl transfer 
callers non 	repl transfer 
zero merge merge 	repl 
merge config 	transfer tmpfile 
user didn 	repl transfer 
define real branch 	lastio repl 
branch vivified 	serve stale 
non existing refs 	data repl 
create list 	slave 
consisting copies remote 	repl since 
matches refspec 	repl disable 
refspec must pattern 	tcp nodelay 
fill copies 	slave priority 
peer describe local 	repl master 
tracking refs 	runid 
map omit references 	repl master 
would map 	initial offset 
existing local symbolic 	repl scriptcache 
dereference item 	dict repl 
old must commit 	scriptcache fifo 
ish descendant 	repl 
old otherwise 	scriptcache size 
require force compare 	clients waiting 
branch upstream 	acks ack 
save differences number 	slaves maxclients 
commits num 	maxmemory maxmemory 
num name upstream 	policy 
branch upstream 	maxmemory samples 
defined returned via 	bpop blocked 
upstream name 	clients unblocked 
returns num num 	clients ready 
could filled 	keys sort 
upstream defined exist 	desc 
otherwise cannot 	sort alpha 
stat unless marked 	sort bypattern 
build top 	sort store 
somebody cannot stat 	hash max 
used build 	ziplist entries 
longer exists run 	hash 
rev list 	max ziplist 
left right 	max intset 
internally ignored count 	entries zset 
commits side 	max ziplist 
clear flags smudged 	entries zset 
traversal anything 	max 
report otherwise already 	ziplist hll 
know starts 	sparse max 
refs transports support 	bytes list 
directly peeking 	max ziplist 
head points guess 	size list 
refs heads 	compress 
master could right 	depth unixtime 
look another 	mstime pubsub 
points matches find 	channels pubsub 
suitable refspec 	patterns notify 
symref list refs 	keyspace events 
currently exist 	cluster 
remote consider stale 	enabled cluster 
order deal 	node timeout 
overlapping refspecs 	cluster configfile 
need matching refs 	cluster cluster 
compare swap 	migration barrier 
option option option 	cluster 
refname option 	slave validity 
refname look remote 	factor cluster 
fetch refspec 	require full 
see remote tracking 	coverage lua 
branch refname 	lua client 
fill current sha 	lua 
cannot negative 	caller lua 
signal error tracking 	scripts lua 
refname remote 	time limit 
know tracking cannot 	lua time 
read find 	start lua 
option name entry 	write 
option cover 	dirty lua 
branch another remote 	random dirty 
also uses 	lua replicate 
non remote 	commands lua 
tracking refs advise 	multi emitted 
user local 	lua 
branches silently skip 	repl lua 
non remote 	timedout lua 
refs make sure 	kill lua 
symrefs deleted 	always replicate 
first symrefs rename 	commands latency 
rest create 	monitor 
symrefs cannot pass 	threshold latency 
function deletes 	events failed 
branches one one 	file line 
since relies 	bug report 
cached refs invalidated 	start watchdog 
deleting branch 	period 
sorting comparison list 	system memory 
push info 	size name 
structs field remote 	proc arity 
branch info 	sflags flags 
git pull 	getkeys proc 
info git push 	firstkey 
info make 	lastkey keystep 
sure valid fetch 	microseconds calls 
mode use 	name pointer 
fetch url push 	server shared 
found requested 	dict type 
special cases entry 	zset 
old url 	dict type 
specified demand one 	cluster nodes 
matches remote.h 	dict type 
ent name origin 	cluster nodes 
foreign vcs 	black list 
url url url 	dict 
alloc pushurl 	type dict 
pushurl pushurl alloc 	type sha 
push refspec 	script dict 
push push 	type zero 
refspec push refspec 	pos inf 
alloc fetch 	neg 
refspec fetch fetch 	inf nan 
refspec fetch 	hash dict 
refspec alloc fetch 	type repl 
tags skip 	script cache 
update mirror prune 	dict 
receivepack uploadpack 	type len 
http proxy http 	crc retcode 
proxy authmethod 	count title 
name name remote 	privdata mask 
priv remote 	node length 
url src dst 	privdata 
tag refspec 	mask privdata 
next old oid 	mask privdata 
oid old 	mask privdata 
oid expect symref 	mask obj 
remote status 	len obj 
peer name 	err 
list name name 	status length 
cmp refs 	dst src 
matched flags src 	longest output 
buf src 	list biggest 
len list flags 	input buffer 
extra shallow 	peerid 
list oid old 	peerid len 
oid map 	port client 
refspec refspec refspec 	client argc 
refspec refspec 	newval argc 
specs query refspecs 	argv name 
refspec name 	port 
src refspec refspec 	fds count 
src dst 	duration handler 
refspec refspec remote 	installed attribute 
refs send 	attribute fmt 
mirror force update 	fmt subject 
remote refs 	subject 
refspec tail 	subject subject 
missing remote refs 	subject index 
name remote 	direction entry 
refspec name refname 	entry entry 
remote name 	entry iter 
pushremote name merge 	entry 
name merge 	subject enc 
merge merge alloc 	key key 
push tracking 	dbid obj 
name branch branch 	type ptr 
branch branch 	ptr len 
branch err branch 	ptr 
err branch 	len ptr 
num num upstream 	len llongval 
name branch 	humanfriendly target 
head refs refs 	msg type 
count fetch 	target msg 
map expect refname 	target 
alloc option 	msg target 
arg unset 	target target 
push cas option 	msg encoding 
arg unset 	ptr size 
push cas option 	timeout ptr 
push cas 	size 
option remote must 	timeout ptr 
first never 	size timeout 
fetch tags follow 	slaves dictid 
tags heuristic 	argv argc 
always follow tags 	monitors dictid 
always fetch 	argv 
tags curl remotes 	argc bgsaveerr 
used expect 	type newsize 
old order important 	port sha 
write fetch 	sha offset 
head numeric order 	slave offset 
merge xcalloc 	pos 
structures renaming 	force cmd 
frees entire list 	dictid argv 
peers elements 	argc childpid 
free first entries 	filename exitcode 
input list 	bysignal zsl 
map remote reference 	zsl 
local reference 	score obj 
two entries map 	ele score 
different remote 	zsl score 
references local reference 	obj zsl 
emit error 	range zsl 
message die pointer 	range 
head resulting 	sptr eptr 
list given list 	sptr eptr 
remote refs 	sptr zobj 
specification things fetch 	zobj encoding 
makes separate 	zobj maxelelen 
list refs fetch 	zobj 
local refs 	member score 
store tail 	zsl score 
pointer tail pointer 	name name 
list results 	flags cmd 
beforehand tail pointer 	dbid argv 
list results 	argc 
afterward missing usually 	flags cmd 
adding branch 	dbid argv 
name merge branch 	argc target 
remote anymore 	flags attribute 
given remote reads 	level fmt 
refspec src 	level 
sets fields fully 	msg level 
qualified refname 	msg dict 
tracking branch branch 	msg unlink 
branch upstream 	unix socket 
would give returns 	flags delay 
upstream defined 	subject 
err upstream defined 	subject subject 
specific error 	subject objele 
message recorded 	llele setobj 
function err touched 	objele llele 
tracking branch 	count aux 
corresponds would push 	subject 
given bare 	subject enc 
git push branch 	enc subject 
err conventions 	argv start 
match branch upstream 	end subject 
flags match 	key key 
refs reporting tracking 	key 
info find 	key subject 
refs list likely 	vstr vlen 
pointed given 	vll dst 
head returns likely 	key notify 
otherwise returns 	notify channel 
list candidate refs 	message 
match found 	type key 
head returns returns 	dbid classes 
newly allocated 	flags filename 
freed refs 	options seconds 
longer exist remote 	changes state 
compare swap 	option 
repack.c delta offset 	line force 
pack kept 	path key 
objects write bitmaps 	key key 
packdir packtmp 	key key 
git repack usage 	key key 
buf dirlen 	key 
prefixlen dir signo 	key reply 
fname list 	key reply 
dir fname len 	key val 
dir name 	key val 
name exts buf 	key val 
plen argc 	key 
argv prefix name 	key key 
cmd item 	callback key 
names rollback 	dbid hashslot 
existing packs line 	keys count 
ext ret 	hashslot hashslot 
failed pack everything 	cursor 
redundant unpack 	cursor cmd 
unreachable window memory 	argv argc 
depth max 	numkeys result 
pack size reuse 	cmd argv 
update server 	argc numkeys 
info quiet local 	cmd 
builtin repack 	argv argc 
options fname fname 	numkeys cmd 
old rollback 	argv argc 
failure fname fname 	numkeys cmd 
old fname 	argv argc 
fname old statbuffer 	numkeys 
exists fname 	buf len 
opts sha len 	key keylen 
strcmp git 	channel message 
config strcmp 	argv argc 
git config strcmp 	rdbfilename argv 
strcmp git 	argc 
config git config 	setup pid 
opendir strlen 	btype timeout 
strbuf addstr readdir 	unit attribute 
strncmp strbuf 	attribute attribute 
setlen strbuf addstr 	attribute estr 
unlink closedir 	file 
strbuf release temporary 	line estr 
files sigchain 	file line 
pop opendir readdir 	msg file 
strip suffix 	line sig 
xmemdupz file exists 	info secret 
mkpath list 	section 
append nodup free 	period period 
closedir strbuf 	level descr 
addf size strbuf 	len bytes 
setlen strbuf 	passes copyright 
addstr unlink 	salvatore sanfilippo 
strbuf release git 	antirez 
config parse 	gmail dot 
options die mkpathdup 	rights reserved 
directory mkpathdup 	redistribution use 
getpid sigchain push 	source binary 
common argv 	forms without 
push argv push 	modification 
argv push 	permitted provided 
argv push argv 	following conditions 
push argv 	met redistributions 
push argv push 	source code 
argv pushf 	must retain 
argv pushf argv 	copyright 
pushf argv 	notice list 
pushf argv pushf 	conditions following 
argv pushf 	disclaimer redistributions 
argv push non 	binary form 
kept pack 	must reproduce 
filenames argv 	copyright 
pushf argv push 	notice list 
argv push 	conditions following 
argv push argv 	disclaimer documentation 
push argv 	materials provided 
push argv push 	distribution neither 
argv push 	name 
argv push argv 	redis names 
push start 	contributors may 
command xfdopen strbuf 	used endorse 
getline die 	promote products 
list append fclose 	derived software 
finish command 	without 
size mkpathdup file 	specific prior 
exists free 	written permission 
mkpathdup file exists 	software provided 
unlink rename 	copyright holders 
free free list 	contributors express 
append free 	implied 
mkpathdup mkpathdup 	warranties including 
rename list append 	limited implied 
free free 	warranties merchantability 
exit size mkpathdup 	fitness particular 
mkpathdup stat 	purpose disclaimed 
chmod rename die 	shall 
errno free 	copyright owner 
free size mkpathdup 	contributors liable 
path warning 	direct indirect 
free list sort 	incidental special 
strlen list 	exemplary consequential 
redundant pack isatty 	damages 
prune packed 	including limited 
objects update server 	procurement substitute 
info temporary 	goods services 
files list clear 	loss use 
list clear 	data profits 
list clear 	business 
strbuf release temporary 	interruption however 
git directory 	caused theory 
pack tmp pack 	liability whether 
files point 	contract strict 
slash end objects 	liability tort 
pack hold 	including 
length tmp pack 	negligence otherwise 
adds packs 	arising way 
hex fname list 	use software 
corresponding keep 	even advised 
file variables filled 	possibility damage 
option parsing 	millisecond 
prepared packfiles first 	time type 
see packs 	driven programming 
name move way 	library safe 
happen repacked 	hash tables 
immediately packing fully 	linked lists 
ones name 	total 
way old 	memory usage 
files end pack 	aware version 
replacement replace.c 	malloc free 
git replace usage 	networking easy 
pattern refname 	way compact 
oid flag data 	list 
data pattern 	data structure 
format data argv 	compact integer 
full hex 	structure version 
error sha name 	macro misc 
sha prev 	functions useful 
size force replace 	many 
repl force 	places latency 
prev transaction err 	monitor api 
replace force 	ascii graphs 
repl export force 	api following 
raw tmpfile 	includes allow 
old prev buf 	test 
argc argv 	functions called 
parents parent 	redis main 
start parent end 	error codes 
sha argc 	server configuration 
argv commit extra 	time interrupt 
data mergetag 	calls 
data tag sha 	sec tcp 
tag oid 	port tcp 
commit argc argv 	listen backlog 
mergetag data 	client timeout 
argc argv force 	infinite maximum 
old old 	length 
commit buf buffer 	syslog messages 
size argc 	hour wait 
argv prefix force 	secs trying 
raw format 	inet addrstrlen 
options wildmatch oid 	need sure 
hex sha 	must 
error sha info 	enough port 
sha info 	loopkups per 
oid hex 	loop microseconds 
strcmp strcmp strcmp 	cpu max 
die replace 	keys collection 
sha error sha 	instantaneous 
hex snprintf 	metrics tracking 
strlen read error 	number samples 
snprintf sha 	per metric 
hex die check 	number commands 
refname format 	executed bytes 
die read hashclr 	read 
die sha 	network bytes 
info sha info 	written network 
die check 	protocol related 
valid transaction begin 	defines max 
transaction update 	query buffer 
transaction commit die 	buffer 
transaction free 	size output 
sha die 	buffer max 
sha die replace 	size reads 
sha git 	bytes needed 
pathdup sha die 	str fdatasync 
sha info 	every 
die sha hex 	configuring server 
check valid 	eventloop setup 
export launch editor 	total number 
die free 	file descriptors 
hashcmp error sha 	handle server 
hex replace 	maxclients 
sha starts sha 	reserved fds 
die lookup 	stay safe 
commit die strbuf 	since reserved 
addf sha 	fds defaults 
hex strbuf splice 	order make 
strbuf release 	sure 
hash sha file 	provisioning fds 
lookup tag 	hash table 
die parse 	parameters minimal 
tag buffer die 	hash table 
sha die 	fill command 
oidcmp die sha 	flags 
hex mergetag 	please check 
sha die lookup 	command table 
commit die 	defined redis 
commit buffer strbuf 	file information 
unuse commit 	meaning every 
buffer replace parents 	flag 
signature warning 	flag flag 
warning check mergetags 	flag longer 
write sha 	used flag 
file die strbuf 	flag flag 
release hashcmp 	flag flag 
error sha hex 	flag 
replace sha 	flag flag 
parse options usage 	flag flag 
msg opt 	flag types 
usage msg 	objects encoding 
opt usage msg 	kind objects 
opt usage 	like 
msg opt replace 	hashes internally 
name usage 	represented multiple 
msg opt replace 	ways encoding 
usage msg 	field one 
opt edit replace 	fields raw 
usage msg 	representation 
opt create graft 	encoded integer 
usage msg 	encoded hash 
opt list replace 	table encoded 
refs die 	zipmap encoded 
builtin git replace 	regular linked 
copyright christian 	list 
couder chriscool tuxfamily 	encoded ziplist 
builtin tag 	encoded intset 
kristian gsberg krh 	encoded skiplist 
redhat carlos 	embedded sds 
rica jasampler 	encoding encoded 
gmail git tag 	linked 
mktag linus 	list ziplists 
torvalds data format 	defines related 
replace format 	dump file 
read may reuse 	format store 
buffer write 	bits lengths 
contents named sha 	keys 
file filename 	requires lot 
raw raw contents 	space check 
printed according 	significant bits 
type otherwise pretty 	first interpreter 
print contents 	length two 
human editing read 	msb 
previously exported 	len bits 
possibly edited back 	len byes 
filename interpreting 	bits bits 
type writing 	next bit 
result database sha 	integer full 
written returned 	bit 
via sha index 	len follow 
close need 	means specially 
close run command 	encoded follow 
index done 	six bits 
find existing parents 	number specify 
hex sha 	kind 
parent hex sha 	follows see 
prepare parents 	rdb enc 
replace existing parents 	defines lengths 
ones iterate 	stored single 
parents found replace 	keys may 
objectc original 	values 
replacement replace alloc 	fit inside 
replace index 	length stored 
table replace sha 	disk first 
replace ignore 	two bits 
dups pos 	remaining two 
refname oid flag 	bits 
data slash 	specify special 
hash repl obj 	encoding accordingly 
replace prepared 	following defines 
sha pos depth 	bit integer 
cur sha 	bit integer 
pos replace pos 	bit 
free free 	integer compressed 
alloc grow memmove 	fastlz aof 
strrchr xmalloc 	states aof 
strlen sha hex 	aof aof 
free warning 	waits rewrite 
hashcpy replace die 	start 
replace prepare 	appending client 
replace die sha 	flags client 
hex replace 	slave server 
pos replacements kept 	client master 
sorted original 	server client 
sha sha 	slave 
refname copy sha 	monitor see 
read allow 	monitor client 
recursive replacement within 	multi context 
reason though 	client waiting 
replacement sha replacement 	blocking operation 
name replaced 	watched 
recursively necessary either 	keys modified 
sha pointer 	exec fail 
permanently allocated function 	close writing 
always respects 	entire reply 
replace references regardless 	client unblocked 
check replace 	stored 
refs recursively replace 	server unblocked 
repo treec 	clients non 
path mode err 	connected client 
buf revision 	used lua 
src dst err 	client 
mode data 	issued asking 
path strbuf 	command close 
reset fast export 	client asap 
die errno 	client connected 
strbuf reset fast 	via unix 
export rev 	domain 
die errno fast 	socket exec 
export fast 	fail errors 
export modify fast 	queueing queue 
export licensed 	replies even 
two clause bsd 	master force 
style license 	aof 
see license details 	propagation current 
treat missing 	cmd force 
paths directories repo 	replication current 
treeh revision 	cmd instance 
src dst path 	understand psync 
mode blob 	cluster 
mark path mode 	client read 
path revision 	state client 
author log 	pub sub 
uuid url timestamp 	mode propagate 
rerere.c rerere 	aof propagate 
resolved rerere enabled 	slaves 
rerere autoupdate 	client output 
item file hex 	send write 
sha buf 	handler yet 
path sha write 	installed send 
buf strbuf 	replies client 
rerere output wrerror 	client 
count err 	reply skip 
err str size 	next cmd 
buf mem 	send reply 
input buf marker 	run eval 
marker size 	debug mode 
want sha marker 	eval 
size ctx 	debugging without 
hunk two 	fork client 
buf path sha 	block type 
output hunk 	btype field 
marker size input 	client structure 
len path 	client 
sha output mmfile 	blocked flag 
result pos 	blocked client 
len hunk marker 	blocked flag 
size size 	blpop wait 
type conflict conflict 	synchronous replication 
type merge 	client 
conflict type path 	request types 
ret result 	client classes 
index update item 	client limits 
item update 	currently used 
path conflict update 	max client 
sha path 	output 
ret flags merge 	buffer limit 
path filename 	implementation normal 
sha ret 	req reply 
item pathspec conflict 	clients monito 
merge name 	slaves clients 
dir name dir 	subscribed 
name dir 	pub sub 
cutoff cutoff noresolve 	channels master 
cutoff resolve 	number clients 
merge free git 	expose output 
path rerere 	buffer configuration 
hex git path 	first 
rerere hex 	three normal 
stat rerere path 	slave pubsub 
xmalloc xsnprintf 	slave replication 
rerere hex sha 	state used 
hex fopen 	server repl 
git path merge 	state 
strbuf getwholeline 	slaves remember 
sha hex die 	next active 
die rerere 	replication must 
hex list 	connect master 
insert strbuf release 	connecting master 
fclose strbuf 	handshake 
addf rerere hex 	states must 
write full 	ordered wait 
die strbuf release 	ping reply 
commit file 	send auth 
die fwrite ferr 	master wait 
write strlen 	auth 
ferr puts memset 	reply send 
memset rerere 	replconf listening 
putstr ferr write 	port wait 
strbuf getwholeline 	replconf reply 
isspace git sha 	send replconf 
init getline 	capa 
cmarker cmarker cmarker 	wait replconf 
cmarker strbuf 	reply send 
cmp strbuf swap 	psync wait 
rerere putconflict 	psync reply 
rerere putmem 	end handshake 
rerere putconflict rerere 	states 
putmem rerere 	receiving rdb 
putconflict git sha 	master connected 
update git 	master state 
sha update strbuf 	slaves pov 
reset strbuf 	master used 
reset strbuf addbuf 	client 
strbuf addbuf 	replstate send 
rerere putstr strbuf 	bulk online 
release strbuf 	state slave 
release strbuf release 	receives updates 
git sha 	output queue 
merge marker size 	wait 
memset fopen 	bgsave states 
error fopen fclose 	instead server 
error handle 	waiting start 
path fclose 	next background 
error strerror fclose 	saving order 
error strerror 	send 
unlink warn error 	updates need 
strbuf release 	produce rdb 
memchr strbuf strbuf 	file waiting 
merge marker 	rdb file 
size strlen cache 	creation finish 
name pos 	sending 
namelen memcmp stage 	rdb file 
read sha 	slave rdb 
file xstrdup merge 	file transmitted 
free memset 	sending updates 
fopen strbuf init 	slave capabilities 
strbuf attach 	parse 
handle path strbuf 	rdb eof 
release fclose 	streaming format 
stage stage stage 	synchronous read 
stage name 	timeout slave 
isreg isreg 	side list 
name read cache 	related 
error check 	stuff sort 
one conflict list 	operations log 
insert setup 	levels modifier 
rerere read cache 	log without 
error check 	timestamp supervision 
one conflict list 	options 
insert list 	anti warning 
lookup free rerere 	macro enough 
handle file 	elements skiplist 
rerere path read 	append defines 
mmfile rerere 	zip structure 
path read mmfile 	related 
rerere path 	defaults list 
read mmfile rerere 	defaults hyper 
path merge 	log log 
utime rerere path 	defines sets 
warning rerere 	operations codes 
path strerror 	redis 
fopen error strerror 	maxmemory strategies 
fwrite error 	scripting milliseconds 
strerror fclose error 	units shutdown 
strerror free 	flags flags 
free free free 	force save 
hold locked 	shutdown 
index file cache 	even save 
exit write 	points configured 
locked index die 	save shutdown 
rollback file 	command call 
rerere resolution merge 	flags see 
list insert 	call 
handle file copy 	function command 
file rerere 	propagation flags 
path free rerere 	see propagate 
find conflict 	function rdb 
list handle file 	active child 
rerere list 	save 
insert mkdir 	type rdb 
gitdir rerere path 	written disk 
handle file 	rdb written 
rerere path rerere 	slave socket 
one path 	keyspace changes 
update paths write 	notification 
git config 	classes every 
git config git 	associated character 
config mkdir 	configuration purposes 
gitdir git path 	first bind 
cache die 	addr following 
git path cache 	macro 
git rerere 	run code 
config rerere enabled 	inside server 
hold file 	cron specified 
update git path 	period specified 
merge read 	milliseconds actual 
setup rerere 	resolution 
plain rerere handle 	depends server 
cache error 	print stacktrace 
rerere rerere path 	defined way 
unlink error 	data types 
error strerror handle 	redis type 
cache rerere 	able 
path list insert 	hold list 
free rerere 	actual redis 
read cache error 	max obj 
setup rerere 	lru lru 
unmerge cache find 	clock resolution 
conflict match 	lru 
pathspec strlen rerere 	time relative 
forget one 	server lruclock 
path write xsnprintf 	macro used 
dirname stat 	obtain current 
rerere path dirname 	lru clock 
stat rerere 	current 
path unlink 	resolution lower 
rerere path unlink 	frequency refresh 
rerere path 	lru clock 
unlink rerere path 	production servers 
rmdir rerere 	precomputed otherwise 
path time setup 	need 
rerere git 	resort function 
config git config 	call macro 
git config 	used initialize 
opendir git path 	redis allocated 
die errno 	stack note 
readdir dot dotdot 	macro 
rerere last 	taken near 
used rerere created 	structure definition 
list append 	make sure 
closedir unlink item 	update structure 
dirname list 	changed avoid 
clear rollback file 	bugs 
setup rerere 	like bug 
rerere resolution 	introduced exactly 
unlink item unlink 	way improve 
warn git 	quality lru 
path merge rollback 	approximation take 
file rerere 	keys 
enabled fall back 	good candidate 
detection git 	eviction across 
cache automatically update 	free memory 
cleanly resolved 	needed calls 
paths index git 	entries inside 
dir merge 	eviciton 
file collection records 	pool taken 
conflict pathname 	ordered idle 
terminated nul used 	time putting 
keep track 	greater idle 
paths rerere may 	times right 
need work 	order 
left previous invocation 	empty entries 
git rerere 	key pointer 
current conflict 	idle time 
resolution session hash 	key name 
tab path 	redis database 
nul rerere interacts 	representation 
conflicted file 	multiple databases 
contents abstraction reads 	identified integers 
conflicted contents 	database max 
one place via 	configured database 
getline method 	database number 
optionally write normalizing 	field 
conflicted hunks 	structure keyspace 
output subclasses rerere 	timeout keys 
embed structure 	timeout keys 
beginning rerere stuff 	clients waiting 
write conflict 	data blpop 
marker output defined 	blocked 
make sure 	keys received 
write everything round 	push watched 
leaving least 	keys multi 
next round 	exec cas 
giving next round 	eviction pool 
chance terminating 	keys 
yuck subclass rerere 	database average 
reads disk 	ttl stats 
file getline method 	client multi 
implementation require 	exec state 
exact number conflict 	multi commands 
marker letters 	total 
less followed whitespace 	number multi 
including beginning 	commands minreplicas 
version end version 	synchronous replication 
always labeled 	minreplicas timeout 
like hence want 	unixtime structure 
note version 	holds 
common ancestor diff 	blocking operation 
style output 	state client 
always labelled 	fields used 
common often seen 	depend client 
alone also 	btype fields 
valid want read 	blocking 
contents file 	operation timeout 
conflicts normalize conflicts 	unix current 
discarding common 	time timeout 
ancestor version diff 	operation timed 
style reordering 	blocked list 
side side whichever 	keys 
sorts alphabetically 	waiting terminate 
earlier comes one 	blocking operation 
computing conflict 	blpop otherwise 
sha hash one 	key receive 
side conflict 	element brpoplpush 
nul side conflict 	blocked 
nul concatenated 	wait number 
together number conflict 	replicas waiting 
hunks found 	ack replication 
needswork logic 	offset reach 
theory operation behind 	following structure 
conflict normalization 	represents 
may deserve documented 	node server 
somewhere perhaps 	ready keys 
documentation technical rerere 	list accumulate 
txt discard 	keys clients 
force error exit 	blocked blocking 
scan path 	operation 
conflicts handle path 	pop received 
thing number 	data context 
conflict hunks found 	last executed 
subclass rerere 	command execution 
reads core buffer 	every command 
strbuf getline 	script 
method implementation reproduce 	run list 
conflicted merge 	check result 
core needswork handle 	serve data 
conflicts merges 	clients blocked 
merge renormalize 	unblocking note 
grab conflict optionally 	server 
write original 	ready keys 
contents conflict markers 	duplicates dictionary 
look cache 	also called 
entry see conflicting 	ready keys 
conflicting willing 	every structure 
handle conflicting unable 	representing 
handle determination 	redis database 
type cache index 	make sure 
looked next 	remember given 
skipping stages already 	key already 
looked invocation 	added server 
function handle regular 	ready 
files stages 	keys list 
skip entries name 	multiplexing need 
scan index 	take per 
find paths conflicts 	client state 
rerere handle 	clients taken 
ones stages 	linked 
needswork record replay 	list client 
previous resolve 	incremental unique 
deletion modify conflict 	client socket 
inherently risky 	pointer currently 
without knowing modification 	selec ted 
discarded safe 	currently 
side deletion modification 	selec ted 
identical previous 	client setname 
round might want 	buffer use 
handled though 	accumulate client 
merge list meant 	queries recent 
hold outstanding 	peak 
conflicted paths rerere 	querybuf size 
could handle 	num arguments 
abuse list adding 	current command 
types entries 	arguments current 
allow caller 	command last 
show rerere remaining 	command 
conflicted paths 	executed request 
rerere handle added 	protocol type 
conflicted paths 	proto req 
resolved marked storing 	number multi 
rerere resolved 	bulk arguments 
field conflict expected 	left 
stored write 	read length 
merge file calling 	bulk argument 
function needswork 	multi bulk 
may want fix 	request list 
caller rerere 	reply objects 
remaining without abusing 	send 
merge find 	client tot 
conflict identified change 	bytes objects 
preimage previous 	reply list 
contents conflict markers 	amount bytes 
postimage corresponding 	already sent 
contents conflicts 	current 
resolved may apply 	buffer sent 
cleanly contents 	client creation 
stored path conflict 	time time 
time around 	last interaction 
returns successful replay 	used timeout 
recorded resolution 	client 
non zero failure 	flags client 
normalize conflicts 	macros requirepass 
path write thisimage 	non replication 
temporary file 	state slave 
three way merge 	install slave 
note honors 	write 
user customizable low 	handler ack 
level merge 	replication file 
driver settings successful 	descriptor replication 
replay recorded 	file offset 
resolution mark postimage 	replication file 
used help 	size 
update path 	replication preamble 
resolution path indicated 	replication offset 
item may 	master replication 
still conflict recorded 	ack offset 
resolution replay 	slave replication 
optionally update may 	ack 
resolved user 	time slave 
may preimage conflict 	fullresync reply 
result needs 	offset slaves 
recorded resolution postimage 	copying slave 
file recorded 	output buffer 
resolution could attempt 	use 
apply failed 	master run 
replay user resolved 	master configured 
merge records 	slaveconf listening 
paths conflicts immediately 	port slave 
merge failed 	capabilities slave 
conflicted paths might 	capa 
hand resolved 	bitwise multi 
working since 	exec state 
initial run would 	type blocking 
preimages ask 	client blocked 
handle file scan 	blocking state 
assign conflict 	last 
need write anything 	write replication 
yet directory 	offset keys 
exist create mkdir 	watched multi 
gitdir fail 	exec cas 
eexist already one 	channels client 
needswork make 	interested 
sure preimage without 	subscribe patterns 
removing directory 	client interested 
first encounter conflict 	subscribe cached 
ask handle 	peer response 
file write normalized 	buffer zse 
contents preimage 	use 
file main 	specialized version 
entry point called 	skiplists redis 
internally codepaths 	structure defines 
perform mergy operations 	redis operation 
possibly leaving 	instance command 
conflicted index entries 	argument 
working files 	vector database 
recreate original conflict 	propagation target 
stages index 	propagate command 
compute conflict nuke 	pointer currently 
recorded resolution 	used 
conflict update preimage 	additionally propagate 
user resolve 	commands aof 
conflict working run 	replication propagation 
record postimage 	executed command 
remember record resolution 	defines redis 
conflict user 	operations 
done paths may 	api structure 
resolved incorrectly 	easy way 
recover original 	redis init 
conflicted state find 	redis append 
conflicted paths 	redis free 
garbage collection support 	server 
note reentrant 	state aix 
used one time 	defines use 
matter right 	define order 
recorded resolution given 	allow redis 
conflict needswork 	build aix 
rmdir fails wouldn 	need 
already preimage 	undef general 
recorded plain rerere 	main process 
collect stale 	pid absolute 
conflict one one 	config file 
conflict resolution 	path absolute 
rerere recorded preimages 	executable 
abandon user 	file path 
resolve record resolutions 	executable argv 
drop git 	vector copy 
dir merge 	server cron 
needswork shouldn calling 	calls frequency 
reset hard 	hertz 
prepare later call 	command table 
list clear 	command table 
rerere usage dummy 	command renaming 
ptr nbuf 	clock lru 
file label file 	eviction shutdown 
label xpp 	needed 
xecfg ecb minus 	asap incremental 
plus ret 	rehash server 
argc argv prefix 	cron pass 
merge flags 	auth command 
options pathspec path 	pid file 
write full 	path 
read mmfile read 	depending number 
mmfile fflush 	times cron 
memset memset xdi 	function run 
diff free 	always different 
free parse 	every exec 
options git config 	instance 
rerere strcmp 	sentinel networking 
warning parse pathspec 	tcp listening 
rerere forget 	port tcp 
strcmp rerere clear 	listen backlog 
strcmp rerere 	addresses bind 
strcmp setup rerere 	number 
strcmp rerere 	addresses server 
remaining strcmp setup 	bindaddr unix 
rerere diff 	socket path 
two rerere path 	unix socket 
die rerere 	permission tcp 
path usage options 	socket 
list clear 	file descriptors 
rerere enabled fall 	used slots 
back detection 	ipfd unix 
git cache automatically 	socket file 
update cleanly 	descriptor cluster 
resolved paths 	bus 
index git dir 	listening socket 
merge file 	used slots 
collection records conflict 	cfd list 
pathname terminated 	active clients 
nul used keep 	clients close 
track paths 	asynchronously 
rerere may need 	write install 
work left 	handler list 
previous invocation git 	slaves monito 
rerere current 	current client 
conflict resolution session 	used crash 
hash tab 	report 
path nul rerere 	clients currently 
interacts conflicted 	paused time 
file contents abstraction 	undo clients 
reads conflicted 	paused error 
contents one 	buffer anet 
place via getline 	migrate 
method optionally 	cached sockets 
write normalizing conflicted 	next client 
hunks output 	unique incremental 
subclasses rerere embed 	accept external 
structure beginning 	connections rdb 
rerere stuff write 	aof 
conflict marker 	loading information 
output defined make 	loading data 
sure write 	disk fast 
everything round leaving 	pointers often 
least next 	looked command 
round giving next 	fields 
round chance 	used stats 
terminating yuck subclass 	server start 
rerere reads 	time number 
disk file getline 	processed commands 
method implementation 	number connections 
require exact 	received 
number conflict marker 	number expired 
letters less 	keys number 
followed whitespace including 	evicted keys 
beginning version 	maxmemory number 
end version always 	successful lookups 
labeled like 	keys 
hence want note 	number failed 
version common 	lookups keys 
ancestor diff style 	max used 
output always 	memory record 
labelled common often 	time needed 
seen alone 	perform 
also valid want 	latest fork 
read contents 	fork rate 
file conflicts normalize 	sec clients 
conflicts discarding 	rejected maxclients 
common ancestor version 	number full 
diff style 	resyncs 
reordering side 	slaves number 
side whichever sorts 	accepted psync 
alphabetically earlier 	requests number 
comes one computing 	unaccepted psync 
conflict sha 	requests slowlog 
hash one side 	list 
conflict nul 	commands slowlog 
side conflict nul 	current entry 
concatenated together 	slowlog time 
number conflict hunks 	limit logged 
found needswork 	slowlog max 
logic theory operation 	number 
behind conflict 	items logged 
normalization may deserve 	rss sampled 
documented somewhere 	server cron 
perhaps documentation technical 	bytes read 
rerere txt 	network bytes 
discard force error 	written 
exit scan 	network following 
path conflicts 	two used 
handle path thing 	track instantaneous 
number conflict 	metrics like 
hunks found subclass 	number operations 
rerere reads 	per 
core buffer strbuf 	second network 
getline method 	traffic timestamp 
implementation reproduce conflicted 	last sample 
merge core 	count last 
needswork handle conflicts 	sample configuration 
merges merge 	loglevel 
renormalize grab conflict 	redis conf 
optionally write 	client timeout 
original contents conflict 	seconds keepalive 
markers look 	non zero 
cache entry see 	disabled testing 
conflicting conflicting 	purposes 
willing handle 	limit client 
conflicting unable handle 	query buffer 
determination type 	length total 
cache index looked 	number configured 
next skipping 	supervised otherwise 
stages already looked 	see 
invocation function 	supervised running 
handle regular files 	daemon aof 
stages skip 	persistence aof 
entries name scan 	wait rewrite 
index find 	kind fsync 
paths conflicts rerere 	policy 
handle ones 	name aof 
stages needswork record 	file fsync 
replay previous 	rewrite prog 
resolve deletion modify 	rewrite aof 
conflict inherently 	growth aof 
risky without knowing 	file 
modification discarded 	least bytes 
safe side 	aof size 
deletion modification identical 	latest startup 
previous round 	rewrite aof 
might want handled 	current size 
though merge 	rewrite 
list meant hold 	bgsave terminates 
outstanding conflicted 	pid rewriting 
paths rerere could 	process hold 
handle abuse 	changes aof 
list adding types 	rewrite aof 
entries allow 	buffer 
caller show rerere 	written entering 
remaining conflicted 	loop file 
paths rerere handle 	descriptor currently 
added conflicted 	selected aof 
paths resolved marked 	file currently 
storing rerere 	selected 
resolved field conflict 	aof unix 
expected stored 	time postponed 
write merge 	aof flush 
file calling function 	unix time 
needswork may 	last fsync 
want fix caller 	time 
rerere remaining 	used last 
without abusing merge 	aof rewrite 
find conflict 	run current 
identified change preimage 	aof rewrite 
previous contents 	start time 
conflict markers postimage 	err 
corresponding contents 	delayed aof 
conflicts resolved may 	fsync counter 
apply cleanly 	fsync incrementally 
contents stored path 	rewriting err 
conflict time 	valid aof 
around returns successful 	last 
replay recorded 	write status 
resolution non zero 	err stop 
failure normalize 	unexpected aof 
conflicts path 	eof aof 
write thisimage temporary 	pipes used 
file three 	communicate 
way merge note 	parent child 
honors user 	rewrite stop 
customizable low level 	sending accumulated 
merge driver 	diffs child 
settings successful replay 	process aof 
recorded resolution 	diff 
mark postimage used 	accumulator child 
help update 	side rdb 
path resolution path 	persistence changes 
indicated item 	last save 
may still conflict 	used restore 
recorded resolution 	dirty 
replay optionally update 	failed bgsave 
may resolved 	pid rdb 
user may 	saving child 
preimage conflict result 	save points 
needs recorded 	rdb number 
resolution postimage file 	saving 
recorded resolution 	points name 
could attempt apply 	rdb file 
failed replay 	use compression 
user resolved merge 	rdb use 
records paths 	rdb checksum 
conflicts immediately merge 	unix 
failed conflicted 	time last 
paths might hand 	successful save 
resolved working 	unix time 
since initial run 	last attempted 
would preimages 	bgsave time 
ask handle file 	used 
scan assign 	last rdb 
conflict need write 	save run 
anything yet 	current rdb 
directory exist 	save start 
create mkdir gitdir 	time type 
fail eexist 	save 
already one needswork 	active child 
make sure 	err allow 
preimage without removing 	writes bgsave 
directory first 	rdb pipes 
encounter conflict ask 	used state 
handle file 	slave 
write normalized contents 	diskless sync 
preimage file 	propagation commands 
main entry point 	aof replication 
called internally 	additional command 
codepaths perform mergy 	propagate logging 
operations possibly 	path 
leaving conflicted index 	log file 
entries working 	syslog enabled 
files recreate original 	syslog ident 
conflict stages 	syslog facility 
index compute 	replication master 
conflict nuke recorded 	last 
resolution conflict 	selec ted 
update preimage user 	replication output 
resolve conflict 	replication offset 
working run record 	master pings 
postimage remember 	slave every 
record resolution conflict 	seconds 
user done 	replication backlog 
paths may resolved 	syncs backlog 
incorrectly recover 	circular buffer 
original conflicted state 	size backlog 
find conflicted 	actual data 
paths garbage collection 	length 
support note 	backlog circular 
reentrant used one 	buffer current 
time matter 	offset replication 
right recorded resolution 	offset first 
given conflict 	backlog buffer 
needswork rmdir 	time 
fails wouldn already 	without slaves 
preimage recorded 	backlog gets 
plain rerere collect 	released slaves 
stale conflict 	since time 
one one conflict 	valid server 
resolution rerere 	slaves 
recorded preimages abandon 	len min 
user resolve 	number slaves 
record resolutions drop 	write max 
git dir 	lag count 
merge needswork shouldn 	slaves write 
calling reset 	number 
hard prepare later 	slaves lag 
call list 	max lag 
clear rerere.c rerere 	send rdb 
resolved rerere 	slaves sockets 
enabled rerere autoupdate 	directly delay 
item file 	start 
hex sha 	diskless repl 
buf path sha 	bgsave replication 
write buf 	slave auth 
strbuf rerere output 	password master 
wrerror count 	hostname master 
err err str 	port 
size buf 	master timeout 
mem input buf 	seconds master 
marker marker 	idle client 
size want sha 	master slave 
marker size 	cached master 
ctx hunk two 	reused 
buf path 	psync timeout 
sha output hunk 	synchronous calls 
marker size 	replication status 
input len path 	instance slave 
sha output 	size rdb 
mmfile result 	read 
pos len hunk 	master sync 
marker size 	amount rdb 
size type conflict 	read master 
conflict type 	sync offset 
merge conflict type 	fsync last 
path ret 	time 
result index update 	slave master 
item item 	sync socket 
update path conflict 	slave master 
update sha 	sync temp 
path ret flags 	file descriptor 
merge path 	slave 
filename sha ret 	master sync 
item pathspec 	temp file 
conflict merge name 	name unix 
dir name 	time latest 
dir name dir 	read timeout 
cutoff cutoff 	serve 
noresolve cutoff 	stale data 
resolve merge free 	link slave 
git path 	read unix 
rerere hex git 	time link 
path rerere 	master went 
hex stat rerere 	disable 
path xmalloc 	tcp nodelay 
xsnprintf rerere hex 	sync reported 
sha hex 	info used 
fopen git path 	sentinel master 
merge strbuf 	run psync 
getwholeline sha hex 	master 
die die 	psync offset 
rerere hex list 	replication script 
insert strbuf 	cache sha 
release fclose strbuf 	slaves aware 
addf rerere 	first first 
hex write full 	lru 
die strbuf 	eviction max 
release commit 	number elements 
file die fwrite 	synchronous replication 
ferr write 	clients waiting 
strlen ferr puts 	wait command 
memset memset 	send 
rerere putstr ferr 	replconf getack 
write strbuf 	limits max 
getwholeline isspace git 	number simultaneous 
sha init 	clients max 
getline cmarker cmarker 	number memory 
cmarker cmarker 	bytes 
strbuf cmp strbuf 	use policy 
swap rerere 	key eviction 
putconflict rerere putmem 	pricision random 
rerere putconflict 	sampling blocked 
rerere putmem rerere 	clients number 
putconflict git 	clients 
sha update git 	blocked lists 
sha update 	list clients 
strbuf reset 	unblock next 
strbuf reset strbuf 	loop list 
addbuf strbuf 	ready list 
addbuf rerere putstr 	structures 
strbuf release 	blpop sort 
strbuf release strbuf 	parameters qsort 
release git 	available bsd 
sha merge marker 	take state 
size memset 	order pass 
fopen error fopen 	sort 
fclose error 	compare zip 
handle path fclose 	structure config 
error strerror 	see redis 
fclose error strerror 	conf information 
unlink warn 	list parameters 
error strbuf release 	time 
memchr strbuf 	cache unix 
strbuf merge 	time sampled 
marker size strlen 	every cron 
cache name 	cycle like 
pos namelen memcmp 	unixtime milliseconds 
stage read 	resolution 
sha file xstrdup 	pubsub map 
merge free 	channels list 
memset fopen strbuf 	subscribed clients 
init strbuf 	list pubsub 
attach handle path 	patterns events 
strbuf release 	propagate 
fclose stage stage 	via pub 
stage stage 	sub xor 
name isreg isreg 	notify flags 
name read 	cluster cluster 
cache error check 	enabled cluster 
one conflict 	node 
list insert setup 	timeout cluster 
rerere read 	generated config 
cache error 	file name 
check one conflict 	state cluster 
list insert 	cluster replicas 
list lookup free 	migration 
rerere handle 	barrier slave 
file rerere path 	max data 
read mmfile 	age failover 
rerere path read 	put cluster 
mmfile rerere 	least uncovered 
path read mmfile 	slot 
rerere path 	scripting lua 
merge utime rerere 	interpreter use 
path warning 	one clients 
rerere path strerror 	fake client 
fopen error 	query 
strerror fwrite error 	redis lua 
strerror fclose 	client running 
error strerror free 	eval right 
free free 	dictionary sha 
free hold 	lua scripts 
locked index file 	script 
cache exit 	timeout milliseconds 
write locked index 	start time 
die rollback 	script milliseconds 
file rerere resolution 	time write 
merge list 	command called 
insert handle file 	execution 
copy file 	current script 
rerere path free 	random command 
rerere find 	called execution 
conflict list handle 	current script 
file rerere 	single commands 
list insert mkdir 	repl 
gitdir rerere 	already proagated 
path handle file 	multi script 
rerere path 	replication flags 
rerere one path 	redis repl 
update paths 	reached time 
write git 	limit 
config git config 	script execution 
git config 	kill script 
mkdir gitdir git 	replication type 
path cache 	latency monitor 
die git path 	bug reporting 
cache git 	bug 
rerere config rerere 	report header 
enabled hold 	already logged 
file update git 	software watchdog 
path merge 	period system 
read setup rerere 	hardware info 
plain rerere 	total 
handle cache error 	memory system 
rerere rerere 	reported flags 
path unlink error 	representation one 
error strerror 	per flag 
handle cache 	actual flags 
rerere path list 	obtained 
insert free 	sflags field 
rerere read cache 	use function 
error setup 	determine keys 
rerere unmerge cache 	arguments command 
find conflict 	line used 
match pathspec strlen 	redis 
rerere forget 	cluster redirect 
one path write 	keys loaded 
xsnprintf dirname 	background calling 
stat rerere path 	command first 
dirname stat 	argument key 
rerere path unlink 	keys 
rerere path 	last argument 
unlink rerere path 	key step 
unlink rerere 	first last 
path rmdir rerere 	key structure 
path time 	hold list 
setup rerere 	iteration 
git config git 	abstraction iteration 
config git 	direction structure 
config opendir git 	entry iterating 
path die 	list entry 
errno readdir dot 	quicklist structure 
dotdot rerere 	hold 
last used rerere 	iteration abstraction 
created list 	intset iterator 
append closedir unlink 	structure hold 
item dirname 	hash iteration 
list clear rollback 	abstraction note 
file setup 	iteration 
rerere rerere resolution 	hashes involves 
unlink item 	fields values 
unlink warn git 	possible required 
path merge 	store pointers 
rollback file rerere 	iterator avoid 
enabled fall 	unnecessary 
back detection 	memory allocation 
git cache automatically 	fields values 
update cleanly 	declarations functions 
resolved paths index 	prototypes utils 
git dir 	networking networking 
merge file collection 	client 
records conflict 	related operations 
pathname terminated nul 	list data 
used keep 	type multi 
track paths rerere 	exec watch 
may need 	redis implementation 
work left previous 	synchronous 
invocation git 	timeout replication 
rerere current conflict 	persistence functions 
resolution session 	rdb persistence 
hash tab path 	aof persistence 
nul rerere 	sorted sets 
interacts conflicted file 	data 
contents abstraction 	type hold 
reads conflicted 	inclusive exclusive 
contents one place 	range spec 
via getline 	score comparison 
method optionally write 	min max 
normalizing conflicted 	exclusive 
hunks output subclasses 	hold inclusive 
rerere embed 	exclusive range 
structure beginning rerere 	spec lexicographic 
stuff write 	comparison may 
conflict marker output 	shared minstring 
defined make 	maxstring 
sure write everything 	min max 
round leaving 	exclusive core 
least next round 	functions proper 
giving next 	shutdown config 
round chance terminating 	rewrite restart 
yuck subclass 	data 
rerere reads disk 	type hash 
file getline 	data type 
method implementation 	pub sub 
require exact number 	keyspace events 
conflict marker 	notification configuration 
letters less followed 	forward 
whitespace including 	declaration export 
beginning version end 	api keyspace 
version always 	access api 
labeled like hence 	api key 
want note 	arguments commands 
version common ancestor 	cluster 
diff style 	sentinel redis 
output always labelled 	check rdb 
common often 	scripting blocked 
seen alone also 	clients git 
valid want 	sha commands 
read contents file 	prototypes 
conflicts normalize 	debugging stuff 
conflicts discarding 	setproctitle.c environ 
common ancestor version 	arg end 
diff style 	nul reset 
reordering side side 	error environ 
whichever sorts 	tmp 
alphabetically earlier comes 	oldenv environ 
one computing 	error argc 
conflict sha hash 	argv tmp 
one side 	argc argv 
conflict nul side 	envp end 
conflict nul 	nul 
concatenated together number 	tmp error 
conflict hunks 	fmt buf 
found needswork logic 	nul len 
theory operation 	error spt 
behind conflict normalization 	min clearenv 
may deserve 	malloc 
documented somewhere perhaps 	spt clearenv 
documentation technical 	strchr setenv 
rerere txt 	strdup strlen 
discard force error 	strlen strlen 
exit scan 	strdup strdup 
path conflicts handle 	strdup 
path thing 	strdup getprogname 
number conflict hunks 	setprogname spt 
found subclass 	copyenv spt 
rerere reads core 	copyargs start 
buffer strbuf 	vsnprintf end 
getline method implementation 	snprintf 
reproduce conflicted 	memset memset 
merge core needswork 	spt min 
handle conflicts 	spt min 
merges merge renormalize 	spt min 
grab conflict 	memcpy setproctitle 
optionally write original 	linux 
contents conflict 	darwin setproctitle 
markers look cache 	copyright william 
entry see 	ahern copyright 
conflicting conflicting 	salvatore sanfilippo 
willing handle conflicting 	copyright stam 
unable handle 	permission 
determination type cache 	hereby granted 
index looked 	free charge 
next skipping stages 	person obtaining 
already looked 	copy software 
invocation function handle 	associated documentation 
regular files 	files 
stages skip entries 	software deal 
name scan 	software without 
index find paths 	restriction including 
conflicts rerere 	without limitation 
handle ones stages 	rights use 
needswork record 	copy 
replay previous resolve 	modify merge 
deletion modify 	publish distribute 
conflict inherently risky 	sublicense sell 
without knowing 	copies software 
modification discarded 	permit persons 
safe side deletion 	software 
modification identical 	furnished subject 
previous round might 	following conditions 
want handled 	copyright notice 
though merge list 	permission notice 
meant hold 	shall included 
outstanding conflicted paths 	copies 
rerere could 	substantial portions 
handle abuse list 	software software 
adding types 	provided without 
entries allow caller 	warranty kind 
show rerere 	express implied 
remaining conflicted paths 	including 
rerere handle 	limited warranties 
added conflicted paths 	merchantability fitness 
resolved marked 	particular purpose 
storing rerere 	noninfringement shall 
resolved field conflict 	authors copyright 
expected stored 	holders 
write merge file 	liable claim 
calling function 	damages liability 
needswork may want 	whether action 
fix caller 	contract tort 
rerere remaining without 	otherwise arising 
abusing merge 	connection 
find conflict identified 	software use 
change preimage 	dealings software 
previous contents conflict 	size list 
markers postimage 	start end 
corresponding contents conflicts 	malloc setenv 
resolved may 	clearenv 
apply cleanly contents 	setproctitle getprogname 
stored path 	vsnprintf snprintf 
conflict time around 	strlen strchr 
returns successful 	strdup memset 
replay recorded 	memcpy errno 
resolution non zero 	program 
failure normalize 	invocation name 
conflicts path write 	program invocation 
thisimage temporary 	name original 
file three way 	title space 
merge note 	available pointer 
honors user customizable 	original 
low level 	nul character 
merge driver settings 	within spt 
successful replay 	min discussion 
recorded resolution mark 	portability various 
postimage used 	methods see 
help update path 	http 
resolution path 	lists freebsd 
indicated item may 	pipermail freebsd 
still conflict 	stable june 
recorded resolution replay 	html spt 
optionally update 	clearenv spt 
may resolved 	copyenv 
user may preimage 	spt copyargs 
conflict result 	spt init 
needs recorded resolution 	use buffer 
postimage file 	argv passed 
recorded resolution could 	setproctitle linux 
attempt apply 	apple 
failed replay user 	setproctitle SFMT-alti.h 
resolved merge 	mask perm 
records paths conflicts 	perm mask 
immediately merge 	perm perm 
failed conflicted paths 	ctx ctx 
might hand 	size 
resolved working since 	size perm 
initial run 	vec perm 
would preimages ask 	vec vec 
handle file 	perm vec 
scan assign conflict 	vec xor 
need write 	vec 
anything yet 	vec xor 
directory exist create 	vec xor 
mkdir gitdir 	vec xor 
fail eexist already 	vec recursion 
one needswork 	vec recursion 
make sure preimage 	vec 
without removing 	recursion vec 
directory first encounter 	recursion vec 
conflict ask 	recursion vec 
handle file write 	recursion vec 
normalized contents 	perm file 
preimage file main 	derives 
entry point 	sfmt http 
called internally codepaths 	www math 
perform mergy 	sci hiroshima 
operations possibly leaving 	mat sfmt 
conflicted index 	index html 
entries working 	released 
files recreate original 	terms following 
conflict stages 	license copyright 
index compute conflict 	mutsuo saito 
nuke recorded 	makoto matsumoto 
resolution conflict update 	hiroshima university 
preimage user 	rights 
resolve conflict working 	reserved redistribution 
run record 	use source 
postimage remember record 	binary forms 
resolution conflict 	without modification 
user done paths 	permitted provided 
may resolved 	following 
incorrectly recover original 	conditions met 
conflicted state 	redistributions source 
find conflicted paths 	code must 
garbage collection 	retain copyright 
support note reentrant 	notice list 
used one 	conditions 
time matter 	following disclaimer 
right recorded resolution 	redistributions binary 
given conflict 	form must 
needswork rmdir fails 	reproduce copyright 
wouldn already 	notice list 
preimage recorded plain 	conditions 
rerere collect 	following disclaimer 
stale conflict one 	documentation materials 
one conflict 	provided distribution 
resolution rerere recorded 	neither name 
preimages abandon 	hiroshima university 
user resolve record 	names 
resolutions drop 	contributors may 
git dir merge 	used endorse 
needswork shouldn 	promote products 
calling reset hard 	derived software 
prepare later 	without specific 
call list clear 	prior 
rerere usage 	written permission 
dummy ptr 	software provided 
nbuf file label 	copyright holders 
file label 	contributors express 
xpp xecfg ecb 	implied warranties 
minus plus 	including 
ret argc argv 	limited implied 
prefix merge 	warranties merchantability 
flags options pathspec 	fitness particular 
path write 	purpose disclaimed 
full read mmfile 	shall copyright 
read mmfile 	owner 
fflush memset memset 	contributors liable 
xdi diff 	direct indirect 
free free parse 	incidental special 
options git 	exemplary consequential 
config rerere strcmp 	damages including 
warning parse 	limited 
pathspec rerere forget 	procurement substitute 
strcmp rerere 	goods services 
clear strcmp 	loss use 
rerere strcmp setup 	data profits 
rerere strcmp 	business interruption 
rerere remaining strcmp 	however 
setup rerere 	caused theory 
diff two rerere 	liability whether 
path die 	contract strict 
rerere path usage 	liability tort 
options list 	including negligence 
clear rerere enabled 	otherwise 
fall back 	arising way 
detection git cache 	use software 
automatically update 	even advised 
cleanly resolved paths 	possibility damage 
index git 	file sfmt 
dir merge file 	alti 
collection records 	brief simd 
conflict pathname terminated 	oriented fast 
nul used 	mersenne twister 
keep track 	sfmt pseudorandom 
paths rerere may 	number generator 
need work 	author 
left previous invocation 	mutsuo saito 
git rerere 	hiroshima university 
current conflict resolution 	author makoto 
session hash 	matsumoto hiroshima 
tab path nul 	university copyright 
rerere interacts 	mutsuo 
conflicted file contents 	saito makoto 
abstraction reads 	matsumoto hiroshima 
conflicted contents one 	university rights 
place via 	reserved bsd 
getline method optionally 	license applied 
write normalizing 	software 
conflicted hunks output 	see license 
subclasses rerere 	txt function 
embed structure 	represents recursion 
beginning rerere stuff 	formula alti 
write conflict 	vec big 
marker output defined 	endian 
make sure 	param bit 
write everything round 	part interal 
leaving least 	state param 
next round giving 	bit part 
next round 	interal state 
chance terminating yuck 	param 
subclass rerere 	bit part 
reads disk file 	interal state 
getline method 	param bit 
implementation require exact 	part interal 
number conflict 	state output 
marker letters less 	function 
followed whitespace 	fills state 
including beginning version 	pseudorandom integers 
end version 	function fills 
always labeled 	user specified 
like hence want 	pseudorandom integers 
note version 	param 
common ancestor diff 	bit filled 
style output 	pseudorandom numbers 
always labelled common 	param size 
often seen 	number bit 
alone also valid 	pesudorandom numbers 
want read 	generated 
contents file conflicts 	main loop 
normalize conflicts 	function swaps 
discarding common ancestor 	high low 
version diff 	bit bit 
style reordering side 	integers user 
side whichever 	specified 
sorts alphabetically earlier 	param bit 
comes one 	swaped param 
computing conflict sha 	size size 
hash one 	bit SFMT-params.h 
side conflict 	file derives 
nul side conflict 	sfmt 
nul concatenated 	http www 
together number conflict 	math sci 
hunks found 	hiroshima mat 
needswork logic theory 	sfmt index 
operation behind 	html released 
conflict normalization may 	terms 
deserve documented 	following license 
somewhere perhaps documentation 	copyright mutsuo 
technical rerere 	saito makoto 
txt discard force 	matsumoto hiroshima 
error exit 	university rights 
scan path conflicts 	reserved 
handle path 	redistribution use 
thing number conflict 	source binary 
hunks found 	forms without 
subclass rerere reads 	modification permitted 
core buffer 	provided following 
strbuf getline 	conditions 
method implementation reproduce 	met redistributions 
conflicted merge 	source code 
core needswork handle 	must retain 
conflicts merges 	copyright notice 
merge renormalize grab 	list 
conflict optionally 	conditions following 
write original contents 	disclaimer redistributions 
conflict markers 	binary form 
look cache entry 	must reproduce 
see conflicting 	copyright notice 
conflicting willing handle 	list 
conflicting unable 	conditions following 
handle determination type 	disclaimer documentation 
cache index 	materials provided 
looked next skipping 	distribution neither 
stages already 	name hiroshima 
looked invocation 	university 
function handle regular 	names contributors 
files stages 	may used 
skip entries name 	endorse promote 
scan index 	products derived 
find paths conflicts 	software without 
rerere handle 	specific 
ones stages needswork 	prior written 
record replay 	permission software 
previous resolve deletion 	provided copyright 
modify conflict 	holders contributors 
inherently risky without 	express implied 
knowing modification 	warranties 
discarded safe side 	including limited 
deletion modification 	implied warranties 
identical previous round 	merchantability fitness 
might want 	particular purpose 
handled though merge 	disclaimed shall 
list meant 	copyright 
hold outstanding 	owner contributors 
conflicted paths rerere 	liable direct 
could handle 	indirect incidental 
abuse list adding 	special exemplary 
types entries 	consequential damages 
allow caller show 	including 
rerere remaining 	limited procurement 
conflicted paths rerere 	substitute goods 
handle added 	services loss 
conflicted paths resolved 	use data 
marked storing 	profits business 
rerere resolved field 	interruption 
conflict expected 	however caused 
stored write merge 	theory liability 
file calling 	whether contract 
function needswork may 	strict liability 
want fix 	tort including 
caller rerere remaining 	negligence 
without abusing 	otherwise arising 
merge find 	way use 
conflict identified change 	software even 
preimage previous 	advised possibility 
contents conflict markers 	damage basic 
postimage corresponding 	definitions 
contents conflicts resolved 	mersenne exponent 
may apply 	period sequence 
cleanly contents stored 	multiple mexp 
path conflict 	define mexp 
time around returns 	sfmt generator 
successful replay 	state 
recorded resolution non 	bit integers 
zero failure 	size size 
normalize conflicts path 	state regarded 
write thisimage 	bit integers 
temporary file three 	size state 
way merge 	regarded 
note honors user 	bit integers 
customizable low 	parameters sfmt 
level merge 	following definitions 
driver settings successful 	xxxx file 
replay recorded 	pick position 
resolution mark postimage 	define 
used help 	pos parameter 
update path resolution 	shift left 
path indicated 	four bit 
item may still 	registers define 
conflict recorded 	parameter shift 
resolution replay optionally 	left 
update may 	one bit 
resolved user may 	bit integer 
preimage conflict 	shifted bits 
result needs recorded 	define parameter 
resolution postimage 	shift right 
file recorded resolution 	four 
could attempt 	bit registers 
apply failed 	define parameter 
replay user resolved 	shift right 
merge records 	one bit 
paths conflicts immediately 	bit integer 
merge failed 	shifted 
conflicted paths might 	bits define 
hand resolved 	bitmask used 
working since initial 	recursion parameters 
run would 	introduced symmetry 
preimages ask handle 	simd define 
file scan 	msk 
assign conflict need 	xdfffffef define 
write anything 	msk xddfecb 
yet directory exist 	define msk 
create mkdir 	xbffaffff define 
gitdir fail eexist 	msk xbffffff 
already one 	definitions 
needswork make sure 	part bit 
preimage without 	period certification 
removing directory 	vector define 
first encounter conflict 	parity define 
ask handle 	parity define 
file write normalized 	parity 
contents preimage 	define parity 
file main entry 	sfmt SFMT-params11213.h 
point called 	file derives 
internally codepaths perform 	sfmt http 
mergy operations 	www math 
possibly leaving conflicted 	sci 
index entries 	hiroshima mat 
working files recreate 	sfmt index 
original conflict 	html released 
stages index compute 	terms following 
conflict nuke 	license copyright 
recorded resolution conflict 	mutsuo 
update preimage 	saito makoto 
user resolve conflict 	matsumoto hiroshima 
working run 	university rights 
record postimage 	reserved redistribution 
remember record resolution 	use source 
conflict user 	binary 
done paths may 	forms without 
resolved incorrectly 	modification permitted 
recover original conflicted 	provided following 
state find 	conditions met 
conflicted paths garbage 	redistributions source 
collection support 	code 
note reentrant used 	must retain 
one time 	copyright notice 
matter right recorded 	list conditions 
resolution given 	following disclaimer 
conflict needswork rmdir 	redistributions binary 
fails wouldn 	form 
already preimage recorded 	must reproduce 
plain rerere 	copyright notice 
collect stale conflict 	list conditions 
one one 	following disclaimer 
conflict resolution 	documentation materials 
rerere recorded preimages 	provided 
abandon user 	distribution neither 
resolve record resolutions 	name hiroshima 
drop git 	university names 
dir merge needswork 	contributors may 
shouldn calling 	used endorse 
reset hard prepare 	promote 
later call 	products derived 
list clear rerere.h 	software without 
rerere resolved 	specific prior 
hex list rerere 	written permission 
file pathspec 	software provided 
list list list 	copyright 
marks paths 	holders contributors 
hand resolved added 	express implied 
index field 	warranties including 
paths calling rerere 	limited implied 
remaining given 	warranties merchantability 
conflict name 	fitness 
file used replaying 	particular purpose 
recorded resolution 	disclaimed shall 
preimage postimage path 	copyright owner 
filesystem entity 	contributors liable 
file specified path 	direct indirect 
directory houses 	incidental 
files reset.c git 	special exemplary 
reset usage 	consequential damages 
reset type names 	including limited 
sha reset 	procurement substitute 
type quiet desc 	goods services 
opts head 	loss 
sha commit hex 	use data 
body msg 	profits business 
eol len opt 	interruption however 
data intent 	caused theory 
one missing 	liability whether 
pathspec sha intent 	contract 
opt action 	strict liability 
rev rla reset 	tort including 
type pathspec 	negligence otherwise 
argv prefix patch 	arising way 
mode rev 	use software 
ret rev unused 	even 
rev sha 	advised possibility 
update status msg 	damage parameters 
sha orig 	altivec osx 
sha old orig 	linux osx 
argc argv 	sfmt SFMT-params1279.h 
prefix quiet unborn 	file 
rev oid 	derives sfmt 
pathspec intent options 	http www 
commit flags 	math sci 
err access git 	hiroshima mat 
path merge 	sfmt index 
head memset 	html 
read cache unmerged 	released terms 
sha error 	following license 
fill descriptor error 	copyright mutsuo 
fill descriptor 	saito makoto 
error sha hex 	matsumoto hiroshima 
unpack trees 	university 
parse indirect prime 	rights reserved 
cache find 	redistribution use 
unique abbrev logmsg 	source binary 
reencode log 	forms without 
output encoding strstr 	modification permitted 
strchr strlen 	provided 
unuse commit buffer 	following conditions 
sha file 	met redistributions 
cache make cache 	source code 
entry die 	must retain 
name intent entry 	copyright notice 
cache entry 	list 
memset copy 	conditions following 
pathspec diff cache 	disclaimer redistributions 
diffcore std 	binary form 
diff flush free 	must reproduce 
pathspec getenv 	copyright notice 
strbuf reset strbuf 	list 
addf strbuf 	conditions following 
addf strbuf addf 	disclaimer documentation 
merge unmerged 	materials provided 
cache die strcmp 	distribution neither 
strcmp sha 	name hiroshima 
committish sha treeish 	university 
verify non 	names contributors 
filename verify filename 	may used 
read cache 	endorse promote 
die parse pathspec 	products derived 
sha sha 	software without 
reflog message update 	specific 
reflog message 	prior written 
update strbuf 	permission software 
release git config 	provided copyright 
parse options 	holders contributors 
parse args strcmp 	express implied 
sha hashcpy 	warranties 
sha committish die 	including limited 
lookup commit 	implied warranties 
reference die oidcpy 	merchantability fitness 
sha treeish 	particular purpose 
die parse indirect 	disclaimed shall 
die oidcpy 	copyright 
die run interactive 	owner contributors 
warning die 	liable direct 
git work setup 	indirect incidental 
work bare 	special exemplary 
repository die die 	consequential damages 
die unmerged 	including 
cache xcalloc 	limited procurement 
hold locked index 	substitute goods 
read git 	services loss 
work refresh index 	use data 
reset index 	profits business 
reset index die 	interruption 
write locked 	however caused 
index die reset 	theory liability 
refs print 	whether contract 
head line lookup 	strict liability 
commit reference 	tort including 
branch state git 	negligence 
reset builtin 	otherwise arising 
command copyright carlos 	way use 
rica git 	software even 
reset copyright linus 	advised possibility 
torvalds junio 	damage parameters 
hamano fallthrough possible 	altivec 
arguments git 	osx linux 
reset opts 	osx sfmt 
rev git reset 	SFMT-params132049.h file 
opts paths 	derives sfmt 
git reset opts 	http www 
paths git 	math 
reset opts paths 	sci hiroshima 
git reset 	mat sfmt 
opts paths point 	index html 
argv points 	released terms 
immediately opts reset 	following license 
head possibly 	copyright 
paths otherwise argv 	mutsuo saito 
could either 	makoto matsumoto 
rev paths unambiguous 	hiroshima university 
single argument 	rights reserved 
argv looks like 	redistribution use 
commit filename 	source 
otherwise treat filename 	binary forms 
reset unborn 	without modification 
branch treat 	permitted provided 
reset empty git 	following conditions 
reset paths 	met redistributions 
used load chosen 	source 
paths index 	code must 
without affecting working 	retain copyright 
head soft 	notice list 
reset touch index 	conditions following 
file working 	disclaimer redistributions 
requires good order 	binary 
resets reset 	form must 
index file switching 	reproduce copyright 
resets without 	notice list 
paths update head 	conditions following 
head switched 	disclaimer documentation 
saving previous head 	materials 
orig head 	provided distribution 
resolve-undo.c istate lost 	neither name 
resolve undo 	hiroshima university 
stage resolve 	names contributors 
undo item data 	may used 
size resolve 	endorse 
undo len endptr 	promote products 
lost istate 	derived software 
resolve undo istate 	without specific 
pos item 	prior written 
matched name nce 	permission software 
istate istate 	provided 
pathspec stage xcalloc 	copyright holders 
list insert 	contributors express 
xcalloc hashcpy strbuf 	implied warranties 
addstr strbuf 	including limited 
addch strbuf addf 	implied warranties 
strbuf xcalloc 	merchantability 
strlen list insert 	fitness particular 
xcalloc strtoul 	purpose disclaimed 
hashcpy list 	shall copyright 
clear error list 	owner contributors 
clear free 	liable direct 
stage strcmp list 	indirect 
lookup xstrdup 	incidental special 
index entry make 	exemplary consequential 
cache entry 	damages including 
index entry error 	limited procurement 
free free 	substitute goods 
unmerge index entry 	services 
unmerge index 	loss use 
entry path match 	data profits 
unmerge index 	business interruption 
entry error run 	however caused 
memory list 	theory liability 
already unmerged last 	whether 
entry processed 	contract strict 
resolve-undo.h mode sha 	liability tort 
index state 	including negligence 
cache entry 	otherwise arising 
strbuf list index 	way use 
state index 	software 
state index state 	even advised 
pathspec index 	possibility damage 
state rev-list.c rev 	parameters altivec 
list usage 	osx linux 
commit data commit 	osx sfmt 
data info 	SFMT-params19937.h 
revs parents children 	file derives 
buf ctx 	sfmt http 
commit data obj 	www math 
name data 	sci hiroshima 
info obj name 	mat sfmt 
data info 	index 
commit val val 	html released 
info reaches 	terms following 
cnt flags hex 	license copyright 
tried revs 	mutsuo saito 
show fast 	makoto matsumoto 
argc argv prefix 	hiroshima 
revs info 	university rights 
bisect list bisect 	reserved redistribution 
show vars 	use source 
bisect find use 	binary forms 
bitmap index 	without modification 
arg commit count 	permitted 
finish commit 	provided following 
graph show commit 	conditions met 
finish commit 	redistributions source 
fputs fputs revision 	code must 
mark fputs 	retain copyright 
find unique abbrev 	notice 
fputs oid 	list conditions 
hex oid hex 	following disclaimer 
lookup decoration 	redistributions binary 
oid hex show 	form must 
decorations putchar 	reproduce copyright 
putchar cached 	notice 
commit buffer log 	list conditions 
output encoding 	following disclaimer 
pretty print commit 	documentation materials 
graph show 	provided distribution 
oneline graph show 	neither name 
commit msg 	hiroshima 
graph show padding 	university names 
putchar graph 	contributors may 
show remainder putchar 	used endorse 
putchar fwrite 	promote products 
putchar strbuf release 	derived software 
graph show 	without 
remainder putchar maybe 	specific prior 
flush die 	written permission 
finish commit free 	software provided 
commit list 	copyright holders 
free commit buffer 	contributors express 
file die 	implied 
oid hex 	warranties including 
parse finish show 	limited implied 
name oid 	warranties merchantability 
hex filter skipped 	fitness particular 
sha hex 	purpose disclaimed 
traverse commit list 	shall 
print str 	copyright owner 
print print print 	contributors liable 
print print 	direct indirect 
estimate bisect steps 	incidental special 
git config 	exemplary consequential 
init revisions setup 	damages 
revisions memset 	including limited 
diff opt tst 	procurement substitute 
strcmp strcmp 	goods services 
strcmp strcmp strcmp 	loss use 
strcmp strcmp 	data profits 
test bitmap 	business 
walk usage usage 	interruption however 
die prepare 	caused theory 
bitmap walk count 	liability whether 
bitmap commit 	contract strict 
list prepare bitmap 	liability tort 
walk traverse 	including 
bitmap commit list 	negligence otherwise 
prepare revision 	arising way 
walk die mark 	use software 
edges uninteresting 	even advised 
find bisection show 	possibility damage 
bisect vars 	parameters 
traverse commit list 	altivec osx 
newline commit 	linux osx 
message usually newline 	sfmt SFMT-params216091.h 
produces blank 	file derives 
padding line entries 	sfmt 
need graph 	http www 
padding line 	math sci 
however commit message 	hiroshima mat 
may end 	sfmt index 
newline newline simply 	html released 
ends last 	terms 
line commit message 	following license 
need graph 	copyright mutsuo 
output always happens 	saito makoto 
cmit fmt 	matsumoto hiroshima 
oneline happens cmit 	university rights 
fmt userformat 	reserved 
format doesn explicitly 	redistribution use 
end newline 	source binary 
message buffer empty 	forms without 
show rest 	modification permitted 
graph output commit 	provided following 
revs commits 	conditions 
reach reaches commits 	met redistributions 
among commits 	source code 
good reaches 	must retain 
commits left bisected 	copyright notice 
hand bad 	list conditions 
bisect reaches bisect 	following 
size commits 	disclaimer redistributions 
test already know 	binary form 
one bad 	must reproduce 
one command line 	copyright notice 
pretty header 	list conditions 
specified rev-parse.c filter 	following 
def show 	disclaimer documentation 
type symbolic abbrev 	materials provided 
abbrev abbrev 	distribution neither 
strict output stuck 	name hiroshima 
excludes arg 	university names 
rev args str 	contributors 
len arg 	may used 
type arg type 	endorse promote 
sha name 	products derived 
discard full 	software without 
arg sha refname 	specific prior 
oid flag 	written 
data refname oid 	permission software 
flag data 	provided copyright 
sha data flag 	holders contributors 
datestr buffer 	express implied 
arg output prefix 	warranties including 
prefix arg 	limited 
dotdot sha end 	implied warranties 
next symmetric 	merchantability fitness 
head exclude commit 	particular purpose 
arg dotdot 	disclaimed shall 
sha commit parents 	copyright owner 
parents arg 	contributors 
unset parsed argc 	liable direct 
argv prefix 	indirect incidental 
stop non 	special exemplary 
option parseopt usage 	consequential damages 
parseopt opts 	including limited 
flag chars parsed 	procurement 
usage opts 	substitute goods 
usz help argc 	services loss 
argv buf 	use data 
quiet builtin rev 	profits business 
parse usage 	interruption however 
argc argv prefix 	caused 
type dashdash 	theory liability 
output prefix sha 	whether contract 
flags name 	strict liability 
unused arg work 	tort including 
pfx work 	negligence otherwise 
gitdir cwd len 	arising 
pfx gitdir 	way use 
sha isdigit strlen 	software even 
strcmp strncmp 	advised possibility 
putchar fputs 	damage parameters 
putchar putchar putchar 	altivec osx 
puts putchar 	linux 
show dwim strlen 	osx sfmt 
shorten unambiguous 	SFMT-params2281.h file 
show type error 	derives sfmt 
free show 	http www 
type show type 	math sci 
find unique 	hiroshima 
abbrev show type 	mat sfmt 
sha hex 	index html 
rev argument show 	released terms 
sha show 	following license 
rev excluded show 	copyright mutsuo 
rev show 	saito 
rev show rev 	makoto matsumoto 
snprintf approxidate 	hiroshima university 
show show show 	rights reserved 
prefix filename 	redistribution use 
strlen show 	source binary 
strstr sha committish 	forms 
sha committish 	without modification 
show rev show 	permitted provided 
rev lookup 	following conditions 
commit reference lookup 	met redistributions 
commit reference 	source code 
merge bases pop 	must 
commit show 	retain copyright 
rev strstr strstr 	notice list 
sha committish 	conditions following 
show rev lookup 	disclaimer redistributions 
commit reference 	binary form 
show rev strbuf 	must 
addf strbuf 	reproduce copyright 
addf strbuf addf 	notice list 
strbuf addch 	conditions following 
strbuf addch quote 	disclaimer documentation 
buf isspace 	materials provided 
strbuf addstr 	distribution 
parse options strcmp 	neither name 
usage options 	hiroshima university 
strbuf getline die 	names contributors 
alloc grow 	may used 
strcmp die strbuf 	endorse promote 
detach strbuf 	products 
getline alloc grow 	derived software 
memset strchr 	without specific 
xstrdup skipspaces xstrdup 	prior written 
skipspaces strpbrk 	permission software 
xmemdupz xmemdupz xmemdupz 	provided copyright 
strbuf release 	holders 
alloc grow memset 	contributors express 
parse options 	implied warranties 
strbuf addf quote 	including limited 
argv puts 	implied warranties 
quote argv strbuf 	merchantability fitness 
release exit 	particular 
die strcmp 	purpose disclaimed 
cmd parseopt strcmp 	shall copyright 
cmd quote 	owner contributors 
strcmp usage strcmp 	liable direct 
setup git 	indirect incidental 
directory git config 	special 
strcmp die 	exemplary consequential 
puts git path 	damages including 
show file 	limited procurement 
verify filename strcmp 	substitute goods 
die show 	services loss 
show starts show 	use 
strcmp show 	data profits 
file strcmp die 	business interruption 
strcmp die 	however caused 
strcmp strcmp strcmp 	theory liability 
strcmp strcmp 	whether contract 
strcmp strcmp 	strict 
strcmp starts strtoul 	liability tort 
strcmp strcmp 	including negligence 
strcmp strcmp starts 	otherwise arising 
strcmp strcmp 	way use 
die strcmp starts 	software even 
abbrev strcmp 	advised 
starts glob clear 	possibility damage 
exclusion strcmp 	parameters altivec 
branch clear exclusion 	osx linux 
starts glob 	osx sfmt 
clear exclusion strcmp 	SFMT-params4253.h file 
tag clear 	derives 
exclusion starts glob 	sfmt http 
clear exclusion 	www math 
starts glob clear 	sci hiroshima 
exclusion strcmp 	mat sfmt 
remote clear exclusion 	index html 
starts exclusion 	released 
strcmp strcmp 	terms following 
git work puts 	license copyright 
strcmp puts 	mutsuo saito 
putchar strcmp inside 	makoto matsumoto 
work git 	hiroshima university 
work strchr putchar 	rights 
strcmp getenv 	reserved redistribution 
puts puts xgetcwd 	use source 
strlen free 	binary forms 
strcmp puts prefix 	without modification 
filename strlen 	permitted provided 
git common dir 	following 
strcmp die 	conditions met 
resolve gitdir die 	redistributions source 
puts strcmp 	code must 
inside git dir 	retain copyright 
strcmp inside 	notice list 
work strcmp bare 	conditions 
repository strcmp 	following disclaimer 
read cache 	redistributions binary 
die puts git 	form must 
path sha 	reproduce copyright 
hex starts show 	notice list 
datestring starts 	conditions 
show datestring starts 	following disclaimer 
show datestring 	documentation materials 
starts show datestring 	provided distribution 
show flag 	neither name 
die single rev 	hiroshima university 
difference parent 	names 
shorthands sha context 	contributors may 
show rev 	used endorse 
die single rev 	promote products 
die show 	derived software 
file verify filename 	without specific 
show rev 	prior 
show die single 	written permission 
rev show 	software provided 
rev parse 	copyright holders 
copyright linus torvalds 	contributors express 
arguments relevant 	implied warranties 
revision arguments others 	including 
output format 	limited implied 
details sorts accept 	warranties merchantability 
digit like 	fitness particular 
traditional head output 	purpose disclaimed 
argument either 	shall copyright 
normal like show 	owner 
negation prefix 	contributors liable 
according type output 	direct indirect 
revision filter 	incidental special 
allows found could 	exemplary consequential 
emit name 	damages including 
symbolic full users 	limited 
interested finding 	procurement substitute 
refs spelled 	goods services 
full would need 	loss use 
filter non 	data profits 
refs happy ambiguous 	business interruption 
output flag 	however 
filter allows date 	caused theory 
handling requires 	liability whether 
flags revs range 	contract strict 
pathspec parent 	liability tort 
directory usage first 	including negligence 
line parse 	otherwise 
arghint help name 	arising way 
option option 	use software 
flags put opt 	even advised 
end pass 	possibility damage 
show anything files 	parameters altivec 
flag argument 	osx 
revert.c revert usage 	linux osx 
cherry pick 	sfmt SFMT-params44497.h 
usage opts 	file derives 
opts opt arg 	sfmt http 
unset opts 	www math 
ptr opts opt 	sci 
opt argc 	hiroshima mat 
argv opts usage 	sfmt index 
str cmd 	html released 
options extra operation 	terms following 
opt argc 	license copyright 
argv prefix opts 	mutsuo 
res argc 	saito makoto 
argv prefix opts 	matsumoto hiroshima 
res alloc 	university rights 
grow xstrdup start 	reserved redistribution 
arg arg 	use source 
end die revert 	binary 
cherry pick 	forms without 
usage action name 	modification permitted 
parse options 	provided following 
concat size 	conditions met 
die parse options 	redistributions source 
verify opt 	code 
compatible verify opt 	must retain 
compatible xmalloc 	copyright notice 
init revisions usage 	list conditions 
options strcmp 	following disclaimer 
memset setup revisions 	redistributions binary 
usage options 	form 
memset isatty git 	must reproduce 
config parse 	copyright notice 
args sequencer pick 	list conditions 
revisions die 	following disclaimer 
memset git config 	documentation materials 
parse args 	provided 
sequencer pick revisions 	distribution neither 
die builtins 	name hiroshima 
revert cherry pick 	university names 
copyright johannes 	contributors may 
schindelin git 	used endorse 
revert copyright linus 	promote 
torvalds copyright 	products derived 
junio hamano implies 	software without 
allow empty 	specific prior 
subcommand check incompatible 	written permission 
command line 	software provided 
arguments revision.c show 	copyright 
early output 	holders contributors 
term bad term 	express implied 
good obj 	warranties including 
name blob desc 	limited implied 
entry obj 	warranties merchantability 
obj commit commit 	fitness 
revs obj 	particular purpose 
name mode path 	disclaimed shall 
buf len 	copyright owner 
revs obj 	contributors liable 
name mode revs 	direct indirect 
obj name 	incidental 
revs sha obj 	special exemplary 
revs name 	consequential damages 
sha flags revs 	including limited 
name sha 	procurement substitute 
flags revs entry 	goods services 
name path 	loss 
mode flags tag 	use data 
commit orig 	profits business 
interesting cache list 	interruption however 
commit commit 	caused theory 
commit revs orig 	liability whether 
list relevant 	contract 
commit difference options 	strict liability 
addremove mode 	tort including 
sha sha valid 	negligence otherwise 
fullpath dirty 	arising way 
submodule diff 	use software 
options old mode 	even 
mode old 	advised possibility 
sha sha old 	damage parameters 
sha valid 	altivec osx 
sha valid fullpath 	linux osx 
old dirty 	sfmt SFMT-params607.h 
submodule dirty submodule 	file 
revs parent 	derives sfmt 
commit revs commit 	http www 
retval nparents 	math sci 
treesame revs commit 	hiroshima mat 
revs commit 	sfmt index 
nth parent old 	html 
revs commit 	released terms 
relevant parents relevant 	following license 
change irrelevant 	copyright mutsuo 
change revs revs 	saito makoto 
commit parent 	matsumoto hiroshima 
irrelevant change 	university 
relevant parents nth 	rights reserved 
parent head 	redistribution use 
cached cache entry 	source binary 
revs commit 	forms without 
list cache ptr 	modification permitted 
parent left 	provided 
flag cached list 	following conditions 
revs right 	met redistributions 
count left first 	source code 
ids cherry 	must retain 
flag commit flags 	copyright notice 
commit flags 	list 
commit flags commit 	conditions following 
ent src 	disclaimer redistributions 
date slop interesting 	binary form 
cache bottom 	must reproduce 
list rlist made 	copyright notice 
progress parents 	list 
list elem 	conditions following 
bottom list revs 	disclaimer documentation 
commit revs 	materials provided 
slop date list 	distribution neither 
newlist bottom 	name hiroshima 
interesting cache commit 	university 
obj show 	names contributors 
revs item name 	may used 
whence flags 	endorse promote 
info revs commit 	products derived 
list whence 	software without 
flags flags warned 	specific 
bad reflog 	prior written 
revs name errormsg 	permission software 
excludes path 	provided copyright 
item path oid 	holders contributors 
flag data 	express implied 
revs flags excludes 	warranties 
excludes exclude 	including limited 
submodule revs 	implied warranties 
flags sha data 	merchantability fitness 
osha nsha 	particular purpose 
email timestamp message 	disclaimed shall 
data path 	copyright 
oid flag data 	owner contributors 
revs flags 	liable direct 
revs path baselen 	indirect incidental 
sub revs 	special exemplary 
flags blob path 	consequential damages 
revs arg 	including 
flags sha commit 	limited procurement 
parents arg 	substitute goods 
revs prefix revs 	services loss 
commit list 	use data 
flags revs bases 	profits business 
head sha 	interruption 
prune prune 	however caused 
num arg revs 	theory liability 
flags revarg 	whether contract 
opt dotdot sha 	strict liability 
local flags 	tort including 
arg cant filename 	negligence 
sha flags 	otherwise arising 
sha next symmetric 	way use 
flags exclude 	software even 
head flags obj 	advised possibility 
obj exclude 	damage parameters 
alloc path prune 	altivec 
revs prune 	osx linux 
revs prune seen 	osx sfmt 
dashdash save 	SFMT-params86243.h file 
warning len grep 	derives sfmt 
header grep 	http www 
revs pattern revs 	math 
argc argv 	sci hiroshima 
unkc unkv 	mat sfmt 
arg optarg argcount 	index html 
count buf 	released terms 
opts revs ctx 	following license 
options usagestr 	copyright 
submodule data term 	mutsuo saito 
bisect refs 	makoto matsumoto 
status submodule data 	hiroshima university 
submodule data 	rights reserved 
submodule revs argc 	redistribution use 
argv flags 	source 
arg optarg argcount 	binary forms 
def sha 	without modification 
flags refname argc 	permitted provided 
argv revs 	following conditions 
opt flags left 	met redistributions 
seen dashdash 	source 
read stdin revarg 	code must 
opt prune 	retain copyright 
data submodule 	notice list 
arg arg opts 	conditions following 
sha revs 	disclaimer 
parent child revs 	redistributions binary 
commit surviving 	form must 
parents parent simplified 	reproduce copyright 
revs commit 	notice list 
revs commit marked 	conditions following 
orig cnt 	disclaimer 
cnt revs commit 	documentation materials 
marked parent 	provided distribution 
revs commit marked 	neither name 
revs commit 	hiroshima university 
nth parent removed 	names contributors 
parent revs 	may 
commit tail parent 	used endorse 
pst cnt 	promote products 
marked revs list 	derived software 
next yet 	without specific 
tail commit 	prior written 
revs commit revs 	permission 
old pending 	software provided 
next commit parent 	copyright holders 
buf mailmap 	contributors express 
person endp len 	implied warranties 
namelen maillen 	including limited 
name mail ident 	implied 
namemail commit 	warranties merchantability 
opt retval encoding 	fitness particular 
message buf 	purpose disclaimed 
revs revs commit 	shall copyright 
revs revs 	owner contributors 
commit parents revs 	liable 
commit revs 	direct indirect 
commit entry data 	incidental special 
unused revs 	exemplary consequential 
objects revs 	damages including 
revs reversed revs 	limited procurement 
commit revs 	substitute 
commit mark oid 	goods services 
hex fputc 	loss use 
fputc file parse 	data profits 
die oid 	business interruption 
hex init desc 	however caused 
entry type 	theory 
mark uninteresting lookup 	liability whether 
mark blob 	contract strict 
uninteresting lookup blob 	liability tort 
free buffer 	including negligence 
mark contents uninteresting 	otherwise arising 
commit list 	way 
insert pop commit 	use software 
file commit 	even advised 
list insert interpret 	possibility damage 
branch name 	parameters altivec 
strbuf addstr 	osx linux 
reflog walk strbuf 	osx 
release path 	sfmt SFMT-sse2.h 
pending path pending 	mask ctx 
mode sha 	mask ctx 
parse pending parse 	size mask 
die reference 	load srli 
pending pending die 	epi 
parse die 	srli slli 
oid hex parse 	epi xor 
commit die 	xor slli 
mark parents uninteresting 	xor xor 
xstrdup mark 	epi load 
contents uninteresting pending 	load 
path pending 	recursion store 
path die relevant 	recursion store 
commit diff 	epi load 
opt diff opt 	load recursion 
name decoration 	store recursion 
diff opt 	store 
clr diff sha 	recursion store 
diff opt 	load store 
clr diff sha 	recursion store 
commit list 	store file 
count xcalloc decoration 	derives sfmt 
die rev 	http 
empty lookup decoration 	www math 
die memmove 	sci hiroshima 
die free decoration 	mat sfmt 
lookup decoration 	index html 
die oid hex 	released terms 
relevant commit 	following 
rev empty relevant 	license copyright 
commit initialise 	mutsuo saito 
treesame parse commit 	makoto matsumoto 
die oid 	hiroshima university 
hex oid hex 	rights reserved 
rev compare 	redistribution 
relevant commit 	use source 
rev empty parse 	binary forms 
commit die 	without modification 
oid hex oid 	permitted provided 
hex relevant 	following conditions 
commit die oid 	met 
hex commit 	redistributions source 
list insert date 	code must 
commit list 	retain copyright 
insert date include 	notice list 
check parse 	conditions following 
commit gently mark 	disclaimer 
parents uninteresting 	redistributions binary 
commit list insert 	form must 
date cached 	reproduce copyright 
simplify commit parse 	notice list 
commit gently 	conditions following 
commit list 	disclaimer 
insert date cached 	documentation materials 
init patch 	provided distribution 
ids commit patch 	neither name 
commit patch 	hiroshima university 
free patch ids 	names contributors 
everybody uninteresting 	may 
commit list insert 	used endorse 
free commit 	promote products 
list commit list 	derived software 
insert collect 	without specific 
bottom commits die 	prior written 
pop commit 	permission 
parents list mark 	software provided 
parents uninteresting 	copyright holders 
commit list insert 	contributors express 
still interesting 	implied warranties 
commit list insert 	including limited 
show cherry 	implied 
pick list 	warranties merchantability 
limit left right 	fitness particular 
limit ancestry 	purpose disclaimed 
free commit list 	shall copyright 
limiting increase 	owner contributors 
treesame update treesame 	liable 
alloc grow 	direct indirect 
xstrdup rev cmdline 	incidental special 
oid hex 	exemplary consequential 
wildmatch excluded reference 	damages including 
rev cmdline 	limited procurement 
pending sha list 	substitute 
clear free 	goods services 
xcalloc list append 	loss use 
init refs 	data profits 
sha parse pending 	business interruption 
warning handle 	however caused 
one reflog commit 	theory 
handle one 	liability whether 
reflog commit 	contract strict 
reflog ent reflog 	liability tort 
lookup pending 	including negligence 
path strbuf addf 	otherwise arising 
cache strbuf 	way 
setlen read cache 	use software 
isgitlink lookup 	even advised 
blob die pending 	possibility damage 
path cache 	file sfmt 
strbuf release sha 	sse brief 
committish reference 	simd 
hashcpy rev cmdline 	oriented fast 
pending memset 	mersenne twister 
diff opt diff 	sfmt intel 
opt init 	sse author 
grep defaults grep 	mutsuo saito 
init diff 	hiroshima 
setup strlen pending 	university author 
oid hex 	makoto matsumoto 
sha die 	hiroshima university 
lookup commit die 	note little 
sha die 	endian file 
lookup commit die 	copyright 
pending pending 	mutsuo saito 
merge bases rev 	makoto matsumoto 
cmdline list 	hiroshima university 
pending commit list 	rights reserved 
free commit 	bsd license 
list read cache 	applied 
stage path 	software see 
match realloc name 	license txt 
free pathspec 	function represents 
parse pathspec strstr 	recursion formula 
sha committish 	param bit 
sha committish verify 	part 
non filename 	interal state 
parse parse die 	param bit 
lookup commit 	part interal 
reference lookup 	state param 
commit reference merge 	bit part 
bases rev 	interal 
cmdline list pending 	state param 
commit list 	bit part 
free commit list 	interal state 
rev cmdline 	param mask 
rev cmdline pending 	bit mask 
pending strstr 	output 
parents strstr parents 	function fills 
sha context 	state pseudorandom 
verify non filename 	integers function 
reference rev 	fills user 
cmdline pending mode 	specified pseudorandom 
alloc grow 	integers 
strbuf getline alloc 	param bit 
grow xstrdup 	filled pseudorandom 
strbuf init 	numbers param 
strbuf getline die 	size number 
handle revision 	bit pesudorandom 
arg die read 	numbers 
pathspec stdin 	generated main 
strbuf release grep 	loop SFMT.c 
strcmp strcmp 	sfmt idx 
strcmp strcmp strcmp 	initialized parity 
strcmp strcmp 	shift shift 
strcmp strcmp starts 	ctx 
strcmp starts 	ctx size 
starts starts starts 	ctx size 
starts parse 	shift shift 
opt atoi parse 	shift shift 
opt atoi 	ctx ctx 
isdigit strtol die 	size 
strcmp error 	size ctx 
atoi starts atoi 	inner work 
parse opt 	psfmt ctx 
atoi parse 	psfmt ctx 
opt approxidate parse 	limit ret 
opt approxidate 	ctx 
parse opt atoi 	psfmt psfmt 
parse opt 	ctx limit 
approxidate parse opt 	ret ctx 
approxidate strcmp 	size ctx 
strcmp strcmp strcmp 	size seed 
init reflog 	ctx 
walk strcmp error 	psfmt init 
strcmp strcmp 	key key 
strcmp strcmp load 	length ctx 
decorations strcmp 	count lag 
strcmp starts atoi 	mid size 
strcmp strcmp 	psfmt 
strcmp strcmp strcmp 	ctx lshift 
strcmp strcmp 	rshift lshift 
starts atoi starts 	rshift recursion 
starts atoi 	recursion recursion 
starts strcmp 	recursion recursion 
strcmp strcmp die 	recursion 
strcmp die 	idxof idxof 
strcmp die strcmp 	gen rand 
strcmp die 	gen rand 
strcmp die strcmp 	gen rand 
strcmp strcmp 	kqu kqu 
strcmp strcmp starts 	gen 
die strcmp 	rand gen 
diff opt strcmp 	rand gen 
diff opt 	rand swap 
diff opt strcmp 	posix memalign 
strcmp strcmp 	idxof idxof 
strcmp strcmp commit 	idxof 
format starts 	idxof period 
starts commit format 	certification posix 
strcmp strcmp 	memalign memset 
strcmp strcmp starts 	func idxof 
starts xstrdup 	idxof idxof 
starts starts 	idxof 
starts strbuf addstr 	idxof idxof 
strbuf addstr 	func idxof 
expand notes list 	idxof idxof 
append strbuf 	idxof idxof 
detach strcmp list 	idxof func 
clear strcmp 	idxof 
strcmp strcmp commit 	idxof idxof 
format strcmp 	idxof idxof 
graph init strcmp 	idxof func 
strcmp strcmp 	idxof idxof 
strcmp strcmp starts 	idxof idxof 
strtoul strcmp 	idxof 
strcmp strcmp strcmp 	idxof period 
strcmp parse 	certification free 
opt parse date 	file derives 
format strcmp 	sfmt http 
parse opt 	www math 
header grep parse 	sci 
opt header 	hiroshima mat 
grep parse opt 	sfmt index 
header grep 	html released 
parse opt message 	terms following 
grep strcmp 	license copyright 
strcmp grep pattern 	mutsuo 
type option 	saito makoto 
strcmp strcmp grep 	matsumoto hiroshima 
pattern type 	university rights 
option strcmp strcmp 	reserved redistribution 
diff opt 	use source 
strcmp strcmp grep 	binary 
pattern type 	forms without 
option strcmp grep 	modification permitted 
pattern type 	provided following 
option strcmp strcmp 	conditions met 
parse opt 	redistributions source 
strcmp xstrdup 	code 
strcmp strcmp strcmp 	must retain 
diff opt 	copyright notice 
parse die handle 	list conditions 
revision opt 	following disclaimer 
error usage options 	redistributions binary 
strbuf addf 	form 
submodule strbuf release 	must reproduce 
bisect bisect 	copyright notice 
strcmp handle refs 	list conditions 
handle refs 	following disclaimer 
clear exclusion strcmp 	documentation materials 
handle refs 	provided 
clear exclusion strcmp 	distribution neither 
read bisect 	name hiroshima 
terms handle refs 	university names 
handle refs 	contributors may 
strcmp handle refs 	used endorse 
clear exclusion 	promote 
strcmp handle 	products derived 
refs clear exclusion 	software without 
parse opt 	specific prior 
init refs glob 	written permission 
clear exclusion 	software provided 
parse opt exclusion 	copyright 
starts init 	holders contributors 
refs glob clear 	express implied 
exclusion starts 	warranties including 
init refs glob 	limited implied 
clear exclusion 	warranties merchantability 
starts init refs 	fitness 
glob clear 	particular purpose 
exclusion strcmp reflogs 	disclaimed shall 
pending strcmp 	copyright owner 
index objects pending 	contributors liable 
strcmp strcmp 	direct indirect 
starts strcmp strcmp 	incidental 
error strcmp 	special exemplary 
resolve die 	consequential damages 
skip prefix die 	including limited 
memset strcmp 	procurement substitute 
append prune data 	goods services 
handle revision 	loss 
pseudo opt strcmp 	use data 
die read 	profits business 
revisions stdin handle 	interruption however 
revision opt 	caused theory 
exit handle revision 	liability whether 
arg die 	contract 
verify filename append 	strict liability 
prune data 	tort including 
alloc grow parse 	negligence otherwise 
pathspec tweak 	arising way 
prepare show merge 	use software 
sha context 	even 
diagnose missing 	advised possibility 
reference pending mode 	damage file 
diff opt 	sfmt brief 
tst copy pathspec 	simd oriented 
diff opt 	fast mersenne 
tst copy pathspec 	twister 
diff setup 	sfmt author 
done grep commit 	mutsuo saito 
pattern type 	hiroshima university 
compile grep patterns 	author makoto 
die die 	matsumoto hiroshima 
die die die 	university 
die die 	copyright mutsuo 
xcalloc decoration lookup 	saito makoto 
decoration compact 	matsumoto hiroshima 
treesame lookup decoration 	university rights 
xcalloc decoration 	reserved bsd 
reduce heads commit 	license 
list count 	applied software 
commit list 	see license 
count die free 	txt bit 
commit list 	simd data 
lookup decoration free 	type altivec 
compact treesame 	sse 
update treesame locate 	standard bit 
simplify state 	data structure 
locate simplify state 	bit data 
commit list 	type bit 
insert commit list 	data structure 
insert locate 	bit 
simplify state duplicate 	data type 
parents mark 	bit data 
redundant parents mark 	structure bit 
treesame root 	data type 
parents one treesame 	bit state 
parent marked 	index 
parents one relevant 	counter bit 
parent locate 	state flag 
simplify state 	state yet 
commit list insert 	initialized file 
pop commit 	variables state 
simplify one pop 	index 
commit locate 	counter flag 
simplify state commit 	parity check 
list insert 	vector certificate 
child clear flags 	period mexp 
memcpy handle 	functions function 
commit commit list 	simulate 
append clear 	bit index 
limiting increase treesame 	little endian 
commit list 	big endian 
sort date limit 	machine function 
list sort 	simulates simd 
topological order line 	bit 
log filter 	right shift 
simplify merges children 	standard bit 
rewrite parent 	integer given 
duplicate parents 	shifted shift 
strstr strlen strchr 	bits function 
split ident 	simulates 
line map user 	little endian 
strbuf addf 	simd param 
strbuf splice strbuf 	output function 
release strbuf 	param bit 
addstr reflog message 	data shifted 
strbuf addch 	param 
log output encoding 	shift shift 
logmsg reencode 	function simulates 
strbuf addstr strbuf 	simd bit 
addstr commit 	left shift 
rewrite person commit 	standard bit 
rewrite person 	integer 
strbuf addstr format 	given shifted 
display notes 	shift bits 
grep buffer grep 	function simulates 
buffer strlen 	little endian 
strbuf release 	simd param 
unuse commit buffer 	output 
sha pack 	function param 
commit list count 	bit data 
commit match 	shifted param 
want ancestry relevant 	shift shift 
commit xmalloc 	function represents 
init saved parents 	recursion 
saved parents 	formula param 
copy commit list 	output param 
clear saved 	bit part 
parents saved parents 	state param 
oidcmp free 	bit 
commit list copy 	part state 
commit list 	param bit 
pop commit save 	part state 
parents fake 	param bit 
reflog parent 	part state 
parents list die 	function 
oid hex 	fills state 
simplify commit die 	pseudorandom integers 
oid hex 	function fills 
track linear filter 	user specified 
free commit 	pseudorandom integers 
list commit list 	param 
insert sort 	bit filled 
topological order pop 	pseudorandom numbers 
commit revision 	param size 
revision create boundary 	number bit 
commit list 	pseudorandom numbers 
revision boundary revision 	generated 
commit list 	function represents 
insert pop commit 	function used 
revision graph 	initialization init 
update free saved 	param bit 
parents free 	integer bit 
commit list 	integer 
revision mark strlen 	function represents 
fputs putchar 	function used 
subproject commit repository 	initialization init 
care marked 	param bit 
uninteresting missing commit 	integer bit 
iff parent 	integer 
marked uninteresting mark 	function certificate 
thing parsed 	period mexp 
popped next time 	check check 
around won 	modification functions 
trying parse error 	function returns 
normally haven 	identification 
parsed parent yet 	shows word 
won parent 	size mersenne 
parent however may 	exponent parameters 
turn reached 	generator function 
commit way wasn 	returns minimum 
uninteresting need 	size 
mark parents 	used fill 
recursively tag look 	function minimum 
points handle 	size used 
tagged looping dropping 	fill function 
non tag 	function returns 
handlers propagate path 	minimum 
data tag 	size used 
pending entry commit 	fill function 
complex reachability 	minimum size 
crud either mark 	used fill 
uninteresting list 	function function 
objects look later 	generates 
blob know 	returns bit 
drill definition relevant 	pseudorandom number 
commit use 	init gen 
simplify limited graphs 	rand init 
eliminating side 	must called 
branches relevant commit 	function 
one uninteresting 	bit pseudorandom 
including list 	number generate 
specified bottom commit 	random integer 
computing limited 	limit function 
list processing generally 	generates returns 
ignore boundary 	bit 
merges coming outside 	pseudorandom number 
graph irrelevant 	init gen 
parents treat merges 	rand init 
single parent 	must called 
treesame defined consider 	function function 
relevant parents 	gen 
treesame graph parents 	rand called 
care treesame 	gen rand 
non graph parents 	unless initialization 
treating bottom 	executed bit 
commits relevant ensures 	pseudorandom number 
limited graph 	generate 
connection actual 	random integer 
bottom commit viewed 	limit function 
side branch 	generates pseudorandom 
treated part graph 	bit integers 
example computing 	specified one 
connection least important 	call 
despite flagged 	number pseudorandom 
uninteresting computing ancestry 	integers specified 
path connection 	argument size 
important despite flagged 	must least 
uninteresting single 	multiple four 
relevant commit parent 	generation 
list treesame 	function much 
commit selects one 	faster following 
parents safely 	gen rand 
simplify parent parent 	function initialization 
commits first 	init gen 
parent first parent 	rand 
even relevant 	init must 
definition treesame 	called first 
purely parent multi 	call function 
parent commits 	function used 
identify sole relevant 	calling gen 
parent one 	rand 
relevant parent treesame 	function without 
purely regard 	initialization param 
parent simplify accordingly 	pseudorandom bit 
one relevant 	integers filled 
parent relevant parents 	function pointer 
multiple irrelevant 	must 
ones parent goal 	aligned namely 
rev result 	must multiple 
diff consists changes 	simd version 
rev old 	since refers 
whole diff removal 	address bit 
old data 	integer 
otherwise rev different 	standard version 
course trees 	pointer arbitrary 
want rev 	param size 
means rev different 	number bit 
look simplifying 	pseudorandom integers 
decoration commit worth 	generated 
showing tag 	size must 
pointing commit pointed 	multiple greater 
tag uninteresting 	equal mexp 
limited path means 	note memalign 
see usual 	posix memalign 
commits touch paths 	available 
plus tagged 	aligned memory 
commit specifying simplify 	mac osx 
decoration pathspec 	doesn functions 
must called immediately 	malloc osx 
removing nth 	returns pointer 
parent commit parent 	aligned 
list maintaining 	memory block 
per parent treesame 	function generates 
decoration recalculate 	pseudorandom bit 
master treesame 	integers specified 
flag update treesame 	one call 
called update 	number 
sequence treesame modifications 	pseudorandom integers 
may affected 	specified argument 
removed parent non 	size must 
merge different 	least multiple 
handling lack decoration 	two generation 
become non 	function 
merge commit update 	much faster 
treesame immediately 	following gen 
longer needed decoration 	rand function 
still merge 	initialization init 
defer update update 	gen rand 
treesame treesame 	init 
irrelevant unless prune 	must called 
dense simplify 	first call 
history mixture 	function function 
treesame treesame interesting 	used calling 
parents treesame 	gen rand 
decoration anyway first 	function 
parent treesame 	without initialization 
flag locked first 	param pseudorandom 
parent lack 	bit integers 
treesame decoration pruning 	filled function 
everything interesting 	pointer must 
normal non merge 	aligned 
commit want 	namely must 
make history dense 	multiple simd 
consider always 	version since 
change second loop 	refers address 
iteration know 	bit integer 
dealing merge compare 	standard 
later parents 	version pointer 
care first parent 	arbitrary param 
chain order 	size number 
avoid derailing 	bit pseudorandom 
traversal follow side 	integers generated 
branch brought 	size 
everything path limited 	must multiple 
pathspec remain 	greater equal 
potentially simplifiable merge 	mexp note 
remember per 	memalign posix 
parent treesame needed 	memalign available 
initialise comparison 	aligned 
first iteration even 	memory mac 
merge uninteresting 	osx doesn 
side branch brought 	functions malloc 
entire change 	osx returns 
interested want lose 	pointer aligned 
branches merge 	memory 
keep going adding 	block function 
specified paths 	initializes state 
parent history beyond 	bit integer 
parent interesting 	seed param 
parents grandparents 	seed bit 
iow pretend parent 	integer 
root commit 	used seed 
fallthrough treesame straightforward 	function initializes 
single parent 	state bit 
commits merge commits 	integers used 
useful define 	seeds param 
irrelevant parents cannot 	init 
make treesame 	key bit 
relevant parents consider 	integers used 
treesam eness 	seed param 
respect allowing irrelevant 	key length 
merges uninteresting 	length init 
branches simplified away 	key 
irrelevant parents 	file derives 
treesame note logic 	sfmt http 
replicated update 	www math 
treesame kept sync 	sci hiroshima 
commit uninteresting 	mat sfmt 
prune parents 	index 
want maximal uninteresting 	html released 
normally haven 	terms following 
parsed parent yet 	license copyright 
won parent 	mutsuo saito 
parent however may 	makoto matsumoto 
turn reached 	hiroshima 
commit way wasn 	university rights 
uninteresting need 	reserved redistribution 
mark parents recursively 	use source 
commit wasn 	binary forms 
uninteresting simplify commit 	without modification 
history find 	permitted 
parent differences path 	provided following 
one exists 	conditions met 
first count commits 	redistributions source 
left right 	code must 
compute patch ids 	retain copyright 
one side 	notice 
fewer left 	list conditions 
left first omit 	following disclaimer 
commits right 	redistributions binary 
branch loop fewer 	form must 
right skip 	reproduce copyright 
left ones either 	notice 
cherry mark 	list conditions 
cherry pick check 	following disclaimer 
side fewer 	documentation materials 
left left first 	provided distribution 
omit commits 	neither name 
left branch loop 	hiroshima 
seen patch 	university names 
check original side 	contributors may 
seen ones 	used endorse 
many extra uninteresting 	promote products 
commits want 	derived software 
see source 	without 
list definitely done 	specific prior 
destination list 	written permission 
contain entries date 	software provided 
source list 	copyright holders 
definitely done source 	contributors express 
list still 	implied 
interesting commits definitely 	warranties including 
done closing 	limited implied 
rev list ancestry 	warranties merchantability 
path computes 	fitness particular 
commits ancestors ancestors 	purpose disclaimed 
limits result 	shall 
descendants takes list 	copyright owner 
bottom commits 	contributors liable 
result without ancestry 	direct indirect 
path limits 	incidental special 
latter ones reach 	exemplary consequential 
one commits 	damages 
bottom reverse 	including limited 
list likely would 	procurement substitute 
process parents 	goods services 
children mark ones 	loss use 
reach bottom 	data profits 
commits list bottom 	business 
fashion needswork 	interruption however 
decide want parents 	caused theory 
marked tmp 	liability whether 
mark commit parents 	contract strict 
commits resulting 	liability tort 
list may want 	including 
though ones 	negligence otherwise 
marked tmp mark 	arising way 
uninteresting done 	use software 
tmp mark walking 	even advised 
history keep 	possibility damage 
negative refs caller 	init 
asked exclude 	gen rand 
used compute 	expected init 
rev list ancestry 	expected init 
path need 	gen rand 
filter result ones 	expected init 
actually reach 	expected 
assumes either left 	jemalloc attr 
right revs 	jemalloc attr 
left showing whole 	ctx jemalloc 
pending list 	attr jemalloc 
end check commits 	attr ini 
become treesame 	ctx 
parents becoming uninteresting 	jemalloc attr 
entry refs 	jemalloc attr 
cmdline specified information 	ctx jemalloc 
name copied 	attr jemalloc 
cmdlineflags counting terminating 	attr ini 
range pathspec 	ctx 
parent directory find 	min size 
merge bases 	init gen 
two pseudo 	rand fill 
revision arguments accept 	fill fini 
digit like 	gen rand 
traditional head fallthrough 	init 
needs limit 	gen rand 
list detached form 	gen rand 
pretty opposed 	gen rand 
pretty allowed since 	fini gen 
argument optional 	rand min 
strdup ing trick 	size 
list free 	init fill 
ing grepping commit 	fill fini 
log note 	gen rand 
commands like git 	init gen 
shortlog accept 	rand gen 
options unless parse 	rand 
revision opt 	fini gen 
queues opposed 	rand min 
erroring implementing pseudo 	size init 
option remember 	gen rand 
list top handle 	fill fill 
revision opt 	fini 
detached form walk 	gen rand 
opposed walk 	init gen 
allowed since argument 	rand gen 
optional parse 	rand gen 
revision information filling 	rand fini 
rev info 	gen 
structure removing used 	rand min 
arguments argument 	size init 
list returns number 	fill fill 
arguments left 	fini gen 
weren recognized also 	rand init 
moved head 	gen 
argument list first 	rand gen 
search second 	rand fini 
deal arguments 	gen rand 
options didn filenames 	test file 
must exist 	derives sfmt 
rev args must 	http 
interpretable valid 	www math 
filename latter main 	sci hiroshima 
loop need 	mat sfmt 
introduce magic lone 	index html 
means pathspec 	released terms 
whatsoever place prune 	following 
data strcmp 	license copyright 
prune data prune 	mutsuo saito 
data prune 	makoto matsumoto 
data alloc free 	hiroshima university 
prune data 	rights reserved 
path prune data 	redistribution 
path terminate 	use source 
prune data alloc 	binary forms 
call init 	without modification 
pathspec revs 	permitted provided 
prune data user 	following conditions 
ask diff 	met 
output run diff 	redistributions source 
pickaxe diff 	code must 
filter rename following 	retain copyright 
need diffs 	notice list 
prune commits rename 	conditions following 
following paths 	disclaimer 
change limitations graph 	redistributions binary 
functionality examine 	form must 
existing parents marking 	reproduce copyright 
ones seen 	notice list 
clear temporary mark 	conditions following 
update treesame 	disclaimer 
removing duplicates affect 	documentation materials 
treesame want 	provided distribution 
sanity checking ready 	neither name 
items yet 	hiroshima university 
mark output 	names contributors 
reduce heads reduce 	may 
heads outputs 	used endorse 
reduced original order 	promote products 
isn hard 	derived software 
awkward naming means 	without specific 
one parent 	prior written 
treesame mark treesame 	permission 
root parents 	software provided 
root parents treesame 	copyright holders 
empty better 	contributors express 
name suggestions treesame 	implied warranties 
marked deletion 	including limited 
parent unmarked parents 	implied 
unmark first 	warranties merchantability 
treesame parent parent 	fitness particular 
simplify history 	purpose disclaimed 
scan would 	shall copyright 
followed doesn make 	owner contributors 
sense omit 	liable 
path asking simplified 	direct indirect 
full history 	incidental special 
retaining improves chances 	exemplary consequential 
understanding odd 	damages including 
missed merges took 	limited procurement 
old version 	substitute 
file example modified 	goods services 
file mainline 	loss use 
merge used took 	data profits 
version treesame 	business interruption 
treesame log would 	however caused 
produce without 	theory 
check full history 	liability whether 
simplify merges 	contract strict 
would produce showing 	liability tort 
merge commit 	including negligence 
changed making 	otherwise arising 
clear taken version 	way 
check topology 	use software 
retained note possible 	even advised 
simplification chooses 	possibility damage 
different treesame parent 	file sfmt 
test doesn 	brief simd 
activate drop parent 	oriented 
example modified 	fast mersenne 
file reverted meaning 	twister sfmt 
mainline merge 	author mutsuo 
treesame parents log 	saito hiroshima 
would produce 	university author 
following first parent 	makoto 
full history 	matsumoto hiroshima 
simplify merges produce 	university copyright 
reasonable result 	mutsuo saito 
presents logical full 	makoto matsumoto 
history leading 	hiroshima university 
important merge 	rights 
removing parents increase 	reserved bsd 
treesam eness 	license applied 
handled one uninteresting 	software see 
commit simplifies 	license txt 
root commit rewrite 	bit 
parents commit 	simd data 
anyway know commit 	type altivec 
parents matter 	sse standard 
rewritten otherwise ready 	bit data 
rewrite one 	structure bit 
yet rewrite list 	data 
parents note 	type bit 
cannot affect treesame 	data structure 
flags way 	bit data 
commit always treesame 	type bit 
simplification possible 	data structure 
merge one side 	bit 
branch commit 	data type 
touches given 	bit state 
paths immediate parent 	index counter 
branch rewritten 	bit state 
merge commit looking 	flag state 
commit touches 	yet 
paths merge independent 	initialized file 
branch doesn 	variables state 
touch path reduce 	index counter 
treesame root 	flag parity 
parent commit looking 	check vector 
commit touches 	certificate 
paths root commit 	period mexp 
touching paths 	functions function 
detect simplify cases 	simulate bit 
commit simplifies 	index little 
root uninteresting touches 	endian big 
given paths 	endian 
merge parents simplify 	machine function 
one relevant 	simulates simd 
commit first 	bit right 
two cases already 	shift standard 
handled beginning 	bit integer 
function otherwise simplifies 	given 
sole relevant 	shifted shift 
parent simplifies feed 	bits function 
list reversed 	simulates little 
free list yet 	endian simd 
original list 	param output 
used later function 	function 
clean result 	param bit 
removing simplified ones 	data shifted 
signal whether 	param shift 
need per parent 	shift function 
treesame decoration 	simulates simd 
prepend fake headers 	bit 
needed grep 	left shift 
user output 	standard bit 
encoding assumption encoding 	integer given 
likely write 	shifted shift 
grep pattern addition 	bits function 
means match 	simulates 
notes encoding end 	little endian 
buffer two 	simd param 
different encodings copy 	output function 
commit temporary 	param bit 
fake headers append 	data shifted 
fake message 	param 
parts needed find 	shift shift 
either original 	function represents 
commit message temporary 	recursion formula 
note cast 	param output 
away constness message 	param bit 
may come 	part 
cached commit buffer 	state param 
know modifiable 	bit part 
heap memory 	state param 
grep buffer may 	bit part 
modify speed 	state param 
restore changes returning 	bit 
commit without 	part state 
changes drop merges 	function fills 
unless want 	state pseudorandom 
parenthood want ancestry 	integers function 
need keep 	fills user 
merges relevant commits 	specified 
tie together 	pseudorandom integers 
topology consistency treesame 	param bit 
simplification use 	filled pseudorandom 
relevant rather interesting 	numbers param 
treat bottom 	size number 
commit part topology 	bit 
may call 	pseudorandom numbers 
save parents per 	generated function 
commit non 	represents function 
root commits 	used initialization 
walking reflogs may 	init param 
visit commit 	bit 
several times appearance 	integer bit 
reflog save 	integer function 
parents called multiple 	represents function 
times want 	used initialization 
keep first parents 	init param 
need store 	bit 
sentinel empty parent 	integer bit 
list distinguish 	integer function 
yet saved list 	certificate period 
however full 	mexp check 
diff simplified parents 	check modification 
good show 	functions 
spurious changes commits 	function returns 
elided save 	identification shows 
parents side full 	word size 
diff effect 	mersenne exponent 
first commit 	parameters generator 
haven done list 	function 
limiting need 	returns minimum 
look parents also 	size used 
need date 	fill function 
limiting otherwise done 	minimum size 
limit list 	used fill 
entries yet shown 	function 
func verge 	function returns 
realloc garbage collect 	minimum size 
entries already 	used fill 
shown free space 	function minimum 
revs commits 	size used 
non point error 	fill 
occurred revision 	function function 
ignore error printing 	generates returns 
boundary commits 	bit pseudorandom 
anyway code 	number init 
always done put 	gen rand 
actual boundary 	init 
commits revs boundary 	must called 
commits revs 	function bit 
commits revs topo 	pseudorandom number 
order sort 	generate random 
boundary commits topological 	integer limit 
order normal 	function 
commits already returned 	generates returns 
returning boundary 	bit pseudorandom 
commits create boundary 	number init 
commit list 	gen rand 
populated revs commits 	init must 
remaining commits 	called 
max count counter 	function function 
reached zero 	gen rand 
done simply still 	called gen 
might need 	rand unless 
show boundary 	initialization executed 
commits want avoid 	bit 
calling revision 	pseudorandom number 
might considerable amount 	generate random 
work finding 	integer limit 
next commit away 	function generates 
non zero 	pseudorandom bit 
either max count 	integers 
still counting 	specified one 
decrement revision runs 	call number 
commits done 	pseudorandom integers 
computing boundaries boundary 	specified argument 
commits output 	size must 
mode update revs 	least 
commits contain 	multiple four 
list boundary commits 	generation function 
boundary commits 	much faster 
commits parents ones 	following gen 
got revision 	rand function 
returned revision 	initialization 
returning need mark 	init gen 
parents could 	rand init 
boundaries revision.h alloc 	must called 
item name 	first call 
flags commits pending 	function function 
boundary commits 	used 
cmdline excludes prefix 	calling gen 
def prune 	rand function 
data date mode 	without initialization 
abbrev loginfo 	param pseudorandom 
total mime boundary 	bit integers 
patch suffix 	filled 
numbered files reroll 	function pointer 
count message 	must aligned 
ident message ids 	namely must 
signoff extra 	multiple simd 
headers log reencode 	version since 
subject prefix 	refers 
show log 	address bit 
size mailmap grep 	integer standard 
filter invert 	version pointer 
grep graph skip 	arbitrary param 
count max 	size number 
count max age 	bit 
min age 	pseudorandom integers 
min parents max 	generated size 
parents commit 	must multiple 
include check data 	greater equal 
diffopt pruning 	mexp note 
reflog info children 	memalign 
merge simplification 	posix memalign 
treesame notes opt 	available aligned 
count left 	memory mac 
count right count 	osx doesn 
line log 	functions malloc 
data saved 	osx 
parents slab previous 	returns pointer 
parents bar 	aligned memory 
list path list 	block function 
list exclude 	generates pseudorandom 
show early output 	bit integers 
def rev 	specified 
info setup revision 	one call 
opt submodule 	number pseudorandom 
dashdash revarg opt 	integers specified 
revs prefix 	argument size 
argc argv revs 	must least 
setup revision 	multiple 
opt revs ctx 	two generation 
options usagestr 	function much 
arg revs flags 	faster following 
revarg opt 	gen rand 
revs revs revs 	function initialization 
commit revs 	init 
commit commit 	gen rand 
path name revs 	init must 
obj name 	called first 
revs name sha 	call function 
flags rev 	function used 
info rev info 	calling 
flags rev 	gen rand 
info flags revs 	function without 
commit rewrite 	initialization param 
parent revs commit 	pseudorandom bit 
remember update 	integers filled 
flag allocation isolated 	function 
cases clean 	pointer must 
use parents already 	aligned namely 
parsed added 	must multiple 
starting list parents 	simd version 
shown commits 	since refers 
end points specified 	address 
end user 	bit integer 
excluding branches 	standard version 
refs etc expansion 	pointer arbitrary 
basic information 	param size 
topo sort traversal 	number bit 
flags diff 	pseudorandom 
flags format info 	integers generated 
show linear 	size must 
filter commit log 	multiple greater 
message negate 	equal mexp 
match grep filter 	note memalign 
display history 	posix 
graph special limits 	memalign available 
diff info 	aligned memory 
patches paths limiting 	mac osx 
notes specific 	doesn functions 
options refs show 	malloc osx 
commit counts 	returns 
line level range 	pointer aligned 
chasing copies 	memory block 
parent lists 	function initializes 
full diff display 	state bit 
files files 	integer seed 
removed mixed changes 	param 
revision log 	seed bit 
machinery saves original 	integer used 
parent list 	seed function 
saved parents later 	initializes state 
tell real 	bit integers 
parents commits commit 	used 
parents modified 	seeds param 
history simpification saved 	init key 
parents transparently 	bit integers 
commit parents history 	used seed 
simplification rm.c 	param key 
builtin usage alloc 	length 
name submodule 	length init 
path pos files 	key file 
list main 	derives sfmt 
msg hints 	http www 
msg errs err 	math sci 
msg files 	hiroshima 
errs errs files 	mat sfmt 
name pos 	index html 
head index head 	released terms 
errs files 	following license 
staged files cached 	copyright mutsuo 
files submodule 	saito 
files local pos 	makoto matsumoto 
name sha 	hiroshima university 
mode local changes 	rights reserved 
staged changes 	redistribution use 
file quiet ignore 	source binary 
unmatch builtin 	forms 
options argc argv 	without modification 
prefix pathspec 	permitted provided 
seen original 	following conditions 
seen sha path 	met redistributions 
gitmodules modified 	source code 
path buf strcmp 	must 
stage strbuf 	retain copyright 
addstr strbuf addf 	notice list 
strbuf addstr 	conditions following 
error strbuf release 	disclaimer redistributions 
print error 	binary form 
files list clear 	must 
cache name 	reproduce copyright 
pos strlen cache 	notice list 
pos isgitlink 	conditions following 
file exists empty 	disclaimer documentation 
dir submodule 	materials provided 
uses gitfile list 	distribution 
append error 	neither name 
removing concrete submodules 	hiroshima university 
sha cache 	names contributors 
name pos 	may used 
strlen cache pos 	endorse promote 
isgitlink empty 	products 
dir lstat warning 	derived software 
strerror isdir 	without specific 
isgitlink match stat 	prior written 
isgitlink submodule 	permission software 
entry create mode 	provided copyright 
hashcmp intent 	holders 
list append list 	contributors express 
append isgitlink 	implied warranties 
submodule uses gitfile 	including limited 
list append 	implied warranties 
list append print 	merchantability fitness 
error files 	particular 
list clear print 	purpose disclaimed 
error files 	shall copyright 
list clear error 	owner contributors 
removing concrete 	liable direct 
submodules print 	indirect incidental 
error files list 	special 
clear gitmodules 	exemplary consequential 
config git config 	damages including 
parse options 	limited procurement 
usage options setup 	substitute goods 
work hold 	services loss 
locked index read 	use 
cache die 	data profits 
parse pathspec refresh 	business interruption 
index xcalloc 	however caused 
path match alloc 	theory liability 
grow xstrdup 	whether contract 
isgitlink staging gitmodules 	strict 
die die 	liability tort 
die exit sha 	including negligence 
hashclr check 	otherwise arising 
local mod exit 	way use 
check submodules 	software even 
use gitfiles 	advised 
exit file cache 	possibility damage 
die empty 	SFMT.c sfmt 
dir rmdir path 	idx initialized 
gitmodules strbuf 	parity shift 
addstr dir recursively 	shift ctx 
path gitmodules 	ctx 
strbuf release file 	size ctx 
exists path 	size shift 
gitmodules strbuf release 	shift shift 
path die 	shift ctx 
errno stage updated 	ctx size 
gitmodules write 	size 
locked index die 	ctx inner 
git builtin 	work psfmt 
command copyright linus 	ctx psfmt 
torvalds items 	ctx limit 
list already 	ret ctx 
sorted cache order 	psfmt 
could lot 	psfmt ctx 
efficiently desc traversal 	limit ret 
wanted lazy 	ctx size 
cares removal files 	ctx size 
tad slower 	seed ctx 
theoretical maximum speed 	psfmt 
skip unmerged 	init key 
entries populated submodules 	key length 
could lose 	ctx count 
history removed already 	lag mid 
vanished working 	size psfmt 
file removed directory 	ctx 
enoent far 	lshift rshift 
git concerned track 	lshift rshift 
directories unless 	recursion recursion 
submodules path changes 	recursion recursion 
need treated 	recursion recursion 
carefully allow 	idxof 
losing local changes 	idxof gen 
accidentally local 	rand gen 
change could file 	rand gen 
work different 	rand kqu 
since index user 	kqu gen 
staged content 	rand 
different current commit 	gen rand 
index would 	gen rand 
need force removal 	swap posix 
however cached 	memalign idxof 
index safe index 	idxof idxof 
matches file 	idxof 
work head commit 	period certification 
means content 	posix memalign 
removed available elsewhere 	memset func 
index different 	idxof idxof 
file work submodule 	idxof idxof 
work modified 	idxof 
index different 	idxof func 
head commit definition 	idxof idxof 
initial commit 	idxof idxof 
anything staged index 	idxof idxof 
treated way 	func idxof 
changed head index 	idxof 
match file 	idxof idxof 
work match head 	idxof idxof 
commit either 	func idxof 
git without cached 	idxof idxof 
definitely lose 	idxof idxof 
information git cached 	idxof 
lose information 	period certification 
unless removing intent 	free file 
entry forced 	derives sfmt 
file index head 	http www 
exists must 	math sci 
match file already 	hiroshima 
removed since 	mat sfmt 
sequence natural 	index html 
novice way git 	released terms 
head commit 	following license 
exists diff index 	copyright mutsuo 
cached must 	saito 
report changes unless 	makoto matsumoto 
forced first 	hiroshima university 
names index won 	rights reserved 
commit index 	redistribution use 
unless succeed unless 	source 
used cached 	binary forms 
filenames workspace fail 	without modification 
first one 	permitted provided 
abort git successfully 	following conditions 
removed file 	met redistributions 
ahead commit already 	source 
committed fail 	code must 
middle submodule 	retain copyright 
removed user fallthrough 	notice list 
path fail 	conditions following 
run-command.c child child 	disclaimer redistributions 
pid next 	binary 
children clean installed 	form must 
child cleanup 	reproduce copyright 
handler sig signal 	notice list 
sig pid 	conditions following 
pid clean file 	disclaimer documentation 
buf end 	materials 
file file argv 	provided distribution 
argv argv 	neither name 
nargv child notifier 	hiroshima university 
flags pid 	names contributors 
argv signal status 	may used 
code waiting 	endorse 
failed errno cmd 	promote products 
need need 	derived software 
need err 	without specific 
fdin fdout fderr 	prior written 
failed errno 	permission software 
str notify pipe 	provided 
child err 	copyright holders 
fherr sargv nargv 	contributors express 
cmd ret 	implied warranties 
cmd cmd code 	including limited 
argv opt 	implied warranties 
argv opt dir 	merchantability 
env cmd 	fitness particular 
main main key 	purpose disclaimed 
die counter 	shall copyright 
data ret err 	owner contributors 
ret code 	liable direct 
alloc git atexit 	indirect 
installed handler 	incidental special 
process code need 	exemplary consequential 
need fdin 	damages including 
fdout proc 	limited procurement 
proc err ret 	substitute goods 
name path 	services 
env name args 	loss use 
hook env 	data profits 
name args ret 	business interruption 
cmd buf 	however caused 
hint data max 	theory liability 
processes processes 	whether 
next task start 	contract strict 
failure task 	liability tort 
finished process err 	including negligence 
data pfd 	otherwise arising 
output owner buffered 	way use 
output err 	software 
task result err 	even advised 
task signo 	possibility damage 
signal signo next 	file sfmt 
task start 	brief simd 
failure task 	oriented fast 
finished data code 	mersenne 
output timeout 	twister sfmt 
code result next 	author mutsuo 
task start 	saito hiroshima 
failure task finished 	university author 
code output 	makoto matsumoto 
timeout spawn cap 	hiroshima 
memset argv 	university copyright 
init argv init 	mutsuo saito 
argv clear 	makoto matsumoto 
argv clear kill 	hiroshima university 
free cleanup 	rights reserved 
children sigchain pop 	bsd 
cleanup children 	license applied 
xmalloc atexit sigchain 	software see 
push common 	license txt 
free close close 	bit simd 
open die 	data type 
errno dup 	altivec 
die errno close 	sse standard 
getenv strchrnul 	bit data 
strbuf reset strbuf 	structure bit 
strbuf addch 	data type 
strbuf addstr access 	bit data 
strbuf detach 	structure 
strbuf release locate 	bit data 
path free 	type bit 
execvp strchr exists 	data structure 
path strchr 	bit data 
die strcspn strlen 	type bit 
argv push 	state 
argv push argv 	index counter 
push argv 	bit state 
push argv pushf 	flag state 
argv pushv 	yet initialized 
prepare shell 	file variables 
cmd trace argv 	state 
sane execvp 	index counter 
argv clear xwrite 	flag parity 
fcntl fcntl 	check vector 
waitpid error strerror 	certificate period 
error wifsignaled 	mexp functions 
wtermsig error wifexited 	function 
wexitstatus error 	simulate bit 
clear child cleanup 	index little 
pipe close 	endian big 
pipe close pair 	endian machine 
close pipe 	function simulates 
close pair close 	simd 
close pair 	bit right 
close error strerror 	shift standard 
child process 	bit integer 
clear trace argv 	given shifted 
fflush pipe 	shift bits 
fork dup 	function 
cloexec error handle 	simulates little 
fdopen close 	endian simd 
cloexec atexit dup 	param output 
devnull dup 	function param 
close pair dup 	bit data 
close dup 	shifted 
devnull dup close 	param shift 
pair dup 	shift function 
close dup devnull 	simulates simd 
dup dup 	bit left 
close pair dup 	shift standard 
close chdir 	bit 
die errno strchr 	integer given 
putenv unsetenv 	shifted shift 
execv git cmd 	bits function 
execv shell 	simulates little 
cmd sane execvp 	endian simd 
error strerror 	param 
exit die 	output function 
errno error strerror 	param bit 
mark child 	data shifted 
cleanup close read 	param shift 
wait whine 	shift function 
close open dup 	represents 
dup open 	recursion formula 
dup dup open 	param output 
dup dup 	param bit 
dup prepare git 	part state 
cmd prepare 	param bit 
shell cmd mingw 	part 
spawnvpe error 	state param 
strerror mark child 	bit part 
cleanup argv 	state param 
clear close close 	bit part 
close close 	state function 
pair close close 	fills 
pair close 	state pseudorandom 
close pair 	integers function 
close child process 	fills user 
clear close 	specified pseudorandom 
close close close 	integers param 
close close 	bit 
wait whine child 	filled pseudorandom 
process clear 	numbers param 
wait whine die 	size number 
start command 	bit pseudorandom 
finish command run 	numbers generated 
command opt 	function 
env run command 	represents function 
pthread setspecific 	used initialization 
proc vreportf pthread 	init param 
getspecific close 	bit integer 
close pthread exit 	bit integer 
exit pthread 	function 
getspecific pthread 	represents function 
setspecific pthread equal 	used initialization 
pthread self 	init param 
pthread exit free 	bit integer 
memset alloc 	bit integer 
grow atexit exit 	function 
pipe close 	certificate period 
error strerror pipe 	mexp check 
close pair 	check modification 
close error strerror 	functions function 
fflush fork 	returns identification 
error strerror close 	shows 
close git 	word size 
atexit clear exit 	mersenne exponent 
proc mark 	parameters generator 
child cleanup close 	function returns 
close close 	minimum size 
close pthread self 	used 
pthread key 	fill function 
create pthread 	minimum size 
key create die 	used fill 
routine die 	function function 
recursing routine cloexec 	returns minimum 
cloexec pthread 	size 
create error strerror 	used fill 
close pair 	function minimum 
close close pair 	size used 
close wait 	fill function 
whine pthread error 	function generates 
strbuf reset 	returns 
strbuf git path 	bit pseudorandom 
access find 	number init 
hook argv push 	gen rand 
arg argv 	init must 
push run command 	called function 
start run 	bit 
hook end start 	pseudorandom number 
command strbuf 	generate random 
read close 	integer limit 
finish command close 	function generates 
finish command 	returns bit 
kill kill children 	pseudorandom 
sigchain pop 	number init 
online cpus trace 	gen rand 
die xcalloc 	init must 
xcalloc strbuf init 	called function 
strbuf init 	function gen 
child process init 	rand 
sigchain push 	called gen 
common trace strbuf 	rand unless 
release child 	initialization executed 
process clear free 	bit pseudorandom 
free fputs 	number generate 
strbuf release sigchain 	random 
pop common 	integer limit 
die next task 	function generates 
strbuf addbuf 	pseudorandom bit 
strbuf reset 	integers specified 
start command start 	one call 
failure strbuf 	number 
addbuf strbuf reset 	pseudorandom integers 
poll cleanup 	specified argument 
die errno strbuf 	size must 
read close 	least multiple 
die errno fputs 	four generation 
strbuf reset 	function 
finish command task 	much faster 
finished child 	following gen 
process init strbuf 	rand function 
addbuf strbuf 	initialization init 
reset fputs strbuf 	gen rand 
reset fputs 	init 
strbuf reset init 	must called 
start one 	first call 
kill children 	function function 
buffer stderr output 	used calling 
collect finished 	gen rand 
kill children cleanup 	function 
posix specifies 	without initialization 
empty entry current 	param pseudorandom 
directory cannot 	bit integers 
happen command found 	filled function 
one directories 	pointer must 
listed path unsearchable 	aligned 
execvp reports 	namely must 
eacces careful usability 	multiple simd 
testing read 	version since 
analysis occasional bug 	refers address 
reports reveals 	bit integer 
file directory intuitive 	standard 
avoid commands 	version pointer 
execvp path lookups 	arbitrary param 
reassignment eacces 	size number 
errno looks 	bit pseudorandom 
like need protect 	integers generated 
exists path 	size 
overwriting errno extra 	must multiple 
arguments even 	greater equal 
need bother magic 	mexp note 
execvp failed 	memalign posix 
possible like start 	memalign available 
command know 	aligned 
failures like enoent 	memory mac 
handled right 	osx doesn 
away otherwise finish 	functions malloc 
command still 	osx returns 
report error nothing 	pointer aligned 
chosen code 	memory 
xff mimics exit 	block function 
code posix 	generates pseudorandom 
shell would report 	bit integers 
program died 	specified one 
signal convert 	call number 
special exit code 	pseudorandom 
execvp failed 	integers specified 
errors must keep 	argument size 
promise close 	must least 
passed via redirect 	multiple two 
channel write 	generation function 
syscall error messages 	much 
redirecting process 	faster following 
stderr die subsequent 	gen rand 
call paths 	function initialization 
use parent stderr 	init gen 
wait child 	rand init 
execvp execvp succeeds 	must 
fork failed 	called first 
eof seen immediately 	call function 
parent otherwise 	function used 
child process sends 	calling gen 
single note 	rand function 
use infrastructure 	without 
completely advisory therefore 	initialization param 
keep error 	pseudorandom bit 
checks minimal point 	integers filled 
know fork 	function pointer 
succeeded execvp failed 	must aligned 
errors reported 	namely 
stderr asyncs started 	must multiple 
yet flush 	simd version 
stdio fork avoid 	since refers 
cloning buffers 	address bit 
first time start 	integer standard 
called main 	version 
away exit code 	pointer arbitrary 
pollfd logically 	param size 
part children system 	number bit 
call expects 	pseudorandom integers 
finished children next 	generated size 
task added 	must 
messages buffer 	multiple greater 
last iteration buffered 	equal mexp 
output non 	note memalign 
empty returns task 	posix memalign 
started jobs 	available aligned 
started next task 	memory 
ran work 	mac osx 
non critical problem 	doesn functions 
starting command 	malloc osx 
job started user 	returns pointer 
wishes shutdown 	aligned memory 
early use negative 	block 
code signal 	function initializes 
children buffer output 	state bit 
pipes output 	integer seed 
finished child processes 	param seed 
pick next 	bit integer 
process output 	used 
live needswork pick 	seed function 
randomly round 	initializes state 
robin later may 	bit integers 
want pick 	used seeds 
one output longest 	param init 
shortest running 	key 
process time run-command.h 	bit integers 
argv args 	used seed 
env pid err 	param key 
dir env 	length length 
child process child 	init key 
process child 	file 
process child process 	derives sfmt 
child process 	http www 
child process name 	math sci 
env name 	hiroshima mat 
env name args 	sfmt index 
argv opt 	html 
argv opt 	released terms 
dir env cmd 	following license 
buf hint 	copyright mutsuo 
data data pid 	saito makoto 
tid proc 	matsumoto hiroshima 
proc code err 	university 
specify redirections 	rights reserved 
child inherits stdin 	redistribution use 
stdout stderr 	source binary 
parent specify pipe 	forms without 
allocated follows 	modification permitted 
returns writable pipe 	provided 
end parent 	following conditions 
writes readable pipe 	met redistributions 
end becomes 	source code 
child stdin err 	must retain 
returns readable 	copyright notice 
pipe end parent 	list 
reads writable 	conditions following 
pipe end 	disclaimer redistributions 
becomes child stdout 	binary form 
stderr caller 	must reproduce 
start command must 	copyright notice 
close returned 	list 
completed reading writing 	conditions following 
specify channel 	disclaimer documentation 
particular follows readable 	materials provided 
becomes child 	distribution neither 
stdin writable becomes 	name hiroshima 
child stdout 	university 
stderr err writable 	names contributors 
becomes child 	may used 
stderr specified closed 	endorse promote 
start command 	products derived 
even errors git 	software without 
sub command 	specific 
returns path hook 	prior written 
file hook 	permission software 
missing disabled 	provided copyright 
note points storage 	holders contributors 
overwritten calls 	express implied 
find hook run 	warranties 
hook git 	including limited 
sub command env 	implied warranties 
environment formatted 	merchantability fitness 
like environ unset 	particular purpose 
environment variable 	disclaimed shall 
use execute given 	copyright 
command capturing 	owner contributors 
stdout given strbuf 	liable direct 
returns starting 	indirect incidental 
command fails reading 	special exemplary 
fails otherwise 	consequential damages 
returns exit code 	including 
command output 	limited procurement 
collected buffer 	substitute goods 
kept even command 	services loss 
returns non 	use data 
zero exit hint 	profits business 
field gives 	interruption 
starting size strbuf 	however caused 
allocation fields 	theory liability 
cmd would normal 	whether contract 
run command 	strict liability 
invocation note need 	tort including 
cmd function 	negligence 
sets caller purpose 	otherwise arising 
following functions 	way use 
feed pipe running 	software even 
function asynchronously 	advised possibility 
providing output caller 	damage init 
reads expected 	gen 
synchronization mutual exclusion 	rand expected 
caller feed 	init expected 
function necessary 	init gen 
function run without 	rand expected 
interfering caller 	init 
proc reads closes 	expected jemalloc 
proc writes 	attr jemalloc 
closes returns success 	attr ctx 
non zero 	jemalloc attr 
failure caller writes 	jemalloc attr 
closes caller 	ini 
reads closes callback 	ctx jemalloc 
initialize child 	attr jemalloc 
process preload error 	attr ctx 
channel desired 	jemalloc attr 
preloading useful want 	jemalloc attr 
message printed 	ini 
directly output child 	ctx min 
process callback 	size init 
cookie passed run 	gen rand 
processes parallel 	fill fill 
store child 	fini gen 
process specific callback 	rand 
cookie task 	init gen 
even returning indicate 	rand gen 
processes function 	rand gen 
called running child 	rand fini 
processes next 	gen rand 
child ready run 	min 
currently tasks 	size init 
processed send signal 	fill fill 
child processes 	fini gen 
abortion negative signal 	rand init 
number callback 	gen rand 
called whenever problems 	gen 
starting process 	rand fini 
must write stdout 	gen rand 
stderr function 	min size 
message strbuf err 	init gen 
instead printed 	rand fill 
without messing 	fill 
output parallel processes 	fini gen 
callback cookie 	rand init 
passed run processes 	gen rand 
parallel task 	gen rand 
callback cookie passed 	gen rand 
next task 	fini 
parallel processing abort 	gen rand 
non zero 	min size 
send signal child 	init fill 
processes abortion 	fill fini 
negative signal number 	gen rand 
callback called 	init 
every child process 	gen rand 
finished processing 	gen rand 
must write stdout 	fini gen 
stderr function 	rand test 
message strbuf 	file derives 
err instead printed 	sfmt 
without messing 	http www 
output parallel processes 	math sci 
callback cookie 	hiroshima mat 
passed run processes 	sfmt index 
parallel task 	html released 
callback cookie passed 	terms 
next task 	following license 
parallel processing abort 	copyright mutsuo 
non zero 	saito makoto 
send signal child 	matsumoto hiroshima 
processes abortion 	university rights 
negative signal number 	reserved 
runs processes 	redistribution use 
time whenever process 	source binary 
started callback 	forms without 
next task called 	modification permitted 
obtain data 	provided following 
required start 	conditions 
another child process 	met redistributions 
children started 	source code 
via function run 	must retain 
parallel output 	copyright notice 
stdout stderr routed 	list conditions 
stderr manner 	following 
output different tasks 	disclaimer redistributions 
interleave start 	binary form 
failure task finished 	must reproduce 
omit special 	copyright notice 
handling send-pack.c opt 	list conditions 
arg unset 	following 
sha negative buf 	disclaimer documentation 
refs extra 	materials provided 
args argv buf 	distribution neither 
refs hint 	name hiroshima 
ret line refname 	university names 
msg data 	contributors 
ret graft 	may used 
args line len 	endorse promote 
req buf 	products derived 
remote refs args 	software without 
cap push 	specific prior 
cert nonce signing 	written 
key cert 	permission software 
update seen anon 	provided copyright 
url args 	holders contributors 
remote refs failing 	express implied 
nonce len 	warranties including 
args conn remote 	limited 
refs extra 	implied warranties 
req buf cap 	merchantability fitness 
buf need 	particular purpose 
pack data allow 	disclaimed shall 
deleting refs 	copyright owner 
status report use 	contributors 
sideband quiet 	liable direct 
supported agent 	indirect incidental 
supported use atomic 	special exemplary 
atomic supported 	consequential damages 
cmds sent ret 	including limited 
demux push 	procurement 
cert nonce len 	substitute goods 
old hex 	services loss 
hex git parse 	use data 
maybe strcasecmp 	profits business 
die sha file 	interruption however 
memcpy sha 	caused 
hex write whine 	theory liability 
repository shallow 	whether contract 
start command die 	strict liability 
errno feed 	tort including 
oid feed oid 	negligence otherwise 
feed close 	arising 
xmalloc xread send 	way use 
sideband free 	software even 
close finish 	advised possibility 
command packet read 	damage file 
line starts 	sfmt brief 
error strcmp error 	simd 
packet read 	oriented fast 
line starts starts 	mersenne twister 
error strchr 	sfmt author 
find name find 	mutsuo saito 
name warning 	hiroshima university 
warning xstrdup close 	author 
recv sideband 	makoto matsumoto 
close packet buf 	hiroshima university 
write oid 	copyright mutsuo 
hex repository shallow 	saito makoto 
commit graft 	matsumoto hiroshima 
memchr xstrdup signing 	university 
key strbuf 	rights reserved 
addf strbuf 	bsd license 
addf datestamp strbuf 	applied software 
addch transport 	see license 
anonymize url strbuf 	txt bit 
addf free 	simd 
strbuf addf strbuf 	data type 
addstr check 	altivec sse 
send update strbuf 	standard bit 
addf oid 	data structure 
hex oid hex 	bit data 
sign buffer 	type 
die packet buf 	bit data 
write next 	structure bit 
line packet buf 	data type 
write packet 	bit data 
buf write free 	structure bit 
strbuf release 	data 
error die isalnum 	type bit 
die server 	state index 
supports server 	counter bit 
supports server supports 	state flag 
server supports 	state yet 
server supports server 	initialized 
supports server 	file variables 
supports server supports 	state index 
server feature 	counter flag 
reject invalid nonce 	parity check 
xmemdupz die 	vector certificate 
warning die strbuf 	period 
addstr strbuf 	mexp functions 
addstr strbuf addstr 	function simulate 
strbuf addstr 	bit index 
strbuf addf git 	little endian 
user agent 	big endian 
sanitized advertise shallow 	machine 
grafts buf 	function simulates 
generate push cert 	simd bit 
check send 	right shift 
update atomic 	standard bit 
push failure check 	integer given 
send update 	shifted 
oid hex oid 	shift bits 
hex packet 	function simulates 
buf write packet 	little endian 
buf write 	simd param 
repository shallow packet 	output function 
buf flush 	param 
send sideband write 	bit data 
die packet 	shifted param 
flush strbuf release 	shift shift 
strbuf release 	function simulates 
memset start die 	simd bit 
pack objects 	left 
close git connection 	shift standard 
socket shutdown 	bit integer 
finish packet flush 	given shifted 
receive status 	shift bits 
packet flush 	function simulates 
finish error close 	little 
make pack 	endian simd 
stream spit file 	param output 
descriptor child 	function param 
becomes pack objects 	bit data 
revs feed 	shifted param 
revision parameters via 	shift 
stdin stdout 	shift function 
back end feed 	represents recursion 
pack objects 	formula param 
spawned revision parameters 	output param 
writing pipe 	bit part 
first searching hint 	state 
falling back 	param bit 
refs start next 	part state 
search next 	param bit 
check statuses 	part state 
status push beginning 	param bit 
next line 	part 
end buffer needswork 	state function 
perhaps move 	fills state 
git compat somewhere 	pseudorandom integers 
convert many 	function fills 
similar uses found 	user specified 
git grep 	pseudorandom 
memchr incomplete line 	integers param 
mark refs 	bit filled 
failed nothing end 	pseudorandom numbers 
support reporting 	param size 
needswork refs specific 	number bit 
send pack 	pseudorandom 
machinery status push 	numbers generated 
cannot bit 	function represents 
clear status see 	function used 
need send 	initialization init 
pack data 	param bit 
error know server 	integer 
would reject 	bit integer 
update send trying 	function represents 
send refs 	function used 
atomically abort whole 	initialization init 
operation fallthrough 	param bit 
non atomic tell 	integer 
end closed 	bit integer 
pack objects via 	function certificate 
start command 	period mexp 
mirror incompatible neither 	check check 
makes sense 	modification functions 
refspecs match send 	function 
pack usage 	returns identification 
args buf msg 	shows word 
res argc 	size mersenne 
argv prefix refspecs 	exponent parameters 
refspecs remote 	generator function 
name remote 	returns 
dest conn extra 	minimum size 
shallow remote 	used fill 
refs local refs 	function minimum 
ret helper 	size used 
status send verbose 	fill function 
receivepack dry 	function 
run send mirror 	returns minimum 
force update 	size used 
quiet push cert 	fill function 
use thin 	minimum size 
pack atomic stateless 	used fill 
rpc flags 	function 
reject reasons progress 	function generates 
stdin cas 	returns bit 
options refspecs buf 	pseudorandom number 
line strbuf 	init gen 
reset strbuf addf 	rand init 
strbuf addch 	must 
quote two 	called function 
style strbuf addch 	bit pseudorandom 
write die 	number generate 
strbuf release git 	random integer 
gpg config 	limit function 
strcmp git config 	generates 
git config 	returns bit 
maybe strcasecmp error 	pseudorandom number 
git config 	init gen 
parse options usage 	rand init 
options argv 	must called 
push packet read 	function 
line argv 	function gen 
push strbuf getline 	rand called 
argv push 	gen rand 
strbuf release usage 	unless initialization 
options remote 	executed bit 
remote url 	pseudorandom 
die isatty git 	number generate 
connect remote 	random integer 
heads transport verify 	limit function 
remote names 	generates pseudorandom 
local heads match 	bit integers 
push refs 	specified 
empty cas apply 	one call 
push cas 	number pseudorandom 
status push send 	integers specified 
pack print 	argument size 
helper status close 	must least 
close finish 	multiple 
connect transport print 	four generation 
push status 	function much 
transport update tracking 	faster following 
transport refs 	gen rand 
pushed make pack 	function initialization 
stream spit 	init 
file descriptor 	gen rand 
child becomes pack 	init must 
objects revs 	called first 
feed revision parameters 	call function 
via stdin 	function used 
stdout back end 	calling 
feed pack 	gen rand 
objects spawned revision 	function without 
parameters writing 	initialization param 
pipe first searching 	pseudorandom bit 
hint falling 	integers filled 
back refs start 	function 
next search 	pointer must 
next check statuses 	aligned namely 
status push 	must multiple 
beginning next line 	simd version 
end buffer 	since refers 
needswork perhaps move 	address 
git compat 	bit integer 
somewhere convert 	standard version 
many similar uses 	pointer arbitrary 
found git 	param size 
grep memchr incomplete 	number bit 
line mark 	pseudorandom 
refs failed nothing 	integers generated 
end support 	size must 
reporting needswork refs 	multiple greater 
specific send 	equal mexp 
pack machinery status 	note memalign 
push cannot 	posix 
bit clear status 	memalign available 
see need 	aligned memory 
send pack data 	mac osx 
error know 	doesn functions 
server would reject 	malloc osx 
update send 	returns 
trying send refs 	pointer aligned 
atomically abort 	memory block 
whole operation 	function generates 
fallthrough non atomic 	pseudorandom bit 
tell end 	integers specified 
closed pack objects 	one 
via start 	call number 
command mirror incompatible 	pseudorandom integers 
neither makes 	specified argument 
sense refspecs match 	size must 
send-pack.c opt 	least multiple 
arg unset sha 	two 
negative buf 	generation function 
refs extra args 	much faster 
argv buf 	following gen 
refs hint ret 	rand function 
line refname 	initialization init 
msg data ret 	gen 
graft args 	rand init 
line len req 	must called 
buf remote 	first call 
refs args 	function function 
cap push cert 	used calling 
nonce signing 	gen 
key cert update 	rand function 
seen anon 	without initialization 
url args remote 	param pseudorandom 
refs failing 	bit integers 
nonce len args 	filled function 
conn remote 	pointer 
refs extra req 	must aligned 
buf cap 	namely must 
buf need pack 	multiple simd 
data allow 	version since 
deleting refs status 	refers address 
report use 	bit 
sideband quiet supported 	integer standard 
agent supported 	version pointer 
use atomic 	arbitrary param 
atomic supported cmds 	size number 
sent ret 	bit pseudorandom 
demux push cert 	integers 
nonce len 	generated size 
old hex hex 	must multiple 
git parse 	greater equal 
maybe strcasecmp die 	mexp note 
sha file 	memalign posix 
memcpy sha hex 	memalign 
write whine 	available aligned 
repository shallow start 	memory mac 
command die 	osx doesn 
errno feed oid 	functions malloc 
feed oid 	osx returns 
feed close xmalloc 	pointer 
xread send 	aligned memory 
sideband free close 	block function 
finish command 	initializes state 
packet read 	bit integer 
line starts error 	seed param 
strcmp error 	seed 
packet read line 	bit integer 
starts starts 	used seed 
error strchr find 	function initializes 
name find 	state bit 
name warning warning 	integers used 
xstrdup close 	seeds 
recv sideband close 	param init 
packet buf 	key bit 
write oid hex 	integers used 
repository shallow 	seed param 
commit graft memchr 	key length 
xstrdup signing 	length 
key strbuf addf 	init key 
strbuf addf 	file derives 
datestamp strbuf addch 	sfmt http 
transport anonymize 	www math 
url strbuf 	sci hiroshima 
addf free strbuf 	mat 
addf strbuf 	sfmt index 
addstr check send 	html released 
update strbuf 	terms following 
addf oid hex 	license copyright 
oid hex 	mutsuo 
sign buffer die 	saito makoto 
packet buf 	matsumoto hiroshima 
write next line 	university rights 
packet buf 	reserved redistribution 
write packet buf 	use source 
write free 	binary 
strbuf release error 	forms without 
die isalnum 	modification permitted 
die server supports 	provided following 
server supports 	conditions met 
server supports server 	redistributions source 
supports server 	code 
supports server 	must retain 
supports server supports 	copyright notice 
server supports 	list conditions 
server feature reject 	following disclaimer 
invalid nonce 	redistributions binary 
xmemdupz die warning 	form 
die strbuf 	must reproduce 
addstr strbuf addstr 	copyright notice 
strbuf addstr 	list conditions 
strbuf addstr strbuf 	following disclaimer 
addf git 	documentation materials 
user agent sanitized 	provided 
advertise shallow 	distribution neither 
grafts buf generate 	name hiroshima 
push cert 	university names 
check send update 	contributors may 
atomic push 	used endorse 
failure check 	promote 
send update oid 	products derived 
hex oid 	software without 
hex packet buf 	specific prior 
write packet 	written permission 
buf write repository 	software provided 
shallow packet 	copyright 
buf flush send 	holders contributors 
sideband write 	express implied 
die packet flush 	warranties including 
strbuf release 	limited implied 
strbuf release memset 	warranties merchantability 
start die 	fitness 
pack objects close 	particular purpose 
git connection 	disclaimed shall 
socket shutdown finish 	copyright owner 
packet flush 	contributors liable 
receive status packet 	direct indirect 
flush finish 	incidental 
error close 	special exemplary 
make pack stream 	consequential damages 
spit file 	including limited 
descriptor child becomes 	procurement substitute 
pack objects 	goods services 
revs feed revision 	loss 
parameters via 	use data 
stdin stdout back 	profits business 
end feed 	interruption however 
pack objects spawned 	caused theory 
revision parameters 	liability whether 
writing pipe first 	contract 
searching hint 	strict liability 
falling back refs 	tort including 
start next 	negligence otherwise 
search next check 	arising way 
statuses status 	use software 
push beginning next 	even 
line end 	advised possibility 
buffer needswork 	damage SFMT.h 
perhaps move git 	ctx ctx 
compat somewhere 	limit ctx 
convert many similar 	ctx limit 
uses found 	ctx 
git grep memchr 	size ctx 
incomplete line 	size seed 
mark refs failed 	init key 
nothing end 	key length 
support reporting needswork 	ctx ctx 
refs specific 	ctx 
send pack machinery 	ctx ctx 
status push 	ctx ctx 
cannot bit clear 	ctx ctx 
status see 	ctx ctx 
need send pack 	real gen 
data error 	rand 
know server would 	real gen 
reject update 	rand real 
send trying 	gen rand 
send refs atomically 	res res 
abort whole 	gen rand 
operation fallthrough non 	gen 
atomic tell 	rand gen 
end closed pack 	rand res 
objects via 	mix file 
start command mirror 	derives sfmt 
incompatible neither 	http www 
makes sense refspecs 	math 
match send 	sci hiroshima 
pack usage args 	mat sfmt 
buf msg 	index html 
res argc argv 	released terms 
prefix refspecs 	following license 
refspecs remote name 	copyright 
remote dest 	mutsuo saito 
conn extra 	makoto matsumoto 
shallow remote refs 	hiroshima university 
local refs 	rights reserved 
ret helper status 	redistribution use 
send verbose 	source 
receivepack dry run 	binary forms 
send mirror 	without modification 
force update quiet 	permitted provided 
push cert 	following conditions 
use thin pack 	met redistributions 
atomic stateless 	source 
rpc flags reject 	code must 
reasons progress 	retain copyright 
stdin cas options 	notice list 
refspecs buf 	conditions following 
line strbuf reset 	disclaimer redistributions 
strbuf addf 	binary 
strbuf addch quote 	form must 
two style 	reproduce copyright 
strbuf addch 	notice list 
write die strbuf 	conditions following 
release git 	disclaimer documentation 
gpg config strcmp 	materials 
git config 	provided distribution 
git config maybe 	neither name 
strcasecmp error 	hiroshima university 
git config parse 	names contributors 
options usage 	may used 
options argv push 	endorse 
packet read 	promote products 
line argv push 	derived software 
strbuf getline 	without specific 
argv push strbuf 	prior written 
release usage 	permission software 
options remote remote 	provided 
url die 	copyright holders 
isatty git connect 	contributors express 
remote heads 	implied warranties 
transport verify 	including limited 
remote names local 	implied warranties 
heads match 	merchantability 
push refs empty 	fitness particular 
cas apply 	purpose disclaimed 
push cas status 	shall copyright 
push send 	owner contributors 
pack print helper 	liable direct 
status close 	indirect 
close finish connect 	incidental special 
transport print 	exemplary consequential 
push status transport 	damages including 
update tracking 	limited procurement 
transport refs pushed 	substitute goods 
make pack 	services 
stream spit file 	loss use 
descriptor child 	data profits 
becomes pack objects 	business interruption 
revs feed 	however caused 
revision parameters 	theory liability 
via stdin stdout 	whether 
back end 	contract strict 
feed pack objects 	liability tort 
spawned revision 	including negligence 
parameters writing pipe 	otherwise arising 
first searching 	way use 
hint falling back 	software 
refs start 	even advised 
next search next 	possibility damage 
check statuses 	file sfmt 
status push beginning 	brief simd 
next line 	oriented fast 
end buffer needswork 	mersenne 
perhaps move 	twister sfmt 
git compat somewhere 	pseudorandom number 
convert many 	generator author 
similar uses found 	mutsuo saito 
git grep 	hiroshima university 
memchr incomplete 	author 
line mark refs 	makoto matsumoto 
failed nothing 	hiroshima university 
end support reporting 	copyright mutsuo 
needswork refs 	saito makoto 
specific send pack 	matsumoto hiroshima 
machinery status 	university 
push cannot bit 	rights reserved 
clear status 	bsd license 
see need send 	applied software 
pack data 	see license 
error know server 	txt note 
would reject 	system 
update send trying 	inttypes system 
send refs 	doesn inttypes 
atomically abort whole 	define file 
operation fallthrough 	follows verbatim 
non atomic 	define llu 
tell end closed 	define 
pack objects 	llx endverbatim 
via start command 	must exactly 
mirror incompatible 	bit integer 
neither makes sense 	type less 
refspecs match 	must exactly 
send-pack.h url opt 	bit 
arg unset 	integer type 
args conn remote 	used function 
refs extra 	print bit 
possible values push 	bit hexadecimal 
cert field 	format real 
send pack args 	versions 
one send 	due isaku 
pack push cert 	wada generates 
constants sequencer.c 	random number 
sign header cherry 	real interval 
picked prefix 	divided generates 
buf len 	random 
sob ignore footer 	number real 
prev len 	interval generates 
buf found sob 	random number 
found rfc 	real interval 
seq dir opts 	divided generates 
parent label 	random 
label subject message 	number real 
commit abbrev 	interval generates 
subject subject len 	random number 
commit msg 	real interval 
show hint opts 	divided generates 
msg msgbuf 	random 
filename msg file 	number real 
msg opts 	interval real 
unborn opts transaction 	versions due 
err msgbuf 	isaku wada 
next label next 	generates random 
label head 	number 
msgbuf opts 	bit resolution 
result next head 	generates random 
clean xopt 	number bit 
index head sha 	resolution two 
head commit 	bit integers 
defmsg opts allow 	generates 
empty commit 	random number 
ptree sha parent 	bit resolution 
opts commit 	generates random 
index unchanged empty 	number bit 
commit commit 	resolution bit 
opts head next 	integer 
parent label 	sha1.c state 
next label msg 	buffer block 
msgbuf res 	block context 
allow cnt common 	context data 
remotes opts 	len digest 
opts index index 	context 
buf todo 	finalcount argc 
list opts 	argv ctx 
cur sha abbrev 	hash buf 
action str 	memcpy memset 
subject subject len 	memcpy sha 
commit buffer 	transform 
bol eol opts 	sha transform 
commit sha 	memcpy sha 
end name saved 	update sha 
status padding 	update sha 
action str buf 	update memset 
todo list 	memset 
opts next commit 	unused unused 
eol todo 	sha init 
list opts buf 	sha update 
res key 	sha valgrind 
data opts error 	tests sha 
flag opts 	sha 
ptr todo 	steve reid 
list opts commit 	steve edmweb 
next head 	domain test 
head buf sha 	vectors fips 
argv head 	pub abc 
sha opts sha 	abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq 
buf todo 	baae million 
list opts todo 	repetitions daa 
buf opts 	eeb dbad 
opts file buf 	define little 
todo list 	endian define 
opts cur res 	already 
argv opts 	define sha 
todo list ret 	handsoff copies 
cmit opts 	data messing 
opts todo list 	blk blk 
sha sha 	perform initial 
name cmit msgbuf 	expand 
ignore footer 	got idea 
flag dup 	expanding round 
sob sob footer 	function leay 
append newlines 	different operations 
len strlen starts 	used sha 
rfc line 	hash 
strncmp cherry picked 	single bit 
line strbuf 	block core 
addf git path 	algorithm use 
dir recursively 	appear pointer 
strbuf release logmsg 	following better 
reencode commit 	never 
output encoding find 	used causes 
unique abbrev 	pointer buffer 
find commit subject 	cast pointer 
xmemdupz xstrfmt 	non result 
xstrfmt free free 	written threw 
free unuse 	hoping 
commit buffer getenv 	cause diagnostic 
unlink git 	copy context 
path cherry 	state working 
pick head advise 	vars rounds 
advise hold 	operations loop 
file update write 	unrolled 
full die 	working vars 
errno strbuf release 	back context 
commit file 	state wipe 
die lookup read 	variables sha 
cache unmerged 	init initialize 
error resolve conflict 	context 
action name 	sha initialization 
error error advise 	constants run 
read cache 	data padding 
checkout fast forward 	message digest 
exit strbuf 	untested improvement 
addf action name 	dhr 
transaction begin 	convert context 
transaction update transaction 	count sequence 
commit transaction 	bytes finalcount 
free error 	second element 
strbuf release strbuf 	first big 
release strbuf 	endian 
release strbuf release 	order within 
transaction free 	element backwards 
strbuf addch strbuf 	endian independent 
commented addf 	cause sha 
stage strbuf commented 	transform wipe 
addf strcmp 	variables 
hold locked index 	end sha 
read cache 	sha1.h state 
init merge options 	buffer context 
parse indirect 	context data 
empty empty parse 	len digest 
merge opt 	context 
merge trees write 	argc argv 
locked index 	sha sha 
die action 	steve reid 
name rollback file 	steve edmweb 
append signoff 	domain size 
append conflicts hint 	classesc 
resolve error 	nhchunks mib 
lookup commit parse 	miblen max 
commit cache 	size size 
cache fully valid 	max size 
cache update 	index max 
error hashcmp argv 	index 
init argv 	mallctl mallctlnametomib 
push argv push 	mallctlbymib max 
argv pushf 	size size 
argv push argv 	index size 
push argv 	index size 
push git config 	index 
argv push 	index size 
argv push argv 	size index 
push run 	index size 
command opt 	size index 
argv clear parse 	size index 
commit error 	index 
oid hex parse 	size size 
commit error 	index size 
oid hex hashcmp 	index index 
index unchanged 	size index 
original commit empty 	size size 
write cache 	index 
die sha hashcpy 	index size 
index differs 	index size 
error dirty index 	size index 
discard cache 	index size 
error oid hex 	test slowlog.c 
error oid 	argv 
hex error oid 	argc duration 
hex hashcmp 	slargc septr 
fast forward parse 	argv argc 
commit error 	duration sent 
action name 	totentries zmalloc 
oid hex message 	zmalloc 
error oid 	create sdscatprintf 
hex strbuf addstr 	sdsempty sds 
strbuf addstr 	encoded sdslen 
strbuf addstr strbuf 	sdsnewlen sdscatprintf 
addstr oid 	sdslen create 
hex strbuf addstr 	incr 
strbuf addstr 	count time 
oid hex strbuf 	decr count 
addstr strstr 	zfree zfree 
strbuf addstr conforming 	list create 
footer strbuf 	list free 
addch strbuf addstr 	method 
strbuf addstr 	list node 
oid hex strbuf 	head slowlog 
addstr strcmp 	create entry 
recursive merge write 	list length 
message git 	list del 
path merge 	node 
msg write message 	list last 
git path 	list length 
merge msg commit 	list del 
list insert 	node list 
commit list insert 	last strcasecmp 
merge command 	slowlog 
sha hex free 	reset reply 
commit list 	strcasecmp reply 
free commit list 	list length 
update update 	strcasecmp reply 
error find unique 	list rewind 
abbrev print 	deferred 
advice rerere allow 	multi bulk 
empty run 	length list 
git commit git 	next reply 
path merge 	multi bulk 
msg free message 	len reply 
prepare revision 	reply 
walk die 	reply reply 
die hold locked 	multi bulk 
index read 	len reply 
index preload die 	bulk deferred 
action name 	multi bulk 
refresh index write 	length 
locked index 	reply error 
die action name 	slowlog system 
rollback file 	able remember 
commit buffer find 	latest queries 
unique abbrev 	took microseconds 
find commit subject 	execute 
strbuf addf 	execution time 
unuse commit buffer 	reach logged 
starts strlen 	slow log 
starts strlen strspn 	slowlog log 
strcspn sha 	slower 
error action 	config directive 
name lookup commit 	also readable 
reference strchrnul 	writable config 
parse insn line 	command slow 
error commit 	queries log 
list append error 	actually 
open git 	logged redis 
path todo file 	log file 
die errno 	accessible thanks 
git path todo 	slowlog command 
file strbuf 	copyright salvatore 
read close strbuf 	sanfilippo 
release die 	antirez gmail 
git path todo 	dot rights 
file close 	reserved redistribution 
parse insn buffer 	use source 
strbuf release 	binary forms 
die git path 	without 
todo file 	modification permitted 
strcmp git 	provided following 
config strcmp git 	conditions met 
config strcmp 	redistributions source 
git config strcmp 	code must 
git config 	retain 
strcmp git config 	copyright notice 
strcmp git 	list conditions 
config strcmp git 	following disclaimer 
config strcmp 	redistributions binary 
git config strcmp 	form must 
alloc grow 	reproduce 
xstrdup error error 	copyright notice 
file exists 	list conditions 
git path opts 	following disclaimer 
file git 	documentation materials 
config file git 	provided distribution 
path opts 	neither 
file die git 	name redis 
path opts 	names contributors 
file prepare 	may used 
revs revision commit 	endorse promote 
list append 	products derived 
file exists git 	software 
path seq 	without specific 
dir error advise 	prior written 
mkdir git 	permission software 
path seq dir 	provided copyright 
die errno 	holders contributors 
git path seq 	express 
dir hold 	implied warranties 
file update git 	including limited 
path head 	implied warranties 
file strbuf addf 	merchantability fitness 
write full 	particular purpose 
die errno git 	disclaimed 
path head 	shall copyright 
file commit file 	owner contributors 
die git 	liable direct 
path head 	indirect incidental 
file sha hex 	special exemplary 
run command 	consequential 
opt file exists 	damages including 
git path 	limited procurement 
cherry pick head 	substitute goods 
file exists 	services loss 
git path revert 	use data 
head error 	profits 
read full error 	business interruption 
sha error 	however caused 
reset rollback fopen 	theory liability 
git path 	whether contract 
head file rollback 	strict liability 
single pick 	tort 
error git path 	including negligence 
head file 	otherwise arising 
strerror strbuf 	way use 
getline error git 	software even 
path head 	advised possibility 
file ferror strerror 	damage 
fclose fclose 	create slowlog 
sha hex error 	entry incrementing 
git path 	count objects 
head file reset 	retained function 
rollback sequencer 	logging many 
state strbuf release 	arguments 
strbuf release 	useless memory 
hold file update 	waste stop 
git path 	slowlog entry 
todo file format 	max argc 
todo die 	use last 
git path todo 	argument 
file write 	specify many 
full strbuf release 	remaining arguments 
die errno 	original command 
git path 	trim well 
todo file commit 	free slow 
file strbuf 	log 
release die git 	entry argument 
path todo 	prototype function 
file strbuf release 	matches one 
git path 	free method 
opts file git 	adlist function 
config file 	take 
git config file 	care release 
git config 	retained initialize 
file git config 	slow log 
file git 	function called 
config file strbuf 	single time 
addf git 	server 
config file strbuf 	startup push 
release git 	entry slow 
config file git 	log function 
config file 	make sure 
git config 	trim slow 
multivar file setenv 	log 
action name 	accordingly configured 
read refresh cache 	max length 
save todo 	slowlog disabled 
pick commit sequencer 	old entries 
state file 	needed entries 
exists git path 	current 
cherry pick 	slow log 
head file exists 	slowlog command 
git path 	subcommands needed 
revert head error 	handle redis 
run command 	slow log 
opt file exists 	slowlog.h 
git path 	argv argc 
todo file single 	duration copyright 
pick read 	salvatore sanfilippo 
populate opts read 	antirez gmail 
populate todo 	dot rights 
file exists 	reserved 
git path cherry 	redistribution use 
pick head 	source binary 
file exists git 	forms without 
path revert 	modification permitted 
head single pick 	provided following 
index differs 	conditions 
error dirty index 	met redistributions 
pick commits 	source code 
setenv action name 	must retain 
pick commit 	copyright notice 
read refresh cache 	list conditions 
sequencer state 	following 
sequencer rollback sequencer 	disclaimer redistributions 
strlen sha 	binary form 
lookup commit reference 	must reproduce 
gently die 	copyright notice 
die prepare 	list conditions 
revision walk die 	following 
revision revision 	disclaimer documentation 
die single pick 	materials provided 
walk revs 	distribution neither 
populate todo create 	name redis 
seq dir 	names contributors 
sha error error 	may 
save head 	used endorse 
sha hex save 	promote products 
opts pick 	derived software 
commits strbuf addstr 	without specific 
strbuf addstr 	prior written 
fmt name getenv 	permission 
getenv strbuf 	software provided 
addch strncmp conforming 	copyright holders 
footer strbuf 	contributors express 
splice strlen strbuf 	implied warranties 
splice strbuf 	including limited 
release care 	implied 
looks roughly like 	warranties merchantability 
cherry picked 	fitness particular 
returns non conforming 	purpose disclaimed 
footer returns 	shall copyright 
conforming footer returns 	owner contributors 
sob exists 	liable 
within conforming footer 	direct indirect 
returns sob 	incidental special 
exists within conforming 	exemplary consequential 
footer last 	damages including 
entry footer must 	limited procurement 
end newline 	substitute 
paragraph require least 	goods services 
one blank 	loss use 
line advance start 	data profits 
last paragraph 	business interruption 
nothing conflict occurred 	however caused 
porcelain typically 	theory 
rebase interactive 	liability whether 
wants take care 	contract strict 
commit cherry 	liability tort 
pick head different 	including negligence 
translation cherry 	otherwise arising 
pick revert callee 	way 
complained already 	use software 
translators revert cherry 	even advised 
pick head 	possibility damage 
commit check commit 	structure defines 
called lookup 	entry inside 
commit would indicated 	slow 
head commit 	log list 
commit already parse 	unique entry 
commit failure 	time spent 
without complaints otherwise 	query nanoseconds 
commit invalid 	unix time 
parse commit complain 	query 
nothing say 	executed exported 
failure cherry 	api exported 
pick merge result 	commands solarisfixes.h 
hand editing 	solaris specific 
hit commit inherit 	fixes copyright 
original author 	salvatore 
date name revert 	sanfilippo antirez 
cherry pick 	gmail dot 
results hand merge 	rights reserved 
better say 	redistribution use 
current user responsible 	source binary 
commit root 	forms 
run git commit 	without modification 
allow empty 	permitted provided 
three cases allow 	following conditions 
empty error 	met redistributions 
allow ones initially 	source code 
empty forbid 	must 
ones become empty 	retain copyright 
allow git 	notice list 
commit barf 	conditions following 
necessary say allow 	disclaimer redistributions 
empty intend 	binary form 
commit immediately want 	must 
merge differences 	reproduce copyright 
compute represents current 	notice list 
state merge 	conditions following 
recursive work reverting 	disclaimer documentation 
cherry picking 	materials provided 
merge commit translators 	distribution 
first revert 	neither name 
cherry pick second 	redis names 
sha commit 	contributors may 
existing commit would 	used endorse 
want apply 	promote products 
difference introduces since 	derived 
first parent 	software without 
prev top 	specific prior 
current head cherry 	written permission 
pick reverse 	software provided 
revert append commit 	copyright holders 
log message 	contributors 
msgbuf starts parent 	express implied 
author committer 	warranties including 
information followed merge 	limited implied 
clean failed 	warranties merchantability 
due conflict write 	fitness particular 
cherry pick 	purpose 
head subsequent invocation 	disclaimed shall 
commit use 	copyright owner 
however merge even 	contributors liable 
start want 	direct indirect 
write picking reverting 	incidental special 
ranges individual 	exemplary 
revisions done reverse 	consequential damages 
eat extra 	including limited 
spaces tabs 	procurement substitute 
name verify action 	goods services 
matches one 	loss use 
opts support arbitrary 	data 
instructions reset 	profits business 
merge arg multiple 	interruption however 
cherry pick 	caused theory 
progress cherry pick 	liability whether 
head revert 	contract strict 
head indicates single 	liability 
cherry pick 	tort including 
progress abort sequence 	negligence otherwise 
picks finished 	arising way 
successfully cleanup removing 	use software 
git sequencer 	even advised 
directory verify conflict 	possibility 
resolved decide 	damage gnuc 
depending arguments fresh 	sun sort.c 
cherry pick 	zsl rank 
handled differently 	type pattern 
existing one continued 	pattern subst 
happens stdin 	spat 
called git cherry 	ssub keyobj 
pick commit 	prefixlen sublen 
cherry pick revert 	postfixlen fieldlen 
cherry pick 	cmp operations 
head revert head 	outputlen alpha 
touch sequencer 	start 
state means possible 	end vectorlen 
cherry pick 	getop convertion 
middle cherry pick 	error syntax 
sequence start 	error sortval 
cherry pick revert 	storekey vector 
sequence first 	leftargs 
make sure existing 	entry entry 
one isn 	ele zsl 
progress whole message 	ele rangelen 
buffer equal 	zsetlen setele 
sob pretend 	byval eptr 
found conforming footer 	sop 
matching sob 	val sobj 
buffer completely empty 	sop val 
foom title 	zmalloc incr 
body filled user 	count decoded 
incomplete line 	strchr decr 
complete line blank 	count 
one empty 	strstr sdslen 
line message body 	create sdslen 
sob buffer 	sdslen create 
contains single newline 	memcpy memcpy 
another room 	memcpy decr 
title body buffer 	count 
ends single 	lookup key 
newline another empty 	read hash 
line message 	type incr 
body sob 	count decr 
buffer already ends 	count decr 
two newlines 	count 
sequencer.h edit record 	decr count 
origin commit 	decr count 
signoff allow allow 	compare objects 
rerere allow 	compare objects 
empty allow empty 	strcoll compare 
message keep 	objects 
redundant commits mainline 	collate objects 
gpg sign 	lookup key 
strategy xopts xopts 	read reply 
xopts alloc 	list create 
revs opts sign 	list free 
header msgbuf 	method 
ignore footer flag 	incr count 
msgbuf options 	create quicklist 
merge strategy used 	strcasecmp strcasecmp 
replay none 	strcasecmp strcasecmp 
server-info.c path 	reply reply 
generate tmp ret 	strcasecmp 
path oid 	strcasecmp strchr 
flag data force 	reply error 
path ret 	strcasecmp reply 
old num num 	error list 
alloc heads 	node tail 
num pack objdir 	create 
objdirlen name 	sort operation 
line old cnt 	reply decr 
infofile line 	count list 
old cnt len 	release zset 
infofile force 	convert list 
stale force infofile 	type 
ret force 	length type 
errs mkpathdup safe 	size dict 
create leading 	size server 
directories git mkstemp 	panic zmalloc 
mode fdopen 	list type 
generate fclose 	init 
adjust shared perm 	iterator list 
rename error 	type length 
strerror fclose close 	list type 
unlink free 	next list 
parse oid hex 	type list 
deref tag 	type 
oid hex git 	release iterator 
pathdup update 	list type 
info file free 	init iterator 
strcmp find 	list type 
pack name fopen 	next list 
fgets strlen 	type 
parse pack def 	list type 
error fclose 	release iterator 
fclose directory strlen 	type init 
prepare packed 	iterator type 
git xcalloc xcalloc 	next type 
read pack 	release 
info file 	iterator dict 
qsort free free 	size zsl 
fputc mkpathdup 	element rank 
directory init pack 	zsl element 
info update 	rank server 
info file free 	info 
pack info 	dict iterator 
free update info 	dict next 
refs update 	dict key 
info packs unlink 	dict release 
warn git 	iterator server 
path create file 	panic 
path writing 	server info 
temporary file renaming 	lookup key 
place contents 	pattern decoded 
file come generate 	sds encoded 
non zero 	strtod isnan 
encounters error 	server 
packs skip pack 	info decr 
git objects 	count pqsort 
returns non zero 	qsort getop 
detect info 	reply error 
old file useless 	reply multi 
file describes 	bulk 
pack longer returns 	len reply 
non zero 	bulk list 
detect info old 	rewind list 
file useless 	next lookup 
nonexistent error name 	key pattern 
used emit 	reply 
misguided used emit 	reply bulk 
nobody uses 	decr count 
keep order original 	server info 
existed original 	create quicklist 
obviously newer way 	list type 
around matter 	push 
least keep 	list rewind 
comparison stable ignore 	list next 
things alternate 	lookup key 
path since available 	pattern create 
pullers general 	list type 
renumber would dumb 	push 
server support 	decr count 
files later including 	server info 
index available 	key notify 
pack files intended 	keyspace signal 
audiences leftover 	modified key 
rev cache file 	notify 
setenv.c name 	keyspace decr 
replace namelen valuelen 	count reply 
envstr oldval 	decr count 
strchr getenv strlen 	decr count 
strlen malloc 	list release 
memcpy memcpy putenv 	decr 
putenv makes 	count zfree 
argument part 	sort command 
environment changing modifies 	helper functions 
environment means 	copyright salvatore 
storage anymore free 	sanfilippo antirez 
envstr setup.c 	gmail 
inside git dir 	dot rights 
inside work 	reserved redistribution 
work config bogus 	use source 
unknown extensions 	binary forms 
path len wtlen 	without 
path work 	modification permitted 
prefix len remaining 	provided following 
prefix path 	conditions met 
orig sanitized prefix 	redistributions source 
len path 	code must 
prefix path len 	retain 
prefix arg 	copyright notice 
name prefix arg 	list conditions 
diagnose misspelt 	following disclaimer 
rev prefix 	redistributions binary 
arg diagnose misspelt 	form must 
rev prefix 	reproduce 
arg gitdir git 	copyright notice 
env common 	list conditions 
dir gitdir data 	following disclaimer 
path ret 	documentation materials 
suspect path ret 	provided distribution 
len path 	neither 
ret gitfile error 	name redis 
orig path 	names contributors 
len work git 	may used 
dir initialized 	endorse promote 
ext gitdir nongit 	products derived 
repo config 	software 
ret path error 	without specific 
code max 	prior written 
file size error 	permission software 
code buf 	provided copyright 
dir slash 	holders contributors 
len pathlen gitdirenv 	express 
cwd nongit 	implied warranties 
work env worktree 	including limited 
gitfile offset 	implied warranties 
core worktree gitdir 	merchantability fitness 
cwd offset 	particular purpose 
nongit cwd offset 	disclaimed 
nongit root 	shall copyright 
len gitdir cwd 	owner contributors 
nongit path 	liable direct 
prefix prefix len 	indirect incidental 
buf item 	special exemplary 
data empty entry 	consequential 
found ceil 	damages including 
real path nongit 	limited procurement 
env ceiling 	substitute goods 
dirs ceiling 	services loss 
dirs cwd gitdirenv 	use data 
ret gitfile 	profits 
offset offset parent 	business interruption 
ceil offset 	however caused 
current device one 	theory liability 
filesystem empty 	whether contract 
entry found parent 	strict liability 
device nongit 	tort 
prefix endptr ret 	including negligence 
suspect git 	otherwise arising 
work strlen strlen 	way use 
offset component 	software even 
strncmp memmove memmove 	advised possibility 
strcmp real 	damage 
path memmove strcmp 	qsort sort 
real path 	limit isnan 
absolute path xmallocz 	associated key 
strlen normalize 	name obtained 
path copy 	following rules 
len free abspath 	first 
part inside 	occurrence pattern 
repo free xstrfmt 	substituted subst 
normalize path 	pattern matches 
copy len free 	everything left 
prefix path 	arrow treated 
gently die strlen 	name 
prefix path 	hash field 
gently free starts 	part left 
prefix filename 	key name 
strlen lstat die 	containing hash 
errno die 	specified field 
isalnum maybe die 	returned 
misspelt name 	pattern function 
die die check 	simply returns 
filename wildcard 	subst sort 
die verify filename 	command used 
inside work 	like sort 
inside git 	key 
dir check filename 	retrieve list 
die getenv 	elements directly 
strbuf addstr common 	returned always 
dir noenv 	refcount increased 
strbuf addf file 	non pattern 
exists strbuf 	substitution 
read file die 	order implement 
errno strbuf 	sort feature 
reset absolute path 	substitution may 
strbuf addf 	specially encoded 
strbuf addbuf strbuf 	create decoded 
addstr real 	fly 
path strbuf addstr 	otherwise decoded 
strbuf release 	increment count 
strbuf release strbuf 	decrement later 
addf validate 	find pattern 
headref strbuf reset 	key make 
common dir 	sense 
getenv access 	find dealing 
getenv strbuf setlen 	hash dereference 
strbuf addstr 	perform substitution 
access strbuf setlen 	incremented decode 
strbuf addstr 	lookup substituted 
access strbuf release 	key 
strbuf complete 	retrieve hash 
strbuf addstr read 	field name 
gitfile gently 	operation already 
git directory strbuf 	increases refcount 
setlen inside 	returned every 
dir git dir 	function 
inside dir 	returns needs 
git work die 	refcount increased 
git work 	sort command 
git dir absolute 	decreases sort 
path real 	compare used 
path git 	qsort 
dir chdir die 	sort command 
getenv setenv 	given qsort 
git dir leading 	additional parameter 
path strcmp 	standard bsd 
git config strcmp 	specific pass 
git config 	sorting 
perm skip prefix 	parameters via 
strcmp strcmp 	server structure 
git config list 	numeric sorting 
append list 	trivial precomputed 
clear common dir 	scores objects 
strbuf addstr 	score 
git config early 	want comparison 
die warning 	undefined compare 
warning die warning 	objects lexicographically 
strbuf release 	way result 
stat isreg open 	sort deterministic 
xmallocz read 	alphanumeric 
full close 	sorting least 
starts absolute path 	one compare 
strrchr xstrfmt 	objects compare 
free git directory 	use strcoll 
real path 	directly sure 
die errno die 	objects 
die die 	decoded objects 
die die free 	compare elements 
getenv strlen 	directly sort 
die read gitfile 	command complex 
xstrdup git 	command redis 
directory free die 	warning 
check repository 	code optimized 
format gently free 	speed bit 
git work 	less readability 
warning git dir 	operation counter 
free absolute 	resulting vector 
path git work 	sort 
chdir die 	lookup key 
errno chdir 	sort must 
die errno xgetcwd 	right types 
chdir die 	create list 
errno git work 	operations perform 
free git 	every 
env git dir 	sorted element 
free git 	operations options 
work git work 	start argv 
strcmp git 	need protect 
dir free dir 	sortval incrementing 
inside git 	count 
dir real path 	future sort 
chdir die 	may options 
errno strbuf addch 	able overwrite 
free git 	keys sorting 
dir free check 	sorted key 
repository format 	may 
gently getenv absolute 	destroyed sort 
path xstrdup 	command sql 
real path 	alike syntax 
chdir die errno 	parse pattern 
setup git 	contain constant 
dir git dir 	need 
real path 	sort lookup 
chdir die errno 	weight keys 
git work 	specified real 
strcmp git dir 	patter accept 
strbuf addch 	cluster mode 
check repository format 	handle 
gently setenv 	syntax errors 
getenv xmemdupz chdir 	options parsing 
die errno 	sorting sort 
setup git dir 	specified must 
chdir die 	sort output 
errno offset component 	result 
strbuf setlen 	consistent across 
git dir 	scripting replication 
git dir die 	types list 
chdir die 	sorted retain 
errno stat die 	order even 
errno absolute 	sort 
path real path 	order requested 
valid free 	remain stable 
xstrdup getenv git 	across scripting 
config clear 	replication force 
strbuf getcwd die 	alpha sorting 
errno getenv 	destructively 
setup git dir 	convert encoded 
list split 	sorted sets 
filter list longest 	sort objtain 
ancestor length 	length sort 
list clear dos 	avoid gcc 
drive prefix 	warning 
git env device 	perform limit 
die read 	start count 
gitfile xstrdup 	sanity checking 
git directory setup 	whenever possible 
discovered git 	load elements 
dir free free 	output 
git directory 	direct way 
setup bare git 	possible sort 
dir setup 	sorted list 
nongit device die 	internally sorted 
chdir die 	nothing sort 
errno strbuf setlen 	dontsort 
die chdir 	constant special 
strbuf setlen die 	limit option 
errno setup 	actually reduces 
git directory gently 	number elements 
setenv setenv 	fetch also 
strcmp strcmp strcmp 	optimize 
strcmp strcmp 	load range 
strtol git config 	interested allocating 
die check 	vector big 
repo format 	enough selected 
strcmp git config 	range length 
strcmp config 	load 
error nonbool free 	sorting vector 
xstrdup check 	objects sort 
repository format gently 	special handling 
git dir 	list dontsort 
setup git directory 	makes sure 
gently git 	elements 
directory read gitfile 	list original 
open dup 	ordering accordingly 
die errno close 	desc asc 
fork die 	options note 
errno exit setsid 	also handle 
die errno 	limit 
close close close 	direct way 
sanitize stdfds 	getting required 
input parameter must 	range optimization 
contain absolute 	fix start 
path must 	end output 
already normalized find 	code 
part absolute 	aware optimization 
path lies inside 	special handling 
work dereferencing 	sorted dontsort 
symlinks outside work 	makes sure 
example dir 	elements sorted 
repo dir file 	original 
work dir 	ordering accordingly 
repo dir file 	desc asc 
dir file 	options note 
work dir file 	also handle 
dir symlink 	limit direct 
symlink symlink points 	way 
work symlink 	getting required 
dir repolink file 	range optimization 
repolink points 	check starting 
dir repo file 	point trivial 
dir repo 	log lookup 
exactly equal 	fix 
work empty check 	start end 
work already 	output code 
prefix work root 	aware optimization 
whole path 	time load 
work might match 	right scores 
beginning symlink 	sorting 
work check terminated 	vector lookup 
level check 	sort use 
whole path normalize 	sort need 
path prepending 	decode integer 
prefix relative paths 	encoded encoding 
remaining prefix 	supported 
actual prefix still 	far cast 
remains path 	retrieved lookup 
example prefix sub 	key pattern 
sub path 	refcount needs 
foo sub 	decreased send 
sub foo full 	command 
prefix foo 	output output 
sub foo remaining 	buffer performing 
prefix sub 	specified del 
bar bar remaining 	incr decr 
prefix sub 	operations store 
sub foo sub 	option 
sub foo 	specified sent 
remaining prefix pwd 	sorting result 
bar sub 	client always 
bar remaining prefix 	fails store 
root dir 	option specified 
always exists file 	sorting 
exists file 	result list 
exist saying icase 	list type 
foo exist 	push incr 
index user gave 	count take 
icase foo 	care care 
stupid magic 	incremented 
pathspec begins colon 	refcount caused 
followed non 	either lookup 
alnum maybe die 	key pattern 
misspelt name 	create always 
even trigger fall 	fails cleanup 
back general 	sparkline.c 
message verify filename 	charset charset 
got argument 	fill charset 
pathspec entry note 	len label 
filename begins 	margin top 
never verifies even 	seq seq 
filename exist 	label 
want preceded marker 	seq output 
want user 	seq rows 
use format like 	offset len 
filename diagnose 	flags relmax 
misspelt rev used 	steps row 
provide user 	chars 
friendly diagnosis 	loop opt 
dying upon finding 	fill opt 
name pathname 	log relval 
diagnosis diagnose name 	step charidx 
invalid name 	label len 
head foo diagnosis 	label 
complain inexisting 	output seq 
file function typically 	columns rows 
called check 	flags sublen 
file rev argument 	zmalloc zstrdup 
unambiguous caller 	zrealloc zfree 
want diagnose misspelt 	zfree 
rev verifying 	zfree zmalloc 
first non rev 	log memset 
argument could 	log strlen 
revision diagnose misspelt 	sdscatlen sdscatlen 
rev next 	zfree sdscatlen 
ones already saw 	sparkline 
filename ambiguity 	render range 
anymore opposite 	sparkline ascii 
command line marker 	sparklines code 
parsed arg 	modified http 
refname interpretable filename 	github antirez 
flag test 	aspark 
looks like git 	adapted order 
directory want 	sds instead 
see either objects 	outputting directly 
directory proper 	terminal copyright 
git directory environment 	salvatore sanfilippo 
variable refs 	antirez 
directory either head 	gmail rights 
symlink head 	reserved redistribution 
file formatted proper 	use source 
regular file 	binary forms 
head properly formatted 	without modification 
sha name 	permitted 
check worktree 	provided following 
related signatures check 	conditions met 
non worktree 	redistributions source 
related signatures make 	code must 
sure subsequent 	retain copyright 
git processes find 	notice 
correct worktree 	list conditions 
git work relative 	following disclaimer 
record known 	redistributions binary 
extensions otherwise fall 	form must 
recording unknown 	reproduce copyright 
check repository format 	notice 
complain git 	list conditions 
config used calls 	following disclaimer 
git pathdup 	documentation materials 
git config config 	provided distribution 
call make 	software provided 
setup git env 	copyright 
git dir 	holders contributors 
git gitdir 	express implied 
setup git dir 	warranties including 
found useable 	limited implied 
yet use gentler 	warranties merchantability 
version git 	fitness 
config check repo 	particular purpose 
good one 	disclaimed shall 
read location git 	copyright owner 
directory git 	contributors liable 
file path git 	direct indirect 
directory found 	incidental 
failure error code 	special exemplary 
error code 	consequential damages 
error code returned 	including limited 
error code 	procurement substitute 
function die instead 	goods services 
cases non 	loss 
fatal follow path 	use data 
see git 	profits business 
work must 	interruption however 
called git work 	caused theory 
cwd already 	liability whether 
normalized cwd worktree 	contract 
cwd inside 	strict liability 
worktree cwd outside 	tort including 
worktree work 	negligence otherwise 
without git dir 	arising way 
use discovered 	use software 
one see make 	even 
offset point 	advised possibility 
past end see 	damage charset 
work without 	used display 
git dir use 	graphs multiple 
discovered one 	rows used 
list func function 	increase 
canonicalizes entry 	resolution sequences 
git ceiling directories 	arrays samples 
real path 	use represent 
valid discards 	data turn 
unusable presence empty 	sparklines api 
entry git 	order 
ceiling directories turns 	generate sparkline 
canonicalization subsequent 	sequence seq 
entries keep entry 	create sparkline 
canonicalize cannot 	sequence sparkline 
decide function whether 	sequence sample 
work since 	seq 
config read function 	sparkline sequence 
called may 	sample seq 
read incomplete configuration 	sparkline sequence 
setting git 	sample seq 
directory clear cache 	last 
next queries 	sample label 
configuration reload complete 	sds output 
configuration including 	sparkline render 
per repo 	sdsempty seq 
config file ignored 	sparkline fill 
previously git 	free 
repository turns later 	sparkline sequence 
somewhere updated 	seq create 
accordingly git dir 	sequence sample 
explicitly going 	sequence free 
discovery still repository 	sequence ascii 
validation test 	rendering 
following order relative 	sequence render 
cwd git 	part sequence 
file containing gitdir 	render sequence 
path git 	call call 
bare git git 	function differnent 
bare git 	parts 
etc parse octal 	order create 
numbers octal 	full output 
number maybe treat 	without overflowing 
values compatibility 	current terminal 
cases otherwise 	columns print 
chmod restrict filemode 	character 
given xxx 	needed create 
mask filemode others 	sparkline labels 
write permission 	spacing print 
flags directories handled 	label needed 
separately returns 	turn sequence 
prefix path current 	ascii 
working directory 	representation sparkline.h 
relative work root 	label length 
current working 	labels samples 
directory strict subdirectory 	min max 
work root 	seq label 
prefix always ends 	seq 
character standard 	output seq 
file descriptor missing 	rows offset 
open dev 	len flags 
sh-i18n--envsubst.c variables argc 	output seq 
argv callback 	columns rows 
variable start 	flags 
variable end valid 	sparkline ascii 
ptr len 	sparklines header 
item nitems nitems 	file copyright 
max slp 	salvatore sanfilippo 
slp pstr pstr 	antirez gmail 
str str 	rights 
slp slp result 	reserved redistribution 
variables ptr 	use source 
len buffer bufmax 	binary forms 
buflen opening 	without modification 
brace closing brace 	permitted provided 
valid env 	following 
error note variables 	conditions met 
subst stdin 	redistributions source 
strcmp error print 	code must 
variables error 	retain copyright 
ferror fflush fclose 	notice list 
exit fclose 	conditions 
exit exit 	following disclaimer 
callback fwrite putchar 	redistributions binary 
find variables 	form must 
realloc strcmp qsort 	reproduce copyright 
strcmp strcmp 	notice list 
xmemdupz list append 	conditions 
list init 	following disclaimer 
find variables list 	documentation materials 
sort getc 	provided distribution 
ferror error ungetc 	software provided 
getc getc 	copyright holders 
getc xrealloc getc 	contributors 
ungetc ungetc 	express implied 
xrealloc sorted list 	warranties including 
member getenv 	limited implied 
fputs putchar putchar 	warranties merchantability 
fwrite putchar 	fitness particular 
ungetc putchar putchar 	purpose 
putchar envsubst 	disclaimed shall 
stripped version 	copyright owner 
gettext envsubst copyright 	contributors liable 
arnfj bjarmason 	direct indirect 
modified version gettext 	incidental special 
runtime src 	exemplary 
envsubst gettext git 	consequential damages 
repository stripped 	including limited 
implement envsubst features 	procurement substitute 
need git 	goods services 
fallbacks close standard 	loss use 
error part 	data 
main dac gnulib 	profits business 
local lib 	interruption however 
closeout copyright notices 	caused theory 
files reproduced 	liability whether 
immediately substitution environment 	contract strict 
variables shell 	liability 
format copyright 	tort including 
free software foundation 	negligence otherwise 
inc written 	arising way 
bruno haible bruno 	use software 
clisp program 	even advised 
free software redistribute 	possibility 
modify terms 	damage sequence 
gnu general license 	represented many 
published free 	samples fill 
software foundation either 	area curve 
version option 	use logarithmic 
later version program 	scale 
distributed hope 	sparkline stats.c 
useful without warranty 	opt stats 
without even 	print stats 
implied warranty merchantability 	cactive write 
fitness particular 	cbopaque write 
purpose see gnu 	cbopaque 
general license 	write cbopaque 
details received 	write cbopaque 
copy gnu general 	bins large 
license along 	huge write 
program write free 	cbopaque page 
software foundation 	config 
inc franklin street 	tcache gap 
fifth floor 	nbins nruns 
boston usa closeout 	reg size 
close standard 	run size 
output standard error 	curregs availregs 
copyright free 	milli 
software foundation inc 	curruns nregs 
program free 	nmalloc ndalloc 
software redistribute modify 	nrequests nfills 
terms gnu 	nflushes reruns 
general license published 	write cbopaque 
free software 	nbins 
foundation either version 	nlruns gap 
option later 	nmalloc ndalloc 
version program 	nrequests run 
distributed hope useful 	size curruns 
without warranty 	write cbopaque 
without even implied 	nbins 
warranty merchantability 	nlruns nhchunks 
fitness particular purpose 	gap nmalloc 
see gnu 	ndalloc nrequests 
general license details 	hchunk size 
received copy 	curhchunks write 
gnu general license 	cbopaque 
along program 	bins large 
write free software 	huge nthreads 
foundation inc 	dss dirty 
franklin street fifth 	mult page 
floor boston 	pactive pdirty 
usa substitution shall 	mapped 
performed variables 	metadata mapped 
forward declaration local 	metadata allocated 
functions values 	npurge nmadvise 
command line 	purged small 
options show variables 	allocated small 
variables subst 	nmalloc 
stdin echo foo 	small ndalloc 
bar git 	small nrequests 
envsubst variables foo 	large allocated 
bar git 	large nmalloc 
envsubst variables foo 	large ndalloc 
bar show 	large 
variables close standard 	nrequests huge 
error simpler 	allocated huge 
fwriteerror ebadf upon 	nmalloc huge 
failure need 	ndalloc huge 
errno point exit 	nrequests write 
status parse 	cbopaque 
invoke callback time 	opts err 
variable variable 	epoch general 
construct seen 	merged unmerged 
variable nonempty sequence 	bins large 
ascii alphanumeric 	huge cpv 
underscore characters starting 	ssv 
ascii alphabetic 	bsz ssz 
underscore character allow 	sssz cpsz 
ascii characters 	cactive allocated 
avoid dependencies current 	active metadata 
encoding looks 	resident mapped 
like variable access 	narenas 
iso encoding 	isz ninitialized 
doesn look like 	narenas isz 
one big 	ctl ctl 
big hkscs gbk 	malloc cprintf 
shift jis 	malloc cprintf 
johab encodings single 	ctl 
character encodings 	ctl malloc 
print variable stdout 	cprintf ctl 
followed newline 	ctl ctl 
print variables 	ctl ctl 
contained stdout one 	ctl ctl 
followed newline 	ctl 
type describing list 	ctl ctl 
immutable implemented 	ctl malloc 
initialize empty list 	snprintf malloc 
append single 	snprintf malloc 
end list grow 	snprintf malloc 
list end 	snprintf 
list compare two 	malloc cprintf 
given reference 	malloc cprintf 
sort list test 	malloc cprintf 
whether sorted 	malloc cprintf 
list contains given 	ctl ctl 
binary search 	ctl 
know list index 	ctl ctl 
variables perform 	ctl ctl 
substitution used variables 	malloc cprintf 
adds variable 	malloc cprintf 
variables stores 	malloc cprintf 
variables occurring variables 	malloc 
copies stdin 	cprintf ctl 
stdout performing substitutions 	ctl ctl 
look variable 	ctl ctl 
variable accumulate variable 	ctl ctl 
buffer terminate 	ctl malloc 
variable buffer test 	cprintf 
whether variable 	malloc cprintf 
shall substituted substitute 	malloc cprintf 
variable environment 	ctl ctl 
perform substitution since 	malloc cprintf 
buffered input 	ctl malloc 
contains start output 	cprintf 
buffered contents 	ctl malloc 
sha1-array.c sha index 	cprintf malloc 
table sha 	cprintf ctl 
data alloc grow 	ctl ctl 
hashcpy hashcmp 	ctl ctl 
qsort sha 	malloc 
sort sha pos 	cprintf malloc 
free sha 	cprintf ctl 
sort hashcmp sha1-array.h 	ctl ctl 
alloc sorted 	ctl malloc 
sha sha data 	cprintf ctl 
sha sha1-chunked.c 	ctl 
data len total 	ctl ctl 
cdata platform 	malloc cprintf 
sha update sha1-chunked.h 	ctl ctl 
data len 	ctl ctl 
sha1-lookup.c sha sha 	malloc cprintf 
table lov 	malloc 
hiv miv ofs 	cprintf malloc 
cmp table 	cprintf ctl 
elem size key 	malloc cprintf 
offset key 	ctl ctl 
key key 	malloc cprintf 
ofs debug lookup 	stats 
cmp ofs 	arena bins 
range lov hiv 	print stats 
kyv key 	arena lruns 
take take take 	print stats 
die hashcmp 	arena hchunks 
getenv memcmp die 	print 
sha hex 	mallctl malloc 
memcmp conventional binary 	write malloc 
search loop 	write abort 
looks like cmp 	malloc cprintf 
entry pointed 	ctl malloc 
minus target cmp 	cprintf 
wanted one 	ctl malloc 
cmp larger target 	cprintf malloc 
smaller target 	cprintf malloc 
invariants entering loop 	cprintf ctl 
points slot 	malloc cprintf 
never target 	malloc 
could target points 	cprintf ctl 
slot guaranteed 	malloc cprintf 
target never target 	ctl malloc 
find point 	cprintf ctl 
could never check 	malloc cprintf 
hits target 	malloc 
three cases hit 	cprintf mallctl 
happy strictly 	malloc cprintf 
higher target update 	mallctl ctl 
strictly lower 	malloc cprintf 
target update one 	ctl malloc 
slot allow 	cprintf 
target choosing take 	malloc cprintf 
middle anywhere 	ctl malloc 
satisfied somehow know 	cprintf ctl 
distance target 	ctl ctl 
much shorter target 	ctl ctl 
could pick 	ctl 
much closer 	malloc cprintf 
midway table contain 	malloc cprintf 
elements sha 	atomic read 
element returned table 	ctl variable 
point miv 	xmallctl malloc 
could equal hiv 	cprintf 
sha could 	stats arena 
still higher invariant 	print ctl 
kept conventional 	variable xmallctl 
binary search loop 	malloc cprintf 
looks like 	stats arena 
cmp entry pointed 	print 
minus target 	malloc cprintf 
cmp wanted one 	data function 
cmp larger 	prototypes non 
target smaller target 	functions yyy 
invariants entering 	refresh stats 
loop points slot 	mallctl 
never target 	called application 
could target 	check oom 
points slot guaranteed 	since refreshing 
target never 	ctl cache 
target find point 	trigger allocation 
could never 	practice 
check hits target 	none subsequent 
three cases 	mallctl related 
hit happy strictly 	calls function 
higher target 	cause oom 
repeat search strictly 	one succeeds 
lower target 	print 
update one slot 	merged arena 
allow target 	stats print 
loop exits matching 	stats arena 
entry choosing 	lazy locking 
take middle anywhere 	would dodge 
satisfied somehow 	tcache 
know distance target 	testing cactive 
much shorter 	allocated active 
target could 	resident mapped 
pick much closer 	expected epoch 
midway take 	allocated nmalloc 
advantage fact sha 	ndalloc 
good hash 	nrequests expected 
function enough entries 	arena little 
table expect 	large huge 
uniform distribution entry 	epoch expected 
begins example 	mapped npurge 
deadbeef much likely 	nmadvise 
appear much 	purged arg 
later midway table 	thd arena 
reasonably expected 	allocated epoch 
near top table 	nmalloc ndalloc 
however want 	nrequests expected 
pick precisely entry 	arena 
example turns 	allocated epoch 
higher target 	nmalloc ndalloc 
looking would end 	nrequests expected 
narrowing search 	arena allocated 
space instead would 	epoch nmalloc 
simple binary 	ndalloc 
search would want 	expected arena 
hedge bets 	curruns curregs 
less aggressive table 	epoch nmalloc 
table holds 	ndalloc nrequests 
least entries elem 	nfills nflushes 
size bytes 	nruns 
entry sha key 	nreruns expected 
key offset 	arena epoch 
table sorted sha 	nmalloc ndalloc 
key entries 	nrequests curruns 
caller wants find 	expected arena 
entry key 	epoch 
knows entry higher 	nmalloc ndalloc 
entry looking 	curhchunks expected 
entry higher 	mallctl mallctl 
entry looking thru 	mallctl mallctl 
ofs ofs 	mallctl mallocx 
first different ofs 	ptr 
bytes different 	mallctl mallctl 
meaning entries duplicate 	mallctl mallctl 
keys know 	mallctl dallocx 
solid run entry 	mallctl mallocx 
entries sorted 	ptr mallocx 
nothing single key 	ptr 
stop search 	mallocx ptr 
either one entries 	mallctl mallctl 
care furthermore 	mallctl mallctl 
know one endpoints 	mallctl mallctl 
must edge 	dallocx dallocx 
run duplicates example 	dallocx 
given sequence 	thd create 
idx key searching 	thd lazy 
might hit 	mallctl mallocx 
duplicate run 	ptr mallctl 
first never key 	mallctl mallctl 
less run 	mallctl 
know edge say 	mallctl mallctl 
nothing similarly 	dallocx mallctl 
key greater run 	mallocx ptr 
know edge 	mallctl mallctl 
say nothing therefore 	mallctl mallctl 
find also 	mallctl 
know would exist 	dallocx mallctl 
far side 	mallocx ptr 
edge know even 	mallctl mallctl 
know target 	mallctl mallctl 
much closer pick 	dallocx mallctl 
precisely overshoot 	mallocx 
know closer pick 	ptr mallctl 
higher target 	mallctl mallctl 
end narrowing search 	mallctl mallctl 
space smaller 	mallctl mallctl 
amount distance 	mallctl mallctl 
would half hedge 	mallctl 
bets pick 	mallctl dallocx 
less aggressively make 	mallctl mallocx 
bit closer 	ptr mallctl 
middle would otherwise 	mallctl mallctl 
pick sha1-lookup.h 	mallctl mallctl 
sha table table 	dallocx 
elem size 	mallctl mallocx 
key offset key 	ptr mallctl 
sha1.c ctx 	mallctl mallctl 
block ctx ctx 	mallctl dallocx 
data len 	test data 
len left hashout 	function 
ctx pad 	prototypes non 
padlen memcpy blk 	functions yyy 
sha block 	refresh stats 
blk sha 	mallctl called 
block memcpy htonl 	application check 
htonl blk 	oom 
sha update blk 	since refreshing 
sha update 	ctl cache 
put sha routine 	trigger allocation 
optimized word 	practice none 
accesses rather accesses 	subsequent mallctl 
avoid unnecessary 	related 
copies context initially 	calls function 
mozilla sha 	cause oom 
implementation although none 	one succeeds 
original mozilla 	print merged 
code remains definitions 	arena stats 
memcpy ntohl 	print 
htonl force usage 	stats arena 
rol ror 	lazy locking 
selecting one smaller 	would dodge 
constant generate 	tcache testing 
slightly smaller 	stats.c opt 
code constant special 	stats 
perhaps importantly 	print stats 
possibly faster uarch 	cactive write 
rotate loop 	cbopaque write 
registers compiler change 	cbopaque write 
accesses registers 	cbopaque 
however machines less 	write cbopaque 
registers won 	bins large 
really work least 	huge write 
gcc make 	cbopaque page 
unholy mess avoid 	config tcache 
mess slows 	gap 
things force stores 	nbins nruns 
memory actually 	reg size 
happen might better 	run size 
val asm 	curregs availregs 
instead suggested artur 	milli curruns 
skawina also 	nregs 
make gcc 	nmalloc ndalloc 
unable silly optimize 	nrequests nfills 
away loads 	nflushes reruns 
part won see 	write cbopaque 
ben herrenschmidt 	nbins nlruns 
reports ppc version 	gap 
comes close 	nmalloc ndalloc 
optimized asm ppc 	nrequests run 
want since 	size curruns 
lots registers arm 	write cbopaque 
best code 	nbins nlruns 
generation forcing full 	nhchunks 
memory barrier 	gap nmalloc 
sha round otherwise 	ndalloc nrequests 
gcc happily 	hchunk size 
wild spilling stack 	curhchunks write 
frame size 	cbopaque bins 
simply explode performance 	large 
goes drain 	huge nthreads 
rolls bit 	dss dirty 
source first iterations 	mult page 
input data 	pactive pdirty 
next mix bit 	mapped metadata 
round iterations 	mapped 
take input block 	metadata allocated 
round tail 	npurge nmadvise 
input bit mixing 	purged small 
round round 	allocated small 
round initialize magic 	nmalloc small 
constants see 	ndalloc 
fips constants read 	small nrequests 
data process 	large allocated 
blocks full pad 	large nmalloc 
binary zeroes 	large ndalloc 
length output hash 	large nrequests 
sha implementation 	huge 
copyright paul mackerras 	allocated huge 
paulus samba 	nmalloc huge 
version assumes 	ndalloc huge 
running big endian 	nrequests write 
machine calls 	cbopaque opts 
external sha core 	err 
process blocks 	epoch general 
bytes hash nblocks 	merged unmerged 
ptr hash 	bins large 
cnt memcpy ppc 	huge cpv 
sha core 	ssv bsz 
ppc sha core 	ssz 
memset ppc 	sssz cpsz 
sha core memset 	cactive allocated 
ppc sha 	active metadata 
core memcpy sha 	resident mapped 
routine optimized 	narenas isz 
word accesses rather 	ninitialized 
accesses avoid 	narenas isz 
unnecessary copies 	ctl ctl 
context initially mozilla 	malloc cprintf 
sha implementation 	malloc cprintf 
although none original 	ctl ctl 
mozilla code 	malloc 
remains definitions memcpy 	cprintf ctl 
ntohl htonl 	ctl ctl 
force usage rol 	ctl ctl 
ror selecting 	ctl ctl 
one smaller constant 	ctl ctl 
generate slightly 	ctl 
smaller code constant 	ctl malloc 
special perhaps 	snprintf malloc 
importantly possibly faster 	snprintf malloc 
uarch rotate 	snprintf malloc 
loop registers compiler 	snprintf malloc 
change accesses 	cprintf 
registers however machines 	malloc cprintf 
less registers 	malloc cprintf 
won really 	malloc cprintf 
work least gcc 	ctl ctl 
make unholy 	ctl ctl 
mess avoid mess 	ctl 
slows things 	ctl ctl 
force stores memory 	malloc cprintf 
actually happen 	malloc cprintf 
might better val 	malloc cprintf 
asm instead 	malloc cprintf 
suggested artur skawina 	ctl 
also make 	ctl ctl 
gcc unable silly 	ctl ctl 
optimize away 	ctl ctl 
loads part won 	ctl malloc 
see ben 	cprintf malloc 
herrenschmidt reports ppc 	cprintf 
version comes 	malloc cprintf 
close optimized asm 	ctl ctl 
ppc want 	malloc cprintf 
since lots 	ctl malloc 
registers arm best 	cprintf ctl 
code generation 	malloc 
forcing full memory 	cprintf malloc 
barrier sha 	cprintf ctl 
round otherwise gcc 	ctl ctl 
happily wild 	ctl ctl 
spilling stack frame 	malloc cprintf 
size simply 	malloc 
explode performance goes 	cprintf ctl 
drain rolls 	ctl ctl 
bit source first 	ctl malloc 
iterations input 	cprintf ctl 
data next mix 	ctl ctl 
bit round 	ctl 
iterations take input 	malloc cprintf 
block round 	ctl ctl 
tail input bit 	ctl ctl 
mixing round 	malloc cprintf 
round round 	malloc cprintf 
initialize magic constants 	malloc 
see fips 	cprintf ctl 
constants read data 	malloc cprintf 
process blocks 	ctl ctl 
full pad binary 	malloc cprintf 
zeroes length 	stats arena 
output hash sha 	bins 
implementation copyright 	print stats 
paul mackerras paulus 	arena lruns 
samba version 	print stats 
assumes running big 	arena hchunks 
endian machine 	print mallctl 
calls external sha 	malloc 
core process 	write malloc 
blocks bytes sha1.c 	write abort 
ctx block 	malloc cprintf 
ctx ctx 	ctl malloc 
data len len 	cprintf ctl 
left hashout 	malloc 
ctx pad padlen 	cprintf malloc 
memcpy blk 	cprintf malloc 
sha block blk 	cprintf ctl 
sha block 	malloc cprintf 
memcpy htonl htonl 	malloc cprintf 
blk sha 	ctl 
update blk sha 	malloc cprintf 
update put 	ctl malloc 
sha routine optimized 	cprintf ctl 
word accesses 	malloc cprintf 
rather accesses avoid 	malloc cprintf 
unnecessary copies 	mallctl 
context initially mozilla 	malloc cprintf 
sha implementation 	mallctl ctl 
although none original 	malloc cprintf 
mozilla code 	ctl malloc 
remains definitions 	cprintf malloc 
memcpy ntohl htonl 	cprintf 
force usage 	ctl malloc 
rol ror selecting 	cprintf ctl 
one smaller 	ctl ctl 
constant generate slightly 	ctl ctl 
smaller code 	ctl malloc 
constant special perhaps 	cprintf 
importantly possibly 	malloc cprintf 
faster uarch rotate 	atomic read 
loop registers 	ctl variable 
compiler change accesses 	xmallctl malloc 
registers however 	cprintf stats 
machines less registers 	arena 
won really 	print ctl 
work least gcc 	variable xmallctl 
make unholy 	malloc cprintf 
mess avoid mess 	stats arena 
slows things 	print malloc 
force stores 	cprintf 
memory actually happen 	data function 
might better 	prototypes non 
val asm instead 	functions yyy 
suggested artur 	refresh stats 
skawina also make 	mallctl called 
gcc unable 	application 
silly optimize away 	check oom 
loads part 	since refreshing 
won see ben 	ctl cache 
herrenschmidt reports 	trigger allocation 
ppc version comes 	practice none 
close optimized 	subsequent 
asm ppc want 	mallctl related 
since lots 	calls function 
registers arm best 	cause oom 
code generation 	one succeeds 
forcing full memory 	print merged 
barrier sha 	arena 
round otherwise 	stats print 
gcc happily wild 	stats arena 
spilling stack 	lazy locking 
frame size simply 	would dodge 
explode performance 	tcache testing 
goes drain rolls 	cactive 
bit source 	allocated active 
first iterations input 	resident mapped 
data next 	expected epoch 
mix bit round 	allocated nmalloc 
iterations take 	ndalloc nrequests 
input block round 	expected 
tail input 	arena little 
bit mixing round 	large huge 
round round 	epoch expected 
initialize magic constants 	mapped npurge 
see fips 	nmadvise purged 
constants read 	arg 
data process blocks 	thd arena 
full pad 	allocated epoch 
binary zeroes length 	nmalloc ndalloc 
output hash 	nrequests expected 
sha implementation copyright 	arena allocated 
paul mackerras 	epoch 
paulus samba version 	nmalloc ndalloc 
assumes running 	nrequests expected 
big endian machine 	arena allocated 
calls external 	epoch nmalloc 
sha core process 	ndalloc expected 
blocks bytes 	arena 
hash nblocks ptr 	curruns curregs 
hash cnt 	epoch nmalloc 
memcpy ppc sha 	ndalloc nrequests 
core ppc 	nfills nflushes 
sha core memset 	nruns nreruns 
ppc sha 	expected 
core memset 	arena epoch 
ppc sha core 	nmalloc ndalloc 
memcpy sha 	nrequests curruns 
routine optimized word 	expected arena 
accesses rather 	epoch nmalloc 
accesses avoid unnecessary 	ndalloc 
copies context 	curhchunks expected 
initially mozilla sha 	mallctl mallctl 
implementation although 	mallctl mallctl 
none original mozilla 	mallctl mallocx 
code remains 	ptr mallctl 
definitions memcpy ntohl 	mallctl 
htonl force 	mallctl mallctl 
usage rol ror 	mallctl dallocx 
selecting one 	mallctl mallocx 
smaller constant generate 	ptr mallocx 
slightly smaller 	ptr mallocx 
code constant special 	ptr 
perhaps importantly 	mallctl mallctl 
possibly faster 	mallctl mallctl 
uarch rotate loop 	mallctl mallctl 
registers compiler 	dallocx dallocx 
change accesses registers 	dallocx thd 
however machines 	create 
less registers won 	thd lazy 
really work 	mallctl mallocx 
least gcc make 	ptr mallctl 
unholy mess 	mallctl mallctl 
avoid mess slows 	mallctl mallctl 
things force 	mallctl 
stores memory actually 	dallocx mallctl 
happen might 	mallocx ptr 
better val asm 	mallctl mallctl 
instead suggested 	mallctl mallctl 
artur skawina also 	mallctl dallocx 
make gcc 	mallctl 
unable silly optimize 	mallocx ptr 
away loads 	mallctl mallctl 
part won 	mallctl mallctl 
see ben herrenschmidt 	dallocx mallctl 
reports ppc 	mallocx ptr 
version comes close 	mallctl 
optimized asm 	mallctl mallctl 
ppc want since 	mallctl mallctl 
lots registers 	mallctl mallctl 
arm best code 	mallctl mallctl 
generation forcing 	mallctl mallctl 
full memory barrier 	dallocx 
sha round 	mallctl mallocx 
otherwise gcc happily 	ptr mallctl 
wild spilling 	mallctl mallctl 
stack frame size 	mallctl mallctl 
simply explode 	dallocx mallctl 
performance goes drain 	mallocx 
rolls bit 	ptr mallctl 
source first iterations 	mallctl mallctl 
input data 	mallctl dallocx 
next mix 	test data 
bit round iterations 	function prototypes 
take input 	non 
block round tail 	functions yyy 
input bit 	refresh stats 
mixing round round 	mallctl called 
round initialize 	application check 
magic constants see 	oom since 
fips constants 	refreshing 
read data process 	ctl cache 
blocks full 	trigger allocation 
pad binary zeroes 	practice none 
length output 	subsequent mallctl 
hash sha implementation 	related calls 
copyright paul 	function 
mackerras paulus samba 	cause oom 
version assumes 	one succeeds 
running big 	print merged 
endian machine calls 	arena stats 
external sha 	print stats 
core process blocks 	arena 
bytes sha1.h 	lazy locking 
ctx ctx data 	would dodge 
len hashout 	tcache testing 
ctx sha routine 	stats.h nrequests 
optimized word 	nmalloc ndalloc 
accesses rather accesses 	nrequests 
avoid unnecessary 	curregs nfills 
copies context initially 	nflushes nruns 
mozilla sha 	reruns curruns 
implementation although none 	nmalloc ndalloc 
original mozilla 	nrequests curruns 
code remains sha 	nmalloc 
implementation copyright 	ndalloc curhchunks 
paul mackerras paulus 	mapped npurge 
samba hash 	nmadvise purged 
sha routine 	metadata mapped 
optimized word accesses 	metadata allocated 
rather accesses 	allocated 
avoid unnecessary copies 	large nmalloc 
context initially 	large ndalloc 
mozilla sha implementation 	large nrequests 
although none 	large allocated 
original mozilla code 	huge nmalloc 
remains sha 	huge 
implementation copyright paul 	ndalloc huge 
mackerras paulus 	lstats hstats 
samba sha1.h ctx 	opt stats 
ctx data 	print stats 
len hashout ctx 	cactive write 
sha routine 	cbopaque 
optimized word accesses 	opts size 
rather accesses 	size size 
avoid unnecessary copies 	size atomic 
context initially 	read atomic 
mozilla sha 	atomic sub 
implementation although none 	jemalloc 
original mozilla 	types number 
code remains sha 	allocation requests 
implementation copyright 	corresponded size 
paul mackerras paulus 	bin total 
samba hash 	number allocation 
sha routine optimized 	deallocation 
word accesses 	requests served 
rather accesses avoid 	directly bin 
unnecessary copies 	note tcache 
context initially mozilla 	may allocate 
sha implementation 	recycle many 
although none original 	times 
mozilla code 	resulting many 
remains sha implementation 	increments nrequests 
copyright paul 	one nmalloc 
mackerras paulus samba 	ndalloc number 
sha1 filec 	allocation requests 
sha oid 	correspond 
sha buf size 	size bin 
cached cached 	includes requests 
alloc empty last 	served tcache 
found pack 	though tcache 
sha path saved 	periodically merges 
errno path 	counter 
buf pathbuf sha 	current number 
hex val 	regions size 
pos sha buf 	including regions 
objdir len 	currently cached 
sha buf sha 	tcache number 
buf sha 	tcache 
buf alt odb 	fills bin 
list alt 	number tcache 
odb tail entry 	flushes bin 
relative depth 	total number 
normalized objdir 	runs created 
ent alt pfxlen 	bin 
entlen pathbuf 	size total 
alt len sep 	number runs 
relative depth 	reused extracting 
entries alt copy 	runs bin 
objdirbuf entry 	size current 
relative depth map 	number 
mapsz path 	runs bin 
reference alts line 	total number 
found ent 	allocation deallocation 
alt freshen sha 	requests served 
freshen sha 	directly arena 
freshen alt sha 	note 
freshen sha 	tcache may 
sha pack used 	allocate recycle 
ctr pack 	many times 
mmap calls peak 	resulting many 
pack open 	increments nrequests 
windows pack 	one 
open windows pack 	nmalloc ndalloc 
open fds 	number allocation 
pack max fds 	requests correspond 
peak pack 	size includes 
mapped pack mapped 	requests served 
packed git 	tcache 
path idx map 	though tcache 
hdr idx 	periodically merges 
size version index 	counter current 
min size 	number runs 
max size idx 	size including 
name len 	runs 
ret lru lru 	currently cached 
lru current 	tcache total 
lru lru need 	number allocation 
cur length 	deallocation requests 
limit start length 	served directly 
prot flags 	arena 
offset ret 	current number 
start length prot 	multi chunk 
flags offset 	allocations size 
ret lru mru 	number bytes 
accept windows 	currently mapped 
inuse mru windows 	total 
inuse lru 	number purge 
mru accept windows 	sweeps total 
inuse cursor 	number madvise 
pack name lim 	calls made 
open max 	total pages 
hdr sha idx 	purged 
sha flag 	order keep 
max fds win 	dirty unused 
offset win 	memory control 
cursor offset left 	number bytes 
win window 	currently 
align len extra 	mapped purely 
size path 	metadata purposes 
path len 	number bytes 
local free routine 	currently allocated 
alloc sha 	metadata via 
idx path path 	atomic 
alloc pack 	per size 
seen bits path 	category statistics 
list seen 	one element 
bits first last 	large size 
list seen 	one element 
bits path dot 	huge 
objdir local 	size jemalloc 
path dirnamelen dir 	structs jemalloc 
garbage len 	externs jemalloc 
len ary prepare 	inlines stdbool.h 
packed git 	msvc doesn 
run alt sha 	define 
sha sha 	note doesn 
map size 	pass autoconf 
type real sha 	test clang 
hdr hdrlen 	uses msvc 
buf readlen name 	headers needs 
sha file 	msvc 
open flag sha 	compat built 
alt sha 	type stdbool 
alt interesting errno 	stdint.h iso 
sha size 	compliant stdint 
map unpack header 	microsoft visual 
buffer stream 	studio 
map mapsize buffer 	iso iec 
bufsiz stream 	committee draft 
map mapsize buffer 	may copyright 
bufsiz header 	alexander chemeris 
status stream buffer 	redistribution use 
size sha 	source 
bytes buf status 	binary forms 
hdr flags 	without modification 
type buf 	permitted provided 
size type type 	following conditions 
len hdr 	met redistributions 
sizep unpack sha 	source 
file curs 	code must 
curpos data delta 	retain copyright 
head stream 	notice list 
delta delta sha 	conditions following 
curs curpos 	disclaimer redistributions 
sizep left used 	binary 
obj offset 	form must 
type revidx sha 	reproduce copyright 
obj offset 	notice list 
curs size curpos 	conditions following 
tmp pos 	disclaimer documentation 
offset revidx curs 	materials 
curpos size 	provided distribution 
stream buffer delta 	name author 
cached prev 	may used 
next lru 	endorse promote 
data offset size 	products derived 
offset hash 	software 
offset hash ent 	without specific 
offset offset 	prior written 
ent ent cache 	permission software 
unpack entry 	provided author 
ent delta cache 	express implied 
read obj 	warranties 
offset pack access 	including limited 
check packed 	implied warranties 
crc obj offset 	merchantability fitness 
curpos size 	particular purpose 
unpack entry index 	disclaimed shall 
vptr ptr 	author 
start end index 	liable direct 
sha level 	indirect incidental 
ofs index stride 	special exemplary 
use lookup 	consequential damages 
debug lookup 	including limited 
pos cmp sha 	procurement 
offset sha 	substitute goods 
sha packs sha 	services loss 
flags status 	use data 
mapsize map stream 	profits business 
hdr hdrbuf 	interruption however 
sha flags rtype 	caused 
real sha 	theory liability 
sizep read packed 	whether contract 
sha pretend 	strict liability 
sha file read 	tort including 
read sha 	negligence otherwise 
file extended sha 	arising 
required type 	way use 
name size actual 	software even 
sha buffer 	advised possibility 
isize actual sha 	damage msc 
length type 	ver visual 
buf len 	studio 
type sha hdr 	mode many 
hdrlen tmpfile 	visual studio 
filename ret buf 	versions compiling 
len buf 	arm wrap 
len type sha 	wchar include 
hdr hdrlen 	compiler 
filename tmp filename 	give many 
dirlen sha 	errors like 
hdr hdrlen buf 	error second 
len mtime 	linkage overloaded 
ret compressed stream 	function wmemchr 
parano sha 	allowed 
tmp file filename 	define macros 
utb sha 	mark types 
sha buf len 	changing size 
type sha 	like intptr 
hdr hdrlen 	integer types 
buf len type 	exact 
sha flags 	width integer 
header hdrlen status 	types visual 
sha mtime 	studio embedded 
buf len hdr 	visual doesn 
hdrlen ret 	realize size 
sha sha sha 	give 
flags oid 	minimum width 
buf size desc 	integer types 
entry buf 	fastest minimum 
size buf size 	width integer 
index mem 	types integer 
sha path flags 	types 
ret write 	capable holding 
sbuf index pipe 	pointers win 
index core 	win greatest 
index stream index 	width integer 
sha path 	types limits 
flags errstr 	specified 
header sha type 	width integer 
subdir path 	types see 
obj cruft subdir 	footnote page 
data baselen 	footnote page 
dir hex sha 	limits exact 
path obj 	width 
cruft subdir data 	integer types 
baselen path 	limits minimum 
obj cruft subdir 	width integer 
data buf 	types limits 
data alt vdata 	fastest minimum 
data buf 	width 
data flags alt 	integer types 
data sha 	limits integer 
data flags pack 	types capable 
errors hashcmp 	holding pointers 
hashcmp mkdir lstat 	win win 
islnk strbuf 	limits 
readlink absolute 	greatest width 
path mkdir strbuf 	integer types 
release strbuf 	limits integer 
release adjust shared 	types win 
perm xstrdup 	win win 
free directory strlen 	win 
die memcpy 	size max 
fill sha path 	wchar min 
strbuf reset 	wchar max 
strbuf addf directory 	also defined 
sha hex 	wchar wchar 
sha pack name 	min 
sha pack 	wchar max 
name absolute path 	stdc limit 
strbuf addstr 	macros limits 
real path strbuf 	integer types 
addch strbuf 	see footnote 
addstr normalize path 	page 
copy strlen 	macros minimum 
xmalloc memcpy 	width integer 
strbuf release directory 	constants macros 
error free 	greatest width 
memcmp free strcmp 	integer constants 
icase free 	stdc 
read info alternates 	constant macros 
error strbuf 	msc stdint 
absolute path directory 	strbuf.c fmt 
normalize path 	arg len 
copy xmemdupz list 	size len 
split place 	increment 
absolute path error 	len buf 
link alt 	len reqsize 
odb entry list 	newsize len 
clear free 	newsize str 
strbuf release xstrfmt 	space len 
git open 	fmt 
noatime free 	arg fmt 
fstat close xsize 	len fmt 
xmmap close 	arg fmt 
link alt odb 	len empty 
entries munmap 	len start 
xcalloc git pathdup 	vfprintf 
hold file 	end exit 
update fdopen file 	malloc die 
die errno 	strbuf ensure 
fopen strbuf getline 	malloc die 
strcmp die 	strbuf init 
strbuf release fclose 	die 
rollback file 	debug stats 
die errno die 	free free 
commit file 	debug stats 
die errno link 	strbuf ensure 
alt odb 	free die 
entries strlen free 	calculate 
prepare alt 	size realloc 
odb getenv 	die strbuf 
link alt odb 	empty length 
entries strlen 	strbuf resize 
read info alternates 	strbuf empty 
directory time 	length 
utime access freshen 	strbuf ensure 
file check 	empty length 
freshen file sha 	start vsnprintf 
file name 	end die 
prepare alt odb 	start strbuf 
fill sha 	empty 
path check freshen 	length vsnprintf 
file check 	end die 
freshen local check 	strbuf resize 
freshen nonlocal 	strbuf buffer 
check freshen nonlocal 	routines copyright 
check freshen 	mark 
fmt getpagesize fmt 	pulford mark 
fmt fmt 	kyne permission 
fmt git 	hereby granted 
open noatime fstat 	free charge 
close xsize 	person obtaining 
close error xmmap 	copy 
close htonl 	software associated 
ntohl munmap error 	documentation files 
ntohl munmap 	software deal 
error munmap error 	software without 
munmap error 	restriction including 
munmap error strip 	without 
suffix die 	limitation rights 
xstrfmt check packed 	use copy 
git idx 	modify merge 
free scan windows 	publish distribute 
scan windows 	sublicense sell 
munmap free unuse 	copies 
one window 	software permit 
git env die 	persons software 
mmap limit 	furnished subject 
check mmap 	following conditions 
release pack memory 	copyright notice 
mmap xmmap 	permission 
gently die errno 	notice shall 
die munmap 	included copies 
free close close 	substantial portions 
pack windows 	software software 
close pack close 	provided without 
pack index 	warranty 
die close pack 	kind express 
find lru 	implied including 
pack close pack 	limited warranties 
munmap strcmp 	merchantability fitness 
clear delta cache 	particular purpose 
close pack 	noninfringement 
free free getrlimit 	shall authors 
sysconf open 	copyright holders 
pack index 	liable claim 
error max limit 	damages liability 
close one 	whether action 
pack git open 	contract 
noatime fstat 	tort otherwise 
isreg error error 	arising connection 
fcntl error 	software use 
fcntl error read 	dealings software 
full error 	terminator strbuf 
htonl error pack 	allocation 
version error 	deallocation increment 
ntohl ntohl error 	linear buffer 
ntohl lseek 	growth rate 
error read full 	increment exponential 
error hashcmp 	buffer growth 
error open packed 	rate 
git close 	strbuf dynamically 
pack open packed 	allocated strbuf 
git die 	free called 
die die 	number times 
window window open 	strbuf init 
packed git 	ensure 
die xcalloc unuse 	room optional 
one window 	termination user 
xmmap die strerror 	requested shrink 
close pack 	buffer exactly 
xsize xmalloc memset 	exponential sizing 
release pack 	linear 
memory free routine 	sizing ensure 
strip suffix 	strbuf handle 
mem strlen alloc 	length bytes 
packed git 	ignoring optional 
memcpy xsnprintf access 	termination strbuf 
xsnprintf stat 	append 
isreg free sha 	fmt used 
hex hashclr 	upper bound 
sha pack name 	known output 
strlen alloc 	never happen 
packed git 	strbuf append 
memcpy hashcpy check 	fmt 
packed git 	retry used 
idx free report 	known upper 
garbage list 	bound output 
sort strncmp report 	first attempt 
helper strrchr 	append fails 
report garbage strcmp 	resize 
strcmp report 	buffer appropriately 
helper strbuf addstr 	append formatted 
strbuf addstr 	fmt len 
opendir error strerror 	length required 
strbuf release 	excluding trailing 
strbuf addch readdir 	since 
dot dotdot 	also space 
strbuf setlen strbuf 	store terminating 
addstr strip 	success strbuf.h 
suffix mem strip 	len len 
suffix memcmp 	increment len 
packed git 	len 
install packed git 	len len 
ends ends 	len len 
ends ends list 	fmt format 
append report 	len str 
garbage closedir report 	len len 
pack garbage 	len 
list clear strbuf 	len len 
release xcalloc 	strbuf empty 
qsort free prepare 	length strbuf 
packed git 	resize strbuf 
one directory prepare 	ensure empty 
alt odb 	length 
prepare packed git 	strbuf ensure 
one rearrange 	empty length 
packed git prepare 	memcpy memcpy 
packed git 	strbuf buffer 
hashcmp xrealloc mult 	routines copyright 
hashcpy hashcmp 	mark 
hash sha 	pulford mark 
file hashcmp open 	kyne permission 
istream xsnprintf 	hereby granted 
git sha init 	free charge 
git sha 	person obtaining 
update read istream 	copy 
close istream 	software associated 
git sha update 	documentation files 
git sha 	software deal 
close istream hashcmp 	software without 
open lstat 	restriction including 
sha file name 	without 
prepare alt 	limitation rights 
odb fill sha 	use copy 
path lstat 	modify merge 
git open noatime 	publish distribute 
sha file 	sublicense sell 
name prepare 	copies 
alt odb fill 	software permit 
sha path 	persons software 
git open noatime 	furnished subject 
open sha 	following conditions 
file fstat xsize 	copyright notice 
error sha 	permission 
file name xmmap 	notice shall 
close memset 	included copies 
git inflate init 	substantial portions 
git inflate 	software software 
unpack sha header 	provided without 
memchr strbuf 	warranty 
git inflate strbuf 	kind express 
memchr strlen 	implied including 
xmallocz memcpy git 	limited warranties 
inflate git 	merchantability fitness 
inflate end error 	particular purpose 
sha hex 	noninfringement 
error sha 	shall authors 
hex free type 	copyright holders 
gently strbuf 	liable claim 
die parse sha 	damages liability 
header extended 	whether action 
memset git inflate 	contract 
init use 	tort otherwise 
pack git inflate 	arising connection 
git inflate 	software use 
end error delta 	dealings software 
hdr size 	size total 
delta hdr size 	bytes 
use pack 	allocated buf 
unpack header buffer 	length length 
find pack 	excluding optional 
revindex nth packed 	terminator increment 
sha mark 	allocation increments 
bad packed sha 	resizing 
info delta 	buffer created 
unpack header 	via strbuf 
retry bad packed 	initialise release 
offset free 	management update 
retry bad packed 	reset use 
offset unpack 	bytes 
header delta size 	remaining buffer 
delta find 	ensure space 
pack revindex packed 	terminator strings.h 
type delta 	bit scan 
sha hashcpy hashclr 	forward ffsl 
unuse pack 	msvc 
xmallocz gently memset 	doesn define 
git inflate 	ffs ffsl 
init use pack 	dummy header 
git inflate 	provided syncio.c 
git inflate end 	ptr size 
free pack 	timeout 
entry hash delta 	nwritten ret 
cache entry 	start remaining 
delta cache 	wait elapsed 
entry free release 	ptr size 
delta cache 	timeout nread 
trace key init 	totread 
trace key 	start remaining 
open pack index 	wait elapsed 
die die 	ptr size 
ntohl ntohl check 	timeout nread 
pack index 	mstime write 
ptr ntohl ntohl 	wait 
getenv open 	mstime mstime 
pack index ntohl 	read wait 
ntohl getenv 	mstime sync 
sha entry pos 	read synchronous 
nth packed 	socket file 
offset hashcmp nth 	operations 
packed offset 	useful across 
open packed 	core copyright 
git hashcmp find 	salvatore sanfilippo 
pack entry 	antirez gmail 
one pack valid 	dot 
hashcpy prepare 	rights reserved 
packed git fill 	redistribution use 
pack entry 	source binary 
fill pack entry 	forms without 
find pack 	modification permitted 
entry one hashclr 	provided 
stat sha 	following conditions 
file map sha 	met redistributions 
file unpack 	source code 
sha header strbuf 	must retain 
error sha 	copyright notice 
hex unpack sha 	list 
header error 	conditions following 
sha hex parse 	disclaimer redistributions 
sha header 	binary form 
extended error 	must reproduce 
sha hex parse 	copyright notice 
sha header 	list 
extended error sha 	conditions following 
hex git 	disclaimer documentation 
inflate end munmap 	materials provided 
strbuf release 	distribution neither 
lookup replace extended 	name redis 
find cached 	names 
hashclr strbuf addstr 	contributors may 
find pack 	used endorse 
entry sha loose 	promote products 
info reprepare 	derived software 
packed git find 	without specific 
pack entry 	prior 
packed info mark 	written permission 
bad packed 	software provided 
sha info extended 	copyright holders 
delta cache 	contributors express 
strbuf addstr 	implied warranties 
sha info extended 	including 
type hashcpy 	limited implied 
read sha file 	warranties merchantability 
hashcpy free 	fitness particular 
strlen memcmp sha 	purpose disclaimed 
hex free 	shall copyright 
free xsnprintf git 	owner 
sha init 	contributors liable 
git sha update 	direct indirect 
git sha 	incidental special 
update git sha 	exemplary consequential 
link rename 	damages including 
unlink warn error 	limited 
strerror adjust 	procurement substitute 
shared perm error 	goods services 
write full 	loss use 
error strerror write 	data profits 
sha file 	business interruption 
prepare fsync 	however 
die close die 	caused theory 
errno strrchr 	liability whether 
directory size strbuf 	contract strict 
reset strbuf 	liability tort 
strbuf addstr git 	including negligence 
mkstemp mode 	otherwise 
strbuf reset strbuf 	arising way 
mkdir adjust 	use software 
shared perm strbuf 	even advised 
addstr git 	possibility damage 
mkstemp mode sha 	blocking sockets 
file name 	timeouts 
create tmpfile error 	redis performs 
directory error 	nonblocking way 
strerror git deflate 	sync command 
init git 	slave blocking 
sha init 	way migrate 
git deflate git 	command 
sha update 	must blocking 
git deflate git 	order atomic 
sha update 	point view 
write buffer die 	two instances 
die sha 	one migrating 
hex git deflate 	key 
end gently 	one receiving 
die sha hex 	key need 
git sha 	following blocking 
hashcmp die sha 	functions functions 
hex close 	take timeout 
sha file utime 	milliseconds 
warning strerror 	resolution milliseconds 
finalize file check 	write specified 
freshen find 	payload writing 
pack entry freshen 	whole payload 
file write 	done within 
sha file 	timeout 
prepare freshen packed 	milliseconds operation 
freshen loose 	succeeds size 
write loose strlen 	returned otherwise 
xmalloc write 	operation fails 
sha file prepare 	returned unspecified 
freshen packed 	write 
freshen loose write 	could performed 
loose free 	file descriptor 
loose read packed 	optimistically write 
sha error 	checking file 
sha hex xsnprintf 	descriptor actually 
write loose 	writable 
free stat sha 	worst eagain 
pack index 	wait read 
name find pack 	specified amount 
entry find 	bytes bytes 
pack entry loose 	read within 
reprepare packed 	timeout 
git find 	milliseconds operation 
pack entry sha 	succeed size 
file init 	returned otherwise 
desc entry memset 	operation fails 
parse commit 	returned unspecified 
buffer die memset 	amount 
parse tag 	data could 
buffer die would 	read file 
convert git 	descriptor optimistically 
filter convert git 	read checking 
filter write 	file descriptor 
sha file hash 	actually 
sha file 	readable worst 
strbuf release open 	eagain read 
error strerror 	wait read 
index error strbuf 	line making 
readlink strerror 	sure every 
error hash sha 	require 
file write 	timeout milliseconds 
sha file 	read success 
error strbuf release 	number bytes 
resolve gitlink 	read returned 
error read full 	otherwise success 
htonl pack 	always 
version opendir error 	correctly terminated 
strerror readdir 	tcache.c opt 
dot dotdot strbuf 	tcache opt 
setlen strbuf 	tcache max 
addf strlen snprintf 	tcache bin 
sha hex 	info 
obj cruft closedir 	stack nelms 
strbuf setlen 	nhbins tcache 
subdir strbuf addf 	maxclass tcaches 
file obj 	tcaches past 
subdir strbuf setlen 	tcaches avail 
strbuf addstr 	ptr 
loose file objdir 	tsd tcache 
buf strbuf 	binind tbin 
release strbuf 	tbin info 
loose file objdir 	tsd arena 
buf strbuf 	tcache tbin 
release loose file 	binind 
objdir directory 	ret tsd 
alt odb nth 	tcache tbin 
packed sha 	binind rem 
error prepare packed 	arena ptr 
git open 	nflush ndeferred 
pack index pack 	merged 
git information 	stats chunk 
manager hell copyright 	bin arena 
linus torvalds 	bin pageind 
handles basic git 	bitselm bin 
sha files 	tsd tbin 
packing unpacking creation 	binind 
etc meant 	rem tcache 
hold small 	arena ptr 
number objects would 	nflush ndeferred 
want read 	merged stats 
sha file able 	chunk locked 
yet want 	arena 
write store browse 	idump tcache 
application pointer 	arena tcache 
last packed git 	oldarena newarena 
found sought 	tcache arena 
look packfile first 	iter tsd 
objects looked 	arena 
similar times often 	tsd arena 
packfile one 	tcache size 
another looking path 	stack offset 
symlinked worktree 	tsd tcache 
whose original repository 	arena tbin 
yet git 	bin 
cache pointing original 	tbin tsd 
repository user 	tcache tsd 
hasn performed 	tcache arena 
conflict resolution yet 	bin tbin 
path exists 	lstats tbin 
somebody created since 	tsd 
either mkdir 	ind tcache 
failed somebody pruned 	elm tsd 
containing directory 	elm tsd 
stat failed file 	ind tsd 
way removed 	ind elm 
either way inform 	arena 
caller might 	salloc tcache 
worth trying path 	bin flush 
points cache 	small tcache 
entries xstrdup messing 	bin flush 
sha sha 	large arena 
name pack index 	tcache 
file specified 	fill small 
sha filename name 	tcache alloc 
scratch space 	easy arena 
must provided 	choose chunk 
caller pack idx 	addr extent 
prepare alternate 	node 
database registry variable 	arena arena 
alt odb 	prof accum 
list points list 	prof idump 
alternate database 	malloc mutex 
elements list come 	chunk addr 
non empty 	extent 
elements colon separated 	node arena 
alternate environment 	arena bitselm 
environment variable git 	arena dalloc 
directory info 	bin junked 
alternates whose contents 	locked malloc 
similar environment 	mutex 
variable separated points 	unlock malloc 
statically allocated 	mutex malloc 
buffer contains directory 	mutex unlock 
corresponding git 	memmove arena 
objects name 	choose chunk 
points slash end 	addr 
git objects 	extent node 
example enough space 	arena malloc 
hold hex 	mutex arena 
sha extra slash 	prof accum 
first level 	locked chunk 
indirection terminating nul 	addr 
trailing slash 	extent node 
directory name given 	arena arena 
function end 	dalloc large 
duplicates hex hex 	junked locked 
nul detect 	malloc mutex 
cases alternate disappeared 	unlock 
prevent common 	prof idump 
mistake listing thing 	malloc mutex 
twice directory 	malloc mutex 
alternate entry 	unlock memmove 
recursively alternates returns 	malloc mutex 
successfully freshened 	elm 
file otherwise check 	tail insert 
freshen functions 	malloc mutex 
file exists freshened 	unlock tcache 
freshening requested 	arena dissociate 
otherwise safe skip 	tcache arena 
write either 	associate 
exist disk stale 	malloc mutex 
mtime may 	tcache stats 
subject pruning open 	merge malloc 
mmap index 	mutex unlock 
file path perform 	tcache enabled 
couple consistency 	tsd 
checks record information 	nominal tcache 
success skip 	enabled arena 
index header total 	choose unlikely 
size index 	tcache create 
entries bytes 	offsetof ptr 
entries sha offset 	ceiling 
sha packfile 	ipallocztm tcache 
sha file checksum 	arena associate 
minimum size 	arena choose 
bytes header index 	tcache arena 
entries bytes 	dissociate tcache 
sha entry crc 	bin 
entry offset 	flush small 
entry sha packfile 	malloc mutex 
sha file 	malloc mutex 
checksum offset table 	unlock tcache 
might variable 	bin flush 
sized table containing 	large 
entries offsets 	malloc mutex 
larger make sure 	malloc mutex 
deal large 	unlock arena 
pack offsets bit 	prof accum 
offset won 	prof idump 
enough neither 	idalloctm 
bit one nothing 	tsd tcache 
lru pack 	tcache destroy 
one oldest mru 	tsd tcache 
window preferring 	cassert malloc 
packs used windows 	mutex malloc 
oldest mtime 	mutex 
windows allocated reject 	unlock alloc 
pack windows 	tcache create 
previously selected one 	tcache destroy 
pack windows 	tcaches elm 
reject pack file 	flush tcaches 
newer previously 	elm 
selected one reject 	flush size 
pack windows 	index alloc 
use previously selected 	data total 
pack inuse 	stack elms 
windows otherwise record 	per tcache 
pack windows 	index 
use reject 	first element 
pack windows used 	within tcaches 
recently previously 	never used 
selected pack previously 	head singly 
selected pack 	linked list 
windows inuse encountered 	tracking 
window pack 	available tcaches 
inuse skip check 	elements flush 
since prefer 	ceiling objects 
pack inuse windows 	low water 
one inuse 	mark reduce 
windows pack used 	fill 
git repack 	count limit 
newly created pack 	fill div 
happens contain 	fill count 
objects existing one 	always least 
resulting file 	increase fill 
might different 	count 
even name would 	make sure 
best close 	fill div 
reference old pack 	stays greater 
replaced disk 	arena bin 
course index pointers 	associated first 
windows given 	allocated 
pack must subsist 	via different 
point ever 	arena bin 
objects pack requested 	one currently 
version pack 	locked stash 
reinitialized reprepare packed 	handled future 
git otherwise 	pass 
got one two 	flush loop 
reasons sysconf 	didn happen 
understand open max 	flush arena 
signaled error 	stats didn 
sysconf said limit 	merged manually 
could clear 	arena 
errno calling 	associated first 
sysconf tell two 	allocated via 
cases apart 	different arena 
huge number latter 	one currently 
caller cap 	locked stash 
selfish letting fallback 	handled 
open max 	future pass 
codepath take care 	flush loop 
cases lot 	didn happen 
simpler see caller 	flush arena 
call directly 	stats didn 
leaks pack error 	merged 
call open 	manually link 
packed git instead 	list extant 
save stdin 	tcaches unlink 
stdout stderr work 	list extant 
nothing created 	tcaches memoize 
pack lack size 	naturally 
file descriptors 	align pointer 
open sliding 	stacks avoid 
mmap point keeping 	cacheline sharing 
open across 	nothing caller 
exec though verify 	must arena 
recognize pack 	merge 
file format verify 	reset tcache 
pack matches 	stats necessary 
index must promise 	clamp opt 
least bytes 	tcache max 
one hash offset 	large maxclass 
available window 	known 
otherwise offset actually 	initialize tcache 
window different 	bin info 
window one hash 	tcache.h ncached 
excess must 	max tstats 
used support header 	low water 
delta parsing 	fill 
routines since packfiles 	div ncached 
end hash 	avail prof 
content pointless 	accumbytes cnt 
ask offset middle 	next bin 
hash window 	tbins tcache 
function wouldn match 	next 
allow offset 	opt tcache 
close end file 	opt tcache 
nothing make 	max tcache 
sure corresponding pack 	bin info 
file exists 	nhbins tcache 
index looks sane 	maxclass 
pack enough 	tcaches ptr 
hold suffix adding 	tsd tcache 
use xsnprintf 	tsd arena 
checks looks sane 	tcache tbin 
far check 	binind tsd 
without actually mapping 	tcache 
pack file 	tbin binind 
includes nul reopen 	rem tsd 
pack already 	tbin binind 
see really 	rem tcache 
valid idx file 	tcache arena 
corresponding pack 	tcache 
file map local 	oldarena newarena 
packs tend 	tcache arena 
contain objects specific 	tsd tsd 
variant project 	arena tsd 
remote ones addition 	tsd tcache 
remote ones 	arena 
could network mounted 	tsd ind 
filesystem favor 	tsd ind 
local ones reasons 	tsd ind 
younger packs 	tsd tcache 
tend contain recent 	tsd create 
objects recent 	enabled 
objects tend accessed 	tbin tsd 
often prepare 	arena tcache 
packed git 	size zero 
easier sorting link 	tsd arena 
back core 	tcache size 
data map rehash 	zero 
make sure 	tsd tcache 
name actually matches 	ptr binind 
sha detect 	tsd tcache 
corruption map reading 	ptr size 
named sha 	tsd ind 
streaming rehash generate 	tsd 
header sha 	tsd tcache 
might failure due 	enabled enabled 
noatime mmap 	tsd tcache 
forbidden empty files 	enabled tsd 
data stream 	create tcache 
check entire header 	tsd 
unpacked first 	tcache tbin 
iteration buffer bufsiz 	ret tsd 
large enough 	arena tcache 
copy result 	size zero 
header append result 	ret binind 
reading stream 	usize 
condition must bytes 	tbin tsd 
size bytes 	arena tcache 
size words even 	size zero 
though expect 	ret binind 
output avail zero 	usize tbin 
input zlib 	chunk 
stream may bytes 	pageind tsd 
express concludes 	tcache ptr 
stream want eat 	binind tbin 
input otherwise 	tbin info 
would able test 	tsd 
consumed input 	tcache ptr 
reach expected size 	size binind 
also want 	tbin tbin 
check zlib tells 	info tsd 
went well 	ind elm 
status stream 	cassert 
end end used 	tsd fetch 
use sscanf 	tcache cleanup 
actually way permissive 	cassert tsd 
want check 	fetch tsd 
anal header parse 	tcache enabled 
hand type 	tsd 
size followed space 	tcache enabled 
type unknown 	cassert tsd 
obtaining type allow 	fetch tsd 
unkown type 	tcache enabled 
option length must 	tcache cleanup 
follow immediately 	tsd 
canonical format valid 	tcache unlikely 
length must 	tsd nominal 
followed zero examine 	tcache hard 
initial part 	tsd tcache 
delta figure result 	unlikely tcache 
size ignore 	hard 
size read 	unlikely unlikely 
result size use 	size index 
pack assured 	index size 
info info range 	tcache alloc 
look without 	easy unlikely 
walking end mapped 	tcache 
window actually 	alloc small 
hash size assured 	hard tcache 
ofs delta 	salloc likely 
longer hash size 	unlikely arena 
stupid delta 	alloc junk 
would smaller store 	small 
overflow bound 	unlikely memset 
entry must pack 	unlikely arena 
like delta 	alloc junk 
sha instead pack 	small memset 
offset means 	tcache size 
cheaper deltas 	index 
lookup expensive ofs 	index size 
deltas load 	tcache alloc 
revidx convert offset 	easy unlikely 
back sha 	arena malloc 
use pack assures 	large chunk 
available range 	addr 
look actually hash 	arena mapbits 
size assured 	large binind 
header encoding maximum 	likely unlikely 
deflated size 	memset unlikely 
insane know won 	memset memset 
exceed given 	tcache 
push going behind 	tcache salloc 
parsing offset 	unlikely arena 
fails unwind getting 	dalloc junk 
fails first 	small unlikely 
retry otherwise unwind 	tcache bin 
always representation 	flush 
type convert 	small tcache 
real type later 	tcache salloc 
caller interested 	tcache salloc 
payload larger phase 	size index 
drill innermost 	unlikely arena 
bail phase hopes 	dalloc 
recovery push 	junk large 
proceed phase handle 	unlikely tcache 
phase apply 	bin flush 
deltas order invariants 	large tcache 
data holds 	unlikely tcache 
data corruption probably 	create 
deep shit 	arena choose 
fetch required anyway 	tcache pointers 
another pack 	close used 
loose costly happen 	encode state 
presence corrupted 	information used 
pack better failing 	two 
outright could 	purposes preventing 
apply delta 	caching per 
warn user keep 	basis cleaning 
going failure 	shutdown absolute 
noticed either next 	minimum number 
iteration loop 	cache 
delta caller code 	slots small 
paths take 	bin absolute 
care making warning 	maximum number 
retrying another 	cache slots 
copy need check 	small bin 
underflow idx 	cache 
files must least 	additional constraint 
bytes already 	beyond imposed 
open pack known 	twice number 
valid pack 	regions per 
one window completely 	run size 
covering file 	constant 
size pack known 	must even 
valid even 	number number 
descriptor currently 	cache slots 
open force pack 	large size 
open prove 	classes opt 
valid tell caller 	tcache 
locate requested 	max used 
better make sure 	compute tcache 
packfile still 	maxclass tcache 
accessed supplying answer 	sweep approximate 
may deleted 	number allocation 
since index loaded 	events 
iff pack 	full sweeps 
file contains named 	integer rounding 
sha store 	may cause 
location already one 	actual number 
care type 	slightly higher 
size need look 	since 
inside note 	performed incrementally 
optimize stat 	number tcache 
call even caller 	allocation deallocation 
doesn care 	events incremental 
disk size since 	jemalloc types 
implicitly indicates 	enable 
whether even exists 	cast read 
nothing likely 	information associated 
loose loose someone 	element tcache 
may packed 	tbins stored 
packed info follow 	separately mainly 
delta chain 	reduce 
find real type 	memory usage 
unless given 	upper limit 
typep returns type 	ncached min 
negative probably 	cached since 
deep shit fetch 	last fill 
required anyway 	ncached 
another pack loose 	max fill 
happen presence 	div cached 
corrupted pack 	objects stack 
better failing outright 	available objects 
function dies 	used aggregating 
corrupt objects callers 	stats 
want deal 	cleared arena 
arrange call read 	prof accum 
give error 	count since 
messages die replaced 	incremental next 
one exist 	bin dynamically 
handle references referred 	sized 
actual sha 	pointer stacks 
check generate header 	associated tbins 
sha move 	follow contiguous 
written resting place 	tcache initialization 
coda hack 	avail pointer 
coda doesn like 	element 
cross directory 	tbins initialized 
links fall back 	point proper 
rename mean 	offset within 
won able 	linkage list 
check collisions big 	available previously 
deal holds 	used 
fat formatted media 	tcache jemalloc 
succeeds nothing 	structs number 
left unlink fixme 	tcache bins 
collision check 	nbins small 
finalize file disk 	bins plus 
close size 	large 
directory component including 	bins maximum 
ending creates 	cached size 
temporary file directory 	tcaches managed 
filename want 	via tcache 
avoid cross directory 	create flush 
filename renames 	destroy 
problems various filesystems 	mallctls usable 
fat nfs 	via mallocx 
coda make sure 	tcache flag 
directory exists 	automatic per 
note contents 	tcaches completely 
buffer undefined mkstemp 	disjoint 
returns error 	data structure 
rewrite whole buffer 	tcaches starts 
scratch first 	sparse physical 
header nothing data 	memory footprint 
normally pack 	individual pages 
bother writing git 	touched 
objects file 	allows entire 
type length plus 	allocated first 
nul must 	time tcache 
fit nothing entry 	created without 
die malformed 	disproportionate impact 
entries convert blobs 	memory 
git format 	usage jemalloc 
creates one packfile 	externs allocate 
per large 	one large 
blob unless bulk 	time quite 
checkin machinery 	expensive create 
plugged also 	one 
bypasses usual convert 	use jemalloc 
git dance 	inlines test.c 
purpose could write 	host port 
streaming version 	timeout path 
converting functions insert 	fails reply 
feeding data 	keep 
fast equivalent core 	reply config 
api described 	dummy ctx 
however somewhat complicated 	cmd len 
know size 	argv lens 
filter result need 	argc config 
know beforehand 	reply 
writing git since 	cmd len 
primary motivation 	reader reply 
trying stream working 	ret config 
file avoid 	reply config 
mmaping core 	reply reply 
deal large binary 	major 
blobs generally 	minor field 
want conversion callers 	eptr config 
avoid code 	config replies 
path filters requested 	num argc 
call xsize 	argv cfg 
needed avoid potentially 	throughput 
unnecessary die 	test inherit 
large files eof 	gettimeofday redis 
pack header 	command free 
fully read protocol 	reply redis 
error pack 	command free 
signature mismatch detected 	reply 
protocol error 	exit redis 
pack version unsupported 	command free 
copy including 	reply redis 
trailing sha1 namec 	command free 
commit list 	reply redis 
data candidate 	free 
current len hex 	keep redis 
pfx alt 	free redis 
hex fakeent objdir 	connect redis 
objdir len 	connect unix 
dir sha len 	redis connect 
len bin 	unix 
pfx num last 	disconnect redis 
first current 	connect exit 
mid current cmp 	exit database 
len bin 	test redis 
pfx sha sha 	format command 
data unused 	test 
kind sha data 	cond strncmp 
unused obj 	free test 
kind sha data 	redis format 
unused kind 	command test 
sha data unused 	cond strncmp 
obj kind 	free 
sha data 	test redis 
unused kind name 	format command 
len bin 	test cond 
pfx hex pfx 	strncmp free 
val name 	test redis 
len sha flags 	format 
status hex 	command test 
pfx bin pfx 	cond strncmp 
quietly prefix 	free test 
data hex pfx 	redis format 
bin pfx 	command test 
len hex sha 	cond 
len status 	strncmp free 
exists sha ret 	test redis 
sha len 	format command 
hex path len 	test cond 
slash cnt 	strncmp free 
len suffix suffix 	test 
len len 	redis format 
suffix len 	command test 
suffix name len 	cond strncmp 
sha lookup 	free integer 
flags name namelen 	width test 
buf str 	integer 
len sha flags 	width test 
warn msg 	integer width 
name msg tmp 	test integer 
sha real 	width test 
refs found reflog 	width test 
len nth 	width 
prior buf detached 	test test 
nth time 	redis format 
time cnt errors 	command test 
tmp name 	cond test 
len result idx 	redis format 
sha ret 	command 
commit name 	argv test 
len result generation 	cond strncmp 
sha commit 	free test 
ret peel type 	redis format 
name len 	command argv 
sha outer expected 	test 
type lookup 	cond strncmp 
flags prefix ret 	free connect 
list name 	test redis 
len sha flags 	format command 
name len 	test cond 
sha lookup flags 	redis 
ret suffix 	append formatted 
num len path 	command redis 
oid flag 	reply free 
data list prefix 	free reply 
sha list 	disconnect test 
found negative regex 	redis 
buf commit 	reader create 
matches remaining 	redis reader 
buf osha nsha 	feed redis 
email timestamp 	reader reply 
message data target 	test cond 
len name 	strcasecmp 
namelen buf nth 	redis reader 
retval brace 	free test 
num end name 	redis reader 
sha one 	create redis 
two mbs sha 	reader feed 
tmp dots 	redis 
name namelen len 	reader feed 
buf next 	redis reader 
name namelen len 	feed redis 
buf tmp 	reader reply 
used ret buf 	test cond 
name namelen 	strcasecmp 
buf mark data 	redis reader 
len branch 	free test 
err name 	redis reader 
str name namelen 	create redis 
buf start 	reader feed 
len name len 	redis 
used name 	reader reply 
name sha unused 	test cond 
name sha 	strncasecmp redis 
unused name sha 	reader free 
unused name 	test redis 
sha unused name 	reader 
sha unused 	create redis 
name sha unused 	reader feed 
prefix filename 	redis reader 
sha name name 	reply test 
len sha 	cond redis 
mode fullname stage 	reader 
prefix filename 	free test 
pos namelen fullname 	redis reader 
rel name 	create redis 
flags prefix 	reader feed 
sha ret bracket 	redis reader 
depth namelen 	reply 
die stage path 	redis reader 
pos list 	feed redis 
sha len filename 	reader reply 
filename name 	test cond 
prefix sha str 	redis reader 
flags sha 	free 
orc hashcpy hashcmp 	test redis 
hashcpy directory 	reader create 
strlen xmalloc memcpy 	redis reader 
xsnprintf xsnprintf 	feed redis 
opendir readdir strlen 	reader reply 
memcmp memcpy 	redis 
sha hex update 	reader reply 
candidates closedir 	test cond 
open pack 	redis reader 
index nth packed 	free test 
sha hashcmp 	redis reader 
nth packed sha 	create 
match sha 	redis reader 
update candidates prepare 	feed redis 
packed git 	reader reply 
unique pack hashcpy 	test cond 
sha info 	free reply 
sha info deref 	redis 
tag parse 	reader free 
sha info sha 	test redis 
info deref 	connect test 
tag lookup sha 	cond strcmp 
info hashclr 	strcmp strcmp 
memset prepare prefixes 	strcmp 
prepare alt 	strcmp redis 
odb memset find 	free test 
filename find 	redis connect 
packed finish 	test cond 
disambiguation error strlen 	strcmp redis 
prepare prefixes 	free 
prepare alt odb 	test redis 
memset find 	connect unix 
filename find packed 	test cond 
sha hex 	redis free 
sha file sha 	connect test 
find unique 	redis 
abbrev strlen memcmp 	command free 
mark size 	reply test 
mark size sha 	redis command 
hex dwim 	free reply 
warning free upstream 	test redis 
mark push 	command 
mark ambiguous path 	free reply 
interpret nth 	redis command 
prior checkout sha 	test cond 
hex strbuf 	strcmp free 
release dwim 	reply test 
dwim log dwim 	redis 
sha warning 	command free 
xstrndup approxidate careful 	reply redis 
free free 	command test 
read starts strlen 	free reply 
warning show 	test redis 
date date mode 	command 
exit die 	free reply 
free sha lookup 	test redis 
commit reference 	command free 
parse commit hashcpy 	reply test 
hashcpy sha 	free reply 
lookup commit reference 	redis 
parse commit 	command free 
hashcpy starts starts 	reply redis 
starts starts 	command redis 
starts sha parse 	command free 
deref tag 	reply test 
parse hashcpy 	free 
peel type hashcpy 	reply redis 
xstrndup commit 	command free 
list insert sha 	reply redis 
oneline free 	command free 
isxdigit sha parent 	reply redis 
nth ancestor 	command 
peel onion sha 	redis command 
basic describe 	test cond 
name sha parse 	memcmp memcmp 
deref tag 	strcasecmp free 
strlen commit list 	reply disconnect 
insert regcomp 	connect 
commit list insert 	redis command 
pop recent 	strstr strtol 
commit parse commit 	strlen strtol 
buffer strstr 	free reply 
regexec unuse commit 	test 
buffer hashcpy 	redis command 
regfree free 	test cond 
commit list clear 	strcasecmp redis 
commit marks 	reply free 
free commit list 	reply test 
skip prefix 	cond 
strstr strbuf reset 	strcmp redis 
strbuf memchr 	free connect 
strtol strbuf init 	test redis 
reflog ent 	timeout test 
reverse strbuf reset 	cond redis 
strbuf addbuf 	reply 
strbuf release strstr 	redis free 
sha sha 	test redis 
strbuf init strbuf 	connect timeout 
sha committish 	test cond 
strbuf release lookup 	test redis 
commit reference 	connect 
gently sha 	timeout test 
committish lookup commit 	cond redis 
reference gently 	free connect 
merge bases hashcpy 	test free 
free commit 	reply redis 
list memchr strbuf 	command 
reset strbuf 	malloc usec 
strbuf interpret branch 	redis command 
name strbuf 	usec free 
setlen strbuf reset 	reply free 
strbuf addbuf 	malloc usec 
strbuf release shorten 	redis 
unambiguous strbuf 	command usec 
reset strbuf addstr 	free reply 
free mark 	free malloc 
memchr xmemdupz branch 	redis append 
free branch 	command usec 
data die shortened 	redis 
interpret nth 	reply usec 
prior checkout 	free reply 
strlen reinterpret memchr 	free malloc 
interpret empty 	redis append 
reinterpret interpret branch 	command usec 
mark interpret 	redis 
branch mark strlen 	reply usec 
interpret branch 	free reply 
name strbuf strbuf 	free disconnect 
branchname strbuf 	signal strcmp 
splice check refname 	strcmp atoi 
format sha 	strcmp 
context sha context 	strcmp strcmp 
sha context 	exit test 
sha context sha 	format commands 
context sha 	test reply 
context file exists 	reader test 
die xstrfmt 	blocking 
entry die die 	connection errors 
strlen cache 	test blocking 
name pos 	connection test 
namelen memcmp die 	blocking errors 
stage strbuf 	test invalid 
addstr strbuf addstr 	timeout 
cache name 	errors test 
pos namelen memcmp 	append formatted 
die stage 	commands test 
stage file exists 	throughput test 
die die 	blocking connection 
strbuf release starts 	test 
starts die 	blocking errors 
inside work die 	test throughput 
prefix path 	test blocking 
strlen strlen memset 	connection following 
sha commit 	lines make 
list sort date 	testing 
sha oneline 	framework testing 
resolve relative path 	know chat 
strlen strlcpy 	make sure 
read cache 	empty awesome 
cache name pos 	empty make 
namelen memcmp 	sure 
stage hashcpy free 	free context 
diagnose invalid 	well keep 
index path free 	requested create 
sha resolve 	dummy connection 
relative path entry 	inherit vararg 
follow symlinks 	width 
entry diagnose invalid 	depends type 
sha path 	tests make 
hashcpy strlcpy free 	sure width 
die sha 	correctly determined 
context die sha 	format subsequent 
context first 	varargs 
candidate already seen 	correctly interpolated 
cannot disambiguate 	reply already 
candidate current 	contains multiple 
discard candidate know 	items must 
satisfy reach 	free error 
point know candidate 	valgrind 
satisfies current 	bark doesn 
candidate satisfy cannot 	happen regression 
disambiguate otherwise 	test issue 
current discarded candidate 	git hub 
still good 	care message 
create fake alternate 	test 
database points 	multi bulk 
database make easier 	reply reply 
temporary working 	specifically test 
space alt name 	ordering reply 
alt iterating 	items parse 
databases including every 	connect 
alt odb 	target given 
extra bytes exactly 	config find 
purpose point 	redis version 
first location 	determine path 
lowest name could 	next test 
match bin 	next 
pfx see objects 	first returns 
actually match 	quit read 
candidate point calling 	issued know 
disambiguation hint 	descriptor eof 
callback hand current 	quit cause 
candidate replaced 	connection 
earlier candidate pass 	closed immediately 
disambiguation hint 	read reply 
callback one objects 	quit error 
match name 	eof quit 
given make sure 	another read 
one matches 	needed 
otherwise discovered one 	issued find 
one previously 	socket closed 
discarded reverse order 	server conditions 
would end 	error eof 
showing different 	test callback 
results repository need 	flags 
hard way 	test callback 
need hard way 	redis context 
basic time 	privdata shift 
number number format 	detect execution 
query log 	order test 
start accept unambiguous 	callback 
paths allow 	flags test 
mean current branch 	callback flags 
reflog asking 	privdata test 
entry approxidate detached 	reply callback 
head type 	redis context 
dereferences repeatedly cannot 	redis 
dereference anymore 	reply reply 
given type whichever 	privdata shift 
comes first 	detect execution 
means dereference tags 	order test 
non tag 	callback flags 
shorthand commit 	test 
commit could used 	callback flags 
find top 	privdata reply 
level given commit 	free reply 
beginning type 	reply redis 
name closing brace 	context connect 
empty point 	nonblock 
syntax look correct 	reset callback 
needed barf 	flags test 
commit foo commit 	callback flags 
regex implementation 	redis connect 
may reject need 	non block 
regex anyway 	port 
pattern always matches 	test nonblocking 
must looking 	connection redis 
something describe output 	context wdone 
name name 	test calls 
name name 	command callback 
name name suffix 	command 
goes without 	issued connect 
saying could describe 	nonblock redis 
output something 	command callback 
xxxx interprets names 	test callback 
like initial 	redis command 
revision git searching 	ping 
history returning 	test cond 
first commit whose 	test callback 
message starts 	flags redis 
given regular expression 	free test 
negative matching 	calls disconnect 
prefix pattern part 	callback 
like wip 	redis disconnect 
character beginning pattern 	connect nonblock 
repeat like 	redis disconnect 
foo future extension 	callback test 
sequences beginning 	callback redis 
reserved remember 	disconnect 
update flag allocation 	test cond 
done parse 	test callback 
syntax number characters 	flags redis 
parsed successful 	free test 
otherwise signal error 	calls disconnect 
negative parse 	callback 
something syntax something 	free callback 
make sure 	redis free 
single foo extra 	connect nonblock 
data might 	redis disconnect 
need processing data 	callback test 
interpreted cruft 	callback 
tweak size versus 	redis free 
expanded name 	callback test 
reads hand syntax 	callback redis 
evaluates commit 	free test 
name also act 	cond test 
end user 	callback 
spelled name 	flags test 
branch command line 	redis buffer 
finds name 	write empty 
nth previous branch 	write buffer 
places name 	connect nonblock 
branch given buf 	test 
returns number 	cond redis 
characters parsed successful 	buffer write 
branch upstream 	wdone redis 
finds name branch 	wdone redis 
configured merge 	free test 
missing branch defaults 	redis 
current branch 	buffer write 
places name branch 	yet connected 
given buf 	connect nonblock 
returns number characters 	redis command 
parsed successful 	ping test 
input accepted format 	cond 
returns negative 	redis buffer 
number signal 	write redis 
error input branch 	err strncmp 
switches reflog 	error write 
returns syntax enough 	redis free 
switches consumed 	test 
like sha basic 	redis buffer 
allows sha 	write closed 
expressions notably xyz 	connect nonblock 
parent xyz 	redis command 
many callers know 	ping redis 
user meant 	disconnect 
name commit ish 	test cond 
syntactical positions 	redis buffer 
name appears calling 	write redis 
function allows 	err strncmp 
machinery disambiguate shorter 	error write 
unique abbreviated 	redis 
names commit ish 	free test 
others note 	process callbacks 
error named 	right sequence 
commit ish merely 	connect nonblock 
give hint 	redis command 
disambiguation machinery must 	callback 
called name 	test reply 
filename doesn exist 	callback ping 
must called 	redis command 
stage filename doesn 	callback test 
exist wrong 	reply callback 
stage number confusion 	ping 
relative absolute 	redis command 
filenames die inside 	callback test 
prefix path 	reply callback 
resolved path outside 	ping write 
worktree sha 	output buffer 
path name path 	wdone 
ent sha 	wdone usleep 
path name 	redis buffer 
absolute path index 	write wdone 
path name 	read least 
path relative cwd 	one callback 
index path 	executed 
name path index 	replies arrive 
stage foo 	single packet 
recent commit matching 	causing callbacks 
foo call 	executed single 
function know name 	pass test 
given end 	callback 
user must name 	flags redis 
doesn function 	buffer read 
may die better 	redis redis 
diagnostic message 	process callbacks 
name path doc 	test cond 
exist head 	test 
given head doc 	callback flags 
may chance 	redis free 
diagnose error 	test redis 
shallow.c shallow shallow 	disconnect executes 
stat alternate 	pending callbacks 
shallow file path 	reply 
sha graft 	connect nonblock 
commit buf path 	redis disconnect 
sha heads 	callback test 
depth shallow flag 	callback redis 
shallow flag 	command callback 
cur depth result 	test 
stack commit 	reply callback 
graft pointer pointer 	ping redis 
use pack 	disconnect test 
protocol count flags 	cond test 
graft data 	callback flags 
data hex use 	redis 
pack protocol 	free ignore 
extra flags data 	broken pipe 
use pack 	signal error 
protocol extra 	tests parse 
temporary shallow extra 	command line 
shallow alternate 	options 
shallow file extra 	make sure 
graft show 	initialization occurs 
shallow trace shallow 	prior running 
info graft 	tests tests 
info info dst 	special may 
bitmap bits 	use 
slab free end 	facilities prior 
slab count 	triggering initialization 
info size info 	side effect 
sha head 	calling api 
bitmap bitmap size 	safety works 
tmp bitmap 	even 
refs refs refname 	jemalloc constructor 
oid flags 	doesn run 
data commit info 	msvc builds 
bitmap status 	test count 
info used 	test counts 
status shallow shallow 	test 
bitmap size 	status test 
map commits alloc 	name format 
refname oid 	format test 
flags data status 	status name 
bitmap info 	ret prefix 
bitmap status bitmap 	message 
dst bitmap 	start malloc 
commit die free 	vcprintf end 
xstrdup xmalloc 	malloc start 
lookup commit hashcpy 	malloc vcprintf 
commit graft 	end malloc 
git path shallow 	reached 
fopen stat 	malloc test 
validity clear stat 	status nallocx 
validity update 	malloc start 
fileno fgets 	arg end 
sha hex die 	malloc test 
shallow fclose 	status 
deref tag xmalloc 	test status 
parse commit 	test status 
die repository shallow 	malloc cprintf 
lookup commit 	following lines 
graft commit list 	make testing 
insert xmalloc 	framework 
die stat validity 	testing know 
check git 	chat make 
path shallow die 	sure empty 
oid hex 	awesome empty 
lookup commit oid 	make sure 
hex packet 	free 
buf write strbuf 	context well 
addstr strbuf 	keep requested 
addch commit graft 	create dummy 
strbuf addstr 	connection inherit 
sha hex 	vararg width 
strbuf addch write 	depends 
shallow commits 	type tests 
write shallow commits 	make sure 
xmks tempfile 	width correctly 
git path write 	determined format 
full die 	subsequent varargs 
errno tempfile path 	correctly 
close tempfile 	interpolated reply 
strbuf release tempfile 	already contains 
path tempfile 	multiple items 
path hold file 	must free 
update git 	error valgrind 
path shallow check 	bark 
shallow file 	doesn happen 
update write shallow 	regression test 
commits write 	issue git 
full die errno 	hub care 
file path 	message test 
file path 	multi 
strbuf release packet 	bulk reply 
write oid 	reply specifically 
hex repository shallow 	test ordering 
commit graft 	reply items 
write shallow commits 	parse connect 
strbuf release 	target 
hold file update 	given config 
git path 	find redis 
shallow check shallow 	version determine 
file update 	path next 
write shallow commits 	test next 
write full 	first 
die errno file 	returns quit 
path commit 	read issued 
file unlink git 	know descriptor 
path shallow 	eof quit 
rollback file strbuf 	cause connection 
release trace 	closed 
key init 	immediately read 
trace key memset 	reply quit 
alloc alloc 	error eof 
sha file lookup 	quit another 
commit graft 	read needed 
free free trace 	issued 
key sha 	find socket 
file define commit 	closed server 
slab realloc 	conditions error 
xmalloc mult xmalloc 	eof test 
paint alloc 	callback flags 
lookup commit reference 	test 
gently memset 	callback redis 
commit list insert 	context privdata 
pop commit 	shift detect 
bitmap memcpy memcmp 	execution order 
paint alloc 	test callback 
memcpy parse 	flags 
commit die oid 	test callback 
hex bitmap 	flags privdata 
commit list insert 	test reply 
max index 	callback redis 
indexed free lookup 	context redis 
commit reference 	reply 
gently mark parents 	reply privdata 
uninteresting trace 	shift detect 
key alloc max 	execution order 
index indexed 	test callback 
memset init bitmap 	flags test 
head lookup 	callback 
commit paint memset 	flags privdata 
lookup commit 	reply free 
bitmap xmemdupz post 	reply reply 
assign shallow 	redis context 
clear bitmap free 	connect nonblock 
free free 	reset 
alloc grow 	callback flags 
lookup commit reference 	test callback 
gently trace 	flags redis 
key memset lookup 	connect non 
commit bitmap 	block port 
update refstatus memset 	test 
head lookup 	nonblocking connection 
commit bitmap merge 	redis context 
bases many 	wdone test 
update refstatus free 	calls command 
lookup commit 	callback 
memset head merge 	command issued 
bases many 	connect nonblock 
fetch pack sets 	redis command 
shallow file 	callback test 
indicator shallow file 	callback redis 
used could 	command 
open likely fail 	ping test 
check instead 	cond test 
repository shallow 	callback flags 
sees empty shallow 	redis free 
file repository 	test calls 
shallow sees empty 	disconnect 
shallow file 	callback redis 
mark reachable objects 	disconnect connect 
run prior 	nonblock redis 
reachable commits marked 	disconnect callback 
seen step 	test callback 
split sender shallow 	redis 
commits step 	disconnect test 
clean git shallow 	cond test 
step non 	callback flags 
existent ones getting 	redis free 
pack given 	test calls 
commit sha walk 	disconnect 
parents either 	callback free 
seen uninteresting bottom 	callback redis 
hit bit 	free connect 
bitmap walked 	nonblock redis 
commits freed xxx 	disconnect callback 
check uninteresting 	test 
pack bitmaps available 	callback redis 
step associate 	free callback 
shallow commits refs 	test callback 
info must 	redis free 
initialized calling function 	test cond 
used info 	test 
shallow bitmaps bit 	callback flags 
bitmap needs 	test redis 
shallow commit info 	buffer write 
shallow used 	empty write 
updated status ints 	buffer connect 
status needs 	nonblock 
shallow commits either 	test cond 
info info 	redis buffer 
prepare commit graph 	write wdone 
track refs 	redis wdone 
reach shallow 	redis free 
commits cut traversal 	test 
refs connect 	redis buffer 
old refs force 	write yet 
updates current 	connected connect 
shallow commits mark 	nonblock redis 
potential bottoms 	command ping 
won bound unreachable 	test 
shallow commits 	cond redis 
removed user supposed 	buffer write 
run step 	redis err 
every separately trust 	strncmp error 
step reachability 	write redis 
test commit level 	free 
unreachable shallow 	test redis 
commits unreachable shallow 	buffer write 
commits step 	closed connect 
reachability test 	nonblock redis 
commit level delayed 	command ping 
step reachability 	redis 
test commit level 	disconnect test 
shell.c arg 	cond redis 
argv arg cvsserver 	buffer write 
argv cmd 	redis err 
prog home done 	strncmp error 
help argv 	write 
argv status line 	redis free 
prog full 	test process 
cmd rawargs split 	callbacks right 
args argv 	sequence connect 
code count name 	nonblock redis 
arg argc 	command 
argv prog user 	callback test 
argv cmd 	reply callback 
count len arg 	ping redis 
setup path 	command callback 
dequote die 	test reply 
starts die execv 	callback 
git cmd 	ping redis 
strcmp die setup 	command callback 
path execv 	test reply 
git cmd strcspn 	callback ping 
xstrfmt getenv 	write output 
die chdir die 	buffer 
access run 	wdone wdone 
command opt exit 	usleep redis 
exit run 	buffer write 
command opt strbuf 	wdone read 
getline strbuf 	least one 
release strbuf trim 	callback 
strbuf detach 	executed replies 
xstrdup split cmdline 	arrive single 
split cmdline 	packet causing 
strerror free free 	callbacks executed 
strcmp strcmp 	single pass 
strcmp strcmp 	test 
strcmp valid cmd 	callback flags 
name make 	redis buffer 
cmd run command 	read redis 
opt free 	redis process 
free free git 	callbacks test 
setup gettext 	cond 
git extract argv 	test callback 
path sanitize 	flags redis 
stdfds strcmp homedir 	free test 
access die 	redis disconnect 
run shell exit 	executes pending 
strcmp die 	callbacks 
xstrdup strncmp isspace 	reply connect 
strlen strncmp 	nonblock redis 
exit exec homedir 	disconnect callback 
split cmdline 	test callback 
valid cmd name 	redis command 
make cmd 	callback 
execv free 	test reply 
free die free 	callback ping 
die split 	redis disconnect 
cmdline strerror test 	test cond 
command contains 	test callback 
characters interactive login 	flags 
disabled print 	redis free 
help enabled always 	ignore broken 
open file 	pipe signal 
descriptors avoid clobbering 	error tests 
files die 	parse command 
also avoids messing 	line 
pipes dup 	options make 
onto stdin stdout 	sure initialization 
stderr child 	occurs prior 
processes spawn special 	running tests 
hack pretend 	tests special 
cvs server 	may 
allow user run 	use facilities 
interactive shell 	prior triggering 
accept modes followed 	initialization side 
cmd arg 	effect calling 
cmd limited subset 	api safety 
git commands 	works 
command command dir 	even jemalloc 
accept git 	constructor doesn 
foo caller said 	run msvc 
git foo 	builds test.c 
shortlog.c shortlog usage 	host port 
log author 	timeout 
oneline item mailbuf 	path fails 
namebuf namelen 	reply keep 
maillen namemailbuf ident 	reply config 
dot buffer 	dummy ctx 
subject eol eob 	cmd len 
dot len 	argv 
taillen log 	lens argc 
author oneline log 	config reply 
commit author 	cmd len 
oneline ctx rev 	reader reply 
log commit 	ret config 
arg comma defval 	reply 
ret endp 	config reply 
wrap arg usage 	reply major 
opt arg 	minor field 
unset log log 	eptr config 
argc argv 	config replies 
prefix log rev 	num 
nongit options 	argc argv 
ctx log log 	cfg throughput 
item onelines 	test inherit 
msg split ident 	gettimeofday redis 
line strlen 	command free 
map user strbuf 	reply 
strbuf addf 	redis command 
list insert 	free reply 
isspace strchr strlen 	exit redis 
starts strchr 	command free 
isspace format subject 	reply redis 
strbuf detach 	command 
strlen strstr strlen 	free reply 
memcpy memmove 	redis free 
xcalloc list append 	keep redis 
strbuf getline 	free redis 
skip prefix skip 	connect redis 
prefix strbuf 	connect 
getline strbuf getline 	unix redis 
insert one 	connect unix 
record strbuf release 	disconnect redis 
strbuf release 	connect exit 
log output encoding 	exit database 
format commit 	test 
message pretty print 	redis format 
commit format 	command test 
commit message 	cond strncmp 
insert one record 	free test 
strbuf release 	redis format 
strbuf release prepare 	command 
revision walk 	test cond 
die revision shortlog 	strncmp free 
commit strtoul 	test redis 
parse parse parse 	format command 
error error 	test cond 
memset read mailmap 	strncmp 
git config 	free test 
shortlog init init 	redis format 
revisions parse 	command test 
options start parse 	cond strncmp 
options step 	free test 
exit parse revision 	redis 
opt parse 	format command 
options end 	test cond 
setup revisions error 	strncmp free 
usage options 	test redis 
isatty head pending 	format command 
isatty read 	test 
stdin rev shortlog 	cond strncmp 
output strbuf 	free test 
wrapped text strbuf 	redis format 
addch qsort 	command test 
strbuf reset wrapped 	cond strncmp 
shortlog msg 	free 
fwrite putchar list 	integer width 
clear free 	test integer 
strbuf release list 	width test 
clear clear 	integer width 
mailmap field list 	test integer 
items contain 	width 
one two things 	test width 
summary use 	test width 
point list 	test test 
oneline subjects assigned 	redis format 
author summary 	command test 
use need list 	cond 
need know 	test redis 
size abuse pointer 	format command 
slot store 	argv test 
integer counter macro 	cond strncmp 
accesses latter 	free test 
skip leading whitespace 	redis 
including blank 	format command 
lines discard headers 	argv test 
discard blanks 	cond strncmp 
head tty shortlog.h 	free connect 
list summary 	test redis 
wrap lines sort 	format 
number wrap 	command test 
user format abbrev 	cond redis 
common repo 	append formatted 
prefix email 	command redis 
mailmap log log 	reply free 
commit log 	free 
show-branch.c show branch 	reply disconnect 
usage showbranch 	test redis 
use color args 	reader create 
idx list 	redis reader 
commit head name 	feed redis 
generation commit 	reader 
head name nth 	reply test 
name commit 	cond strcasecmp 
parent commit name 	redis reader 
parent name 	free test 
list rev name 	redis reader 
num rev 	create 
parents nth newname 	redis reader 
commit seen 	feed redis 
list seen num 	reader feed 
rev extra 	redis reader 
mask revs 	feed redis 
parents still interesting 	reader 
commit flags 	reply test 
flag changed parents 	cond strcasecmp 
commit name 	redis reader 
pretty pretty str 	free test 
name name 	redis reader 
name cnt ver 	create 
bottom top 	redis reader 
refname oid allow 	feed redis 
dups commit 	reader reply 
refname oid flag 	test cond 
data tmp 	strncasecmp redis 
ofs refname oid 	reader 
flag data 	free test 
tmp ofs refname 	redis reader 
oid flag 	create redis 
data match pattern 	reader feed 
match slash 	redis reader 
cnt refname 	reply 
oid flag data 	test cond 
tail slash 	redis reader 
head remotes orig 	free test 
cnt orig 	redis reader 
cnt head headlen 	create redis 
name head 	reader 
sha sha seen 	feed redis 
num rev 	reader reply 
mask revs exit 	redis reader 
status commit 	feed redis 
flags rev num 	reader reply 
rev name 	test 
rev mask commit 	cond redis 
flag revkey 	reader free 
saved matches commit 	test redis 
rev flag 	reader create 
count reflog 	redis reader 
opt arg unset 	feed 
prefix rev 	redis reader 
commit reflog msg 	reply redis 
seen rev 	reader reply 
mask num rev 	test cond 
extra remotes 	redis reader 
mask revs head 	free 
head head 	test redis 
len head oid 	reader create 
merge independent 	redis reader 
name sha name 	feed redis 
shown merge 	reader reply 
point current branch 	test 
head topics 	cond free 
dense reflog builtin 	reply redis 
show branch 	reader free 
options oid flags 	test redis 
fake logmsg 	connect test 
nth desc 	cond 
msg timestamp head 	strcmp strcmp 
offset revkey 	strcmp strcmp 
flag head commit 	strcmp redis 
flag merge 	free test 
point merge mark 	redis connect 
want color 	test 
want color xmalloc 	cond strcmp 
name commit 	redis free 
name parent name 	test redis 
commit name 	connect unix 
first parent chain 	test cond 
strbuf addstr 	redis 
strbuf addf strbuf 	free connect 
addf strbuf 	test redis 
addch strbuf addf 	command free 
name commit 	reply test 
strbuf detach name 	redis command 
first parent 	free 
chain commit 	reply test 
list insert interesting 	redis command 
pop commit 	free reply 
mark seen parse 	redis command 
commit mark 	test cond 
seen commit list 	strcmp 
insert date 	free reply 
commit easy starts 	test redis 
find unique 	command free 
abbrev puts strbuf 	reply redis 
release find 	command test 
digit prefix find 	free 
digit prefix 	reply test 
version cmp qsort 	redis command 
lookup commit 	free reply 
reference gently strcmp 	test redis 
warning xstrdup 	command free 
starts sha oidcmp 	reply 
append starts 	test free 
sha oidcmp 	reply redis 
append starts append 	command free 
count slash 	reply redis 
wildmatch starts append 	command redis 
head starts 	command 
append tag append 	free reply 
sort range 	test free 
sort range hashcmp 	reply redis 
starts starts 	command free 
starts strcmp pop 	reply redis 
commit puts 	command 
oid hex puts 	free reply 
oid hex 	redis command 
sha append strchr 	redis command 
strchr strchr 	test cond 
count slash error 	memcmp memcmp 
sort range 	strcasecmp 
die strcmp 	free reply 
config error nonbool 	disconnect connect 
argv push 	redis command 
argv push strcmp 	strstr strtol 
git config 	strlen strtol 
colorbool git color 	free 
config strtoul 	reply test 
error git config 	redis command 
parse options 	test cond 
usage options die 	strcasecmp redis 
resolve refdup 	reply free 
die die die 	reply 
dwim strlen 	test cond 
die strtoul approxidate 	strcmp redis 
read read 	free connect 
strchr xstrfmt show 	test redis 
date date 	timeout test 
mode free xstrfmt 	cond 
append free 	redis reply 
free append 	redis free 
one rev snarf 	test redis 
refs resolve 	connect timeout 
strlen memcpy rev 	test cond 
head starts 	test 
append one rev 	redis connect 
exit die 	timeout test 
sha die lookup 	cond redis 
commit reference 	free connect 
die oid hex 	test free 
parse commit 	reply 
mark seen commit 	redis command 
list insert 	malloc usec 
date revs commit 	redis command 
list sort 	usec free 
date show merge 	reply free 
show independent 	malloc 
rev head putchar 	usec redis 
color code 	command usec 
color reset 	free reply 
code show one 	free malloc 
commit puts 	redis append 
putchar putchar exit 	command 
sort topological 	usec redis 
order name commits 	reply usec 
pop commit 	free reply 
omit dense color 	free malloc 
code color 	redis append 
reset code putchar 	command 
show one 	usec redis 
commit exceed bits 	reply usec 
per rev 	free reply 
shift head ancestor 	free disconnect 
many parents 	signal strcmp 
away head name 	strcmp 
name commit 	atoi strcmp 
nth generation ancestor 	strcmp strcmp 
head name 	exit test 
count first 	format commands 
parent relationship naming 	test 
purposes parent 	reply reader 
first parent commit 	test blocking 
may name 	connection errors 
generation ancestor head 	test blocking 
name commit 	connection test 
nth generation ancestor 	blocking 
generation number 	errors test 
better name already 	invalid timeout 
first give 	errors test 
names given heads 	append formatted 
commits first 	commands test 
parent ancestry chain 	throughput 
unnamed commits 	test blocking 
postprocess complete well 	connection test 
poisoning point 	blocking errors 
commits seen 	test throughput 
seen list mark 	test blocking 
anything reached 	connection 
uninteresting commits interesting 	following lines 
current commit 	make testing 
either merge already 	framework testing 
uninteresting one 	know chat 
mark parents uninteresting 	make sure 
commits already 	empty 
parsed reason find 	awesome empty 
ones avoid 	make sure 
adding thing twice 	free context 
heads foo 	well keep 
tags foo exists 	requested create 
sha would 	dummy 
confused heads foo 	connection inherit 
tags foo 	vararg width 
exists sha would 	depends type 
confused want 	tests make 
allow pattern 	sure width 
hold asterisk show 	correctly 
branches refs 	determined format 
heads hold show 	subsequent varargs 
refs tags 	correctly interpolated 
friends glob style 	reply already 
match arg 	contains multiple 
passed parse options 	items 
need mimic 	must free 
real argv bit 	error valgrind 
better commit 	bark doesn 
tip named branches 	happen regression 
omit otherwise 	test issue 
merge reachable one 	git 
tip interesting 	hub care 
nothing specified first 	message test 
listing mode 	multi bulk 
incompatible independent merge 	reply reply 
modes asking 	specifically test 
reflog mode 	ordering 
make sense list 	reply items 
also remotes 	parse connect 
make sense either 	target given 
nothing specified 	config find 
show branches specified 	redis version 
date spec 	determine 
interested adding branch 	path next 
head points 	test next 
rev uses bit 	first returns 
rev shift 	quit read 
rev uses bit 	issued know 
rev shift 	descriptor 
rev shift bits 	eof quit 
bit used 	cause connection 
bookkeeping show list 	closed immediately 
means list 	read reply 
header lines never 	quit error 
need name 	eof 
sort topologically 	quit another 
give names commits 	read needed 
show-index.c show 	issued find 
index usage argc 	socket closed 
argv version 	server conditions 
top index offset 	error 
entry sha 	eof test 
crc offset git 	callback flags 
setup gettext 	test callback 
usage fread die 	redis context 
htonl ntohl 	privdata shift 
die fread die 	detect 
fread die 	execution order 
ntohl die fread 	test callback 
die ntohl 	flags test 
sha hex alloc 	callback flags 
fread die 	privdata test 
fread die fread 	reply 
die ntohl 	callback redis 
die fread 	context redis 
die ntohl ntohl 	reply reply 
sha hex 	privdata shift 
ntohl free show-ref.c 	detect execution 
show usage 	order 
deref tags show 	test callback 
head tags 	flags test 
heads found match 	callback flags 
verify quiet 	privdata reply 
hash abbrev exclude 	free reply 
arg pattern 	reply 
exclude existing arg 	redis context 
refname oid 	connect nonblock 
hex refname oid 	reset callback 
flag cbdata 	flags test 
hex peeled match 	callback flags 
reflen len 	redis 
refname oid 	connect non 
flag cbdata list 	block port 
match existing 	test nonblocking 
refs buf matchlen 	connection redis 
len reflen 	context wdone 
opt arg unset 	test 
opt arg 	calls command 
unset show options 	callback command 
argc argv 	issued connect 
prefix oid find 	nonblock redis 
unique abbrev 	command callback 
strcmp starts starts 	test 
strlen strlen 	callback redis 
memcmp sha file 	command ping 
die oid 	test cond 
hex show one 	test callback 
peel find 	flags redis 
unique abbrev list 	free 
insert strlen 	test calls 
fgets strlen 	disconnect callback 
strcmp isspace strncmp 	redis disconnect 
check refname 	connect nonblock 
format warning list 	redis disconnect 
parse opt 	callback 
abbrev parse options 	test callback 
exclude existing 	redis disconnect 
die starts read 	test cond 
show one 	test callback 
die head die 	flags redis 
verify requires 	free 
exact match changes 	test calls 
semantics slightly 	disconnect callback 
even quiet detect 	free callback 
error repository 	redis free 
corrupt points nonexistent 	connect nonblock 
read anything 	redis 
refname standard input 	disconnect callback 
strip end 	test callback 
line ignore 	redis free 
match provided head 	callback test 
match refname 	callback redis 
warn refname well 	free 
formed refname 	test cond 
skip ignore refname 	test callback 
exists local 	flags test 
repository otherwise output 	redis buffer 
line use 	write empty 
full length sha 	write 
argument sideband.c 	buffer connect 
stream buf suffix 	nonblock test 
term skip 	cond redis 
band len brk 	buffer write 
save band 	wdone redis 
data packet max 	wdone 
ssz hdr 	redis free 
strlen memcpy getenv 	test redis 
isatty strcmp 	buffer write 
strlen packet 	yet connected 
read memcpy memcpy 	connect nonblock 
memcpy memmove 	redis 
write die xsnprintf 	command ping 
write die 	test cond 
xsnprintf write die 	redis buffer 
write die 	write redis 
receive multiplexed output 	err strncmp 
stream git 	error 
protocol stream input 	write redis 
stream remote 	free test 
carries data pkt 	redis buffer 
line format 	write closed 
band designator demultiplex 	connect nonblock 
err error 	redis 
appropriately band carries 	command ping 
primary payload 	redis disconnect 
things coming 	test cond 
band necessarily error 	redis buffer 
usually informative 	write redis 
message standard error 	err 
stream aka 	strncmp error 
verbose message band 	write redis 
signal remote 	free test 
died unexpectedly flush 	process callbacks 
concludes stream 	right sequence 
large enough last 	connect 
buffer didn 	nonblock redis 
end line print 	command callback 
prefix time 	test reply 
around look line 	callback ping 
insert suffix 	redis command 
clear end screen 	callback 
line line 	test reply 
found also skip 	callback ping 
prefix non 	redis command 
empty must 	callback test 
present connected remote 	reply callback 
side send 	ping 
sideband data multiplexed 	write output 
packet stream 	buffer wdone 
sideband.h stream band 	wdone usleep 
data packet 	redis buffer 
max sigchain.c old 	write wdone 
alloc signals 	read 
sig sig sig 	least one 
die check 	callback executed 
signum alloc grow 	replies arrive 
signal check 	single packet 
signum signal sigchain 	causing callbacks 
push sigchain 	executed 
push sigchain push 	single pass 
sigchain push 	test callback 
sigchain push sigchain 	flags redis 
pop sigchain 	buffer read 
pop sigchain 	redis redis 
pop sigchain pop 	process 
sigchain pop 	callbacks test 
sigchain.h sig sig 	cond test 
sigchain sliding 	callback flags 
windowc file file 	redis free 
gap file 	test redis 
buf width offset 	disconnect 
len view 	executes pending 
width file offset 	callbacks reply 
buffer ferror 	connect nonblock 
error error strerror 	redis disconnect 
buffer skip 	callback test 
bytes input error 	callback 
buffer read 	redis command 
binary input error 	callback test 
maximum type 	reply callback 
error overflows error 	ping redis 
check offset 	disconnect test 
overflow check 	cond 
offset overflow error 	test callback 
error strbuf 	flags redis 
skip whine strbuf 	free ignore 
setlen read 	broken pipe 
fill whine licensed 	signal error 
two clause 	tests 
bsd style license 	parse command 
see license 	line options 
details move overlapping 	make sure 
region place 	initialization occurs 
seek ahead skip 	prior running 
gap already 	tests 
read sliding windowh 	tests special 
file width 	may use 
max buf view 	facilities prior 
width means 	triggering initialization 
unlimited snprintf.c 	side effect 
str maxsize format 	calling 
ret str 	api safety 
maxsize format ret 	works even 
copy vsnprintf 	jemalloc constructor 
end realloc copy 	doesn run 
vsnprintf end 	msvc builds 
free start git 	test 
vsnprintf end 	count test 
size parameter specifies 	counts test 
available space 	status test 
includes trailing nul 	name format 
windows vsnprintf 	format test 
uses entire buffer 	status 
avoids trailing 	name ret 
nul buffer exactly 	prefix message 
big enough 	start malloc 
result defining snprintf 	vcprintf end 
size corr 	malloc start 
therefore reported 	malloc 
buffer size always 	vcprintf end 
room trailing 	malloc reached 
nul windows nul 	malloc test 
terminate result 	status nallocx 
fills buffer split-index.c 	malloc start 
istate istate 	arg 
data data ret 	end malloc 
istate istate 	test status 
pos data istate 	test status 
pos data 	test status 
istate dst src 	malloc cprintf 
istate istate 	following 
alloc ondisk flags 	lines make 
flags flags 	testing framework 
ret istate istate 	testing know 
istate istate 	chat make 
old xcalloc error 	sure empty 
init split 	awesome 
index hashcpy 	empty make 
ewah ewah read 	sure free 
mmap error 	context well 
ewah ewah read 	keep requested 
mmap error 	create dummy 
error strbuf ewah 	connection 
serialize strbuf 	inherit vararg 
ewah serialize strbuf 	width depends 
xcalloc alloc 	type tests 
grow memcpy mark 	make sure 
index entries 	width correctly 
die die die 	determined 
die namelen 	format subsequent 
die copy cache 	varargs correctly 
entry free 	interpolated reply 
mark index entries 	already contains 
alloc grow 	multiple items 
memcpy ewah bit 	must 
ewah bit 	free error 
marked cache 	valgrind bark 
entries namelen die 	doesn happen 
index entry 	regression test 
ewah free ewah 	issue git 
free free 	hub 
init split index 	care message 
ewah ewah 	test multi 
strcmp memcmp offsetof 	bulk reply 
offsetof free 	reply specifically 
ewah ewah alloc 	test ordering 
grow alloc 	reply 
grow init split 	items parse 
index ewah 	connect target 
free ewah free 	given config 
free discard 	find redis 
index free free 	version determine 
free free 	path 
keep track shared 	next test 
entries istate 	next first 
cache istate 	returns quit 
cache entry position 	read issued 
stored entry 	know descriptor 
positions start instead 	eof 
resrved say 	quit cause 
entry old index 	connection closed 
entries may 	immediately read 
shared istate cache 	reply quit 
accept bit 	error eof 
leaking code used 	quit 
lived update 	another read 
index zero timestamp 	needed issued 
disables racy 	find socket 
test write index 	closed server 
may replay 	conditions error 
merge recursive update 	eof 
stages flag 	test callback 
istate cache 	flags test 
mark matched entry 	callback redis 
positive index 	context privdata 
cache later entries 	shift detect 
marked eith 	execution 
either matched update 	order test 
istate cache 	callback flags 
duplicate deduplicate namelen 	test callback 
separately shared 	flags privdata 
disk flags matter 	test reply 
take cache 	callback 
temporarily put entries 	redis context 
place writing 	redis reply 
split-index.h sha bitmap 	reply privdata 
replace bitmap 	shift detect 
saved cache saved 	execution order 
cache deletions 	test 
replacements refcount istate 	callback flags 
istate replace 	test callback 
index entry 	flags privdata 
istate data istate 	reply free 
istate istate 	reply reply 
istate istate istate 	redis 
stat.c mode 	context connect 
perm bits path 	nonblock reset 
buf buf 	callback flags 
path buf isreg 	test callback 
isdir islnk 	flags redis 
isblk ischr isfifo 	connect 
issock stat 	non block 
mode git fstat 	port test 
mode git 	nonblocking connection 
lstat mode git 	redis context 
stat mode 	wdone test 
non standard type 	calls 
bits given 	command callback 
strbuf.c str prefix 	command issued 
strbuf slopbuf 	connect nonblock 
hint res 	redis command 
buf len alloc 	callback test 
extra buf 	callback 
len end str 	redis command 
slen terminator 	ping test 
max ret alloc 	cond test 
len end 	callback flags 
sbs len cmp 	redis free 
pos len 	test 
data dlen pos 	calls disconnect 
data len 	callback redis 
pos len data 	disconnect connect 
len pos 	nonblock redis 
len fmt prefix 	disconnect callback 
prefix buf 	test 
size prefix next 	callback redis 
buf size 	disconnect test 
prefix prefix fmt 	cond test 
buf incomplete 	callback flags 
line fmt 	redis free 
len format context 	test 
percent consumed 	calls disconnect 
placeholder context len 	callback free 
dst src 	callback redis 
len size res 	free connect 
oldalloc hint 	nonblock redis 
oldlen oldalloc want 	disconnect 
got hint 	callback test 
cnt path hint 	callback redis 
oldalloc len 	free callback 
oldalloc guessed len 	test callback 
term term 	redis free 
term term len 	test 
path hint 	cond test 
len prefix buf 	callback flags 
size buf 	test redis 
len len 	buffer write 
reserved reserved buf 	empty write 
bytes path 	buffer 
cwd stat pwd 	connect nonblock 
stat orig 	test cond 
len cwd pwd 	redis buffer 
fmt ret 	write wdone 
fmt ret result 	redis 
len fmt 	wdone redis 
buf fmt ret 	free test 
fmt hint 	redis buffer 
len munged fmt 	write yet 
sha abbrev 	connected connect 
len line len 	nonblock 
skip comments 	redis command 
empties len newlen 	ping test 
eol strbuf 	cond redis 
grow free strbuf 	buffer write 
init strbuf 	redis err 
grow strbuf 	strncmp 
init strbuf release 	error write 
strbuf grow 	redis free 
overflows overflows die 	test redis 
alloc grow 	buffer write 
strbuf rtrim strbuf 	closed connect 
ltrim isspace 	nonblock 
isspace memmove encoding 	redis command 
reencode len 	ping redis 
strbuf attach tolower 	disconnect test 
memchr xmalloc 	cond redis 
strbuf init strbuf 	buffer write 
alloc grow 	redis 
alloc grow strbuf 	err strncmp 
release free 	error write 
free memcmp overflows 	redis free 
die die 	test process 
die strbuf grow 	callbacks right 
memmove memcpy 	sequence 
strbuf setlen 	connect nonblock 
strbuf splice strbuf 	redis command 
splice strbuf 	callback test 
grow memcpy strbuf 	reply callback 
setlen strbuf 	ping redis 
grow memcpy strbuf 	command 
setlen strbuf 	callback test 
grow memset strbuf 	reply callback 
setlen start 	ping redis 
strbuf vaddf end 	command callback 
memchr strbuf 	test reply 
addstr strbuf strbuf 	callback 
complete line 	ping write 
xsnprintf xsnprintf lines 	output buffer 
start strbuf 	wdone wdone 
vaddf end strbuf 	usleep redis 
commented lines 	buffer write 
strbuf release strbuf 	wdone 
avail strbuf 	read least 
grow copy 	one callback 
vsnprintf end die 	executed replies 
strbuf avail 	arrive single 
strbuf grow vsnprintf 	packet causing 
strbuf avail 	callbacks 
die strbuf setlen 	executed single 
strchrnul strbuf 	pass test 
strbuf addch strbuf 	callback flags 
addch strlen 	redis buffer 
strncmp strbuf addstr 	read redis 
strbuf addch 	redis 
strbuf addch strbuf 	process callbacks 
grow fread 	test cond 
strbuf setlen strbuf 	test callback 
release strbuf 	flags redis 
grow read full 	free test 
strbuf release 	redis 
strbuf setlen 	disconnect executes 
strbuf grow strbuf 	pending callbacks 
grow xread 	reply connect 
strbuf setlen strbuf 	nonblock redis 
grow readlink 	disconnect callback 
strbuf setlen strbuf 	test 
release strbuf 	callback redis 
grow getcwd strbuf 	command callback 
setlen strlen 	test reply 
strbuf release strbuf 	callback ping 
reset feof 	redis disconnect 
strbuf reset getdelim 	test 
die strbuf 	cond test 
init feof strbuf 	callback flags 
reset flockfile 	redis free 
getc unlocked strbuf 	ignore broken 
avail strbuf 	pipe signal 
grow funlockfile strbuf 	error 
getwholeline strbuf 	tests parse 
setlen strbuf 	command line 
getwholeline strbuf setlen 	options make 
strbuf setlen 	sure initialization 
strbuf getdelim strbuf 	occurs prior 
getdelim strbuf 	running 
reset xread strbuf 	tests tests 
addch open 	special may 
strbuf read close 	use facilities 
lines strcspn 	prior triggering 
strbuf strbuf addstr 	initialization side 
strbuf addstr 	effect 
strbuf addstr strbuf 	calling api 
addstr isalnum 	safety works 
strbuf grow rfc 	even jemalloc 
unreserved rfc 	constructor doesn 
reserved strbuf addch 	run msvc 
strbuf addf 	builds 
strbuf urlencode strlen 	test.h jemalloc 
strbuf addf 	format jemalloc 
strbuf addf 	format name 
strbuf addf strbuf 	prefix message 
addf die 	changes corresponding 
absolute path xgetcwd 	changes 
getenv strcmp 	test test 
stat stat strbuf 	also necessary 
addstr strbuf 	use macros 
addstr dir sep 	testhelp.h failed 
strbuf addch 	tests test 
free strbuf addstr 	num 
start vprintf 	really minimal 
end putchar start 	testing framework 
vfprintf end 	example test 
putc strlen xmallocz 	cond check 
tolower strbuf 	test cond 
vaddf strbuf detach 	check 
start xstrvfmt 	test report 
end strbuf grow 	copyright salvatore 
strftime strbuf 	sanfilippo antirez 
addf strbuf 	gmail dot 
grow strftime strbuf 	rights reserved 
release strbuf 	redistribution 
setlen strbuf grow 	use source 
find unique 	binary forms 
abbrev strbuf setlen 	without modification 
isspace strbuf 	permitted provided 
grow memchr cleanup 	following conditions 
memmove strbuf 	met 
setlen used buf 	redistributions source 
people always 	code must 
buf non buf 	retain copyright 
nul terminated 	notice list 
even freshly initialized 	conditions following 
strbuf empty 	disclaimer 
buffer small translate 	redistributions binary 
slopbuf cannot 	form must 
call realloc normally 	reproduce copyright 
would called 	notice list 
xrealloc free 	conditions following 
memory recover way 	disclaimer 
tell getdelim 	documentation materials 
worse cannot recover 	provided distribution 
enomem idea 	neither name 
many bytes read 	redis names 
getdelim dying 	contributors may 
reasonable mirrors xrealloc 	used 
would catastrophic 	endorse promote 
memory failure skip 	products derived 
opportunity free 	software without 
pack memory retry 	specific prior 
unlikely help 	written permission 
malloc small enough 	software 
hold single 	provided copyright 
line input anyway 	holders contributors 
restore slopbuf 	express implied 
moved way 	warranties including 
rounding rounding strftime 	limited implied 
reports could 	warranties 
fit result buffer 	merchantability fitness 
unfortunately also 	particular purpose 
reports requested time 	disclaimed shall 
takes bytes 	copyright owner 
strategy munge format 	contributors liable 
output contains 	direct 
least one character 	indirect incidental 
drop extra 	special exemplary 
character returning drop 	consequential damages 
munged space 	including limited 
returns length line 	procurement substitute 
without trailing 	goods 
spaces line ends 	services loss 
newline removed 	use data 
empty lines beginning 	profits business 
end also 	interruption however 
trailing spaces 	caused theory 
every line turn 	liability 
multiple consecutive 	whether contract 
empty lines paragraphs 	strict liability 
one empty 	tort including 
line input empty 	negligence otherwise 
lines spaces 	arising way 
output produced last 	use 
line newline 	software even 
end one added 	advised possibility 
enable skip 	damage thd.c 
comments skip every 	thd proc 
line starting 	arg routine 
comment character may 	thd 
newline empty 	ret exit 
line strbuf.h alloc 	code thd 
len buf 	proc arg 
strbuf slopbuf strbuf 	thd ret 
strbuf strbuf 	create test 
strbuf tmp 	fail 
strbuf len strbuf 	wait single 
strbuf strbuf 	exit code 
strbuf strbuf strbuf 	pthread create 
pos strbuf 	test fail 
pos len strbuf 	pthread thd.h 
pos len 	thd 
buf size strbuf 	proc arg 
pos len 	thd ret 
format context placeholder 	abstraction layer 
placeholder context 	threading tests 
dst src buf 	thread arenac 
bytes fmt 	arg 
fmt fmt fmt 	main arena 
strbuf strbuf 	ind arena 
hint strbuf hint 	ind size 
path hint 	err buf 
path hint strbuf 	buf arena 
strbuf strbuf 	ind 
path buf 	size err 
skip comments buf 	thds buf 
skip comments 	ret malloc 
suffix terminator max 	ptr free 
str terminator 	mallctl buferror 
max terminator max 	test 
terminator strbuf 	fail mallctl 
sha abbrev len 	buferror test 
path buffer 	fail malloc 
env prefix buf 	ptr mallctl 
size term 	buferror test 
name name strbuf 	fail 
reserved fmt 	thd create 
fmt fmt fmt 	thd test 
die strbuf 	thread tcache 
avail strbuf grow 	enabledc config 
strbuf strlen 	tcache arg 
strbuf grow 	err 
strbuf strbuf stripspace 	thd mallctl 
strip suffix 	mallctl mallctl 
mem strbuf setlen 	mallctl mallctl 
strbuf split 	mallctl free 
buf strlen strbuf 	malloc mallctl 
split buf 	free 
strbuf split max 	malloc mallctl 
strbuf addch 	free malloc 
strbuf complete strbuf 	mallctl free 
meant used 	malloc mallctl 
usual memory given 	free malloc 
length buffer 	test 
known often better 	skip thd 
use mem 	start thd 
functions str one 	create thd 
memchr strchr 	test run 
though one careful 	tests multiple 
fact str 	times 
functions often 	check bad 
stop strbufs may 	interactions timer.c 
embedded strbuf 	timer timer 
nul terminated convenience 	timer buf 
function strbuf 	buflen mult 
api actually relies 	round 
free strbufs 	system time 
invariants important keep 	file time 
mind buf 	sysconf clock 
member never used 	gettime gettimeofday 
usual operations 	system time 
safely strbuf initialized 	file 
either strbuf 	time clock 
init strbuf init 	gettime gettimeofday 
invariants though 	timer usec 
anything buf really 	timer usec 
allocated memory 	malloc snprintf 
use strbuf detach 	malloc 
unwrap memory 	snprintf malloc 
buffer strbuf 	snprintf whole 
shell safe way 	fraction timer.h 
sole supported 	timer timer 
way give malloced 	timer buf 
buffer later 	buflen 
free however totally 	simple timer 
safe modify 	use benchmark 
anything pointed buf 	reporting tsd.c 
member indices 	ncleanups cleanups 
len inclusive buf 	size wrapper 
member least 	arg 
len bytes allocated 	pending arg 
extra used 	tsd state 
store allowing buf 	hinst dll 
member valid 	fdw reason 
every strbuf function 	lpv reserved 
ensure invariant 	head 
preserved note play 	block self 
buffer directly 	iter head 
work way 	block malloc 
strbuf grow size 	cacheline ceiling 
strbuf setlen 	dalloc reached 
len size memory 	tsd 
starting buf 	tsd reached 
length strbuf avail 	tsd boot 
sure strbuf 	tsd arenas 
avail least size 	cache bypassp 
note size 	tsd fetch 
must smaller equal 	tsd 
strbuf avail 	boot tsd 
safe though done 	arenas cache 
many places 	bypassp tsd 
adding missing api 	fetch malloc 
strbuf module 	cleanup pthread 
way warning area 	self 
size alloc 	malloc mutex 
even current 	malloc mutex 
implementation alloc somehow 	unlock elm 
member messed 	tail insert 
use strbuf avail 	malloc mutex 
instead data 	unlock 
structures buffer structure 	malloc mutex 
len member 	malloc mutex 
used determine current 	unlock data 
length buf 	nothing previous 
member provides access 	time destructor 
life cycle 	called 
functions initialize structure 	state tsd 
second parameter 	state purgatory 
zero bigger number 	destructors wouldn 
allocate memory 	cause creation 
want prevent reallocs 	tsd time 
release buffer 	nothing 
memory used use 	request another 
buffer function 	callback another 
unless initialize 	destructor deallocated 
detach strbuf returns 	memory destructor 
storage occupies 	called reset 
responsibility release free 	state 
done attach 	tsd state 
buffer specify attach 	purgatory request 
current length 	another callback 
amount allocated memory 	check whether 
amount must 	already inserted 
larger length pass 	list 
supposed nul 	insert block 
terminated must malloc 	list allocate 
attaching pointer 	cleanup two 
cannot relied upon 	rounds order 
anymore neither 	assure jemalloc 
free directly swap 	tsd 
contents two 	reinitialization happens 
buffers functions related 	data cleanup 
size buffer 	executed arg 
determine amount 	data arg 
allocated unused memory 	thd data 
ensure least 	tsd 
amount unused memory 	data tsd 
available len 	reached mallocx 
used know typical 	ptr dallocx 
size want 	data tsd 
avoid repetitive automatic 	malloc ptr 
resizing underlying 	data 
buffer never needed 	tsd data 
operation critical 	tsd data 
performance cases length 	tsd free 
buffer given 	thd start 
function allocate memory 	thd create 
perform strbuf 	thd 
setlen length larger 	data tsd 
len strbuf 	boot test 
avail strbuf setlen 	data nothing 
meant please 	previous time 
fix invariants 	destructor called 
strbuf messed empty 	state 
buffer setting 	tsd state 
size zero functions 	purgatory destructors 
related contents 	wouldn cause 
buffer strip whitespace 	creation tsd 
beginning ltrim 	time nothing 
end rtrim side 	request 
trim replace 	another callback 
contents strbuf reencoded 	another destructor 
form returns 	deallocated memory 
error success lowercase 	destructor called 
character buffer 	reset state 
tolower compare two 	tsd 
buffers returns 	state purgatory 
integer less equal 	request another 
greater zero 	callback check 
first buffer found 	whether already 
respectively less 	inserted list 
match greater 	insert 
second buffer adding 	block list 
data buffer 	allocate cleanup 
note functions section 	two rounds 
grow buffer 	order assure 
necessary fail reason 	jemalloc tsd 
memory shortage 	reinitialization 
buffer hadn allocated 	happens tsd.c 
strbuf strbuf 	ncleanups cleanups 
init free single 	size wrapper 
character buffer 	arg pending 
character specified number 	arg tsd 
times buffer 	state 
insert data given 	hinst dll 
position buffer 	fdw reason 
remaining contents shifted 	lpv reserved 
overwritten given 	head block 
amount data 	self iter 
given position buffer 	head 
bytes pos 	block malloc 
pos len replace 	cacheline ceiling 
given data 	dalloc reached 
nul terminated buffer 	tsd tsd 
line prepended 	reached tsd 
comment character blank 	boot 
data given 	tsd arenas 
length buffer nul 	cache bypassp 
terminated buffer 	tsd fetch 
note function always 	tsd boot 
implemented macro 	tsd arenas 
strlen meaning efficient 	cache 
write things 	bypassp tsd 
like strbuf addstr 	fetch malloc 
immediate copy 	cleanup pthread 
contents another buffer 	self malloc 
end current 	mutex malloc 
one copy 	mutex 
part buffer given 	unlock elm 
position till 	tail insert 
given length end 	malloc mutex 
buffer function 	unlock malloc 
used expand format 	mutex malloc 
containing placeholders 	mutex 
end parses calls 	unlock data 
specified function 	nothing previous 
every percent sign 	time destructor 
found callback 	called state 
function given pointer 	tsd state 
character pointer 	purgatory 
strbuf expected expanded 	destructors wouldn 
version placeholder 	cause creation 
strbuf newline character 	tsd time 
letter appears 	nothing request 
function returns length 	another 
placeholder recognized 	callback another 
strbuf expand 	destructor deallocated 
skips format automatically 	memory destructor 
expanded single 	called reset 
quoting mechanism callers 	state tsd 
need handle 	state 
placeholder callback function 	purgatory request 
invoked placeholder 	another callback 
characters non percent 	check whether 
skipped ones 	already inserted 
copied verbatim strbuf 	list insert 
callback returned 	block 
zero meaning placeholder 	list allocate 
unknown percent 	cleanup two 
sign copied order 	rounds order 
facilitate caching 	assure jemalloc 
make possible give 	tsd reinitialization 
parameters callback 	happens 
strbuf expand passes 	data cleanup 
context pointer 	executed arg 
used programmer 	data arg 
callback sees fit 	thd data 
used callback 	tsd data 
strbuf expand expects 	tsd 
strbuf expand 	reached mallocx 
dict entry context 	ptr dallocx 
pairs placeholder 	data tsd 
replacement needs terminated 	malloc ptr 
entry placeholder 	data tsd 
append contents one 	data 
strbuf another 	tsd data 
quoting percent signs 	tsd free 
percents destination 	thd start 
useful data fed 	thd create 
either strbuf 	thd data 
expand family functions 	tsd 
append given 	boot test 
size human 	data nothing 
readable formatted buffer 	previous time 
formatted prepended 	destructor called 
comment character blank 	state tsd 
buffer time 	state 
specified formatted strftime 	purgatory destructors 
read given 	wouldn cause 
size data file 	creation tsd 
pointer buffer 	time nothing 
note buffer rewound 	request another 
read fails 	callback 
returned errno must 	another destructor 
consulted like 	deallocated memory 
would read strbuf 	destructor called 
read strbuf 	reset state 
read file strbuf 	tsd state 
getline family 	purgatory 
functions behaviour well 	request another 
read contents 	callback check 
given file 	whether already 
descriptor third argument 	inserted list 
used give 	insert block 
hint file size 	list 
avoid reallocs 	allocate cleanup 
read fails read 	two rounds 
undone read 	order assure 
contents given file 	jemalloc tsd 
descriptor partially 	reinitialization happens 
one attempt xread 	tsd.h 
third argument 	data state 
used give hint 	tsd initializer 
file size 	size wrapper 
avoid reallocs returns 	arg head 
number bytes 	block head 
appended read contents 	block 
file specified 	arg tsd 
path third argument 	tsd fetch 
used give 	tsd maximum 
hint file 	number malloc 
size avoid reallocs 	tsd users 
read target 	cleanup 
symbolic link specified 	functions tls 
path third 	tsd agnostic 
argument used give 	macro implementation 
hint size 	specific data 
avoid reallocs read 	five macros 
line file 	support 
overwriting existing contents 	least three 
strbuf strbuf 	use cases 
getline family functions 	file library 
share signature 	library inlined 
different line termination 	following example 
conventions reading 	library 
stops terminator eof 	tsd variable 
terminator removed 	example example 
buffer returning returns 	define initializer 
unless nothing 	jemalloc concat 
left eof 	malloc tsd 
returns eof uses 	types 
line terminator 	example example 
uses nul line 	malloc tsd 
terminator similar 	protos example 
strbuf getline additionally 	example malloc 
treats comes 	tsd externs 
immediately part terminator 	example 
friendly version 	example example 
used read text 	malloc tsd 
files come 	data example 
platforms whose text 	example initializer 
format crlf 	malloc tsd 
terminated like strbuf 	funcs 
getline keeps 	example example 
trailing terminator buffer 	initializer example 
like strbuf 	tsd cleanup 
getwholeline operates 	result generated 
file descriptor reads 	functions example 
one character 	tsd 
time slow use 	boot example 
unless need 	example tsd 
correct position file 	example tsd 
descriptor buffer 	example val 
path current working 	note functions 
directory path 	deal 
buffer converting relative 	terms type 
path absolute 	rather type 
one process symbolic 	possible support 
links resolved 	non pointer 
strip whitespace buffer 	types unlike 
second parameter 	pthreads 
controls comments considered 	tsd example 
contents removed 	tsd cleanup 
temporary topic branches 	passed type 
switched use 	pointer cast 
strbuf stripspace 	means cleanup 
directly split str 	function 
length slen 	needs cast 
specified terminator character 	function argument 
terminated pointers 	type dereference 
strbuf objects holding 	resulting pointer 
substrings substrings 	access fields 
include terminator last 	example 
substring might 	tsd cleanup 
unterminated original end 	arg example 
terminator max 	example example 
positive split max 	arg example 
substrings last 	want cleanup 
substring containing everything 	function 
following max 	called example 
terminator character form 	tsd example 
strbuf split 	example tsd 
buf takes arbitrary 	called within 
pointer len 	example tsd 
buffer str 	cleanup 
variant takes nul 	called similar 
terminated max 	pthreads tsd 
variant takes strbuf 	destruction works 
strbuf split 	pthreads calls 
convenience wrapper drop 	cleanup function 
max parameter 	non 
lighter weight alternatives 	malloc tsd 
see list 	types malloc 
split list split 	tsd protos 
place free 	malloc tsd 
terminated list strbufs 	externs malloc 
example values 	tsd 
strbuf split functions 	data malloc 
abbreviation generated 	tsd funcs 
find unique abbrev 	initialization cleanup 
sha strbuf 	nothing initialization 
launch user preferred 	cleanup nothing 
editor edit 	initialization 
file fill 	cleanup trigger 
buffer file contents 	another cleanup 
upon user 	round initialization 
completing editing third 	cleanup trigger 
argument used 	another cleanup 
environment editor run 	round 
buffer editor 	jemalloc types 
launched usual file 	name type 
contents read 	jemalloc structs 
buffer upon completion 	jemalloc externs 
append characters 	trigger cleanup 
converted xml entities 	handler 
complete contents 	registration jemalloc 
ensuring either ends 	inlines t 
character term 	hashc argv 
empty used example 	start end 
ensure text 	subject field 
ends newline without 	vstr 
creating empty 	vlen vll 
blank line 	vptr ret 
content first place 	field field 
create newly 	vstr vlen 
allocated format easily 	vll aux 
strbuf provides 	field 
shortcut save lines 	len vstr 
strbuf strcasestr.c 	vlen vll 
haystack needle nlen 	aux field 
hlen strlen 	vstr vlen 
strlen toupper toupper 	vll aux 
streaming.c close 	field 
read filter open 	update fptr 
istream tbl 	vptr field 
upstream filter ibuf 	deleted fptr 
obuf end 	length subject 
ptr end ptr 	fptr vptr 
input finished 	vstr 
vtbl size 	vlen vll 
buf read ptr 	ret dst 
mapped mapsize 	dst vstr 
hdr hdr avail 	vlen vll 
hdr used 	key enc 
pack pos filtered 	dict 
buf open 	ret field 
istream feed receive 	enc update 
receive filtered 	incr oldvalue 
vtbl filter ifs 	current incr 
copy status 	current aux 
loose vtbl total 	field 
read status 	ret vstr 
window mapped pack 	vlen vll 
non delta 	keyremoved vstr 
vtbl incore vtbl 	vlen vll 
sha filter 	flags multiplier 
seek kept result 	length 
buf wrote 	count cursor 
holeto readlen 	sds encoded 
open method decl 	sdslen hash 
open method 	type convert 
decl open method 	encoding encoding 
decl close 	server 
free read git 	decoded ziplist 
inflate end 	index ziplist 
stream filter stream 	find sdslen 
filter read 	ziplist next 
istream xmalloc memcpy 	server decr 
git inflate 	count 
git inflate end 	ziplist server 
git inflate 	server dict 
end close deflated 	find dict 
stream munmap 	val hash 
unpack sha header 	type ziplist 
git inflate 	create 
end munmap parse 	create hash 
sha header 	type hash 
strlen memset 	table incr 
git inflate init 	count server 
use pack 	panic hash 
git inflate unuse 	type 
pack git 	ziplist sdigits 
inflate end git 	hash type 
inflate end 	hash table 
free memcpy open 	len server 
istream free 	panic hash 
stream filter read 	type 
istream lseek 	ziplist hash 
write full lseek 	type hash 
xwrite close 	table server 
istream copyright google 	panic decoded 
inc forward 	decoded ziplist 
declaration inflated size 	index 
full read 	ziplist find 
fallthru stream filter 	sdslen ziplist 
filter performance 	next server 
common helpers 	ziplist ziplist 
filtered stream already 	insert sdslen 
filtered output 	ziplist 
anything feed filter 	push sdslen 
tell filter 	ziplist push 
drain upon input 	sdslen decr 
refill input 	count decr 
upstream unknown loose 	count hash 
stream non 	type 
delta packed stream 	length hash 
deltas core 	type convert 
stream users streaming 	dict replace 
streaming.h open 	incr count 
istream git istream 	incr count 
git istream 	server 
stream filter seek 	panic decoded 
copyright google 	ziplist index 
inc opaque 	ziplist find 
streaming string-list.c list 	sdslen ziplist 
strdup list 	ziplist decr 
exact match right 	count 
cmp middle 	dict needs 
compare insert list 	resize dict 
exact match 	resize server 
index list index 	panic ziplist 
list exact 	len dict 
match list negative 	size 
existing index 	server panic 
exact match index 	zmalloc dict 
list exact 	iterator server 
match list free 	panic dict 
src dst 	release iterator 
cmp list data 	zfree 
ret list 	server ziplist 
free want data 	index server 
src dst 	ziplist next 
item unused 	ziplist next 
list free list 	server dict 
free list 	next 
clearfunc text list 	server panic 
retval list 	server ziplist 
compare qsort one 	server ziplist 
two list 	server server 
list cmp list 	dict key 
list free 	dict 
list delim maxsplit 	val hash 
count end 	type current 
list delim maxsplit 	ziplist create 
count end 	create hash 
memset cmp entry 	type current 
index realloc 	hash 
memmove xstrdup entry 	table incr 
entry index 	count server 
entry index entry 	panic lookup 
index cmp 	key write 
free free 	create hash 
want free free 	reply 
filter list 	server hash 
free free free 	type init 
clearfunc free 	iterator dict 
free alloc grow 	create hash 
list append 	type next 
nodup xstrdup compare 	hash 
qsort qsort 	type current 
cmp unsorted list 	encoding hash 
lookup free 	type current 
free die list 	encoding dict 
append strchr 	server log 
list append nodup 	hex 
xmemdupz list 	dump ziplist 
append die list 	blob len 
append strchr 	server hash 
list append list 	type release 
append exact 	iterator zfree 
match point 	server 
index entry could 	panic hash 
inserted returns 	type convert 
index already exists 	ziplist server 
yuck call 	panic server 
inside list sort 	panic hash 
string-list.h items 	type 
alloc cmp list 	lookup write 
strdup text 	create hash 
list free list 	type conversion 
clearfunc list 	hash type 
data list free 	encoding hash 
want data 	type 
list free list 	reply signal 
list negative 	modified key 
existing index list 	notify keyspace 
list sorted 	hash type 
list free 	lookup write 
list list list 	create 
list list 	hash type 
list free list 	conversion hash 
delim maxsplit 	type exists 
list delim maxsplit 	reply hash 
uses strcmp 	type encoding 
use function call 	hash 
custom clear 	type reply 
function pointer associated 	signal modified 
pointer passed 	key notify 
second argument use 	keyspace reply 
function macro 	error hash 
iterate item apply 	type 
want item 	lookup write 
list retaining ones 	create hash 
function returns 	type conversion 
free call free 	hash type 
members items 	encoding hash 
deleted preserve 	type 
order items retained 	reply signal 
empty list 	modified key 
free call free 	notify keyspace 
members items 	reply hash 
deleted preserve order 	type lookup 
items retained 	write 
use functions sorted 	create hash 
lists inserts 	type reply 
given sorted list 	decr count 
already exists 	decr count 
list altered returns 	reply error 
list item 	create 
part checks given 	hash type 
part sorted 	encoding hash 
list part list 	type decr 
coresponding list 	count reply 
item otherwise first 	signal modified 
consecutive entries 	key 
free call 	notify keyspace 
free members items 	reply hash 
deleted use 	type lookup 
functions unsorted lists 	write create 
end list 	hash type 
list strdup copied 	reply 
otherwise list 	decr count 
entry refers input 	decr count 
like list 	create hash 
append never copied 	type encoding 
list strdup 	hash type 
function used hand 	reply 
ownership malloc 	bulk signal 
list without making 	modified key 
extra copy 	notify keyspace 
split substrings character 	create rewrite 
delim append 	client command 
substrings list input 	argument 
modified list 	decr count 
strdup must 	rewrite client 
memory needs allocated 	command argument 
hold substrings 	decr count 
maxsplit non negative 	reply hash 
split maxsplit 	type 
times number substrings 	ziplist reply 
appended list 	reply bulk 
examples list split 	buffer reply 
foo bar 	bulk hash 
baz foo bar 	type hash 
baz list 	table 
split foo bar 	reply reply 
baz foo 	bulk server 
bar baz list 	panic lookup 
split foo 	key read 
bar baz foo 	reply check 
bar baz 	type 
list split foo 	hash field 
bar foo 	reply lookup 
bar list 	key read 
split list split 	reply reply 
like list 	multi bulk 
split split place 	len 
delimiter characters 	hash field 
overwritten list items 	reply lookup 
point therefore 	key write 
must modified freed 	reply check 
list use 	type 
list strdup must 	hash type 
list stripspace.c 	hash type 
buf msg len 	length signal 
stripspace usage 	modified key 
argc argv prefix 	notify keyspace 
buf options 	notify 
strbuf detach strbuf 	keyspace reply 
commented lines 	lookup key 
free parse 	read reply 
options usage options 	check type 
git config 	reply hash 
strbuf read die 	type 
errno strbuf 	length lookup 
stripspace comment lines 	key read 
write die 	reply check 
strbuf release strlcpy.c 	type reply 
dest src 	hash type 
size ret len 	length 
strlen memcpy 	hash type 
strtoimax.c nptr endptr 	current ziplist 
strtol strtoll 	reply bulk 
strtoumax.c nptr endptr 	buffer reply 
strtoul strtoull 	bulk hash 
submodule--helper.c entries alloc 	type 
argc argv 	current hash 
prefix pathspec list 	table reply 
result matched 	bulk server 
argc argv 	panic lookup 
prefix pathspec list 	key read 
module list 	reply 
options git submodule 	check type 
helper usage 	hash type 
argc argv prefix 	length reply 
sub path 	multi bulk 
gitdir url depth 	len hash 
reference quiet 	type 
argc argv prefix 	init iterator 
url depth 	hash type 
quiet submodule dot 	next hash 
git gitdir 	iterator cursor 
cwd rel path 	reply hash 
module clone 	iterator 
options git submodule 	cursor reply 
helper usage 	hash type 
cmd commands argc 	release iterator 
argv prefix 	server hgetall 
parse pathspec 	command hgetall 
xcalloc read cache 	command 
die isgitlink 	hgetall command 
match pathspec namelen 	lookup key 
alloc grow 	read reply 
strcmp report path 	check type 
error free 	reply hash 
parse options module 	type 
list compute 	exists parse 
stage sha hex 	scan cursor 
sha hex 	reply lookup 
stage utf usage 	key read 
gitmodules config 	reply check 
submodule path die 	type 
child process 	scan command 
init argv push 	copyright salvatore 
argv push 	sanfilippo antirez 
argv push argv 	gmail dot 
pushl argv 	rights reserved 
pushl argv 	redistribution 
pushl argv push 	use source 
argv push 	binary forms 
run command parse 	without modification 
options strbuf 	permitted provided 
addf git dir 	following conditions 
strbuf detach 	met 
file exists safe 	redistributions source 
create leading 	code must 
directories die clone 	retain copyright 
submodule die 	notice list 
safe create leading 	conditions following 
directories die 	disclaimer 
strbuf addf unlink 	redistributions binary 
warn strbuf 	form must 
reset safe create 	reproduce copyright 
leading directories 	notice list 
die strbuf 	conditions following 
addf strbuf addstr 	disclaimer 
safe create 	documentation materials 
leading directories die 	provided distribution 
fopen die 	neither name 
errno relative path 	redis names 
fclose die 	contributors may 
strbuf reset strbuf 	used 
reset xgetcwd 	endorse promote 
absolute path strbuf 	products derived 
addf free 	software without 
strbuf detach strbuf 	specific prior 
addf git 	written permission 
pathdup submodule die 	software 
git config 	provided copyright 
file relative path 	holders contributors 
strbuf release 	express implied 
strbuf release free 	warranties including 
free free 	limited implied 
die size 	warranties 
strcmp die skip 	merchantability fitness 
entries name 	particular purpose 
different stages make 	disclaimed shall 
sure entry 	copyright owner 
returned write git 	contributors liable 
file submodule 	direct 
redirect superproject redirect 	indirect incidental 
worktree submodule 	special exemplary 
superproject config submodule-config.c 	consequential damages 
path name 	including limited 
ent config cache 	procurement substitute 
cache init 	goods 
unused unused cache 	services loss 
entry cache 	use data 
iter entry sha 	profits business 
cache submodule 	interruption however 
hash cache submodule 	caused theory 
hash removed 	liability 
cache submodule 	whether contract 
hash cache gitmodules 	strict liability 
sha path 	tort including 
entry hash key 	negligence otherwise 
key config 	arising way 
cache gitmodules sha 	use 
name entry 	software even 
hash key key 	advised possibility 
config name 	damage hash 
item subsection key 	type api 
subsection len 	check length 
parse cache gitmodules 	number 
sha name 	objects see 
submodule name buf 	need convert 
opt arg 	ziplist real 
die error opt 	hash note 
arg opt 	check encoded 
arg die error 	objects 
opt arg 	length queried 
commit sha 	constant time 
name option commit 	encode given 
cache commit 	objects place 
sha gitmodules sha 	hash uses 
overwrite data 	dict 
submodule item ret 	ziplist encoded 
die error 	hash identified 
commit sha gitmodules 	field returns 
sha rev 	field cannot 
ret config cache 	found grab 
commit sha 	pointer 
path cache commit 	fptr points 
sha name 	field hash 
parameter commit sha 	table encoded 
name commit 	hash identified 
sha path strcmp 	field returns 
hashcmp strcmp 	field 
hashcmp hashmap 	cannot found 
init hashmap init 	higher level 
free free 	function hash 
free hashmap iter 	type always 
init hashmap 	returns redis 
iter next free 	either 
one config 	refcount incremented 
hashmap free hashmap 	caller retain 
free memhash 	reference call 
strhash hash sha 	decr count 
xmalloc hashmap 	usage lower 
entry init hashmap 	level 
put hash 	function prevent 
sha hashmap entry 	copy write 
init hashmap 	preferred way 
free hash sha 	read operations 
xmalloc hashmap 	higher level 
entry init hashmap 	function 
hash sha 	hash type 
hashcpy hashmap 	length associated 
entry init hashmap 	requested field 
hash sha 	field exist 
hashcpy hashmap entry 	test specified 
init hashmap 	field 
parse config key 	exists given 
strbuf strbuf 	hash returns 
addstr cache lookup 	field exists 
name xmalloc 	doesn element 
strbuf addstr strbuf 	discard old 
detach hashcpy 	key 
cache git config 	already exists 
maybe strcmp 	insert update 
die parse fetch 	function take 
recurse git 	care incrementing 
config maybe die 	reference count 
strcmp strcmp 	retained 
die parse push 	fields objects 
recurse sha 	grab pointer 
hex warning 	fptr points 
name item lookup 	field insert 
create name 	push field 
strcmp config error 	pair 
nonbool warn 	onto tail 
multiple config cache 	ziplist check 
path free 	ziplist needs 
xstrdup cache put 	converted hash 
path strcmp 	table insert 
sha warn multiple 	update 
config parse 	element hash 
fetch recurse strcmp 	deleted found 
config error 	always check 
nonbool warn multiple 	dictionary needs 
config strcmp 	resize number 
strcmp strcmp strcmp 	elements 
warning free 	hash move 
xstrdup strcmp config 	next entry 
error nonbool 	hash next 
warn multiple 	entry could 
config free xstrdup 	found err 
strbuf release 	iterator 
strbuf release sha 	reaches end 
hashcpy strbuf 	initialize cursor 
addf sha hex 	advance cursor 
sha strbuf 	grab pointer 
release config config 	fptr points 
cache init 	field 
ensure cache init 	fptr vptr 
parse config 	point first 
ensure cache init 	next pair 
config name 	field iterator 
ensure cache init 	cursor iterator 
config path 	hash 
cache free submodule 	encoded ziplist 
cache lookup 	prototype similar 
structure one shared 	hash type 
submodule entries 	ziplist field 
looked sha 	iterator cursor 
blob gitmodule file 	iterator 
either path 	hash encoded 
name key path 	ziplist prototype 
stores submodule 	similar hash 
entries path key 	type hash 
name stores 	table non 
submodule entries name 	copy 
key thin 	write friendly 
wrapper needed insert 	higher level 
submodule entries 	version hash 
hashmap iterate name 	type current 
hash symmetric 	returns incremented 
allocation submodule entries 	refcount 
allocated gitmodule 	caller decr 
blob sha submodule 	count reference 
name simple 	retained nothing 
pushing also 	hash type 
ensures parse submodule 	commands always 
entries parsing 	replicate 
worktree configurations die 	hincrbyfloat hset 
early lookup 	command order 
submodule configuration name 	make sure 
path key 	differences pricision 
demand reading appropriate 	formatting create 
gitmodules revisions 	differences 
parameter cache pointer 	replicas aof 
first submodule 	restart abort 
used check whether 	key cannot 
submodules parsed 	found non 
fill submodule config 	existing keys 
cache submodule-config.h 	empty 
path name url 	hashes hmget 
fetch recurse 	respond series 
ignore gitmodules sha 	bulks t 
opt arg 	listc subject 
opt arg 	pos len 
commit sha name 	data 
commit sha 	subject vlong 
path submodule entry 	subject subject 
containing information 	index direction 
certain submodule certain 	iter direction 
revision sha 	entry entry 
blob responsible gitmodules 	entry 
file submodule 	str len 
config submodule.c config 	entry iter 
fetch recurse 	entry subject 
submodules changed submodule 	enc zlen 
paths initialized 	depth pushed 
fetch tips tips 	lobj 
fetch tips 	refval val 
fetch gitmodules unmerged 	subject iter 
gitmodules modified 	entry inserted 
oldpath newpath entry 	index entry 
submodule path 	index replaced 
sect submodule 	start 
path objects directory 	end llen 
alt odb 	rangelen iter 
ret alloc diffopt 	entry start 
path submodule 	end llen 
work gitmodules path 	ltrim rtrim 
pos diffopt 	subject 
arg rev path 	obj toremove 
left right 	removed entry 
fast forward fast 	dstkey dstobj 
backward merge 	sobj dobj 
bases list rev 	touchedkey keys 
line prefix 	numkeys 
del reset format 	timeout target 
commit ctx 	retval key 
path line prefix 	key receiver 
one two 	key dstkey 
dirty submodule meta 	argv dstobj 
del reset 	clients 
rev right 	numclients clientnode 
message fast backward 	receiver dstkey 
refname oid 	timeout timeout 
flags data path 	key decoded 
sha argv 	sdslen quicklist 
buf needs pushing 	push 
options data 	decr count 
needs pushing commit 	server panic 
needs pushing 	create quicklist 
rev sha remotes 	pop custom 
name needs 	create server 
pushing rev commit 	panic 
argv argc 	quicklist count 
sha copy remotes 	server panic 
arg path 	zmalloc quicklist 
argv sha remotes 	iterator idx 
name ret 	server panic 
needs pushing 	zfree 
path path sha 	zfree server 
present argv 	quicklist next 
buf options data 	server panic 
path oid 	create create 
flags data sha 	server panic 
sha data 	decoded 
rev commit argv 	sdslen quicklist 
parent diff 	insert quicklist 
opts count args 	insert decr 
work prefix 	count server 
command line option 	panic server 
quiet result 	info 
err data task 	sds encoded 
ret spf 	quicklist compare 
submodule path submodule 	sdslen server 
git dir 	panic quicklist 
submodule prefix git 	del entry 
dir argv 	server 
submodule err 	panic server 
task spf retvalue 	info server 
err task 	info quicklist 
spf options prefix 	create ziplist 
command line 	server panic 
option quiet max 	lookup 
parallel jobs 	key write 
spf path ignore 	reply encoding 
untracked len 	create quicklist 
argv buf dirty 	quicklist options 
submodule line 	list type 
next line git 	push 
dir path 	reply list 
argv buf git 	type length 
dir path 	signal modified 
len argv buf 	key notify 
result path 	keyspace push 
merges commit contains 	command 
another merged 	push command 
revision rev 	lookup key 
args revs rev 	write reply 
opts commit 	check type 
ctx result path 	list type 
search commit 	init 
commit commit parent 	iterator list 
count merges 	type next 
work git dir 	list type 
file name 	equal list 
rel path real 	type insert 
work file 	list 
exists die submodule 	type release 
path warning 	iterator signal 
strbuf addstr strbuf 	modified key 
addstr strbuf 	notify keyspace 
addstr git config 	reply list 
file gently 	type 
warning strbuf release 	push signal 
strbuf release 	modified key 
file exists 	notify keyspace 
die submodule path 	reply list 
warning strbuf 	type length 
addstr strbuf addstr 	encoding 
git config 	pushx command 
rename section file 	encoding pushx 
warning strbuf 	command encoding 
release strbuf release 	strcasecmp pushx 
file cache 	command strcasecmp 
die strbuf git 	pushx 
path submodule 	command reply 
directory prepare alt 	lookup key 
odb strncmp 	read reply 
xmalloc xsnprintf read 	check type 
info alternates 	reply list 
strbuf release submodule 	type 
path handle 	length lookup 
ignore submodules 	key read 
arg diff opt 	reply check 
starts parse 	type reply 
submodule config option 	quicklist index 
strcmp parse 	create 
fetch recurse submodules 	create reply 
arg git 	bulk decr 
work strbuf addstr 	count reply 
strbuf addstr 	server panic 
read cache die 	lookup key 
cache name 	write 
pos namelen memcmp 	reply check 
lstat match 	type reply 
stat git config 	quicklist replace 
file strbuf 	index sdslen 
release diff opt 	reply reply 
clr diff 	signal 
opt clr diff 	modified key 
opt clr 	notify keyspace 
strcmp diff 	server panic 
opt strcmp diff 	lookup key 
opt strcmp 	write reply 
diff opt strcmp 	check 
die init 	type list 
revisions setup revisions 	type pop 
pending pending 	reply reply 
merge bases pending 	bulk decr 
oid hex 	count notify 
prepare revision walk 	keyspace 
revision log 	list type 
output encoding strbuf 	length notify 
setlen strbuf 	keyspace signal 
addstr strbuf addstr 	modified key 
strbuf addstr 	pop 
format commit message 	command pop 
strbuf addstr 	command reply 
strbuf addch strbuf 	reply lookup 
release sha 	key read 
submodule odb 	reply check 
sha lookup commit 	type 
reference lookup 	list type 
commit reference prepare 	length reply 
submodule summary 	reply multi 
hashcmp strbuf release 	bulk len 
strbuf addf 	list type 
find unique abbrev 	init 
strbuf addch 	iterator list 
strbuf addf find 	type next 
unique abbrev 	reply bulk 
strbuf addf strbuf 	buffer reply 
addf fwrite 	bulk list 
print submodule summary 	type 
clear commit 	release iterator 
marks clear commit 	server panic 
marks strbuf 	reply reply 
release submodule odb 	lookup key 
lookup commit 	write reply 
reference remote 	check 
submodule sha hex 	type list 
start command 	type length 
die sha hex 	quicklist del 
strbuf read 	range quicklist 
finish command close 	del range 
strbuf release 	server 
isgitlink submodule needs 	panic notify 
pushing list 	keyspace list 
insert init revisions 	type length 
diff combined 	notify keyspace 
merge size strbuf 	signal modified 
addf init 	key 
revisions xstrdup sha 	reply reply 
hex setup 	lookup key 
revisions prepare revision 	write reply 
walk die 	check type 
revision find unpushed 	list type 
submodule commits 	init 
reset revision 	iterator list 
walk free strbuf 	type init 
release submodule 	iterator list 
odb remote submodule 	type next 
run command 	list type 
close find unpushed 	equal 
submodules push 	list type 
submodule list clear 	list type 
submodule odb 	release iterator 
lookup commit reference 	signal modified 
sha hex 	key notify 
capture command strbuf 	keyspace 
release isgitlink 	list type 
isgitlink unsorted list 	length notify 
lookup submodule 	keyspace reply 
commit present list 	create quicklist 
append xstrdup 	quicklist options 
sha append 	signal 
sha append argv 	modified key 
push sha 	list type 
hex submodule path 	push notify 
init revisions 	keyspace reply 
argv push sha 	bulk lookup 
unique argv 	key 
push sha unique 	write reply 
setup revisions 	check type 
prepare revision walk 	list type 
die revision 	length reply 
diff setup diff 	lookup key 
opt diff 	write 
setup done diff 	check type 
sha diffcore 	list type 
std diff flush 	pop incr 
argv clear 	count rpoplpush 
sha clear sha 	handle push 
clear isgitlink 	decr 
submodule path 	count notify 
submodule name unsorted 	keyspace list 
list lookup 	type length 
unsorted list lookup 	notify keyspace 
unsorted list 	signal modified 
lookup strbuf addf 	key 
strbuf addf 	decr count 
strbuf addf read 	incr count 
gitfile directory 	dict incr 
child process init 	count dict 
strbuf detach 	find list 
strbuf addf argv 	create 
init argv 	dict incr 
pushv argv push 	count server 
argv push 	info dict 
argv push strbuf 	val list 
release strbuf 	node tail 
release strbuf release 	block 
git work 	client server 
read cache 	info dict 
die argv push 	size dict 
argv push 	iterator dict 
argv push calculate 	next dict 
changed submodule 	key 
paths run processes 	dict fetch 
parallel argv 	server info 
clear list clear 	list del 
strbuf addf 	node list 
read gitfile directory 	search key 
strbuf release 	list 
strbuf reset start 	length dict 
command die 	dict release 
strbuf read strchr 	iterator dict 
close finish 	empty decr 
command die strbuf 	count dict 
release strbuf 	find 
addf read gitfile 	dict find 
strbuf release 	zmalloc incr 
strbuf release 	count list 
run command file 	node tail 
exists empty 	incr count 
dir submodule uses 	server 
gitfile start 	dict propagate 
command die strbuf 	reply multi 
read close 	bulk len 
finish command die 	reply bulk 
strbuf release 	reply bulk 
memset memset snprintf 	lookup 
oid hex 	key write 
init revisions setup 	check type 
revisions size 	propagate rpoplpush 
prepare revision walk 	handle push 
die revision 	propagate list 
merge bases reset 	length 
revision walk 	list create 
merge bases 	list length 
free format commit 	list first 
message strbuf 	dict lookup 
release hashcpy sha 	key write 
sha sha 	dict 
submodule odb merge 	find dict 
warning lookup 	val list 
commit reference lookup 	length list 
commit reference 	first list 
lookup commit reference 	type pop 
merge warning 	incr 
merge bases merge 	count unblock 
bases merge 	client serve 
warning merge bases 	client blocked 
hashcpy merge 	list list 
bases hashcpy find 	type push 
first merges 	decr 
merge warning merge 	count decr 
warning print 	count list 
commit oid 	type length 
hex merge warning 	decr count 
print commit 	zfree list 
free xstrdup real 	del 
path strbuf 	node list 
addf write file 	release timeout 
relative path 	reply lookup 
strbuf reset strbuf 	key write 
addf git 	reply list 
config file relative 	type 
path strbuf 	length list 
release strbuf release 	type pop 
free following 	server reply 
flag gitmodules file 	multi bulk 
unmerged disable 	len reply 
recursion submodules git 	bulk 
config doesn 	reply bulk 
matching config entry 	decr count 
guess might 	notify keyspace 
configured gitmodules 	list type 
unless user resolves 	length notify 
conflict command 	keyspace 
line option given 	signal modified 
always overrides 	key rewrite 
configuration flag ignored 	client command 
flag gitmodules 	vector reply 
file unstaged modifications 	block keys 
startup must 	blocking 
allowing modifications gitmodules 	pop command 
file intention 	blocking pop 
stage later continuing 	command timeout 
would stage 	reply lookup 
modifications user didn 	key write 
stage might 	reply 
change future version 	block keys 
learn stage 	reply server 
changes without staging 	info list 
previous modifications 	type length 
update path 	rpoplpush command 
entry submodule name 	copyright 
section gitmodules 	salvatore sanfilippo 
file gitmodules file 	antirez gmail 
found section 	dot rights 
correct path oldpath 	reserved redistribution 
setting found 	use source 
could update nothing 	binary 
without gitmodules 	forms without 
maybe user already 	modification permitted 
error submodule 	provided following 
name section gitmodules 	conditions met 
given path 	redistributions source 
configured gitmodules file 	code 
found section 	must retain 
correct path path 	copyright notice 
setting found 	list conditions 
could nothing without 	following disclaimer 
gitmodules maybe 	redistributions binary 
user already 	form 
error avoid adding 	must reproduce 
twice sha 	copyright notice 
possible alternates submodule 	list conditions 
gitmodules found 	following disclaimer 
isn merged gitmodules 	documentation materials 
succeeded setting 	provided 
walk even submodule 	distribution neither 
commit present 	name redis 
make sure reachable 	names contributors 
needswork honor 	may used 
name configured gitmodules 	endorse promote 
file commit 	products 
examining able correctly 	derived software 
follow submodules 	without specific 
moved around submodule 	prior written 
moved needswork 	permission software 
git directories 	provided copyright 
submodules live inside 	holders 
superprojects git 	contributors express 
directory day fetch 	implied warranties 
submodules directly 	including limited 
location config options 	implied warranties 
request need 	merchantability fitness 
check submodules configured 	particular 
argv program 	purpose disclaimed 
name collect submodules 	shall copyright 
whether commits 	owner contributors 
recorded upstream changed 	liable direct 
submodule paths 	indirect incidental 
submodule prefix added 	special 
later submodule 	exemplary consequential 
modified test nested 	damages including 
submodules use 	limited procurement 
gitfile revisions merge 	substitute goods 
commit save 	services loss 
revisions list 	use 
contain got merges 	data profits 
contain prune 	business interruption 
merges contain another 	however caused 
found merge 	theory liability 
save result store 	whether contract 
result fail 	strict 
handle deletion conflicts 	liability tort 
check whether 	including negligence 
changes forward contained 	otherwise arising 
vice versa 	way use 
one merges contain 	software even 
submodule one 	advised 
present suggestion user 	possibility damage 
marked unmerged 	list api 
user needs confirm 	function pushes 
resolution skip 	element specified 
search makes sense 	list subject 
calling context 	head 
find commit 	tail position 
merges update gitfile 	specified need 
core worktree 	caller increment 
setting connect work 	refcount function 
git dir 	takes care 
update gitfile update 	needed 
core worktree 	initialize iterator 
setting submodule.h oldpath 	specified index 
newpath path 	list head 
diffopt path diffopt 	means start 
path line 	tail move 
prefix one two 	towards 
dirty submodule 	head list 
meta del reset 	tail means 
sha options 	start head 
prefix command line 	move towards 
option quiet 	tail clean 
max parallel jobs 	iterator 
path ignore 	stores pointer 
untracked path 	current entry 
path result path 	provided entry 
search sha 	structure advances 
remotes name needs 	position iterator 
pushing sha 	returns 
remotes name work 	current entry 
git dir 	fact entry 
svn-fe.c argc argv 	otherwise protect 
svndump init 	converting iterating 
svndump read svndump 	entry current 
deinit svndump 	position 
reset file domain 	iterator compare 
may freely 	given entry 
use modify distribute 	current position 
relicense svndiff.c 	element pointed 
instructions data ctx 	create quicklist 
input delta 	single 
delta len 	ziplist list 
buf len len 	commands seek 
magic result 	refval head 
len buf result 	tail notify 
end pos 	client failed 
result len val 	insert 
result len 	convert negative 
val ctx instructions 	indexes invariant 
nbytes insns 	start test 
end offset ctx 	end range 
instructions nbytes 	empty start 
instructions end offset 	end 
ctx data 	start length 
pos nbytes pos 	result form 
buf end 	multi bulk 
result ctx instructions 	reply convert 
data pos 	negative indexes 
instruction insns end 	invariant 
nbytes ctx 	start test 
instructions data 	end range 
pos delta delta 	empty start 
len preimage 	end start 
ctx len instructions 	length range 
len data 	start 
len delta delta 	start end 
len preimage 	result empty 
postimage pre pre 	list list 
len strbuf 	elements perform 
release strbuf release 	trim semantic 
strbuf release 	command 
fwrite error strerror 	rpoplpush srclist 
buffer ferror 	dstlist llen 
error strerror error 	srclist element 
strbuf reset 	rpop srclist 
buffer read binary 	lpush dstlist 
error read 	element 
read chunk strbuf 	element nil 
release memcmp 	end end 
strbuf release 	idea able 
error strbuf release 	element list 
buffer read 	reliable way 
error read error 	since 
read maximum 	element returned 
type error read 	pushed another 
error parse 	list well 
overflows error strbuf 	command originally 
parse error 	proposed ezra 
strbuf addch overflows 	zygmuntowicz 
error strbuf 	create list 
parse parse first 	key exist 
operand copyfrom 	always send 
source copyfrom target 	pushed client 
copyfrom data 	may happen 
error execute one 	loading 
instruction error 	old rdb 
window init read 	files recent 
length read 	versions redis 
length read 	keys empty 
length read chunk 	lists saved 
read chunk 	touched 
strbuf grow apply 	key protect 
window core 	since rpoplpush 
error write strbuf 	handle push 
window release 	may change 
read magic read 	client command 
offset read 	argument 
length move window 	vector currently 
apply one 	list type 
window licensed two 	pop returns 
clause bsd 	refcount incremented 
style license see 	source list 
license details 	empty 
svndiff applier see 	blocking pop 
http svn 	operations current 
apache repos 	blocking pop 
asf subversion trunk 	works use 
notes svndiff 	blpop example 
svndiff svn window 	user 
window instructions 	calls blpop 
data instructions instruction 	key exists 
instruction view 	contains non 
selector copyfrom data 	empty list 
packed view 	lpop called 
selector packed copyfrom 	instead 
data view 	blpop semantically 
selector copyfrom source 	lpop blocking 
copyfrom target 	required instead 
copyfrom source binary 	blpop called 
copyfrom target 	key exists 
binary copyfrom data 	list 
binary packed 	empty need 
view selector view 	block order 
selector bit 	notification data 
packed copyfrom 	read client 
data copyfrom data 	socket serve 
bit highdigit 	requests 
lowdigit highdigit binary 	blocking request 
bit lowdigit 	served also 
bit success immediate 	put client 
operand fill 	dictionary blocking 
ctx buf data 	keys mapping 
source target 	keys 
data views source 	list clients 
view offset 	blocking keys 
length already handled 	push operation 
window svndiff.h 	key blocked 
delta delta len 	clients waiting 
preimage postimage 	performed 
svndump.c input action 	mark key 
src rev 	ready current 
type prop length 	command multi 
text length 	exec block 
src dst 	script executed 
text delta prop 	serve 
delta revision 	clients waiting 
timestamp log author 	list one 
note version 	blocked first 
uuid url fname 	last accordingly 
revision url 	number elements 
key buf val 	ready 
type key 	list client 
keylen key val 	blocking mode 
type len 	specified key 
type type props 	specified timeout 
text empty 	key already 
blob old data 	exists 
old mode 	dict ignore 
mode remote note 	side map 
mark url 	keys clients 
local notes val 	every key 
active ctx 	take list 
len end 	clients 
len report filename 	blocked unblock 
back strbuf 	client waiting 
reset strbuf reset 	blocking operation 
strbuf addstr 	blpop never 
strbuf reset strbuf 	call 
reset strbuf 	function directly 
reset strbuf reset 	unblock client 
strbuf addstr 	instead client 
strbuf reset constcmp 	may wait 
die strbuf 	multiple keys 
swap constcmp strbuf 	unblock 
reset strbuf 	every key 
swap constcmp die 	client list 
parse date 	clients waiting 
basic warning strlen 	key list 
constcmp strlen 	empty need 
constcmp die strlen 	avoid 
buffer ferror 	wasting memory 
die errno 	cleanup client 
die buffer read 	structure specified 
line strcmp 	key clients 
die atoi strbuf 	blocked waiting 
reset buffer 	list 
read binary die 	pushes function 
read buffer 	put key 
read die read 	reference server 
die strbuf 	ready keys 
swap handle handle 	list note 
strbuf reset 	ready 
die die repo 	keys hash 
repo repo 	table allows 
copy die die 	avoid putting 
repo read 	key list 
path die die 	multiple pushes 
die die 	made 
read props 	script context 
fast export modify 	multi exec 
fast export 	list processed 
modify fast export 	handle clients 
data fast 	blocked lists 
export modify fast 	clients 
export blob 	blocking key 
delta fast export 	need queue 
begin commit 	key already 
fast export end 	signaled need 
commit fast 	queue need 
export begin note 	queue 
strbuf addf 	key server 
fast export note 	ready keys 
fast export 	also key 
buf data reset 	ready keys 
dump ctx 	dictionary order 
buffer read line 	avoid 
strchr constcmp 	adding multiple 
atoi die 	times list 
constcmp strbuf reset 	simple check 
strbuf addstr 	helper function 
constcmp handle node 	handle clients 
begin revision 	blocked 
end revision reset 	lists work 
rev ctx 	serve specific 
atoi strbuf addf 	client receiver 
constcmp constcmp 	blocked key 
strlen handle node 	context specified 
begin revision 	following 
reset node ctx 	provide client 
strbuf addf 	element dstkey 
constcmp strlen strbuf 	serving brpoplpush 
addf strcmp 	also push 
strcmp constcmp strbuf 	element destination 
addf strcmp 	list 
strcmp strcmp strcmp 	lpush side 
constcmp strbuf 	command propagate 
reset strbuf 	resulting brpop 
addstr strbuf addf 	blpop additional 
constcmp atoi 	lpush aof 
strbuf addf constcmp 	replication 
constcmp constcmp 	channel argument 
strtoumax isdigit die 	list tail 
maximum type 	list head 
die constcmp strcmp 	indicates element 
constcmp strcmp 	popped fron 
constcmp atoi buffer 	head 
read line 	blpop tail 
die read die 	brpop propagate 
read props 	command properly 
handle node buffer 	function returns 
skip bytes 	able serve 
die read buffer 	client 
ferror die 	otherwise err 
read handle node 	returned signal 
begin revision 	caller list 
end revision 	pop operation 
fast export init 	undone client 
strbuf init 	served 
strbuf init strbuf 	happens brpoplpush 
init strbuf 	fails push 
init strbuf init 	destination key 
strbuf init 	wrong type 
strbuf init reset 	propagate pop 
dump ctx 	operation 
reset rev ctx 	brpop blpop 
reset node 	brpoplpush propagate 
ctx buffer init 	rpop operation 
error strerror 	propagate lpush 
init buffer fdinit 	operation brpoplpush 
xdup error 	failed 
strerror init xdup 	wrong destination 
fast export 	type function 
deinit reset 	called redis 
dump ctx reset 	every time 
rev ctx 	single command 
reset node ctx 	multi 
strbuf release 	exec block 
strbuf release strbuf 	lua script 
release strbuf 	terminated execution 
release strbuf release 	called client 
buffer deinit 	keys least 
ferror strbuf release 	one 
strbuf release 	client blocked 
strbuf release strbuf 	received least 
release parse 	one element 
rearrange svnadmin dump 	via push 
create dump 	operation accumulated 
svnadmin dump incremental 	server 
startrev endrev 	ready keys 
repository outfile licensed 	list function 
two clause 	run list 
bsd style 	serve clients 
license see license 	accordingly note 
details compare 	function 
start equal length 	iterate result 
must guarded 	serving brpoplpush 
length test states 	blocking clients 
dump metadata 	serve push 
revision metadata node 	side brpoplpush 
metadata nodes 	point 
needswork support simple 	server ready 
mode changes 	keys fresh 
like svn special 	list save 
svn executable 	current one 
keep track whether 	locally way 
mode reset 	run 
plain file keeping 	old list 
track symlink 	free call 
executable bits separately 	signal list 
instead discard 	ready may 
trailing newline 	push elements 
old text node 	server 
directory bug 	ready keys 
empty blob empty 	handling clients 
dataref data 	blocked brpoplpush 
retrievable fast find 	first key 
old content 	ready keys 
old data decide 	safely 
mode adjust 	call signal 
mode reflect properties 	list ready 
save result 	key key 
directories tracked fast 	exists list 
export functions 	serve blocked 
means empty revision 	clients 
gets git 	data serve 
commit strlen key 	clients order 
svndump.h filename 	blocked key 
back url local 	first blocked 
notes symbolic-ref.c 	last protect 
git symbolic 	receiver 
usage head quiet 	bpop target 
shorten print 	freed next 
sha flag refname 	unblock client 
argc argv 	call failed 
prefix ret msg 	serving client 
options resolve 	need 
die die shorten 	also undo 
unambiguous puts 	pop operation 
git config parse 	call signal 
options die 	modified key 
usage options check 	already called 
symref die 	element 
check symref strcmp 	pushed list 
starts die 	free item 
create symref usage 	list place 
options symlinks.c 	point blocking 
cache name 	rpop lpop 
len cache name 	non 
len prefix 	empty list 
len name len 	like non 
name len 	normal pop 
previous slash max 	replicate pop 
len cache 	instead pop 
cache cache name 	inside 
len ret 	multi exec 
flags track flags 	list empty 
prefix len 	thing treating 
stat func match 	timeout even 
len last 	timeout list 
slash last slash 	empty 
dir previous 	key exists 
slash save flags 	must block 
ret cache 	blocking empty 
name len track 	list multi 
flags prefix 	state returns 
len stat 	immediately 
func flags cache 	list empty 
name len 	client blocks 
name len name 	list exists 
len cache 	elements regular 
name len flags 	rpoplpush command 
match len 	executed 
name len prefix 	t setc 
len cache 	setkeys setnum 
name len prefix 	dstkey subject 
len removal 	llval success 
len name len 	setobj llval 
match len 	success 
last slash previous 	subject llval 
slash strbuf 	subject objele 
reset reset lstat 	llele intele 
cache longest 	objele encoding 
path match strbuf 	setobj objele 
grow stat 	llele 
lstat isdir 	subject setobj 
islnk reset lstat 	enc intele 
cache lstat 	element added 
cache matchlen lstat 	keyremoved srcset 
cache threaded 	dstset ele 
symlink leading path 	count 
threaded check 	size propargv 
leading path lstat 	objele encoding 
cache matchlen 	llele remaining 
threaded dirs path 	newset ele 
lstat cache 	aux llele 
rmdir longest path 	encoding 
match scheduled 	count size 
dirs strbuf scheduled 	uniq ele 
dirs returns 	llele encoding 
length path component 	retval added 
basis longest 	ele llele 
common prefix match 	encoding 
name name 	setkeys setnum 
name substring 	dstkey sets 
name way around 	eleobj dstset 
name name 	intobj replylen 
exact track flags 	cardinality encoding 
prefix len 	setobj 
stat func members 	deleted setkeys 
safeguard rule 	setnum dstkey 
inside lstat cache 	sets ele 
check name 	dstset cardinality 
name length len 	diff algo 
symlink leading 	setobj 
component directory exists 	algo two 
real speed 	work deleted 
check information allowed 	cursor representable 
cached indicated 	create intset 
track flags argument 	create dict 
also used 	incr 
indicate check full 	count representable 
path prefix 	intset intset 
len stat 	len type 
func parameter used 	convert type 
length prefix 	convert server 
cache use stat 	info 
function instead 	dict incr 
lstat function test 	count server 
path component 	panic dict 
safeguard rule clear 	needs resize 
cache values 	dict resize 
track flags prefix 	representable 
len stat 	intset server 
func match last 	panic dict 
supplied values 	find representable 
check see match 	intset find 
cache excluding 	server panic 
path types match 	zmalloc 
len would 	dict iterator 
know matched 	server panic 
part always directory 	dict release 
also tracking 	iterator zfree 
directories name substring 	dict next 
cache path 	dict 
component basis immediately 	key intset 
okay match 	server panic 
cache far check 	type next 
rest path 	create incr 
components end update 	count server 
cache note 	panic 
max different path 	dict random 
types noent 	key dict 
symlink dir cached 	key intset 
moment separate 	random server 
test directory since 	panic dict 
could found 	size 
symlink non existing 	intset len 
directory track 	server panic 
flags says 	server info 
cannot cache fact 	dict create 
cache would 	dict expand 
left empty allowed 	intset 
track real 	len type 
directories still cache 	init iterator 
path components 	type next 
last one found 	create server 
symlink non 	info dict 
existing component non 	type 
zero path 	release iterator 
name leading symlink 	zfree server 
component non 	panic lookup 
zero path name 	key write 
leading symlink 	type create 
component zero path 	reply 
name leading 	encoding type 
symlink component leading 	signal modified 
path component 	key notify 
exists leading 	keyspace reply 
path exists directory 	lookup key 
path length 	write 
leading path exists 	reply check 
neither directory 	type type 
symlink zero path 	type size 
name leading 	signal modified 
symlink component leading 	key notify 
path component 	keyspace 
exists leading path 	notify keyspace 
exists directory 	reply lookup 
path length leading 	key write 
path exists 	lookup key 
neither directory symlink 	write encoding 
non zero 	reply 
path components name 	check type 
exists directory 	check type 
prefix len test 	reply type 
stat function 	member type 
instead lstat 	reply notify 
function prefix length 	keyspace 
prefix len 	type size 
thus allow symlinks 	notify keyspace 
prefix part 	signal modified 
points real existing 	key signal 
directories non 	modified key 
zero path components 	type 
name exists 	create type 
directory prefix len 	notify keyspace 
test stat 	reply lookup 
function instead lstat 	key read 
function prefix 	reply check 
length prefix len 	type 
thus allow 	encoding type 
symlinks prefix part 	member reply 
points real 	reply lookup 
existing directories 	key read 
find last slash 	reply check 
inside name 	type 
directory check must 	reply type 
first upwards 	size reply 
possible empty directories 	reply lookup 
upwards deeper 	key read 
directory need save 	reply check 
path components 	type 
syslog.c eventlog ident 	reply type 
logopt facility 	size notify 
priority fmt logtype 	keyspace sunion 
str pos 	diff command 
str len source 	notify keyspace 
warning last 	rewrite 
error start vsnprintf 	client command 
end warning 	vector signal 
strerror malloc warning 	modified key 
strerror start 	create reply 
vsnprintf end 	multi bulk 
strstr realloc warning 	len 
strerror memmove 	type random 
strlen report free 	element create 
syslog.h ident 	incr count 
logopt facility priority 	reply bulk 
fmt syslog 	type also 
tag.c tag type 	propagate 
warn warnlen 	decr count 
sha obj buf 	type random 
tail dateptr 	element create 
item data size 	incr count 
sha type 	type create 
bufptr tail item 	type 
data size 	type decr 
ret parse strlen 	count incr 
error parse 	count overwrite 
lookup create alloc 	type init 
tag node 	iterator type 
type strtoul 	next 
memcmp sha hex 	create incr 
starts memchr 	count reply 
memcpy strcmp lookup 	bulk also 
blob strcmp 	propagate decr 
lookup strcmp lookup 	count type 
commit strcmp 	release 
lookup tag error 	iterator decr 
starts memchr 	count decr 
xmemdupz starts parse 	count prevent 
tag date 	command propagation 
read sha file 	spop count 
error oid 	command 
hex free error 	reply lookup 
oid hex 	key write 
parse tag buffer 	reply check 
free nada 	type type 
nada dateptr buf 	random element 
buf strtoul 	create 
stop buf 	intset incr 
sha good builtin 	count type 
git tag 	notify keyspace 
copyright kristian gsberg 	create rewrite 
krh redhat 	client command 
carlos rica jasampler 	vector 
gmail git 	decr count 
tag mktag linus 	decr count 
torvalds parse 	reply bulk 
arg given sorting 	type size 
skip header 	notify keyspace 
skip write message 	signal 
editing git 	modified key 
tag usage colopts 	reply lookup 
filter sorting 	key read 
format free argv 	reply check 
error sha 	type type 
name sha 	size 
name sha argv 	reply reply 
verify tag 	multi bulk 
buffer tag tag 	len type 
nocleanup arg 	random element 
sorting tail len 	reply bulk 
status sorting 	reply 
tail sha size 	bulk sunion 
buf buf 	diff command 
sign result sign 	dict create 
tag buf 	type init 
opt prev result 	iterator type 
header buf 	next 
header len path 	dict create 
buf given 	dict dup 
buf opt arg 	server type 
unset msg 	release iterator 
name argc argv 	server 
prefix buf 	dict size 
prev tag 	dict random 
opt cleanup arg 	key dict 
create reflog 	dict key 
force cmdmode keyid 	type random 
msg transaction 	element 
err filter sorting 	create dup 
tail format 	dict decr 
options ret copts 	count reply 
memset xstrfmt 	multi bulk 
verify format filter 	len dict 
refs sort 	iterator 
show item clear 	dict next 
free snprintf 	reply bulk 
error read error 	dict key 
find unique 	dict release 
abbrev sha hex 	iterator dict 
run command 	release 
opt error sign 	srandmember count 
buffer signing 	command reply 
key xcalloc 	lookup key 
skip prefix skip 	read reply 
prefix strlen 	check type 
parse filter atom 	type 
strcmp config 	random element 
error nonbool parse 	reply bulk 
sorting git 	reply bulk 
gpg config starts 	type size 
git column 	type size 
config git config 	type 
read sha 	size type 
file strstr free 	size zmalloc 
write die 	lookup key 
parse signature free 	write lookup 
sign error 	key read 
write sha file 	zfree 
error sha 	signal modified 
info die snprintf 	key reply 
sha hex 	reply check 
git committer 	type zfree 
info die git 	qsort deferred 
pathdup open 	multi 
die errno sha 	bulk length 
write tag 	create intset 
body strbuf addch 	type init 
strbuf commented 	iterator type 
addf strbuf commented 	next intset 
addf write 	find 
die strbuf release 	create type 
close launch 	member decr 
editor exit strbuf 	count decr 
stripspace die 	count intset 
strbuf insert build 	find type 
tag exit 	member 
unlink warn free 	reply bulk 
strbuf addstr 	reply bulk 
strbuf addstr strbuf 	create type 
reset strbuf 	decr count 
addf check 	type type 
refname format git 	release 
config memset 	iterator type 
memset parse options 	size reply 
signing key 	type size 
usage options finalize 	notify keyspace 
colopts explicitly 	decr count 
enable column die 	reply 
sorting column 	notify keyspace 
active memset run 	signal modified 
column filter 	key deferred 
list tags column 	multi bulk 
active stop 	length zfree 
column filter die 	sinter 
die die 	command sinter 
die tag name 	command zmalloc 
tag name 	lookup key 
die strbuf 	write lookup 
addbuf strcmp strbuf 	key read 
read die 	check 
errno strbuf read 	type zfree 
file die 	type size 
errno die sha 	type size 
die strbuf 	qsort create 
check tag die 	intset type 
read hashclr 	init 
die strcmp strcmp 	iterator type 
strcmp die 	next type 
create tag transaction 	decr count 
begin transaction 	type release 
update transaction commit 	iterator type 
die transaction 	init 
free sha hashcmp 	iterator type 
find unique 	next type 
abbrev strbuf release 	member type 
strbuf release 	decr count 
strbuf release 	type release 
nada nada dateptr 	iterator 
buf buf 	type init 
strtoul stop buf 	iterator type 
sha good 	next type 
builtin git tag 	type decr 
copyright kristian 	count type 
gsberg krh redhat 	release 
carlos rica 	iterator reply 
jasampler gmail git 	multi bulk 
tag mktag 	len type 
linus torvalds parse 	init iterator 
arg given 	type next 
sorting skip header 	reply 
skip write 	bulk decr 
message editing tag.c 	count type 
tag type 	release iterator 
warn warnlen sha 	decr count 
obj buf 	type size 
tail dateptr 	reply 
item data size 	type size 
sha type 	notify keyspace 
bufptr tail item 	decr count 
data size 	reply notify 
ret parse strlen 	keyspace signal 
error parse 	modified 
lookup create alloc 	key zfree 
tag node 	sunion diff 
type strtoul memcmp 	command sunion 
sha hex 	diff command 
starts memchr memcpy 	sunion diff 
strcmp lookup 	command 
blob strcmp lookup 	sunion diff 
strcmp lookup 	command parse 
commit strcmp lookup 	scan cursor 
tag error 	reply lookup 
starts memchr xmemdupz 	key read 
starts parse 	reply 
tag date 	check type 
read sha file 	scan command 
error oid 	copyright salvatore 
hex free error 	sanfilippo antirez 
oid hex 	gmail dot 
parse tag buffer 	rights 
free nada 	reserved redistribution 
nada dateptr buf 	use source 
buf strtoul 	binary forms 
stop buf sha 	without modification 
good builtin 	permitted provided 
git tag copyright 	following 
kristian gsberg 	conditions met 
krh redhat carlos 	redistributions source 
rica jasampler 	code must 
gmail git tag 	retain copyright 
mktag linus 	notice list 
torvalds parse 	conditions 
arg given sorting 	following disclaimer 
skip header 	redistributions binary 
skip write message 	form must 
editing git 	reproduce copyright 
tag usage colopts 	notice list 
filter sorting 	conditions 
format free argv 	following disclaimer 
error sha 	documentation materials 
name sha name 	provided distribution 
sha argv 	neither name 
verify tag buffer 	redis names 
tag tag 	contributors 
nocleanup arg sorting 	may used 
tail len 	endorse promote 
status sorting tail 	products derived 
sha size 	software without 
buf buf sign 	specific prior 
result sign 	written 
tag buf 	permission software 
opt prev result 	provided copyright 
header buf 	holders contributors 
header len path 	express implied 
buf given 	warranties including 
buf opt arg 	limited 
unset msg 	implied warranties 
name argc argv 	merchantability fitness 
prefix buf 	particular purpose 
prev tag opt 	disclaimed shall 
cleanup arg 	copyright owner 
create reflog force 	contributors 
cmdmode keyid 	liable direct 
msg transaction err 	indirect incidental 
filter sorting 	special exemplary 
tail format options 	consequential damages 
ret copts 	including limited 
memset xstrfmt verify 	procurement 
format filter 	substitute goods 
refs sort 	services loss 
show item clear 	use data 
free snprintf 	profits business 
error read error 	interruption however 
find unique 	caused 
abbrev sha hex 	theory liability 
run command 	whether contract 
opt error sign 	strict liability 
buffer signing 	tort including 
key xcalloc skip 	negligence otherwise 
prefix skip 	arising 
prefix strlen parse 	way use 
filter atom 	software even 
strcmp config error 	advised possibility 
nonbool parse 	damage commands 
sorting git gpg 	factory method 
config starts 	hold 
git column config 	integer encodable 
git config 	intset returned 
read sha 	otherwise regular 
file strstr free 	hash table 
write die 	specified function 
parse signature free 	takes 
sign error 	care incrementing 
write sha file 	reference count 
error sha 	needed order 
info die snprintf 	retain copy 
sha hex 	already member 
git committer info 	nothing 
die git 	done returned 
pathdup open die 	otherwise element 
errno sha 	added returned 
write tag body 	convert regular 
strbuf addch 	intset contains 
strbuf commented addf 	many 
strbuf commented 	entries failed 
addf write 	integer convert 
die strbuf release 	regular intset 
close launch 	integer encodable 
editor exit strbuf 	dict always 
stripspace die 	work 
strbuf insert build 	move next 
tag exit 	entry returns 
unlink warn free 	current position 
strbuf addstr 	since elements 
strbuf addstr strbuf 	internally stored 
reset strbuf 	redis 
addf check refname 	objects simple 
format git 	arrays integers 
config memset memset 	type next 
parse options 	returns encoding 
signing key usage 	iterating populate 
options finalize 	appropriate 
colopts explicitly enable 	pointer objele 
column die 	llele accordingly 
sorting column 	note objele 
active memset run 	llele pointers 
column filter 	passed cannot 
list tags column 	since 
active stop 	function defensively 
column filter die 	populate non 
die die 	used field 
die tag name 	values easy 
tag name 	trap misused 
die strbuf addbuf 	longer 
strcmp strbuf 	elements returned 
read die errno 	returned objects 
strbuf read 	count incremented 
file die errno 	function copy 
die sha 	write friendly 
die strbuf check 	needed 
tag die 	defensive needed 
read hashclr die 	defensive copy 
strcmp strcmp 	write friendly 
strcmp die 	version easy 
create tag transaction 	use version 
begin transaction 	type 
update transaction commit 	next type 
die transaction 	next returning 
free sha hashcmp 	objects incrementing 
find unique 	count returned 
abbrev strbuf release 	objects retain 
strbuf release 	pointer 
strbuf release nada 	call decr 
nada dateptr 	count function 
buf buf strtoul 	way write 
stop buf 	operations cow 
sha good builtin 	issue result 
git tag 	anyway 
copyright kristian gsberg 	incrementing count 
krh redhat 	suppress warnings 
carlos rica jasampler 	random element 
gmail git 	non empty 
tag mktag 	returned element 
linus torvalds parse 	encoded 
arg given 	intset blob 
sorting skip header 	integers redis 
skip write 	regular caller 
message editing tag.h 	provides pointers 
tag type 	populated right 
tagged tag date 	function 
sha item 	encoding field 
data size item 	used caller 
tag tar.h 	check pointer 
name mode uid 	redis pointer 
gid size 	populated note 
mtime chksum typeflag 	objele 
linkname magic 	llele pointers 
version uname gname 	passed cannot 
devmajor devminor 	since function 
prefix tempfile.c tempfile 	defensively populate 
list skip 	non used 
fclose signo 	field 
tempfile tempfile path 	values easy 
save errno 	trap misused 
tempfile path tempfile 	returned real 
suffixlen mode 	count incremented 
tempfile suffixlen mode 	function considered 
tmpdir tempfile 	copy 
mode full tempfile 	write friendly 
mode tempfile 	needed defensive 
tempfile tempfile tempfile 	needed defensive 
err save 	convert specified 
errno tempfile tempfile 	encoding resulting 
path save 	dict 
errno tempfile getpid 	converting hash 
tempfile tempfiles 	table presized 
tempfiles sigchain pop 	hold number 
sigchain push 	elements original 
common atexit 	presize dict 
die strbuf init 	avoid 
die prepare 	rehashing elements 
tempfile strbuf absolute 	extract integers 
path open 	create redis 
strbuf reset getpid 	objects source 
adjust shared 	key exist 
perm error tempfile 	source 
prepare tempfile 	key wrong 
strbuf absolute path 	type destination 
getpid prepare 	key wrong 
tempfile strbuf absolute 	type error 
path git 	srcset dstset 
mkstemps mode strbuf 	equal 
reset getpid 	smove element 
prepare tempfile getenv 	cannot removed 
strbuf addf 	src src 
git mkstemps mode 	database empty 
strbuf reset 	create destination 
getpid strbuf 	doesn 
absolute path mks 	exist extra 
tempfile die 	key changed 
errno strbuf release 	ele successfully 
die die 	added dstset 
fdopen die die 	handle spop 
die ferror 	key 
fclose close tempfile 	count variant 
die die 	normal version 
open die close 	command handled 
tempfile rename 	spop command 
tempfile strbuf reset 	function many 
close tempfile 	times 
unlink warn strbuf 	bigger compared 
reset state 	remaining size 
diagram cleanup program 	use create 
exits temporary 	strategy read 
file active want 	later implementation 
make sure 	info 
done remembering 	count argument 
active temporary files 	make sure 
linked list 	key name 
tempfile list atexit 	inputted exists 
handler signal 	type indeed 
handler registered clean 	otherwise 
active temporary 	nil count 
files signal handler 	zero serve 
run time 	empty multibulk 
tempfile list tempfile 	asap avoid 
objects comprise 	special cases 
must kept self 	later 
consistent states 	generate spop 
times possible states 	keyspace notification 
tempfile follows 	number requested 
uninitialized state list 	elements greater 
field must 	equal number 
zero rest contents 	elements 
need initialized 	inside simply 
soon used 	whole entire 
way irrevocably registered 	empty propagate 
tempfile list 	command del 
list active file 	operation require 
open create 	replicate 
tempfile reopen tempfile 	spop serm 
state temporary 	commands prepare 
file exists active 	replication argument 
filename holds 	vector also 
filename temporary file 	send length 
holds file 	common 
descriptor open writing 	code paths 
holds pointer 	common iteration 
open file fdopen 	vars elements 
tempfile called 	left spop 
owner holds pid 	number requested 
process created 	elements 
file active 	less number 
file closed successful 	elements inside 
close tempfile 	also sure 
previous state temporary 	count size 
file closed 	use two 
inactive tempfile rename 	different 
tempfile failed 	strategies number 
attempt create temporary 	elements small 
file failed 	compared size 
close tempfile state 	extract random 
active unset 	elements element 
filename empty usually 	client 
though transitory 	replicate aof 
states condition doesn 	command srem 
hold client 	operation number 
code rely filename 	elements big 
empty state 	approaching size 
left registered tempfile 	time 
list list 	extracting random 
temporary file 	elements becomes 
owned process created 	computationally expensive 
tempfile owner 	use different 
field records owner 	strategy extract 
pid field 	random 
used prevent forked 	elements want 
process deleting 	elements remain 
temporary file created 	part creating 
parent fclose 	stored original 
safe call signal 	elements left 
handler initialize 	original 
tempfile necessary tempfile 	release create 
list one 	remaining elements 
time initialization initialize 	assign key 
tempfile tempfile 	protect old 
list shouldn happen 	tranfer old 
better safe 	client 
sorry make sure 	release replicate 
errno contains 	aof command 
meaningful error 	srem operation 
note circuiting want 	propagate command 
fclose tempfile.h 	even 
next active owner 	incremented dirty 
list filename 	counter want 
tempfile path tempfile 	propagate spop 
path tempfile 	command since 
suffixlen mode tempfile 	propagated command 
suffixlen tempfile 	sre 
mode tempfile tempfile 	operations also 
suffixlen mode 	propagate api 
tempfile suffixlen tempfile 	make sure 
mode tempfile 	key name 
tempfile mode tempfile 	inputted exists 
tempfile mode 	type 
tempfile tempfile tempfile 	indeed random 
tempfile tempfile 	element element 
tempfile tempfile tempfile 	replicate aof 
path handle 	command srem 
temporary files 	operation element 
tempfile api allows 	reply 
temporary files 	empty modified 
created deleted atomically 	handle srandmember 
renamed temporary 	key count 
files still active 	variant normal 
program ends 	version command 
cleaned automatically lockfiles 	handled 
see lockfile 	srandmember command 
built top api 	function many 
calling sequence 	times bigger 
caller allocates tempfile 	compared requested 
either variable 	size use 
heap initialized zeros 	elements 
use structure 	strategy read 
call create tempfile 	later implementation 
belongs tempfile 	info negative 
subsystem storage 	count means 
must remain valid 	elements multiple 
throughout life 	times 
program cannot use 	extracted element 
stack variable 	every extraction 
hold structure attempts 	count zero 
create temporary 	serve asap 
file calling create 	avoid special 
tempfile writes 	cases 
content file either 	later count 
writing file 	negative extraction 
descriptor returned create 	method random 
tempfile also 	elements sampling 
available via tempfile 	whole every 
calling fdopen 	time 
tempfile file pointer 	trivial served 
open file 	without auxiliary 
writing file stdio 	data structures 
finished writing 	number requested 
caller close 	elements greater 
file descriptor temporary 	number 
file calling 	elements inside 
tempfile close temporary 	simply whole 
file rename 	need auxiliary 
atomically specified filename 	dictionary number 
calling rename 	elements inside 
tempfile relinquishes control 	greater 
file close 	srandmember sub 
file descriptor without 	strategy mul 
removing renaming 	times number 
temporary file calling 	requested elements 
close tempfile 	create scratch 
later call tempfile 	elements 
rename tempfile 	subtract random 
even temporary file 	elements reach 
renamed deleted 	requested number 
tempfile must freed 	elements done 
altered caller 	number requsted 
however may 	elements 
reused pass another 	bit less 
call create 	number elements 
tempfile program exits 	natural approach 
rename tempfile 	used highly 
tempfile called atexit 	inefficient elements 
handler close 	temporary 
temporary file need 	dictionary random 
close file 	elements reach 
descriptor calling close 	right count 
tempfile never 	big compared 
call close fclose 	requested number 
otherwise tempfile 	elements 
structure would still 	simply random 
think file 	elements temporary 
descriptor needs closed 	trying eventually 
later cleanup 	enough unique 
would result duplicate 	elements reach 
calls close 	specified 
worse yet 	count dictionary 
close later open 	already exists 
another file 	free otherwise 
descriptor completely different 	increment number 
purpose unrelated 	objects result 
file descriptor might 	dictionary 
closed error 	send result 
handling create tempfile 	user used 
returns file 	sdiff receive 
descriptor success failure 	handled empty 
errors errno 	sets sort 
describes reason failure 	sets 
tempfile rename 	smallest largest 
tempfile close tempfile 	improve algorithm 
success failure 	performance first 
errno appropriately best 	thing output 
temporary file 	total number 
attempt create temporary 	elements 
file specified 	since multi 
path file 	bulk write 
descriptor writing error 	stage know 
error file 	intersection size 
already exists path 	use trick 
existing file 	append 
tempfile meaning deleted 	empty output 
program exits 	list save 
tempfile considered closed 	pointer later 
worked like 	modify right 
closed tempfile example 	length target 
opened reopen 	key 
tempfile mks tempfile 	store resulting 
functions following 	create key 
functions attempt create 	empty inside 
open temporary 	iterate elements 
files names derived 	first smallest 
automatically manner 	test 
mkstemps arrange 	element sets 
deleted program ends 	least one 
deleted explicitly 	include element 
whole family functions 	discarded intset 
named according 	intset simple 
following pattern mks 	fast 
tempfile optional 	order compare 
letters following meanings 	integer use 
die temporary 	function creating 
file cannot created 	optimization source 
create temporary 	integer encoded 
file tmpdir opposed 	target 
relative current 	intset much 
directory variants used 	faster path 
pattern filename 	check easy 
alone without path 	use type 
includes suffix 	agnostic api 
suffixlen characters temporary 	take 
file created 	action sets 
specified mode 	contain member 
otherwise mode none 	store resulting 
functions modify 	target intersection 
caller wants know 	empty diff 
absolute path 	algorithm 
file created read 	use algorithm 
tempfile filename 	size element 
success functions file 	first total 
descriptor open 	number sets 
writing temporary file 	algorithm total 
errors errno 	number 
appropriately variants die 	elements sets 
errors see 	compute best 
mks tempfile functions 	bet current 
see mks 	input algorithm 
tempfile functions see 	better constant 
mks tempfile 	times 
functions see mks 	performs less 
tempfile functions 	operations elements 
see mks 	common give 
tempfile functions see 	advantage algorithm 
mks tempfile 	better order 
functions see mks 	sets 
tempfile functions 	subtract decreasing 
see mks tempfile 	size likely 
functions see 	find duplicated 
mks tempfile functions 	elements asap 
see mks 	need temp 
tempfile functions associate 	store 
stdio stream 	dstkey inside 
temporary file must 	sunionstore operation 
still open 	resulting target 
without deleting file 	key trivial 
error stream 	every element 
closed automatically close 	every 
tempfile called 	temporary non 
file deleted renamed 	existing keys 
path lockfile 	like empty 
pointer field 	sets diff 
within file freed 	algorithm perform 
temporary file 	diff 
still open close 	iterating elements 
file pointer 	first adding 
opened fdopen tempfile 	target element 
without deleting 	exist sets 
file upon success 	way perform 
failure close 	max 
negative file usually 	operations size 
tempfile rename 	first number 
tempfile eventually called 	sets key 
close tempfile 	empty element 
succeeds open temporary 	diff algorithm 
file closed 	elements 
close tempfile yet 	first auxiliary 
deleted renamed 	elements next 
used implement 	sets sum 
sequence operations like 	elements every 
following create 	non existing 
temporary file write 	keys 
contents file 	like empty 
close tempfile cause 	sets exit 
contents written 	result empty 
disk pass name 	additional removal 
temporary file 	elements effect 
another program allow 	output 
nobody inspect 	content resulting 
even modify file 	store mode 
contents reopen 	target key 
tempfile reopen temporary 	store resulting 
file make 	create key 
updates contents rename 	result 
tempfile move 	inside t 
file permanent location 	stringc size 
close file 	flags key 
descriptor file 	val expire 
pointer temporary file 	unit reply 
associated tempfile 	abort 
call tempfile tempfile 	reply milliseconds 
already deleted 	expire unit 
renamed close file 	flags next 
descriptor file 	offset olen 
pointer still open 	start end 
atomically rename 	str 
temporary file path 	llbuf strlen 
path must 	busykeys incr 
filesystem file success 	oldvalue incr 
failure temporary 	incr incr 
file errno failing 	aux totlen 
call close 	append 
rename bug call 	reply error 
rename tempfile 	reply reply 
tempfile currently active 	error format 
tempfile terminal.c 	lookup key 
sig term 	write lookup 
old term hconin 	key 
cmode prompt 	write reply 
echo buf input 	key expire 
output prompt 	mstime notify 
echo restore term 	keyspace notify 
sigchain pop 	keyspace reply 
tcsetattr close open 	reply 
tcgetattr sigchain 	encoding command 
push common tcsetattr 	encoding command 
close console 	encoding command 
mode close handle 	encoding command 
create file 	lookup key 
console mode sigchain 	read 
push common 	reply reply 
console mode close 	reply bulk 
handle fopen 	command command 
fopen fclose disable 	encoding key 
echo fclose 	notify keyspace 
fclose fputs 	reply 
fflush strbuf getline 	reply error 
putc fflush 	lookup key 
restore term fclose 	write sdslen 
fclose getpass 	reply check 
terminal.h prompt echo 	length sdslen 
compat terminal 	create 
test-chmtime.c usage str 	sdsnewlen sdslen 
arg time 	check type 
test timespec argc 	len sdslen 
argv verbose 	reply check 
time utb mtime 	length sdslen 
strtol time 	unshare 
strcmp strcmp timespec 	sdslen sdsgrowzero 
arg stat 	sdslen memcpy 
strerror chmod strerror 	sdslen signal 
utime strerror 	modified key 
program either 	notify keyspace 
change modification time 	reply 
given file 	sdslen reply 
print program change 	reply lookup 
atime ctime 	key read 
values explicitly preserved 	reply check 
mtime changed 	type sdslen 
absolute test chmtime 	reply 
seconds file 	reply bulk 
relative current time 	buffer reply 
returned time 	multi bulk 
test chmtime seconds 	len lookup 
seconds file 	key read 
relative current mtime 	reply 
file test 	reply reply 
chmtime seconds file 	bulk reply 
test chmtime 	error lookup 
seconds seconds file 	key write 
examples print 	reply encoding 
mtime use 	key 
verbose file mtime 	notify keyspace 
offset test 	reply mset 
chmtime file mtime 	command mset 
current time 	command lookup 
test chmtime file 	key write 
relative future 	check 
mtime change test-config.c 	type reply 
argc argv 	reply error 
val strptr err 	create overwrite 
err git 	signal modified 
configset init strcmp 	key notify 
git config 	keyspace 
strcmp git config 	reply reply 
multi strcmp 	reply incr 
git config strcmp 	decr command 
git config 	incr decr 
strcmp git config 	command reply 
strcmp git 	incr 
configset file 	decr command 
git configset strcmp 	reply incr 
git configset 	decr command 
file git configset 	lookup key 
multi die 	write check 
git configset clear 	type 
git configset 	reply reply 
clear git configset 	isnan isinf 
clear program 	reply error 
exposes api configuration 	create overwrite 
mechanism simple 	signal modified 
commands order facilitate 	key 
testing reads 	notify keyspace 
stdin prints result 	reply bulk 
command stdout 	create rewrite 
prints highest priority 	client command 
entered key 	argument decr 
multi prints values 	count 
entered key 	rewrite client 
increasing order 	command argument 
priority print integer 	lookup key 
entered key 	write encoding 
die print entered 	incr count 
key die 	len 
print entered key 	check type 
die configset 	len sdslen 
returns highest priority 	check length 
entered key 	unshare sdscatlen 
config constructed files 	sdslen sdslen 
entered arguments 	signal 
configset multi returns 	modified key 
list entered 	notify keyspace 
key sorted order 	reply lookup 
priority config 	key read 
constructed files entered 	reply check 
arguments examples 	type 
print highest priority 	reply len 
key foo 	copyright salvatore 
baz rock 	sanfilippo antirez 
test config foo 	gmail dot 
baz rock 	rights reserved 
test-ctype.c argc argv 	redistribution 
strchr test 	use source 
test test test 	binary forms 
test find 	without modification 
nul strchr classless 	permitted provided 
anyway test-date.c 	following conditions 
usage msg argv 	met 
buf argv 	redistributions source 
result argv argc 	code must 
argv atoi 	retain copyright 
show date relative 	notice list 
strbuf release 	conditions following 
strbuf reset parse 	disclaimer 
date sscanf 	redistributions binary 
show date 	form must 
date mode strbuf 	reproduce copyright 
release approxidate 	notice list 
relative show date 	conditions following 
date mode 	disclaimer 
getenv atoi gettimeofday 	documentation materials 
usage strcmp 	provided distribution 
show dates strcmp 	neither name 
parse dates 	redis names 
strcmp parse approxidate 	contributors may 
usage test-delta.c 	used 
usage str argc 	endorse promote 
argv buf 	products derived 
data buf buf 	software without 
size data 	specific prior 
size size strcmp 	written permission 
strcmp open 	software 
fstat perror mmap 	provided copyright 
perror close 	holders contributors 
close open 	express implied 
fstat perror mmap 	warranties including 
perror close 	limited implied 
close diff delta 	warranties 
patch delta 	merchantability fitness 
open write full 	particular purpose 
perror test 	disclaimed shall 
delta test code 	copyright owner 
exercise diff 	contributors liable 
delta patch delta 	direct 
nicolas pitre 	indirect incidental 
nico fluxnic net 	special exemplary 
code free 	consequential damages 
software redistribute modify 	including limited 
terms gnu 	procurement substitute 
general license version 	goods 
published free 	services loss 
software foundation test-dump-cache-tree.c 	use data 
pfx pfx 	profits business 
errs path 	interruption however 
rdwn istate another 	caused theory 
sha hex 	liability 
dump one dump 	whether contract 
one dump 	strict liability 
one hashcmp dump 	tort including 
one cache 	negligence otherwise 
sub xsnprintf dump 	arising way 
cache cache 	use 
read cache die 	software even 
cache update 	advised possibility 
dump cache missing 	damage isnan 
either invalid 	isinf commands 
claims valid lying 	command function 
test-dump-split-index.c pos 	operation 
data read index 	different options 
sha hex 	variants function 
sha hex sha 	called order 
hex stage 	implement following 
ewah bit 	commands setex 
ewah bit test-dump-untracked-cache.c 	psetex 
ucd len 	setnx flags 
strcmp strcmp qsort 	changes behavior 
qsort strbuf 	command see 
addf sha hex 	belove expire 
fputs fputs 	represents expire 
fputs dump strbuf 	form 
setlen setup 	redis passed 
git directory read 	user interpreted 
cache die 	according specified 
sha hex sha 	unit reply 
hex dump 	abort 
hack avoid modifying 	reply function 
untracked cache 	reply client 
read test-fake-ssh.c argc 	operation performed 
argv trash 	flags reply 
directory buf 	used abort 
child argv getenv 	reply 
die strbuf 	used key 
addf fopen die 	exists key 
fclose run 	exists time 
command opt first 	seconds given 
print parameters 	time given 
trash directory ssh 	initialized 
output evaluate 	avoid harmness 
last parameter test-genrandom.c 	warning key 
argc argv 	seconds milliseconds 
count next strtoul 	setting nothing 
putchar simple 	non existing 
random data generator 	resulting 
used create 	exceeds allowed 
reproducible test files 	size key 
inspired posix 	exists check 
implementation example rand 	type existing 
copyright nicolas 	length setting 
pitre licensed 	nothing 
gpl version test-hashmap.c 	resulting exceeds 
ent key 	allowed size 
key key hash 	create copy 
key klen 	shared encoded 
vlen entry method 	convert negative 
key hash 	indexes 
method rounds map 	precondition end 
buf entries 	end strlen 
hashes argc argv 	condition nothing 
line map 	returned start 
icase cmd hash 	end handle 
entry key 	flag 
iter strlen strcmp 	msetnx semantic 
strcasecmp malloc 	zero nothing 
hashmap entry init 	least one 
memcpy memcpy 	already key 
strhash malloc malloc 	exists always 
snprintf alloc 	replicate 
test entry 	incrbyfloat command 
strlen hash hashmap 	order make 
init hashmap 	sure differences 
entry init hashmap 	precision formatting 
hashmap free 	create differences 
hashmap init hashmap 	replicas 
entry init 	aof restart 
hashmap hashmap hash 	create key 
hashmap free 	key exists 
strcmp hashmap init 	check type 
hashmap cmp 	append argument 
fgets strtok strtok 	always 
strlen strihash 	sds append 
strhash strtok strlen 	t zsetc 
strcmp strhash 	spec spec 
memhash strihash memihash 	level score 
strcmp alloc 	obj zsl 
test entry hashmap 	node 
strcmp alloc 	zsl next 
test entry 	level zsl 
hashmap put puts 	score obj 
free strcmp 	update rank 
hashmap hash puts 	level zsl 
puts hashmap 	update 
next strcmp hashmap 	zsl score 
entry init 	obj update 
hashmap puts free 	spec spec 
strcmp hashmap 	zsl range 
iter init hashmap 	zsl range 
iter next 	zsl 
strcmp strcmp strintern 	range zsl 
strintern strcmp 	range dict 
strcmp perf hashmap 	update removed 
atoi atoi 	next zsl 
hashmap free key 	range dict 
two terminated 	update 
test performance 	removed next 
hashmap usage time 	zsl start 
echo perfhashmap 	end dict 
method rounds test 	update removed 
hashmap test 	next zsl 
adding map entries 	score 
test map 	rank zsl 
lookups fill map 	rank traversed 
sparsely specified 	min max 
read stdin line 	spec eptr 
line print 	item dest 
result commands stdout 	min 
hash key 	max spec 
strhash key memhash 	spec spec 
key strihash 	spec zsl 
key memihash key 	range zsl 
put key 	range zsl 
old key key 	range 
old iterate 	sptr vstr 
key nkey 	vlen vlong 
size tablesize numentries 	buf score 
perfhashmap method 	sptr vstr 
rounds test hashmap 	vlen vlong 
performance init 	eptr 
hash map process 	cstr clen 
commands stdin 	vstr vlen 
line command two 	vlong vbuf 
parameters ignore 	minlen cmp 
empty lines print 	eptr sptr 
results different 	eptr 
hash functions create 	sptr eptr 
entry key 	sptr eptr 
hashmap create entry 	sptr range 
key replace 	score range 
entry print free 	sptr score 
replaced entry 	range 
lookup entry hashmap 	sptr score 
print result 	spec res 
setup key 	spec res 
entry hashmap print 	range range 
result free 	sptr range 
entry print table 	sptr 
sizes test 	ele score 
strintern works test-index-version.c 	sptr eptr 
argc argv 	eptr ele 
hdr version memset 	score sptr 
read ntohl 	scorebuf scorelen 
test-line-buffer.c end command 	offset 
arg buf 	ele score 
line stdin buf 	sptr range 
arg argc 	deleted eptr 
argv stdin buf 	sptr score 
file buf 	num range 
input filename strtoumax 	deleted 
die starts 	eptr sptr 
strbuf addch buffer 	num start 
read binary 	end deleted 
strtouint fwrite 	num zobj 
strbuf release starts 	length zobj 
buffer copy 	encoding 
bytes strtouint starts 	node next 
buffer skip 	ele score 
bytes strtouint die 	eptr sptr 
strchr die 	vstr vlen 
handle command usage 	vlong zobj 
buffer init 	maxelelen 
die errno buffer 	zset zobj 
fdinit strtouint 	member score 
die errno buffer 	flags nanerr 
init die 	key ele 
errno buffer read 	zobj curobj 
line handle 	curscore 
line buffer deinit 	elements scoreidx 
die buffer 	added updated 
deinit die ferror 	processed opt 
die test 	incr eptr 
line buffer 	znode key 
code exercise svn 	zobj 
importer input 	eptr score 
helper test-match-trees.c hash 	rangetype key 
hash shifted 	zobj keyremoved 
one two sha 	deleted range 
die sha 	lexrange start 
die parse indirect 	end 
die parse 	llen val 
indirect die shift 	ell val 
sha hex 	val val 
exit test-mergesort.c text 	val score 
next argc 	target val 
argv line lines 	aggregate 
strcmp strbuf 	dstkey setnum 
getwholeline xmalloc strbuf 	aggregate src 
detach llist 	zval tmp 
mergesort test-mktemp.c 	maxelelen dstobj 
argc argv usage 	dstzset znode 
xmkstemp xstrdup 	touched 
test mktemp code 	obj remaining 
exercise creation 	score accumulator 
temporary files test-parse-options.c 	score ele 
integer magnitude 	reverse key 
timestamp abbrev quiet 	zobj withscores 
file ambiguous 	start 
list opt arg 	end llen 
unset opt 	rangelen eptr 
arg unset argc 	sptr vstr 
argv prefix 	vlen vlong 
usage options strlen 	zsl ele 
strtol parse 	reverse 
options support unset 	range key 
test-path-utils.c item 	zobj limit 
unused ceil input 	withscores rangelen 
alternative data 	replylen minidx 
func funcname 	maxidx remaining 
buffer basename data 	pos 
dirname data 	eptr sptr 
argc argv buf 	vstr vlen 
len ceiling 	vlong score 
dirs path prefix 	zsl key 
prefix len 	zobj range 
nongit prefix prefix 	count 
rel die 	eptr sptr 
absolute path die 	score zsl 
normalize path 	rank key 
copy die strcmp 	zobj range 
strcmp die 	count eptr 
func xsnprintf func 	sptr 
strcmp error 	zsl rank 
strcmp error strcmp 	reverse range 
xmallocz strlen 	key zobj 
normalize path copy 	limit rangelen 
puts strcmp 	replylen minidx 
puts real 	maxidx 
path strcmp puts 	remaining pos 
absolute path 	eptr sptr 
strcmp xstrdup normalize 	vstr vlen 
path copy 	vlong zsl 
die list split 	key zobj 
filter list 	key 
longest ancestor length 	zobj score 
list clear 	reverse key 
free strcmp strlen 	ele zobj 
setup git 	llen rank 
directory gently puts 	eptr sptr 
prefix path 	zsl 
strcmp strip path 	score cursor 
suffix strcmp 	zmalloc zmalloc 
puts strcmp normalize 	zsl create 
argv normalize 	node decr 
argv relative path 	count zfree 
puts puts 	zfree 
strlen strbuf 	zsl free 
release strcmp test 	node zfree 
function strcmp 	random server 
test function list 	isnan compare 
func function 	objects zsl 
normalizes entry git 	random 
ceiling directories 	level zsl 
path unusable reason 	create node 
die explanation 	compare objects 
input transform output 	equal objects 
output posix 	zsl node 
type paths win 	zsl 
type paths 	free node 
posix type paths 	zsl gte 
win type 	min zsl 
paths normalize arguments 	lte max 
windows bash 	zsl range 
mangles arguments 	zsl 
look like absolute 	gte min 
posix paths 	server zsl 
colon separate lists 	lte max 
absolute posix 	zsl range 
paths dos paths 	zsl lte 
foo foo 	max 
bar might converted 	server zsl 
src msysgit 	gte min 
foo src msysgit 	zsl node 
foo bar 	dict zsl 
whereas longest ancestor 	free node 
length requires 	zsl 
paths use forward 	lex gte 
slashes test-prio-queue.c 	min zsl 
data argc argv 	lex lte 
free strcmp 	max zsl 
show prio queue 	node dict 
strcmp prio 	zsl 
queue show 	free node 
malloc atoi prio 	zsl node 
queue put 	dict zsl 
test-read-cache.c argc argv 	free node 
cnt strtol 	compare objects 
read cache discard 	equal 
cache test-regex.c 	objects strtod 
argc argv pat 	isnan strtod 
str regcomp 	isnan strtod 
die regexec die 	isnan strtod 
die exit 	isnan incr 
http sourceware bugzilla 	count 
show bug 	incr count 
cgi matches test-revision-walking.c 	create sdslen 
commit ctx 	create sdslen 
rev commit argv 	zsl parse 
argc got 	lex range 
revision argc argv 	item 
format commit 	zsl parse 
message strbuf 	lex range 
release size init 	item decr 
revisions setup 	count decr 
revisions prepare revision 	count decr 
walk die 	count 
revision print commit 	decr count 
reset revision 	compare objects 
walk strcmp run 	compare objects 
revision walk 	lex range 
run revision walk 	compare objects 
test revision 	lex 
walking test revision 	range compare 
walking api 	objects lex 
heiko voigt hvoigt 	range compare 
hvoigt net 	objects lex 
code free software 	range compare 
redistribute modify 	objects 
terms gnu general 	lex range 
license version 	compare objects 
published free 	zsl lex 
software foundation test-run-command.c 	gte min 
number callbacks 	zsl lex 
err task err 	lte 
task result 	max zsl 
err task argc 	lex range 
argv proc 	zsl lex 
jobs argv pushv 	gte min 
strbuf addf 	server zsl 
strbuf addf strbuf 	lex 
addf strcmp 	lte max 
start command strcmp 	zsl lex 
exit run 	range zsl 
command atoi strcmp 	lex lte 
exit run 	max server 
processes parallel strcmp 	zsl 
exit run 	lex gte 
processes parallel 	min server 
strcmp exit run 	server ziplist 
processes parallel 	memcpy strtod 
test run command 	server server 
test run 	ziplist 
command api ilari 	create create 
liusvaara ilari 	server ziplist 
liusvaara elisanet code 	memcmp ziplist 
free software 	len server 
redistribute modify terms 	ziplist next 
gnu general 	ziplist 
license version published 	next server 
free software 	server ziplist 
foundation test-scrap-cache-tree.c index 	prev ziplist 
hold locked 	prev server 
index read cache 	ziplist index 
die write 	zzl 
locked index die 	score zsl 
test-sha1-array.c sha 	gte min 
data argc 	ziplist index 
argv line arg 	server zzl 
sha puts 	score zsl 
sha hex strbuf 	lte 
getline skip 	max ziplist 
prefix sha hex 	index zzl 
die sha 	range ziplist 
append skip prefix 	next server 
sha hex 	zzl score 
die sha lookup 	zsl 
strcmp sha 	gte min 
clear strcmp sha 	zsl lte 
unique die 	max ziplist 
test-sha1.c ctx sha 	next ziplist 
bufsz binary 	index zzl 
buffer room strcmp 	range 
strtoul malloc 	ziplist next 
die git sha 	server zzl 
init xread 	score zsl 
die errno 	lte max 
git sha update 	zsl gte 
git sha 	min 
fwrite puts sha 	ziplist prev 
hex exit 	server ziplist 
test-sigchain.c argc argv 	prev ziplist 
sigchain push 	zsl lex 
sigchain push sigchain 	gte min 
push test-string-list.c 	decr 
list arg list 	count ziplist 
list item 	zsl lex 
data prefix argc 	lte max 
argv list 	decr count 
delim maxsplit list 	compare objects 
delim maxsplit 	lex 
list prefix list 	range compare 
strcmp list 	objects ziplist 
split starts strcmp 	index zzl 
atoi list 	lex gte 
split write 	min ziplist 
list list clear 	index 
strcmp xstrdup 	server zzl 
atoi list split 	lex lte 
place write 	max ziplist 
list list clear 	index zzl 
free strcmp 	lex range 
parse list filter 	zzl 
list write 	lex gte 
list compact list 	min zzl 
clear strcmp 	lex lte 
parse list list 	max ziplist 
duplicates write 	next server 
list compact list 	ziplist 
clear parse 	next ziplist 
argument list arg 	index zzl 
either separated 	lex range 
list indicate empty 	zzl lex 
list opposed 	lte max 
indicates list 	zzl 
containing single empty 	lex gte 
list strdup 	min ziplist 
must retain items 	prev server 
specified prefix 	ziplist prev 
arguments list prefix 	ziplist index 
test-submodule-config.c argc 	decoded 
argv msg argc 	ziplist next 
argv arg 	server info 
argc output url 	ziplist compare 
lookup name 	sdslen zzl 
commit sha submodule 	score decr 
commit path 	count 
name exit parse 	ziplist next 
submodule config 	decr count 
option starts strcmp 	ziplist ziplist 
strcmp die 	server info 
usage setup 	sds encoded 
git directory gitmodules 	ziplist 
config git 	push sdslen 
config hashcpy sha 	ziplist push 
die usage 	ziplist insert 
submodule name submodule 	sdslen server 
path die 	info ziplist 
usage submodule free 	next 
test-subprocess.c argc 	ziplist insert 
argv nogit setup 	ziplist index 
git directory 	decoded ziplist 
gently die strcmp 	next server 
setup work 	info zzl 
run command test-svn-fe.c 	score 
test svnfe 	zzl insert 
usage argc argv 	zzl compare 
preimage delta 	elements sdslen 
preimage view argc 	zzl insert 
argv sliding 	ziplist 
view init 	next zzl 
usage buffer init 	insert decr 
die errno 	count zzl 
buffer init die 	first range 
errno svndiff 	ziplist next 
apply strtoumax buffer 	zzl 
deinit die 	score zsl 
errno buffer deinit 	lte max 
die errno 	ziplist ziplist 
strbuf release svndump 	zzl first 
init svndump 	lex range 
read svndump deinit 	ziplist 
svndump reset 	next zzl 
strcmp apply delta 	lex lte 
usage test 	max ziplist 
svn code exercise 	ziplist ziplist 
svn lib 	range zzl 
test-urlmatch-normalization.c argc argv 	length 
usage url 	server panic 
url opt 	server panic 
info strcmp strcmp 	zmalloc dict 
die url 	create zsl 
normalize die url 	create ziplist 
normalize url 	index 
normalize strcmp one 	server info 
url succeed 	ziplist next 
url normalize succeeds 	server info 
fail otherwise 	zzl score 
two urls succeed 	server info 
url normalize 	ziplist 
succeeds results compare 	create create 
equal strcmp 	zsl insert 
given one url 	server info 
url normalize 	dict incr 
succeeds print result 	count zzl 
followed given 	next 
one url url 	zfree ziplist 
normalize succeeds 	server panic 
print returned 	dict release 
length followed test-wildmatch.c 	zfree zfree 
argc argv 	decoded zzl 
die strncmp strcmp 	insert 
wildmatch strcmp 	decr count 
wildmatch strcmp wildmatch 	zsl free 
test.c help 	node zfree 
puts phony program 	server panic 
test xgettext 	zset convert 
message extraction translators 	zzl 
test need 	find dict 
translate translators test 	find dict 
need translate 	val server 
translators test need 	panic strcasecmp 
translate translators 	strcasecmp strcasecmp 
test need translate 	strcasecmp 
translators test 	reply reply 
need translate 	error reply 
translators test need 	error zmalloc 
translate thread-utils.c 	reply lookup 
ncpus info psd 	key write 
mib len 	sdslen 
cpucount ret system 	create zset 
info pstat 	create zset 
getdynamic sysctl sysctl 	ziplist reply 
sysconf pthread 	zzl find 
mutexattr init pthread 	isnan reply 
mutexattr settype 	error 
pthread mutex init 	zzl zzl 
pthread mutexattr 	insert zzl 
destroy two steps 	insert zzl 
least function 	length zset 
somewhat coherent even 	convert sdslen 
disgusting nest 	zset 
ifdefs availcpu defined 	convert encoding 
bsd sysctl 	dict find 
defined ncpu 	dict key 
thread-utils.h compat time.h 	dict val 
intentionally empty 	isnan reply 
file support building 	error 
git msvc 	server info 
trace.c key trace 	zsl zsl 
trace key 	insert incr 
err msg file 	count dict 
line key 	val zsl 
buf trace bare 	insert 
secs key 	incr count 
buf len key 	server info 
buf file 	dict incr 
line key format 	count server 
buf file 	panic reply 
line argv format 	reply 
buf file 	reply zfree 
line key data 	signal modified 
buf trace 	key notify 
perf key 	keyspace zadd 
file line nanos 	command zadd 
format buf 	command 
format key format 	lookup key 
argv format 	write reply 
key data nanos 	check type 
format start 	zzl find 
format file line 	zzl zzl 
key format 	length 
file line argv 	dict find 
format file 	dict val 
line nanos format 	server info 
path path 	zsl dict 
prefix key git 	needs resize 
work cwd 	dict 
key high scaled 	resize dict 
low scale 	size server 
cnt offset highres 	panic notify 
command start 	keyspace notify 
time command 	keyspace signal 
line argv getenv 	modified 
strcmp strcmp 	key reply 
strcasecmp strcmp strcasecmp 	reply reply 
strlen isdigit 	zsl parse 
atoi absolute path 	range reply 
open strerror 	error zsl 
close trace key 	parse 
init trace 	lex range 
want free routine 	reply error 
trace want 	lookup key 
gettimeofday localtime strbuf 	write reply 
addf strbuf 	check type 
addf strbuf addch 	zset 
trace want 	length reply 
write whine pipe 	zzl range 
trace strbuf 	rank zzl 
complete line 	range score 
write whine pipe 	zzl range 
trace strbuf 	lex 
release prepare trace 	zzl length 
line strbuf 	zsl range 
vaddf print trace 	rank zsl 
line prepare 	range score 
trace line strbuf 	zsl range 
vaddf quote 	lex 
argv print trace 	needs resize 
line prepare 	dict resize 
trace line strbuf 	dict size 
addbuf print 	server panic 
trace line trace 	signal modified 
key init 	key 
prepare trace line 	notify keyspace 
strbuf addf 	notify keyspace 
strbuf addstr strbuf 	reply zsl 
vaddf print 	free lex 
trace line 	range zremrange 
start trace vprintf 	command 
end start 	zremrange command 
trace vprintf end 	zremrange command 
start trace 	dict iterator 
argv vprintf end 	dict next 
trace strbuf 	server panic 
start trace performance 	ziplist 
vprintf end 	index ziplist 
start trace performance 	next server 
vprintf getnanotime 	server panic 
end start trace 	server panic 
vprintf end 	unused dict 
start trace argv 	release 
vprintf end 	iterator server 
start trace performance 	panic unused 
vprintf end 	unused server 
strbuf reset strbuf 	panic server 
addstr strbuf 	panic intset 
addstr strbuf 	len 
addstr strbuf addch 	dict size 
trace key 	server panic 
init trace want 	zzl length 
xgetcwd git 	server panic 
work trace key 	server panic 
quote crnl 	decr 
git dir trace 	count memset 
key quote 	intset dict 
crnl git common 	key dict 
dir trace 	next server 
key quote crnl 	panic server 
trace key 	ziplist 
quote crnl trace 	zzl score 
key quote 	zzl next 
crnl free trace 	server panic 
clock gettime 	server panic 
query performance frequency 	sds encoded 
query performance 	sdslen 
counter gettimeofday 	server panic 
highres nanos gettimeofday 	create create 
nanos gettimeofday 	sds encoded 
nanos highres nanos 	sdslen server 
trace performance 	panic zui 
since trace want 	intset 
atexit strbuf 	find zui 
reset quote argv 	dict find 
getnanotime git 	server panic 
information manager hell 	zui zzl 
copyright michael 	find dict 
elkins mutt copyright 	find 
oswald buddenhagen 	dict val 
ossi users net 	server panic 
copyright theodore 	server panic 
tytso mit edu 	zui length 
copyright mike 	zui length 
cormack copyright christian 	isnan 
couder program 	server panic 
free software 	reply reply 
redistribute modify terms 	error reply 
gnu general 	zcalloc lookup 
license published free 	key write 
software foundation 	zfree 
either version license 	reply strcasecmp 
option later 	reply zfree 
version program distributed 	strcasecmp strcasecmp 
hope useful 	strcasecmp strcasecmp 
without warranty without 	zfree reply 
even implied 	zfree 
warranty merchantability fitness 	reply qsort 
particular purpose 	create zset 
see gnu general 	memset zui 
license details 	length zui 
received copy gnu 	init iterator 
general license 	zui 
along program 	next isnan 
write free software 	zunion inter 
foundation inc 	aggregate zui 
temple place suite 	find zunion 
boston usa 	inter aggregate 
trace file descriptor 	zui 
key env 	zsl insert 
variable use git 	incr count 
trace open 	dict incr 
twice never reset 	count sds 
unit tests 	encoded sdslen 
may want disable 	sdslen 
additional trace 	zui clear 
output print current 	iterator dict 
timestamp print 	create dict 
file line align 	expand zui 
trace output 	length zui 
column catches files 	length 
names git 	zui init 
variadic macros 	iterator zui 
fixme move prefix 	next isnan 
startup info 	dict find 
rid arg high 	zui zui 
number per 	sds 
cnt high part 	encoded sdslen 
number per 	sdslen dict 
cnt low part 	raw incr 
frequency high 	count dict 
maximum precision scale 	val zunion 
factor fits 	inter 
within bit won 	aggregate zui 
overflow multiplied 	clear iterator 
cnt low part 	dict iterator 
qpf worked 	dict expand 
initialization expect qpc 	dict size 
work well 	dict 
returns nanoseconds since 	next dict 
epoch performance 	key dict 
tracing favoring 	val zsl 
high precision wall 	insert incr 
clock time 	count dict 
accuracy initialization succeeded 	incr 
offset high 	count dict 
res time initialization 	release iterator 
failed fall 	dict release 
back gettimeofday initialize 	server panic 
offset high 	signal modified 
resolution timer works 	key 
trace.h key 	zset convert 
prefix key key 	ziplist needed 
argv key 	reply zset 
buf len format 	length signal 
key format 	modified key 
argv format key 	notify 
data nanos 	keyspace decr 
format start format 	count reply 
file line 	notify keyspace 
key format 	zfree zunion 
file line argv 	inter command 
format file 	zunion 
line key data 	inter command 
file line 	reply reply 
nanos fmt prints 	strcasecmp reply 
elapsed time 	lookup key 
nanoseconds git trace 	read reply 
performance enabled 	check 
prints elapsed time 	type zset 
since start 	length reply 
git trace performance 	reply multi 
enabled macros 	bulk len 
file line see 	ziplist index 
style declarations 	ziplist 
used trace context 	index server 
may function 	info ziplist 
compiler supports 	next server 
file consistent function 	info server 
names necessarily 	info ziplist 
unique file function 	reply 
doesn work 	bulk reply 
gnuc file supplied 	bulk buffer 
preprocessor function 	reply zzl 
filled compiler constant 	score zzl 
note variadic 	prev zzl 
macros args must 	next 
include last 	zsl element 
parameter format otherwise 	rank zsl 
call without 	element rank 
variable arguments surplus 	server info 
define foo 	reply bulk 
format bar format 	reply 
args foo 	server panic 
test expand bar 	zrange command 
test invalid 	zrange command 
note gnuc 	zsl parse 
args drops comma 	range reply 
non standard 	error 
backend functions use 	strcasecmp strcasecmp 
non macros 	reply reply 
instead variadic macros 	reply lookup 
trace trailer.c 	key read 
name key command 	reply check 
conf info 	type 
previous next token 	zzl last 
conf first 	range zzl 
conf item separators 	first range 
end token 	reply server 
len len len 	info ziplist 
min len 	next 
str ptr item 	deferred multi 
outfile tok 	bulk length 
val outfile first 	zzl prev 
trim empty 	zzl next 
item last 	zzl score 
first tok arg 	zsl 
tok first 	gte min 
last tok arg 	zsl lte 
tok check 	max server 
item first last 	info ziplist 
next previous 	reply bulk 
first item command 	reply 
arg cmd 	bulk buffer 
buf argv result 	reply zzl 
tok arg 	prev zzl 
tok arg tok 	next zsl 
arg tok 	last range 
tok tok first 	zsl 
tok last 	first range 
tok first tok 	reply deferred 
last arg 	multi bulk 
tok tok tok 	length zsl 
first tok 	gte min 
last arg 	zsl 
tok tok tok 	lte max 
following tok 	reply bulk 
middle backwards start 	reply server 
tok tok 	panic deferred 
first tok last 	multi bulk 
arg tok 	length 
first arg tok 	zrangebyscore command 
next arg 	zrangebyscore command 
applied item item 	zsl parse 
item dst 	range reply 
src name item 	error lookup 
previous name 	key 
conf key trailer 	read reply 
item variable 	check type 
name conf key 	zzl first 
trailer item 	range reply 
variable name 	ziplist next 
item conf name 	zzl 
tok val 	score server 
trailer len seps 	info zsl 
item tok 	lte max 
conf item tok 	zzl score 
val tok 	zsl lte 
item tok len 	max 
tok val 	zzl next 
item tok len 	zsl first 
first last 	range zsl 
trailers arg tok 	rank zsl 
first arg 	last range 
tok last item 	zsl 
file lines 	rank server 
lines count lines 	panic reply 
count start 	zsl parse 
end title spaces 	lex range 
lines patch 	reply error 
start ignore 	lookup 
bytes lines start 	key read 
outfile lines 	reply check 
start end outfile 	type zsl 
lines tok 	free lex 
first tok last 	range zzl 
count patch 	first 
start trailer start 	lex range 
trailer end 	zsl free 
first item trailers 	lex range 
tempfile file 	reply ziplist 
tail outfile file 	next server 
place trim 	info 
empty trailers tok 	zzl lex 
first tok 	lte max 
last arg tok 	zzl lex 
first lines 	lte max 
trailer end outfile 	zzl next 
isalnum token 	zsl 
len without 	first lex 
separator strlen token 	range zsl 
len without 	rank zsl 
separator strlen strncasecmp 	last lex 
strcasecmp token 	range zsl 
isspace strstr strbuf 	rank 
splice strlen 	server panic 
strlen free free 	zsl free 
free free 	lex range 
free free strlen 	reply zsl 
isspace last 	parse lex 
non space strchr 	range 
strlen print 	reply error 
tok val end 	strcasecmp reply 
update last 	reply zsl 
update first trailer 	free lex 
end strbuf 	range reply 
addstr strbuf replace 	lookup 
capture command 	key read 
error strbuf 	reply check 
release xstrdup strbuf 	type zsl 
trim strbuf 	free lex 
detach strbuf release 	range zzl 
xstrdup xstrdup 	last 
apply command free 	lex range 
free trailer 	zzl first 
item apply item 	lex range 
command arg 	reply zsl 
input list list 	free 
free trailer 	lex range 
item apply item 	server info 
command arg 	ziplist next 
input list apply 	deferred multi 
item command 	bulk length 
check different arg 	zzl 
input list 	prev zzl 
free trailer item 	next zzl 
apply item 	lex gte 
command check 	min zzl 
different arg input 	lex lte 
list free 	max 
trailer item free 	server info 
trailer item 	ziplist reply 
end apply item 	bulk reply 
command arg 	bulk buffer 
input list end 	zzl prev 
token apply 	zzl 
arg exists list 	next zsl 
find apply 	last lex 
arg apply arg 	range zsl 
missing strcasecmp 	first lex 
strcasecmp strcasecmp strcasecmp 	range reply 
strcasecmp strcasecmp 	zsl 
strcasecmp strcasecmp strcasecmp 	free lex 
strcasecmp strcasecmp 	range deferred 
xstrdup xstrdup 	multi bulk 
xstrdup strcasecmp xcalloc 	length zsl 
duplicate conf 	lex gte 
xstrdup skip prefix 	min 
strrchr strcmp 	zsl lex 
warning strcmp exists 	lte max 
warning strcmp 	reply bulk 
missing warning strcmp 	server panic 
xstrdup skip 	zsl free 
prefix strrchr size 	lex 
strcmp xstrndup 	range deferred 
conf item free 	multi bulk 
warning xstrdup 	length zrangebylex 
warning xstrdup warning 	command zrangebylex 
exists warning 	command lookup 
missing warning die 	key 
strbuf addstr 	read reply 
strbuf addch strcspn 	check type 
strbuf release 	reply zset 
strlen isspace 	length lookup 
error strlen strbuf 	key read 
strbuf trim 	reply 
strbuf addstr strbuf 	check type 
trim strbuf 	zset score 
addstr strbuf trim 	reply reply 
xcalloc xstrdup 	lookup key 
duplicate conf xstrdup 	read reply 
token item 	check 
free duplicate conf 	type zset 
strncasecmp strncasecmp 	length server 
parse trailer token 	info sds 
len without 	encoded ziplist 
separator token matches 	index server 
item trailer 	info 
item strbuf detach 	ziplist next 
strbuf detach 	server info 
trailer item strbuf 	ziplist compare 
detach strbuf 	sdslen zzl 
detach trailer 	next reply 
item trailer item 	reply 
create trailer 	reply dict 
item trailer item 	find dict 
strbuf read 	val zsl 
file die errno 	rank server 
strbuf read 	info reply 
fileno die errno 	reply 
strbuf split 	reply server 
strbuf release starts 	panic zrank 
contains spaces 	command zrank 
contains spaces strcspn 	command parse 
strbuf addbuf 	scan cursor 
ignore non trailer 	reply 
strbuf release 	lookup key 
contains spaces find 	read reply 
patch start 	check type 
find trailer end 	scan command 
find trailer 	copyright salvatore 
start print 	sanfilippo 
lines blank line 	antirez gmail 
create trailer 	dot copyright 
item trailer item 	pieter noordhuis 
first free 	pcnoordhuis gmail 
trailer item stat 	dot rights 
die errno 	reserved 
isreg die die 	redistribution use 
strrchr strbuf 	source binary 
strbuf addstr xmks 	forms without 
tempfile strbuf 	modification permitted 
release fdopen tempfile 	provided following 
die errno 	conditions 
git config git 	met redistributions 
config read 	source code 
input file create 	must retain 
place tempfile 	copyright notice 
process input 	list conditions 
file process command 	following 
line args 	disclaimer redistributions 
process trailers lists 	binary form 
print free 	must reproduce 
print lines rename 	copyright notice 
tempfile die 	list conditions 
errno strbuf list 	following 
free copyright 	disclaimer documentation 
christian couder chriscool 	materials provided 
tuxfamily length 	distribution neither 
including punctuation input 	name redis 
would stripping 	names contributors 
trailing punctuation retaining 	may 
punctuation want 	used endorse 
trailer another one 	promote products 
check one 	derived software 
look item name 	without specific 
item already 	prior written 
exists create 	permission 
lookup token matches 	software provided 
something config 	copyright holders 
trailer item configured 	contributors express 
trailer command 	implied warranties 
trailer item trailer 	including limited 
command line 	implied 
index start patch 	warranties merchantability 
line count 	fitness particular 
patch message start 	purpose disclaimed 
patch part 	shall copyright 
index first trailer 	owner contributors 
line count 	liable 
trailers trailers searched 	direct indirect 
lines index 	incidental special 
count index first 	exemplary consequential 
paragraph title 	damages including 
cannot trailers start 	limited procurement 
trailers looking 	substitute 
starting end 	goods services 
line spaces lines 	loss use 
one separator 	data profits 
index end trailers 	business interruption 
line count 	however caused 
print lines trailers 	theory 
parse trailer 	liability whether 
lines create temporary 	contract strict 
file directory 	liability tort 
original config must 	including negligence 
setup first 	otherwise arising 
print lines trailers 	way 
print lines 	use software 
trailers trailer.h file 	even advised 
place trim 	possibility damage 
empty trailers trailer 	sorted api 
transport-helper.c debug 	zse ordered 
name helper export 	sets 
marks marks 	two data 
refspecs refspec 	structures hold 
transport options helper 	elements order 
buffer helper 	log insert 
buffer name helper 	operations sorted 
buffer str 	data 
url colon transport 	structure elements 
data transport 	added hash 
data buf helper 	table mapping 
refspecs refspec 	redis objects 
refspec alloc duped 	scores time 
code capname 	elements 
arg mandatory transport 	added skip 
data res 	list mapping 
unsupported options options 	scores redis 
transport name 	objects objects 
data buf ret 	sorted scores 
buf transport 	view 
res data 	skiplist implementation 
transport heads fetch 	almost translation 
data buf 	original algorithm 
posn name transport 	described william 
fastimport helper 	pugh skip 
data cat blob 	lists 
code transport 	probabilistic alternative 
fastexport revlist args 	balanced trees 
data helper 	modified three 
transport heads fetch 	ways implementation 
fastimport data 	allows repeated 
posn buf name 	scores 
transport name 	comparison key 
exec data cmdbuf 	score satellite 
helper duped 	data back 
ret input transport 	pointer doubly 
push data 	linked list 
name exec transport 	back 
name exec 	pointers level 
data transport 	allows traverse 
heads fetch data 	list tail 
count buf 	head useful 
remote refs refname 	zrevrange returns 
msg status 	random 
forced msg buf 	level skiplist 
end data 	node going 
remote refs flags 	create function 
buf ret 	zskiplist maxlevel 
transport name flags 	inclusive powerlaw 
transport remote 	alike 
refs flags force 	distribution higher 
mirror data 	levels less 
buf cas options 	likely returned 
cas option 	store rank 
cas transport remote 	crossed reach 
refs flags 	insert 
helper exporter data 	position key 
revlist args 	already inside 
buf oid 	since allow 
name flag transport 	duplicated scores 
remote refs 	insertion score 
flags data attrs 	redis 
attr len 	never happen 
space transport push 	since caller 
data helper 	zsl insert 
ret tail posn 	test hash 
buf eov 	table element 
eon transport name 	already 
data fmt 	inside update 
args msgbuf debug 	span covered 
enabled src 	update inserted 
dest src sock 	increment span 
dest sock 	untouched levels 
state buf bufuse 	function 
src name 	used zsl 
dest name bytes 	zsl score 
bytes ptg 	zsl rank 
gtp udt 	element matching 
name err tret 	score skiplist 
gtp ptg 	may 
err ret pid 	multiple elements 
name tret 	score need 
pid pid ret 	find element 
input output 	right score 
state write full 	found returns 
die errno 	part 
strbuf reset strbuf 	zset range 
getline recvline 	test ranges 
write full strlen 	always empty 
strlen die 	find first 
errno strchr transport 	node contained 
take fclose 	specified 
free xmalloc child 	range returns 
process init 	element contained 
argv pushf argv 	range everything 
push argv 	range early 
push ext 	forward range 
force argv pushf 	inner 
git dir 	range next 
start command die 	node cannot 
exit dup 	check score 
die errno xfdopen 	max find 
write constant 	last node 
recvline exit strcmp 	contained 
strcmp strcmp 	specified range 
strcmp strcmp strcmp 	returns element 
strcmp skip 	contained range 
prefix alloc grow 	everything range 
xstrdup strcmp 	early forward 
strcmp skip prefix 	range 
xstrdup skip 	inner range 
prefix xstrdup starts 	node cannot 
die parse 	check score 
fetch refspec 	min elements 
free free warning 	score min 
strbuf release 	max 
standard options sigchain 	skiplist min 
push xwrite 	max inclusive 
sigchain pop close 	score min 
close fclose 	score max 
finish command free 	deleted note 
helper size 	function 
strcmp size strcmp 	takes reference 
strbuf addf 	hash table 
strbuf addstr quote 	view sorted 
style strbuf 	order elements 
addch sendline recvline 	hash table 
exit strcmp 	current 
starts strcmp warning 	node last 
strbuf release 	score min 
helper option snprintf 	nodes range 
die helper 	current node 
option helper 	last score 
option helper option 	min 
free refspec 	nodes range 
disconnect helper free 	elements rank 
strbuf addf 	start end 
oid hex strbuf 	skiplist start 
addch sendline 	end inclusive 
recvline exit starts 	note 
warning xstrdup 	start end 
strcmp warning strbuf 	need find 
release helper 	rank element 
child process init 	score key 
argv push 	returns element 
argv push xdup 	cannot 
argv pushf 	found rank 
start command helper 	otherwise note 
child process 	rank due 
init dup argv 	span zsl 
push argv 	header first 
push argv 	element 
push argv pushf 	might equal 
argv pushf 	zsl header 
argv push start 	test obj 
command helper 	non finds 
importer die strbuf 	element rank 
addf sendline 	rank 
strbuf reset write 	argument needs 
constant finish 	populate rangespec 
command die apply 	according objects 
refspecs xstrdup 	min max 
read die free 	parse min 
strbuf release 	max 
helper dup die 	interval one 
errno xfdopen 	values prefixed 
setvbuf strcmp helper 	character considered 
option warning 	open instance 
warning strbuf addf 	zrangebyscore zset 
sendline recvline 	match 
exit strcmp 	min max 
strcmp die fclose 	zrangebyscore zset 
process connect 	instead match 
service helper die 	min max 
process connect 	lexicographic ranges 
service die process 	parse 
connect take 	max min 
fetch helper option 	argument zrangebylex 
helper option 	foo means 
helper option fetch 	foo open 
fetch fetch 	interval foo 
starts starts die 	means 
strchr unquote 	foo closed 
style strbuf detach 	interval means 
xstrdup strbuf 	min possible 
release strcmp free 	means max 
strcmp free 	possible valid 
strcmp free 	dest 
strcmp free strcmp 	pointer redis 
free strcmp 	used comparision 
free strcmp free 	respectively item 
strcmp free 	exclusive inclusive 
find name find 	returned valid 
name warning 	range 
recvline push update 	err returned 
status apply 	dest undefined 
refspecs update free 	populate rangespec 
strbuf release 	according objects 
helper option die 	min max 
helper option 	success 
die helper option 	error err 
die helper 	returned returned 
strbuf addstr strbuf 	structure must 
addch strbuf 	freed zsl 
addstr strbuf addstr 	free lex 
oid hex 	range 
strbuf addch 	otherwise release 
strbuf addstr strbuf 	needed range 
addch strbuf 	valid objects 
addf oid hex 	integer encoded 
list append 	every item 
strbuf detach list 	must 
clear helper 	start free 
option common push 	lex range 
options strbuf 	structure must 
addch sendline strbuf 	called zel 
release push 	parse lex 
update refs status 	range 
die common 	populated structure 
push options helper 	success returned 
option warning 	wrapper compare 
helper write constant 	objects able 
apply refspecs 	handle shared 
sha strbuf addf 	minstring 
list append 	shared maxstring 
strbuf detach 	equivalent inf 
oidcpy free strcmp 	inf makes 
resolve strbuf 	sure handle 
addf strbuf addf 	inf inf 
list append 	inf 
list append strbuf 	inf asap 
release list 	one special 
append exporter die 	less returns 
list clear 	part zset 
finish command die 	lex range 
push update 	test 
refs status strbuf 	ranges always 
addf rename 	empty find 
strbuf release process 	first node 
connect take 	contained specified 
push refs push 	lex range 
refs push 	returns 
push refs export 	element contained 
strlen strchrnul 	range everything 
strncmp helper 	range early 
process connect take 	forward range 
refs list 	inner range 
write str full 	next 
write str 	node cannot 
full recvline exit 	check score 
strchr die 	max find 
strchr alloc xstrdup 	last node 
oid hex 	contained specified 
attribute read die 	range 
strbuf release 	returns element 
resolve remote symref 	contained range 
xcalloc transport 	everything range 
check allowed getenv 	early forward 
getenv start 	range inner 
vsnprintf end state 	range 
needs closing 	node cannot 
shutdown close 	check score 
transfer debug transfer 	min ziplist 
debug read 	backed sorted 
error strerror transfer 	api ziplist 
debug transfer 	element 
debug transfer debug 	redis simple 
xwrite error 	abstraction used 
strerror memmove transfer 	simplifies code 
debug state 	cost performance 
needs reading udt 	compare element 
read state 	sorted 
needs writing udt 	given element 
write state 	store representation 
needs closing udt 	buf move 
close finished 	next entry 
pthread error error 	values eptr 
strerror pthread 	sptr 
create die strerror 	next entry 
pthread create 	next entry 
die strerror 	move previous 
tloop tloop close 	entry values 
shutdown close 	eptr 
waitpid error strerror 	sptr next 
wifexited wexitstatus 	entry previous 
error fork die 	entry returns 
errno udt 	part zset 
kill transfer exit 	range used 
udt copy 	internally 
task routine fork 	zzl first 
die errno 	range zzl 
udt kill transfer 	last range 
exit udt 	test ranges 
copy task routine 	always empty 
udt kill 	last 
transfer udt kill 	score empty 
transfer tloop 	sorted first 
tloop tloop spawnwait 	score find 
tasks remote 	pointer first 
name list 	element contained 
name transport options 	specified 
fetch pack 	range returns 
send pack one 	element contained 
invoked open 	range everything 
output file strbuf 	range early 
getline family 	check score 
functions used duped 	max 
fclose close 	move next 
stuff like taking 	element find 
require remain 	pointer last 
ignore write errors 	element contained 
nothing since 	specified range 
close pipe anyway 	returns 
likely error 	element contained 
epipe due helper 	range everything 
dying report 	range early 
error already old 	check score 
remote helpers 	min move 
setting need 	previous 
duplicate helper want 	element moving 
use fastexport 	score previous 
done remote helpers 	element returns 
advertise bidi 	know also 
capability required buffer 	element returns 
complete batch 	part 
commands newline sending 	zset range 
data fast 	used internally 
helpers read back 	zzl first 
data fast 	range zzl 
stdin could mixed 	last range 
commands otherwise 	test 
fast stream remote 	ranges always 
helper advertises 	empty last 
refspec capability writes 	element first 
refs named 	element find 
right hand side 	pointer first 
first refspec 	element 
matching fetching 	contained specified 
refspec capability specified 	lex range 
historical reasons 	returns element 
equivalent store result 	contained range 
fetch old 	everything range 
sha callers git 	early 
fetch use 	check score 
write feedback terminal 	max move 
populate fetch 	next element 
head determine written 	element score 
peer update 	skip next 
fast forward forced 	element 
update yes 	find pointer 
dup pipe another 	last element 
time need 	contained specified 
unbuffered version input 	lex range 
pipe file 	returns element 
fclose closes 	contained 
underlying stream buffering 	range everything 
changed first 	range early 
operation handle upload 	check score 
pack friends 	min move 
fire forget warn 	previous element 
fails helper 	moving 
connect inited earlier 	score previous 
marked pushed 	element returns 
ignore status reported 	know also 
remote helper 	element matching 
latter match propagate 	element pull 
back update 	score 
remote check statuses 	move next 
status push 	element element 
nothing force lease 	score pair 
options without 	ziplist use 
values expect already 	local copy 
expanded old 	eptr 
oid expect 	want modify 
field ignore transport 	one given 
smart options 	argument todo 
cas altogether instead 	function ziplist 
enumerate refs 	api elements 
follow symbolic refs 	offset 
mainly head 	keep offset 
linux pipes buffer 	relative might 
bytes platforms 	allocated insert 
buffer less attempt 	score element 
reads writes 	insert element 
size enough hold 	score 
debugging message 	pair ziplist 
print bidirectional transfer 	function assumes 
loop debug 	element yet 
message stream state 	present list 
data may 	first element 
coming direction stream 	score 
state data 	larger score 
coming direction 	element inserted 
flushing rest data 	means take 
stream state 	spot list 
transfer direction finished 	maintain ordering 
unidirectional transfer 	ensure 
source destination source 	lexicographical ordering 
socket destination 	elements move 
socket transfer state 	next element 
transferring flushing 	push tail 
finished buffer buffer 	list yet 
used name 	inserted 
source name destination 	tail ziplist 
closes target 	deleted eptr 
writing transfer finished 	point sentinel 
tries read 	ziplist next 
read data source 	element score 
buffer buffer 	longer 
full data read 	range tail 
returns success 	ziplist deleted 
error space 	eptr point 
tries write data 	sentinel ziplist 
buffer destination 	next element 
buffer empty data 	score 
written returns 	longer range 
success error nothing 	elements rank 
write state 	start end 
bidirectional transfer loop 	skiplist start 
direction program 	end inclusive 
git direction git 	note 
program non 	start end 
appropriate errors failure 	need common 
name name 	sorted api 
error messages returns 	incremented refcount 
success failure 	since created 
spawn transfer tasks 	added 
wait returns 	dictionary approach 
success failure 	similar zsl 
close source target 	free since 
writing transfer 	want free 
socket read end 	skiplist time 
left open 	creating 
isn disaster nobody 	ziplist convert 
attempts read 	sorted ziplist 
mingw compat headers 	already ziplist 
shut fully 	number elements 
close socket since 	maximum element 
otherwise gtp 	size 
task would first 	within expected 
close socket 	ranges reference 
sends data closing 	score specified 
ptg file 	member sorted 
descriptors process appropriate 	storing score 
errors failure 	element 
name name process 	exist err 
error messages 	returned otherwise 
returns success 	returned score 
failure spawn transfer 	correctly populated 
tasks wait 	zobj member 
returns success failure 	err 
fork git 	returned sorted 
program fork program 	commands command 
git close 	zadd zincrby 
streams parent interfere 	increment score 
end file 	instead setting 
detection wait tasks 	touch 
finish copies 	elements already 
data stdin output 	existing touch 
input stdout 	elements already 
simultaneously additionally filtering 	exisitng num 
given filter 	elements added 
filter uses identity 	updated 
filter fill 	following vars 
state fields transport.c 	used order 
transport refs 	track command 
pretend localname 	actually execution 
tmp remotename sha 	reply client 
flag header 	trigger 
transport push data 	notification keyspace 
result transport 	change number 
heads fetch data 	elements added 
transport data 	number elements 
options conn extra 	updated score 
shallow opts 	number 
name end transport 	elements processed 
push data 	may remain 
flags transport push 	zero options 
data refs 	like parse 
transport heads fetch 	options end 
data refs 	scoreidx 
dest args refs 	argument position 
tmp remote 	score first 
verbose flag summary 	score element 
msg porcelain 	pair turn 
sha porcelain 	options simple 
quickref type msg 	check 
dest count 	vars options 
porcelain dest refs 	expect even 
verbose porcelain 	number args 
reject reasons head 	since expect 
sha head 	number score 
heads heads local 	element 
remote transport 	pairs holds 
remote refs flags 	number score 
data args 	element pairs 
ret tmp refs 	check incompatible 
transport name 	options start 
executable data transport 	parsing 
data transport 	scores need 
child data url 	emit syntax 
buf url 	error executing 
enabled allowed 	additions sorted 
type allowed type 	command either 
remote url 	execute 
helper ret data 	fully nothing 
data len 	lookup key 
handler transport name 	create sorted 
protocol reports 	exist key 
transport verbosity force 	option nothing 
progress needs 	prefer 
pushing transport remote 	non encoded 
refs proc 	element dealing 
buf argv transport 	ziplists insert 
refspec refspec 	score changed 
flags reject reasons 	optimize check 
remote refs 	element 
local refs match 	large list 
flags verbose 	becomes executing 
quiet porcelain pretend 	zzl insert 
push ret 	need check 
ret err 	sorted empty 
needs pushing transport 	know 
transport refs 	least one 
refs heads transport 	element insert 
transport name 	score changed 
exec transport ret 	safely key 
url scheme 	skiplist since 
prefix anon part 	dictionary 
anon len 	still reference 
prefix len data 	inserted skiplist 
data len 	update score 
remote transport extra 	ptr inserted 
data oid 	skiplist added 
resolve starts starts 	dictionary 
starts install 	zincrby incr 
branch config close 	option zadd 
read bundle 	skiplist hash 
header die alloc 	table zremrangebyrank 
hashcpy unbundle 	zremrangebyscore zremrangebylex 
close free 	commands 
strcmp strcmp strcmp 	step parse 
strcmp strcmp 	range step 
strcmp strcmp strtol 	lookup range 
die git 	sanity checks 
connect connect setup 	needed sanitize 
remote heads 	indexes 
xstrdup memset connect 	invariant start 
setup remote 	test end 
heads fetch pack 	range empty 
close close 	start end 
finish connect free 	start length 
refs free 	step 
refs free refs 	perform range 
free remote 	deletion operation 
find tracking update 	step notifications 
free prettify 	reply sorted 
refname prettify refname 	iterators sorted 
fputs prettify 	iterators 
refname fputs 	use dirty 
fputs fputc fputc 	flags pointers 
find unique 	need cleaned 
abbrev print status 	next iteration 
oid print 	zsetopval dirty 
status starts strbuf 	flag 
addstr status 	special since 
abbrev strbuf addstr 	values need 
strbuf addstr 	cleanup instead 
strbuf addstr status 	means already 
abbrev print 	ell holds 
status strbuf release 	tried 
print status 	convert another 
print status print 	representation successful 
status print 	opval valid 
status print status 	well store 
print status 	retrieved iterator 
print status print 	buffer 
status print 	skip skip 
status print 	skip check 
status print status 	current valid 
print status 	store passed 
print status resolve 	structure move 
refdup print 	next 
one push status 	element valid 
print one 	means reached 
push status print 	end structure 
one push 	abort move 
status strcmp free 	next element 
strrchr check 	move 
refname format die 	next element 
connect setup 	need check 
remote heads memset 	better move 
send pack 	next element 
close close finish 	move next 
connect git 	element 
connect packet 	already flag 
flush close close 	valid find 
finish connect 	pointed val 
free die xcalloc 	source pointer 
stat isreg 	found store 
strchr getenv list 	score 
split list 	target otherwise 
sort protocol whitelist 	score already 
list transport 	zzl find 
allowed die protocol 	result adding 
whitelist xcalloc 	two doubles 
isatty die urlschemechar 	one 
starts xstrndup 	variable inf 
transport helper init 	inf numbers 
starts die 	added maintain 
url local ssh 	convention result 
file bundle 	safety net 
xcalloc transport check 	expect 
allowed url 	setnum input 
starts starts 	keys given 
starts starts starts 	test expected 
xcalloc external 	number keys 
specification len xmemdupz 	would overflow 
transport helper 	read 
init git option 	keys used 
option isatty 	input weights 
list clear die 	parse optional 
find hook 	extra arguments 
start command finish 	sort sets 
command sigchain 	smallest 
push strbuf init 	largest improve 
strbuf reset 	algorithm performance 
strbuf addf oid 	skip everything 
hex oid 	smallest input 
hex write full 	empty precondition 
strbuf release 	src 
close sigchain pop 	non empty 
finish command 	inputs ordered 
transport verify 	size src 
remote names die 	non empty 
push local 	safe access 
heads check push 	zset 
refs refs 	iterating explicitly 
list match push 	check equal 
refs empty 	present every 
cas apply push 	input added 
cas status 	skiplist added 
push run pre 	dictionary 
push hook 	least large 
bare repository oid 	largest resize 
push unpushed 	dictionary asap 
submodules die bare 	avoid useless 
repository oid 	rehashing step 
find unpushed submodules 	create 
die unpushed 	dictionary elements 
submodules push refs 	aggregated scores 
push errors 	iterating one 
transport print 	sorted initialize 
push status upstreams 	search element 
transport update 	accumulating 
tracking puts transport 	dictionary need 
refs pushed 	create entry 
refs list oid 	remember longest 
oidcmp alloc 	single element 
grow alloc fetch 	encountered understand 
free unlink 	possible 
warn free connect 	convert ziplist 
die disconnect 	end element 
free strchr url 	initial score 
local ssh 	update score 
strlen strstr strchr 	score instance 
isalnum strchr 	element 
xstrfmt xstrdup xstrdup 	found current 
real path 	sorted access 
strlen memcmp 	directly dict 
memcpy directory remote 	entry inside 
transport transport 	big speedup 
remote refs transport 	compared 
disconnect free 	api step 
alt odb check 	convert dictionary 
suitability tracking 	sorted aware 
must successful already 	size resulting 
date create 	sorted resize 
modify follow symbolic 	dictionary 
refs mainly 	embedded inside 
head source destination 	sorted right 
must local 	size order 
branches matching refspec 	save rehashing 
okay maybe 	time added 
foreign url deprecated 	skiplist 
use deprecated 	added dictionary 
use builtin smart 	free accumulator 
transports allowed 	dictionary sanitize 
transports individually 	indexes invariant 
git connect unknown 	start test 
protocol url 	end 
pass external handler 	range empty 
either report 	start end 
report success either 	start length 
reports invalid 	result form 
report otherwise report 	multi bulk 
unknown report 	reply 
unknown rules used 	check starting 
determine whether 	point trivial 
report progress processing 	log lookup 
aborts rule 	command zrangebyscore 
satisfied report progress 	zrevrangebyscore parse 
force progress 	range 
progress report progress 	arguments range 
force progress 	given max 
progress report progress 	min range 
verbosity quiet 	given min 
report progress 	max parse 
isatty mind hook 	optional 
read refs 	extra arguments 
maybe fixme important 	note zcount 
transport uses 	exactly arguments 
deepening shallow repository 	never enter 
requested local 	following 
remote refs likely 	code path 
still equal 	lookup key 
feed fetch method 	range reversed 
condition shouldn 	last node 
met non deepening 	range starting 
fetch see 	point 
builtin fetch quickfetch 	first element 
strip username 	specified interval 
password url newly 	score pointer 
allocated cannot 	first element 
path name make 	know advance 
sure scheme 	many 
reasonable rfc 	matching elements 
isn past first 	list push 
slash count 	represent multi 
git repository refs 	bulk length 
transport.h depth 	output buffer 
uploadpack receivepack cas 	fix 
remote url 	later offset 
data remote refs 	traverse number 
connection name 	elements without 
transport push transport 	checking score 
refs refs 	done next 
transport refs flags 	loop 
connection refspec 	abort node 
refspec flags connection 	longer range 
name executable 	know element 
connection pack lockfile 	exists ziplist 
smart options 	always succeed 
remote type 	move 
type transport name 	next node 
transport verbosity 	reversed last 
force progress connection 	node range 
refspec refspec 	starting point 
flags reject reasons 	first element 
transport transport 	specified 
refs transport transport 	interval know 
url transport 	advance many 
child transport name 	matching elements 
exec transport 	list push 
name input output 	represent multi 
heads heads 	bulk 
remote verbose dest 	length output 
refs verbose 	buffer fix 
porcelain reject reasons 	later offset 
indicates whether 	traverse number 
already called refs 	elements without 
list transport 	checking 
transport remote 	score done 
refs transports call 	next loop 
take destroys 	abort node 
data specific transport 	longer range 
type cannot 	move next 
reused hint caller 	node 
performing clone 	parse range 
normal fetch iow 	arguments lookup 
repository guaranteed 	sorted use 
empty returns successful 	first element 
positive option 	range starting 
recognized inapplicable negative 	point 
option applicable 	first element 
invalid returns list 	first element 
remote side 	range iterate 
refs order allow 	elements range 
transport share 	abort node 
connections push hint 	longer 
whether ultimate 	range find 
operation push 	first element 
fetch transport able 	range use 
determine remote 	rank first 
hash without huge 	element determine 
amount effort 	preliminary 
store old sha 	count find 
field otherwise 	last element 
fetch objects given 	range use 
refs note 	rank last 
gets ignore list 	element determine 
structure transport 	actual 
hashes refs refs 	count parse 
list old 	range arguments 
sha fields provided 	lookup sorted 
refs push 	use first 
objects refs send 	element range 
necessary objects 	starting 
refs peer peer 	point first 
oid different 	element first 
old oid 	element range 
tell remote side 	iterate elements 
update list 	range abort 
old oid peer 	node 
oid possible 	longer range 
status appropriately transport 	find first 
must modify 	element range 
sha remote accepted 	use rank 
change note 	first element 
could different peer 	determine 
oid process 	preliminary count 
involved generating commits 	find last 
refs list 	element range 
fetch push refs 	use rank 
keep resources 	last element 
connection reserved use 	determine 
disconnect releases 	actual count 
resources transports directly 	command zrangebylex 
use without 	zrevrangebylex parse 
check isatty 	range arguments 
quiet transport verbose 	range given 
etc checking 	max 
already done transport 	min range 
verbosity transport 	given min 
least potentially smart 	max parse 
points git 	optional extra 
transport options structure 	arguments note 
use transport 	zcount 
actually turns smart 	exactly arguments 
returns transport 	never enter 
suitable url check 	following code 
whether transport 	path lookup 
allowed environment type 	key range 
generally url 	reversed 
scheme described documentation 	last node 
git txt 	range starting 
check whether 	point first 
transport allowed environment 	element specified 
die otherwise 	interval score 
returns user attempted 	pointer 
turn protocol 	first element 
restrictions transport options 	know advance 
apply git 	many matching 
scp style program 	elements list 
use remote 	push represent 
side send pack 	multi 
program use 	bulk length 
remote side receive 	output buffer 
pack transfer 	fix later 
data thin pack 	offset traverse 
check current 	number elements 
remote keep pack 	without 
transferred limit 	checking score 
depth fetch aggressively 	done next 
fetch annotated 	loop abort 
tags possible 	node longer 
accept refs may 	range know 
update git 	element 
shallow without depth 	exists ziplist 
send push 	always succeed 
certificates returns option 	move next 
used non 	node reversed 
zero otherwise prints 	last node 
message stderr 	range 
option used transport 	starting point 
methods defined 	first element 
outside transport common 	specified interval 
methods used 	know advance 
transport builtin send 	many matching 
pack tree-diff.c 	elements 
sha parents sha 	list push 
nparent opt 	represent multi 
old opt cmp 	bulk length 
opt sha 	output buffer 
mode addremove 	fix later 
last nparent path 	offset 
pathlen mode 	traverse number 
sha len alloclen 	elements without 
opt nparent 	checking score 
imin mode path 	done next 
sha pathlen 	loop abort 
old baselen isdir 	node 
emitthis keep 	longer range 
pprev tpi valid 	move next 
sha mode 	node existing 
parents sha tpi 	elements always 
valid opt 	rank util.c 
nparent sha parents 	cbopaque 
sha nparent 	uppercase slen 
opt ttree tptree 	sign slen 
imin cmp 	alt form 
done sha parents 	slen alt 
sha nparent 	form uppercase 
opt old 	slen 
opt diff opts 	cbopaque result 
choice path 	result err 
old opt phead 	buf buflen 
pathchange old 	nptr endptr 
pprev old str 	ret digit 
opt retval 	neg 
opt name compare 	pret uppercase 
entry len 	slen digits 
entry len change 	digits sign 
combine diff 	slen neg 
path size free 	alt form 
xmalloc memcpy 	slen 
memcpy hashcpy entry 	alt form 
extract entry 	uppercase slen 
len isdir entry 	str size 
extract entry 	format ret 
len isdir 	alt form 
diff opt tst 	left 
diff opt 	justify plus 
tst path appendnew 	space plus 
hashcpy pathchange 	plus prec 
xalloca strbuf strbuf 	width len 
addch diff 	uwidth uprec 
paths xalloca free 	slen 
strbuf setlen 	jemalloc silence 
entry interesting update 	init buf 
entry update 	jemalloc silence 
entry xalloca xalloca 	init buf 
fill descriptor 	jemalloc silence 
fill descriptor diff 	init 
opt tst 	buf jemalloc 
diff quit early 	silence init 
skip uninteresting 	buf val 
skip uninteresting entry 	buf val 
pathcmp entry 	buf str 
pathcmp diff 	size 
opt tst hashcmp 	format ret 
emit path 	write cbopaque 
update entry update 	format buf 
entries emit 	write cbopaque 
path update entry 	format format 
diff opt 	syscall 
tst emit path 	strlen write 
update entries 	strlen malloc 
free free xalloca 	message wrtmessage 
free xalloca 	format message 
free diff paths 	strerror strncpy 
free diff 	strerror 
file valid guard 	errno errno 
pathspec diff 	errno reached 
setup diff opt 	memcpy arg 
diff opt 	errno malloc 
diff setup done 	strtoumax errno 
diff sha 	arg 
diffcore std 	errno malloc 
free pathspec strcmp 	strtoumax errno 
free pathspec 	append arg 
parse pathspec diff 	numeric append 
free filepair 	padded arg 
diff paths free 	numeric 
strbuf init 	append padded 
strbuf addstr diff 	arg numeric 
sha diff 	append padded 
opt tst diff 	arg numeric 
might rename 	append padded 
follow renames strbuf 	implemented 
release diff 	arg append 
sha helper functions 	padded implemented 
diff generation 	arg strlen 
mode marker saying 	append padded 
entry entry 	arg numeric 
imin see diff 	append 
paths means 	padded reached 
update use 	append start 
emit entry diff 	malloc vsnprintf 
unset compare 	end malloc 
two entries taking 	vsnprintf write 
account path 	start 
isdir mode sha 	malloc vcprintf 
note files 	end start 
directories always compare 	malloc vcprintf 
differently even 	end function 
name thanks name 	prototypes non 
compare note 	functions 
empty invalid descriptor 	malloc message 
take part 	setup use 
comparison infty sort 	syscall rather 
valid entries 	write possible 
due convention trees 	order avoid 
scanned sorted 	possibility 
order non 	memory allocation 
empty descriptors processed 	within libc 
first empty 	necessary free 
descriptors sort valid 	bsd operating 
entries convert 	systems problem 
path opt diff 	though 
callbacks emits 	wrapper around 
diff first parent 	malloc message 
tells diff 	avoids need 
walker done freed 	malloc message 
done make 	throughout code 
combine diff path 	glibc 
path mode 	provides non 
sha append paths 	standard strerror 
list tail 	gnu source 
memory created elements 	defined provide 
could reused 	wrapper swallow 
last next memory 	leading 
allocated last 	whitespace sign 
next assumed 	fall fall 
last next returned 	prefix note 
earlier function 	first non 
next modified memory 	whitespace sign 
reused clients 	character 
need keep element 	possible tell 
path appendnew 	whether digits 
process next need 	consumed convert 
keep element 	overflow conversion 
processing pprev path 	performed characters 
appendnew process 	converted 
pprev forget free 	fall left 
tail next 	padding right 
end parent remains 	padding synthetic 
uninitialized last 	used flags 
next pre allocated 	width width 
memory reuse 	precision 
next round next 	separator precision 
holds many 	length conversion 
bytes allocated 	specifier caller 
faster realloc need 	provide alternate 
copying old 	write callback 
data path added 	function 
combine diff 	use one 
cases called behaves 	malloc write 
path added 	function use 
parents lack path 	malloc message 
removed parents 	directly print 
path modified added 	callback 
imin otherwise 	function way 
least something valid 	hopefully avoid 
path present 	memory allocation 
resulting path removed 	print stderr 
take path 	way avoid 
imin parent also 	memory 
take mode 	allocation copyright 
parent decide recursion 	salvatore sanfilippo 
modes imin 	antirez gmail 
wrt isdir 	dot rights 
thanks name compare 	reserved redistribution 
valid present 	use 
imin otherwise ignore 	source binary 
path filtered 	forms without 
consumed need list 	modification permitted 
reuse memory 	provided following 
leaving pre allocated 	conditions met 
element tail 	redistributions 
hand path needs 	source code 
kept need 	must retain 
correct next pre 	copyright notice 
initialized much 	list conditions 
memory allocated see 	following disclaimer 
path appendnew 	redistributions 
details rule emitthis 	binary form 
generate paths 	must reproduce 
combined diff sha 	copyright notice 
parents sha 	list conditions 
resulting paths 	following disclaimer 
appended combine diff 	documentation 
path linked 	materials provided 
list also emitted 	distribution neither 
via opt 	name redis 
pathchange callback possible 	names contributors 
process result 	may used 
batch incrementally paths 	endorse 
generated scanning 	promote products 
parents trees simultaneously 	derived software 
similarly diff 	without specific 
trees theory behind 	prior written 
scan follows 	permission software 
calculation scheme regarding 	provided 
resulting paths 	copyright holders 
diff combined diff 	contributors express 
parents start 	implied warranties 
trees sorted 	including limited 
compare entries step 	implied warranties 
imin argmin 	merchantability 
time could cases 	fitness particular 
imin imin 	purpose disclaimed 
imin schematic deduction 	shall copyright 
every means 	owner contributors 
follows imin imin 	liable direct 
imin imin 	indirect 
imin imin imin 	incidental special 
imin imin 	exemplary consequential 
imin remains investigate 	damages including 
imin investigate 	limited procurement 
looking imin imin 	substitute goods 
imin imin 	services 
note usual diff 	loss use 
definition combined 	data profits 
diff diff paths 	business interruption 
generator used 	however caused 
plain diffs 	theory liability 
generation please keep 	whether 
attention common 	contract strict 
working code order 	liability tort 
slow note 	including negligence 
nparent must imin 	otherwise arising 
load parents 	way use 
first probably already 	software 
cached log 	even advised 
diff parses commit 	possibility damage 
parent calling 	glob style 
via diff sha 	pattern matching 
parent commit 	match match 
enable recursion indefinitely 	match 
comparing finished 	match match 
trees done lookup 	fall match 
imin argmin 	match convert 
mark entries whether 	representing amount 
imin along 	memory number 
way fixup 	bytes 
markings entries imin 	instance memtoll 
imin compare 	parsing error 
imin imin either 	err otherwise 
imin diff 	error function 
imin diff imin 	regardless fact 
imin imin 	err 
imin imin imin 	unit multiplier 
imin imin 	search first 
free pre allocated 	non digit 
last element 	character copy 
see path appendnew 	digits buffer 
details look 	use 
like resulting diff 	strtoll convert 
might due 	digit without 
rename single entry 	unit number 
valid previous 	number digits 
file follow rename 	converted radix 
code specific 	see 
need exactly 	information like 
one path magic 	digits values 
matches one 	abs llong 
path supported reject 	min requires 
wildcards well 	special handling 
unfortunately haven got 	minus 
reliable way 	convert returns 
detect foo bar 	number characters 
fact wildcards 	needed represent 
nowildcard len merely 	number buffer 
hint optimization 	big enough 
slip wildmatch taught 	store 
dry run 	returned following 
mode returns wildcard 	article apparently 
info file 	provide novel 
creation entry diff 	approach publicizes 
queue remember 	already 
filepairing see 	used technique 
find interesting one 	https www 
found source 	facebook notes 
use diff queued 	facebook engineering 
diff also 	three optimization 
use path future 	tips 
file pairs 	modified order 
around update path 	handle integers 
use caller 	since original 
expects vanilla filepairs 	code designed 
later call 	integers main 
diffcore std makes 	loop 
sort renames 	works bit 
among things already 	integers simplicity 
found renames 	convert number 
signal diffcore std 	remember negative 
muck rename 	check length 
information discard non 	term 
relevant file 	handle last 
pairs instate 	digits sign 
one want might 	convert returns 
either original 	could parsed 
one rename copy 	non overflowing 
found tree-walk.c 	otherwise 
str modep mode 	parsed appropriate 
desc buf 	special first 
size path mode 	digit abort 
len desc 	negative sign 
buffer size desc 	first digit 
sha size 	otherwise 
buf desc buf 	overflow overflow 
end size 	bytes used 
len desc entry 	overflow overflow 
info pathlen 	convert returns 
dummy path info 	could parsed 
len pathlen 	non 
prev ptr skip 	overflowing otherwise 
len len 	parsed appropriate 
cmp first 	convert representation 
first len path 	returns number 
len probe 	bytes required 
skip skip info 	representation 
still interesting 	always parsable 
info error entry 	strtod see 
interesting traverse 	http wikipedia 
path trees used 	wiki zero 
mask dirmask 	comparisons check 
first first len 	safe 
len size 	range casted 
sha name result 	assuming bit 
mode namelen 	also assuming 
entry sha entrylen 	implementations around 
cmp sha 	precision bit 
name sha mode 	assumptions 
retval size 	test inside 
root parent link 	interval casting 
len len 	safe two 
contents contents 	castings make 
start parent match 	sure part 
entry item 	zero 
match len ret 	use integer 
item match 	printing function 
matchlen item baselen 	much faster 
matched match 	generate redis 
matchlen dirlen item 	run sha 
match str 	sized 
matched entry offset 	random number 
die mode 	identifies given 
die strlen canon 	execution redis 
mode decode 	talking instance 
entry read reference 	run reconnect 
die sha 	run 
hex init desc 	sure either 
memset die 	different instance 
decode entry 	restarted state 
update entry strlen 	sha seed 
memset entry 	dev urandom 
len memcpy entry 	counter 
len name 	hash seed 
compare memcmp entry 	initialize seed 
clear entry 	use sha 
extract update entry 	counter mode 
entry len 	hash seed 
check entry match 	progressive 
entry clear 	counter goals 
entry extract entry 	function need 
len check 	non colliding 
entry match entry 	cryptographic security 
clear update 	needs convert 
entry entry clear 	hex 
update entry 	digits read 
xmalloc free entry 	dev urandom 
interesting xmalloc 	reasonable effort 
xcalloc strbuf 	order create 
grow make traverse 	entropy since 
path strbuf 	function 
setlen xstrndup xstrndup 	used generate 
extended entry 	run cluster 
extract entry len 	instance use 
name compare 	time pid 
extended entry extract 	fill initial 
entry len 	xor 
name compare entry 	rand output 
clear isdir 	already seeded 
prune traversal update 	time startup 
extended entry 	convert hex 
free free extended 	digits given 
entry free 	filename 
free strbuf release 	absolute path 
strlen entry 	sds fails 
extract entry len 	reason note 
update entry 	filename may 
memcmp hashcpy 	absolute path 
isdir hashcpy entry 	already 
read reference 	detected handled 
hashcpy free init 	correctly function 
desc find 	normalize everything 
entry free init 	obvious one 
desc strchr 	appearning start 
strcmp strbuf free 	filename 
init desc 	relative path 
strbuf hashcpy find 	path already 
entry isdir 	absolute path 
hashcpy strbuf isreg 	relative cwd 
hashcpy islnk 	relative path 
read sha file 	point 
strbuf addstr 	current path 
free init desc 	always ending 
strbuf splice 	trimmed relative 
free free free 	path normalize 
strbuf release 	obvious trailing 
strncmp strncmp 	elements 
basecmp basecmp basecmp 	start path 
match dir 	every find 
prefix within depth 	filename also 
isdir basecmp 	last element 
match entry git 	cwd unless 
fnmatch isdir 	current 
match wildcard strbuf 	cwd glue 
git fnmatch 	two parts 
strbuf setlen strbuf 	together specified 
setlen isdir 	path file 
match match isdir 	basename without 
initialize descriptor 	relative 
entry caller wants 	absolute path 
pick nothing 	function checks 
looking name trivially 	character exists 
happy three 	inside specified 
possibilities could hiding 	path enough 
behind sorts 	environments 
earlier matter 	redis runs 
subtree blob otherwise 	may start 
know won 	leading space 
appear without scanning 	trailing space 
common first 	may start 
reading sync trees 	overflow 
comes matter 	overflow may 
len len memcmp 	start may 
len len 	start overflow 
keep looking comes 	overflow pow 
looking keep 	err input 
looking cannot appear 	expected 
extended desc 	remainder expected 
extract first name 	errno expected 
entry paying 	errno name 
attention candidate first 	expected tests 
name importantly 	test err 
looking entry 	result 
entries sorts earlier 	remainder buf 
representation name 	result len 
skip process named 	buf result 
entry first 	pow ceil 
remember haven processed 	pow ceil 
first entry 	pow 
yet later call 	ceil pow 
skip entry 	ceil pow 
processed early update 	ceil errno 
extended entry 	malloc strtoumax 
called underlying entries 	errno errno 
blob blob 	malloc 
blob first asks 	strtoumax errno 
remember still 	str test 
need process extract 	test test 
processing entry 	test test 
call caller know 	test test 
calling update 	test 
extended entry 	test test 
remember processed already 	test test 
extract first 	test test 
entry desc skip 	test test 
ones already 	test test 
returned earlier rounds 	test 
found found 	test test 
processed entry already 	test test 
caller wants 	test test 
first nothing need 	test test 
look ahead 	test test 
suspect subtree whose 	test 
name first 	test test 
may hiding behind 	test test 
current entry 	test test 
path keep looking 	test test 
returned entry 	test test 
early may current 	test 
location even 	test test 
though may 	test test 
subtree behind another 	test test 
may want 	test test 
grab trees match 	test test 
cull ones 	test 
earliest entry earliest 	test test 
name trees 	test test 
linux built max 	test test 
number symlinks 	test test 
follow limit course 	test test 
affect git 	test 
reasonable choice find 	test test 
entry following 	test test 
symlinks sha assumed 	test test 
root repository 	test test 
symlink points outside 	test test 
repository link 	test 
foo root level 	test test 
link foo 	test test 
portion link 	test test 
outside repository returned 	test test 
result path 	test test 
mode assumed result 	test 
path uninitialized 	test test 
symlinks end result 	test test 
symlink chain 	test test 
points inside repository 	test test 
result filled 	test test 
sha found mode 	function 
hold mode 	prototypes non 
see code follow 	functions malloc 
symlink result 	message setup 
description values descend 	use syscall 
handle symlinks 	rather write 
removing leading slashes 	possible 
split namebuf 	order avoid 
first component 	possibility memory 
remainder could end 	allocation within 
namebuf appears 	libc necessary 
symlink could end 	free bsd 
via symlink 	operating 
dir look first 	systems problem 
path component 	though wrapper 
descend follow symlink 	around malloc 
many symlinks 	message avoids 
followed point followed 	need malloc 
least one 	message 
symlink error need 	throughout code 
report signals 	glibc provides 
haven called strncmp 	non standard 
never interesting 	strerror gnu 
trick requires exact 	source defined 
matching could 	provide 
something clever inexact 	wrapper swallow 
matching trickier 	leading whitespace 
forget strcasecmp 	sign fall 
locale dependent least 	fall prefix 
glibc disable 	note first 
worse wildcard codepath 	non 
pattern seen 	whitespace sign 
match sorts later 	character possible 
current path 	tell whether 
match sort strictly 	digits consumed 
earlier path 	convert overflow 
common parts come 	conversion 
even means 	performed characters 
least one pathspec 	converted fall 
would sort 	left padding 
equal later path 	right padding 
currently looking 	synthetic used 
words never reached 	flags 
point iterating 	width width 
pathspecs means pathspecs 	precision separator 
either outside 	precision length 
inside sorts 	conversion specifier 
strictly earlier current 	caller provide 
one either 	alternate 
never match subsequent 	write callback 
entries initialized 	function use 
variable returned allowing 	one malloc 
caller terminate 	write function 
early cheated strncmp 	use malloc 
common part 	message 
matched earlier hit 	directly print 
rejected path 	callback function 
leading directory shorter 	way hopefully 
match match 	avoid memory 
entry check prefix 	allocation print 
part matched 	stderr 
sensitively entry directory 	way avoid 
part prefix 	memory allocation 
rematched eventually basecmp 	copyright salvatore 
special treatment 	sanfilippo antirez 
prefix icase 	gmail dot 
aware compare subdirectory 	rights 
path specified 	reserved redistribution 
interesting random prefix 	use source 
match perform 	binary forms 
matching leading non 	without modification 
wildcard part 	permitted provided 
pathspec item nowildcard 	following 
len must 	conditions met 
greater zero non 	redistributions source 
zero matched 	code must 
wildcard part considered 	retain copyright 
function early 	notice list 
longer non wildcard 	conditions 
part match 	following disclaimer 
early shorter non 	redistributions binary 
wildcard part 	form must 
match note 	reproduce copyright 
ends sure really 	notice list 
matches directory 	conditions 
could entry non 	following disclaimer 
wildcard part 	documentation materials 
similar never interesting 	provided distribution 
optimization match 	neither name 
entry happy comparison 	redis names 
entry interesting 	contributors 
given pathspec pre 	may used 
condition either 	endorse promote 
baselen offset empty 	products derived 
path baselen 	software without 
trailing slash doesn 	specific prior 
match move 	written 
along either must 	permission software 
must match 	provided copyright 
match directories match 	holders contributors 
files later 	express implied 
concatenate entry 	warranties including 
path one fnmatch 	limited 
could avoid 	implied warranties 
concatenation certain cases 	merchantability fitness 
saves memcpy 	particular purpose 
potentially realloc turns 	disclaimed shall 
worth measurement 	copyright owner 
linux show clear 	contributors 
improvements partly 	liable direct 
nowildcard len optimization 	indirect incidental 
git fnmatch 	special exemplary 
avoid micro optimizations 	consequential damages 
match wildcard 	including limited 
says directory already 	procurement 
matched need 	substitute goods 
match rest shorter 	services loss 
theory faster 	use data 
match directories match 	profits business 
files later 	interruption however 
max depth 	caused 
ignored may consider 	theory liability 
support future 	whether contract 
see http gmane 	strict liability 
gmane comp 	tort including 
version control git 	negligence otherwise 
focus matches 	arising 
entry interesting given 	way use 
pathspec pre 	software even 
condition either baselen 	advised possibility 
offset empty 	damage glob 
path baselen trailing 	style pattern 
slash entry 	matching 
positive negative result 	match match 
file file 	match match 
file file file 	match fall 
file file 	match match 
file file file 	convert representing 
dir dir 	amount 
dir dir 	memory number 
dir dir dir 	bytes instance 
dir dir 	memtoll parsing 
dir exclude pattern 	error err 
interested directory 	otherwise error 
necessarily mean exclude 	function 
directory wildcard 	regardless fact 
decide looking individual 	err unit 
files inside 	multiplier search 
write directories yet 	first non 
tree-walk.h sha 	digit character 
path mode buffer 	copy 
entry size 	digits buffer 
desc pathp modep 	use strtoll 
desc desc 	convert digit 
buf size desc 	without unit 
name entry 	number number 
desc sha info 	digits 
traverse path 	converted radix 
prev name 	see information 
pathlen pathspec conflicts 	like digits 
data show 	values abs 
errors path info 	llong min 
info info 	requires 
entry len helper 	special handling 
function entry 	minus convert 
extract update entry 	returns number 
returns success 	characters needed 
includes links initial 	represent number 
symlink missing 	buffer 
initial symlink transitively 	big enough 
points missing 	store returned 
file somewhere along 	following article 
symlink chain 	apparently provide 
path requested contains 	novel approach 
file non 	publicizes 
element general 	already used 
positive means kind 	technique https 
interesting subsequent 	www facebook 
entries either yes 	notes facebook 
subsequent entries 	engineering three 
tree.c type sha 	optimization 
baselen pathname 	tips modified 
mode stage opt 	order handle 
len size 	integers since 
sha pathname mode 	original code 
stage context 	designed integers 
sha pathname mode 	main 
stage context 	loop works 
stage pathspec context 	bit integers 
desc entry 	simplicity convert 
sha len oldlen 	number remember 
commit baselen 	negative check 
stage pathspec context 	length 
ret stage 	term handle 
match err 	last digits 
sha obj item 	sign convert 
buffer size 	returns could 
item quiet missing 	parsed non 
buffer size 	overflowing 
sha obj isdir 	otherwise parsed 
strlen cache 	appropriate special 
entry size xcalloc 	first digit 
create mode 	abort negative 
create flags memcpy 	sign 
memcpy hashcpy 	first digit 
cache entry read 	otherwise overflow 
one entry 	overflow bytes 
opt read one 	used overflow 
entry opt 	overflow convert 
parse init desc 	returns 
entry entry 	could parsed 
interesting isdir hashcpy 	non overflowing 
isgitlink lookup 	otherwise parsed 
commit die 	appropriate convert 
sha hex parse 	representation returns 
commit die 	number 
sha hex hashcpy 	bytes required 
entry len 	representation always 
strbuf strbuf addch 	parsable strtod 
read lookup 	see http 
strbuf setlen strbuf 	wikipedia wiki 
read strbuf 	zero 
release cache name 	comparisons check 
stage compare 	safe range 
stage stage stage 	casted assuming 
read recursive 	bit also 
cache free qsort 	assuming implementations 
lookup create 	around 
alloc node type 	precision bit 
read sha 	assumptions test 
file error oid 	inside interval 
hex free 	casting safe 
error oid 	two castings 
hex parse buffer 	make 
free parse 	sure part 
parse used caller 	zero use 
knows existing 	integer printing 
entries stage conflict 	function much 
entry added 	faster generate 
currently existing callers 	redis 
function call 	run sha 
stage making sure 	sized random 
nothing stage 	number identifies 
could always use 	given execution 
read one 	redis talking 
entry quick decide 	instance 
straighten git 	run reconnect 
read use unpack 	run sure 
trees cases 	either different 
probably start 	instance restarted 
matter see cache 	state sha 
entry stage 	seed 
original slow way 	dev urandom 
otherwise append 	counter hash 
sort end sort 	seed initialize 
cache entry 	seed use 
need nuke cache 	sha counter 
though tree.h 	mode 
type buffer size 	hash seed 
sha item 	progressive counter 
buffer size quiet 	goals function 
missing sha 	need non 
baselen stage pathspec 	colliding cryptographic 
context stage 	security 
pathspec parse gently 	needs convert 
parses returns 	hex digits 
given ent chasing 	read dev 
tags commits 	urandom reasonable 
unicode widthh 	effort order 
zero width width 	create 
plane plane 	entropy since 
plane plane plane 	function used 
plane plane 	generate run 
plane plane plane 	cluster instance 
plane plane 	use time 
plane plane plane 	pid 
plane plane 	fill initial 
unistd.h win define 	xor rand 
porting git 	output already 
mode ssize defines 	seeded time 
access access 	startup convert 
mode doesn define 	hex 
doesn seem 	digits given 
hurt check file 	filename absolute 
existence well 	path sds 
maybe hurt newer 	fails reason 
versions msvcrt 	note filename 
access mode 	may 
causes invalid parameter 	absolute path 
error access 	already detected 
doesn check execute 	handled correctly 
permission check 	function normalize 
write permission check 	everything obvious 
read permission 	one 
fifo character block 	appearning start 
ever directory 	filename relative 
regular file type 	path path 
mask unix-socket.c 	already absolute 
orig len path 	path relative 
orig dir 	cwd 
ctx path ctx 	relative path 
size slash 	point current 
dir cwd path 	path always 
saved errno 	ending trimmed 
ctx path saved 	relative path 
errno ctx 	normalize 
socket die 	obvious trailing 
errno xmemdupz chdir 	elements start 
free chdir 	path every 
die free strlen 	find filename 
find last 	also last 
dir sep strlen 	element 
strbuf getcwd 	cwd unless 
strbuf detach chdir 	current cwd 
len memset 	glue two 
memcpy unix sockaddr 	parts together 
init unix 	specified path 
stream socket connect 	file 
unix sockaddr 	basename without 
cleanup unix sockaddr 	relative absolute 
cleanup close 	path function 
unlink unix sockaddr 	checks character 
init unix 	exists inside 
stream socket bind 	specified 
listen unix 	path enough 
sockaddr cleanup 	environments redis 
unix sockaddr cleanup 	runs may 
close fail 	start leading 
error since moved 	space trailing 
cwd whole 	space 
process could confuse 	may start 
calling code 	overflow overflow 
better die unix-socket.h 	may start 
path path 	may start 
unix socket unpack-file.c 	overflow overflow 
sha path 	pattern 
buf size argc 	pattern len 
argv prefix 	len nocase 
sha read sha 	match start 
file die 	end pattern 
sha hex xsnprintf 	nocase err 
xmkstemp write 	buf 
full die 	mul val 
errno close strcmp 	digits endptr 
usage sha 	dst dstlen 
die git config 	svalue digits 
puts create 	negative length 
temp file unpack-objects.c 	next 
dry run 	slen plen 
quiet recover errors 	negative slen 
strict unpack 	lval llval 
usage buffer offset 	buf len 
len consumed 	min max 
bytes ctx fsck 	len 
options buffer 	charset seed 
size obj decorate 	initialized seed 
buffer size 	counter digest 
obj min ret 	ctx copylen 
bytes size 	pid filename 
stream buf ret 	cwd 
sha offset 	abspath relpath 
size delta 	trimlen path 
next delta list 	buf buf 
sha offset 	buf argc 
delta size info 	argv stringmatchlen 
offset sha 	tolower 
obj obj list 	tolower tolower 
objects obj 	tolower tolower 
obj buf sha 	tolower tolower 
obj type 	stringmatchlen strlen 
data options obj 	strlen isdigit 
buf size 	strcasecmp 
type added write 	strcasecmp strcasecmp 
resolve delta 	strcasecmp strcasecmp 
added unpack non 	strcasecmp strcasecmp 
delta entry 	memcpy strtoll 
delta data delta 	digits digits 
size obj 	digits 
obj buffer unpack 	digits isnan 
delta entry 	snprintf isinf 
shift pack 	snprintf snprintf 
size progress hdr 	snprintf snprintf 
argc argv 	snprintf fopen 
prefix sha arg 	fread 
hdr ret 	fclose sha 
lookup decoration xcalloc 	init sha 
decoration die 	update sha 
oid hex die 	update sha 
git sha 	memcpy getpid 
update memmove xread 	gettimeofday 
die die 	memcpy memcpy 
errno die overflows 	memcpy rand 
die xmallocz 	sdsnew sdstrim 
memset fill git 	getcwd sdsfree 
inflate init 	sdsnew sdslen 
git inflate use 	sdslen 
error free 	sdscat sdslen 
exit fill git 	sdsrange sdslen 
inflate end 	sdslen sdsrange 
xmalloc hashcpy 	sdscatsds sdsfree 
write sha file 	strchr strchr 
die oid 	strcpy 
hex die sha 	strlen strcpy 
info die 	strlen strcpy 
lookup buffer die 	strlen strcpy 
oid hex 	strlen strcpy 
fsck die fsck 	strlen strcpy 
walk die 	strlen 
oid hex write 	strcpy strlen 
cached check 	strcpy strlen 
lookup lookup buffer 	strcpy strlen 
resolve delta 	strcpy strlen 
fill use fill 	strcpy strlen 
use unpack 	strcpy 
non delta entry 	strlen strcpy 
unpack delta 	strlen strcpy 
entry error 	strlen strcpy 
exit fill ntohl 	strlen strcpy 
ntohl die 	strlen strcpy 
pack version die 	strlen 
ntohl use 	strcpy strlen 
start progress xcalloc 	strcpy strlen 
unpack one 	strcpy strlen 
display progress stop 	strcpy strlen 
progress die 	strcpy strlen 
git config isatty 	strcpy 
strcmp strcmp 	strlen strcpy 
strcmp strcmp skip 	strlen strcmp 
prefix fsck 	strcmp strcmp 
msg types starts 	strcmp strcmp 
htonl htonl 	strcmp strcmp 
strtoul die htonl 	unused 
strtoul die 	unused test 
usage usage git 	test test 
sha init 	function prototypes 
unpack git 	non functions 
sha update git 	malloc message 
sha write 	setup 
rest hashcmp fill 	use syscall 
die use 	rather write 
xwrite always read 	possible order 
chunks running 	avoid possibility 
strict mode objects 	memory allocation 
whose reachability 	within 
suspect kept core 	libc necessary 
without getting 	free bsd 
written store make 	operating systems 
sure least 	problem though 
min bytes available 	wrapper around 
buffer pointer 	malloc 
buffer make sure 	message avoids 
sufficiently large 	need malloc 
wrap called check 	message throughout 
verified end 	code glibc 
processing write 	provides non 
rest scans objects 	standard 
reachability requirements 	strerror gnu 
calls function verify 	source defined 
reachability validity 	provide wrapper 
recursively write write 	swallow leading 
list know 	whitespace sign 
contents strict buffers 	fall 
structured objects 	fall prefix 
core end know 	note first 
contents pack 	non whitespace 
resolve deltified objects 	sign character 
one done 	possible tell 
cannot resolve yet 	whether 
queue delta 	digits consumed 
delta resolved yet 	convert overflow 
take non 	conversion performed 
flag arguments maybe 	characters converted 
day write 	fall left 
last part 	padding 
buffer stdout done 	right padding 
unpack-trees.c unpack 	synthetic used 
plumbing errors opts 	flags width 
cmd msgs 	width precision 
msg cmd clear 	separator precision 
size clear 	length 
rejected path something 	conversion specifier 
displayed rejects 	caller provide 
path state total 	alternate write 
progress index 	callback function 
errs verify absent 	use one 
sparse istate 	malloc 
skip worktree src 	write function 
ret bottom 	use malloc 
index index len 	message directly 
pos index 	print callback 
len pos 	function way 
next index pos 	hopefully 
index len 	avoid memory 
pos next src 	allocation print 
ret traverse 	stderr way 
info name entry 	avoid memory 
info bottom 	allocation copyright 
info ret pos 	salvatore 
dirmask conflicts 	sanfilippo antirez 
names info ret 	gmail dot 
bottom buf 	rights reserved 
newinfo sha info 	redistribution use 
len pathlen 	source binary 
len name cmp 	forms 
info len 	without modification 
pathlen len name 	permitted provided 
cmp info 	following conditions 
cmp info info 	met redistributions 
stage len 	source code 
mask dirmask 	must 
src names info 	retain copyright 
conflicts stage 	notice list 
bit message info 	conditions following 
pos index 	disclaimer redistributions 
pfxlen len name 	binary form 
slash cmp 	must 
len info pos 	reproduce copyright 
info mask 	notice list 
dirmask names info 	conditions following 
mask dirmask 	disclaimer documentation 
names info src 	materials provided 
cmp matches 	distribution 
cache prefix mask 	neither name 
clear mask 	redis names 
defval cache prefix 	contributors may 
basename mask 	used endorse 
clear mask defval 	promote products 
cache end 	derived 
dtype ret 	software without 
cache prefix mask 	specific prior 
clear mask 	written permission 
defval cache end 	software provided 
name slash 	copyright holders 
len dtype ret 	contributors 
processed cache 	express implied 
mask clear mask 	warranties including 
prefix index 	limited implied 
flag skip flag 	warranties merchantability 
verify absent 	fitness particular 
len ret dfc 	purpose 
sparse prefix 	disclaimed shall 
info empty worktree 	copyright owner 
verify uptodate 	contributors liable 
verify clean submodule 	direct indirect 
verify clean 	incidental special 
subdirectory name len 	exemplary 
src check 	consequential damages 
verify absent 	including limited 
verify absent verify 	procurement substitute 
absent sparse 	goods services 
old update merge 	loss use 
old label 	data 
stages index head 	profits business 
remote count 	interruption however 
head match remote 	caused theory 
match conflict 	liability whether 
head conflict remote 	contract strict 
anc missing 	liability 
anc exists head 	tort including 
deleted remote 	negligence otherwise 
deleted src current 	arising way 
oldtree newtree 	use software 
src old src 	even advised 
old update 	possibility 
strcmp xstrfmt xstrfmt 	damage glob 
xstrfmt size 	style pattern 
index entry 	matching match 
size xmalloc memcpy 	match match 
entry dup 	match match 
entry strbuf addf 	fall 
error errormsg 	match match 
strbuf release list 	convert representing 
clear check 	amount memory 
leading path namelen 	number bytes 
warn schedule 	instance memtoll 
dir removal namelen 	parsing 
start progress 	error err 
delay git attr 	otherwise error 
direction display 	function regardless 
progress unlink entry 	fact err 
marked cache 	unit multiplier 
entries scheduled dirs 	search 
die display 	first non 
progress checkout 	digit character 
entry stop progress 	copy digits 
git attr 	buffer use 
direction skip worktree 	strtoll convert 
skip worktree 	digit 
skip worktree skip 	without unit 
worktree verify 	number number 
uptodate sparse skip 	digits converted 
worktree verify 	radix see 
absent sparse namelen 	information like 
index name 	digits 
pos namelen locate 	values abs 
src index 	llong min 
namelen memcmp mark 	requires special 
used namelen 	handling minus 
index name pos 	convert returns 
die namelen 	number 
memcmp entry mark 	characters needed 
used mark 	represent number 
used stage 	buffer big 
entry call unpack 	enough store 
stage mark 	returned following 
used name find 	article 
cache pos 	apparently provide 
entry len fill 	novel approach 
descriptor cache 	publicizes already 
bottom traverse trees 	used technique 
restore cache 	https www 
bottom free compare 	facebook 
entry piecewise 	notes facebook 
namelen entry len 	engineering three 
name compare 	optimization tips 
compare entry piecewise 	modified order 
strncmp namelen 	handle integers 
entry len name 	since 
compare compare 	original code 
entry namelen traverse 	designed integers 
path len 	main loop 
compare entry 	works bit 
namelen traverse path 	integers simplicity 
len xcalloc 	convert 
cache entry size 	number remember 
create mode 	negative check 
create flags hashcpy 	length term 
make traverse 	handle last 
path create entry 	digits sign 
call unpack 	convert 
free entry discard 	returns could 
index error 	parsed non 
entry len traverse 	overflowing otherwise 
path strncmp 	parsed appropriate 
strchr namelen name 	special 
compare memcmp 	first digit 
find cache pos 	abort negative 
debug path 	sign first 
putchar debug path 	digit otherwise 
putchar debug 	overflow overflow 
name entry 	bytes 
debug unpack callback 	used overflow 
next cache 	overflow convert 
entry find cache 	returns could 
entry compare 	parsed non 
entry unpack index 	overflowing otherwise 
entry unpack 	parsed 
failed stage unmerged 	appropriate convert 
unpack nondirectories 	representation returns 
stage mark used 	number bytes 
name mark 	required representation 
used isdir cache 	always parsable 
matches traversal 	strtod 
traverse trees recursive 	see http 
excluded list 	wikipedia wiki 
strbuf addch strncmp 	zero comparisons 
clear flags 	check safe 
strbuf setlen 	range casted 
strncmp strchr strbuf 	assuming 
clear flags 	bit also 
dir strbuf setlen 	assuming implementations 
strbuf addch 	around precision 
clear flags strbuf 	bit assumptions 
setlen dtype 	test inside 
excluded list namelen 	interval 
strbuf reset 	casting safe 
clear flags stage 	two castings 
clear flags 	make sure 
die memset memset 	part zero 
git pathdup 	use integer 
excludes file list 	printing 
free memset 	function much 
hashcpy mark unused 	faster generate 
mark skip 	redis run 
worktree xcalloc cache 	sha sized 
entry size 	random number 
setup traverse 	identifies 
info next cache 	given execution 
entry traverse 	redis talking 
path unpack index 	instance run 
entry traverse 	reconnect run 
trees next cache 	sure either 
entry unpack 	different 
index entry mark 	instance restarted 
unused unpack 	state sha 
failed mark skip 	seed dev 
worktree verify 	urandom counter 
absent apply sparse 	hash seed 
checkout skip 	initialize 
worktree unpack failed 	seed use 
check updates 	sha counter 
cache cache fully 	mode hash 
valid cache 	seed progressive 
update discard index 	counter goals 
discard index 	function 
clear exclude 	need non 
list display error 	colliding cryptographic 
msgs mark 	security needs 
unused unpack failed 	convert hex 
rejected path 	digits read 
hashcmp verify uptodate 	dev 
verify uptodate 	urandom reasonable 
cache invalidate path 	effort order 
untracked cache 	create entropy 
invalidate path index 	since function 
file exists 	used generate 
match stat dup 	run 
entry verify 	cluster instance 
absent free invalidate 	use time 
path copy 	pid fill 
cache entry verify 	initial xor 
uptodate free 	rand output 
invalidate path invalidate 	already 
path entry 	seeded time 
verify absent 	startup convert 
verify uptodate entry 	hex digits 
invalidate path 	given filename 
entry sha hex 	absolute path 
stage reject 	sds 
merge merged entry 	fails reason 
reject merge 	note filename 
merged entry merged 	may absolute 
entry deleted 	path already 
entry verify absent 	detected handled 
merged entry 	correctly 
verify uptodate keep 	function normalize 
entry show 	everything obvious 
stage entry show 	one appearning 
stage entry 	start filename 
keep entry keep 	relative path 
entry error 	path 
deleted entry 	already absolute 
merged entry reject 	path relative 
merge keep 	cwd relative 
entry deleted entry 	path point 
merged entry 	current path 
reject merge reject 	always 
merge merged 	ending trimmed 
entry deleted entry 	relative path 
error error 	normalize obvious 
errormsg keep entry 	trailing elements 
merged entry 	start path 
error deleted entry 	every 
uptodate skip 	find filename 
worktree lstat match 	also last 
stat entry 	element cwd 
merged entry error 	unless current 
messages expected 	cwd glue 
scripts plumbing commands 	two 
read non 	parts together 
scripted porcelain 	specified path 
required use messages 	file basename 
fact encouraged 	without relative 
reword better suit 	absolute path 
particular situation 	function 
better see git 	checks character 
checkout git 	exists inside 
merge replaces setup 	specified path 
unpack trees 	enough environments 
porcelain example error 	redis runs 
would overwrite 	may 
error uptodate file 	start leading 
error uptodate 	space trailing 
dir error would 	space may 
lose untracked 	start overflow 
overwritten error would 	overflow may 
lose untracked 	start 
removed error bind 	may start 
overlap error 	overflow overflow 
sparse uptodate 	util.c cbopaque 
file error would 	uppercase slen 
lose orphaned 	sign slen 
overwritten error would 	alt 
lose orphaned 	form slen 
removed special error 	alt form 
bind overlap 	uppercase slen 
refers pair paths 	cbopaque result 
cannot easily 	result err 
display list rejected 	buf 
paths may 	buflen nptr 
buffer error messages 	endptr ret 
path path 	digit neg 
corresponding type message 	pret uppercase 
msg indicating 	slen digits 
display porcelain otherwise 	digits 
insert list 	sign slen 
future display display 	neg alt 
error msgs 	form slen 
display error 	alt form 
messages stored nice 	uppercase slen 
way unlink 	str 
last component schedule 	size format 
leading directories 	ret alt 
removal empty directories 	form left 
removed skip 	justify plus 
worktree skip worktree 	space plus 
perfectly normal 	plus 
move merge strategies 	prec width 
may update 	len uwidth 
outside checkout area 	uprec slen 
result skip 	jemalloc silence 
worktree shortcuts verify 	init buf 
absent verify 	jemalloc 
uptodate make sure 	silence init 
modify worktree 	buf jemalloc 
already outside checkout 	silence init 
area also 	buf jemalloc 
file removed 	silence init 
index worktree file 	buf 
already outside 	val buf 
worktree area bother 	val buf 
update verify 	str size 
uptodate must called 	format ret 
already also 	write cbopaque 
stat info may 	format 
lost merged 	buf write 
entry calling verify 	cbopaque format 
uptodate may 	format syscall 
fail call unpack 	strlen write 
index entry 	strlen malloc 
unmerged cache entry 	message 
diff index 	wrtmessage format 
wants single callback 	message strerror 
skip unmerged 	strncpy strerror 
entry name 	errno errno 
compare traverse path 	errno reached 
cache entry 	memcpy 
without actually generate 	arg errno 
textual representation 	malloc strtoumax 
traverse path note 	errno arg 
compares size 	errno malloc 
traverse path caller 	strtoumax errno 
needs check 	append 
cache entry data 	arg numeric 
end len 	append padded 
pathlen must previously 	arg numeric 
hit name 	append padded 
directory entry precomputed 	arg numeric 
traverse path 	append 
quicker avoid precomputed 	padded arg 
quicker use 	numeric append 
precomputed version even 	padded implemented 
beginning compared 	arg append 
identically compare 	padded implemented 
bigger directory leading 	arg 
blob name 	strlen append 
path won inside 	padded arg 
directories nothing 	numeric append 
filled potential index 	padded reached 
entry src 	append start 
rest traversal looking 	malloc 
name matching 	vsnprintf end 
entry name directory 	malloc vsnprintf 
index anything 	write start 
want match traversal 	malloc vcprintf 
descends directory 	end start 
cache bottom entry 	malloc 
already unpacked 	vcprintf end 
never match check 	function prototypes 
check skip 	non functions 
future cache checks 	malloc message 
already past 	setup use 
possible entries 	syscall 
traverse path exact 	rather write 
match directory 	possible order 
need delay returning 	avoid possibility 
keep looking 	memory allocation 
name sorts path 	within libc 
could files 	necessary 
path directory index 	free bsd 
name path 	operating systems 
may index keep 	problem though 
looking find 	wrapper around 
first entry real 	malloc message 
name could 	avoids 
use mask supposed 	need malloc 
look index 	message throughout 
skip unmerged index 	code glibc 
entries skip 	provides non 
entry entries associated 	standard strerror 
handle directories 	gnu 
special diff 	source defined 
index cached looking 	provide wrapper 
everything name 	swallow leading 
matches skip entire 	whitespace sign 
hierarchy diff 	fall fall 
index cached codepath 	prefix 
special cases 	note first 
conflicts way look 	non whitespace 
ahead safe 	sign character 
whole directory matching 	possible tell 
undecided use 	whether digits 
matching result parent 	consumed 
dir defval 	convert overflow 
todo check patterns 	conversion performed 
may conflict 	characters converted 
ret iow know 	fall left 
advance incl 	padding right 
excl decision 	padding 
entire directory clear 	synthetic used 
flag without 	flags width 
calling clear flags 	width precision 
function call 	separator precision 
expensive excluded list 	length conversion 
every entry 	specifier 
traverse index find 	caller provide 
every entry 	alternate write 
matches according flags 	callback function 
clear mask 	use one 
entries number traversed 	malloc write 
entries mask 	function 
non zero entries 	use malloc 
whose flags 	message directly 
bits enabled traversed 	print callback 
cache pointer 	function way 
index entry prefix 	hopefully avoid 
len offset 	memory 
path current 	allocation print 
path prefix including 	stderr way 
trailing cache 	avoid memory 
name prefix len 	allocation copyright 
top level 	salvatore sanfilippo 
path prefix len 	antirez 
zero process 	gmail dot 
entries given prefix 	rights reserved 
meet mask 	redistribution use 
condition directory whole 	source binary 
directory match 	forms without 
first clear dir 	modification 
eats whole 	permitted provided 
dir already non 	following conditions 
directory clear 	met redistributions 
skip worktree according 	source code 
git dir 	must retain 
info sparse checkout 	copyright 
pretend narrowest 	notice list 
worktree unmerged 	conditions following 
entries widen worktree 	disclaimer redistributions 
according sparse 	binary form 
checkout file matched 	must reproduce 
entries skip 	copyright 
flag cleared way 	notice list 
merge len 	conditions following 
trees returns success 	disclaimer documentation 
failure manipulate 	materials provided 
resulting index failure 	distribution neither 
reflect changes 	name 
work added unpacked 	redis names 
skip worktree 	contributors may 
used internally sparse 	used endorse 
checkout loop 	promote products 
skip worktree existing 	derived software 
entries unpack 	without 
existing index entries 	specific prior 
sort prefix 	written permission 
spliced note 	software provided 
merge always left 	copyright holders 
entries index 	contributors express 
sparse checkout loop 	implied 
skip worktree 	warranties including 
entries loop skip 	limited implied 
worktree also 	warranties merchantability 
skip worktree apply 	fitness particular 
sparse checkout 	purpose disclaimed 
won attempt worktree 	shall 
entries marked 	copyright owner 
added merged entry 	contributors liable 
verify absent 	direct indirect 
check check effectively 	incidental special 
disabled skip 	exemplary consequential 
worktree unconditionally real 	damages 
check correct 	including limited 
skip worktree 	procurement substitute 
sparse checkout meant 	goods services 
narrow checkout 	loss use 
area make sense 	data profits 
narrow empty 	business 
working usually mistake 	interruption however 
sparse checkout 	caused theory 
rules allow users 	liability whether 
come merge 	contract strict 
functions gets turned 	liability tort 
unmerged entry 	including 
want date valid 	negligence otherwise 
skip worktree 	arising way 
cheat better check 	use software 
entry truly 	even advised 
date file may 	possibility damage 
overwritten keep 	glob 
checking needswork current 	style pattern 
policy allow 	matching match 
submodule sync 	match match 
wrt superproject index 	match match 
needs tightened 	fall match 
later submodules marked 	match 
automatically check 	convert representing 
checking sha subdir 	amount memory 
name going 	number bytes 
overwrite working files 	instance memtoll 
currently git 	parsing error 
checkout subprojects superproject 	err 
checkout going 	otherwise error 
overwrite anything extract 	function regardless 
name would 	fact err 
want lose anything 	unit multiplier 
existing directory 	search first 
going update submodule 	non 
care first 	digit character 
make sure local 	copy digits 
modification directory 	buffer use 
name entry 	strtoll convert 
subdirectory removed need 	digit without 
make sure 	unit 
lose locally present 	number number 
file ignored 	digits converted 
gets called index 	radix see 
entry entry 	information like 
dst found file 	digits values 
working lstat 	abs 
said fine insensitive 	llong min 
filesystem see 	requires special 
find insensitive match 	handling minus 
index also 	convert returns 
matches stat information 	number characters 
file may 	needed 
lstat succeeded even 	represent number 
though target 	buffer big 
absent old entry 	enough store 
different ignore 	returned following 
lstat matches 	article apparently 
name explicitly excluded 	provide 
overwrite checking 	novel approach 
path foo found 	publicizes already 
foo working 	used technique 
tricky modified files 	https www 
foo would 	facebook notes 
lose previous round 	facebook 
may already 	engineering three 
decided path subdirectory 	optimization tips 
replaced blob 	modified order 
want overwrite working 	handle integers 
file tracked 	since original 
unless ignored index 	code 
entries sparse 	designed integers 
checkout following verify 	main loop 
absent delayed 	works bit 
traverse trees finishes 	integers simplicity 
unpack trees 	convert number 
skip worktree 	remember 
computed correctly verify 	negative check 
absent called 	length term 
time correct skip 	handle last 
worktree verify 	digits sign 
absent call nothing 	convert returns 
sparse checkout 	could 
skip sparse checkout 	parsed non 
see use 	overflowing otherwise 
old directly way 	parsed appropriate 
uptodate stat 	special first 
info also removes 	digit abort 
update flag 	negative 
match otherwise end 	sign first 
overwriting local 	digit otherwise 
changes work migrate 	overflow overflow 
old flags 	bytes used 
previously unmerged 	overflow overflow 
entry left existence 	convert 
marker read 	returns could 
index unmerged exist 	parsed non 
index first 	overflowing otherwise 
situation note prevent 	parsed appropriate 
start cases 	convert 
index allowed match 	representation returns 
something head 	number bytes 
alt alt permitted 	required representation 
match result 	always parsable 
instead alt alt 	strtod see 
entry index 	http 
cache want make 	wikipedia wiki 
sure matches 	zero comparisons 
head alt alt 	check safe 
aggressive rule 	range casted 
resolve mostly trivial 	assuming bit 
cases historically 	also 
git merge 	assuming implementations 
one file resolve 	around precision 
deleted deleted 	bit assumptions 
one unchanged added 	test inside 
identically merge 	interval casting 
cases require index 	safe 
date avoid 	two castings 
files getting overwritten 	make sure 
conflict resolution 	part zero 
files two way 	use integer 
merge rule 	printing function 
carry forward index 	much 
without losing 	faster generate 
information across fast 	redis run 
forward favoring 	sha sized 
successful merge merge 	random number 
failure makes 	identifies given 
sense details carry 	execution 
forward rule 	redis talking 
please see 	instance run 
documentation git read 	reconnect run 
txt deletion 	sure either 
path staged bind 	different instance 
merge keep 	restarted 
index entries stage 	state sha 
collapse stage 	seed dev 
make sure stage 	urandom counter 
anything one 	hash seed 
way merge rule 	initialize seed 
take stat 	use 
information stage take 	sha counter 
data stage 	mode hash 
unpack-trees.h opts cmd 	seed progressive 
reset merge 	counter goals 
update index nontrivial 	function need 
merge trivial 	non 
merges verbose update 	colliding cryptographic 
aggressive skip 	security needs 
unmerged initial 	convert hex 
checkout diff index 	digits read 
cached debug 	dev urandom 
unpack skip sparse 	reasonable 
checkout gently 	effort order 
exiting early show 	create entropy 
errors dry 	since function 
run prefix cache 	used generate 
bottom dir 	run cluster 
pathspec msgs unpack 	instance 
rejects head 	use time 
idx merge size 	pid fill 
conflict entry 	initial xor 
unpack data dst 	rand output 
index src 	already seeded 
index result options 	time 
stages src 	startup convert 
src src 	hex digits 
sets list user 	given filename 
friendly error 	absolute path 
messages used command 	sds fails 
cmd either 	reason 
merge checkout show 	note filename 
errors store 	may absolute 
error messages corresponding 	path already 
error message 	detected handled 
type use unsetenv.c 	correctly function 
name environ 	normalize 
src dst nmln 	everything obvious 
enln strlen 	one appearning 
strlen strncmp might 	start filename 
match test 	relative path 
safely matches skip 	path already 
update-index.c allow 	absolute 
allow allow replace 	path relative 
info force 	cwd relative 
verbose mark 	path point 
valid mark skip 	current path 
worktree mtime 	always ending 
dir fmt path 	trimmed 
path path 	relative path 
path path ret 	normalize obvious 
path flag 	trailing elements 
mark namelen pos 	start path 
path path 	every find 
err old path 	filename 
len option 	also last 
size path len 	element cwd 
sha pos 	unless current 
path pos len 	cwd glue 
mode sha 	two parts 
path stage size 	together 
len option 	specified path 
flip path pos 	file basename 
mode path 	without relative 
nul term 	absolute path 
line buf getline 	function checks 
ptr tab 	character 
path name sha 	exists inside 
mode stage 	specified path 
update index usage 	enough environments 
head sha 	redis runs 
merge head sha 	may start 
ent path 	leading 
namelen stage mode 	space trailing 
sha size 	space may 
path namelen pos 	start overflow 
ret prefix 	overflow may 
prefix length err 	start may 
arg prefix 	start 
prefix length pos 	overflow overflow 
head pathspec 	pow err 
old save path 	input expected 
flags errors 	remainder expected 
flag opt 	errno expected 
arg unset opt 	errno 
arg unset 	name expected 
opt arg unset 	tests test 
flip opt 	err result 
arg unset arg 	remainder buf 
mode sha 	result len 
path endp ctx 	buf 
opt unset 	result pow 
sha mode path 	ceil pow 
ctx opt 	ceil pow 
unset nul term 	ceil pow 
line ctx 	ceil pow 
opt unset read 	ceil 
stdin ctx 	errno malloc 
opt flags errors 	strtoumax errno 
prefix ctx 	errno malloc 
opt flags 	strtoumax errno 
errors prefix argc 	str test 
argv prefix 	test 
newfd entries nul 	test test 
term line 	test test 
read stdin prefix 	test test 
length preferred 	test test 
index format executable 	test test 
bit refresh 	test 
args error split 	test test 
index file 	test test 
ctx getline parseopt 	test test 
state options 	test test 
path buf unquoted 	test test 
start vprintf 	test 
putchar end dir 	test test 
recursively strbuf 	test test 
reset strbuf addf 	test test 
mtime path 	test test 
mkdir die 	test test 
errno stat die 	test 
errno mtime 	test test 
path open die 	test test 
errno mtime 	test test 
path unlink die 	test test 
errno mtime 	test test 
path rmdir die 	test 
errno sleep 	test test 
strbuf addstr mkdtemp 	test test 
die errno 	test test 
xgetcwd atexit xstat 	test test 
mtime dir 	test test 
fill stat data 	test 
fputc avoid 	test test 
racy create file 	test test 
xstat mtime 	test test 
dir match stat 	test test 
data close 	test test 
fputc fill 	test 
stat data fputc 	test test 
avoid racy 	test test 
xmkdir xstat mtime 	test test 
dir match 	test test 
stat data close 	test test 
fputc fill 	test 
stat data fputc 	test test 
avoid racy 	test test 
write die close 	test test 
xstat mtime 	test test 
dir match stat 	test test 
data fputc 	test 
fputc avoid racy 	test test 
close create 	test test 
file xstat mtime 	test function 
dir match 	prototypes non 
stat data fputc 	functions malloc 
fputc avoid 	message 
racy xunlink 	setup use 
xstat mtime dir 	syscall rather 
match stat 	write possible 
data fputc fill 	order avoid 
stat data 	possibility memory 
fputc avoid racy 	allocation 
xunlink xrmdir 	within libc 
xstat mtime dir 	necessary free 
match stat 	bsd operating 
data fputc rmdir 	systems problem 
die errno 	though wrapper 
strbuf release strlen 	around 
cache name 	malloc message 
pos cache invalidate 	avoids need 
path error 	malloc message 
file cache error 	throughout code 
one path 	glibc provides 
error strerror stage 	non 
match stat 	standard strerror 
cache entry 	gnu source 
size xcalloc memcpy 	defined provide 
create flags 	wrapper swallow 
fill stat cache 	leading whitespace 
info mode 	sign 
stat index path 	fall fall 
free cache 	prefix note 
entry error cache 	first non 
name pos 	whitespace sign 
isgitlink resolve gitlink 	character possible 
one path 	tell 
one path strncmp 	whether digits 
error resolve 	consumed convert 
gitlink one path 	overflow conversion 
error strlen 	performed characters 
symlink leading path 	converted fall 
error cache 	left 
name pos 	padding right 
skip worktree file 	padding synthetic 
cache error 	used flags 
lstat process lstat 	width width 
error isdir 	precision separator 
process directory one 	precision 
path verify 	length conversion 
path error strlen 	specifier caller 
cache entry 	provide alternate 
size xcalloc hashcpy 	write callback 
memcpy create 	function use 
flags create mode 	one 
cache entry 	malloc write 
error report cache 	function use 
name pos 	malloc message 
strlen isreg cache 	directly print 
invalidate path 	callback function 
report die verify 	way 
path mark 	hopefully avoid 
flags die 	memory allocation 
mark flags die 	print stderr 
file cache 	way avoid 
die report process 	memory allocation 
path die 	copyright 
report getline strtoul 	salvatore sanfilippo 
strchr sha 	antirez gmail 
hex strbuf reset 	dot rights 
unquote style 	reserved redistribution 
die verify path 	use source 
file cache 	binary 
die cacheinfo die 	forms without 
die strbuf 	modification permitted 
release strbuf release 	provided following 
entry error 	conditions met 
error cache entry 	redistributions source 
size xcalloc 	code 
hashcpy memcpy create 	must retain 
flags create 	copyright notice 
mode strlen 	list conditions 
cache name pos 	following disclaimer 
unmerge cache 	redistributions binary 
entry stage namelen 	form 
memcmp namelen 	must reproduce 
memcmp read one 	copyright notice 
ent read 	list conditions 
one ent hashcmp 	following disclaimer 
file cache 	documentation materials 
cache entry error 	provided 
cache entry 	distribution neither 
error free free 	name redis 
read die 	names contributors 
read exit read 	may used 
head pointers 	endorse promote 
prefix path unresolve 	products 
one free 	derived software 
parse pathspec read 	without specific 
stage path 	prior written 
match read 	permission software 
one ent namelen 	provided copyright 
hashcmp free 	holders 
xstrdup update one 	contributors express 
free free 	implied warranties 
free pathspec setup 	including limited 
work read 	implied warranties 
cache preload refresh 	merchantability fitness 
cache refresh 	particular 
refresh error resolve 	purpose disclaimed 
undo clear 	shall copyright 
strtoul sha hex 	owner contributors 
parse style 	liable direct 
cacheinfo cacheinfo die 	indirect incidental 
error strtoul 	special 
sha hex cacheinfo 	exemplary consequential 
die error 	damages including 
read index 	limited procurement 
info error unresolve 	substitute goods 
strlen setup 	services loss 
work reupdate strlen 	use 
strlen strcmp 	data profits 
usage options git 	business interruption 
config xcalloc 	however caused 
hold locked index 	theory liability 
read cache 	whether contract 
die parse options 	strict 
start parse 	liability tort 
options step exit 	including negligence 
setup work 	otherwise arising 
prefix path update 	way use 
one chmod 	software even 
path free error 	advised 
error usage 	possibility damage 
options parse options 	glob style 
end die 	pattern matching 
setup work 	match match 
getline strbuf reset 	match match 
unquote style 	match 
die strbuf swap 	fall match 
prefix path 	match convert 
update one chmod 	representing amount 
path free 	memory number 
strbuf release strbuf 	bytes instance 
release init 	memtoll 
split index git 	parsing error 
config untracked 	err otherwise 
cache warning untracked 	error function 
cache report 	regardless fact 
setup work test 	err unit 
untracked cache 	multiplier 
supported git config 	search first 
untracked cache 	non digit 
warning untracked cache 	character copy 
report git 	digits buffer 
work die 	use strtoll 
exit unable die 	convert 
index file 	digit without 
write locked index 	unit number 
die rollback 	number digits 
file git information 	converted radix 
manager hell 	see information 
copyright linus torvalds 	like 
allowing changes 	digits values 
list files tool 	abs llong 
doesn actually 	min requires 
care makes harder 	special handling 
files revision 	minus convert 
control mistake something 	returns 
like git 	number characters 
update index suddenly 	needed represent 
files revision 	number buffer 
controlled untracked cache 	big enough 
mode use 	store returned 
could usleep 	following 
use nsec defined 	article apparently 
field nsec 	provide novel 
could could choose 	approach publicizes 
ignore handle 	already used 
path couldn lstat 	technique https 
either missing 	www 
file enoent enotdir 	facebook notes 
supposed removing 	facebook engineering 
removal actually succeeds 	three optimization 
permission error 	tips modified 
never old index 	order handle 
entry already 	integers 
date handle path 	since original 
directory four 	code designed 
cases already gitlink 	integers main 
index keep 	loop works 
way update 	bit integers 
cannot find head 	simplicity 
going keep 	convert number 
unchanged index file 	remember negative 
index removed 	check length 
file removal allowed 	term handle 
since doesn 	last digits 
exist removal isn 	sign 
allowed error 	convert returns 
note old arguably 	could parsed 
fairly strange 	non overflowing 
behaviour might want 	otherwise parsed 
make error 	appropriate special 
unconditionally use force 	first 
actually want 	digit abort 
force removal used 	negative sign 
exist subdirectory 	first digit 
multiple files particular 	otherwise overflow 
prefix index 	overflow bytes 
wrong update 	used 
directory doesn exist 	overflow overflow 
index valid 	convert returns 
git directory added 	could parsed 
gitlink exact 	non overflowing 
match file existing 	otherwise parsed 
gitlink nothing 	appropriate 
index head unconditional 	convert representation 
error inexact 	returns number 
match perhaps subdirectory 	bytes required 
match subdirectory 	representation always 
match error match 	parsable strtod 
gitlink error 	see 
working directory version 	http wikipedia 
assumed good 	wiki zero 
updating make sense 	comparisons check 
hand removing 	safe range 
index work first 	casted assuming 
things first 	bit 
stat information 	also assuming 
decide pathname reads 	implementations around 
lines formatted 	precision bit 
one three formats 	assumptions test 
mode sha 	inside interval 
tab path first 	casting 
format git 	safe two 
apply index info 	castings make 
reports used 	sure part 
reconstruct used phony 	zero use 
merge falling 	integer 
back way merge 	printing function 
mode type 	much faster 
sha tab path 	generate redis 
second format 	run sha 
stuff git output 	sized random 
index file 	number 
mode sha stage 	identifies given 
tab path 	execution redis 
format put 	talking instance 
higher order stages 	run reconnect 
index file 	run sure 
matches git files 	either 
stage output 	different instance 
point head path 	restarted state 
point tail 	sha seed 
sha point head 	dev urandom 
path mode 	counter hash 
means path mode 	seed 
sha name 	initialize seed 
ptr points tab 	use sha 
ptr beginning 	counter mode 
sha see entry 	hash seed 
index already 	progressive counter 
merged resolve undo 	goals 
information fall 	function need 
back isn either 	non colliding 
unmerged resolved 	cryptographic security 
removed mistake 	needs convert 
want anything former 	hex digits 
grab blobs 	read 
given path head 	dev urandom 
merge head 	reasonable effort 
stuff head version 	order create 
stage stuff 	entropy since 
merge head version 	function used 
stage read 	generate 
head merge head 	run cluster 
merge head 	instance use 
exist merge exit 	time pid 
success status 	fill initial 
read head run 	xor rand 
update index 	output 
paths merged already 	already seeded 
different index 	time startup 
head head 	convert hex 
means initial commit 	digits given 
update everything 	filename absolute 
index unchanged careful 	path 
working may 	sds fails 
path anymore allow 	reason note 
worse yet 	filename may 
allow replace active 	absolute path 
may decrease 	already detected 
style cacheinfo consume 	handled 
remaining arguments 	correctly function 
consume remaining arguments 	normalize everything 
disallow cacheinfo 	obvious one 
mode form free 	appearning start 
memory becomes 	filename relative 
part linked list 	path 
parsed atexit 	path already 
custom copy parse 	absolute path 
options want 	relative cwd 
handle filename 	relative path 
arguments come discard 	point current 
split index 	path 
index destroy split 	always ending 
index cache 	trimmed relative 
may shared index 	path normalize 
cache yeah 	obvious trailing 
leaking bit update-ref.c 	elements start 
git update 	path 
usage line termination 	every find 
update flags 	filename also 
create reflog flag 	last element 
msg next 	cwd unless 
arg orig input 	current cwd 
next input 	glue 
next sha command 	two parts 
refname flags 	together specified 
arg ret transaction 	path file 
input next 	basename without 
err refname 	relative absolute 
sha old sha 	path 
old transaction 	function checks 
input next err 	character exists 
refname sha 	inside specified 
transaction input next 	path enough 
err refname 	environments redis 
old sha old 	runs 
transaction input 	may start 
next err refname 	leading space 
old sha 	trailing space 
input next transaction 	may start 
input next 	overflow overflow 
argc argv prefix 	may 
refname oldval 	start may 
sha oldsha end 	start overflow 
flags create 	overflow pattern 
reflog options err 	pattern len 
transaction unquote 	len nocase 
style die 	match 
isspace die isspace 	start end 
strbuf addch 	pattern nocase 
parse arg strbuf 	err buf 
addstr strbuf 	mul val 
release check refname 	digits endptr 
format die 	dst 
strbuf detach die 	dstlen svalue 
parse arg 	digits negative 
sha hashclr die 	length next 
strbuf addstr 	slen plen 
sha warning hashclr 	negative slen 
strbuf release 	lval 
die die parse 	llval buf 
refname die 	len min 
parse next sha 	max len 
die parse 	charset seed 
next sha 	initialized seed 
die transaction update 	counter 
die free 	digest ctx 
strbuf release parse 	copylen pid 
refname die 	filename cwd 
parse next sha 	abspath relpath 
die sha 	trimlen path 
die die transaction 	buf 
create die 	buf buf 
free strbuf release 	argc argv 
parse refname 	stringmatchlen tolower 
die parse next 	tolower tolower 
sha sha 	tolower tolower 
die die transaction 	tolower 
die free 	tolower stringmatchlen 
strbuf release parse 	strlen strlen 
refname die 	isdigit strcasecmp 
parse next sha 	strcasecmp strcasecmp 
hashclr die 	strcasecmp strcasecmp 
transaction verify 	strcasecmp 
die free strbuf 	strcasecmp memcpy 
release strncmp 	strtoll digits 
die strbuf read 	digits digits 
die errno 	digits isnan 
die isspace die 	snprintf isinf 
starts parse 	snprintf 
cmd update starts 	snprintf snprintf 
parse cmd 	snprintf snprintf 
create starts parse 	fopen fread 
cmd starts 	fclose sha 
parse cmd verify 	init sha 
starts parse 	update 
cmd option die 	sha update 
strbuf release 	sha memcpy 
git config parse 	getpid gettimeofday 
options die 	memcpy memcpy 
transaction begin die 	memcpy rand 
usage options 	sdsnew 
update refs 	sdstrim getcwd 
stdin transaction commit 	sdsfree sdsnew 
die transaction 	sdslen sdslen 
free strbuf release 	sdscat sdslen 
usage options 	sdsrange sdslen 
usage options usage 	sdslen 
options sha 	sdsrange sdscatsds 
die hashclr sha 	sdsfree strchr 
die sha 	strchr strcpy 
update parse one 	strlen strcpy 
whitespace nul 	strlen strcpy 
terminated possibly quoted 	strlen 
argument append 	strcpy strlen 
result arg pointer 	strcpy strlen 
terminator die 	strcpy strlen 
error argument quoted 	strcpy strlen 
function used 	strcpy strlen 
parse reference name 	strcpy 
immediately command 	strlen strcpy 
handle quoting 	strlen strcpy 
pointer newly allocated 	strlen strcpy 
containing name 	strlen strcpy 
reference error update 	strlen strcpy 
next point 	strlen 
character terminates argument 	strcpy strlen 
die quoting 	strcpy strlen 
malformed reference name 	strcpy strlen 
invalid without 	strcpy strlen 
use next argument 	strcpy strlen 
use everything 	strcpy 
next nul parsed 	strlen strcpy 
oldvalue opposed 	strlen strcpy 
newvalue difference affects 	strlen strcpy 
error messages 	strlen strcpy 
generated backwards compatibility 	strlen strcmp 
accept empty 	strcmp 
update newvalue 	strcmp strcmp 
binary mode equivalent 	strcmp strcmp 
specifying zeros 	strcmp unused 
parse argument separator 	unused test 
followed next 	test test 
argument argument convert 	function 
sha write 	prototypes non 
sha next point 	functions malloc 
character terminating 	message setup 
argument argument even 	use syscall 
empty next 	rather write 
unchanged provided cannot 	possible 
converted sha 	order avoid 
die flags include 	possibility memory 
parse sha 	allocation within 
old parse sha 	libc necessary 
allow empty 	free bsd 
without consume use 	operating 
next argument 	systems problem 
without empty 	though wrapper 
means zeros read 	around malloc 
next nul 	message avoids 
terminated line treat 	need malloc 
empty zeros 	message 
empty non required 	throughout code 
means unspecified 	glibc provides 
following five parse 	non standard 
cmd functions 	strerror gnu 
parse corresponding command 	source defined 
next points 	provide 
character following command 	wrapper swallow 
name following 	leading whitespace 
space pointer character 	sign fall 
terminating command 	fall prefix 
die explanatory message 	note first 
parsing problems 	non 
functions handle either 	whitespace sign 
text binary 	character possible 
format input 	tell whether 
depending line termination 	digits consumed 
read line 	convert overflow 
dispatch command empty 	conversion 
implies reference 	performed characters 
must already exist 	converted fall 
purposes backwards 	left padding 
compatibility treat sha 	right padding 
care update-server-info.c 	synthetic used 
update server info 	flags 
usage argc 	width width 
argv prefix force 	precision separator 
options git 	precision length 
config parse options 	conversion specifier 
usage options 	caller provide 
update server info 	alternate 
upload-archive.c upload 	write callback 
archive usage deadchild 	function use 
argc argv 	one malloc 
prefix sent 	write function 
argv arg cmd 	use malloc 
buf fmt 	message 
buf child band 	directly print 
buf argc 	callback function 
argv prefix writer 	way hopefully 
err pfd 	avoid memory 
usage enter repo 	allocation print 
die argv 	stderr 
push packet read 	way avoid 
line die 	memory allocation 
starts die argv 	copyright salvatore 
push strlen 	sanfilippo antirez 
write archive start 	gmail dot 
strbuf vaddf 	rights 
end send sideband 	reserved redistribution 
die read 	use source 
error clnt strerror 	binary forms 
send sideband 	without modification 
start command 	permitted provided 
packet write die 	following 
strerror packet 	conditions met 
write packet flush 	redistributions source 
poll error 	code must 
strerror sleep process 	retain copyright 
input process 	notice list 
input finish command 	conditions 
error clnt 	following disclaimer 
packet flush copyright 	redistributions binary 
franck bui 	form must 
huu put received 	reproduce copyright 
options sent 	notice list 
argv got flush 	conditions 
parse options 	following disclaimer 
sent client sideband 	documentation materials 
subprocess parent 	provided distribution 
monitor read 	neither name 
child sending multiplexed 	redis names 
child dies 	contributors 
tell end channel 	may used 
status stream 	endorse promote 
ready data stream 	products derived 
ready upload-pack.c 	software without 
upload pack usage 	specific prior 
oldest multi 	written 
ack done use 	permission software 
thin pack 	provided copyright 
use ofs delta 	holders contributors 
use include 	express implied 
tag progress daemon 	warranties including 
mode allow 	limited 
unadvertised request shallow 	implied warranties 
obj want 	merchantability fitness 
obj extra edge 	particular purpose 
obj timeout 	disclaimed shall 
keepalive use 	copyright owner 
sideband advertise refs 	contributors 
stateless rpc 	liable direct 
data graft data 	indirect incidental 
pack objects 	special exemplary 
data progress abort 	consequential damages 
msg buffered 	including limited 
argv arg pipe 	procurement 
pfd pollsize 	substitute goods 
ret outsz buf 	services loss 
hex sha 	use data 
knew parents commit 	profits business 
want work 	interruption however 
list commit parent 	caused 
want sha 	theory liability 
last hex got 	whether contract 
common got 	strict liability 
sent ready line 	tort including 
hex allow 	negligence otherwise 
hidden argv 	arising 
cmd namebuf shallows 	way use 
depth non 	software even 
tip features sha 	advised possibility 
buf line 	damage glob 
sha end backup 	style pattern 
parents refname 	matching 
refname full oid 	match match 
refname full 	match match 
oid flag data 	match fall 
refname buf 	match match 
symref item refname 	convert representing 
oid flag 	amount 
data capabilities refname 	memory number 
nons peeled 	bytes instance 
symref info refname 	memtoll parsing 
oid flag 	error err 
data symref target 	otherwise error 
item unused 	function 
symref unused 	regardless fact 
argc argv dir 	err unit 
strict arg 	multiplier search 
alarm send sideband 	first non 
xwrite write 	digit character 
die oid hex 	copy 
start command 	digits buffer 
die xfdopen commit 	use strtoll 
graft oid 	convert digit 
hex oid hex 	without unit 
oid hex 	number number 
fflush fclose reset 	digits 
timeout poll 	converted radix 
error strerror sleep 	see information 
xread send 	like digits 
client data close 	values abs 
xread close 	llong min 
send client 	requires 
data write die 	special handling 
finish command 	minus convert 
error send client 	returns number 
data packet 	characters needed 
flush send client 	represent number 
data die 	buffer 
sha hex die 	big enough 
sha file 	store returned 
parse die sha 	following article 
hex commit 	apparently provide 
list insert date 	novel approach 
pop commit 	publicizes 
parse commit list 	already used 
insert date 	technique https 
clear commit marks 	www facebook 
free commit 	notes facebook 
list deref tag 	engineering three 
reachable packet 	optimization 
read line 	tips modified 
reset timeout give 	order handle 
packet write 	integers since 
packet write packet 	original code 
write exit 	designed integers 
starts got sha 	main 
give sha 	loop works 
hex packet write 	bit integers 
packet write 	simplicity convert 
memcpy sha hex 	number remember 
packet write 	negative check 
packet write packet 	length 
write strcmp 	term handle 
packet write packet 	last digits 
write die 	sign convert 
start command sigchain 	returns could 
push max 	parsed non 
index indexed memcpy 	overflowing 
oid hex 	otherwise parsed 
write full 	appropriate special 
memcpy oid hex 	first digit 
write full 	abort negative 
close sigchain pop 	sign first 
read full 	digit 
close finish command 	otherwise overflow 
die oid 	overflow bytes 
hex packet read 	used overflow 
line reset 	overflow convert 
timeout starts sha 	returns could 
hex die 	parsed 
parse die sha 	non overflowing 
hex starts 	otherwise parsed 
strtol die starts 	appropriate convert 
sha hex 	representation returns 
die parse feature 	number bytes 
request parse 	required 
feature request parse 	representation always 
feature request 	parsable strtod 
parse feature 	see http 
request parse feature 	wikipedia wiki 
request parse 	zero comparisons 
feature request parse 	check 
feature request 	safe range 
parse feature request 	casted assuming 
parse feature 	bit also 
request parse die 	assuming implementations 
sha hex 	around precision 
check non tip 	bit 
repository shallow 	assumptions test 
shallow commits packet 	inside interval 
write oid 	casting safe 
hex shallow free 	two castings 
commit list 	make sure 
packet write oid 	part 
hex unregister 	zero use 
shallow parse 	integer printing 
commit die shallow 	function much 
packet flush 	faster generate 
shallow free lookup 	redis 
unknown hidden 	run sha 
strip mark strbuf 	sized random 
addf strip 	number identifies 
mark format symref 	given execution 
info packet 	redis talking 
write oid hex 	instance 
git user 	run reconnect 
agent sanitized strbuf 	run sure 
release packet 	either different 
write oid hex 	instance restarted 
peel packet 	state sha 
write oid hex 	seed 
resolve die 	dev urandom 
list append xstrdup 	counter hash 
head namespaced 	seed initialize 
reset timeout 	seed use 
head namespaced namespaced 	sha counter 
advertise shallow 	mode 
grafts packet flush 	hash seed 
head namespaced 	progressive counter 
namespaced list clear 	goals function 
receive needs 	need non 
common commits create 	colliding cryptographic 
pack file 	security 
strcmp git config 	needs convert 
strcmp git 	hex digits 
config strcmp git 	read dev 
config parse 	urandom reasonable 
hide refs config 	effort order 
git setup 	create 
gettext packet trace 	entropy since 
identity git 	function used 
extract argv path 	generate run 
strcmp strcmp 	cluster instance 
strcmp starts 	use time 
atoi strcmp usage 	pid 
setup path 	fill initial 
enter repo die 	xor rand 
git config 	output already 
upload pack remember 	seeded time 
update flag 	startup convert 
allocation allow specifying 	hex 
sha tip 	digits given 
allow request sha 	filename absolute 
reachable possibly 	path sds 
hidden sideband otherwise 	fails reason 
maximum packet 	note filename 
size bytes emergency 	may 
quit xxx 	absolute path 
happy lose stuff 	already detected 
read pack 	handled correctly 
objects err capture 	function normalize 
stderr output 	everything obvious 
progress bar 	one 
pack objects capture 	appearning start 
pack data 	filename relative 
status ready ship 	path path 
side band 	already absolute 
dump standard error 	path relative 
give priority 	cwd 
status messages data 	relative path 
ready keep 	point current 
last detect broken 	path always 
rev list 	ending trimmed 
stream corrupted unfortunate 	relative path 
unpack objects 	normalize 
would happily accept 	obvious trailing 
valid packdata 	elements start 
trailing garbage appending 	path every 
garbage pass 	find filename 
pack data good 	also last 
enough signal 	element 
breakage downstream 	cwd unless 
hit keepalive timeout 	current cwd 
without saying 	glue two 
anything send empty 	parts together 
message data 	specified path 
sideband side know 	file 
still working 	basename without 
data yet sideband 	relative absolute 
channel room 	path function 
protocol say anything 	checks character 
clients luck 	exists inside 
flush data way 	specified 
tell reachable 	path enough 
looking ancestry chain 	environments redis 
alone note 	runs may 
worry anymore sha 	start leading 
normal process 	space trailing 
without uploadpack 	space 
allow reachable sha 	may start 
want non 	overflow overflow 
tip requests never 	may start 
happen rev 	may start 
list stdin encounters 	overflow overflow 
unknown commit 	util.c 
terminates cause sigpipe 	cbopaque uppercase 
write loop 	slen sign 
commits rev list 	slen alt 
ancestors rev 	form slen 
list may died 	alt form 
encountering bad 	uppercase 
commit history want 	slen cbopaque 
bail even 	result result 
showed commit non 	err buf 
tip ones 	buflen nptr 
ancestors advertised pick 	endptr ret 
one know 	digit 
least one 	neg pret 
sent refs already 	uppercase slen 
end chosen 	digits digits 
operating stateless rpc 	sign slen 
mode however 	neg alt 
choice may older 	form 
refs advertised 	slen alt 
another process handled 	form uppercase 
initial request 	slen str 
make sure real 	size format 
parents parsed 	ret alt 
make sure commit 	form 
traversal conforms 	left justify 
client non zero 	plus space 
hidden otherwise 	plus plus 
url.c first flag 	prec width 
alphanumeric special 	len uwidth 
url val query 	uprec 
len stop 	slen jemalloc 
decode plus 	silence init 
val url url 	buf jemalloc 
len colon 	silence init 
query query buf 	buf jemalloc 
url url 	silence 
dest buf isalnum 	init buf 
urlschemechar urlschemechar 	jemalloc silence 
strchr url decode 	init buf 
strbuf addch 	val buf 
strbuf addch strbuf 	val buf 
addch strbuf 	str 
detach url decode 	size format 
mem strlen 	ret write 
memchr strbuf url 	cbopaque format 
decode url 	buf write 
decode url decode 	cbopaque format 
strbuf addstr 	format 
strbuf complete end 	syscall strlen 
url slash 	write strlen 
free strbuf 	malloc message 
detach valid url 	wrtmessage format 
schemes per 	message strerror 
std rfc use 	strncpy 
sightly looser 	strerror errno 
check earlier version 	errno errno 
check used 	reached memcpy 
remote helpers scheme 	arg errno 
part reasonable 	malloc strtoumax 
seen scheme want 	errno 
colon slash 	arg errno 
slash skip protocol 	malloc strtoumax 
part present 	errno append 
url.h url first 	arg numeric 
flag url 	append padded 
url len query 	arg 
query buf 	numeric append 
url url 	padded arg 
dest url urlmatch.c 	numeric append 
buf len 	padded arg 
esc extra esc 	numeric append 
esc url 	padded 
info url len 	implemented arg 
norm spanned 	append padded 
scheme len passwd 	implemented arg 
len path 	strlen append 
path len result 	padded arg 
len slash 	numeric 
ptr ptr colon 	append padded 
ptr path 	reached append 
start result pnum 	start malloc 
seg start 	vsnprintf end 
seg start next 	malloc vsnprintf 
slash skip 	write 
slash prev slash 	start malloc 
url url 	vcprintf end 
prefix url 	start malloc 
prefix len url 	vcprintf end 
url prefix 	function prototypes 
exactusermatch usermatched pathmatchlen 	non 
item collect 	functions malloc 
matched url key 	message setup 
dot synthkey 	use syscall 
matched len user 	rather write 
matched retval 	possible order 
config url norm 	avoid 
url norm 	possibility memory 
info isxdigit isxdigit 	allocation within 
hexval hexval 	libc necessary 
strchr strchr strchr 	free bsd 
strbuf addf 	operating systems 
strbuf addch strlen 	problem 
strspn isalpha 	though wrapper 
strbuf init strbuf 	around malloc 
addch tolower 	message avoids 
strchr strcspn 	need malloc 
append normalized escapes 	message throughout 
strbuf release 	code 
strchr strbuf addch 	glibc provides 
strchr strncmp 	non standard 
strbuf release strbuf 	strerror gnu 
release strspn 	source defined 
strbuf release strbuf 	provide wrapper 
addch tolower 	swallow 
strspn strncmp strncmp 	leading whitespace 
strncmp strncmp 	sign fall 
strspn strbuf release 	fall prefix 
strtoul strbuf 	note first 
release strbuf addch 	non whitespace 
strbuf strbuf 	sign 
addch strcspn append 	character possible 
normalized escapes 	tell whether 
strbuf release strcmp 	digits consumed 
strbuf setlen 	convert overflow 
strbuf setlen 	conversion performed 
strcmp strbuf release 	characters 
strbuf setlen 	converted fall 
strbuf setlen strbuf 	left padding 
addch append 	right padding 
normalized escapes strbuf 	synthetic used 
release strbuf 	flags width 
detach strncmp strlen 	width 
strncmp strncmp 	precision separator 
strncmp url match 	precision length 
prefix skip 	conversion specifier 
prefix cascade strrchr 	caller provide 
xmemdupz url 	alternate write 
normalize free match 	callback 
urls free 	function use 
strcmp list insert 	one malloc 
xcalloc strbuf 	write function 
addstr strbuf 	use malloc 
addch strbuf addstr 	message directly 
collect strbuf 	print 
release literals need 	callback function 
plus allowed 	way hopefully 
delims append strbuf 	avoid memory 
buf characters 	allocation print 
length len unescaping 	stderr way 
characters need 	avoid 
escaped escaping characters 	memory allocation 
characters escape 	copyright salvatore 
complement unescaped starts 	sanfilippo antirez 
rfc characters 	gmail dot 
esc extra additional 	rights reserved 
characters also 	redistribution 
always escaped esc 	use source 
characters left 	binary forms 
escaped found way 	without modification 
unescaped otherwise 	permitted provided 
used delimiters 	following conditions 
escape sequence encountered 	met 
followed hexadecimal 	redistributions source 
digits sequence invalid 	code must 
returned otherwise 	retain copyright 
returned success note 	notice list 
escape sequences 	conditions following 
normalized uppercase indicated 	disclaimer 
rfc unless 	redistributions binary 
included esc extra 	form must 
esc alphanumerics 	reproduce copyright 
always unescaped per 	notice list 
rfc normalize 	conditions following 
nul terminated url 	disclaimer 
following rules 	documentation materials 
insensitive parts url 	provided distribution 
converted lower 	neither name 
encoded characters need 	redis names 
unencoded characters 	contributors may 
encoded must 	used 
encoded encodings converted 	endorse promote 
upper hexadecimal 	products derived 
leading removed port 	software without 
numbers port 	specific prior 
scheme given removed 	written permission 
path part 	software 
including empty starting 	provided copyright 
one added 	holders contributors 
dot segments path 	express implied 
resolved removed 	warranties including 
host literals allowed 	limited implied 
normalized validated 	warranties 
rules information rfc 	merchantability fitness 
please note 	particular purpose 
function requires full 	disclaimed shall 
url including 	copyright owner 
scheme host part 	contributors liable 
file may 	direct 
empty host 	indirect incidental 
newly allocated must 	special exemplary 
freed url 	consequential damages 
valid info non 	including limited 
url err 	procurement substitute 
fields therein always 	goods 
non returned 	services loss 
stored info url 	use data 
well info 	profits business 
err fields info 	interruption however 
also filled 	caused theory 
returned stored info 	liability 
url info 	whether contract 
err brief translated 	strict liability 
error message 	tort including 
fields filled url 	negligence otherwise 
validation function 	arising way 
full url validation 	use 
performed invalid 	software even 
host names 	advised possibility 
passed function undetected 	damage glob 
however problems 	style pattern 
make url invalid 	matching match 
detected including 	match 
missing host non 	match match 
file copy 	match fall 
lowercased scheme suffix 	match match 
escapes allowed 	convert representing 
first character scheme 	amount memory 
must url 	number 
alpha bad scheme 	bytes instance 
missing part 	memtoll parsing 
copy username password 	error err 
present normalizing 	otherwise error 
escapes copy host 	function regardless 
part excluding 	fact 
port part 	err unit 
escapes allowed missing 	multiplier search 
host invalid 	first non 
url schemes file 	digit character 
file may 	copy digits 
port number host 	buffer 
name invalid 	use strtoll 
characters check port 	convert digit 
part copy 	without unit 
removing leading escapes 	number number 
allowed skip 	digits converted 
leading last one 	radix 
skip port 	see information 
number skip http 	like digits 
skip https 	values abs 
port number must 	llong min 
digits leading 	requires special 
removed since protocols 	handling 
deal bit 	minus convert 
port number 	returns number 
must also range 	characters needed 
allowed means 	represent number 
next available every 	buffer big 
system therefore 	enough 
cannot used port 	store returned 
number invalid 	following article 
characters port number 	apparently provide 
range copy 	novel approach 
path resolving segments 	publicizes already 
careful corrupt 	used 
url unescaping delimiters 	technique https 
initial missing 	www facebook 
normalize escape sequences 	notes facebook 
rfc indicates 	engineering three 
segments unescaped ignore 	optimization tips 
segment careful 	modified 
initial ignore segment 	order handle 
previous segment 	integers since 
careful initial 	original code 
path invalid previous 	designed integers 
segment next 	main loop 
done path simply 	works 
copy rest 	bit integers 
normalizing escapes careful 	simplicity convert 
corrupt url 	number remember 
unescaping delimiters url 	negative check 
prefix matches 	length term 
url url prefix 	handle 
exact match 	last digits 
url prefix url 	sign convert 
match ends 	returns could 
path component boundary 	parsed non 
url url 	overflowing otherwise 
prefix considered end 	parsed 
matching purposes 	appropriate special 
already url must 	first digit 
nul terminated 	abort negative 
url prefix 	sign first 
len length url 	digit otherwise 
prefix need 	overflow 
nul terminated length 	overflow bytes 
match characters 	used overflow 
including even match 	overflow convert 
passing url 	returns could 
url prefix always 	parsed non 
cause returned 	overflowing 
without causing faults 	otherwise parsed 
url prefix 	appropriate convert 
matches url scheme 	representation returns 
host port 	number bytes 
url prefix url 	required representation 
path portion 	always 
url prefix path 	parsable strtod 
portion url 	see http 
prefix matches 	wikipedia wiki 
boundary url prefix 	zero comparisons 
contains user 	check safe 
name must also 	range 
exactly match 	casted assuming 
user name url 	bit also 
user host 	assuming implementations 
port path match 	around precision 
fashion returned 	bit assumptions 
length path match 	test 
including example 	inside interval 
http example path 	casting safe 
matched http 	two castings 
example path length 	make sure 
match exactusermatch 	part zero 
exactusermatch url url 	use 
prefix contained 	integer printing 
user name url 	function much 
prefix user 	faster generate 
name match 	redis run 
exactusermatch left untouched 	sha sized 
check scheme 	random 
schemes match check 	number identifies 
user name 	given execution 
url prefix one 	redis talking 
url prefix 	instance run 
user match check 	reconnect run 
host port 	sure 
host names ports 	either different 
match check 	instance restarted 
path interested match 	state sha 
shorter match 	seed dev 
length without user 	urandom 
current candidate 	counter hash 
user cannot use 	seed initialize 
otherwise replace 	seed use 
one urlmatch.h url 	sha counter 
err url 	mode hash 
len scheme 	seed 
len user user 	progressive counter 
len passwd 	goals function 
passwd len host 	need non 
host len 	colliding cryptographic 
port len path 	security needs 
path len 	convert 
url info matched 	hex digits 
len user 	read dev 
matched vars url 	urandom reasonable 
section key 	effort order 
normalized url success 	create entropy 
must freed 	since 
otherwise url brief 	function used 
reason failure 	generate run 
otherwise rest fields 	cluster instance 
url total 	use time 
length url normalized 	pid fill 
length scheme 	initial 
name excluding 	xor rand 
offset url start 	output already 
user name 	seeded time 
none length user 	startup convert 
name user 	hex digits 
user len empty 	given 
user name 	filename absolute 
given offset url 	path sds 
start passwd 	fails reason 
none length passwd 	note filename 
passwd passwd 	may absolute 
len empty passwd 	path 
given offset 	already detected 
url start host 	handled correctly 
name none 	function normalize 
length host name 	everything obvious 
includes portnum 	one appearning 
file urls 	start 
may host len 	filename relative 
portnum present 	path path 
port len length 	already absolute 
excluding leading 	path relative 
end host name 	cwd relative 
always file 	path 
urls offset url 	point current 
start url 	path always 
path always point 	ending trimmed 
character url 	relative path 
normalized length path 	normalize obvious 
portion excluding 	trailing 
trailing portion always 	elements start 
url match 	path every 
usage.c error handle 	find filename 
tweaked error 	also last 
buffering prefix err 	element cwd 
err err 	unless 
err warn 	current cwd 
dying die routine 	glue two 
routine routine 	parts together 
err err err 	specified path 
fmt fmt 	file basename 
err str error 	without 
err err 	relative absolute 
warn fflush setvbuf 	path function 
fputs vfprintf 	checks character 
fputc vreportf exit 	exists inside 
vreportf exit 	specified path 
vreportf vreportf start 	enough 
usage routine 	environments redis 
end usagef die 	runs may 
recursing fputs 	start leading 
exit start die 	space trailing 
routine end 	space may 
die recursing fputs 	start 
exit strerror 	overflow overflow 
snprintf start 	may start 
die routine end 	may start 
start error 	overflow overflow 
routine end start 	pow err 
warn routine 	input 
end git information 	expected remainder 
manager hell 	expected errno 
copyright linus torvalds 	expected errno 
dlopen write 	name expected 
variable would segfault 	tests test 
ugh keep 	err 
things room overwrite 	result remainder 
userdiff.c drivers 	buf result 
ndrivers drivers alloc 	len buf 
builtin drivers 	result pow 
driver driver len 	ceil pow 
drv drv 	ceil 
cflags drv name 	pow ceil 
type namelen 	pow ceil 
name len 	pow ceil 
path attr check 	errno malloc 
driver name 	strtoumax errno 
strncmp size strncmp 	errno 
git config 	malloc strtoumax 
strcasecmp git config 	errno str 
git config 	test test 
parse config key 	test test 
userdiff find 	test test 
namelen alloc grow 	test 
memset xmemdupz 	test test 
strcmp parse funcname 	test test 
strcmp parse 	test test 
funcname strcmp parse 	test test 
tristate strcmp 	test test 
git config strcmp 	test 
git config 	test test 
strcmp parse strcmp 	test test 
git config 	test test 
strlen userdiff 	test test 
find namelen git 	test test 
attr git 	test 
check attr attr 	test test 
attr attr 	test test 
unset userdiff find 	test test 
name xmalloc 	test test 
strbuf addf notes 	test test 
cache init 	test 
numbers format statements 	test test 
like worry 	test test 
format statements without 	test test 
leading digits 	test test 
since would matched 	test test 
variable anyway 	test 
negate statements look 	test test 
like functions 	test test 
objective methods 	test test 
functions objective protocol 	test test 
definitions prototype 	test test 
attributes regex count 	test 
nested parentheses 	test test 
slurp whatever see 	test test 
taking care 	test test 
accept lines like 	test test 
sub foo 	test test 
defined elsewhere attribute 	test 
could contain 	test test 
semicolon point seems 	test test 
reasonable enough 	test test 
give brace come 	test test 
next line 	test test 
comment brace come 	test 
next line 	test test 
pod taking care 	test test 
interpret jump 	test test 
targets access 	test test 
declarations functions methods 	test test 
variables compounds 	test 
top level keywords 	function prototypes 
methods constructors 	non functions 
properties type definitions 	malloc message 
userdiff.h pattern 	setup use 
cflags name external 	syscall rather 
binary funcname 	write 
word regex textconv 	possible order 
textconv cache 	avoid possibility 
textconv want cache 	memory allocation 
name path 	within libc 
driver initialize textconv 	necessary free 
related fields 	bsd 
driver textconv enabled 	operating systems 
userdiff utf8.c 	problem though 
first last ucs 	wrapper around 
table max 	malloc message 
min mid 	avoids need 
start remainder remainder 	malloc 
incr start 	message throughout 
remainder len skip 	code glibc 
ansi width 	provides non 
orig skip text 	standard strerror 
buf text 	gnu source 
indent indent eol 	defined 
buf text 	provide wrapper 
indent indent width 	swallow leading 
indent utf 	whitespace sign 
bol space start 	fall fall 
orig len 	prefix note 
skip start buf 	first 
data len 	non whitespace 
indent indent width 	sign character 
tmp src 	possible tell 
pos width subst 	whether digits 
dst src 	consumed convert 
end dst 	overflow 
subst len old 	conversion performed 
name src 	characters converted 
dst stream format 	fall left 
buf arg 	padding right 
columns insz conv 	padding synthetic 
outsz outsz 	used 
outalloc outpos cnt 	flags width 
sofar insz 	width precision 
encoding encoding outsz 	separator precision 
conv text 	length conversion 
remainder encoding chrlen 	specifier caller 
path utf 	provide 
bom text len 	alternate write 
buf position 	callback function 
width slen display 	use one 
len utf 	malloc write 
compensation left 	function use 
isdigit bisearch bisearch 	malloc 
pick one 	message directly 
utf git wcwidth 	print callback 
strlen display 	function way 
mode esc sequence 	hopefully avoid 
len utf 	memory allocation 
width utf strnwidth 	print 
utf width 	stderr way 
strchrnul strbuf addchars 	avoid memory 
strbuf strbuf 	allocation copyright 
indented text display 	salvatore sanfilippo 
mode esc 	antirez gmail 
sequence len isspace 	dot 
strbuf addchars 	rights reserved 
strbuf strbuf addch 	redistribution use 
isalnum strbuf 	source binary 
addch strbuf addch 	forms without 
isspace utf 	modification permitted 
width strbuf 	provided 
setlen xstrndup strbuf 	following conditions 
wrapped text 	met redistributions 
free strlen strbuf 	source code 
grow display 	must retain 
mode esc sequence 	copyright notice 
len memcpy 	list 
utf width memcpy 	conditions following 
memcpy strbuf 	disclaimer redistributions 
setlen strbuf swap 	binary form 
strbuf release 	must reproduce 
strcasecmp strcasecmp encoding 	copyright notice 
utf encoding 	list 
utf strcasecmp start 	conditions following 
strbuf vaddf 	disclaimer documentation 
end fputs utf 	materials provided 
strwidth strbuf 	distribution neither 
release xmalloc iconv 	name redis 
free xrealloc 	names 
iconv open 	contributors may 
encoding utf encoding 	used endorse 
utf iconv 	promote products 
open reencode iconv 	derived software 
iconv close 	without specific 
encoding utf pick 	prior 
one utf 	written permission 
pick one utf 	software provided 
next hfs 	copyright holders 
next hfs next 	contributors express 
hfs next 	implied warranties 
hfs next hfs 	including 
dir sep 	limited implied 
strlen memcmp strlen 	warranties merchantability 
strlen strlen 	fitness particular 
utf strnwidth strbuf 	purpose disclaimed 
addstr strbuf 	shall copyright 
addf strbuf addf 	owner 
strbuf addf 	contributors liable 
code originally 	direct indirect 
http www cam 	incidental special 
mgk ucs 	exemplary consequential 
auxiliary function binary 	damages including 
search interval 	limited 
table following two 	procurement substitute 
functions define 	goods services 
column width iso 	loss use 
character follows 	data profits 
character column width 	business interruption 
control characters 	however 
del lead non 	caused theory 
spacing enclosing 	liability whether 
combining characters general 	contract strict 
category code 	liability tort 
unicode database column 	including negligence 
width soft 	otherwise 
hyphen column 	arising way 
width format characters 	use software 
general category 	even advised 
code unicode database 	possibility damage 
zero width 	glob style 
space column width 	pattern 
hangul jamo 	matching match 
medial vowels consonants 	match match 
column width 	match match 
spacing characters east 	fall match 
asian wide 	match convert 
east asian full 	representing 
width category 	amount memory 
defined unicode technical 	number bytes 
report column 	instance memtoll 
width remaining characters 	parsing error 
including printable 	err otherwise 
iso wgl characters 	error 
unicode control 	function regardless 
characters etc 	fact err 
column width implementation 	unit multiplier 
assumes ucs 	search first 
characters encoded iso 	non digit 
sorted list 	character 
non overlapping intervals 	copy digits 
non spacing 	buffer use 
characters test bit 	strtoll convert 
control characters 	digit without 
binary search table 	unit number 
non spacing 	number 
characters binary search 	digits converted 
table width 	radix see 
characters pick one 	information like 
ucs character 	digits values 
starting location start 	abs llong 
points updating 	min 
start pointer point 	requires special 
end character 	handling minus 
remainder location 	convert returns 
holds number bytes 	number characters 
remaining allowed 	needed represent 
pick otherwise allowed 	number 
pick nul 	buffer big 
would eventually appear 	enough store 
remainder also 	returned following 
reduced number bytes 	article apparently 
consumed valid 	provide novel 
utf start pointer 	approach 
undefined caller 	publicizes already 
assumes nul terminated 	used technique 
text choose 	https www 
bother remainder length 	facebook notes 
stop first 	facebook engineering 
nul xxxxxxx xxx 	three 
xxxxxx xxxx 	optimization tips 
xxxxxx xxxxxx overlong 	modified order 
surrogate fffe 	handle integers 
ffff xxx 	since original 
xxxxx xxxxxx xxxxxx 	code designed 
overlong ffff 	integers 
function returns number 	main loop 
columns occupied 	works bit 
character pointed variable 	integers simplicity 
start pointer 	convert number 
updated point next 	remember negative 
character remainder 	check 
points location stores 	length term 
number remaining 	handle last 
bytes use pick 	digits sign 
character see 	convert returns 
pick one utf 	could parsed 
returns total 	non 
number columns required 	overflowing otherwise 
terminated assuming 	parsed appropriate 
utf returns strlen 	special first 
instead look 	digit abort 
like valid 	negative sign 
utf wrap text 	first 
necessary variable 	digit otherwise 
indent indent first 	overflow overflow 
line indent 	bytes used 
indent lines indent 	overflow overflow 
negative already 	convert returns 
indent columns consumed 	could 
extra indent 	parsed non 
necessary first line 	overflowing otherwise 
broken utf 	parsed appropriate 
nothing wrapper returns 	convert representation 
total number 	returns number 
columns required printed 	bytes 
assuming utf 	required representation 
keep error given 	always parsable 
buffer encoding 	strtod see 
encoded iconv 	http wikipedia 
conversion fails returns 	wiki zero 
terminating nul 	comparisons 
insz remaining number 	check safe 
bytes since 	range casted 
started outsz insz 	assuming bit 
likely insz 	also assuming 
enough converting rest 	implementations around 
platforms variously 	precision 
spelled variants utf 	bit assumptions 
fall back 	test inside 
trying official spelling 	interval casting 
fallback platform 	safe two 
understand user spelling 	castings make 
official one 	sure 
returns first character 	part zero 
length bytes 	use integer 
multi text according 	printing function 
encoding text 	much faster 
pointer updated 	generate redis 
point next character 	run 
remainder entry 	sha sized 
remainder much bytes 	random number 
consume text 	identifies given 
exit remainder reduced 	execution redis 
returned character 	talking instance 
length otherwise text 	run 
treated limited 	reconnect run 
nul valid utf 	sure either 
raw sequence 	different instance 
todo use iconv 	restarted state 
decode one 	sha seed 
obtain chrlen treat 	dev 
encodings utf 	urandom counter 
one pick next 	hash seed 
stream ignoring 	initialize seed 
codepoints hfs would 	use sha 
note complete 	counter mode 
means enough 	hash 
make hfs dotgit 	seed progressive 
work used 	counter goals 
otherwise check malformed 	function need 
utf technically 	non colliding 
gets converted percent 	cryptographic security 
sequence returning 	needs 
good enough hfs 	convert hex 
dotgit realize 	digits read 
cannot git code 	dev urandom 
points ignored 	reasonable effort 
completely zero width 	order create 
non joiner 	entropy 
zero width joiner 	since function 
left right 	used generate 
mark right left 	run cluster 
mark left 	instance use 
right embedding right 	time 
left embedding 	pid fill 
pop directional 	initial xor 
formatting left right 	rand output 
right left 	already seeded 
inhibit symmetric swapping 	time startup 
activate symmetric 	convert 
swapping inhibit arabic 	hex digits 
form shaping 	given filename 
activate arabic form 	absolute path 
shaping national 	sds fails 
digit shapes nominal 	reason note 
digit shapes 	filename 
zero width space 	may absolute 
great deal 	path already 
folding occurs hfs 	detected handled 
enough anything 	correctly function 
convert git utf8.h 	normalize everything 
start remainder 	obvious 
len skip 	one appearning 
ansi text name 	start filename 
utf bom 	relative path 
buf text indent 	path already 
indent width 	absolute path 
buf data len 	relative 
indent indent 	cwd relative 
width pos width 	path point 
subst insz 	current path 
conv outsz insz 	always ending 
encoding encoding 	trimmed relative 
outsz encoding encoding 	path 
text remainder 	normalize obvious 
encoding path buf 	trailing elements 
position width 	start path 
reencode len strlen 	every find 
assuming bit 	filename also 
returns path would 	last 
match git 	element cwd 
hfs folding 	unless current 
path nul terminated 	cwd glue 
match variants 	two parts 
git git git 	together specified 
makes suitable 	path 
fsck verify path 	file basename 
align given 	without relative 
store strbuf per 	absolute path 
position width 	function checks 
given length larger 	character exists 
width input 	inside 
truncated alignment done 	specified path 
utime.h utime 	enough environments 
file copyright assigned 	redis runs 
placed domain 	may start 
file part mingw 	leading space 
runtime mingw 	trailing 
runtime code distributed 	space may 
hope useful 	start overflow 
without warranty 	overflow may 
warranties expressed implied 	start may 
hereby disclaimed 	start overflow 
includes limited warranties 	overflow 
merchantability fitness 	pattern pattern 
particular purpose free 	len len 
use code 	nocase match 
without limitation structure 	start end 
used utime 	pattern nocase 
function access time 	err 
modification time 	buf mul 
note must utimbuf 	val digits 
oldnames actime 	endptr dst 
modtime actime modtime 	dstlen svalue 
utime file 	digits negative 
copyright assigned placed 	length 
domain file 	next slen 
part mingw runtime 	plen negative 
mingw runtime 	slen lval 
code distributed 	llval buf 
hope useful without 	len min 
warranty warranties 	max 
expressed implied hereby 	len charset 
disclaimed includes 	seed initialized 
limited warranties merchantability 	seed counter 
fitness particular 	digest ctx 
purpose free use 	copylen pid 
code without 	filename 
limitation structure used 	cwd abspath 
utime function 	relpath trimlen 
access time modification 	path buf 
time note 	buf buf 
must utimbuf oldnames 	argc argv 
utime.h utime 	stringmatchlen 
file copyright assigned 	tolower tolower 
placed domain 	tolower tolower 
file part 	tolower tolower 
mingw runtime mingw 	tolower stringmatchlen 
runtime code 	strlen strlen 
distributed hope useful 	isdigit 
without warranty 	strcasecmp strcasecmp 
warranties expressed implied 	strcasecmp strcasecmp 
hereby disclaimed 	strcasecmp strcasecmp 
includes limited warranties 	strcasecmp memcpy 
merchantability fitness 	strtoll digits 
particular purpose free 	digits 
use code 	digits digits 
without limitation structure 	isnan snprintf 
used utime 	isinf snprintf 
function access time 	snprintf snprintf 
modification time 	snprintf snprintf 
note must utimbuf 	fopen 
oldnames actime 	fread fclose 
modtime actime modtime 	sha init 
utime file 	sha update 
copyright assigned 	sha update 
placed domain file 	sha memcpy 
part mingw 	getpid 
runtime mingw runtime 	gettimeofday memcpy 
code distributed 	memcpy memcpy 
hope useful without 	rand sdsnew 
warranty warranties 	sdstrim getcwd 
expressed implied hereby 	sdsfree sdsnew 
disclaimed includes 	sdslen 
limited warranties merchantability 	sdslen sdscat 
fitness particular 	sdslen sdsrange 
purpose free use 	sdslen sdslen 
code without 	sdsrange sdscatsds 
limitation structure used 	sdsfree strchr 
utime function 	strchr 
access time modification 	strcpy strlen 
time note 	strcpy strlen 
must utimbuf oldnames 	strcpy strlen 
var.c usage 	strcpy strlen 
flag pgm 	strcpy strlen 
flag pgm name 	strcpy 
git vars 	strlen strcpy 
ptr val ptr 	strlen strcpy 
val argc 	strlen strcpy 
argv prefix val 	strlen strcpy 
git editor 	strlen strcpy 
die git pager 	strlen 
read strcmp 	strcpy strlen 
read git config 	strcpy strlen 
usage strcmp 	strcpy strlen 
git config list 	strcpy strlen 
vars git 	strcpy strlen 
config read usage 	strcpy 
git information 	strlen strcpy 
manager hell copyright 	strlen strcpy 
eric biederman 	strlen strcpy 
varint.c bufp buf 	strlen strcpy 
val buf 	strlen strcpy 
varint pos 	strlen 
msb memcpy overflow 	strcpy strlen 
varint.h varint 	strcpy strlen 
verify-commit.c verify commit 	strcmp strcmp 
usage sha 	strcmp strcmp 
buf size flags 	strcmp strcmp 
signature check 	strcmp 
ret name flags 	unused unused 
sha buf 	test test 
size ret status 	test function 
argc argv 	prototypes non 
prefix error flags 	functions malloc 
verify commit 	message 
options memset check 	setup use 
commit signature 	syscall rather 
lookup commit print 	write possible 
signature buffer 	order avoid 
signature check clear 	possibility memory 
sha error 	allocation 
read sha 	within libc 
file error error 	necessary free 
run gpg 	bsd operating 
verify free git 	systems problem 
gpg config 	though wrapper 
git config git 	around 
config parse 	malloc message 
options usage options 	avoids need 
signal verify 	malloc message 
commit builtin git 	throughout code 
commit commit 	glibc provides 
copyright michael gruber 	non 
git drmicha 	standard strerror 
warpmail net git 	gnu source 
verify tag 	defined provide 
sometimes program terminated 	wrapper swallow 
signal received 	leading whitespace 
process writing 	sign 
gpg input verify-pack.c 	fall fall 
path flags 	prefix note 
index pack argv 	first non 
arg verbose 	whitespace sign 
stat err verify 	character possible 
pack usage 	tell 
argc argv prefix 	whether digits 
err flags 	consumed convert 
verify pack options 	overflow conversion 
strbuf addstr 	performed characters 
strbuf strip suffix 	converted fall 
ends strbuf 	left 
addstr run command 	padding right 
strbuf release 	padding synthetic 
git config parse 	used flags 
options usage 	width width 
options verify one 	precision separator 
pack addition 	precision 
foo pack 	length conversion 
accept foo idx 	specifier caller 
foo normalize 	provide alternate 
forms foo pack 	write callback 
index pack 	function use 
verify verify-tag.c verify 	one 
tag usage 	malloc write 
buf size flags 	function use 
sigc len 	malloc message 
ret name flags 	directly print 
sha buf 	callback function 
size ret status 	way 
argc argv 	hopefully avoid 
prefix error flags 	memory allocation 
verify tag 	print stderr 
options memset parse 	way avoid 
signature write 	memory allocation 
full error check 	copyright 
signature print 	salvatore sanfilippo 
signature buffer 	antirez gmail 
signature check clear 	dot rights 
sha error 	reserved redistribution 
sha info error 	use source 
read sha 	binary 
file error run 	forms without 
gpg verify 	modification permitted 
free git gpg 	provided following 
config git 	conditions met 
config git config 	redistributions source 
parse options 	code 
usage options signal 	must retain 
verify tag 	copyright notice 
builtin git verify 	list conditions 
tag copyright 	following disclaimer 
carlos rica jasampler 	redistributions binary 
gmail git 	form 
verify tag sometimes 	must reproduce 
program terminated 	copyright notice 
signal received 	list conditions 
process writing gpg 	following disclaimer 
input version.c 	documentation materials 
git version agent 	provided 
agent buf 	distribution neither 
getenv strbuf addstr 	name redis 
git user 	names contributors 
agent strbuf trim 	may used 
version.h git 	endorse promote 
version version versioncmp.c 	products 
prereleases initialized 	derived software 
diff suffix state 	without specific 
diff next 	prior written 
state result type 	permission software 
starts starts 	provided copyright 
isdigit isdigit git 	holders 
config multi 	contributors express 
swap prereleases 	implied warranties 
isdigit isdigit isdigit 	including limited 
isdigit versioncmp 	implied warranties 
copied strverscmp glibc 	merchantability fitness 
commit def 	particular 
cfb bef cfdc 	purpose disclaimed 
reformatted git 	shall copyright 
coding style implementation 	owner contributors 
lgpl git 	liable direct 
relicenses states normal 	indirect incidental 
comparing integral 	special 
part comparing fractionnal 	exemplary consequential 
parts idem 	damages including 
leading zeroes result 	limited procurement 
type cmp 	substitute goods 
diff len compare 	services loss 
len diff 	use 
diff point first 	data profits 
different character 	business interruption 
two either 	however caused 
starts prerelease suffix 	theory liability 
forced top 	whether contract 
start different suffix 	strict 
order determined 	liability tort 
config file note 	including negligence 
deal situation 	otherwise arising 
start suffix common 	way use 
part already 	software even 
consumed caller non 	advised 
zero diff 	possibility damage 
contains versioncmp compare 	glob style 
holding indices 	pattern matching 
version numbers returning 	match match 
less equal 	match match 
greater zero less 	match 
equal greater 	fall match 
info see texinfo 	match convert 
doc symbol 	representing amount 
others transition 	memory number 
state state hint 	bytes instance 
digit walker.c 	memtoll 
current commit sha 	parsing error 
walker fmt 	err otherwise 
hex obj walker 	error function 
obj walker 	regardless fact 
desc entry obj 	err unit 
blob complete 	multiplier 
walker commit parents 	search first 
walker tag 	non digit 
process queue process 	character copy 
queue end 	digits buffer 
walker obj walker 	use strtoll 
obj walker 	convert 
elem obj walker 	digit without 
target sha 	unit number 
path oid flag 	number digits 
data commit 	converted radix 
target write 	see information 
targets alloc buf 	like 
one one 	digits values 
targets target write 	abs llong 
walker targets 	min requires 
target write write 	special handling 
log details 	minus convert 
refname err transaction 	returns 
sha msg 	number characters 
ret walker oid 	needed represent 
hex sha 	number buffer 
sha hex parse 	big enough 
init desc 	store returned 
entry isgitlink isdir 	following 
lookup lookup 	article apparently 
blob process free 	provide novel 
buffer parse 	approach publicizes 
commit pop 	already used 
recent commit hashcpy 	technique https 
walker say 	www 
oid hex process 	facebook notes 
process parse 	facebook engineering 
tag process process 	three optimization 
commit process 	tips modified 
process tag error 	order handle 
oid hex 	integers 
file prefetch list 	since original 
insert free 	code designed 
fetch report missing 	integers main 
parse process 	loop works 
sha hex check 	bit integers 
refname format 	simplicity 
alloc fetch hashcpy 	convert number 
free free 	remember negative 
lookup commit reference 	check length 
gently commit 	term handle 
list insert 	last digits 
strbuf getline strchr 	sign 
realloc realloc 	convert returns 
xstrdup xstrdup strbuf 	could parsed 
release free 	non overflowing 
free xmalloc transaction 	otherwise parsed 
begin error 	appropriate special 
commit list sort 	first 
date interpret 	digit abort 
target error process 	negative sign 
lookup unknown 	first digit 
loop xstrfmt strbuf 	otherwise overflow 
reset strbuf 	overflow bytes 
addf transaction update 	used 
error transaction 	overflow overflow 
commit error transaction 	convert returns 
free free 	could parsed 
free strbuf release 	non overflowing 
strbuf release 	otherwise parsed 
cleanup free 	appropriate 
submodule commits stored 	convert representation 
superproject remember 	returns number 
update flag allocation 	bytes required 
already scan 	representation always 
scanning placed queue 	parsable strtod 
needed fetch 	see 
first walker.h data 	http wikipedia 
walker walker 	wiki zero 
sha walker sha 	comparisons check 
walker history 	safe range 
verbosely recover corrupt 	casted assuming 
found walker 	bit 
target write targets 	also assuming 
target write 	implementations around 
impl targets target 	precision bit 
write write 	assumptions test 
log details walker 	inside interval 
url report 	casting 
got verbosely 	safe two 
load pull targets 	castings make 
stdin free 	sure part 
loaded targets write 	zero use 
filename write 	integer printing 
target write log 	function 
details additional 	much faster 
text appear log 	generate redis 
walker wildmatch.c 	run sha 
text flags pattern 	sized random 
matched match 	number identifies 
slash negated prev 	given 
prev slash 	execution redis 
upper pattern text 	talking instance 
flags isupper 	run reconnect 
tolower isupper tolower 	run sure 
dowild strchr 	either different 
strchr glob special 	instance 
isupper tolower 	restarted state 
isupper tolower 	sha seed 
dowild islower toupper 	dev urandom 
isalnum isalpha 	counter hash 
isblank iscntrl isdigit 	seed initialize 
isgraph islower 	seed 
isprint ispunct isspace 	use sha 
isupper islower 	counter mode 
isxdigit dowild shell 	hash seed 
style pattern 	progressive counter 
matching characters bit 	goals function 
clean written 	need 
rich alz mirror 	non colliding 
wed nov 	cryptographic security 
est rich alz 	needs convert 
rsalz bbn 	hex digits 
modified wayne davison 	read dev 
special matching 	urandom 
make work 	reasonable effort 
differently fix character 	order create 
code character 	entropy since 
marks inverted character 	function used 
match pattern 	generate run 
text match following 	cluster 
character note 	instance use 
test handles failure 	time pid 
fallthrough match 	fill initial 
anything without pathname 	xor rand 
assuming already 	output 
match foo star 	already seeded 
star slash 	time startup 
matches nothing ahead 	convert hex 
match rest 	digits given 
pattern remaining helps 	filename absolute 
make foo 	path 
bar otherwise breaks 	sds fails 
comment syntax 	reason note 
match foo 	filename may 
bar foo bar 	absolute path 
without pathname 	already detected 
trailing matches everything 	handled 
trailing matches 	correctly function 
slash characters one 	normalize everything 
asterisk followed 	obvious one 
slash pathname matches 	appearning start 
next directory 	filename relative 
slash consumed top 	path 
level loop 	path already 
advance faster asterisk 	absolute path 
followed know 	relative cwd 
must belong match 	relative path 
slash look 	point current 
past first slash 	path 
cannot belong 	always ending 
assign matched comparison 	trimmed relative 
inverted character 	path normalize 
makes prev 	obvious trailing 
shared iterator didn 	elements start 
find treat 	path 
like normal malformed 	every find 
makes prev 	filename also 
match pattern text 	last element 
wildmatch.h pattern 	cwd unless 
text flags win32.h 	current cwd 
attr mode 	glue 
fname fdata file 	two parts 
attributes last 	together specified 
error common win 	path file 
functions min 	basename without 
cygwin defined cygwin 	relative absolute 
win32mmap.c start 	path 
length prot flags 	function checks 
offset hmap 	character exists 
temp len start 	inside specified 
length fstat 	path enough 
die xsize 	environments redis 
die create file 	runs 
mapping osfhandle 	may start 
map view file 	leading space 
close handle 	trailing space 
warning unmap view 	may start 
file winansi.c 	overflow overflow 
console plain attr 	may 
attr negative 	start may 
non ascii used 	start overflow 
hthread hread 	overflow util.h 
hwrite hconsole hconsole 	err buf 
font family 	buflen nptr 
current console font 	endptr 
cfi hkey 	str size 
size msg dummy 	format jemalloc 
sbi hcon 	format write 
initialized str 	cbopaque format 
len wbuf dummy 	jemalloc format 
wlen attributes 	jemalloc 
sbi dummy func 	format bitmap 
paramlen unused 	bitmap errnum 
buffer bytes start 	bitmap bitmap 
state fmt 	ret ret 
hnd hresult hproc 	errnum jemalloc 
pioinfo ioinfo 	ffsl 
istty wastty handle 	jemalloc ffs 
pioinfo old 	bit scan 
handle con con 	reverse bit 
name hnd 	scan reverse 
proc address module 	builtin clz 
handle current 	builtin 
console font reg 	clzl kzu 
open key 	jemalloc ffsl 
reg query reg 	kzu jemalloc 
close key 	ffs last 
write console 	error last 
wcslen osfhandle file 	error 
type console 	size stack 
screen buffer info 	allocated buffer 
xutftowcsn size 	passed buferror 
write console console 	size stack 
text attribute 	allocated buffer 
console screen buffer 	used 
info fill 	malloc must 
console output character 	large enough 
console attr 	possible uses 
erase line read 	within jemalloc 
file last 	wrap cpp 
error last error 	argument 
write console 	contains commas 
memset attr write 	isn broken 
console memmove 	multiple arguments 
warn raster font 	silence compiler 
close handle 	warnings due 
flushall flush 	uninitialized 
file buffers disconnect 	values used 
named pipe 	wherever compiler 
wait single close 	fails recognize 
handle close 	variable never 
handle start err 	used uninitialized 
win posix 	define 
last error die 	custom order 
errno end 	reduce chances 
current process duplicate 	deadlock assertion 
handle die 	failure use 
lasterr ioinfo isatty 	particular configuration 
pioinfo isatty 	cassert 
pioinfo error init 	config debug 
ioinfo pioinfo 	jemalloc types 
console console xsnprintf 	jemalloc structs 
current process 	malloc vsnprintf 
create named pipe 	supports subset 
die lasterr 	snprintf 
create file 	avoids floating 
die lasterr create 	point math 
die lasterr 	jemalloc externs 
atexit die errno 	sanity check 
swap osfhnd 	compute smallest 
duplicate handle swap 	power 
osfhnd duplicate 	outputs inputs 
handle osfhandle isatty 	error code 
file type 	last error 
copyright peter harris 	code jemalloc 
git peter 	inlines copyright 
geek ansi codes 	salvatore 
used git 	sanfilippo antirez 
file git specific 	gmail dot 
therefore file 	rights reserved 
attempt implement codes 	redistribution use 
used git 	source binary 
bother output 	forms 
ascii current console 	without modification 
font available 	permitted provided 
since vista pre 	following conditions 
vista check 	met redistributions 
console font registry 	source code 
handle file 	must 
descriptor check device 	retain copyright 
console printer 	notice list 
serial port check 	conditions following 
handle console 	disclaimer redistributions 
output screen buffer 	binary form 
initialize attributes 	must 
called console buffer 	reproduce copyright 
convert utf 	notice list 
utf write directly 	conditions following 
console remember 	disclaimer documentation 
non ascii characters 	materials provided 
printed could 	distribution 
probably use 	neither name 
bitmask instead series 	redis names 
ifs needed 	contributors may 
windows vista regression 	used endorse 
reset bold 	promote products 
faint normal italic 	derived 
unsupported underline 	software without 
underline wikipedia says 	specific prior 
flag nothing 	written permission 
furthermore mingw doesn 	software provided 
define flag 	copyright holders 
attr common lvb 	contributors 
underscore underline 	express implied 
attr common lvb 	warranties including 
underscore slow 	limited implied 
blink fast blink 	warranties merchantability 
blink background 	fitness particular 
intensity blink negative 	purpose 
positive conceal 	disclaimed shall 
reveal unsupported 	copyright owner 
black red green 	contributors liable 
yellow blue 	direct indirect 
magenta cyan white 	incidental special 
unknown reset 	exemplary 
black red green 	consequential damages 
yellow blue 	including limited 
magenta cyan white 	procurement substitute 
unknown reset 	goods services 
unsupported code unsupported 	loss use 
code read 	data 
next chunk bytes 	profits business 
pipe exit 	interruption however 
pipe closed disconnected 	caused theory 
ignore errors 	liability whether 
scan bytes handle 	contract strict 
ansi control 	liability 
codes print text 	tort including 
seen far 	negligence otherwise 
start parsing 	arising way 
escape sequence otherwise 	use software 
bail parse 	even advised 
parameters next parameter 	possibility 
bail bounds 	damage plen 
end escape sequence 	slen nocase 
change console 	nocase err 
attributes print remaining 	len slen 
text unless 	slen buf 
parsing escape sequence 	len 
check incomplete 	filename path 
utf sequences fix 	argc argv 
end print 	size stack 
remaining complete utf 	allocated buffer 
sequences move 	passed buferror 
remaining bytes front 	size 
data consumed 	stack allocated 
mark buffer empty 	buffer used 
check console 	malloc must 
font supports 	large enough 
unicode flush streams 	possible uses 
signal console 	within 
exit wait console 	jemalloc wrap 
copy remaining 	cpp argument 
data cleanup handles 	contains commas 
make msvcrt 	isn broken 
file descriptor control 	multiple arguments 
structure accessible 	silence 
tweak handles flags 	compiler warnings 
directly need 	due uninitialized 
msvcrt treat pipe 	values used 
handle console 	wherever compiler 
ioinfo structure exposed 	fails recognize 
msvcrt dll 	variable 
via pioinfo starts 	never used 
handle flags 	uninitialized define 
exact size 	custom order 
varies msvcrt versions 	reduce chances 
different sizes 	deadlock assertion 
toggling fdev bit 	failure 
pioinfo osflags 	use particular 
reflected isatty init 	configuration cassert 
twice toggle 	config debug 
fdev flag check 	jemalloc types 
isatty toggle 	jemalloc structs 
back found correct 	malloc 
size init 	vsnprintf supports 
ioinfo size haven 	subset snprintf 
done ioinfo 	avoids floating 
pointer change handles 	point math 
check either 	jemalloc externs 
stdout stderr console 	sanity 
output screen 	check compute 
buffer create named 	smallest power 
pipe communicate 	outputs inputs 
console start 	error code 
console spool pipe 	last error 
read end 	code 
schedule cleanup routine 	jemalloc inlines 
redirect stdout 	copyright salvatore 
stderr pipe returns 	sanfilippo antirez 
real console 	gmail dot 
handle stdout stderr 	rights reserved 
pipe redirecting 	redistribution 
console allows spawn 	use source 
exec pass 	binary forms 
console next process 	without modification 
worktree.c worktrees 	permitted provided 
path detached head 	following conditions 
worktree worktree 	met 
path worktree path 	redistributions source 
gitdir head 	code must 
bare detached worktree 	retain copyright 
path worktree 	notice list 
path gitdir 	conditions following 
head detached list 	disclaimer 
path dir 	redistributions binary 
alloc linked symref 	form must 
target existing 	reproduce copyright 
path worktrees free 	notice list 
free free 	conditions following 
free free strbuf 	disclaimer 
readlink starts 	documentation materials 
check refname format 	provided distribution 
strbuf read 	neither name 
file starts strbuf 	redis names 
strlen strbuf 	contributors may 
trim check refname 	used 
format sha 	endorse promote 
hex resolve strbuf 	products derived 
detach strbuf 	software without 
addf absolute path 	specific prior 
git common 	written permission 
dir strbuf 	software 
addbuf strbuf strip 	provided copyright 
suffix strbuf 	holders contributors 
strip suffix strbuf 	express implied 
addf git 	warranties including 
common dir parse 	limited implied 
xmalloc strbuf 	warranties 
detach strbuf detach 	merchantability fitness 
head info 	particular purpose 
strbuf release strbuf 	disclaimed shall 
release strbuf 	copyright owner 
release strbuf release 	contributors liable 
die strbuf 	direct 
addf absolute path 	indirect incidental 
git common 	special exemplary 
dir strbuf addf 	consequential damages 
strbuf read 	including limited 
file strbuf 	procurement substitute 
rtrim strbuf strip 	goods 
suffix strbuf 	services loss 
reset strbuf addstr 	use data 
absolute path 	profits business 
strbuf strip suffix 	interruption however 
strbuf reset 	caused theory 
strbuf addf git 	liability 
common dir 	whether contract 
parse xmalloc strbuf 	strict liability 
detach strbuf 	tort including 
detach head info 	negligence otherwise 
strbuf release 	arising way 
strbuf release strbuf 	use 
release strbuf 	software even 
release xmalloc main 	advised possibility 
worktree strbuf 	damage util.h 
addf git common 	err buf 
dir opendir 	buflen nptr 
strbuf release 	endptr 
readdir strcmp strcmp 	str size 
linked worktree 	format jemalloc 
alloc grow closedir 	format write 
alloc grow 	cbopaque format 
worktrees strbuf reset 	jemalloc format 
strbuf reset 	jemalloc 
strbuf addf parse 	format bitmap 
strcmp xstrdup 	bitmap errnum 
strbuf release strbuf 	bitmap bitmap 
release free 	ret ret 
worktrees read path 	errnum jemalloc 
also detached 	ffsl 
detached detatched detached 	jemalloc ffs 
git common 	bit scan 
dir symref head 	reverse bit 
practically outside 	scan reverse 
git dir linked 	builtin clz 
worktrees resolve 	builtin 
won work 	clzl kzu 
uses git path 	jemalloc ffsl 
parse proper 	kzu jemalloc 
otherwise success head 	ffs last 
symbolic link 	error last 
textual symref detached 	error 
head sha 	size stack 
head detached given 	allocated buffer 
worktree main 	passed buferror 
worktree invalid gitdir 	size stack 
file repo 	allocated buffer 
moved manually accessed 	used 
since refname 	malloc must 
branch commit branch 	large enough 
must commit 	possible uses 
incomplete repo prune 	within jemalloc 
won unlock 	wrap cpp 
preparation keep resolve 	argument 
happy need 	contains commas 
valid head 	isn broken 
git directory reject 	multiple arguments 
directory looks 	silence compiler 
like since immediately 	warnings due 
replaced symbolic 	uninitialized 
update invocation worktree 	values used 
worktree usage 	wherever compiler 
force detach branch 	fails recognize 
force branch 	variable never 
show verbose expire 	used uninitialized 
reason path 	define 
len link reason 	custom order 
path dir 	reduce chances 
ret prefix options 	deadlock assertion 
junk work 	failure use 
junk git dir 	particular configuration 
junk junk 	cassert 
pid signo 	config debug 
path olen name 	jemalloc types 
len path 	jemalloc structs 
refname opts repo 	malloc vsnprintf 
name child 	supports subset 
env len ret 	snprintf 
symref commit 	avoids floating 
prefix opts branch 	point math 
force path 	jemalloc externs 
branch options symref 	sanity check 
path maxlen 	compute smallest 
abbrev len cur 	power 
path len 	outputs inputs 
path adj abbrev 	error code 
maxlen sha 	last error 
len path len 	code jemalloc 
prefix porcelain 	inlines copyright 
options worktrees prefix 	salvatore 
options directory 	sanfilippo antirez 
git path 	gmail dot 
strbuf addf file 	rights reserved 
exists git 	redistribution use 
path stat git 	source binary 
path strbuf 	forms 
addf open git 	without modification 
path strbuf 	permitted provided 
addf strerror xmallocz 	following conditions 
read full 	met redistributions 
close strbuf addf 	source code 
free file 	must 
exists free stat 	retain copyright 
git path 	notice list 
strbuf addf free 	conditions following 
opendir git 	disclaimer redistributions 
path readdir strcmp 	binary form 
strcmp strbuf 	must 
reset prune worktree 	reproduce copyright 
strbuf reset 	notice list 
strbuf addstr 	conditions following 
git path dir 	disclaimer documentation 
recursively unlink 	materials provided 
error strerror closedir 	distribution 
rmdir git 	neither name 
path strbuf release 	redis names 
strbuf release 	contributors may 
parse options usage 	used endorse 
options prune 	promote products 
worktrees getpid strbuf 	derived 
addstr dir 	software without 
recursively strbuf reset 	specific prior 
strbuf addstr 	written permission 
dir recursively strbuf 	software provided 
release junk 	copyright holders 
sigchain pop strlen 	contributors 
dir sep 	express implied 
dir sep file 	warranties including 
exists empty 	limited implied 
dir die 	warranties merchantability 
strbuf check branch 	fitness 
exists die 	particular purpose 
lookup commit reference 	disclaimed shall 
name die 	copyright owner 
worktree basename strbuf 	contributors liable 
addstr git 	direct indirect 
path safe create 	incidental 
leading directories 	special exemplary 
die errno stat 	consequential damages 
strbuf setlen 	including limited 
strbuf addf strrchr 	procurement substitute 
getpid atexit 	goods services 
sigchain push common 	loss 
mkdir die 	use data 
errno xstrdup strbuf 	profits business 
addf write 	interruption however 
file strbuf addf 	caused theory 
safe create 	liability whether 
leading directories 	contract 
die errno xstrdup 	strict liability 
strbuf reset 	tort including 
strbuf addf write 	negligence otherwise 
file real 	arising way 
path write file 	use software 
real path 	even 
git common dir 	advised possibility 
strbuf reset 	damage plen 
strbuf addf write 	slen nocase 
file strbuf 	nocase err 
reset strbuf addf 	len slen 
write file 	slen 
argv pushf argv 	buf len 
pushf memset 	filename path 
argv pushl oid 	argc argv 
hex argv 	size stack 
pushl run 	allocated buffer 
command argv clear 	passed 
argv pushl 	buferror size 
run command free 	stack allocated 
free strbuf 	buffer used 
reset strbuf addf 	malloc must 
unlink warn 	large enough 
argv clear strbuf 	possible 
release strbuf 	uses within 
release strbuf release 	jemalloc wrap 
strbuf release 	cpp argument 
memset parse options 	contains commas 
die usage 	isn broken 
options prefix filename 	multiple 
strlen strbuf 	arguments silence 
check branch exists 	compiler warnings 
die strbuf 	due uninitialized 
release worktree basename 	values used 
xstrndup memset 	wherever compiler 
argv push 	fails 
argv push argv 	recognize variable 
push argv 	never used 
push run command 	uninitialized define 
worktree sha 	custom order 
hex strlen utf 	reduce chances 
strwidth strbuf 	deadlock 
addf strbuf addstr 	assertion failure 
strbuf addf 	use particular 
find unique abbrev 	configuration cassert 
strbuf addf 	config debug 
shorten unambiguous strbuf 	jemalloc types 
addstr strbuf 	jemalloc 
release strlen strlen 	structs malloc 
find unique 	vsnprintf supports 
abbrev parse options 	subset snprintf 
usage options 	avoids floating 
worktrees measure widths 	point math 
show worktree 	jemalloc 
porcelain show 	externs sanity 
worktree free worktrees 	check compute 
usage options 	smallest power 
strcmp strcmp prune 	outputs inputs 
strcmp list 	error code 
usage options read 	last 
path also 	error code 
detached detached detatched 	jemalloc inlines 
detached git 	copyright salvatore 
common dir symref 	sanfilippo antirez 
head practically 	gmail dot 
outside git dir 	rights 
linked worktrees 	reserved redistribution 
resolve won work 	use source 
uses git 	binary forms 
path parse proper 	without modification 
otherwise success 	permitted provided 
head symbolic link 	following 
textual symref 	conditions met 
detached head 	redistributions source 
sha head detached 	code must 
given worktree 	retain copyright 
main worktree invalid 	notice list 
gitdir file 	conditions 
repo moved manually 	following disclaimer 
accessed since 	redistributions binary 
refname branch commit 	form must 
branch must 	reproduce copyright 
commit incomplete repo 	notice list 
prune won 	conditions 
unlock preparation keep 	following disclaimer 
resolve happy 	documentation materials 
need valid head 	provided distribution 
git directory 	neither name 
reject directory looks 	redis names 
like since 	contributors 
immediately replaced 	may used 
symbolic update invocation 	endorse promote 
worktree worktree.c 	products derived 
worktrees path detached 	software without 
head worktree 	specific prior 
worktree path worktree 	written 
path gitdir 	permission software 
head bare detached 	provided copyright 
worktree path 	holders contributors 
worktree path gitdir 	express implied 
head detached 	warranties including 
list path dir 	limited 
alloc linked 	implied warranties 
symref target existing 	merchantability fitness 
path worktrees 	particular purpose 
free free free 	disclaimed shall 
free free 	copyright owner 
strbuf readlink starts 	contributors 
check refname 	liable direct 
format strbuf 	indirect incidental 
read file starts 	special exemplary 
strbuf strlen 	consequential damages 
strbuf trim check 	including limited 
refname format 	procurement 
sha hex resolve 	substitute goods 
strbuf detach 	services loss 
strbuf addf absolute 	use data 
path git 	profits business 
common dir strbuf 	interruption however 
addbuf strbuf 	caused 
strip suffix strbuf 	theory liability 
strip suffix 	whether contract 
strbuf addf git 	strict liability 
common dir 	tort including 
parse xmalloc strbuf 	negligence otherwise 
detach strbuf 	arising 
detach head info 	way use 
strbuf release 	software even 
strbuf release 	advised possibility 
strbuf release strbuf 	damage valgrind.c 
release die 	ptr usize 
strbuf addf absolute 	ptr 
path git 	usize ptr 
common dir strbuf 	usize ptr 
addf strbuf 	usize valgrind 
read file strbuf 	make mem 
rtrim strbuf 	noaccess valgrind 
strip suffix strbuf 	make 
reset strbuf 	mem undefined 
addstr absolute path 	valgrind make 
strbuf strip 	mem defined 
suffix strbuf reset 	valgrind freelike 
strbuf addf 	block valgrind.h 
git common dir 	ptr 
parse xmalloc 	usize ptr 
strbuf detach strbuf 	usize ptr 
detach head 	usize ptr 
info strbuf 	usize size 
release strbuf release 	reported valgrind 
strbuf release 	must 
strbuf release xmalloc 	consistent chain 
main worktree 	malloc realloc 
strbuf addf git 	realloc calls 
common dir 	request size 
opendir strbuf release 	isn recorded 
readdir strcmp 	anywhere 
strcmp linked worktree 	jemalloc critical 
alloc grow 	callers macros 
closedir alloc grow 	provide usize 
worktrees strbuf 	rather request 
reset strbuf reset 	size result 
strbuf addf 	buffer 
parse strcmp xstrdup 	overflow detection 
strbuf release 	technically weakened 
strbuf release 	standard api 
free worktrees read 	though generally 
path also 	accepted practice 
detached detached detatched 	consider 
detached git 	extra bytes 
common dir symref 	reported malloc 
head practically 	usable size 
outside git dir 	usable space 
linked worktrees 	valgrind malloclike 
resolve won work 	block 
uses git 	valgrind resizeinplace 
path parse proper 	block macro 
otherwise success 	calls must 
head symbolic link 	embedded macros 
textual symref 	rather functions 
detached head sha 	valgrind 
head detached 	reports errors 
given worktree main 	extra stack 
worktree invalid 	frames backtraces 
gitdir file 	jemalloc types 
repo moved manually 	jemalloc structs 
accessed since 	jemalloc 
refname branch commit 	externs jemalloc 
branch must 	inlines version.h 
commit incomplete repo 	windows extrah 
prune won 	msvc compat 
unlock preparation keep 	windows extra 
resolve happy 	xallocx.c 
need valid head 	tsz tsz 
git directory 	tsz cmd 
reject directory looks 	ret cmd 
like since 	ind ret 
immediately replaced symbolic 	mib miblen 
update invocation 	ind 
worktree worktree usage 	ind ind 
force detach 	small hugemax 
branch force branch 	small hugemax 
show verbose 	small small 
expire reason 	hugemax smallmax 
path len link 	large 
reason path 	large large 
dir ret prefix 	huge hugemax 
options junk 	largemax huge 
work junk git 	huge huge 
dir junk 	hugemax len 
junk pid signo 	range 
path olen 	offset len 
name len path 	err szmin 
refname opts 	szmax nsz 
repo name child 	large largemax 
env len 	huge huge 
ret symref commit 	mallocx 
prefix opts 	ptr sallocx 
branch force path 	xallocx dallocx 
branch options 	mallocx ptr 
symref path maxlen 	sallocx xallocx 
abbrev len 	dallocx mallocx 
cur path 	ptr 
len path adj 	sallocx xallocx 
abbrev maxlen 	dallocx mallctl 
sha len path 	nsizes impl 
len prefix 	nsizes impl 
porcelain options worktrees 	nsizes impl 
prefix options 	mallctlnametomib 
directory git path 	mallctlbymib size 
strbuf addf 	impl size 
file exists git 	impl size 
path stat 	impl small 
git path strbuf 	size huge 
addf open 	size 
git path strbuf 	nhuge mallocx 
addf strerror 	ptr xallocx 
xmallocz read full 	xallocx xallocx 
close strbuf 	xallocx dallocx 
addf free file 	small size 
exists free 	huge 
stat git 	size nhuge 
path strbuf addf 	mallocx ptr 
free opendir 	xallocx xallocx 
git path readdir 	xallocx xallocx 
strcmp strcmp 	xallocx xallocx 
strbuf reset prune 	dallocx 
worktree strbuf 	small size 
reset strbuf addstr 	small size 
git path 	huge size 
dir recursively unlink 	nhuge mallocx 
error strerror 	ptr xallocx 
closedir rmdir git 	xallocx 
path strbuf 	xallocx xallocx 
release strbuf release 	xallocx dallocx 
parse options 	small size 
usage options prune 	nsmall large 
worktrees getpid 	size large 
strbuf addstr 	size 
dir recursively strbuf 	large size 
reset strbuf 	huge size 
addstr dir recursively 	huge size 
strbuf release 	nhuge mallocx 
junk sigchain pop 	ptr xallocx 
strlen dir 	xallocx 
sep dir sep 	xallocx xallocx 
file exists 	xallocx xallocx 
empty dir die 	xallocx xallocx 
strbuf check 	xallocx xallocx 
branch exists die 	xallocx xallocx 
lookup commit 	xallocx 
reference name die 	xallocx xallocx 
worktree basename 	xallocx xallocx 
strbuf addstr git 	dallocx large 
path safe 	size nlarge 
create leading directories 	huge size 
die errno 	huge 
stat strbuf 	size huge 
setlen strbuf addf 	size huge 
strrchr getpid 	size nhuge 
atexit sigchain push 	mallocx ptr 
common mkdir 	xallocx xallocx 
die errno xstrdup 	xallocx 
strbuf addf 	xallocx xallocx 
write file strbuf 	xallocx xallocx 
addf safe 	xallocx xallocx 
create leading directories 	xallocx xallocx 
die errno 	xallocx xallocx 
xstrdup strbuf reset 	xallocx 
strbuf addf 	xallocx xallocx 
write file real 	xallocx dallocx 
path write 	malloc malloc 
file real path 	malloc print 
git common 	filled extents 
dir strbuf reset 	mallocx 
strbuf addf 	ptr validate 
write file 	fill memset 
strbuf reset strbuf 	validate fill 
addf write 	xallocx validate 
file argv pushf 	fill nallocx 
argv pushf 	xallocx 
memset argv pushl 	validate fill 
oid hex 	validate fill 
argv pushl run 	memset validate 
command argv 	fill dallocx 
clear argv pushl 	large size 
run command 	large 
free free strbuf 	size nlarge 
reset strbuf 	test zero 
addf unlink warn 	huge size 
argv clear 	huge size 
strbuf release strbuf 	test zero 
release strbuf 	test 
release strbuf release 	size classes 
memset parse 	test smallest 
options die 	supported size 
usage options prefix 	test largest 
filename strlen 	supported size 
strbuf check branch 	test 
exists die 	size overflow 
strbuf release worktree 	size classes 
basename xstrndup 	test overflows 
memset argv push 	resolved clamping 
argv push 	extra test 
argv push argv 	overflow 
push run 	hugemax size 
command worktree sha 	underflows size 
hex strlen 	classes test 
utf strwidth strbuf 	size extra 
addf strbuf 	overflow size 
addstr strbuf addf 	classes 
find unique 	test size 
abbrev strbuf 	decrease zero 
addf shorten unambiguous 	extra test 
strbuf addstr 	size decrease 
strbuf release strlen 	non zero 
strlen find 	extra 
unique abbrev parse 	test size 
options usage 	increase zero 
options worktrees measure 	extra test 
widths show 	size increase 
worktree porcelain show 	non zero 
worktree free 	extra 
worktrees usage options 	test size 
strcmp strcmp 	increase non 
prune strcmp list 	zero extra 
usage options 	test size 
read path also 	extra overflow 
detached detached 	size 
detatched detached git 	classes test 
common dir 	size decrease 
symref head 	zero extra 
practically outside git 	test size 
dir linked 	decrease non 
worktrees resolve won 	zero 
work uses 	extra test 
git path parse 	size increase 
proper otherwise 	zero extra 
success head symbolic 	test size 
link textual 	increase non 
symref detached head 	zero 
sha head 	extra test 
detached given worktree 	size increase 
main worktree 	non zero 
invalid gitdir file 	extra test 
repo moved 	size extra 
manually accessed since 	overflow 
refname branch 	fill non 
commit branch must 	zero non 
commit incomplete 	debug builds 
repo prune 	likely detect 
won unlock preparation 	errors shrink 
keep resolve 	place 
happy need valid 	expect growing 
head git 	place succeed 
directory reject directory 	size classes 
looks like 	size classes 
since immediately replaced 	zero.c malloc 
symbolic update 	conf 
invocation worktree worktree.h 	min max 
path git 	prev mallocx 
dir head head 	ptr sallocx 
sha detached 	xallocx rallocx 
bare worktree symref 	ptr dallocx 
target functions 	test 
acting information worktrees 	skip test 
worktrees primary 	zero test 
worktree always first 	skip test 
returned linked 	zero test 
worktrees pointed 	skip test 
next subsequent worktree 	zero 
specific ordering 	test ziplist.c 
done linked worktrees 	encoding encoding 
caller responsible 	rawlen buf 
freeing memory returned 	len len 
worktree free 	len prevlensize 
memory worktree check 	prevlensize 
per worktree 	encoding lensize 
symref points main 	len entry 
worktree linked 	entrylen encoding 
worktree path exising 	encoding encoding 
worktree returns 	ret bytes 
existing caller responsible 	len 
freeing returned 	rawlen rawlensize 
path wrapper.c size 	offset noffset 
size gentle 	extra cur 
limit routine 	next num 
old str ret 	totlen deleted 
size gentle 	offset 
ret size size 	nextdiff first 
gentle ret 	tail slen 
size size data 	reqlen prevlensize 
len str 	prevlen offset 
len ptr size 	nextdiff 
ret nmemb 	encoding tail 
size ret path 	ptail first 
oflag mode 	second first 
buf len pfd 	bytes first 
buf len 	len second 
buf len offset 	bytes 
buf count 	second len 
total loaded buf 	append source 
count total 	target target 
written buf count 	bytes source 
offset total 	bytes zlbytes 
loaded ret 	zllength 
path mode mode 	first offset 
stream path 	second offset 
ret origtemplate saved 	slen index 
errno nonrelative 	prevlensize prevlen 
path len tmp 	prevlensize prevlen 
path len 	sstr 
suffix len tmp 	slen sval 
pattern suffix 	entry slen 
len mode letters 	offset index 
num letters 	num sstr 
len count pattern 	slen entry 
mode pattern 	sencoding 
suffix len mode 	zval sval 
origtemplate saved 	vstr vlen 
errno nonrelative file 	skip skipcnt 
err file 	vencoding vll 
err file file 	prevlensize encoding 
mode file 	lensize 
path err 	len len 
flag path mode 	index entry 
flag ret 	buf pos 
path mode flag 	num maxsize 
ret dst 	dnum posstr 
max fmt len 	start 
path fatal 	vstr vlen 
fmt err path 	vlong target 
fmt status 	min max 
path fmt status 	len minval 
millisec git 	maxval len 
env error die 	argc 
strdup free 	argv entry 
routine strlen strdup 	elen buf 
die memory 	len len 
limit check malloc 	buf buflen 
malloc free 	refnode sstr 
routine malloc malloc 	slen 
die error 	sval zip 
memset xmalloc 	str memcpy 
overflows error die 	memcpy memrev 
xmalloc xmallocz 	ifbe memcpy 
xmallocz memcpy xmallocz 	memrev ifbe 
memchr xmemdupz 	zip 
memory limit check 	decode prevlensize 
realloc realloc 	zip prev 
free routine realloc 	encode length 
realloc die 	zip decode 
mult overflows die 	prevlensize zip 
memory limit 	decode 
check calloc calloc 	length memcpy 
free routine 	memrev ifbe 
calloc calloc die 	memrev ifbe 
start arg 	memcpy memcpy 
end open die 	memrev ifbe 
errno die 	memcpy 
errno die errno 	memrev ifbe 
read poll 	memcpy memrev 
write pread 	ifbe memcpy 
xread xwrite xpread 	memrev ifbe 
dup die 	memcpy memrev 
errno fopen die 	ifbe 
errno die 	memcpy memrev 
errno die errno 	ifbe zip 
fdopen die 	decode prevlen 
errno fopen unlink 	zip decode 
fopen strlcpy 	length zmalloc 
mkstemp strlen strlen 	ziplist 
absolute path 	bytes intrev 
die errno getenv 	ifbe ziplist 
snprintf mkstemp 	tail offset 
getenv snprintf mkstemps 	intrev ifbe 
strlen strncmp 	ziplist length 
gettimeofday size getpid 	zrealloc 
open git 	ziplist bytes 
mkstemps mode 	intrev ifbe 
git mkstemps mode 	intrev ifbe 
strlcpy git 	ziplist bytes 
mkstemp mode absolute 	zip entry 
path die 	zip 
errno warning strerror 	prev encode 
unlink strbuf 	length zip 
addf strerror warn 	entry ziplist 
unremovable unlink 	resize intrev 
warn unremovable rmdir 	ifbe ziplist 
isgitlink rmdir 	tail 
warn unlink warn 	offset ziplist 
warning strerror 	tail offset 
access access error 	intrev ifbe 
warn inaccessible 	intrev ifbe 
access access error 	ziplist tail 
die errno 	offset 
strbuf getcwd die 	memmove zip 
errno strbuf 	prev encode 
detach start 	length zip 
vsnprintf end die 	prev encode 
die open 	length force 
die errno strbuf 	large 
vaddf strbuf 	zip prev 
complete line write 	encode length 
full close 	zip entry 
strbuf release die 	zip raw 
errno strbuf 	entry length 
release close die 	zip 
errno start 	prev len 
write file end 	diff zip 
start write 	prev encode 
file end poll 	length ziplist 
various trivial 	tail offset 
helper wrappers around 	intrev 
standard functions 	ifbe intrev 
xmemdupz allocates len 	ifbe ziplist 
bytes memory 	tail offset 
duplicates len 	zip entry 
bytes data allocated 	ziplist tail 
memory zero 	offset 
terminates allocated memory 	intrev ifbe 
returns pointer 	intrev ifbe 
allocated memory allocation 	ziplist tail 
fails program 	offset memmove 
dies limit size 	intrev ifbe 
chunks huge 	ziplist 
chunks cause pain 	bytes ziplist 
bit buggy 	tail offset 
returning einval len 	intrev ifbe 
max even 	ziplist resize 
absence bugs large 	intrev ifbe 
chunks result 	ziplist 
bad latencies decide 	bytes ziplist 
kill process 	incr length 
pick platform defines 	ziplist cascade 
ssize max 	update intrev 
smaller clip 	ifbe ziplist 
ssize max call 	bytes 
read write 	zip decode 
larger allowed fail 	prevlen ziplist 
last resort 	entry tail 
allow port pass 	zip raw 
via cflags 	entry length 
dmax size definition 	zip 
ssize max 	encoding zip 
given platform broken 	size zip 
xopen open 	prev encode 
die open fails 	length zip 
arg undefined 	encode length 
behavior specified type 	zip 
compatible argument 	prev len 
type since integers 	diff ziplist 
promoted ints 	resize memmove 
fetch next 	zip prev 
argument cast mode 	encode length 
avoid undefined 	ziplist 
behavior xread read 	tail offset 
automatically restarts 	intrev ifbe 
read operations recoverable 	intrev ifbe 
error eagain 	ziplist tail 
eintr xread guarantee 	offset zip 
len bytes 	entry 
read even data 	ziplist tail 
available poll 	offset intrev 
failed want infinite 	ifbe intrev 
loop read 	ifbe ziplist 
returns success expected 	tail offset 
failure would 	ziplist 
next call read 	tail offset 
xwrite write 	intrev ifbe 
automatically restarts write 	ziplist cascade 
operations recoverable 	update zip 
error eagain 	prev encode 
eintr xwrite guarantee 	length 
len bytes 	zip encode 
written even operation 	length zip 
successful xpread 	str memcpy 
pread automatically restarts 	zip save 
pread operations 	integer ziplist 
recoverable error eagain 	incr 
eintr xpread 	length intrev 
guarantee len bytes 	ifbe ziplist 
read even 	bytes intrev 
data available xfopen 	ifbe ziplist 
fopen die 	length intrev 
fopen fails git 	ifbe 
mkstemp create 	ziplist bytes 
tmp file honoring 	intrev ifbe 
tmpdir variable 	ziplist length 
git mkstemps create 	intrev ifbe 
tmp file 	ziplist tail 
suffix honoring 	offset 
tmpdir variable adapted 	intrev ifbe 
libiberty mkstemp 	ziplist tail 
replace pattern xxxxxx 	offset zrealloc 
characters randomness 	memcpy memmove 
tmp max different 	memcpy ziplist 
filenames fill 	bytes 
random bits fatal 	intrev ifbe 
error eperm 	ziplist length 
enospc etc doesn 	intrev ifbe 
make sense 	ziplist tail 
loop random necessary 	offset intrev 
next tmp 	ifbe 
max values generated 	ziplist cascade 
adding different 	update zfree 
module find unique 	zfree ziplist 
file name 	entry head 
mkstemp mkstemps suffix 	ziplist entry 
write-tree.c write 	end 
usage argc 	ziplist insert 
argv unused prefix 	ziplist entry 
ret prefix 	tail zip 
sha write options 	decode prevlen 
git config 	zip decode 
parse options write 	prevlen 
cache sha 	ziplist entry 
hex die die 	head zip 
die git 	raw entry 
information manager hell 	length zip 
copyright linus 	raw entry 
torvalds write diec 	length 
err desc 	ziplist entry 
skip stdout flush 	tail ziplist 
fmt ret 	entry head 
msg buf count 	zip decode 
buf count 	prevlen zip 
msg buf 	entry 
count msg exit 	zip str 
signal exit 	zip load 
getenv atoi fstat 	integer ziplist 
fileno isreg 	insert ziplist 
ferror fflush check 	ziplist index 
pipe die 	ziplist 
errno start vfprintf 	zip entry 
end check 	zip str 
pipe die errno 	memcmp zip 
fsync die 	encoding zip 
errno write full 	load integer 
check pipe 	zip 
die errno write 	decode prevlensize 
full check 	zip decode 
pipe strerror write 	length zip 
full strerror 	str memcmp 
never happen cases 	zip encoding 
use stdio 	zip 
want flush 	load integer 
write error handling 	intrev ifbe 
better interactive 	ziplist length 
behaviour buffering excessively 	intrev ifbe 
course flush 	ziplist length 
happened within write 	zip 
already lost 	raw entry 
error code cannot 	length ziplist 
report ignore 	length intrev 
instead hope right 	ifbe intrev 
error code 	ifbe ziplist 
flush file handle 	bytes 
stdout stdout 	intrev ifbe 
file skip flush 	ziplist bytes 
entirely since 	intrev ifbe 
needed ws.c rule 	ziplist length 
name rule 	intrev ifbe 
bits rule len 	ziplist 
negated tabwidth 	tail offset 
check attr 	ziplist entry 
whitespace pathname attr 	head zip 
whitespace rule 	entry zip 
rule err line 	str fwrite 
len rule 	perror 
stream reset result 	fwrite perror 
written trailing 	zip load 
whitespace trailing newline 	integer ziplist 
trailing carriage 	ziplist push 
line len rule 	ziplist push 
stream reset 	ziplist 
line len rule 	push ziplist 
line len 	push ziplist 
rule dst src 	sprintf ziplist 
len rule 	push strlen 
error count tail 	sprintf ziplist 
tail last 	push 
tab indent last 	strlen sprintf 
space indent 	ziplist push 
need fix 	strlen sprintf 
leading space consecutive 	ziplist push 
spaces last 	strlen sprintf 
start last strspn 	ziplist 
strchrnul size 	push strlen 
strncmp strncmp atoi 	sprintf ziplist 
warning die 	push strlen 
git attr setup 	gettimeofday ziplist 
whitespace attr 	ziplist push 
check git check 	usec 
attr attr 	ziplist push 
tab width size 	ziplist range 
attr tab 	intrev ifbe 
width attr unset 	ziplist bytes 
parse whitespace 	usec zfree 
rule strbuf addstr 	ziplist 
strbuf addstr 	index ziplist 
strbuf addstr strbuf 	fwrite perror 
addstr strbuf 	ziplist exit 
addstr strbuf 	rand rand 
addstr strbuf addstr 	rand ziplist 
strbuf addstr 	len 
strbuf addstr strbuf 	ziplist entry 
addstr strbuf 	zero memset 
detach isspace fputs 	zip entry 
fwrite fputs 	ziplist index 
fwrite fwrite fputs 	memset zip 
fwrite fputs 	entry 
fwrite tab width 	ziplist index 
fputs fwrite 	memcmp srand 
fputs fputs fwrite 	atoi create 
fputs fputs 	list ziplist 
fwrite fputs fputc 	repr zfree 
fputc check 	create 
emit check emit 	list ziplist 
isspace isspace 	repr pop 
isspace tab 	ziplist repr 
width strbuf addch 	pop ziplist 
tab width 	repr pop 
strbuf addch strbuf 	ziplist 
addch tab 	repr pop 
width strbuf addch 	ziplist repr 
strbuf addch 	zfree create 
strbuf strbuf addch 	list ziplist 
strbuf addch 	index ziplist 
whitespace rules copyright 	fwrite 
junio hamano 	perror zfree 
whitespace whitespace reset 	create list 
whitespace returned 	ziplist index 
freed caller stream 	zfree create 
non emits 	list ziplist 
line checking logic 	index 
simpler temporarily 	ziplist fwrite 
ignore trailing newline 	perror zfree 
check trailing 	create list 
whitespace check 	ziplist index 
indentation check indent 	ziplist fwrite 
non tab 	perror 
rest line starts 	zfree create 
written non 	list ziplist 
highlighted part ends 	index zfree 
trailing whitespace 	create list 
emit non highlighted 	ziplist index 
middle segment 	ziplist 
highlight errors trailing 	fwrite perror 
whitespace might 	ziplist next 
want treat differently 	zfree create 
whitespace characters 	list ziplist 
rule eol use 	index ziplist 
stupid definition 	fwrite 
copy line onto 	perror ziplist 
end strbuf 	next zfree 
fixing whitespaces len 	create list 
number bytes 	ziplist index 
copied src 	ziplist fwrite 
starting src typically 	perror 
src len 	ziplist next 
unless incomplete last 	zfree create 
line strip 	list ziplist 
trailing whitespace check 	index ziplist 
leading whitespaces 	zfree create 
indent process indent 	list 
last point 	ziplist index 
one past indent 	ziplist fwrite 
src last 	perror ziplist 
strip funny spaces 	prev zfree 
updating tab 	create list 
needed expand tabs 	ziplist 
spaces wt-status.c 	index ziplist 
cut line status 	fwrite perror 
colors slot 	ziplist ziplist 
bol color fmt 	prev zfree 
trail linebuf 	create list 
line eol 	ziplist 
color fmt color 	range ziplist 
fmt color 	repr zfree 
fmt sha del 	create list 
mod conflict 	ziplist range 
deleted deleted deleted 	ziplist repr 
dirty submodules 	zfree 
stagemask status label 	create list 
minval maxval 	ziplist range 
len onebuf padding 	ziplist repr 
label width 	zfree create 
one len change 	list ziplist 
type status 	range 
one name two 	ziplist repr 
name one 	zfree create 
two twobuf extra 	list ziplist 
padding label 	range ziplist 
width len 	repr zfree 
options data path 	create 
pos mask 	list ziplist 
options data rev 	index ziplist 
rev opt 	strncmp ziplist 
dir begin ent 	fwrite perror 
ent shown 	ziplist next 
header shown header 	ziplist 
dirty submodules 	repr zfree 
changes dirty submodules 	memset memset 
worktree changes 	ziplist ziplist 
uncommitted summary cmd 	push strlen 
stdout summary 	ziplist push 
summary content len 	strlen 
buf output 	ziplist index 
copts path buf 	ziplist strncmp 
pattern explanation 	ziplist index 
buf rev opt 	ziplist strncmp 
dirty submodules 	zfree memset 
branch name 	ziplist 
branch comment line 	ziplist push 
state color 	strlen verify 
state color filename 	ziplist verify 
buf split 	zfree ziplist 
progress head orig 	sprintf ziplist 
head rebase 	push 
amend rebase orig 	ziplist index 
head line 	ziplist ziplist 
split sha abbrev 	index ziplist 
fname lines 	zfree create 
line state color 	list ziplist 
lines show 	index 
done yet state 	ziplist compare 
color state 	ziplist compare 
color state color 	ziplist index 
state color 	ziplist compare 
state color path 	ziplist 
sha branch 	compare zfree 
name abbrev 	create list 
buf nsha osha 	create list 
nsha email 	ziplist ziplist 
timestamp message data 	ziplist merge 
end state 	ziplist 
commit sha state 	merge ziplist 
detached sha 	repr ziplist 
state state color 	len zfree 
branch color 	ziplist merge 
branch status color 	ziplist repr 
state branch 	ziplist 
name onebuf one 	len ziplist 
onebuf one 	len ziplist 
sign onebuf one 	index ziplist 
branch header 	compare ziplist 
color branch color 	compare ziplist 
local branch 	index 
color remote branch 	ziplist compare 
name num 	ziplist compare 
num upstream 	ziplist index 
gone want color 	ziplist compare 
color nil 	ziplist compare 
strbuf vaddf strbuf 	ziplist 
addch strbuf 	index ziplist 
addch color print 	compare ziplist 
strbuf strbuf 	compare zfree 
release strchr strbuf 	ziplist list 
reset strbuf 	create list 
addch strbuf addch 	free 
strbuf strbuf 	method rand 
addstr color print 	rand rand 
strbuf strbuf 	randstring rand 
release strbuf release 	sprintf rand 
start status 	sprintf rand 
vprintf end start 	sprintf 
status vprintf 	rand ziplist 
end start status 	push list 
vprintf end 	node head 
memset memcpy 	sdsnewlen list 
resolve refdup index 	node tail 
file color 	sdsnewlen 
status status status 	list length 
status status 	ziplist len 
status status status 	ziplist index 
color status 	list index 
status status status 	ziplist sprintf 
color status 	memcpy 
status status status 	memcmp list 
status status 	node zfree 
color status status 	list release 
status status 	stress stress 
color die label 	ziplist specially 
utf strwidth 	encoded 
color maxwidth strlen 	dually linked 
xmallocz memset 	list designed 
quote path 	memory efficient 
status color status 	stores integer 
unmerged status 	values integers 
utf strwidth status 	encoded 
strbuf release 	actual integers 
color maxwidth strlen 	instead series 
xmallocz memset 	characters allows 
strbuf addstr strbuf 	push pop 
addf strbuf 	operations either 
addf strbuf addf 	side 
strbuf setlen 	list time 
strbuf addch die 	however every 
quote path 	operation requires 
quote path status 	reallocation memory 
color status 	used ziplist 
diff status die 	actual 
utf strwidth 	complexity related 
status status status 	amount memory 
color strbuf 	used ziplist 
release status 	ziplist overall 
strbuf release strbuf 	layout general 
release list 	layout 
insert xcalloc isgitlink 	ziplist follows 
hashcmp cache 	zlbytes zltail 
name pos strlen 	zllen entry 
strcmp stage 	entry zlend 
stage list insert 	zlbytes integer 
xcalloc xstrdup 	hold 
unmerged mask init 	number bytes 
revisions setup 	ziplist occupies 
revisions diff opt 	needs stored 
diff opt 	able resize 
diff opt handle 	entire structure 
ignore submodules 	without 
arg copy pathspec 	need traverse 
run diff 	first zltail 
files init revisions 	offset last 
memset setup 	entry list 
revisions diff 	allows pop 
opt handle ignore 	operation 
submodules arg 	far side 
handle ignore submodules 	list without 
arg copy 	need full 
pathspec run diff 	traversal zllen 
index path 	number entries 
match list insert 	larger 
xcalloc stage 	need traverse 
stage getnanotime memset 	entire list 
setup standard 	know many 
excludes fill directory 	items holds 
cache name 	zlend single 
dir path match 	special 
list insert 	equal indicates 
free cache name 	end list 
dir path 	ziplist entries 
match list insert 	every entry 
free free 	ziplist prefixed 
free clear 	header 
directory getnanotime status 	contains two 
collect changes 	pieces information 
worktree status collect 	first length 
changes initial 	previous entry 
status collect changes 	stored able 
index status 	traverse 
collect untracked status 	list back 
print unmerged 	front second 
header status print 	encoding optional 
unmerged data 	length entry 
status print trailer 	stored length 
status print 	previous 
cached header status 	entry encoded 
print change 	following way 
data status print 	length smaller 
trailer status 	bytes consume 
check worktree 	single takes 
changes status print 	length 
dirty header 	length greater 
status print change 	equal consume 
data status 	bytes first 
print trailer argv 	indicate larger 
pushf argv 	following remaining 
push argv push 	bytes 
argv push 	take length 
argv push argv 	previous entry 
push argv 	header field 
pushf argv push 	entry depends 
capture command 	contents entry 
strbuf addstr strbuf 	entry 
addstr strbuf 	first bits 
addstr strbuf addbuf 	header hold 
strbuf release 	type encoding 
strbuf detach strbuf 	used store 
commented lines 	length followed 
free fputs 	actual 
strbuf release status 	length entry 
print header 	integer first 
quote path column 	bits following 
active list 	bits used 
append status color 	specify kind 
status color 	integer 
strbuf release column 	stored header 
active strbuf 	overview different 
addf color color 	types encodings 
memset want 	follows pppppp 
color print columns 	length less 
list clear 	equal 
strbuf release status 	bytes bits 
strbuf addf 	pppppp qqqqqqqq 
starts strbuf setlen 	bytes length 
strstr strbuf 	less equal 
setlen strbuf release 	bytes bits 
strbuf commented 	qqqqqqqq 
lines strlen 	rrrrrrrr ssssssss 
fputs strbuf release 	tttttttt bytes 
color init 	length greater 
revisions diff opt 	equal bytes 
memset setup 	integer encoded 
revisions status cut 	bytes 
line status 	integer encoded 
print trailer status 	bytes integer 
run diff 	encoded bytes 
index status check 	integer encoded 
worktree changes 	bit bytes 
status status setup 	integer 
work run 	encoded bit 
diff files skip 	xxxx xxxx 
prefix branch 	immediate bit 
format tracking info 	integer integer 
strchr color 	encoded actually 
color color color 	used 
fputs unmerged 	subtracted encoded 
status status 	bit obtain 
status status status 	right end 
print trailer 	ziplist integers 
status status status 	represented little 
status status 	endian 
status print trailer 	order copyright 
fopen git 	pieter noordhuis 
path strbuf release 	pcnoordhuis gmail 
strbuf getline 	dot copyright 
fclose strbuf detach 	salvatore sanfilippo 
strbuf release 	antirez 
read line git 	gmail dot 
path read 	rights reserved 
line git path 	redistribution use 
read line 	source binary 
git path read 	forms without 
line git 	modification 
path strcmp 	permitted provided 
strcmp strcmp strcmp 	following conditions 
free free 	met redistributions 
free free starts 	source code 
starts strbuf 	must retain 
split max strbuf 	copyright 
trim sha 	notice list 
find unique abbrev 	conditions following 
strbuf reset 	disclaimer redistributions 
strbuf addf strbuf 	binary form 
reset strbuf 	must reproduce 
addf strbuf release 	copyright 
fopen git 	notice list 
path die errno 	conditions following 
git path 	disclaimer documentation 
strbuf getline strbuf 	materials provided 
trim abbrev 	distribution neither 
sha line list 	name 
append read 	redis names 
rebase todolist 	contributors may 
read rebase todolist 	used endorse 
status status 	promote products 
status status git 	derived software 
path status 	without 
status status status 	specific prior 
list clear 	written permission 
list clear status 	software provided 
status show 	copyright holders 
rebase information unmerged 	contributors express 
print rebase 	implied 
state status status 	warranties including 
status stat 	limited implied 
git path merge 	warranties merchantability 
msg print 	fitness particular 
rebase state status 	purpose disclaimed 
split commit 	shall 
progress status status 	copyright owner 
status status 	contributors liable 
status status 	direct indirect 
status status print 	incidental special 
trailer status 	exemplary consequential 
find unique abbrev 	damages 
unmerged status 	including limited 
status status status 	procurement substitute 
print trailer 	goods services 
status find unique 	loss use 
abbrev unmerged 	data profits 
status status status 	business 
status print 	interruption however 
trailer status status 	caused theory 
status status 	liability whether 
print trailer strbuf 	contract strict 
read file 	liability tort 
git path strbuf 	including 
setlen skip 	negligence otherwise 
prefix strbuf starts 	arising way 
sha hex 	use software 
find unique 	even advised 
abbrev strbuf reset 	possibility damage 
strbuf addstr 	different 
strcmp strbuf detach 	encoding length 
strbuf release 	possibilities bit 
skip prefix strstr 	integer immediate 
strlen strbuf 	encoding macro 
reset hashcpy strchrnul 	determine type 
strbuf strcmp 	utility 
strbuf reset strbuf 	macros know 
addstr find 	positive increment 
unique abbrev strbuf 	entries pushed 
init reflog 	one time 
ent reverse strbuf 	extract encoding 
release dwim 	pointed 
hashcmp lookup commit 	ptr encoding 
reference gently 	bytes needed 
hashcmp skip prefix 	store integer 
skip prefix 	encoded encoding 
xstrdup xstrdup 	bit immediate 
find unique abbrev 	encode 
hashcpy sha 	length rawlen 
hashcmp free strbuf 	writing returns 
release stat 	amount bytes 
git path merge 	required encode 
head stat 	length although 
git path stat 	encoding 
git path 	given may 
stat git path 	determine raw 
read strip 	length implies 
branch read strip 	integer encoding 
branch stat 	length always 
git path stat 	store 
git path 	length decode 
read strip branch 	length encoded 
read strip 	ptr encoding 
branch stat 	variable hold 
git path cherry 	entries encoding 
pick head 	lensize 
sha hashcpy stat 	variable hold 
git path 	number bytes 
read strip branch 	required encode 
stat git 	entries length 
path revert head 	len variable 
sha hashcpy 	hold 
status detached color 	entries length 
show merge 	encode length 
progress show progress 	previous entry 
show rebase 	write number 
progress show cherry 	bytes needed 
pick progress 	encode 
show revert progress 	length encode 
show bisect 	length previous 
progress color color 	entry write 
memset status 	uses larger 
state strcmp 	encoding required 
strcmp color skip 	ziplist 
prefix status 	cascade update 
color status status 	decode number 
status print 	bytes required 
tracking status print 	store length 
state free 	previous element 
free free status 	perspective 
color status 	entry pointed 
color status color 	ptr decode 
status print 	length previous 
updated status print 	element perspective 
unmerged status 	entry pointed 
print changed strcmp 	ptr 
status print 	difference number 
submodule summary status 	bytes needed 
print submodule 	store length 
summary status print 	previous element 
status print 	len entry 
status status 	pointed 
status status print 	total number 
verbose status 	bytes used 
color color quote 	entry pointed 
path strbuf 	check pointed 
release color color 	entry encoded 
putchar color 	integer 
color putchar putchar 	stores integer 
quote path 	encoding encoding 
strchr putchar strbuf 	great encoded 
addch strbuf 	check smallest 
release quote path 	encoding types 
strchr putchar 	hold 
strbuf addch strbuf 	store integer 
release quote 	encoded encoding 
path color color 	nothing stored 
strbuf release 	encoding read 
color color color 	integer encoded 
color color 	encoding 
color strcmp 	information entry 
color color skip 	create empty 
prefix branch 	ziplist resize 
color stat tracking 	ziplist entry 
info shorten 	inserted need 
unambiguous color color 	prevlen 
free color 	field next 
color label color 	entry equal 
label color 	length inserted 
color label color 	entry occur 
color label 	length cannot 
color color label 	encoded 
color color 	next entry 
fputc shortstatus print 	needs grow 
tracking shortstatus 	bit larger 
unmerged shortstatus status 	hold encoded 
shortstatus shortstatus 	prevlen done 
shortstatus print 	free 
status header status 	happens entry 
updated status 	already inserted 
changed status untracked 	causes realloc 
status nobranch 	memmove however 
status unmerged status 	encoding prevlen 
local branch 	may 
status remote branch 	require entry 
status onbranch 	grown well 
unspecified needswork use 	effect may 
git reset 	cascade throughout 
unresolve diff status 	ziplist consecutive 
uses outside 	entries 
range trouble unless 	size close 
user explicitly 	zip biglen 
request submodule ignore 	need check 
mode passing 	prevlen encoded 
command line option 	every consecutive 
ignore changed 	entry 
submodule sha 	note effect 
comparing index head 	also happen 
matter configured 	reverse bytes 
otherwise user won 	required encode 
shown submodules 	prevlen field 
manually added staged 	shrink 
committed would 	effect deliberately 
really confusing change 	ignored cause 
change prepend 	flapping effect 
header actual output 	chain prevlen 
going stdout 	fields first 
definitely want color 	grown 
since going 	shrunk consecutive 
commit message file 	inserts rather 
even setting 	field allowed 
won work since 	stay larger 
isatty stdout 	necessary large 
want insert scissor 	prevlen 
line reliably 	field implies 
diff committing 	ziplist holding 
print updated printed 	large entries 
header use 	anyway pointer 
prefix per user 	points first 
config turn 	entry 
pick ccb message 	need updated 
pick message 	consecutive fields 
function assumes line 	may need 
contain useless 	update abort 
spaces command strbuf 	next entry 
split max 	abort 
left space trim 	prevlen changed 
abbreviation extract 	prevlen field 
branch information rebase 	next needs 
bisect rebase 	bytes hold 
bisect head relative 	raw length 
resolve right 	cur 
reflog entry sha 	current pointer 
commit match 	offset next 
without lookup 	element update 
perhaps sha tag 	tail offset 
dereference commit 	next 
staged unstaged nothing 	element tail 
deleted added 	element move 
deleted added deleted 	tail back 
added modified 	advance cursor 
wt-status.h worktree status 	would result 
index status 	shrinking 
stagemask head path 	want avoid 
initial branch 	rawlen available 
reference pathspec verbose 	bytes stop 
amend nowarn 	raw length 
use color gettext 	next changed 
display comment 	num 
prefix relative paths 	entries starting 
submodule summary 	returns pointer 
show ignored 	ziplist storing 
files ignore submodule 	prevrawlen entry 
arg color 	may increase 
palette colopts termination 	decrease 
show branch 	number bytes 
hints commitable workdir 	required compare 
dirty index 	current prevrawlen 
file prefix change 	always room 
untracked ignored 	store previously 
untracked merge progress 	stored 
progress empty 	entry deleted 
patch rebase progress 	update offset 
rebase interactive 	tail tail 
progress cherry pick 	contains one 
progress bisect 	entry need 
progress revert progress 	take 
detached branch 	nextdiff account 
onto detached detached 	well otherwise 
sha revert 	change size 
head sha 	prevlen doesn 
cherry pick head 	effect tail 
sha strbuf 	offset 
state detached color 	move tail 
fmt color 	front ziplist 
fmt commit originate 	entire tail 
normal commit 	deleted need 
came merge commit 	move memory 
came cherry 	resize 
pick computed processing 	update length 
individual sections 	nextdiff raw 
status xdiff-interface.c consume 	length next 
consume callback 	entry changed 
data remainder num 	need cascade 
num line 	update 
len priv size 	throughout ziplist 
priv size 	insert item 
priv nbuf priv 	initialized avoid 
ctx blk 	warning easy 
recovered smaller 	see reason 
xpp xecfg xecb 	use 
consume callback 	uninitialized find 
data xpp xecfg 	prevlen entry 
ret state 	inserted see 
ecb ptr filename 	entry encoded 
ptr sha 	encoding appropriate 
size ptr size 	integer 
negate line 	encoding encoding 
len buffer buffer 	untouched however 
size priv 	zip encode 
line buffer regs 	length use 
pmatch result 	length figure 
reg xecfg cflags 	encode 
regs reg 	need space 
expression buffer xecfg 	length previous 
regs git 	entry length 
xmerge style parse 	payload insert 
num error 	position equal 
parse num 	tail 
parse num parse 	need make 
num memcmp 	sure next 
memchr consume strbuf 	entry hold 
consume one 	entry length 
strbuf consume one 	prevlen field 
strbuf reset 	store 
consume one strbuf 	offset realloc 
reset memcmp 	may change 
trim common tail 	address apply 
xdl diff 	memory move 
memset memset strbuf 	necessary update 
init xdi 	tail 
diff strbuf release 	offset subtract 
stat error 	one zip 
fopen error xsize 	end bytes 
xmalloc fread 	encode entry 
fclose error fclose 	raw length 
hashcmp xstrdup 	next 
read sha 	entry update 
file die sha 	offset tail 
hex memchr 	tail contains 
xstrndup regexec isspace 	one entry 
memcpy free 	need take 
xmalloc alloc strchr 	nextdiff 
die xstrndup 	account well 
regcomp die free 	otherwise change 
regfree free 	size prevlen 
free strcmp die 	doesn effect 
strcmp strcmp 	tail offset 
die git config 	element 
incomplete line 	tail nextdiff 
complete line trim 	raw length 
common substring 	next entry 
end buffers least 	changed need 
ctx lines 	cascade update 
end exclude 	throughout 
terminating newline matching 	ziplist write 
make nul 	entry merge 
terminated xdiff-interface.h xpp 	ziplists first 
xecfg ecb 	second appending 
consume callback data 	second first 
xpp xecfg 	note 
line len ptr 	larger ziplist 
filename ptr 	reallocated contain 
sha ptr size 	merged ziplist 
xecfg line 	either first 
cflags xecfg git 	second used 
xmerge style 	result 
xdiff isn equipped 	parameter used 
handle content 	free calling 
gigabyte make cutoff 	function input 
give breathing 	parameters longer 
room constant sized 	valid since 
additions merge 	changed 
markers xdiff.h 	free place 
mmf size mmf 	result ziplist 
xpp xecfg 	contents first 
ecb orig xmp 	followed second 
result lib 	failure returns 
diff davide libenzi 	merge 
file differential 	impossible success 
library copyright davide 	returns merged 
libenzi library 	ziplist expanded 
free software redistribute 	version either 
modify terms 	first second 
gnu lesser general 	also 
license published 	frees unused 
free software foundation 	input ziplist 
either version 	sets input 
license option later 	ziplist argument 
version library 	equal newly 
distributed hope useful 	reallocated 
without warranty 	ziplist merge 
without even 	merge list 
implied warranty merchantability 	pick largest 
fitness particular 	ziplist resize 
purpose see gnu 	easily place 
lesser general 	must 
license details received 	also track 
copy gnu 	appending prepending 
lesser general license 	target ziplist 
along library 	retain first 
write free software 	append second 
foundation inc 	first 
temple place suite 	retain second 
boston usa 	prepend first 
davide libenzi davidel 	second calculate 
xmailserver ifdef 	bytes subtract 
cplusplus merge simplification 	one pair 
levels merge 	metadata 
favor modes merge 	combined length 
output styles 	limited within 
label orig 	max save 
label label ifdef 	offset positions 
cplusplus defined 	start ripping 
xdiff xdiffi.c lim 	memory 
lim kvdf 	apart extend 
kvdb need min 	target zlbytes 
spl xenv 	append prepend 
xscr chg chg 	source append 
lim lim 	appending target 
kvdf kvdb need 	copy 
min spl 	source target 
xenv dmax bmid 	copying original 
odd fmax 	end target 
bmax prev best 	end source 
got snake 	header append 
fbest fbest bbest 	prepending 
bbest lim 	target move 
lim kvdf 	target contents 
kvdb need min 	exactly size 
xenv rchg 	source end 
rindex rchg rindex 	copy source 
spl xpp 	vacataed 
ndiags kvd kvdf 	space source 
kvdb xenv 	end source 
xscr chg chg 	end target 
xch xdf 	header update 
xdfo flags ixo 	header metadata 
ixs ixref 	tail 
grpsiz nrec rchgo 	offset bytes 
recs xscr 	first ziplist 
xch rchg xscr 	end first 
xch xscr 	ziplist bytes 
ecb xecfg xch 	offset original 
xche xscr 	tail 
flags xch ignore 	second ziplist 
rec xpp 	bytes header 
xecfg ecb 	second offset 
xscr xdl min 	keeps header 
xdl max 	ziplist cascade 
xdl split xdl 	update 
recs cmp 	fixes prev 
xdl recs cmp 	length values 
xdf diff 	finds correct 
alg xdl patience 	prev length 
diff xdf 	assumes rest 
diff alg xdl 	list 
histogram diff 	okay tell 
xdl prepare env 	cascade update 
xdl malloc 	start first 
xdl free env 	ziplist tail 
xdl bogosqrt 	element fix 
xdl recs cmp 	merge 
xdl free 	seam free 
xdl free env 	didn realloc 
xdl free 	returns offset 
xdl malloc 	use iterating 
xdl recmatch xdl 	ziplist next 
recmatch xdl 	given 
change xdl free 	index negative 
script xdl 	list traversed 
free xdl hunk 	back front 
hunk func 	list doesn 
xdl blankline xdl 	contain element 
blankline xdl 	provided 
diff xdl change 	index returned 
compact xdl 	pointer next 
change compact xdl 	entry ziplist 
build script 	pointer ziplist 
xdl free env 	pointer current 
xdl mark 	element 
ignorable xdl free 	element returned 
script xdl 	otherwise end 
free env xdl 	could equal 
free script 	zip end 
xdl free 	caused ziplist 
env lib diff 	otherwise 
davide libenzi 	next element 
file differential library 	zip end 
copyright davide 	next entry 
libenzi library free 	pointer previous 
software redistribute 	entry ziplist 
modify terms gnu 	iterating 
lesser general 	backwards zip 
license published free 	end tail 
software foundation 	equal first 
either version license 	element list 
option later 	already head 
version library distributed 	entry 
hope useful 	pointed store 
without warranty without 	either sstr 
even implied 	sval depending 
warranty merchantability 	encoding entry 
fitness particular purpose 	sstr always 
see gnu 	able 
lesser general license 	find whether 
details received 	pointer integer 
copy gnu lesser 	points end 
general license 	ziplist otherwise 
along library write 	insert entry 
free software 	single 
foundation inc temple 	entry ziplist 
place suite 	pointed also 
boston usa davide 	update place 
libenzi davidel 	able iterate 
xmailserver see difference 	ziplist deleting 
algorithm variations 	entries 
eugene myers basically 	store pointer 
considers box 	current element 
lim lim scan 	ziplist realloc 
forward diagonal 	might result 
starting backward 	different pointer 
diagonal starting lim 	direction 
lim values 	back front 
diagonal crosses returns 	might last 
furthest point 	entry end 
reach might end 	pointing zip 
expensive cases 	end check 
algorithm full little 	range 
bit heuristic 	entries ziplist 
needed cut search 	compare entry 
suboptimal point 	pointer sstr 
initial diagonal values 	length slen 
forward backward 	equal raw 
path need extent 	compare 
diagonal domain 	compare encoded 
one next values 	values compare 
exits box 	encoding different 
boundaries need change 	implementations may 
opposite direction 	encoded integers 
max min 	differently 
must power two 	find pointer 
also initialize 	entry equal 
external avoid extra 	specified entry 
conditions check 	skip skip 
inside core loop 	entries every 
need extent 	comparison 
diagonal domain one 	returns field 
next values 	could found 
exits box boundaries 	compare current 
need change 	entry specified 
opposite direction max 	entry find 
min must 	searched 
power two also 	field encoded 
initialize external 	note first 
avoid extra conditions 	time done 
check inside 	vencoding non 
core loop edit 	zero vll 
cost heuristic 	integer 
trigger got 	entry encoded 
good snake sample 	uchar max 
current diagonals 	retry next 
see reached interesting 	time must 
path measure 	non zero 
function distance diagonal 	compare 
corner penalized 	current entry 
distance mid diagonal 	specified entry 
current edit 	vencoding uchar 
cost times magic 	max encoding 
factor xdl 	possible field 
heur consider interesting 	valid 
enough enough 	integer reset 
spent much time 	skip count 
collect furthest 	skip entry 
reaching path measure 	move next 
rule divide 	entry length 
impera recursively split 	ziplist 
box sub 	store length 
boxes calling 	small enough 
box splitting function 	ziplist blob 
note real 	size bytes 
job marking changed 	num times 
lines done 	push 
two boundary reaching 	pop pos 
checks shrink 	argument given 
box walking diagonal 	use random 
snake one 	seed pop 
dimension empty records 	values compare 
one must 	deleting 
obviously changed divide 	entry increase 
impera allocate 	prevrawlensize entry 
setup vectors used 	create list 
differential algorithm 	gives hello 
one store forward 	foo quux 
path one 	merge 
store backward 	two empty 
path gnu diff 	ziplists empty 
move back 	result back 
forward change groups 	merge gives 
consistent pretty 	hello foo 
diff output also 	quux 
helps finding 	hello foo 
joinable change groups 	quux hold 
reduce diff 	temp vars 
size find first 	ziplist create 
changed line 	lists ziplist 
compacted file need 	reference 
keep track 	list naive 
indexes find changed 	way elements 
lines file 	similar stresser 
scanning compacted file 	executed tcl 
need skip 	test suite 
properly note loops 	ziplist.h 
testing changed 	first second 
lines rchg 	slen index 
need index bounding 	sval slen 
since prepared 	lval slen 
zero position record 	index num 
start changed 	slen 
compacted file find 	vstr vlen 
end compacted 	skip argc 
file indexes ixo 	argv copyright 
line current 	pieter noordhuis 
change equal last 	pcnoordhuis gmail 
line current 	dot 
change shift backward 	copyright salvatore 
change might 	sanfilippo antirez 
joined two change 	gmail dot 
groups take 	rights reserved 
scenario account moving 	redistribution use 
start index 	source 
accordingly file end 	binary forms 
index record 	without modification 
end position 	permitted provided 
matched changes file 	following conditions 
change record 	met redistributions 
end index file 	source 
first line 	code must 
current change equal 	retain copyright 
line next 	notice list 
current change shift 	conditions following 
forward change 	disclaimer redistributions 
might joined two 	binary 
change groups 	form must 
take scenario account 	reproduce copyright 
moving start 	notice list 
index accordingly file 	conditions following 
end index 	disclaimer documentation 
keep tracking reference 	materials 
index shifting 	provided distribution 
together corresponding changes 	neither name 
file move 	redis names 
back possibly 	contributors may 
merged changes match 	used endorse 
recorded position 	promote 
file trivial collects 	products derived 
groups changes 	software without 
creates edit script 	specific prior 
xdiffi.h lim 	written permission 
lim kvdf kvdb 	software provided 
need min 	copyright 
xenv xpp xdf 	holders contributors 
xdfo flags 	express implied 
xscr xscr xscr 	warranties including 
ecb xecfg 	limited implied 
xpp env xpp 	warranties merchantability 
env lib 	fitness 
diff davide libenzi 	particular purpose 
file differential 	disclaimed shall 
library copyright 	copyright owner 
davide libenzi library 	contributors liable 
free software 	direct indirect 
redistribute modify terms 	incidental 
gnu lesser 	special exemplary 
general license published 	consequential damages 
free software 	including limited 
foundation either version 	procurement substitute 
license option 	goods services 
later version library 	loss 
distributed hope 	use data 
useful without warranty 	profits business 
without even 	interruption however 
implied warranty merchantability 	caused theory 
fitness particular 	liability 
purpose see gnu 	whether contract 
lesser general 	strict liability 
license details received 	tort including 
copy gnu 	negligence otherwise 
lesser general 	arising way 
license along library 	use 
write free 	software even 
software foundation inc 	advised possibility 
temple place 	damage ziplist 
suite boston usa 	zipmap.c len 
davide libenzi 	len key 
davidel xmailserver defined 	klen 
xdiffi xemit.c 	totlen llen 
xdf rec xdf 	free klen 
pre ecb 	vlen used 
xdf rec xdf 	len key 
pre ecb 	klen val 
size psize rec 	vlen 
xscr xecfg 	update zmlen 
xch xchp lxch 	offset freelen 
max common 	reqlen empty 
max ignorable ignored 	vempty key 
distance rec 	klen deleted 
len buf 	zmlen 
priv len buf 	freelen key 
xecfg func 	klen vlen 
line start limit 	key klen 
size step 	vlen key 
buf dummy rec 	klen len 
reclen len 	totlen 
xscr ecb xecfg 	argc argv 
lctx xch 	buf vlen 
xche funclineprev func 	vlen key 
line strlen 	klen vlen 
xdl rec xdl 	zmalloc memcpy 
emit diffrec 	memrev 
isalpha isspace memcpy 	ifbe zipmap 
xdl rec 	len bytes 
xdl hunk xdl 	memcpy memrev 
max xdl 	ifbe zipmap 
max func line 	decode length 
xdl min 	zipmap 
xdl min 	encode length 
func line func 	memcmp zipmap 
line func 	decode length 
line xdl emit 	zipmap encode 
hunk hdr 	length zipmap 
xdl emit record 	decode 
xdl emit 	length zipmap 
record xdl emit 	encode length 
record xdl 	zipmap decode 
emit record xdl 	length zipmap 
emit record 	encode length 
lib diff davide 	zipmap 
libenzi file 	raw key 
differential library copyright 	length zipmap 
davide libenzi 	raw length 
library free software 	zrealloc zipmap 
redistribute modify 	required length 
terms gnu 	zipmap 
lesser general license 	lookup raw 
published free 	zipmap resize 
software foundation either 	zipmap raw 
version license 	entry length 
option later version 	zipmap resize 
library distributed 	memmove 
hope useful without 	memmove zipmap 
warranty without 	resize zipmap 
even implied warranty 	encode length 
merchantability fitness 	memcpy zipmap 
particular purpose see 	encode length 
gnu lesser 	memcpy 
general license details 	zipmap lookup 
received copy 	raw zipmap 
gnu lesser general 	raw entry 
license along 	length memmove 
library write free 	zipmap resize 
software foundation 	zipmap 
inc temple 	decode length 
place suite boston 	zipmap len 
usa davide 	bytes zipmap 
libenzi davidel xmailserver 	raw key 
starting passed 	length zipmap 
change atom find 	decode 
latest change 	length zipmap 
atom included inside 	len bytes 
differential hunk 	zipmap raw 
according specified configuration 	length zipmap 
also advance 	lookup raw 
xscr first changes 	zipmap 
must discarded 	raw key 
number ignored blank 	length zipmap 
lines ignorable 	decode length 
changes far changes 	zipmap len 
also identifiers 	bytes zipmap 
vms esoterico overlap 	lookup 
next change 	raw zipmap 
include current 	rewind zipmap 
hunk start find 	next zipmap 
end emit 	lookup raw 
current hunk header 	zipmap decode 
emit pre 	length 
context merge previous 	zipmap encode 
current change 	length fwrite 
atom removes lines 	perror zipmap 
first file 	decode length 
adds lines second 	zipmap encode 
file emit 	length 
post context xemit.h 	fwrite perror 
xscr xecfg 	unused unused 
xscr ecb xecfg 	zipmap zipmap 
lib diff 	zipmap zipmap 
davide libenzi file 	zipmap repr 
differential library 	zipmap 
copyright davide libenzi 	zipmap zipmap 
library free 	zipmap repr 
software redistribute 	zipmap zipmap 
modify terms gnu 	repr zipmap 
lesser general 	zipmap zipmap 
license published free 	repr 
software foundation 	zipmap del 
either version license 	zipmap repr 
option later 	zipmap zipmap 
version library distributed 	zipmap zipmap 
hope useful 	rewind zipmap 
without warranty without 	next 
even implied 	map data 
warranty merchantability fitness 	structure optimized 
particular purpose 	size file 
see gnu lesser 	data structure 
general license 	mapping implementing 
details received copy 	lookup 
gnu lesser 	data structure 
general license along 	designed memory 
library write 	efficient redis 
free software 	hash type 
foundation inc temple 	uses data 
place suite 	structure 
boston usa davide 	hashes composed 
libenzi davidel 	small number 
xmailserver defined xemit 	elements hash 
xhistogram.c ptr 	table given 
cnt next rcha 	number elements 
next ptrs 	reached 
table bits records 	given many 
size line 	times redis 
map size max 	hashes used 
chain length 	represent objects 
key shift ptr 	composed fields 
shift cnt 	big 
common env xpp 	win terms 
begin end 	used memory 
begin end 	copyright salvatore 
xpp index line 	sanfilippo antirez 
count ptr 	gmail dot 
tbl idx chain 	rights 
len rec 	reserved redistribution 
chain rec index 	use source 
lcs ptr 	binary forms 
line count line 	without modification 
count next 	permitted provided 
rec index lcs 	following 
line count 	conditions met 
line count ptr 	redistributions source 
index line 	code must 
count line count 	retain copyright 
xpp xpp 	notice list 
env line count 	conditions 
line count 	following disclaimer 
index lcs result 	redistributions binary 
file file 	form must 
xpp env 	reproduce copyright 
xdl recmatch line 	notice list 
end table 	conditions 
hash cmp next 	following disclaimer 
ptr xdl 	documentation materials 
min line map 	provided distribution 
xdl cha 	neither name 
alloc line map 	redis names 
table hash 	contributors 
cmp cmp next 	may used 
ptr cmp 	endorse promote 
xdl min cnt 	products derived 
line end 	software without 
line end cmp 	specific prior 
xdl min 	written 
cnt next ptr 	permission software 
scan line 	provided copyright 
end lcs xdl 	holders contributors 
fall back 	express implied 
diff line 	warranties including 
end memset xdl 	limited 
hashbits xdl 	implied warranties 
malloc memset xdl 	merchantability fitness 
malloc memset 	particular purpose 
xdl malloc memset 	disclaimed shall 
xdl cha 	copyright owner 
init memset find 	contributors 
lcs fall 	liable direct 
back classic diff 	indirect incidental 
histogram diff 	special exemplary 
histogram diff line 	consequential damages 
end line 	including limited 
end xdl free 	procurement 
xdl free 	substitute goods 
xdl free xdl 	services loss 
cha free 	use data 
xdl prepare env 	profits business 
histogram diff 	interruption however 
copyright google 	caused 
inc copyright owners 	theory liability 
documented git 	whether contract 
log program accompanying 	strict liability 
materials made 	tort including 
available terms eclipse 	negligence otherwise 
distribution license 	arising 
accompanies distribution reproduced 	way use 
available http 	software even 
www eclipse documents 	advised possibility 
edl php 	damage memory 
rights reserved redistribution 	layout zipmap 
use source 	map 
binary forms without 	foo bar 
modification permitted 	hello world 
provided following conditions 	zmlen len 
met redistributions 	foo len 
source code 	free bar 
must retain copyright 	len 
notice list 	hello len 
conditions following disclaimer 	free world 
redistributions binary 	zmlen length 
form must reproduce 	holds current 
copyright notice 	size zipmap 
list conditions following 	zipmap 
disclaimer documentation 	length greater 
materials provided distribution 	equal used 
neither name 	zipmap needs 
eclipse foundation inc 	traversed find 
names contributors 	length len 
may used endorse 	length 
promote products 	following key 
derived software without 	len lengths 
specific prior 	encoded single 
written permission software 	bytes first 
provided copyright 	bit single 
holders contributors 	length 
express implied warranties 	four bytes 
including limited 	integer follows 
implied warranties merchantability 	host ordering 
fitness particular 	used signal 
purpose disclaimed shall 	end hash 
copyright owner 	free 
contributors liable direct 	number free 
indirect incidental 	unused bytes 
special exemplary consequential 	resulting modification 
damages including 	values associated 
limited procurement substitute 	key instance 
goods services 	foo 
loss use data 	bar later 
profits business 	foo free 
interruption however caused 	use enlarge 
theory liability 	later even 
whether contract strict 	order key 
liability tort 	pair 
including negligence 	fits free 
otherwise arising way 	always bit 
use software 	number update 
even advised possibility 	operation free 
damage occurrence 	bytes zipmap 
map line record 	reallocated 
chain ptr 	make sure 
identical another element 	small possible 
insert onto 	compact representation 
front existing element 	two elements 
chain cap 	hash actually 
rec cnt max 	foo 
cnt first 	bar hello 
time ever seen 	world xff 
particular element 	note keys 
sequence construct chain 	values prefixed 
early xdl 	length objects 
cha free lines 	lookup 
comes xprepare 	take number 
xdl prepare 	elements zipmap 
ctx xinclude.h lib 	number bytes 
diff davide 	needed represent 
libenzi file differential 	zipmap lowers 
library copyright 	constant 
davide libenzi library 	times considerably 
free software 	following defines 
redistribute modify terms 	max free 
gnu lesser 	field described 
general license published 	comments max 
free software 	number 
foundation either version 	trailing bytes 
license option 	following macro 
later version library 	returns number 
distributed hope 	bytes needed 
useful without warranty 	encode length 
without even 	integer 
implied warranty 	lengths zipmap 
merchantability fitness particular 	biglen bytes 
purpose see 	lengths create 
gnu lesser general 	empty zipmap 
license details 	length decode 
received copy gnu 	encoded 
lesser general 	length pointed 
license along library 	encode length 
write free 	writing returns 
software foundation inc 	amount bytes 
temple place 	required encode 
suite boston usa 	length 
davide libenzi 	search matching 
davidel xmailserver defined 	key returning 
xinclude xmacros.h 	pointer entry 
lib diff davide 	inside zipmap 
libenzi file 	returns key 
differential library copyright 	found 
davide libenzi 	returned totlen 
library free 	entire size 
software redistribute modify 	zimap calling 
terms gnu 	function able 
lesser general license 	reallocate original 
published free 	zipmap 
software foundation either 	make room 
version license 	entries match 
option later version 	skip key 
library distributed 	user doesn 
hope useful without 	care total 
warranty without 	length 
even implied warranty 	zipmap skip 
merchantability fitness 	well skip 
particular purpose see 	free total 
gnu lesser 	amount used 
general license details 	key encoded 
received copy 	length 
gnu lesser general 	payload total 
license along 	amount used 
library write 	encoded length 
free software foundation 	single free 
inc temple 	count payload 
place suite boston 	points 
usa davide 	key function 
libenzi davidel xmailserver 	returns total 
defined xmacros 	amount bytes 
xmerge.c merge mode 	used store 
chg chg 	entry entry 
chg count next 	key 
line count 	associated trailing 
flags rec rec 	free space 
result use 	key creating 
orig count needs 	key already 
dest recs 	exist update 
size count needs 	update 
dest count 	key already 
needs dest file 	preset otherwise 
size needs 	key found 
name name 	enlarge increase 
name size style 	zipmap length 
dest marker 	insert 
size marker size 	key found 
marker size 	enough space 
marker size needs 	compute total 
name name 	length store 
ancestor name favor 	offset key 
dest style 	within 
marker size size 	current zipmap 
needs xpp 	resized move 
xscr ptr size 	tail backwards 
chg next 	pair fits 
simplify alnum result 	current position 
next begin 	number 
end xscr xscr 	bytes moved 
xmp result 	caused end 
changes xpp ancestor 	zipmap note 
name name 	original zmlen 
name chg 	used suitable 
chg chg level 	block 
style favor 	key entry 
ffo marker size 	written much 
size orig 	free space 
xmp result xscr 	move tail 
xscr status 	zipmap bytes 
xpp xdl malloc 	front 
free xdl 	shrink zipmap 
recmatch memcpy xdl 	want zipmaps 
recs copy 	space efficient 
xdl recs copy 	first move 
eol crlf 	tail empty 
eol crlf eol 	bytes 
crlf strlen 	front resize 
strlen strlen needed 	zipmap empty 
xdl recs 	bytes smaller 
copy memset 	write key 
memcpy xdl recs 	done key 
copy memset 	specified 
memcpy xdl orig 	key deleted 
copy memset 	pointed integer 
xdl recs copy 	key found 
memset memcpy 	found deleted 
fill conflict hunk 	decrease zipmap 
xdl recs 	length 
copy needed xdl 	call iterating 
recs copy 	elements via 
xdl recs copy 	zipmap next 
xdl recs 	function used 
copy xdl diff 	iterate zipmap 
xdl change 	elements 
compact xdl change 	first call 
compact xdl 	first argument 
build script xdl 	pointer zipmap 
free env 	next calls 
xdl free 	zipmap next 
env xdl malloc 	returns 
xdl free 	used first 
env xdl free 	argument example 
script xdl 	zipmap rewind 
free env xdl 	zipmap zipmap 
free script 	next key 
isalnum line contains 	klen 
alnum free 	vlen bytes 
lines contain alnum 	key klen 
xdl merge 	key bytes 
two conflicts xdl 	vlen search 
append merge 	key retrieve 
xdl cleanup merge 	pointer 
xdl append 	len associated 
merge xdl cleanup 	key found 
merge xdl 	function returns 
merge cmp lines 	otherwise key 
xdl append 	exists otherwise 
merge xdl 	returned 
cleanup merge xdl 	number entries 
append merge 	inside zipmap 
xdl cleanup merge 	store length 
xdl append 	small enough 
merge xdl cleanup 	raw 
merge xdl 	size bytes 
refine conflicts xdl 	zipmap serialize 
simplify non 	zipmap disk 
conflicts xdl cleanup 	everywhere needed 
merge xdl 	writing returned 
fill merge buffer 	amount 
xdl malloc 	bytes starting 
xdl cleanup merge 	zipmap pointer 
xdl fill 	zipmap.h key 
merge buffer xdl 	klen val 
cleanup merge 	vlen update 
xdl diff xdl 	key 
diff xdl 	klen deleted 
free env 	key klen 
xdl change compact 	vlen key 
xdl change 	klen vlen 
compact xdl build 	key klen 
script xdl 	argc 
free env xdl 	argv map 
change compact 	data structure 
xdl change compact 	optimized size 
xdl build 	see zipmap 
script xdl free 	info copyright 
script xdl 	salvatore 
free env xdl 	sanfilippo antirez 
free env 	gmail dot 
xdl malloc memcpy 	rights reserved 
xdl malloc 	redistribution use 
memcpy xdl merge 	source binary 
xdl free 	forms 
script xdl 	without modification 
free script xdl 	permitted provided 
free env 	following conditions 
xdl free env 	met redistributions 
lib diff 	source code 
davide libenzi file 	must 
differential library 	retain copyright 
copyright davide libenzi 	notice list 
johannes schindelin 	conditions following 
library free software 	disclaimer redistributions 
redistribute modify 	binary form 
terms gnu lesser 	must 
general license 	reproduce copyright 
published free software 	notice list 
foundation either 	conditions following 
version license option 	disclaimer documentation 
later version 	materials provided 
library distributed hope 	distribution 
useful without 	neither name 
warranty without 	redis names 
even implied warranty 	contributors may 
merchantability fitness 	used endorse 
particular purpose see 	promote products 
gnu lesser 	derived 
general license details 	software without 
received copy 	specific prior 
gnu lesser general 	written permission 
license along 	software provided 
library write free 	copyright holders 
software foundation 	contributors 
inc temple place 	express implied 
suite boston 	warranties including 
usa davide libenzi 	limited implied 
davidel xmailserver 	warranties merchantability 
conflict conflict take 	fitness particular 
first conflict 	purpose 
take second conflict 	disclaimed shall 
take point 	copyright owner 
respective postimages 	contributors liable 
chg side wants 	direct indirect 
change common 	incidental special 
ancestor overlap lines 	exemplary 
postimage side 	consequential damages 
appear merge result 	including limited 
region touched 	procurement substitute 
neither side point 	goods services 
preimage course 	loss use 
one preimage shared 	data 
common ancestor 	profits business 
conflicts returns line 	interruption however 
ends last 	caused theory 
line eol preceding 	liability whether 
line ends 	contract strict 
line ending cannot 	liability 
determined lines 	tort including 
last must end 	negligence otherwise 
cannot determine 	arising way 
eol style 	use software 
empty file last 	even advised 
line ends 	possibility 
line eol determine 	damage zmalloc.c 
eol second 	ptr used 
last line match 	memory zmalloc 
post images 	safe used 
preceding first lines 	memory mutex 
end line 	size 
style look pre 	size ptr 
image first 	size ptr 
line unless already 	ptr size 
settled still 	realptr oldsize 
undecided use conflicting 	newptr ptr 
part postimage 	realptr 
side shared preimage 	size ptr 
postimage side 	realptr oldsize 
conflicting part 	oom handler 
postimage side postimage 	page rss 
side sometimes 	buf filename 
changes quite identical 	count 
differ lines 	task info 
hard show lines 	info count 
conflicting handle 	rss field 
conflicts sense refining 	line bytes 
conflict one 	flen field 
side empty probably 	mib 
work outside 	size len 
git since simple 	mib size 
mmfile structure 	len free 
happens changes identical 	fflush abort 
function merges 	malloc zmalloc 
next marking everything 	oom 
hunks conflicting 	handler update 
less non conflicting 	zmalloc stat 
lines conflicts 	alloc zmalloc 
appears simpler 	size update 
takes less many 	zmalloc stat 
lines lines 	alloc 
moved conflicts level 	calloc zmalloc 
mark overlapping 	oom handler 
changes conflict level 	update zmalloc 
mark overlapping 	stat alloc 
changes conflict identical 	zmalloc size 
level analyze 	update 
non identical changes 	zmalloc stat 
minimal conflict 	alloc zmalloc 
level analyze non 	zmalloc size 
identical changes 	realloc zmalloc 
minimal conflict treat 	oom handler 
hunks containing 	update 
letter number conflicting 	zmalloc stat 
returns error 	free update 
conflicts number conflicts 	zmalloc stat 
diff output 	alloc zmalloc 
make sense 	size realloc 
anything aggressive xdl 	zmalloc 
merge eager 	oom handler 
conflict refine conflicts 	update zmalloc 
output xpatience.c 	stat free 
alloc hash line 	update zmalloc 
line next 	stat alloc 
previous matches file 	update 
file env 	zmalloc stat 
xpp line map 	free zmalloc 
pass records 	size free 
index file file 	update zmalloc 
xpp env 	stat free 
result line count 	free 
line count 	strlen zmalloc 
sequence longest entry 	memcpy update 
right middle 	zmalloc stat 
map sequence entry 	pthread mutex 
map line 	pthread mutex 
line record 	unlock 
record file file 	sysconf snprintf 
xpp env 	getpid open 
line count line 	read close 
count map 	close strchr 
first line count 	strchr strtoll 
line count 	task 
end next next 	pid current 
submap map 	task getpid 
line count line 	task info 
count xpp 	zmalloc used 
file file xpp 	memory zmalloc 
env line 	used 
count line count 	memory fopen 
map first 	strlen fgets 
result file file 	strncmp strchr 
xpp env 	strtol fclose 
xdl recmatch xdl 	zmalloc smap 
malloc memset 	bytes 
insert record 	field sysctl 
insert record xdl 	sysconf sysconf 
malloc binary 	sysctl zmalloc 
search xdl free 	total amount 
xdl free 	allocated memory 
xdl recmatch match 	aware 
match memset 	version malloc 
patience diff xdl 	copyright salvatore 
fall back 	sanfilippo antirez 
diff memset fill 	gmail dot 
hashmap xdl 	rights reserved 
free find longest 	redistribution 
common sequence 	use source 
walk common sequence 	binary forms 
fall back 	without modification 
classic diff xdl 	permitted provided 
free xdl 	following conditions 
prepare env 	met 
patience diff lib 	redistributions source 
diff davide 	code must 
libenzi file differential 	retain copyright 
library copyright 	notice list 
davide libenzi johannes 	conditions following 
schindelin library 	disclaimer 
free software redistribute 	redistributions binary 
modify terms 	form must 
gnu lesser general 	reproduce copyright 
license published 	notice list 
free software foundation 	conditions following 
either version 	disclaimer 
license option later 	documentation materials 
version library 	provided distribution 
distributed hope useful 	neither name 
without warranty 	redis names 
without even implied 	contributors may 
warranty merchantability 	used 
fitness particular 	endorse promote 
purpose see gnu 	products derived 
lesser general 	software without 
license details received 	specific prior 
copy gnu 	written permission 
lesser general license 	software 
along library 	provided copyright 
write free software 	holders contributors 
foundation inc 	express implied 
temple place suite 	warranties including 
boston usa 	limited implied 
davide libenzi davidel 	warranties 
xmailserver basic 	merchantability fitness 
idea patience diff 	particular purpose 
find lines 	disclaimed shall 
unique files intuitively 	copyright owner 
ones want 	contributors liable 
see common lines 	direct 
maximal ordered 	indirect incidental 
sequence line 	special exemplary 
pairs ordered means 	consequential damages 
order sequence 	including limited 
agrees order lines 	procurement substitute 
files naturally 	goods 
defines initial common 	services loss 
lines algorithm 	use data 
tries extend common 	profits business 
lines growing 	interruption however 
line ranges files 	caused theory 
identical lines 	liability 
common lines patience 	whether contract 
diff algorithm 	strict liability 
applied recursively unique 	tort including 
line pairs 	negligence otherwise 
found line ranges 	arising way 
handled well 	use 
known myers algorithm 	software even 
hash mapping 	advised possibility 
line hash 	damage function 
line numbers first 	provide access 
second file 	original libc 
unused entry first 	free 
line second 	useful instance 
etc line non 	free results 
unique line 	obtained backtrace 
unique either first 	symbols need 
second file 	define function 
next previous used 	including 
longest common 	zmalloc may 
sequence initially next 	shadow free 
reflects order 	implementation use 
file common records 	jemalloc another 
found argument 	non standard 
pass first file 	allocator 
second xdl 	explicitly malloc 
prepare env 	free etc 
precisely due xdl 	tcmalloc provide 
classify record 	zmalloc size 
member records aka 	systems function 
lines hash 	provided 
anymore linearized version 	malloc given 
words member 	store header 
guaranteed start second 	information first 
record etc 	bytes every 
multiply hope hashing 	allocation least 
unique enough 	allocations 
function called recursion 	padded underlying 
inter hunk 	allocator rss 
parts previously non 	information specific 
unique lines 	way warning 
become unique restricted 	function zmalloc 
smaller part 	rss 
files assumed env 	designed fast 
prepared xdl 	may called 
prepare know 	busy loops 
exactly large want 	redis tries 
hash map 	release memory 
first fill entries 	expiring 
first file 	swapping objects 
search matches second 	kind fast 
file find 	rss reporting 
longest sequence smaller 	usages use 
last element 	instead function 
meaning smaller line 	redis 
construct sequence 	estimate rss 
entries ordered line 	much faster 
construction two 	less precise 
entries equal index 	version function 
sequence sequence 	rss field 
length idea start 	proc 
list common 	pid stat 
unique lines sorted 	rss specific 
order file 	way system 
pairs longest 	memory usage 
sequence whose last 	estimated zmalloc 
element line 	fragmentation 
smaller determined efficiency 	appear always 
sequences kept 	fragmentation course 
list containing exactly 	fragmentation rss 
one item 	allocated bytes 
per sequence length 	sum specified 
sequence smallest 	field 
last element terms 	converted form 
line common 	bytes proc 
unique lines found 	self smaps 
iterate starting 	field must 
last element adjusting 	specified trailing 
next members 	apperas 
grow line ranges 	smaps output 
common lines 	example zmalloc 
recurse recursively find 	smap bytes 
longest common 	field rss 
sequence unique 	returns size 
lines none found 	physical 
ask xdl 	memory ram 
diff job function 	bytes looks 
assumes env 	ugly cleanest 
prepared xdl prepare 	way achive 
env trivial 	cross platform 
one side empty 	results 
matching lines 	cleaned http 
environment cleaned xdl 	nadeausoftware articles 
diff xprepare.c 	tip physical 
size flags pass 	memory size 
rhash hbits 	system note 
rec pass narec 	function 
xpp xdf 	released following 
xdf dis xdf 	attribution license 
xdf xdf 	http creativecommons 
xdf xdf 	licenses deed 
xdf size flags 	originally implemented 
pass rhash 	david 
hbits rec line 	robert nadeau 
rcrec rcrecs 	modified redis 
pass narec xpp 	matt stancliff 
xdf hbits 	note exists 
nrec hsize bsize 	order comply 
hav blk 	original 
cur top prev 	license osx 
crec recs 	net bsd 
rrecs rhash rchg 	open bsd 
rindex xdf 	bit failed 
xpp enl enl 	free bsd 
sample dis 	linux 
rdis rpdis rdis 	open bsd 
rpdis xdf 	solaris dragon 
xdf nreff mlim 	fly bsd 
recs rcrec 	free bsd 
dis dis 	net bsd 
dis xdf xdf 	open 
lim recs 	bsd osx 
recs xdf xdf 	free bsd 
xdl hashbits 	others bit 
xdl cha init 	failed sysctl 
xdl malloc 	sysconf variants 
xdl cha free 	unknown 
memset xdl 	zmalloc.h drop 
malloc xdl free 	replacement zmalloc 
xdl cha 	order use 
free xdl free 	libc malloc 
xdl free 	without wrappering 
xdl cha free 	zmalloc 
xdl hashlong 	total amount 
xdl recmatch xdl 	allocated memory 
cha alloc 	aware version 
xdl realloc xdl 	malloc copyright 
hashlong xdl 	salvatore sanfilippo 
cha init 	antirez 
xdl malloc xdf 	gmail dot 
diff alg 	rights reserved 
xdl hashbits xdl 	redistribution use 
malloc memset 	source binary 
xdl mmfile first 	forms without 
xdl hash 	modification 
record xdl realloc 	permitted provided 
xdl cha 	following conditions 
alloc xdf diff 	met redistributions 
alg xdl 	source code 
classify record xdl 	must retain 
malloc memset 	copyright 
xdl malloc xdl 	notice list 
malloc xdl 	conditions following 
free xdl free 	disclaimer redistributions 
xdl free 	binary form 
xdl free xdl 	must reproduce 
free xdl 	copyright 
cha free 	notice list 
xdl free xdl 	conditions following 
free xdl 	disclaimer documentation 
free xdl free 	materials provided 
xdl free 	distribution neither 
xdl cha free 	name 
memset xdf 	redis names 
diff alg xdl 	contributors may 
guess lines 	used endorse 
xdl guess lines 	promote products 
xdf diff 	derived software 
alg xdl init 	without 
classifier xdl 	specific prior 
prepare ctx xdl 	written permission 
free classifier 	software provided 
xdl prepare ctx 	copyright holders 
xdl free 	contributors express 
ctx xdl free 	implied 
classifier xdf 	warranties including 
diff alg 	limited implied 
xdf diff alg 	warranties merchantability 
xdl optimize 	fitness particular 
ctxs xdl free 	purpose disclaimed 
ctx xdl 	shall 
free ctx xdl 	copyright owner 
free classifier 	contributors liable 
xdl free ctx 	direct indirect 
xdl free 	incidental special 
ctx xdl malloc 	exemplary 
memset xdl 	consequential damages 
bogosqrt xdl bogosqrt 	including limited 
xdl clean 	procurement substitute 
mmatch xdl clean 	goods services 
mmatch xdl 	loss use 
free xdl trim 	data 
ends xdl 	profits business 
cleanup records 	interruption however 
lib diff davide 	caused theory 
libenzi file 	liability whether 
differential library copyright 	contract strict 
davide libenzi 	liability 
library free software 	tort including 
redistribute modify 	negligence otherwise 
terms gnu lesser 	arising way 
general license 	use software 
published free software 	even advised 
foundation either 	possibility 
version license option 	damage expansion 
later version 	needed stringification 
library distributed hope 	macro values 
useful without 	zmalloc size 
warranty without even 	size ptr 
implied warranty 	size 
merchantability fitness particular 	ptr oom 
purpose see 	handler rss 
gnu lesser 	field ptr 
general license details 	ptr drop 
received copy 	replacement zmalloc 
gnu lesser general 	order 
license along 	use libc 
library write free 	malloc without 
software foundation 	wrappering zmalloc 
inc temple place 	total amount 
suite boston 	allocated memory 
usa davide libenzi 	aware 
davidel xmailserver 	version malloc 
histogram diff afford 	copyright salvatore 
smaller sample 	sanfilippo antirez 
size thus poorer 	gmail dot 
estimate number 	rights reserved 
lines hash table 	redistribution 
rhash won 	use source 
filled grown number 	binary forms 
lines nrecs 	without modification 
updated correctly 	permitted provided 
anyway xdl prepare 	following conditions 
ctx limits 	met 
window examined similar 	redistributions source 
lines scan 	code must 
loops stops dis 	retain copyright 
line match 	notice list 
corner cases loop 	conditions following 
proceed way 	disclaimer 
extremities causing huge 	redistributions binary 
performance penalties 	form must 
big files scans 	reproduce copyright 
lines find 	notice list 
run lines either 	conditions following 
match dis 	disclaimer 
multiple matches dis 	documentation materials 
note always 	provided distribution 
call function dis 	neither name 
current line 	redis names 
already multimatch 	contributors may 
line run line 	used 
found multimatch 	endorse promote 
lines hence make 	products derived 
current line 	software without 
discarded want discard 	specific prior 
multimatch lines 	written permission 
appear middle runs 	software 
nomatch lines 	provided copyright 
dis run line 	holders contributors 
found multimatch 	express implied 
lines hence make 	warranties including 
current line 	limited implied 
discarded reduce problem 	warranties 
complexity discard 	merchantability fitness 
records matches file 	particular purpose 
also lines 	disclaimed shall 
multiple matches 	copyright owner 
might potentially discarded 	contributors liable 
happear run 	direct 
discardable early trim 	indirect incidental 
initial terminal 	special exemplary 
matching records xprepare.h 	consequential damages 
xpp lib 	including limited 
diff davide libenzi 	procurement substitute 
file differential 	goods 
library copyright davide 	services loss 
libenzi library 	use data 
free software redistribute 	profits business 
modify terms 	interruption however 
gnu lesser general 	caused theory 
license published 	liability 
free software foundation 	whether contract 
either version 	strict liability 
license option later 	tort including 
version library 	negligence otherwise 
distributed hope 	arising way 
useful without warranty 	use 
without even 	software even 
implied warranty merchantability 	advised possibility 
fitness particular 	damage expansion 
purpose see gnu 	needed stringification 
lesser general 	macro values 
license details received 	zmalloc 
copy gnu 	zmalloc.h drop 
lesser general license 	replacement zmalloc 
along library 	order use 
write free software 	libc malloc 
foundation inc 	without wrappering 
temple place suite 	zmalloc 
boston usa 	total amount 
davide libenzi davidel 	allocated memory 
xmailserver defined 	aware version 
xprepare xtypes.h lib 	malloc copyright 
diff davide 	salvatore sanfilippo 
libenzi file 	antirez 
differential library copyright 	gmail dot 
davide libenzi 	rights reserved 
library free software 	redistribution use 
redistribute modify 	source binary 
terms gnu lesser 	forms without 
general license 	modification 
published free software 	permitted provided 
foundation either 	following conditions 
version license option 	met redistributions 
later version 	source code 
library distributed hope 	must retain 
useful without 	copyright 
warranty without even 	notice list 
implied warranty 	conditions following 
merchantability fitness particular 	disclaimer redistributions 
purpose see 	binary form 
gnu lesser general 	must reproduce 
license details 	copyright 
received copy 	notice list 
gnu lesser general 	conditions following 
license along 	disclaimer documentation 
library write free 	materials provided 
software foundation 	distribution neither 
inc temple place 	name 
suite boston 	redis names 
usa davide libenzi 	contributors may 
davidel xmailserver 	used endorse 
defined xtypes xutils.c 	promote products 
rec size 	derived software 
pre psize ecb 	without 
mmf size 	specific prior 
mmf cha isize 	written permission 
icount cha 	software provided 
cur tmp cha 	copyright holders 
ancur data 	contributors express 
sample size 	implied 
tsize data cur 	warranties including 
top line 	limited implied 
size flags flags 	warranties merchantability 
data top 	fitness particular 
flags ptr ptr 	purpose disclaimed 
eol mask 	shall 
data top flags 	copyright owner 
hash mask 	contributors liable 
ptr end data 	direct indirect 
top flags 	incidental special 
ptr size bits 	exemplary consequential 
val ptr 	damages 
str buf func 	including limited 
funclen ecb 	procurement substitute 
buf diff env 	goods services 
xpp line 	loss use 
count line count 	data profits 
subfile subfile 	business 
env strlen 	interruption however 
outf xdl free 	caused theory 
xdl malloc 	liability whether 
xdl mmfile first 	contract strict 
memchr xdl 	liability tort 
mmfile size xdl 	including 
isspace memcmp 	negligence otherwise 
xdl isspace xdl 	arising way 
isspace xdl 	use software 
isspace xdl isspace 	even advised 
xdl isspace 	possibility damage 
xdl isspace xdl 	expansion 
isspace xdl 	needed stringification 
isspace xdl isspace 	macro values 
xdl isspace 	zmalloc size 
repeat xdl hash 	size ptr 
record whitespace 	size ptr 
zero zero count 	oom 
masked bytes 	handler rss 
xdl hash 	field ptr 
record whitespace memcpy 	ptr drop 
xdl num 	replacement zmalloc 
memcpy xdl num 	order use 
memcpy xdl 	libc 
num memcpy xdl 	malloc without 
num memcpy 	wrappering zmalloc 
memcpy outf xdl 	total amount 
diff memcpy 	allocated memory 
memcpy xdl free 	aware version 
env lib 	malloc 
diff davide libenzi 	copyright salvatore 
file differential 	sanfilippo antirez 
library copyright davide 	gmail dot 
libenzi library 	rights reserved 
free software redistribute 	redistribution use 
modify terms 	source 
gnu lesser general 	binary forms 
license published 	without modification 
free software 	permitted provided 
foundation either version 	following conditions 
license option 	met redistributions 
later version library 	source 
distributed hope 	code must 
useful without warranty 	retain copyright 
without even 	notice list 
implied warranty merchantability 	conditions following 
fitness particular 	disclaimer redistributions 
purpose see gnu 	binary 
lesser general 	form must 
license details received 	reproduce copyright 
copy gnu 	notice list 
lesser general license 	conditions following 
along library 	disclaimer documentation 
write free software 	materials 
foundation inc 	provided distribution 
temple place suite 	neither name 
boston usa 	redis names 
davide libenzi 	contributors may 
davidel xmailserver classical 	used endorse 
integer square 	promote 
root approximation shifts 	products derived 
matches everything 	software without 
matches turn matches 	specific prior 
everything matches 	written permission 
ignore space eol 	software provided 
flavor ignoring 	copyright 
needs different logic 	holders contributors 
skip whitespaces 	express implied 
sides compare skip 	warranties including 
matching spaces 	limited implied 
keep going running 	warranties merchantability 
one side 	fitness 
remaining side must 	particular purpose 
nothing whitespace 	disclaimed shall 
lines match 	copyright owner 
note ignore whitespace 	contributors liable 
eol may 	direct indirect 
loop still characters 	incidental 
remaining lines 	special exemplary 
already handled high 	consequential damages 
bit first 	including limited 
zero jan achrenius 	procurement substitute 
microoptimized version 	goods services 
simpler mask onebytes 	loss 
onebytes works 	use data 
bytemasks without mask 	profits business 
first mask 	interruption however 
like avoids warnings 	caused theory 
bit machines 	liability whether 
carl chatfield jan 	contract 
achrenius version 	strict liability 
bit ffff ffffff 	tort including 
fix bytes 	negligence otherwise 
word word 	arising way 
left end buffer 	use software 
may work 	even 
memory mapping grab 	advised possibility 
rest instead 	damage expansion 
blindly reading avoid 	needed stringification 
problems masking 	macro values 
use found word 	zmalloc zone.c 
make mask 	zone 
matches read mask 	zone introspect 
first high 	zone ptr 
bit advance past 	zone size 
last possibly 	zone num 
word xdl fast 	size zone 
hash xdl 	size 
fast hash probably 	zone ptr 
work outside 	zone ptr 
git since simple 	size zone 
mmfile structure 	alignment size 
note ideally 	zone ptr 
would reuse prepared 	size 
environment libxdiff 	zone zone 
yet allow diffing 	size zone 
ranges lines 	zone zone 
instead whole files 	ptr zone 
xutils.h rec 	size zone 
size pre psize 	num 
ecb cha 	size zone 
isize icount cha 	size ret 
cha sample 	zone ptr 
line size flags 	zone ptr 
flags data 	size zone 
top flags size 	alignment 
val func 	size ret 
funclen ecb diff 	zone ptr 
env xpp 	size zone 
line count line 	zone size 
count lib 	zone zone 
diff davide 	zone 
libenzi file differential 	purgeable zone 
library copyright 	ivsalloc malloc 
davide libenzi library 	calloc posix 
free software 	memalign ivsalloc 
redistribute modify terms 	free free 
gnu lesser 	ivsalloc 
general license published 	realloc realloc 
free software 	posix memalign 
foundation either version 	ivsalloc ivsalloc 
license option 	free free 
later version library 	reached jemalloc 
distributed hope 	prefork 
useful without warranty 	jemalloc postfork 
without even 	parent malloc 
implied warranty merchantability 	zone strcmp 
fitness particular 	malloc purgeable 
purpose see 	zone malloc 
gnu lesser general 	zone 
license details 	malloc zone 
received copy gnu 	malloc zone 
lesser general 	malloc zone 
license along library 	unregister malloc 
write free 	zone malloc 
software foundation inc 	zone 
temple place 	unregister malloc 
suite boston usa 	zone malloc 
davide libenzi 	purgeable zone 
davidel xmailserver defined 	function available 
xutils zlib.c 	need check 
status len bytes 	whether 
consumed bytes 	present runtime 
produced strm status 	thus weak 
strm window 	data function 
bits status strm 	prototypes non 
status strm 	functions functions 
flush status 	appear 
strm size strm 	places within 
level status 	darwin setenv 
strm level window 	cause calls 
bits status 	function pointers 
strm level strm 	zone owns 
level strm 	knew 
status strm status 	pointers owned 
strm status 	zone could 
strm flush status 	split zone 
zlib buf 	two parts 
cap zlib buf 	use one 
cap die 	allocator 
die zlib pre 	deallocator reallocator 
call inflate 	since work 
init zlib post 	practice must 
call die 	check pointers 
zerr zlib pre 	assure reside 
call inflate 	within 
init zlib 	mapped chunk 
post call die 	determining size 
zerr zlib 	assignment avoids 
pre call inflate 	useless compiler 
end zlib 	warning assignment 
post call error 	avoids 
zerr zlib 	useless compiler 
pre call inflate 	warning function 
die zlib 	never called 
post call error 	something replaced 
zerr deflate 	system zone 
bound memset zlib 	allocator 
pre call 	jemalloc purgeable 
deflate init zlib 	zone created 
post call 	lazily osx 
die zerr memset 	libc uses 
zlib pre 	zone created 
call deflate init 	small 
zlib post 	allocations assumes 
call die 	zone scalable 
zerr git deflate 	zone obviously 
init git 	fails zone 
deflate init zlib 	jemalloc zone 
pre call 	malloc 
deflate end zlib 	purgeable zone 
post call 	called beforehand 
git deflate abort 	purgeable zone 
error zerr 	created zone 
zlib pre call 	still scalable 
deflate end 	zone 
zlib post call 	purgeable zones 
zlib pre 	exist need 
call deflate die 	check existence 
zlib post 	malloc purgeable 
call error zerr 	zone run 
zlib wrappers 	time 
make sure 	custom zone 
silently miss errors 	point won 
init time 	unregister reregister 
avail avail zlib 	zone osx 
counted typically 	unregistering takes 
limits size buffer 	last 
use interacting 	registered zone 
zlib single call 	places location 
inflate deflate 	specified zone 
define zlib buf 	unregistering zone 
max use 	thus makes 
bits accept gzip 	last 
data error 	registered one 
fed zlib format 	osx unregistering 
never say 	shifts registered 
finish unless feeding 	zones first 
everything zlib 	registered zone 
work another round 	becomes 
still make 	osx purgeable 
progress buf 	zone appear 
error normal needs 	zone makes 
space output 	things crash 
buffer use bits 	thinks owns 
generate gzip 	zone 
header trailer instead 	allocated pointers 
zlib wrapper 	thus unregister 
use bits negate 	order ensure 
raw compressed 	always zone 
data without zlib 	osx purgeable 
header trailer 	zone 
never say finish 	nothing osx 
unless feeding 	unregistering replaces 
everything zlib work 	purgeable zone 
another round 	last registered 
still make progress 	zone zone 
buf error 	registering 
normal needs space 	puts end 
output buffer 	obviously zone 
